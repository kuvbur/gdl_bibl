unID=1EPS = 0.0001!!---------------------------start https://gdl.graphisoft.com/gdl_other_docs/get-the-basic-properties-and-geometry -------------COMPTYPE_CORE = 0COMPTYPE_FINISH = 1COMPTYPE_OTHER = 2if GLOB_SCRIPT_TYPE = 2 or GLOB_SCRIPT_TYPE = 3 then	! --- Get the number of components and their types ---	_nComponents = 0	dim _componentTypes[]	n = REQUEST ("Profile_components", myProfileIdx, _nComponents, _componentTypes)	if n then		dim _bShowPart[]		_needRequestDetails = 0		! --- Check the current partial structure display settings and the component types ---		! ---- is there any part to be drawn by the script?		! ---- GLOB_STRUCTURE_DISPLAY: 0 – entire structure, 1 – core only, 2 – without finishes		for _i = 1 to _nComponents			_bShowPart[_i] = 1    			  if GLOB_STRUCTURE_DISPLAY = 1 AND _componentTypes[_i] <> COMPTYPE_CORE then _bShowPart[_i] = 0			  if GLOB_STRUCTURE_DISPLAY = 2 AND _componentTypes[_i] = COMPTYPE_FINISH then _bShowPart[_i] = 0			  if _bShowPart[_i] then _needRequestDetails = 1		next _i		if _needRequestDetails then			! --- Get the profile components geometry ---			dim _profileGeometryRawData[]			n = REQUEST ("Profile_default_geometry", myProfileIdx, _profileGeometryRawData)	 			! --- calculate indices to split up the original data into components ---			dim _idxStartPoints[]			dim _idxEndPoints[]			_idxStartPoints[1] = _nComponents + 1			_numPropertybyNodes = 5			for _i = 2 to _nComponents				_numCompNodes = _profileGeometryRawData[_i - 1]				_idxStartPoints[_i] = _idxStartPoints[_i - 1] + _numCompNodes * _numPropertybyNodes				_idxEndPoints[_i-1] = _idxStartPoints[_i] - 1			next _i			_idxEndPoints[_nComponents] = vardim1(_profileGeometryRawData)		endif	endifendif!!---------------------------end https://gdl.graphisoft.com/gdl_other_docs/get-the-basic-properties-and-geometry -------------!!! Собственно изменение размеров!!! Будем искать по типу линии ребро, которое будем удлинять!!! Затем подменим координаты в profileGeometryRawData для использования в 2д и 3д скриптахif _nComponents<EPS then goto "m_end"for _iComp = 1 to _nComponents	if _bShowPart[_iComp] then		dim _currLineTypes[]		n = REQUEST{4} ("Profile_component_info", myProfileIdx, _iComp, "gs_profile_comp_linetypes", _currLineTypes)		!!! Ищем линию, назначенную перемещаемому ребру		_penLtIdx = 1		for _i = _idxStartPoints[_iComp] to _idxEndPoints[_iComp] step 5			if _currLineTypes[_penLtIdx] = stretch_line then				!! Нашли) Теперь получим индекс следующей точки (Кноца грани)				_i_end = _i+5				if vardim1(_profileGeometryRawData)<(_i+6) then					_i_end = _idxStartPoints[_iComp]				else					_i_end = _i+5				endif				!! Теперь можем выбирать - или отредактировать всю линию, или только одну точку				hotspot2 _profileGeometryRawData[_i], _profileGeometryRawData[_i + 1]				hotspot2 _profileGeometryRawData[_i_end], _profileGeometryRawData[_i_end + 1]				!! ------------ Пример для ребра - перемещение по XY ----------------------------				!! Стартовая точка - центр грани				xs = (_profileGeometryRawData[_i] + _profileGeometryRawData[_i_end]) / 2				ys = (_profileGeometryRawData[_i+1] + _profileGeometryRawData[_i_end+1]) / 2				HOTSPOT2 xs+stretch_edge_x, ys, unID, stretch_edge_y, 1+128: unID=unID+1				HOTSPOT2 xs+stretch_edge_x, ys+stretch_edge_y, unID, stretch_edge_y, 2: unID=unID+1				HOTSPOT2 xs+stretch_edge_x, ys-1, unID, stretch_edge_y, 3: unID=unID+1							HOTSPOT2 xs, ys+stretch_edge_y, unID, stretch_edge_x, 1+128: unID=unID+1				HOTSPOT2 xs+stretch_edge_x, ys+stretch_edge_y, unID, stretch_edge_x, 2: unID=unID+1				HOTSPOT2 xs-1, ys+stretch_edge_y, unID, stretch_edge_x, 3: unID=unID+1				!! Прибавим смещение stretch_edge_x и stretch_edge_y к координатам ребра				_profileGeometryRawData[_i] = _profileGeometryRawData[_i] + stretch_edge_x				_profileGeometryRawData[_i_end] = _profileGeometryRawData[_i_end] + stretch_edge_x				_profileGeometryRawData[_i+1] = _profileGeometryRawData[_i+1] + stretch_edge_y				_profileGeometryRawData[_i_end+1] = _profileGeometryRawData[_i_end+1] + stretch_edge_y			endif			_penLtIdx = _penLtIdx + 1		next _i	endifnext _iComp"m_end":