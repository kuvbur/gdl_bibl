!------------------------
! Reinforcement
! 2012, Eptar Kft.
!------------------------
eps=0.0001
bstirrup=0
boffsetdebug=0
iron_type_rebar=1
iron_type_stirrup=2
iron_type_mesh=3
iron_type_concrete=90
type_rebar_normal=1
type_rebar_polygon=99
type_stirrup_normal=1
type_stirrup_type_2=2
type_stirrup_type_3=3
type_stirrup_type_4=4
type_stirrup_type_5=5
type_stirrup_type_6=6
type_stirrup_type_7=7
type_stirrup_type_8=8
type_stirrup_type_9=9
type_stirrup_type_10=10
type_stirrup_circle=90
type_stirrup_polygon=99
type_mesh_normal=50
type_conc_rectangle=1
type_conc_round=2
type_conc_polygon=99
view_top=1
view_side=2
view_section=3
_iirontype=irontype[ironidx][1]
_ironsubtype=irontype[ironidx][2]
_ndata=irontype[ironidx][3]
_ndatanum=irontype[ironidx][4]
_startdata=2
if buseirondata then
_d=irondata[ironidx][1]
_ironlength=ironextradata[ironidx][6]
_bendradius=ironextradata[ironidx][7]
_jointlength=ironextradata[ironidx][8]
_fiberlength=ironextradata[ironidx][9]
benablehsedit=0
else
_d=d
_bendradius=bendradius
_jointlength=jointlength
_fiberlength=fiberlength
endif
if _iirontype=iron_type_rebar then
_nstirrup=1
_stirrupdist=0
_bclosedpolygon=0
if _ironsubtype=type_rebar_normal then
if buseirondata then
_fulllength=ironextradata[ironidx][1]
_iendtype1=round_int(irondata[ironidx][_startdata])
_iendtype2=round_int(irondata[ironidx][_startdata+1])
_offset1=irondata[ironidx][_startdata+2]
_offset2=irondata[ironidx][_startdata+3]
_endlength1=irondata[ironidx][_startdata+4]
_endlength2=irondata[ironidx][_startdata+5]
_endheight1=irondata[ironidx][_startdata+6]
_endheight2=irondata[ironidx][_startdata+7]
_turnbacklength1=irondata[ironidx][_startdata+8]
_turnbacklength2=irondata[ironidx][_startdata+9]
else
_fulllength=fulllength
_iendtype1=iendtype1
_iendtype2=iendtype2
_offset1=offset1
_offset2=offset2
_endlength1=endlength1
_endlength2=endlength2
_endheight1=endheight1
_endheight2=endheight2
_turnbacklength1=turnbacklength1
_turnbacklength2=turnbacklength2
endif
endif
if _ironsubtype=type_rebar_polygon then
dim __ironpointcoords[][3]
dim __ironprevcoords[][3]
dim __ironarcpoints[]
dim __ironnewpoint[][2]
if buseirondata then
_nelem=0
for i=1 to _ndatanum
__ironpointcoords[i][1]=irondata[ironidx][_startdata+_nelem*4]
__ironpointcoords[i][2]=irondata[ironidx][_startdata+_nelem*4+1]
__ironpointcoords[i][3]=irondata[ironidx][_startdata+_nelem*4+2]
if i<_ndatanum then
__ironarcpoints[i]=irondata[ironidx][_startdata+_nelem*4+3]
endif
_nelem=_nelem+1
next i
__nironpoint=vardim1(__ironpointcoords)
else
__ironpointcoords=rebarpointcoords
__ironprevcoords=rebarprevcoords
__ironarcpoints=rebararcpoints
__ironnewpoint=rebarnewpoint
__nironpoint=min(nrebarpoint,vardim1(rebarpointcoords) )
endif
dim _sidelength[]
dim _halfpoints[][6]
dim _polygondir[]
dim _arcangle[]
dim _lineangle[]
dim _arccenter[][2]
dim _radiusdistance[]
dim _isarc[]
dim _signsize[]
gosub "calculateDirection"
gosub "arcPointsCalculation"
endif
endif
if _iirontype=iron_type_stirrup then
bstirrup=1
if buseirondata then
_nstirrup=round_int(ironextradata[ironidx][2])
_stirrupdist=ironextradata[ironidx][5]
else
_nstirrup=nstirrup
_stirrupdist=stirrupdist
endif
if _ironsubtype=type_stirrup_normal then
_bclosedpolygon=1
if buseirondata then
_hoopx=irondata[ironidx][_startdata]
_hoopy=irondata[ironidx][_startdata+1]
else
_hoopx=hoopx
_hoopy=hoopy
endif
_cxl=_bendradius
_cxr=_hoopx-_bendradius
_cyt=_hoopy-_bendradius
_cyb=_bendradius
_s45=sin(45)
endif
if _ironsubtype=type_stirrup_polygon then
dim __ironpointcoords[][3]
dim __ironprevcoords[][3]
dim __ironarcpoints[]
dim __ironnewpoint[][2]
if buseirondata then
_bclosedpolygon=irondata[ironidx][2]
_bstirrupback1=irondata[ironidx][3]
_bstirrupback2=irondata[ironidx][4]
_stirrupang1=irondata[ironidx][5]
_stirrupang2=irondata[ironidx][6]
_startdata=7
_nelem=0
for i=1 to _ndatanum
__ironpointcoords[i][1]=irondata[ironidx][_startdata+_nelem*4]
__ironpointcoords[i][2]=irondata[ironidx][_startdata+_nelem*4+1]
__ironpointcoords[i][3]=irondata[ironidx][_startdata+_nelem*4+2]
__ironarcpoints[i]=irondata[ironidx][_startdata+_nelem*4+3]
_nelem=_nelem+1
next i
__nironpoint=vardim1(__ironpointcoords)
else
_bclosedpolygon=bclosedpolygon
_bstirrupback1=bstirrupback1
_bstirrupback2=bstirrupback2
_stirrupang1=stirrupang1
_stirrupang2=stirrupang2
__ironpointcoords=stirruppointcoords
for i=vardim1(stirrupprevcoords) to 1 step-1
__ironprevcoords[i][1]=stirrupprevcoords[i][1]
__ironprevcoords[i][2]=stirrupprevcoords[i][2]
__ironprevcoords[i][3]=0
next i
__ironarcpoints=stirruparcpoints
__ironnewpoint=stirrupnewpoint
__nironpoint=min(nstirruppoint,vardim1(stirruppointcoords) )
endif
dim _sidelength[]
dim _halfpoints[][6]
dim _polygondir[]
dim _arcangle[]
dim _lineangle[]
dim _arccenter[][2]
dim _radiusdistance[]
dim _isarc[]
dim _signsize[]
gosub "calculateDirection"
gosub "arcPointsCalculation"
endif
endif
if _iirontype=iron_type_mesh then
if buseirondata then
_netx=irondata[ironidx][_startdata]
_nety=irondata[ironidx][_startdata+1]
else
_netx=netx
_nety=nety
endif
endif
goto "endMasterSript"
"calculateDirection":
pdirection=1
area=0
dim polygon1[][2]
tempnumpnts=__nironpoint+1
polygon1[__nironpoint+1][1]=__ironpointcoords[1][1]
polygon1[__nironpoint+1][2]=__ironpointcoords[1][2]
for i=__nironpoint to 1 step-1
polygon1[i][1]=__ironpointcoords[i][1]
polygon1[i][2]=__ironpointcoords[i][2]
next i
for areai=1 to tempnumpnts-1
area=area+(polygon1[areai+1][1]+polygon1[areai][1])*(polygon1[areai+1][2]-polygon1[areai][2])*0.5
next areai
area=area+(polygon1[1][1]+polygon1[tempnumpnts][1])*(polygon1[1][2]-polygon1[tempnumpnts][2])*0.5
if area<0 then pdirection=-1
return
"arcPointsCalculation":
_signl=0.075/2
_signoffset=0.05
for i=__nironpoint to 1 step-1
if i=__nironpoint then
tempsidex=__ironpointcoords[1][1]-__ironpointcoords[i][1]
tempsidey=__ironpointcoords[1][2]-__ironpointcoords[i][2]
else
tempsidex=__ironpointcoords[i+1][1]-__ironpointcoords[i][1]
tempsidey=__ironpointcoords[i+1][2]-__ironpointcoords[i][2]
endif
_sidelength[i]=sqr(tempsidex^2+tempsidey^2)
_signsize[i]=_signl
if _sidelength[i]/6<=_signsize[i]*2 then
_signsize[i]=(_sidelength[i]/12)*0.8
endif
if abs(_sidelength[i])>eps then
_arcangle[i]=atn(__ironarcpoints[i]/(_sidelength[i]/2) )*4
else
_arcangle[i]=0
endif
_polygondir[i]=1
if tempsidex<-eps then _polygondir[i]=-1
if abs(tempsidex)>eps then
arcalpha1=atn(tempsidey/tempsidex)-90*_polygondir[i]
arcalpha2=atn(tempsidey/tempsidex)+90*_polygondir[i]
_lineangle[i]=atn(tempsidey/tempsidex)
else
if i=__nironpoint then
tempendy=__ironpointcoords[1][2]
else
tempendy=__ironpointcoords[i+1][2]
endif
if __ironpointcoords[i][2]-tempendy>eps then
arcalpha1=180
arcalpha2=0
_lineangle[i]=270
else
arcalpha1=0
arcalpha2=180
_lineangle[i]=90
endif
endif
_halfpoints[i][1]=__ironpointcoords[i][1]+(tempsidex)/2
_halfpoints[i][2]=__ironpointcoords[i][2]+(tempsidey)/2
_halfpoints[i][3]=_halfpoints[i][1]+cos(arcalpha1)*__ironarcpoints[i]
_halfpoints[i][4]=_halfpoints[i][2]+sin(arcalpha1)*__ironarcpoints[i]
_halfpoints[i][5]=_halfpoints[i][1]+cos(arcalpha2)*1
_halfpoints[i][6]=_halfpoints[i][2]+sin(arcalpha2)*1
if abs(__ironarcpoints[i])>eps&abs(sin(_arcangle[i]/4) )>eps then
_isarc[i]=1
_radiusdistance[i]=sqr((_sidelength[i]/2) ^2+__ironarcpoints[i] ^2)/2/sin(_arcangle[i]/4)-__ironarcpoints[i]
_sidelength[i]=abs(((2*abs(__ironarcpoints[i]+_radiusdistance[i])*pi)/360)*_arcangle[i])
else
_isarc[i]=0
_radiusdistance[i]=0
endif
_arccenter[i][1]=_halfpoints[i][1]+cos(arcalpha2)*_radiusdistance[i]
_arccenter[i][2]=_halfpoints[i][2]+sin(arcalpha2)*_radiusdistance[i]
next i
return
"bendCalculation":
dim detpoints[][3]
dim detarcangle[]
dim detarccenter[][2]
dim detradiusdist[]
dim detisarc[]
if bdetailedarc then
np=1
if not(bstirrup)|not(_bstirrupback1) then
detpoints[np][1]=__ironpointcoords[1][1]
detpoints[np][2]=__ironpointcoords[1][2]
detpoints[np][3]=__ironpointcoords[1][3]
else
_dir=1-2*(_stirrupang1<0)
if _bclosedpolygon then
vx=__ironpointcoords[1][1]-__ironpointcoords[2][1]
vy=__ironpointcoords[1][2]-__ironpointcoords[2][2]
gosub "directionAngle"
sang1=angle
vx=__ironpointcoords[1][1]-__ironpointcoords[__nironpoint][1]
vy=__ironpointcoords[1][2]-__ironpointcoords[__nironpoint][2]
gosub "directionAngle"
sang2=angle
szogfelk=(sang1-sang2)/2
if pdirection=-1 then
szogfelk=180+szogfelk
endif
if szogfelk>90 then
szogfelk=szogfelk-180
endif
eidx=2
sidx=1
zz=_d
_stirrupang1=abs(szogfelk)
gosub "startKampo"
else
eidx=2
sidx=1
zz=0
gosub "startKampo"
endif
endif
for i=1 to __nironpoint-1-not(_bclosedpolygon)
if not(_isarc[i])&not(_isarc[i+1]) then
vx=__ironpointcoords[i+1][1]-__ironpointcoords[i][1]
vy=__ironpointcoords[i+1][2]-__ironpointcoords[i][2]
gosub "directionAngle"
ang1=angle
if i=__nironpoint-1 then
vx=__ironpointcoords[i+1][1]-__ironpointcoords[1][1]
vy=__ironpointcoords[i+1][2]-__ironpointcoords[1][2]
else
vx=__ironpointcoords[i+1][1]-__ironpointcoords[i+2][1]
vy=__ironpointcoords[i+1][2]-__ironpointcoords[i+2][2]
endif
gosub "directionAngle"
ang2=angle
szogfel=(ang1-ang2)/2
if abs(tan(szogfel) )>eps then
ivtav=_bendradius/tan(szogfel)
detpoints[np+1][1]=__ironpointcoords[i+1][1]+cos(ang1+180)*abs(ivtav)
detpoints[np+1][2]=__ironpointcoords[i+1][2]+sin(ang1+180)*abs(ivtav)
detpoints[np+1][3]=__ironpointcoords[i+1][3]
detarcangle[np]=0
detarccenter[np][1]=0
detarccenter[np][2]=0
detradiusdist[np]=0
detisarc[np]=0
np=np+1
detpoints[np+1][1]=__ironpointcoords[i+1][1]-cos(ang2)*abs(ivtav)
detpoints[np+1][2]=__ironpointcoords[i+1][2]-sin(ang2)*abs(ivtav)
detpoints[np+1][3]=__ironpointcoords[i+1][3]
x11=__ironpointcoords[i+1][1]
y11=__ironpointcoords[i+1][2]
x12=__ironpointcoords[i+1][1]+cos(szogfel+ang2)
y12=__ironpointcoords[i+1][2]+sin(szogfel+ang2)
x21=detpoints[np+1][1]
y21=detpoints[np+1][2]
x22=detpoints[np+1][1]+cos(ang2+90)
y22=detpoints[np+1][2]+sin(ang2+90)
gosub "intersection_Line_Line"
if state=1 then
vx=cx-detpoints[np][1]
vy=cy-detpoints[np][2]
gosub "directionAngle"
a1=angle
vx=cx-detpoints[np+1][1]
vy=cy-detpoints[np+1][2]
gosub "directionAngle"
a2=angle
if abs(a2-a1)>180 then
if a2-a1>180 then
arca=a2-a1-360
else
arca=360+a2-a1
endif
else
arca=a2-a1
endif
detarcangle[np]=arca
detarccenter[np][1]=cx
detarccenter[np][2]=cy
detradiusdist[np]=abs(_bendradius)
detisarc[np]=1
else
detarcangle[np]=0
detarccenter[np][1]=0
detarccenter[np][2]=0
detradiusdist[np]=0
detisarc[np]=0
endif
np=np+1
else
gosub "addPoint"
endif
else
gosub "addPoint"
endif
next i
if not(bstirrup)|not(_bstirrupback2) then
if _bclosedpolygon then
detpoints[np+1][1]=__ironpointcoords[1][1]
detpoints[np+1][2]=__ironpointcoords[1][2]
detpoints[np+1][3]=__ironpointcoords[__nironpoint][3]
detarcangle[np]=_arcangle[__nironpoint]
detarccenter[np][1]=_arccenter[__nironpoint][1]
detarccenter[np][2]=_arccenter[__nironpoint][2]
detradiusdist[np]=abs(__ironarcpoints[__nironpoint]+_radiusdistance[__nironpoint])
detisarc[np]=_isarc[__nironpoint]
np=np+1
else
detpoints[np+1][1]=__ironpointcoords[__nironpoint][1]
detpoints[np+1][2]=__ironpointcoords[__nironpoint][2]
detpoints[np+1][3]=__ironpointcoords[__nironpoint][3]
detarcangle[np]=_arcangle[__nironpoint-1]
detarccenter[np][1]=_arccenter[__nironpoint-1][1]
detarccenter[np][2]=_arccenter[__nironpoint-1][2]
detradiusdist[np]=abs(__ironarcpoints[__nironpoint-1]+_radiusdistance[__nironpoint-1])
detisarc[np]=_isarc[__nironpoint-1]
np=np+1
endif
else
_dir=1-2*(_stirrupang2<0)
if _bclosedpolygon then
eidx=1
sidx=__nironpoint
zz=0
_stirrupang2=abs(szogfelk)
gosub "endKampo"
else
eidx=__nironpoint
sidx=__nironpoint-1
zz=0
gosub "endKampo"
endif
endif
npoint=vardim1(detpoints)
else
npoint=__nironpoint
detpoints=__ironpointcoords
detarcangle=_arcangle
detarccenter=_arccenter
detisarc=_isarc
for i=vardim1(_radiusdistance) to 1 step-1
detradiusdist[i]=abs(__ironarcpoints[i]+_radiusdistance[i])
next i
if _bclosedpolygon then
detpoints[npoint+1][1]=detpoints[1][1]
detpoints[npoint+1][2]=detpoints[1][2]
detpoints[npoint+1][3]=detpoints[npoint][3]
endif
endif
return
"addPoint":
detpoints[np+1][1]=__ironpointcoords[i+1][1]
detpoints[np+1][2]=__ironpointcoords[i+1][2]
detpoints[np+1][3]=__ironpointcoords[i+1][3]
detarcangle[np]=_arcangle[i]
detarccenter[np][1]=_arccenter[i][1]
detarccenter[np][2]=_arccenter[i][2]
detradiusdist[np]=abs(__ironarcpoints[i]+_radiusdistance[i])
detisarc[np]=_isarc[i]
np=np+1
return
"startKampo":
vx=__ironpointcoords[eidx][1]-__ironpointcoords[sidx][1]
vy=__ironpointcoords[eidx][2]-__ironpointcoords[sidx][2]
gosub "directionAngle"
sang=angle
_kdir=1
if _bclosedpolygon&pdirection=-1 then _kdir=-1
_dir=_dir*_kdir
s1=cos(sang)*_bendradius+cos(sang+90*_dir)*_bendradius
s2=(sin(sang)*_bendradius+sin(sang+90*_dir)*_bendradius)
s3=s1+cos(sang+90*_dir+_stirrupang1*_kdir)*_bendradius
s4=s2+sin(sang+90*_dir+_stirrupang1*_kdir)*_bendradius
detpoints[np][1]=__ironpointcoords[sidx][1]+s3+cos(sang+_stirrupang1*_kdir)*_jointlength
detpoints[np][2]=__ironpointcoords[sidx][2]+s4+sin(sang+_stirrupang1*_kdir)*_jointlength
detpoints[np][3]=__ironpointcoords[sidx][3]
detpoints[np+1][1]=__ironpointcoords[sidx][1]+s3
detpoints[np+1][2]=__ironpointcoords[sidx][2]+s4
detpoints[np+1][3]=__ironpointcoords[sidx][3]
detarcangle[np]=0
detarccenter[np][1]=0
detarccenter[np][2]=0
detradiusdist[np]=0
detisarc[np]=0
np=np+1
if abs(180-_stirrupang1)>180 then
if 180-_stirrupang1>180 then
arca=180-_stirrupang1-360
else
arca=360+180-_stirrupang1
endif
else
arca=180-_stirrupang1
endif
detpoints[np+1][1]=__ironpointcoords[sidx][1]+cos(sang)*_bendradius
detpoints[np+1][2]=__ironpointcoords[sidx][2]+sin(sang)*_bendradius
detpoints[np+1][3]=__ironpointcoords[sidx][3]
detarcangle[np]=arca*_kdir
detarccenter[np][1]=__ironpointcoords[sidx][1]+s1
detarccenter[np][2]=__ironpointcoords[sidx][2]+s2
detradiusdist[np]=abs(_bendradius)
detisarc[np]=1
np=np+1
return
"endKampo":
vx=__ironpointcoords[eidx][1]-__ironpointcoords[sidx][1]
vy=__ironpointcoords[eidx][2]-__ironpointcoords[sidx][2]
gosub "directionAngle"
sang=angle
_kdir=1
if _bclosedpolygon&pdirection=-1 then _kdir=-1
_dir=_dir*_kdir
s1=-cos(sang)*_bendradius+cos(sang+90*_dir)*_bendradius
s2=-sin(sang)*_bendradius+sin(sang+90*_dir)*_bendradius
s3=s1+cos(sang+90*_dir-_stirrupang2*_kdir)*_bendradius
s4=s2+sin(sang+90*_dir-_stirrupang2*_kdir)*_bendradius
detpoints[np+1][1]=__ironpointcoords[eidx][1]-cos(sang)*_bendradius
detpoints[np+1][2]=__ironpointcoords[eidx][2]-sin(sang)*_bendradius
detpoints[np+1][3]=__ironpointcoords[eidx][3]
detarcangle[np]=_arcangle[sidx]
detarccenter[np][1]=_arccenter[sidx][1]
detarccenter[np][2]=_arccenter[sidx][2]
detradiusdist[np]=abs(__ironarcpoints[sidx]+_radiusdistance[sidx])
detisarc[np]=_isarc[sidx]
np=np+1
if abs(180-_stirrupang2)>180 then
if 180-_stirrupang2>180 then
arca=180-_stirrupang2-360
else
arca=360+180-_stirrupang2
endif
else
arca=180-_stirrupang2
endif
detpoints[np+1][1]=__ironpointcoords[eidx][1]+s3
detpoints[np+1][2]=__ironpointcoords[eidx][2]+s4
detpoints[np+1][3]=__ironpointcoords[eidx][3]
detarcangle[np]=arca*_kdir
detarccenter[np][1]=__ironpointcoords[eidx][1]+s1
detarccenter[np][2]=__ironpointcoords[eidx][2]+s2
detradiusdist[np]=abs(_bendradius)
detisarc[np]=1
np=np+1
detpoints[np+1][1]=__ironpointcoords[eidx][1]+s3-cos(sang-_stirrupang2*_kdir)*_jointlength
detpoints[np+1][2]=__ironpointcoords[eidx][2]+s4-sin(sang-_stirrupang2*_kdir)*_jointlength
detpoints[np+1][3]=__ironpointcoords[eidx][3]
detarcangle[np]=0
detarccenter[np][1]=0
detarccenter[np][2]=0
detradiusdist[np]=0
detisarc[np]=0
np=np+1
return
dim offsetedcoords[][]
"offcetCalculate":
offsetdist=-pdirection*rebardist
for i=__nironpoint-not(bclosedpolygon) to 1 step-1
actx1=__ironpointcoords[i][1]
acty1=__ironpointcoords[i][2]
if i=__nironpoint then
actx2=__ironpointcoords[1][1]
acty2=__ironpointcoords[1][2]
else
actx2=__ironpointcoords[i+1][1]
acty2=__ironpointcoords[i+1][2]
endif
if i=1 then
prevx1=__ironpointcoords[__nironpoint][1]
prevy1=__ironpointcoords[__nironpoint][2]
else
prevx1=__ironpointcoords[i-1][1]
prevy1=__ironpointcoords[i-1][2]
endif
prevx2=actx1
prevy2=acty1
actsidex=actx2-actx1
actsidey=acty2-acty1
prevsidex=prevx2-prevx1
prevsidey=prevy2-prevy1
actarccenterx=_arccenter[i][1]
actarccentery=_arccenter[i][2]
actarcdist=_radiusdistance[i]
actarcpoint=__ironarcpoints[i]
if i=1 then
prevarccenterx=_arccenter[__nironpoint][1]
prevarccentery=_arccenter[__nironpoint][2]
prevarcdist=_radiusdistance[__nironpoint]
prevarcpoint=__ironarcpoints[__nironpoint]
else
prevarccenterx=_arccenter[i-1][1]
prevarccentery=_arccenter[i-1][2]
prevarcdist=_radiusdistance[i-1]
prevarcpoint=__ironarcpoints[i-1]
endif
actdir=1
prevdir=1
if actsidex<-eps then actdir=-1
if prevsidex<-eps then prevdir=-1
if abs(actsidex)>eps then
actalpha=atn(actsidey/actsidex)-90
else
if acty1-acty2>eps then
actalpha=180
else
actalpha=0
endif
endif
if abs(prevsidex)>eps then
prevalpha=atn(prevsidey/prevsidex)-90
else
if prevy1-prevy2>eps then
prevalpha=180
else
prevalpha=0
endif
endif
actarcorline=(abs(actarcpoint)>eps)
prevarcorline=(abs(prevarcpoint)>eps)
if i=1&not(bclosedpolygon) then
if actarcorline=0 then
offsetedcoords[i][1]=actx1+actdir*cos(actalpha)*offsetdist
offsetedcoords[i][2]=acty1+actdir*sin(actalpha)*offsetdist
else
vx=actx1-actarccenterx
vy=acty1-actarccentery
gosub "directionAngle"
offsetedcoords[i][1]=actarccenterx+cos(angle)*(_radiusdistance[i]+__ironarcpoints[i]+offsetdist)
offsetedcoords[i][2]=actarccentery+sin(angle)*(_radiusdistance[i]+__ironarcpoints[i]+offsetdist)
endif
else
if actarcorline+prevarcorline=0 then
x11=actx1+actdir*cos(actalpha)*offsetdist
y11=acty1+actdir*sin(actalpha)*offsetdist
x12=actx2+actdir*cos(actalpha)*offsetdist
y12=acty2+actdir*sin(actalpha)*offsetdist
x21=prevx1+prevdir*cos(prevalpha)*offsetdist
y21=prevy1+prevdir*sin(prevalpha)*offsetdist
x22=prevx2+prevdir*cos(prevalpha)*offsetdist
y22=prevy2+prevdir*sin(prevalpha)*offsetdist
gosub "intersection_Line_Line"
if state then
offsetedcoords[i][1]=cx
offsetedcoords[i][2]=cy
else
offsetedcoords[i][1]=x11
offsetedcoords[i][2]=y11
endif
else
if actarcorline+prevarcorline=1 then
if actarcorline then
xo=actarccenterx
yo=actarccentery
ro=abs(actarcdist+actarcpoint+offsetdist)
x1=prevx1+prevdir*cos(prevalpha)*offsetdist
y1=prevy1+prevdir*sin(prevalpha)*offsetdist
x2=prevx2+prevdir*cos(prevalpha)*offsetdist
y2=prevy2+prevdir*sin(prevalpha)*offsetdist
lineisprev=1
gosub "intersection_Circle_Line"
gosub "selectGoodIntersection_Circle_Line":
else
xo=prevarccenterx
yo=prevarccentery
ro=abs(prevarcdist+prevarcpoint+offsetdist)
x1=actx1+actdir*cos(actalpha)*offsetdist
y1=acty1+actdir*sin(actalpha)*offsetdist
x2=actx2+actdir*cos(actalpha)*offsetdist
y2=acty2+actdir*sin(actalpha)*offsetdist
lineisprev=0
gosub "intersection_Circle_Line"
gosub "selectGoodIntersection_Circle_Line":
endif
else
x1=actarccenterx
y1=actarccentery
r1=abs(actarcdist+actarcpoint+offsetdist)
x2=prevarccenterx
y2=prevarccentery
r2=abs(prevarcdist+prevarcpoint+offsetdist)
gosub "intersection_Circle_Circle"
gosub "selectGoodIntersection_Circle_Circle"
endif
endif
endif
if i=__nironpoint-not(bclosedpolygon)&not(bclosedpolygon) then
if actarcorline=0 then
offsetedcoords[__nironpoint][1]=actx2+actdir*cos(actalpha)*offsetdist
offsetedcoords[__nironpoint][2]=acty2+actdir*sin(actalpha)*offsetdist
else
vx=actx2-actarccenterx
vy=acty2-actarccentery
gosub "directionAngle"
offsetedcoords[__nironpoint][1]=actarccenterx+cos(angle)*(_radiusdistance[i]+__ironarcpoints[i]+offsetdist)
offsetedcoords[__nironpoint][2]=actarccentery+sin(angle)*(_radiusdistance[i]+__ironarcpoints[i]+offsetdist)
endif
endif
next i
dim offsetarcangle[][3]
for i=__nironpoint-not(bclosedpolygon) to 1 step-1
if _isarc[i] then
actoffsetx=offsetedcoords[i][1]
actoffsety=offsetedcoords[i][2]
if i=__nironpoint then
nextoffsetx=offsetedcoords[1][1]
nextoffsety=offsetedcoords[1][2]
else
nextoffsetx=offsetedcoords[i+1][1]
nextoffsety=offsetedcoords[i+1][2]
endif
vx=actoffsetx-_arccenter[i][1]
vy=actoffsety-_arccenter[i][2]
gosub "directionAngle"
offsetarcangle[i][2]=angle
vx=nextoffsetx-_arccenter[i][1]
vy=nextoffsety-_arccenter[i][2]
gosub "directionAngle"
offsetarcangle[i][3]=angle
if __ironarcpoints[i]>eps then
offsetarcangle[i][1]=offsetarcangle[i][3]-offsetarcangle[i][2]
if offsetarcangle[i][1]<eps then
offsetarcangle[i][1]=360-offsetarcangle[i][2]+offsetarcangle[i][3]
endif
else
offsetarcangle[i][1]=-(offsetarcangle[i][2]+(360-offsetarcangle[i][3]) )
if offsetarcangle[i][1]<-360 then offsetarcangle[i][1]=offsetarcangle[i][1]+360
endif
if offsetarcangle[i][1]<0 then offsetarcangle[i][2]=offsetarcangle[i][2]-abs(offsetarcangle[i][1])
else
offsetarcangle[i][1]=0
offsetarcangle[i][2]=0
offsetarcangle[i][3]=0
endif
next i
return
"intersection_Line_Line":
v1x=x11-x12
v2x=x21-x22
v1y=y11-y12
v2y=y21-y22
llidiv=v1x*v2y-v1y*v2x
temp1=x11*y12-y11*x12
temp2=x21*y22-y21*x22
if abs(llidiv)>eps then
tempx=temp1*v2x-v1x*temp2
tempy=temp1*v2y-v1y*temp2
state=1
cx=(tempx/llidiv)
cy=(tempy/llidiv)
else
cx=0
cy=0
if abs(abs(temp1)-abs(temp2) )<eps then
state=-1
else
state=0
endif
endif
return
"intersection_Circle_Line":
tempx1=x1-xo:tempy1=y1-yo
tempx2=x2-xo:tempy2=y2-yo
if abs(tempx2-tempx1)<eps then
if abs(ro-abs(tempx1) )<eps then
state=1
xa=tempx1
ya=0
xb=tempx1
yb=0
else
if abs(ro)-abs(tempx1)<0 then
state=0:xa=0:ya=0:xb=0:yb=0
else
state=2
xa=tempx1
ya=sqr(ro^2-tempx1^2)
xb=tempx1
yb=-sqr(ro^2-tempx1^2)
endif
endif
else
kf=(tempy2-tempy1)/(tempx2-tempx1)
ad=1+kf^2
bd=2*tempy1*kf-2*tempx1*kf^2
cd=tempy1^2-2*tempx1*tempy1*kf+tempx1^2*kf^2-ro^2
if bd^2-4*ad*cd<0 then
state=0:xa=0:ya=0:xb=0:yb=0
else
xa=(-bd+sqr(bd^2-4*ad*cd) )/(2*ad)
ya=tempy1+(xa-tempx1)*kf
xb=(-bd-sqr(bd^2-4*ad*cd) )/(2*ad)
yb=tempy1+(xb-tempx1)*kf
if abs(xa-xb)<eps then state=1 else state=2
endif
endif
if state=2 then
da=sqr((tempx1-xa) ^2+(tempy1-ya) ^2)
db=sqr((tempx1-xb) ^2+(tempy1-yb) ^2)
if db<da then
xxo=xa:yyo=ya
xa=xb:ya=yb
xb=xxo:yb=yyo
endif
endif
xa=xa+xo:ya=ya+yo
xb=xb+xo:yb=yb+yo
return
"selectGoodIntersection_Circle_Line":
if state then
if state=2 then
intsectiondistancea=sqr((actx1-xa)**2+(acty1-ya)**2)
intsectiondistanceb=sqr((actx1-xb)**2+(acty1-yb)**2)
if intsectiondistanceb>intsectiondistancea then
offsetedcoords[i][1]=xa
offsetedcoords[i][2]=ya
else
offsetedcoords[i][1]=xb
offsetedcoords[i][2]=yb
endif
else
offsetedcoords[i][1]=xa
offsetedcoords[i][2]=ya
endif
else
if lineisprev then
offsetedcoords[i][1]=x2
offsetedcoords[i][2]=y2
else
offsetedcoords[i][1]=x1
offsetedcoords[i][2]=y1
endif
endif
return
"intersection_Circle_Circle":
vx=x2-x1
vy=y2-y1
gosub "directionAngle"
d=sqr((vx) ^2+(vy) ^2)
if d>(r1+r2)|abs(d)<eps then
state=0
return
endif
if abs(d-(r1+r2) )<eps then
state=1
xa=x1+((x2-x1)*r1)/(r1+r2)
ya=y1+((y2-y1)*r1)/(r1+r2)
xb=xa
yb=ya
return
endif
x=(d^2-r2^2+r1^2)/(2*d)
y=sqr(abs(4*d^2*r1^2-(d^2-r2^2+r1^2) ^2) )/(d*2)
xa=x1+y*sin(-angle)+x*cos(-angle)
ya=y1+y*cos(-angle)-x*sin(-angle)
xb=x1-y*sin(-angle)+x*cos(-angle)
yb=y1-y*cos(-angle)-x*sin(-angle)
state=2
return
"selectGoodIntersection_Circle_Circle":
if state then
if state=2 then
intsectiondistancea=sqr((actx1-xa)**2+(acty1-ya)**2)
intsectiondistanceb=sqr((actx1-xb)**2+(acty1-yb)**2)
if intsectiondistanceb>intsectiondistancea then
offsetedcoords[i][1]=xa
offsetedcoords[i][2]=ya
else
offsetedcoords[i][1]=xb
offsetedcoords[i][2]=yb
endif
else
offsetedcoords[i][1]=xa
offsetedcoords[i][2]=ya
endif
else
vx=actx1-actarccenterx
vy=acty1-actarccentery
gosub "directionAngle"
offsetedcoords[i][1]=actarccenterx+cos(angle)*r1
offsetedcoords[i][2]=actarccentery+sin(angle)*r1
endif
return
"calculatePolygonArea":
area=0
tempnumpnts=nsp/3
dim polygon1[][3]
for p=1to tempnumpnts
polygon1[p][1]=get(1)
polygon1[p][2]=get(1)
polygon1[p][3]=get(1)
next p
for areai=1 to tempnumpnts-1
area=area+(polygon1[areai+1][1]+polygon1[areai][1])*(polygon1[areai+1][2]-polygon1[areai][2])*0.5
next areai
area=area+(polygon1[1][1]+polygon1[tempnumpnts][1])*(polygon1[1][2]-polygon1[tempnumpnts][2])*0.5
return
"directionAngle":
if abs(vx)<eps&abs(vy)<eps then
angle=0
return
endif
if abs(vx)<eps then
if vy>0 then
angle=90
else
angle=270
endif
else
angle=atn(vy/vx)
if vx>=0 then
if angle<0 then
angle=angle+360
endif
else
angle=180+angle
endif
endif
return
"endMasterSript":
