gosub "set_3d"gosub "clear_buff_3d"if GLOB_PREVIEW_MODE<>0 or GLOB_FEEDBACK_MODE=1 or GLOB_VIEW_TYPE=3 then show_3d_hotspot_t = 0if not(is_call) then	hotspot 0,0,0	hotspot A,0,0	hotspot 0,B,0	hotspot A,B,0	hotspot 0,0,ZZYZX	hotspot A,0,ZZYZX	hotspot 0,B,ZZYZX	hotspot A,B,ZZYZXendifif show_type_3d=SHOW_GOST and (arm_array_1_dir>0 or arm_array_2_dir>0) then	if arm_array_1_dir>0 then add sx_1, sy_1, sz_1	if arm_array_2_dir>0 then add sx_2, sy_2, sz_2	add sx, sy, sz	put 0, 0, 0	put ex, ey, ez	put ex+ex_1+ex_2, ey+ey_1+ey_2, ez+ez_1+ez_2	put ex_1+ex_2, ey_1+ey_2, ez_1+ez_2	put 0, 0, 0	PLANE NSP/3, get(NSP)	endendifgroup "body"	gosub "set_form"	gosub "set_path"	mask = 1+2+32+16	add sx, sy, sz : n_trans = n_trans + 1	TUBE n_form, n_path, mask, USE(n_form*3+n_path*4)endgroupgroup_name_out = "body"gosub "clear_buff_3d"if arm_array_2_dir>0 then	group_name_out = "array_2"	group "array_2"		is_chet1 = 0		gosub "_array_2"	endgroup	if arm_array_1_dir_chess>EPS then		group "array_2_chess"			is_chet1 = 1			gosub "_array_2"		endgroup	endif	gosub "clear_buff_3d"	killgroup "body"endifif arm_array_1_dir>0 then	group_name = "body"	if arm_array_2_dir>0 then group_name = "array_2"	is_chet1 = 0 	group "array_1"		add sx_1, sy_1, sz_1 : n_trans = n_trans + 1		for i=1 to qty_1			is_chet1 = (i mod 2)<EPS			if arm_array_1_dir_chess>EPS and is_chet1 then				if arm_array_2_dir>0 then					placegroup "array_2_chess"				else					add arm_array_1_dir_chess*(ex>EPS), arm_array_1_dir_chess*(ey>EPS), arm_array_1_dir_chess*(ez>EPS)					placegroup group_name					add -arm_array_1_dir_chess*(ex>EPS), -arm_array_1_dir_chess*(ey>EPS), -arm_array_1_dir_chess*(ez>EPS)				endif			else				placegroup group_name			endif			if i=1 then 				add step_1_s*(dx_1>EPS), step_1_s*(dy_1>EPS), step_1_s*(dz_1>EPS)				n_trans = n_trans + 1			endif			if i=qty_1-1 then				add step_1_e*(dx_1>EPS), step_1_e*(dy_1>EPS), step_1_e*(dz_1>EPS)				n_trans = n_trans + 1			endif			if i<>1 and i<>qty_1-1 then				add dx_1, dy_1, dz_1				n_trans = n_trans + 1			endif		next i	endgroup	gosub "clear_buff_3d"	group_name_out = "array_1"	killgroup group_name	if arm_array_1_dir_chess>EPS and arm_array_2_dir>0 then killgroup "array_2_chess"endifplacegroup group_name_outkillgroup group_name_outend"set_3d":	show_subpos=1 : show_marker=1	call "Показ_по_сборкам" PARAMETERS ALL subpos=subpos, pos=arm_pos RETURNED_PARAMETERS show_subpos, show_marker	if not(show_subpos) then end		show_all_fon = 1	success = LIBRARYGLOBAL ("Libraryflobals-kzh", "show_all_fon", show_all_fon)	if not(show_all_fon) and arm_fon then end		show_all_plit = 1	success = LIBRARYGLOBAL ("Libraryflobals-kzh", "show_all_plit", show_all_plit)	if not(show_all_plit) and arm_plit then end		show_direction = 0	success = LIBRARYGLOBAL ("Libraryflobals-kzh", "show_direction", show_direction)	if show_direction<>arm_direction and show_direction then end		show_constr = 0	success = LIBRARYGLOBAL ("Libraryflobals-kzh", "show_constr", show_constr)	if show_constr<>arm_constr and show_constr then end		success = LIBRARYGLOBAL ("Libraryflobals-kzh", "arm_mat", arm_mat)	overr_area = 0	success = LIBRARYGLOBAL ("Libraryflobals-kzh", "overr_area", overr_area)	if overr_area then		area_lvl = 1		success = LIBRARYGLOBAL ("Libraryflobals-kzh", "area_lvl", area_lvl)		dim area_arr[]		success = LIBRARYGLOBAL ("Libraryflobals-kzh", "area_arr", area_arr)		dim area_mat[]		success = LIBRARYGLOBAL ("Libraryflobals-kzh", "area_mat", area_mat)		flag = 0		if arm_area<=area_arr[1] then flag = 1		if arm_area>=area_arr[area_lvl] then flag = area_lvl		if not(flag) then			for i=2 to area_lvl				if arm_area>area_arr[i-1] and arm_area<=area_arr[i] then					flag = i					i = area_lvl				endif			next i		endif		if flag then 			arm_mat = area_mat[flag]		else			arm_mat = area_mat[area_lvl]		endif	endif	building_material arm_mat	if overr_area then gs_cont_pen = gs_fill_pen	pen gs_cont_pen	sect_attrs{2} gs_cont_pen	success = LIBRARYGLOBAL ("Libraryflobals-kzh", "show_type_3d", show_type_3d)	res = 24	r_cam = 0	det_level_r1 = 6 : res_r1 = 24	det_level_r2 = 12 : res_r2 = 12	det_level_r3 = 24 : res_r3 = 6	det_level_r4 = 36 : res_r4 = 3	if GLOB_VIEW_TYPE = 3 then		r_cam=sqr((GLOB_EYEPOS_X-SYMB_POS_X)^2+(GLOB_EYEPOS_Y-SYMB_POS_Y)^2+(GLOB_EYEPOS_Z-SYMB_POS_Z)^2)		if r_cam<=det_level_r1 then res = res_r1		if r_cam<=det_level_r2 and r_cam>det_level_r1  then res = res_r2		if r_cam<=det_level_r3 and r_cam>det_level_r2 then 			res = res_r3			show_type_3d = SHOW_LINE			show_3d_hotspot_t = 0		endif		if r_cam>det_level_r4 then			res = res_r4			show_type_3d = SHOW_LINE			show_3d_hotspot_t = 0		endif	endif	if show_type_3d = SHOW_LINE then res = res_r4	RESOL resreturn"set_form":	n_form = 0	tstart = NSP	put 0,0,900+15	if show_type_3d = SHOW_LINE then 		put 0.5/1000,360,4000+15	else		put arm_diam/2,360,4000+15	endif	tend = NSP	n_form = (tend - tstart)/3return"set_path":	n_path = 0	tstart = NSP	if arm_type_pod=ARM_KZ then		gosub "linear"	endif		if arm_type_pod=ARM_FROG then		gosub "frog"	endif		if arm_type_pod=ARM_KSHP then		endif	if arm_type_pod=ARM_KPR then		endif	tend = NSP	n_path = (tend - tstart)/4return"linear":	PUT -1*(abs(ex)>EPS), -1*(abs(ey)>EPS), -1*(abs(ez)>EPS), 0	PUT 0, 0, 0, 0	PUT ex, ey, ez, 0	PUT ex+(abs(ex)>EPS), ey+(abs(ey)>EPS), ez+(abs(ez)>EPS), 0return"frog":	for inx=1 to vardim1(tmp_coord)		PUT tmp_coord[inx][1],tmp_coord[inx][2],tmp_coord[inx][3], tmp_coord[inx][4]	next inxreturn"clear_buff_3d":	if NSP>0 then tt = min(get(NSP))	if n_trans>1 then		n_trans = 0	endifreturn"hotspot_3d":	if show_3d_hotspot_t then		add sx, sy, sz		hotspot 0, 0, 0, unID_arm : unID_arm = unID_arm + 1		hotspot ex, ey, ez, unID_arm : unID_arm = unID_arm + 1		hotspot 0, arm_r*(ey<EPS), arm_r*(ez<EPS), unID_arm : unID_arm = unID_arm + 1		hotspot arm_r*(ex<EPS), 0, arm_r*(ez<EPS), unID_arm : unID_arm = unID_arm + 1		hotspot arm_r*(ex<EPS), arm_r*(ey<EPS), 0, unID_arm : unID_arm = unID_arm + 1		hotspot 0, -arm_r*(ey<EPS), -arm_r*(ez<EPS), unID_arm : unID_arm = unID_arm + 1		hotspot -arm_r*(ex<EPS), 0, -arm_r*(ez<EPS), unID_arm : unID_arm = unID_arm + 1		hotspot -arm_r*(ex<EPS), -arm_r*(ey<EPS), 0, unID_arm : unID_arm = unID_arm + 1		hotspot ex, arm_r*(ey<EPS), arm_r*(ez<EPS), unID_arm : unID_arm = unID_arm + 1		hotspot arm_r*(ex<EPS), ey, arm_r*(ez<EPS), unID_arm : unID_arm = unID_arm + 1		hotspot arm_r*(ex<EPS), arm_r*(ey<EPS), ez, unID_arm : unID_arm = unID_arm + 1		hotspot ex, -arm_r*(ey<EPS), -arm_r*(ez<EPS), unID_arm : unID_arm = unID_arm + 1		hotspot -arm_r*(ex<EPS), ey, -arm_r*(ez<EPS), unID_arm : unID_arm = unID_arm + 1		hotspot -arm_r*(ex<EPS), -arm_r*(ey<EPS), ez, unID_arm : unID_arm = unID_arm + 1		del 1	endifreturn"_array_2":	if is_chet1 then 		add arm_array_1_dir_chess*(dx_2>EPS), arm_array_1_dir_chess*(dy_2>EPS), arm_array_1_dir_chess*(dz_2>EPS)		qty_2_t = qty_2 - 1	else		qty_2_t = qty_2	endif	add sx_2, sy_2, sz_2 : n_trans = n_trans + 1	is_chet2 = 0	for i=1 to qty_2_t		show_3d_hotspot_t = 0		is_chet2 = (i mod 2)<EPS		if arm_array_2_dir_chess>EPS then			if i=2 then show_3d_hotspot_t = show_3d_hotspot			if is_chet2 and (i=qty_2-1 or i=qty_2) then show_3d_hotspot_t = show_3d_hotspot		endif		if i=1 then show_3d_hotspot_t = show_3d_hotspot		if i=qty_2_t then show_3d_hotspot_t = show_3d_hotspot		if i=2 and abs(step_2_s-dx_2-dy_2)>EPS then show_3d_hotspot_t = show_3d_hotspot		if i=qty_2_t-1 and abs(step_2_e-dx_2-dy_2)>EPS then show_3d_hotspot_t = show_3d_hotspot		if is_chet2 and arm_array_2_dir_chess>EPS then add arm_array_2_dir_chess*(ex>EPS), arm_array_2_dir_chess*(ey>EPS), arm_array_2_dir_chess*(ez>EPS)!		gosub "hotspot_3d"		placegroup "body"		if is_chet2 and arm_array_2_dir_chess>EPS then add -arm_array_2_dir_chess*(ex>EPS), -arm_array_2_dir_chess*(ey>EPS), -arm_array_2_dir_chess*(ez>EPS) 		if i=1 then 			add step_2_s*(dx_2>EPS), step_2_s*(dy_2>EPS), step_2_s*(dz_2>EPS)			n_trans = n_trans + 1		endif		if i=qty_2_t-1 then			add step_2_e*(dx_2>EPS), step_2_e*(dy_2>EPS), step_2_e*(dz_2>EPS)			n_trans = n_trans + 1		endif		if i<>1 and i<>qty_2_t-1 then			add dx_2, dy_2, dz_2			n_trans = n_trans + 1		endif	next i	if is_chet1 then add -arm_array_1_dir_chess*(dx_2>EPS), -arm_array_1_dir_chess*(dy_2>EPS), -arm_array_1_dir_chess*(dz_2>EPS)return