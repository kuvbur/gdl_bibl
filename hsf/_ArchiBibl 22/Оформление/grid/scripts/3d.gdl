text2 0,0,"Test"if AC_ShowIn3D=0 or GLOB_CONTEXT=7 then enddocumentType = ""rrr = APPLICATION_QUERY ("Document_Feature", "view_direction", documentType)if documentType <> "free" and GLOB_CONTEXT = 4 then endpen AC_LinePenmaterial AC_GridLineMatMarker_Diameter = GLOB_SCALE/1000*AC_MarkerSizemarker1Cx = 0marker1Cy = 0marker2Cx = 0marker2Cy = 0if cstype_3d_i = i_Rectangle then	res_3d=4else	res_3d=8endif! ================== normalized vectors tangent to the endsve1x = 0.0ve1y = 0.0ve2x = 0.0ve2y = 0.0if AC_MarkerType_i = i_hexagon then	if GLOB_CONTEXT=5 then rot2 10endifif AC_MarkerType_i = i_pentagon then	if GLOB_CONTEXT=5 then rot2 90endifif AC_Type_i = i_Line then	AC_HalfLength = AC_Length/2	AC_SecHalf = AC_HalfLength - AC_Staggering - abs(AC_StaggerDist)	addx AC_HalfLength	ve1x = -1	ve1y = 0	ve2x = 1	ve2y = 0	stag_dist  =  AC_HalfLength - AC_SecHalf - AC_Staggering - abs(AC_StaggerDist)	AC_StartX = -AC_SecHalf	AC_StartY = 0	AC_EndX = AC_SecHalf	AC_EndY = 0endifif AC_Type_i = i_Arc then	angle1 = 0	angle2 = angle1 + AC_Angle	AC_StartX = AC_Radius*cos(angle1)	AC_StartY = AC_Radius*sin(angle1)	AC_EndX = AC_Radius*cos(angle2)	AC_EndY = AC_Radius*sin(angle2)	AC_MidX = AC_Radius*cos((angle1+angle2)/2)	AC_MidY = sin((angle1+angle2)/2)*AC_Radius	ve1x = cos(angle1)	ve1y = sin(angle1)	veT = ve1x	ve1x = ve1y	ve1y = -veT	AC_EndX = AC_Radius*cos(angle2)	AC_EndY = sin(angle2)*AC_Radius	ve2x = cos(angle2)	ve2y = sin(angle2)	veT = ve2x	ve2x = -ve2y	ve2y = veT	stag_dist  =  AC_Extension - AC_Staggering - abs(AC_StaggerDist)endif! ================== coordinates of polyline!! p4p4x=AC_StartXp4y=AC_StartY! p3p3x=p4x + ve1x * stag_distp3y=p4y + ve1y * stag_dist! p2p2x=p3x + ( ve1y * AC_StaggerDist) + (ve1x * abs(AC_StaggerDist))p2y=p3y + (-ve1x * AC_StaggerDist) + (ve1y * abs(AC_StaggerDist))! p1p1x=p2x + (ve1x * AC_Staggering)p1y=p2y + (ve1y * AC_Staggering)! p0p0x=p1x + (ve1x * Marker_Diameter/2)p0y=p1y + (ve1y * Marker_Diameter/2)! p5p5x=AC_EndXp5y=AC_EndY! p6p6x=p5x + ve2x * stag_distp6y=p5y + ve2y * stag_dist! p7p7x=p6x + (-ve2y * AC_StaggerDist) + (ve2x * abs(AC_StaggerDist))p7y=p6y + ( ve2x * AC_StaggerDist) + (ve2y * abs(AC_StaggerDist))! p8p8x=p7x + (ve2x * AC_Staggering)p8y=p7y + (ve2y * AC_Staggering)! p9p9x=p8x + (ve2x * Marker_Diameter/2)p9y=p8y + (ve2y * Marker_Diameter/2)if AC_Type_i = i_Arc then	if AC_MarkerStart=0 then		p2x=p3x		p1x=p3x		p1y=p2y		p0x=p3x	endif	if AC_MarkerEnd=0 then		p7x=p6x + ve2x*AC_StaggerDist		p7y=p6y + ve2y*AC_StaggerDist		p8x=p7x		p8y=p7y		p9x=p7x + ve2x*AC_Staggering		p9y=p7y + ve2y*AC_Staggering	endifelse	if AC_MarkerStart=0 then		p2y=p3y		p1y=p3y		p0y=p3y	endif	if AC_MarkerEnd=0 then		p7y=p6y		p8y=p6y		p9y=p6y	endifendiflineUnID=1000hotline p1x, p1y, 0, p2x, p2y, 0, lineUnID : lineUnID=lineUnID+1hotline  p2x, p2y, 0, p3x, p3y, 0, lineUnID : lineUnID=lineUnID+1if line_3d=0 then		! ********** NOT ONLY LINES IN 3D ***************!  ********** Cross-section points of polyline	alfa_t=360/res_3d	for i=1 to res_3d		PUT (line_diameter_3d/2)*cos(alfa_t*i), (line_diameter_3d/2)*sin(alfa_t*i), 1	next i	if AC_Type_i = i_Line then		if AC_LineVisibility_i = i_Full then			tube (nsp)/3, 8, 0,				  GET (nsp),					p0x, p0y, 0, 0,					p1x, p1y, 0, 0,					p2x, p2y, 0, 0,					p3x, p3y, 0, 0,					p6x, p6y, 0, 0,					p7x, p7y, 0, 0,					p8x, p8y, 0, 0,					p9x, p9y, 0, 0			hotline p3x, p3y, 0, p6x, p6y, 0, lineUnID : lineUnID=lineUnID+1		endif		if AC_LineVisibility_i = i_Short then			tube (nsp)/3, 6, 0,				  USE (nsp),					p0x, p0y, 0, 0,					p1x, p1y, 0, 0,					p2x, p2y, 0, 0,					p3x, p3y, 0, 0,					-AC_SecHalf + AC_VisLength, 0, 0, 0,					 AC_SecHalf-AC_VisLength, 0, 0, 0			tube (nsp)/3, 6, 0,				  GET (nsp),					-AC_SecHalf + AC_VisLength, 0, 0, 0,					 AC_SecHalf-AC_VisLength, 0, 0, 0,					p6x, p6y, 0, 0,					p7x, p7y, 0, 0,					p8x, p8y, 0, 0,					p9x, p9y, 0, 0			hotline p3x, p3y, 0, -AC_SecHalf + AC_VisLength, 0, 0, lineUnID : lineUnID=lineUnID+1			hotline AC_SecHalf-AC_VisLength, 0, 0, p6x, p6y, 0, lineUnID : lineUnID=lineUnID+1		endif		if AC_LineVisibility_i = i_Hidden then			tube (nsp)/3, 5, 0,				  USE (nsp),					p0x, p0y, 0, 0,					p1x, p1y, 0, 0,					p2x, p2y, 0, 0,					p3x, p3y, 0, 0,					-AC_SecHalf + 1, 0, 0, 0			tube (nsp)/3, 5, 0,				  GET (nsp),					 AC_SecHalf - 1, 0, 0, 0,					p6x, p6y, 0, 0,					p7x, p7y, 0, 0,					p8x, p8y, 0, 0,					p9x, p9y, 0, 0			hotline p3x, p3y, 0, -AC_SecHalf + 1, 0, 0, lineUnID : lineUnID=lineUnID+1			hotline AC_SecHalf - 1, 0, 0, p6x, p6y, 0, lineUnID : lineUnID=lineUnID+1		endif	endif	if AC_Type_i = i_Arc then	! ========== 3D arc-points =========[		alfa_a=AC_Angle/res_arc_3D		for arcp=1 to res_arc_3D-1			PUT (AC_Radius)*cos(alfa_a*arcp), (AC_Radius)*sin(alfa_a*arcp), 0, 0		next arcp	! ]========= 3D arc-points ==========		if AC_LineVisibility_i = i_Short then			lenAlfa = (AC_VisLength * 180) / (AC_Radius * PI)			p44x=AC_Radius*cos(angle1+lenAlfa)			p44y=AC_Radius*sin(angle1+lenAlfa)			p55x=AC_Radius*cos(angle2-lenAlfa)			p55y=AC_Radius*sin(angle2-lenAlfa)			cutpolya 6, 2, 0,				0, 0, 15,				p44x, p44y, 15,				2*p44x, 2*p44y, 15,				0, 2*AC_Radius, 15,				2*p55x, 2*p55y, 15,				p55x, p55y, 15		endif		if AC_LineVisibility_i = i_Hidden then			cutpolya 6, 2, 0,				0, 0, 15,				p4x, p4y, 15,				2*p4x, 2*p4y, 15,				0, 2*AC_Radius, 15,				2*p5x, 2*p5y, 15,				p5x, p5y, 15		endif		tube res_3d, 10+res_arc_3D-1, 16,			   GET (res_3d*3),				p0x, p0y, 0, 0,				p1x, p1y, 0, 0,				p2x, p2y, 0, 0,				p3x, p3y, 0, 0,				p4x, p4y, 0, 0,				GET ((res_arc_3D-1)*4),				p5x, p5y, 0, 0,				p6x, p6y, 0, 0,				p7x, p7y, 0, 0,				p8x, p8y, 0, 0,				p9x, p9y, 0, 0		if AC_LineVisibility_i = i_Short then cutend		if AC_LineVisibility_i = i_Hidden then cutend		!!************		unID=100		hotspot 0, 0, 0, unID, AC_Radius, 1+128		unID=unID+1		hotspot 0, 0, 0, unID, AC_Radius, 3		unID=unID+1		hotspot AC_MidX , AC_MidY, 0, unID, AC_Radius, 2		unID=unID+1		!!************		hotspot AC_StartX, AC_StartY, 0, unID, AC_Angle, 4+256		unID=unID+1		hotspot 0, 0, 0, unID, AC_Angle, 6		unID=unID+1		hotspot AC_MidX , AC_MidY, 0, unID, AC_Angle, 7		unID=unID+1		hotspot AC_EndX , AC_EndY, 0, unID, AC_Angle, 5		unID=unID+1	endifendif								! NOT ONLY LINES IN 3D! ===========================================================! Cross-section points of polyline if line_3d is ON! ===========================================================if line_3d=1 then					! ONLY LINES IN 3D	if AC_Type_i = i_Line then		if AC_LineVisibility_i = i_Full then			lin_ p1x, p1y, 0, p2x, p2y, 0			lin_ p2x, p2y, 0, p3x, p3y, 0			lin_ p3x, p3y, 0, p6x, p6y, 0			hotline p3x, p3y, 0, p6x, p6y, 0, lineUnID : lineUnID=lineUnID+1			lin_ p6x, p6y, 0, p7x, p7y, 0			lin_ p7x, p7y, 0, p8x, p8y, 0		endif		if AC_LineVisibility_i = i_Short then			lin_ p1x, p1y, 0, p2x, p2y, 0			lin_ p2x, p2y, 0, p3x, p3y, 0			lin_ p3x, p3y, 0, -AC_SecHalf + AC_VisLength, 0, 0			hotline p3x, p3y, 0, -AC_SecHalf + AC_VisLength, 0, 0, lineUnID : lineUnID=lineUnID+1			lin_ AC_SecHalf-AC_VisLength, 0, 0, p6x, p6y, 0			hotline AC_SecHalf-AC_VisLength, 0, 0, p6x, p6y, 0, lineUnID : lineUnID=lineUnID+1			lin_ p6x, p6y, 0, p7x, p7y, 0			lin_ p7x, p7y, 0, p8x, p8y, 0		endif		if AC_LineVisibility_i = i_Hidden then			lin_ p1x, p1y, 0, p2x, p2y, 0			lin_ p2x, p2y, 0, p3x, p3y, 0			lin_ p6x, p6y, 0, p7x, p7y, 0			lin_ p7x, p7y, 0, p8x, p8y, 0		endif	endif	if AC_Type_i = i_Arc then		! ========== 3D arc-points =========[		alfa_a=AC_Angle/res_arc_3D		for arcp=1 to res_arc_3D			PUT (AC_Radius)*cos(alfa_a*(arcp-1)), (AC_Radius)*sin(alfa_a*(arcp-1)), 0			PUT (AC_Radius)*cos(alfa_a*arcp), (AC_Radius)*sin(alfa_a*arcp), 0		next arcp		! ]========= 3D arc-points ==========		if AC_LineVisibility_i = i_Short then			lenAlfa = (AC_VisLength * 180) / (AC_Radius * PI)			p44x=AC_Radius*cos(angle1+lenAlfa)			p44y=AC_Radius*sin(angle1+lenAlfa)			p55x=AC_Radius*cos(angle2-lenAlfa)			p55y=AC_Radius*sin(angle2-lenAlfa)			cutpolya 6, 2, 0,				0, 0, 15,				p44x, p44y, 15,				2*p44x, 2*p44y, 15,				0, 2*AC_Radius, 15,				2*p55x, 2*p55y, 15,				p55x, p55y, 15		endif		if AC_LineVisibility_i = i_Hidden then			cutpolya 6, 2, 0,				0, 0, 15,				p4x, p4y, 15,				2*p4x, 2*p4y, 15,				0, 2*AC_Radius, 15,				2*p5x, 2*p5y, 15,				p5x, p5y, 15		endif		lin_ p1x, p1y, 0, p2x, p2y, 0		lin_ p2x, p2y, 0, p3x, p3y, 0		lin_ p3x, p3y, 0, p4x, p4y, 0		hotline p3x, p3y, 0, p4x, p4y, 0, lineUnID : lineUnID=lineUnID+1		for arcp=1 to res_arc_3D			lin_ GET (6)		next arcp		lin_ p5x, p5y, 0, p6x, p6y, 0		hotline p5x, p5y, 0, p6x, p6y, 0, lineUnID : lineUnID=lineUnID+1		lin_ p6x, p6y, 0, p7x, p7y, 0		lin_ p7x, p7y, 0, p8x, p8y, 0		if AC_LineVisibility_i = i_Short then cutend		if AC_LineVisibility_i = i_Hidden then cutend		!!************		unID=100		hotspot 0, 0, 0, unID, AC_Radius, 1+128		unID=unID+1		hotspot 0, 0, 0, unID, AC_Radius, 3		unID=unID+1		hotspot AC_MidX , AC_MidY, 0, unID, AC_Radius, 2		unID=unID+1		!!************		hotspot AC_StartX, AC_StartY, 0, unID, AC_Angle, 4+256		unID=unID+1		hotspot 0, 0, 0, unID, AC_Angle, 6		unID=unID+1		hotspot AC_MidX , AC_MidY, 0, unID, AC_Angle, 7		unID=unID+1		hotspot AC_EndX , AC_EndY, 0, unID, AC_Angle, 5		unID=unID+1		!!************	endifendif									! ONLY LINES IN 3Dhotline p6x, p6y, 0, p7x, p7y, 0, lineUnID : lineUnID=lineUnID+1hotline p7x, p7y, 0, p8x, p8y, 0, lineUnID : lineUnID=lineUnID+1! ==========================================================! Hotspots! ==========================================================! ======== Staggering length hotspots ========[unID = 1hotspot p1x, p1y, 0, unID, AC_Staggering, 1+128unID=unID+1hotspot p1x, p1y, 0, unID, AC_Staggering, 3unID=unID+1hotspot p2x, p2y, 0, unID, AC_Staggering, 2unID=unID+1hotspot p8x, p8y, 0, unID, AC_Staggering, 1+128unID=unID+1hotspot p8x, p8y, 0, unID, AC_Staggering, 3unID=unID+1hotspot p7x, p7y, 0, unID, AC_Staggering, 2unID=unID+1! ]======= Staggering length hotspots =========! ======== Staggering distance hotspots =======[hotspot p3x+(ve1x * abs(AC_StaggerDist)), p3y+(ve1y * abs(AC_StaggerDist)), 0, unID, AC_StaggerDist, 1+128unID=unID+1hotspot p3x+(ve1x * abs(AC_StaggerDist)), p3y+(ve1y * abs(AC_StaggerDist)), 0, unID, AC_StaggerDist, 3unID=unID+1hotspot p2x, p2y, 0, unID, AC_StaggerDist, 2unID=unID+1hotspot p6x+(ve2x * abs(AC_StaggerDist)), p6y+(ve2y * abs(AC_StaggerDist)), 0, unID, AC_StaggerDist, 1+128unID=unID+1hotspot p6x+(ve2x * abs(AC_StaggerDist)), p6y+(ve2y * abs(AC_StaggerDist)), 0, unID, AC_StaggerDist, 3unID=unID+1hotspot p7x, p7y, 0, unID, AC_StaggerDist, 2unID=unID+1if AC_Type_i = i_Line then	hotspot p1x, p1y, 0, unID, AC_Length, 1+256	unID=unID+1	hotspot p8x, p8y, 0, unID, AC_Length, 2	unID=unID+1else	hotspot p1x-(ve1x*AC_Extension), p1y-(ve1y*AC_Extension), 0, unID, AC_Extension, 1+128	unID=unID+1	hotspot p1x-(ve1x*AC_Extension), p1y-(ve1y*AC_Extension), 0, unID, AC_Extension, 3	unID=unID+1	hotspot p1x, p1y, 0, unID, AC_Extension, 2	unID=unID+1	hotspot p8x-(ve2x*AC_Extension), p8y-(ve2y*AC_Extension), 0, unID, AC_Extension, 1+128	unID=unID+1	hotspot p8x-(ve2x*AC_Extension), p8y-(ve2y*AC_Extension), 0, unID, AC_Extension, 3	unID=unID+1	hotspot p8x, p8y, 0, unID, AC_Extension, 2	unID=unID+1endif! ]======= Staggering distance hotspots ========hotspot p3x+(ve1x * abs(AC_StaggerDist))+(ve1x * abs(AC_Staggering)),		p3y+(ve1y * abs(AC_StaggerDist))+(ve1y * abs(AC_Staggering)),		 0, unID, AC_StaggerDist, 1+128unID=unID+1hotspot p3x+(ve1x * abs(AC_StaggerDist))+(ve1x * abs(AC_Staggering)),		p3y+(ve1y * abs(AC_StaggerDist))+(ve1y * abs(AC_Staggering)),		 0, unID, AC_StaggerDist, 3unID=unID+1hotspot p1x, p1y, 0, unID, AC_StaggerDist, 2unID=unID+1hotspot p6x+(ve2x * abs(AC_StaggerDist))+(ve2x * abs(AC_Staggering)),		p6y+(ve2y * abs(AC_StaggerDist))+(ve2y * abs(AC_Staggering)),		 0, unID, AC_StaggerDist, 1+128unID=unID+1hotspot p6x+(ve2x * abs(AC_StaggerDist))+(ve2x * abs(AC_Staggering)),		p6y+(ve2y * abs(AC_StaggerDist))+(ve2y * abs(AC_Staggering)),		 0, unID, AC_StaggerDist, 3unID=unID+1hotspot p8x, p8y, 0, unID, AC_StaggerDist, 2unID=unID+1! ==============================================================================! MARKER STYLE! ==============================================================================DEFINE STYLE "markertext_style" AC_TextFont_1, AC_TextSize_1*GLOB_SCALE, 5, AC_TextStyle_1SET STYLE "markertext_style"pen AC_MarkerPenif line_3d=0 then											! NOT ONLY LINES IN 3D	if (AC_MarkerStart = 1) then		! =========== Cross-section points of polyline if line_3d is OFF ============[		alfa_t=360/res_3d		for i=1 to res_3d			PUT (line_diameter_3d/2)*cos(alfa_t*i), (line_diameter_3d/2)*sin(alfa_t*i), 1		next i		! ]========== Cross-section points of polyline if line_3d is OFF =============		ADD p0x , p0y, 0		! =========== Marker polyline-points ============[		alfa_m=360/res_mark		dy=Marker_Diameter/2-Marker_Diameter/2*cos(alfa_m/2)		for m=0 to res_mark+2			PUT (Marker_Diameter/2)*cos(alfa_m*m), (Marker_Diameter/2)*sin(alfa_m*m), 0, 0		next m		! ]========== Marker polyline-points =============		if AC_Type_i = i_Arc then rotz 90		if AC_MarkerRot=1 then			add dy, 0, 0			rotz alfa_m/2		endif		tube res_3d, res_mark+3, 16,			GET (NSP)		if AC_MarkerRot=1 then del 2		if AC_Type_i = i_Arc then del 1	!	hotspot 0 , 0 , 0		pen AC_TextPen_1		material AC_TextMat		addz -line_diameter_3d/2		if AC_MarkerRot=1 then add dy*sgn(AC_Type_i = i_Line), dy*sgn(AC_Type_i = i_Arc), 0		ROTz -SYMB_ROTANGLE * NOT(SYMB_MIRRORED)+SYMB_ROTANGLE * SYMB_MIRRORED		if AC_TextFollowsView then gosub 100		MULx 1-2*SYMB_MIRRORED		text line_diameter_3d, 0, AC_MarkerText_1		del 1		if AC_TextFollowsView then del 1		del 2		if AC_MarkerRot=1 then del 1		del 1	endif	material AC_GridLineMat	pen AC_MarkerPen	if (AC_MarkerEnd = 1) then		! ========= Cross-section points of polyline ========[		alfa_t=360/res_3d		for i=1 to res_3d			PUT (line_diameter_3d/2)*cos(alfa_t*i), (line_diameter_3d/2)*sin(alfa_t*i), 1		next i		! ]======== Cross-section points of polyline =========		ADD p9x , p9y, 0		! ========= Marker polyline-points =========[		alfa_m=360/res_mark		dy=Marker_Diameter/2-Marker_Diameter/2*cos(alfa_m/2)		for m=0 to res_mark+2			PUT (Marker_Diameter/2)*cos(alfa_m*m), (Marker_Diameter/2)*sin(alfa_m*m), 0, 0		next m		! ]======= Marker polyline-points ==========		if AC_Type_i = i_Arc then rotz AC_Angle+90		if AC_MarkerRot=1 then			add -dy, 0, 0			rotz alfa_m/2		endif		rotz 180		tube res_3d, res_mark+3, 16,			GET (NSP)		del 1		if AC_MarkerRot=1 then del 2		if AC_Type_i = i_Arc then del 1	!	hotspot 0 , 0 , 0		pen AC_TextPen_1		material AC_TextMat		addz -line_diameter_3d/2		if AC_MarkerRot=1 then add -dy*sgn(AC_Type_i = i_Line) +dy*sin(AC_Angle)*sgn(AC_Type_i = i_Arc), -dy*cos(AC_Angle)*sgn(AC_Type_i = i_Arc), 0		ROTz -SYMB_ROTANGLE * NOT(SYMB_MIRRORED)+SYMB_ROTANGLE * SYMB_MIRRORED		if AC_TextFollowsView then gosub 100		MULx 1-2*SYMB_MIRRORED		text line_diameter_3d, 0, AC_MarkerText_1		del 1		if AC_TextFollowsView then del 1		del 2		if AC_MarkerRot=1 then del 1		del 1	endifendif										! NOT ONLY LINES IN 3Dif line_3d=1 then							! ONLY LINES IN 3D	if (AC_MarkerStart = 1) then		ADD p0x , p0y, 0		! ========= Marker polyline-points =========[		alfa_m=360/res_mark		dy=Marker_Diameter/2-Marker_Diameter/2*cos(alfa_m/2)		for m=0 to res_mark+2			PUT (Marker_Diameter/2)*cos(alfa_m*m), (Marker_Diameter/2)*sin(alfa_m*m), 0			PUT (Marker_Diameter/2)*cos(alfa_m*(m+1)), (Marker_Diameter/2)*sin(alfa_m*(m+1)), 0		next m		! ]======= Marker polyline-points ==========		if AC_Type_i = i_Arc then rotz 90		if AC_MarkerRot=1 then			add dy, 0, 0			rotz alfa_m/2		endif		for m=0 to res_mark+2			lin_ GET (6)		next m		if AC_MarkerRot=1 then del 2		if AC_Type_i = i_Arc then del 1		pen AC_TextPen_1		material AC_TextMat		addz 0		if AC_MarkerRot=1 then add dy*sgn(AC_Type_i = i_Line), dy*sgn(AC_Type_i = i_Arc), 0		ROTz -SYMB_ROTANGLE * NOT(SYMB_MIRRORED)+SYMB_ROTANGLE * SYMB_MIRRORED		if AC_TextFollowsView then gosub 100		MULx 1-2*SYMB_MIRRORED		text 0.00001, 0, AC_MarkerText_1		del 1		if AC_TextFollowsView then del 1		del 2		if AC_MarkerRot=1 then del 1		del 1	endif	pen AC_MarkerPen	material AC_GridLineMat	if (AC_MarkerEnd = 1) then		ADD p9x , p9y, 0		! ========= Marker polyline-points =========[		alfa_m=360/res_mark		dy=Marker_Diameter/2-Marker_Diameter/2*cos(alfa_m/2)		for m=0 to res_mark+2			PUT (Marker_Diameter/2)*cos(alfa_m*m), (Marker_Diameter/2)*sin(alfa_m*m), 0			PUT (Marker_Diameter/2)*cos(alfa_m*(m+1)), (Marker_Diameter/2)*sin(alfa_m*(m+1)), 0		next m		! ]======== Marker polyline-points ==========		if AC_Type_i = i_Arc then rotz AC_Angle+90		if AC_MarkerRot=1 then			add -dy, 0, 0			rotz alfa_m/2		endif		rotz 180		for m=0 to res_mark+2			lin_ GET (6)		next m		del 1		if AC_MarkerRot=1 then del 2		if AC_Type_i = i_Arc then del 1		pen AC_TextPen_1		material AC_TextMat		addz 0		if AC_MarkerRot=1 then add -dy*sgn(AC_Type_i = i_Line) +dy*sin(AC_Angle)*sgn(AC_Type_i = i_Arc), -dy*cos(AC_Angle)*sgn(AC_Type_i = i_Arc), 0		ROTz -SYMB_ROTANGLE * NOT(SYMB_MIRRORED)+SYMB_ROTANGLE * SYMB_MIRRORED		if AC_TextFollowsView then gosub 100		MULx 1-2*SYMB_MIRRORED		text 0.00001, 0, AC_MarkerText_1		del 1		if AC_TextFollowsView then del 1		del 2		if AC_MarkerRot=1 then del 1		del 1	endifendif												! ONLY LINES IN 3DEND! ===================================================================! Subroutines! ===================================================================100:				! ROTATING 3D TEXTdx= GLOB_EYEPOS_X - GLOB_TARGPOS_Xdy= GLOB_EYEPOS_Y - GLOB_TARGPOS_YtextFollowsViewAng = 0if abs(GLOB_EYEPOS_X-GLOB_TARGPOS_X)<EPS then	if GLOB_EYEPOS_Y > GLOB_TARGPOS_Y then		textFollowsViewAng = textFollowsViewAng + 180	endifelse	alf=atn(abs(dy/dx))	if dx<0 and dy>0 then textFollowsViewAng = textFollowsViewAng + (180-alf)	if dx<0 and dy<0 then textFollowsViewAng = textFollowsViewAng + (180+alf)	if dx>0 and dy<0 then textFollowsViewAng = textFollowsViewAng + (-alf)	if dx>0 and dy>0 then textFollowsViewAng = textFollowsViewAng + (alf)	textFollowsViewAng = textFollowsViewAng + 90endifrotz textFollowsViewAng * NOT(SYMB_MIRRORED) - textFollowsViewAng * SYMB_MIRROREDreturn