! Contact person: <SzL>! ==============================================================================! This macro draws the turned plasters! ------------------------------------------------------------------------------! Input parameters:!	refWidth:				reference width in curved walls (length)!	leftWidth:				wallhole's side distance from the origin at the left side (length)!	rightWidth:				wallhole's side distance from the origin at the right side (length)!	bWndCurved:				is the window made of curved panels (0 / 1)!	bParalellInCurvedWalls:	is the wallhole parallel in curved walls (0 / 1)!	bDrawObjContourIn:!	bDrawObjContourOut:!	bDrawFrameContourLeft:	Draw the wall contour border on window frame at the left side (0 / 1)!	bDrawFrameContourRight:	Draw the wall contour border on window frame at the left side (0 / 1)!	bWindowSymbolAtMiddle:	Is the window symbol appears always on the middle of the wall (CHI special) (0 / 1)! Corner Window Parameters -----------------------------------------------------!	bCornerWindow:			is the hole a corner window? (0 / 1)! Reveal Parameters ------------------------------------------------------------!	iRevealType:			reveal type (integer)!								0 = no Reveal!								1 = Positive Reveal!								2 = Negative Reveal!								3 = Slanted Reveal!								4 =!	gs_reveal_left:			left reveal size (length)!	gs_reveal_right:		left reveal size (length)!	gs_reveal_left_angle:	left reveal angle in case of slanted reveal (angle)!	gs_reveal_right_angle:	right reveal angle in case of slanted reveal (angle)! Stacked Window Parameters ----------------------------------------------------!	gs_stack_left:			align to door/window on left side (0 / 1)!	gs_stack_right:			align to door/window on right side (0 / 1)! Cavity Closure Parameters ----------------------------------------------------!	gs_useWallFinishSkin:	use wall finish component (0 / 1)!	gs_maxPlasterThk:		wall skin classification parameter (length)!							consider Skin as Plaster if it is thinner this!	gs_bAutoTurnIn:			automatic plaster return at Outside Face (0 / 1)!	gs_bAutoTurnOut:		automatic plaster return at Inside Face (0 / 1)!	gs_bOverIn:				number of turned plaster skins at Outside Face (integer)!	gs_bOverOut:			number of turned plaster skins at Inside Face (integer)!	gs_bJoint:				is there an insulation strip at the front!							 side of the turned skins (0 / 1) [MODE1]!	gs_thkJoint:			strip thickness (length)!	gs_penJoint:			strip contour pen (pen)!	gs_ltJoint:				strip contour linetype (line type)!	gs_fillJoint:			strip fill type (fill)!	gs_penJointFg:			strip fill pen (pen)!	gs_penJointBg:			strip fill background pen (pen)!	gs_widthPlug:			heat insulation profile width (length) [MODE2]!	gs_penPlug:				profile contour pen (pen)!	gs_ltPlug:				profile contour linetype (line type)!	gs_fillPlug:			profile fill type (fill)!	gs_penPlugFg:			profile fill pen (pen)!	gs_penPlugBg:			profile fill background pen (pen)! ==============================================================================if WIDO_REVEAL_SIDE then	mul2 1,-1	add2 0,WIDO_FRAME_THICKNESSendifif wallIsLeft then mul2 1, -1yShift = -(wallIsLeft * WIDO_SILL) - (not(wallIsLeft) * (-WIDO_SILL+WALL_THICKNESS))add2 0, yShift! ==============================================================================! Calculations and reordering! ==============================================================================!!! Changing the order and directions (No 1 point is always on the Inside Face)dim RevealPnts[][]dim TempLeftRevealPnts[][]TempLeftRevealPnts = leftRevealPntsfor i = 1 to MaxNumPointsLeft	TempLeftRevealPnts[i][2] = leftRevealPnts[i][2]+WIDO_SILLnext ifor kk = 1 to MaxNumPointsLeft	if wallIsLeft then		leftRevealPnts[kk][1] = TempLeftRevealPnts[MaxNumPointsLeft-(kk-1)][1]		leftRevealPnts[kk][2] = TempLeftRevealPnts[MaxNumPointsLeft-(kk-1)][2]	else		leftRevealPnts[kk][1] = TempLeftRevealPnts[kk][1]		leftRevealPnts[kk][2] = WALL_THICKNESS-1*TempLeftRevealPnts[kk][2]	endifnext kkdim TempRightRevealPnts[][]TempRightRevealPnts = rightRevealPntsfor i = 1 to MaxNumPointsRight	TempRightRevealPnts[i][2] = rightRevealPnts[i][2]+WIDO_SILLnext ifor kk = 1 to MaxNumPointsRight	if wallIsLeft then		rightRevealPnts[kk][1] = TempRightRevealPnts[MaxNumPointsRight-(kk-1)][1]		rightRevealPnts[kk][2] = TempRightRevealPnts[MaxNumPointsRight-(kk-1)][2]	else		rightRevealPnts[kk][1] = TempRightRevealPnts[kk][1]		rightRevealPnts[kk][2] = WALL_THICKNESS-1*TempRightRevealPnts[kk][2]	endifnext kk!!! Angles of segments---------------------------------------------dim SegmentAngles[]dim TempLeftSegmentAngles[]dim LeftSegmentAngles[]for i = 1 to MaxNumPointsLeft-1	if abs(leftRevealPnts[i][1] - leftRevealPnts[i+1][1]) > EPS then		if abs(leftRevealPnts[i][2] - leftRevealPnts[i+1][2]) > EPS then			ActAng = atn( (leftRevealPnts[i+1][2] - leftRevealPnts[i][2]) / (leftRevealPnts[i+1][1] - leftRevealPnts[i][1]) )			if (leftRevealPnts[i+1][1] - leftRevealPnts[i][1]) > EPS then				LeftSegmentAngles[i] = 180 - ActAng			else				LeftSegmentAngles[i] =  360 - ActAng			endif		else			if (leftRevealPnts[i][1] - leftRevealPnts[i+1][1]) > EPS then				LeftSegmentAngles[i] = 0			else				LeftSegmentAngles[i] = 180			endif		endif	else		LeftSegmentAngles[i] = 270	endifnext idim TempRightSegmentAngles[]dim RightSegmentAngles[]for i = 1 to MaxNumPointsRight-1	if abs(rightRevealPnts[i][1] - rightRevealPnts[i+1][1]) > EPS then		if abs(rightRevealPnts[i][2] - rightRevealPnts[i+1][2]) > EPS then			ActAng = atn( (rightRevealPnts[i+1][2] - rightRevealPnts[i][2]) / (rightRevealPnts[i+1][1] - rightRevealPnts[i][1]) )			if (rightRevealPnts[i+1][1] - rightRevealPnts[i][1]) > EPS then				RightSegmentAngles[i] = 180 - ActAng			else				RightSegmentAngles[i] =  360 - ActAng			endif		else			if (rightRevealPnts[i][1] - rightRevealPnts[i+1][1]) > EPS then				RightSegmentAngles[i] = 0			else				RightSegmentAngles[i] = 180			endif		endif	else		RightSegmentAngles[i] = 270	endifnext i! ==============================================================================! Drawing Plasters! ==============================================================================if wallIsLeft then	bDrawPlasterRefSide = (abs(WIDO_SILL) > EPS)	bDrawPlasterOppSide = (abs(WIDO_SILL - (WALL_THICKNESS - WIDO_FRAME_THICKNESS)) > EPS)else	bDrawPlasterRefSide = (abs(WIDO_SILL - (WALL_THICKNESS - WIDO_FRAME_THICKNESS)) > EPS)	bDrawPlasterOppSide = (abs(WIDO_SILL) > EPS)endifif not(gs_stack_left) & not(bLeftCornerFunction) & bDrawPlasterOppSide then	RevealPnts		= leftRevealPnts	SegmentAngles	= LeftSegmentAngles	WallOppDir		= 0	sideSign		= 1	alpha			= leftAlfa	AddOppPoint		= AddOppPointLeft	NumPoints_Opp	= NumPointsLeft_Opp	gosub 1000endifif not(gs_stack_right) & not(bCornerWindow) & bDrawPlasterOppSide then	RevealPnts		= rightRevealPnts	SegmentAngles	= RightSegmentAngles	WallOppDir		= 180	sideSign		= -1	alpha			= rightAlfa	AddOppPoint		= AddOppPointRight	NumPoints_Opp	= NumPointsRight_Opp	gosub 1000endifif not(gs_stack_left) & not(bLeftCornerFunction) & bDrawPlasterRefSide then	RevealPnts		= leftRevealPnts	SegmentAngles	= LeftSegmentAngles	WallOppDir		= 0	sideSign		= 1	alpha			= 0	MaxNumPoints	= MaxNumPointsLeft	AddRefPoint		= AddRefPointLeft	NumPoints_Ref	= NumPointsLeft_Ref	gosub 2000endifif not(gs_stack_right) & not(bCornerWindow) & bDrawPlasterRefSide then	RevealPnts		= rightRevealPnts	SegmentAngles	= RightSegmentAngles	WallOppDir		= 180	sideSign		= -1	alpha			= 0	MaxNumPoints	= MaxNumPointsRight	AddRefPoint		= AddRefPointRight	NumPoints_Ref	= NumPointsRight_Ref	gosub 2000endifend! ==============================================================================! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end! ==============================================================================1000:! ==============================================================================! Turn Plaster - at Inside Face! ==============================================================================ActSummThk = 0if nSkinTurnOut then!!! Offset on the beginning -----------------------------------------------	OutSkinsOffset = 0	OutSkinsOffsetx = 0	OutSkinsOffsety = 0	for i= 1 to nSkinTurnOut		SkinIndex = WALL_SKINS_NUMBER - (i-1)		OutSkinsOffset = OutSkinsOffset + WALL_SKINS_PARAMS[SkinIndex][SKIN_THICKNESS]	next i	if curvedWall then		OutSkinOffsAtf = OutSkinsOffset / cos(SegmentAngles[1] - 270 - alpha)		OutSkinsOffsety = OutSkinOffsAtf * cos(SegmentAngles[1] - 270)		OutSkinsOffsetx = OutSkinOffsAtf * sin(SegmentAngles[1] - 270)	else		OutSkinOffsAtf = OutSkinsOffset / cos(SegmentAngles[1] - 270 - (InclWallyCorrSign * WALL_INCL) * not(reorder))		OutSkinsOffsety = OutSkinOffsAtf * cos(SegmentAngles[1] - 270)		OutSkinsOffsetx = OutSkinOffsAtf * sin(SegmentAngles[1] - 270)	endif!!! First (inner) skin inner points-----------------------------------------	dim ActSkinInnerPoints[][3]	for i = 1 to NumPoints_Opp + 1 + AddOppPoint		ActSkinInnerPoints[i][1] = RevealPnts[i][1]		ActSkinInnerPoints[i][2] = RevealPnts[i][2]		if vardim1(SegmentAngles) >= i then			ActSkinInnerPoints[i][3] = SegmentAngles[i]		else			ActSkinInnerPoints[i][3] = 0		endif	next i!!! First (inner) skin first point-----------------------------------------	if curvedWall then		x1 = RevealPnts[1][1]: y1 = RevealPnts[1][2]		x2 = RevealPnts[1][1] - 1 * cos(SegmentAngles[1]) : y2 = RevealPnts[1][2] + 1 * sin(SegmentAngles[1])		xo = 0		yo = RevSignCorr * WOD - yShift		ro = abs(yo) - WALL_THICKNESS + (rSillLine-(RevSignCorr * WOD)) + OutSkinsOffset		gosub 101	! Circle - Line intersection		gosub 102	! Select good intersection point		ActSkinInnerPoints[1][1] = cx		ActSkinInnerPoints[1][2] = cy	else		ActSkinInnerPoints[1][1] = RevealPnts[1][1] - OutSkinsOffsetx		ActSkinInnerPoints[1][2] = RevealPnts[1][2] - OutSkinsOffsety	endif	if abs(RevealPnts[1][2] - RevealPnts[2][2]) > EPS then		dirAngle = atn((RevealPnts[1][1] - RevealPnts[2][1]) / (RevealPnts[1][2] - RevealPnts[2][2]))	else		dirAngle = 0	endif	RevDepy = ActSkinInnerPoints[NumPoints_Opp][2]	BegX = RevealPnts[1][1]	bShowPrevSkin = 0	for i = 1 to nSkinTurnOut!!! Actual skin properties--------------------------------------------------		SkinIndex				= WALL_SKINS_NUMBER - nSkinTurnOut + (i)		ActSkinThk				= WALL_SKINS_PARAMS[SkinIndex][SKIN_THICKNESS]		ActSkinFill				= WALL_SKINS_PARAMS[SkinIndex][SKIN_FILL]		ActSkinFillPen			= WALL_SKINS_PARAMS[SkinIndex][SKIN_FILL_PEN]		ActSkinFillBkgPen		= WALL_SKINS_PARAMS[SkinIndex][SKIN_FILL_BACK_PEN]		bLocalFill				= round_int(WALL_SKINS_PARAMS[SkinIndex][SKIN_FILL_ORIENTATION])		bFitToSkinFill			= round_int(WALL_SKINS_PARAMS[SkinIndex][SKIN_FILL_FIT_TO_SKIN])		if reorder then			ActSkinUppLinePen	= WALL_SKINS_PARAMS[SkinIndex][SKIN_LOWER_LINE_PEN]			ActSkinUppLineType	= WALL_SKINS_PARAMS[SkinIndex][SKIN_LOWER_LINE_TYPE]		else			ActSkinUppLinePen	= WALL_SKINS_PARAMS[SkinIndex][SKIN_UPPER_LINE_PEN]			ActSkinUppLineType	= WALL_SKINS_PARAMS[SkinIndex][SKIN_UPPER_LINE_TYPE]		endif		ActFacePen				= WALL_SKINS_PARAMS[SkinIndex][SKIN_END_FACE_PEN]		ActSummThk				= ActSummThk + ActSkinThk		bShowSkin = (abs(ActSkinThk) > EPS) & (GLOB_STRUCTURE_DISPLAY = STRUCTURE_ENTIRE_STRUCTURE | (GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[SkinIndex][SKIN_FINISH_STATUS] - 1) > EPS))!!! Last outer point--------------------------------------------------------		if curvedWall then			x1 = RevealPnts[1][1]: y1 = RevealPnts[1][2]			x2 = RevealPnts[1][1] - 1 * cos(SegmentAngles[1]) : y2 = RevealPnts[1][2] + 1 * sin(SegmentAngles[1])			xo = 0			yo = RevSignCorr * WOD - yShift			ro = abs(yo) - WALL_THICKNESS + (rSillLine-(RevSignCorr * WOD)) + OutSkinsOffset - ActSummThk			gosub 101	! Circle - Line intersection			gosub 102	! Select good intersection point			OutLinePx1 = cx			OutLinePy1 = cy		else			OutLinePx1 = BegX			OutLinePy1 = ActSkinInnerPoints[1][2] + InclWallyCorrSign * TAN(WALL_INCL) * not(reorder) * (ActSkinInnerPoints[1][1] - BegX) +  ActSkinThk / cos(WALL_INCL)		endif		put OutLinePx1, OutLinePy1, 0!!! First inner point-------------------------------------------------------		if curvedWall then			x1 = RevealPnts[1][1]: y1 = RevealPnts[1][2]			x2 = RevealPnts[1][1] - 1 * cos(SegmentAngles[1]) : y2 = RevealPnts[1][2] + 1 * sin(SegmentAngles[1])			xo = 0			yo = RevSignCorr * WOD - yShift			ro = abs(yo) - WALL_THICKNESS + (rSillLine-(RevSignCorr * WOD)) + OutSkinsOffset - ActSummThk + ActSkinThk			gosub 101	! Circle - Line intersection			gosub 102	! Select good intersection point			InnLinePx1 = cx			InnLinePy1 = cy		else			InnLinePx1 = BegX			InnLinePy1 = ActSkinInnerPoints[1][2] + InclWallyCorrSign * TAN(WALL_INCL) * not(reorder) * (ActSkinInnerPoints[1][1] - BegX)		endif		if i > 1 then			put InnLinePx1, InnLinePy1, 0		endif!!!Plaster inner points-------------------------------------------------------		dim FinalSkinInnerPoints[][2]		idx = 1		NumPoints = NumPoints_Opp + AddOppPoint * (i > 1)		for ij = 1 to numPoints			px = ActSkinInnerPoints[ij][1]			py = ActSkinInnerPoints[ij][2]			if ij <= numPoints - 2 then				x11 = ActSkinInnerPoints[ij][1]				y11 = ActSkinInnerPoints[ij][2]				if ij = 1 then					x12 = InnLinePx1					y12 = InnLinePy1				else					x12 = ActSkinInnerPoints[ij - 1][1]					y12 = ActSkinInnerPoints[ij - 1][2]				endif				x21 = ActSkinInnerPoints[ij + 1][1]				y21 = ActSkinInnerPoints[ij + 1][2]				x22 = ActSkinInnerPoints[ij + 2][1]				y22 = ActSkinInnerPoints[ij + 2][2]				gosub 103	! Segment - Segment intersection				if state = 3 then	! Intersection point lies on both segments					px = cx					py = cy					ij = ij + 1		! Skip next point				endif			endif			FinalSkinInnerPoints[idx][1] = px			FinalSkinInnerPoints[idx][2] = py			idx = idx + 1			put px, py, 0			if ij = numPoints then				FacePointInnx = ActSkinInnerPoints[ij][1]				FacePointInny = ActSkinInnerPoints[ij][2]			endif		next ij		InnLinePx2 = FinalSkinInnerPoints[1][1]		InnLinePy2 = FinalSkinInnerPoints[1][2]		if FacePointInny >= InnLinePy1 then			bShowSkin = 0		endif!!!Plaster outer points - Offset ---------------------------------------------		dim ActSkinOuterPoints[][3]		numPoints = NumPoints_Opp + AddOppPoint		for ij = numPoints to 1 step -1			ActisArc = 0			PrevisArc = 0			ro = 0			if ij = 1 then				if curvedWall then					xo = 0					yo = RevSignCorr * WOD - yShift					ro = abs(yo) - WALL_THICKNESS + (rSillLine-(RevSignCorr * WOD)) + OutSkinsOffset - ActSummThk					PrevisArc = 1					originalSegmentAngle = 0				else					x11 = ActSkinInnerPoints[1][1]					y11 = ActSkinInnerPoints[1][2] + ActSkinThk / cos(WALL_INCL * not(reorder))					x12 = ActSkinInnerPoints[1][1] - 0.1 * cos(WALL_INCL)					y12 = ActSkinInnerPoints[1][2] + ActSkinThk / cos(WALL_INCL * not(reorder)) + InclWallyCorrSign * 0.1 * sin(WALL_INCL) * not(reorder)					originalSegmentAngle = ActSkinInnerPoints[1][3]				endif			else				if AddOppPoint & ij = numPoints & ( (curvedWall & not(bWndCurved)) | not(curvedWall) ) then					x11 = ActSkinInnerPoints[ij-1][1] + ActSkinThk * sideSign					y11 = ActSkinInnerPoints[ij-1][2]					x12 = ActSkinInnerPoints[ij-1][1] + ActSkinThk * sideSign					y12 = ActSkinInnerPoints[ij-1][2] - 0.1					originalSegmentAngle = ActSkinInnerPoints[ij-1][3]				else					x11 = ActSkinInnerPoints[ij-1][1] + ActSkinThk * cos(SegmentAngles[ij-1] + 90) * sideSign					y11 = ActSkinInnerPoints[ij-1][2] - ActSkinThk * sin(SegmentAngles[ij-1] + 90) * sideSign					x12 = ActSkinInnerPoints[ij][1]   + ActSkinThk * cos(SegmentAngles[ij-1] + 90) * sideSign					y12 = ActSkinInnerPoints[ij][2]   - ActSkinThk * sin(SegmentAngles[ij-1] + 90) * sideSign					originalSegmentAngle = ActSkinInnerPoints[ij-1][3]				endif			endif			if ij = numPoints then				if abs(sin(SegmentAngles[ij-1])) < EPS then					x21 = ActSkinInnerPoints[ij][1]					y21 = ActSkinInnerPoints[ij][2] - ActSkinThk * sideSign					x22 = ActSkinInnerPoints[ij][1] + 0.1 * sideSign					y22 = ActSkinInnerPoints[ij][2] - ActSkinThk * sideSign				else					if curvedWall & bWndCurved then						gosub 800						xo = 0						yo = RevSignCorr * WOD - yShift						ro = sqr( (abs(yo) - RevealPnts[NumPoints_Opp][2]) ^ 2 + RevealPnts[NumPoints_Opp][1] ^ 2 )						ActisArc = 1					else						x21 = ActSkinInnerPoints[ij-AddOppPoint][1]						y21 = RevDepy						x22 = ActSkinInnerPoints[ij-AddOppPoint][1]+ 0.1 * sideSign						y22 = RevDepy					endif				endif			else				x21 = ActSkinInnerPoints[ij][1] + ActSkinThk * cos(SegmentAngles[ij] + 90) * sideSign				y21 = ActSkinInnerPoints[ij][2] - ActSkinThk * sin(SegmentAngles[ij] + 90) * sideSign				x22 = ActSkinInnerPoints[ij+1][1] + ActSkinThk * cos(SegmentAngles[ij] + 90) * sideSign				y22 = ActSkinInnerPoints[ij+1][2] - ActSkinThk * sin(SegmentAngles[ij] + 90) * sideSign				if abs(x21 - x22) < EPS & abs(y21 - y22) < EPS then					x22 = x21 - ActSkinThk * sin(SegmentAngles[ij] + 90) !* sideSign					y22 = y21 - ActSkinThk * cos(SegmentAngles[ij] + 90)				endif			endif			if ij = NumPoints_Opp & AddOppPoint = 1 then				if curvedWall & bWndCurved & not(bParalellInCurvedWalls) then					if abs(ActSkinInnerPoints[ij][1] - ActSkinInnerPoints[ij+1][1]) < EPS then						x21 = ActSkinInnerPoints[ij][1] - ActSkinThk * sin(SegmentAngles[ij]) * sideSign						y21 = ActSkinInnerPoints[ij][2] - ActSkinThk * cos(SegmentAngles[ij]) * sideSign						x22 = ActSkinInnerPoints[ij+1][1] - 0.1 * cos(SegmentAngles[ij]) * sideSign - ActSkinThk * sin(SegmentAngles[ij]) * sideSign						y22 = ActSkinInnerPoints[ij+1][2] + 0.1 * sin(SegmentAngles[ij]) * sideSign - ActSkinThk * cos(SegmentAngles[ij]) * sideSign					else						x21 = ActSkinInnerPoints[ij][1] - ActSkinThk * sin(SegmentAngles[ij]) * sideSign						y21 = ActSkinInnerPoints[ij][2] - ActSkinThk * cos(SegmentAngles[ij]) * sideSign						x22 = ActSkinInnerPoints[ij+1][1] - ActSkinThk * sin(SegmentAngles[ij]) * sideSign						y22 = ActSkinInnerPoints[ij+1][2] - ActSkinThk * cos(SegmentAngles[ij]) * sideSign					endif				else					x21 = ActSkinInnerPoints[ij][1] + ActSkinThk * sideSign					y21 = ActSkinInnerPoints[ij][2]					x22 = ActSkinInnerPoints[ij][1] + ActSkinThk * sideSign					y22 = ActSkinInnerPoints[ij][2] + 0.1 * sideSign				endif			endif			if abs(x11 - x12) < EPS & abs(y11 - y12) < EPS then				x12 = x11 + cos(originalSegmentAngle) * sideSign				y12 = y11 - sin(originalSegmentAngle) * sideSign			endif!!! Finding the intersected points-----------------------------------------			if ActisArc | PrevisArc then				if ActisArc then					x1 = x11: y1 = y11					x2 = x12: y2 = y12				else					x1 = x21: y1 = y21					x2 = x22: y2 = y22				endif				gosub 101	! Circle - Line intersection				gosub 102	! Select good intersection point			else				gosub 100	! Line - Line intersection			endif			if state then				ActSkinOuterPoints[ij][1] = cx				ActSkinOuterPoints[ij][2] = cy			else				ActSkinOuterPoints[ij][1] = x12				ActSkinOuterPoints[ij][2] = y12			endif			ActSkinOuterPoints[ij][3] = originalSegmentAngle			if ij = numPoints then				FacePointOutx = cx				FacePointOuty = cy			endif		next ij!!!Plaster outer points-------------------------------------------------------		dim FinalSkinOuterPoints[][2]		idx = 1		for ij = numPoints to 1 step -1			px = ActSkinOuterPoints[ij][1]			py = ActSkinOuterPoints[ij][2]			if ij < numPoints & ij >= 2 then				x11 = ActSkinOuterPoints[ij][1]				y11 = ActSkinOuterPoints[ij][2]				x12 = ActSkinOuterPoints[ij + 1][1]				y12 = ActSkinOuterPoints[ij + 1][2]				x21 = ActSkinOuterPoints[ij - 1][1]				y21 = ActSkinOuterPoints[ij - 1][2]				if ij <= 2 then					x22 = OutLinePx1					y22 = OutLinePy1				else					x22 = ActSkinOuterPoints[ij - 2][1]					y22 = ActSkinOuterPoints[ij - 2][2]				endif				gosub 103	! Segment - Segment intersection				if state = 3 then	! Intersection point lies on both segments					px = cx					py = cy					ij = ij - 1		! Skip next point				endif			endif			if idx = 1 then				FinalSkinOuterPoints[1][1] = px				FinalSkinOuterPoints[1][2] = py				idx = idx + 1				put px, py, 0			else				if	not(abs(FinalSkinOuterPoints[idx-1][1] - px) < EPS) |\ 		! Skip current point if it is equal to previous point					not(abs(FinalSkinOuterPoints[idx-1][2] - py) < EPS) then					FinalSkinOuterPoints[idx][1] = px					FinalSkinOuterPoints[idx][2] = py					idx = idx + 1					put px, py, 0				endif			endif		next ij!!! Drawing the plaster and inner line-------------------------------------------------		if bShowSkin then			fill ActSkinFill			wallblock2{2} nsp/3, 2, 2,8 * (bLocalFill | bFitToSkinFill) + 32 * bFitToSkinFill + 128 * (bLocalFill & not(bFitToSkinFill)),				ActSkinFillPen, ActSkinFillBkgPen,				use(2),				-sin(dirAngle),-cos(dirAngle), -ActSkinThk*cos(dirAngle),ActSkinThk*sin(dirAngle),				0,				get(nsp)		else			for kk= 1 to nsp				ClearStack = get(1)			next kk		endif		if bShowSkin | (bShowPrevSkin & not(bShowSkin)) then			!!! Inner skin lines			if ActSkinUppLinePen > 0 then				pen ActSkinUppLinePen				line_type ActSkinUppLineType				if bShowSkin then					line_property LINE_PROPERTY_INNER				else					line_property LINE_PROPERTY_CONTOUR				endif				for ij = 1 to vardim1(FinalSkinInnerPoints) - 1					wallline2	FinalSkinInnerPoints[ij][1],	FinalSkinInnerPoints[ij][2],								FinalSkinInnerPoints[ij+1][1],	FinalSkinInnerPoints[ij+1][2]				next ij				if i > 1 then					wallline2	InnLinePx1, InnLinePy1,								InnLinePx2, InnLinePy2				endif			endif			if bShowSkin & ActFacePen > 0 then				pen ActFacePen				wallline2 FacePointInnx, FacePointInny, FacePointOutx, FacePointOuty			endif		endif!!! Outer contour line-----------------------------------------------		if i = nSkinTurnOut & bShowSkin then			if reorder then				WallCotourLinePen = WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][SKIN_UPPER_LINE_PEN]				line_type WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][SKIN_UPPER_LINE_TYPE]			else				WallCotourLinePen = WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][SKIN_LOWER_LINE_PEN]				line_type WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][SKIN_LOWER_LINE_TYPE]			endif			if WallCotourLinePen > 0 then				pen WallCotourLinePen				line_property LINE_PROPERTY_CONTOUR				if (GLOB_PREVIEW_MODE = 0) then					line2	RevealPnts[1][1], RevealPnts[1][2],							ActSkinOuterPoints[1][1], ActSkinOuterPoints[1][2]					for ij = 1 to vardim1(FinalSkinOuterPoints) - 1						line2	FinalSkinOuterPoints[ij][1],	FinalSkinOuterPoints[ij][2],								FinalSkinOuterPoints[ij+1][1],	FinalSkinOuterPoints[ij+1][2]					next ij				endif				wallline2	RevealPnts[1][1], RevealPnts[1][2],							ActSkinOuterPoints[1][1], ActSkinOuterPoints[1][2]				for ij = 1 to vardim1(FinalSkinOuterPoints) - 1					wallline2	FinalSkinOuterPoints[ij][1],	FinalSkinOuterPoints[ij][2],								FinalSkinOuterPoints[ij+1][1],	FinalSkinOuterPoints[ij+1][2]				next ij			endif		endif		!!! Changing the outer points to next plasters' inner points		ActSkinInnerPoints = ActSkinOuterPoints		bShowPrevSkin = bShowSkin	next iendifreturn2000:! ==============================================================================! Turn Plaster - at Outside Face! ==============================================================================ActSummThk = 0if nSkinTurnIn then!!! Offset on the beginning --------------------------------------------------	InSkinsOffset = 0	InSkinsOffsetx = 0	InSkinsOffsety = 0	for i= 1 to nSkinTurnIn		SkinIndex = i		InSkinsOffset = InSkinsOffset + WALL_SKINS_PARAMS[SkinIndex][SKIN_THICKNESS]	next i	if curvedWall then		InSkinsOffsetAtf = InSkinsOffset / cos(SegmentAngles[MaxNumPoints-1] - 270 - alpha)		InSkinsOffsety = InSkinsOffsetAtf * cos(SegmentAngles[MaxNumPoints-1] - 270)		InSkinsOffsetx = InSkinsOffsetAtf * sin(SegmentAngles[MaxNumPoints-1] - 270)	else		InSkinsOffsetAtf = InSkinsOffset / cos(SegmentAngles[MaxNumPoints-1] - 270 - (InclWallyCorrSign * WALL_INCL) * reorder)		InSkinsOffsety = InSkinsOffsetAtf * cos(SegmentAngles[MaxNumPoints-1] - 270)		InSkinsOffsetx = InSkinsOffsetAtf * sin(SegmentAngles[MaxNumPoints-1] - 270)	endif!!! First (inner) skin inner points-----------------------------------------------	dim ActRefSkinInnerPoints[][3]	for i = 1 to NumPoints_Ref + 1 + AddRefPoint		ActRefSkinInnerPoints[i][1] = RevealPnts[MaxNumPoints-(i-1)][1]		ActRefSkinInnerPoints[i][2] = RevealPnts[MaxNumPoints-(i-1)][2]		if vardim1(SegmentAngles) >= MaxNumPoints-(i-1) then			ActRefSkinInnerPoints[i][3] = SegmentAngles[MaxNumPoints-(i-1)]		else			ActRefSkinInnerPoints[i][3] = 0		endif	next i!!! First (inner) skin first point------------------------------------------------	if curvedWall then		x1 = RevealPnts[MaxNumPoints][1]: y1 = RevealPnts[MaxNumPoints][2]		x2 = RevealPnts[MaxNumPoints][1] - 1 * cos(SegmentAngles[MaxNumPoints-1]) : y2 = RevealPnts[MaxNumPoints][2] + 1 * sin(SegmentAngles[MaxNumPoints-1])		xo = 0		yo = RevSignCorr * WOD - yShift		ro = abs(yo) + (rSillLine-(RevSignCorr * WOD)) - InSkinsOffset		dirAngle = atn((x1 - x2) / (y1 - y2))		gosub 101	! Circle - Line intersection		gosub 102	! Select good intersection point		ActRefSkinInnerPoints[1][1] = cx		ActRefSkinInnerPoints[1][2] = cy	else		ActRefSkinInnerPoints[1][1] = RevealPnts[MaxNumPoints][1] + InSkinsOffsetx		ActRefSkinInnerPoints[1][2] = RevealPnts[MaxNumPoints][2] + InSkinsOffsety		dirAngle = 0	endif	RevDepy = RevealPnts[MaxNumPoints - NumPoints_Ref + 1][2]	BegX = RevealPnts[MaxNumPoints][1]	bShowPrevSkin = 0	for i = 1 to nSkinTurnIn!!! Actual skin properties--------------------------------------------------		SkinIndex				= nSkinTurnIn - (i-1)		ActSkinThk				= WALL_SKINS_PARAMS[SkinIndex][SKIN_THICKNESS]		ActSkinFill				= WALL_SKINS_PARAMS[SkinIndex][SKIN_FILL]		ActSkinFillPen			= WALL_SKINS_PARAMS[SkinIndex][SKIN_FILL_PEN]		ActSkinFillBkgPen		= WALL_SKINS_PARAMS[SkinIndex][SKIN_FILL_BACK_PEN]		bLocalFill				= round_int(WALL_SKINS_PARAMS[SkinIndex][SKIN_FILL_ORIENTATION])		bFitToSkinFill			= round_int(WALL_SKINS_PARAMS[SkinIndex][SKIN_FILL_FIT_TO_SKIN])		if reorder then			ActSkinUppLinePen	= WALL_SKINS_PARAMS[SkinIndex][SKIN_UPPER_LINE_PEN]			ActSkinUppLineType	= WALL_SKINS_PARAMS[SkinIndex][SKIN_UPPER_LINE_TYPE]		else			ActSkinUppLinePen	= WALL_SKINS_PARAMS[SkinIndex][SKIN_LOWER_LINE_PEN]			ActSkinUppLineType	= WALL_SKINS_PARAMS[SkinIndex][SKIN_LOWER_LINE_TYPE]		endif		ActFacePen				= WALL_SKINS_PARAMS[SkinIndex][SKIN_END_FACE_PEN]		ActSummThk				= ActSummThk + ActSkinThk		bShowSkin = (abs(ActSkinThk) > EPS) & (GLOB_STRUCTURE_DISPLAY = STRUCTURE_ENTIRE_STRUCTURE | (GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[SkinIndex][SKIN_FINISH_STATUS] - 1) > EPS))!!! Last outer point--------------------------------------------------------		if curvedWall then			x1 = RevealPnts[MaxNumPoints][1]: y1 = RevealPnts[MaxNumPoints][2]			x2 = RevealPnts[MaxNumPoints][1] - 1 * cos(SegmentAngles[MaxNumPoints-1]) : y2 = RevealPnts[MaxNumPoints][2] + 1 * sin(SegmentAngles[MaxNumPoints-1])			xo = 0			yo = RevSignCorr * WOD - yShift			ro = abs(yo) + (rSillLine-(RevSignCorr * WOD)) - InSkinsOffset + ActSummThk			gosub 101	! Circle - Line intersection			gosub 102	! Select good intersection point			OutLinePx1 = cx			OutLinePy1 = cy		else			OutLinePx1 = BegX			OutLinePy1 = ActRefSkinInnerPoints[1][2] + InclWallyCorrSign * TAN(WALL_INCL) * reorder * (ActRefSkinInnerPoints[1][1] - BegX) -  ActSkinThk / cos(WALL_INCL)		endif		put OutLinePx1, OutLinePy1, 0!!! First inner point-------------------------------------------------------		if curvedWall then			x1 = RevealPnts[MaxNumPoints][1]: y1 = RevealPnts[MaxNumPoints][2]			x2 = RevealPnts[MaxNumPoints][1] - 1 * cos(SegmentAngles[MaxNumPoints-1]) : y2 = RevealPnts[MaxNumPoints][2] + 1 * sin(SegmentAngles[MaxNumPoints-1])			xo = 0			yo = RevSignCorr * WOD - yShift			ro = abs(yo) + (rSillLine-(RevSignCorr * WOD)) - InSkinsOffset + ActSummThk - ActSkinThk			gosub 101	! Circle - Line intersection			gosub 102	! Select good intersection point			InnLinePx1 = cx			InnLinePy1 = cy		else			InnLinePx1 = BegX			InnLinePy1 = ActRefSkinInnerPoints[1][2] + InclWallyCorrSign * TAN(WALL_INCL) * reorder * (ActRefSkinInnerPoints[1][1] - BegX)		endif		if i > 1 then			put InnLinePx1, InnLinePy1, 0		endif!!!Plaster inner points-------------------------------------------------------		dim FinalRefSkinInnerPoints[][2]		idx = 1		numPoints = NumPoints_Ref + AddRefPoint * (i > 1)		for ij = 1 to numPoints			px = ActRefSkinInnerPoints[ij][1]			py = ActRefSkinInnerPoints[ij][2]			if ij <= numPoints - 2 then				x11 = ActRefSkinInnerPoints[ij][1]				y11 = ActRefSkinInnerPoints[ij][2]				if ij = 1 then					x12 = InnLinePx1					y12 = InnLinePy1				else					x12 = ActRefSkinInnerPoints[ij - 1][1]					y12 = ActRefSkinInnerPoints[ij - 1][2]				endif				x21 = ActRefSkinInnerPoints[ij + 1][1]				y21 = ActRefSkinInnerPoints[ij + 1][2]				x22 = ActRefSkinInnerPoints[ij + 2][1]				y22 = ActRefSkinInnerPoints[ij + 2][2]				gosub 103	! Segment - Segment intersection				if state = 3 then	! Intersection point lies on both segments					px = cx					py = cy					ij = ij + 1		! Skip next point				endif			endif			FinalRefSkinInnerPoints[idx][1] = px			FinalRefSkinInnerPoints[idx][2] = py			idx = idx + 1			put px, py, 0			if ij = numPoints then				FacePointInnx = ActRefSkinInnerPoints[ij][1]				FacePointInny = ActRefSkinInnerPoints[ij][2]			endif		next ij		InnLinePx2 = FinalRefSkinInnerPoints[1][1]		InnLinePy2 = FinalRefSkinInnerPoints[1][2]		if FacePointInny <= InnLinePy1 then			bShowSkin = 0		endif!!!Plaster outer points - Offset ---------------------------------------------		dim ActRefSkinOuterPoints[][3]		numPoints = NumPoints_Ref + AddRefPoint		for ij = numPoints to 1 step -1			ActisArc = 0			PrevisArc = 0			ro = 0			if ij = 1 then				if curvedWall then					xo = 0					yo = RevSignCorr * WOD - yShift					ro = abs(yo) + (rSillLine-(RevSignCorr * WOD)) - InSkinsOffset + ActSummThk					PrevisArc = 1					originalSegmentAngle = 0				else					x11 = ActRefSkinInnerPoints[1][1]					y11 = ActRefSkinInnerPoints[1][2] - ActSkinThk / cos(WALL_INCL * reorder)					x12 = ActRefSkinInnerPoints[1][1] - 0.1 * cos(WALL_INCL)					y12 = ActRefSkinInnerPoints[1][2] - ActSkinThk / cos(WALL_INCL * reorder) + InclWallyCorrSign * 0.1 * sin(WALL_INCL) * reorder					originalSegmentAngle = ActRefSkinInnerPoints[1][3]				endif			else				if AddRefPoint & ij = numPoints & ( (curvedWall & not(bWndCurved)) | not(curvedWall) ) then					x11 = ActRefSkinInnerPoints[ij-1][1] + ActSkinThk * sideSign					y11 = ActRefSkinInnerPoints[ij-1][2]					x12 = ActRefSkinInnerPoints[ij-1][1] + ActSkinThk * sideSign					y12 = ActRefSkinInnerPoints[ij-1][2] - 0.1					originalSegmentAngle = ActRefSkinInnerPoints[ij-1][3]				else					x11 = ActRefSkinInnerPoints[ij-1][1] + ActSkinThk * cos(SegmentAngles[MaxNumPoints-ij+1] + 90) * sideSign					y11 = ActRefSkinInnerPoints[ij-1][2] - ActSkinThk * sin(SegmentAngles[MaxNumPoints-ij+1] + 90) * sideSign					x12 = ActRefSkinInnerPoints[ij][1] + ActSkinThk * cos(SegmentAngles[MaxNumPoints-ij+1] + 90) * sideSign					y12 = ActRefSkinInnerPoints[ij][2] - ActSkinThk * sin(SegmentAngles[MaxNumPoints-ij+1] + 90) * sideSign					originalSegmentAngle = ActRefSkinInnerPoints[ij][3]				endif			endif			if ij = numPoints then				if abs(sin(SegmentAngles[MaxNumPoints-ij+1])) < EPS then					x21 = ActRefSkinInnerPoints[ij][1]					y21 = ActRefSkinInnerPoints[ij][2] - ActSkinThk * sideSign					x22 = ActRefSkinInnerPoints[ij][1] + 0.1 * sideSign					y22 = ActRefSkinInnerPoints[ij][2] - ActSkinThk * sideSign				else					if curvedWall & bWndCurved then						gosub 801						xo = 0						yo = RevSignCorr * WOD - yShift						ro = sqr( (abs(yo) - RevealPnts[MaxNumPoints - NumPoints_Ref + 1][2]) ^ 2 + RevealPnts[MaxNumPoints - NumPoints_Ref + 1][1] ^ 2 )						ActisArc = 1					else						x21 = ActRefSkinInnerPoints[ij-AddRefPoint][1]						y21 = RevDepy						x22 = ActRefSkinInnerPoints[ij-AddRefPoint][1]+ 0.1 * sideSign						y22 = RevDepy					endif				endif			else				x21 = ActRefSkinInnerPoints[ij][1] + ActSkinThk * cos(SegmentAngles[MaxNumPoints-ij] + 90) * sideSign				y21 = ActRefSkinInnerPoints[ij][2] - ActSkinThk * sin(SegmentAngles[MaxNumPoints-ij] + 90) * sideSign				x22 = ActRefSkinInnerPoints[ij+1][1] + ActSkinThk * cos(SegmentAngles[MaxNumPoints-ij] + 90) * sideSign				y22 = ActRefSkinInnerPoints[ij+1][2] - ActSkinThk * sin(SegmentAngles[MaxNumPoints-ij] + 90) * sideSign				if abs(x21 - x22) < EPS & abs(y21 - y22) < EPS then					x22 = x21 - ActSkinThk * sin(SegmentAngles[MaxNumPoints-ij] + 90) !* sideSign					y22 = y21 - ActSkinThk * cos(SegmentAngles[MaxNumPoints-ij] + 90)				endif			endif			if ij = NumPoints_Ref & AddRefPoint = 1 then				if curvedWall & bWndCurved & not(bParalellInCurvedWalls) then					if abs(ActRefSkinInnerPoints[ij][1] - ActRefSkinInnerPoints[ij+1][1]) < EPS then						x21 = ActRefSkinInnerPoints[ij+1][1] - ActSkinThk * sin(SegmentAngles[MaxNumPoints-ij]) * sideSign						y21 = ActRefSkinInnerPoints[ij+1][2] - ActSkinThk * cos(SegmentAngles[MaxNumPoints-ij]) * sideSign						x22 = ActRefSkinInnerPoints[ij+1][1] - 0.1 * cos(SegmentAngles[MaxNumPoints-ij]) * sideSign - ActSkinThk * sin(SegmentAngles[MaxNumPoints-ij]) * sideSign						y22 = ActRefSkinInnerPoints[ij+1][2] + 0.1 * sin(SegmentAngles[MaxNumPoints-ij]) * sideSign - ActSkinThk * cos(SegmentAngles[MaxNumPoints-ij]) * sideSign					else						x21 = ActRefSkinInnerPoints[ij][1] - ActSkinThk * sin(SegmentAngles[MaxNumPoints-ij]) * sideSign						y21 = ActRefSkinInnerPoints[ij][2] - ActSkinThk * cos(SegmentAngles[MaxNumPoints-ij]) * sideSign						x22 = ActRefSkinInnerPoints[ij+1][1] - ActSkinThk * sin(SegmentAngles[MaxNumPoints-ij]) * sideSign						y22 = ActRefSkinInnerPoints[ij+1][2] - ActSkinThk * cos(SegmentAngles[MaxNumPoints-ij]) * sideSign					endif				else					x21 = ActRefSkinInnerPoints[ij][1] + ActSkinThk * sideSign					y21 = ActRefSkinInnerPoints[ij][2]					x22 = ActRefSkinInnerPoints[ij][1] + ActSkinThk * sideSign					y22 = ActRefSkinInnerPoints[ij][2] + 0.1 * sideSign				endif			endif			if abs(x11 - x12) < EPS & abs(y11 - y12) < EPS then				x12 = x11 + cos(originalSegmentAngle) * sideSign				y12 = y11 - sin(originalSegmentAngle) * sideSign			endif!!! Finding the intersected points-----------------------------------------			if ActisArc | PrevisArc then				if ActisArc then					x1 = x11: y1 = y11					x2 = x12: y2 = y12				else					x1 = x21: y1 = y21					x2 = x22: y2 = y22				endif				gosub 101	! Circle - Line intersection				gosub 102	! Select good intersection point			else				gosub 100	! Line - Line intersection			endif			if state then				ActRefSkinOuterPoints[ij][1] = cx				ActRefSkinOuterPoints[ij][2] = cy			else				ActRefSkinOuterPoints[ij][1] = x12				ActRefSkinOuterPoints[ij][2] = y12			endif			ActRefSkinOuterPoints[ij][3] = originalSegmentAngle			if ij = numPoints then				FacePointOutx = cx				FacePointOuty = cy			endif		next ij!!!Plaster outer points-------------------------------------------------------		dim FinalRefSkinOuterPoints[][2]		idx = 1		for ij = numPoints to 1 step -1			px = ActRefSkinOuterPoints[ij][1]			py = ActRefSkinOuterPoints[ij][2]			if ij < numPoints & ij >= 2 then				x11 = ActRefSkinOuterPoints[ij][1]				y11 = ActRefSkinOuterPoints[ij][2]				x12 = ActRefSkinOuterPoints[ij + 1][1]				y12 = ActRefSkinOuterPoints[ij + 1][2]				x21 = ActRefSkinOuterPoints[ij - 1][1]				y21 = ActRefSkinOuterPoints[ij - 1][2]				if ij <= 2 then					x22 = OutLinePx1					y22 = OutLinePy1				else					x22 = ActRefSkinOuterPoints[ij - 2][1]					y22 = ActRefSkinOuterPoints[ij - 2][2]				endif				gosub 103	! Segment - Segment intersection				if state = 3 then	! Intersection point lies on both segments					px = cx					py = cy					ij = ij - 1		! Skip next point				endif			endif			if idx = 1 then				FinalRefSkinOuterPoints[1][1] = px				FinalRefSkinOuterPoints[1][2] = py				idx = idx + 1				put px, py, 0			else				if	not(abs(FinalRefSkinOuterPoints[idx-1][1] - px) < EPS) |\		! Skip current point if it is equal to previous point					not(abs(FinalRefSkinOuterPoints[idx-1][2] - py) < EPS) then					FinalRefSkinOuterPoints[idx][1] = px					FinalRefSkinOuterPoints[idx][2] = py					idx = idx + 1					put px, py, 0				endif			endif		next ij!!! Drawing the plaster and inner line---------------------------------------		if bShowSkin then			fill ActSkinFill			wallblock2{2} nsp/3, 2, 2,8 * (bLocalFill | bFitToSkinFill) + 32 * bFitToSkinFill + 128 * (bLocalFill & not(bFitToSkinFill)),				ActSkinFillPen, ActSkinFillBkgPen,				use(2),				-sin(dirAngle),-cos(dirAngle), -ActSkinThk*cos(dirAngle),ActSkinThk*sin(dirAngle),				0,				get(nsp)		else			for kk= 1 to nsp				ClearStack = get(1)			next kk		endif		if bShowSkin | (bShowPrevSkin & not(bShowSkin)) then			!!! Inner skin lines			if ActSkinUppLinePen > 0 then				pen ActSkinUppLinePen				line_type ActSkinUppLineType				if bShowSkin then					line_property LINE_PROPERTY_INNER				else					line_property LINE_PROPERTY_CONTOUR				endif				for ij = 1 to vardim1(FinalRefSkinInnerPoints) - 1					wallline2	FinalRefSkinInnerPoints[ij][1],		FinalRefSkinInnerPoints[ij][2],								FinalRefSkinInnerPoints[ij+1][1],	FinalRefSkinInnerPoints[ij+1][2]				next ij				if i > 1 then					wallline2	InnLinePx1, InnLinePy1,								InnLinePx2, InnLinePy2				endif			endif			if bShowSkin & ActFacePen > 0 then				pen ActFacePen				wallline2 FacePointInnx, FacePointInny, FacePointOutx, FacePointOuty			endif		endif!!! Outer contour line-----------------------------------------------		if i = nSkinTurnIn & bShowSkin then			if reorder then				WallCotourLinePen = WALL_SKINS_PARAMS[1][SKIN_LOWER_LINE_PEN]				line_type WALL_SKINS_PARAMS[1][SKIN_LOWER_LINE_TYPE]			else				WallCotourLinePen = WALL_SKINS_PARAMS[1][SKIN_UPPER_LINE_PEN]				line_type WALL_SKINS_PARAMS[1][SKIN_UPPER_LINE_TYPE]			endif			if WallCotourLinePen > 0 then				pen WallCotourLinePen				line_property LINE_PROPERTY_CONTOUR				if (GLOB_PREVIEW_MODE = 0) then					line2	RevealPnts[MaxNumPoints][1], RevealPnts[MaxNumPoints][2],							ActRefSkinOuterPoints[1][1], ActRefSkinOuterPoints[1][2]					for ij = 1 to vardim1(FinalRefSkinOuterPoints) - 1						line2	FinalRefSkinOuterPoints[ij][1],		FinalRefSkinOuterPoints[ij][2],								FinalRefSkinOuterPoints[ij+1][1],	FinalRefSkinOuterPoints[ij+1][2]					next ij				endif				wallline2	RevealPnts[MaxNumPoints][1], RevealPnts[MaxNumPoints][2],							ActRefSkinOuterPoints[1][1], ActRefSkinOuterPoints[1][2]				for ij = 1 to vardim1(FinalRefSkinOuterPoints) - 1					wallline2	FinalRefSkinOuterPoints[ij][1],		FinalRefSkinOuterPoints[ij][2],								FinalRefSkinOuterPoints[ij+1][1],	FinalRefSkinOuterPoints[ij+1][2]				next ij			endif		endif		!!! Changing the outer points to next plasters' inner points		ActRefSkinInnerPoints = ActRefSkinOuterPoints		bShowPrevSkin = bShowSkin	next iendifreturn! ==============================================================================! Line - Line intersection! ------------------------------------------------------------------------------! Input variables:!	EPS:				epsylon!	x11,y11, x12,y12	line #1!	x21,y21, x22,y22	line #2!! Returned variables:!	state:				0 = no intersection point!						1 = valid intersection point!	cx, cy:				intersection point! ==============================================================================100:	lliDiv = (x11-x12) * (y21-y22) - (y11-y12) * (x21-x22)	if abs(lliDiv) > smallEPS then		! Intersection		temp1 = x11 * y12 - y11 * x12		temp2 = x21 * y22 - y21 * x22		tempx = temp1 * (x21-x22) - (x11-x12) * temp2		tempy = temp1 * (y21-y22) - (y11-y12) * temp2		state = 1		cx = (tempx / lliDiv)		cy = (tempy / lliDiv)	else		! No Intersection		state = 0		cx = 0		cy = 0		bPointL1 = (abs(x11 - x12) < EPS & abs(y11 - y11) < EPS)		bPointL2 = (abs(x21 - x22) < EPS & abs(y21 - y21) < EPS)		if bPointL1 & bPointL2 & abs(x11 - x21) < EPS & abs(y11 - y21) < EPS then			state = 1			cx = x11			cy = y11		endif		if bPointL1 & not(bPointL2) then			if (abs((y22-y21) * (x11-x21) - (x22-x21) * (y11-y21)) / sqr((x22-x21)^2 + (y22-y21)^2)) < EPS then				state = 1				cx = x11				cy = y11			endif		endif		if not(bPointL1) & bPointL2 then			if (abs((y12-y11) * (x21-x11) - (x12-x11) * (y21-y11)) / sqr((x12-x11)^2 + (y12-y11)^2)) < EPS then				state = 1				cx = x11				cy = y11			endif		endif	endifreturn! ==============================================================================! Circle - Line intersection! ------------------------------------------------------------------------------! Input variables:!	EPS:				epsylon!	xo,yo,ro:			circle!	x1,y1, x2,y2		line!! Returned variables:!	state:				0 = no intersection point!						1 = one intersection point (tangential line)!						2 = two intersection points!	xa, ya:				intersection point #1!	xb, yb:				intersection point #2! ==============================================================================101:	tempX1 = x1 - xo: tempY1 = y1 - yo	tempX2 = x2 - xo: tempY2 = y2 - yo	if abs(tempX2 - tempX1) < smallEPS then		if abs(ro - abs(tempX1)) < smallEPS then			state = 1			xa = tempX1			ya = 0			xb = tempX1			yb = 0		else			if abs(ro) - abs(tempX1) < 0 then				state = 0: xa = 0: ya = 0: xb = 0: yb = 0			else				state = 2				xa = tempX1				ya = sqr(ro^2 - tempX1^2)				xb = tempX1				yb = -sqr(ro^2 - tempX1^2)			endif		endif	else		kf = (tempY2 - tempY1) / (tempX2 - tempX1)		ad = 1 + kf^2		bd = 2 * tempY1 * kf - 2 * tempX1 * kf^2		cd = tempY1^2 - 2 * tempX1 * tempY1 * kf + tempX1^2 * kf^2 - ro^2		if bd^2 - 4 * ad * cd < 0 then			state = 0: xa = 0: ya = 0: xb = 0: yb = 0		else			xa = (-bd + sqr(bd^2 - 4 * ad * cd)) / (2 * ad)			ya = tempY1 + (xa - tempX1) * kf			xb = (-bd - sqr(bd^2 - 4 * ad * cd)) / (2 * ad)			yb = tempY1 + (xb - tempX1) * kf			if abs(xa - xb) < smallEPS then state = 1 else state = 2		endif	endif	if state = 2 then		da = sqr((tempX1 - xa)^2 + (tempY1 - ya)^2)		db = sqr((tempX1 - xb)^2 + (tempY1 - yb)^2)		if db < da then			xxo = xa: yyo = ya			xa = xb:  ya = yb			xb = xxo: yb = yyo		endif	endif	xa = xa + xo: ya = ya + yo	xb = xb + xo: yb = yb + yoreturn! ==============================================================================! Select good intersection point after Circle - Line intersection! ------------------------------------------------------------------------------! Input variables:!	state:				intersection status!	wallIsLeft:!	xa, ya:				intersection point #1!	xb, yb:				intersection point #2!! Returned variables:!	cx, cy:				selected intersection point! ==============================================================================102:	cx = 0	cy = 0	if state = 1 then		cx = xa		cy = ya	endif	if state = 2 then!		if wallIsLeft then!			if ya > yb then!				cx = xa!				cy = ya!			else!				cx = xb!				cy = yb!			endif!		else			if ya < yb then				cx = xa				cy = ya			else				cx = xb				cy = yb			endif!		endif	endifreturn! ==============================================================================! Segment - Segment intersection! ==============================================================================! Input variables:!	EPS:				epsylon!	x11,y11, x12,y12	segment #1!	x21,y21, x22,y22	segment #2!! Returned variables:!	state:				output status!							-1: no intersection, segments is not parallel!							 0: no intersection, parallel segments!							 1: intersection point lies on S1 segment, but not lies on S2!							 2: intersection point lies on S2 segment, but not lies on S1!							 3: intersection point lies on both segments!	cx, cy:				intersection point! ==============================================================================103:	gosub 100	! Line - Line intersection	if state then		state = 0		if abs(x11 - x12) < EPS then			if (y11 - EPS <= cy & cy <= y12 + EPS) | (y11 + EPS >= cy & cy >= y12 - EPS) then state = 1		else			if (x11 - EPS <= cx & cx <= x12 + EPS) | (x11 + EPS >= cx & cx >= x12 - EPS) then state = 1		endif		if abs(x21 - x22) < EPS then			if (y21 - EPS <= cy & cy <= y22 + EPS) | (y21 + EPS >= cy & cy >= y22 - EPS) then state = state + 2		else			if (x21 - EPS <= cx & cx <= x22 + EPS) | (x21 + EPS >= cx & cx >= x22 - EPS) then state = state + 2		endif		if state = 0 then			state = -1		else			if abs(x11 - cx) < EPS & abs(y11 - cy) < EPS then state = state + 10			if abs(x12 - cx) < EPS & abs(y12 - cy) < EPS then state = state + 10		endif	endifreturn800:! ==============================================================================! Select the reveal point index until the Inside Face plasters have to run in curved panel case! ------------------------------------------------------------------------------! Input variables:!	RevealPnts:				reveal points!	NumPoints_Opp:			number of points on Inside Face!! Returned variables:!	OppLimIndex:			index of the reveal point! ==============================================================================if RevealPnts[NumPoints_Opp][2] < RevealPnts[NumPoints_Opp + 1][2] then	OppLimIndex = NumPoints_Opp + 1else	OppLimIndex = NumPoints_Oppendifreturn801:! ==============================================================================! Select the reveal point index until the Outside Face plasters have to run in curved panel case! ------------------------------------------------------------------------------! Input variables:!	RevealPnts:				reveal points!	NumPoints_Ref:			number of points on Outside Face!! Returned variables:!	RefLimIndex:			index of the reveal point! ==============================================================================if RevealPnts[MaxNumPoints-NumPoints_Ref + 1][2] > RevealPnts[MaxNumPoints-NumPoints_Ref][2] then	RefLimIndex = MaxNumPoints - NumPoints_Ref + 1else	RefLimIndex = MaxNumPoints - NumPoints_Ref + 1endifreturn