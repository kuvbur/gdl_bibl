! Contact person: <NJ>! ==============================================================================! Masonry Arch macro! ------------------------------------------------------------------------------! Input parameters:! Geometry ---------------------------------------------------------------------!	A:						wallhole width (length) (Obsolete)!	B:						wallhole height (length)!	refWidth:				reference width in curved walls (length)!	leftWidth:				wallhole's side distance from the origin at the left side (length)!	rightWidth:				wallhole's side distance from the origin at the right side (length)!	iWindowShape:			shape of the window (integer)!							note: only the rectangular shape can be a Corner Window!	openingArchHeight:		height of the arc (length)! Masonry Arch parameters ------------------------------------------------------!	gs_masonry_arch_int:			Type of the masonry arch. (integer)!	gs_masonry_arch_structure:		Detail level of the masonry arch. (string)!	gs_masonry_arch_structure_int:	Detail level of the masonry arch. (integer)!	gs_masonry_arch_ovhg_left:		Masonry arch overhang - only for straight arches. (length)!	gs_masonry_arch_ovhg_right:		Masonry arch overhang - only for straight arches. (length)!	gs_masonry_arch_rise:			Rise of the Masonry Arch in case of straight windows!	gs_masonry_arch_skewback_angle:	The angle made by the skewback from horizontal. (angle)!	gs_masonry_arch_proj:			Projection of the masonry bricks. (length)!	gs_masonry_arch_height:			Height of bricks in the arch. (length)!	gs_masonry_arch_depth:			Depth of bricks in the arch. (length)!	gs_masonry_arch_brick_thk:		Thickness of bricks in the arch. (length)!	gs_masonry_arch_mort_thk:		Thickness of mortar. (length)!	gs_masonry_arch_keystone_width:	Width of the Keystone at the bottom. (length)!	gs_masonry_arch_keystone_osize:	Vertical overhang of the Keystone. (length)!	gs_masonry_arch_keystone_proj:	Projection of the Keystone. (length)!	gs_masonry_arch_fill:			Type of the fill on the Masonry Arch. (fill type)!	gs_masonry_arch_pen_fg:			Fill pen on the Masonry Arch. (pen)!	gs_masonry_arch_pen_bg:			Fill pen on the Masonry Arch. (pen)!	gs_masonry_arch_pen:			3D contour pen of the Masonry Arch. (pen)!	gs_masonry_arch_brick_mat:		Brick material (material)!	gs_masonry_arch_mort_mat:		Mortar material (material)!	gs_masonry_arch_keystone_mat:	Keystone material (material)! Reveal -----------------------------------------------------------------------!	gs_reveal_left:				Reveal size on the left (length)!	gs_reveal_right:			Reveal size on the right (length)!	gs_reveal_top:				Reveal size at the top (length)! Corner Window Function -------------------------------------------------------!	ac_cw_function:			Turn macro in Corner Window mode (0 / 1)!	ac_corner_window:		Turn macro in Corner Window mode (0 / 1)!	ac_corner_angle:		Angle between connected walls in case of Corner Window (angle)!	ac_diff_con_wall_thk:	Indicates the equality thickness of the two connected walls. (0 / 1)!	ac_con_wall_thk:		Thickness of the connected wall in case of Corner Window (length)!	--- String Tables ---!	stMasonryArchTypes:		String Table for gs_masonry_arch_int(text; array[])!	stMasonryArchStructure:	String Table for gs_masonry_arch_structure (text; array[])!! Related Global Variables:!	WIDO_REVEAL_ON!	WIDO_REVEAL_SIDE!	WIDO_FRAME_THICKNESS!	WIDO_SILL!	SYMB_MIRRORED!	SYMB_ROTANGLE!	WALL_THICKNESS!	WALL_MAT_A!	WALL_MAT_B!	WALL_VIEW_PEN!	WALL_SECT_PEN! ==============================================================================if gs_masonry_arch_fill = 0		then gs_masonry_arch_fill = SYMB_FILLif gs_masonry_arch_pen_fg = 0	then gs_masonry_arch_pen_fg = SYMB_FILL_PENif gs_masonry_arch_pen_bg = 0	then gs_masonry_arch_pen_bg = SYMB_FBGD_PENgs_masonry_arch_keystone_width = min(gs_masonry_arch_keystone_width, leftWidth + rightWidth)masonryArchMortInset = 0.01if iWindowShape = SHAPE_ARCHED then	gs_reveal_left	= gs_reveal_right	gs_reveal_top	= gs_reveal_rightendifif bEnableOnlyBullseyeArch then	gs_reveal_left	= gs_reveal_right	gs_reveal_top	= gs_reveal_right	gs_reveal_bottom = gs_reveal_rightendifif iWindowShape = SHAPE_ARCHED then	resol nArchResolutionendif! === Turn Plaster in 3D ===[thkPlasterAtSillLeft	= thkPlasterAtSillLeft		* gs_turn_plaster_show_3DthkPlasterAtSillRight	= thkPlasterAtSillRight		* gs_turn_plaster_show_3DthkPlasterAtSillTop		= thkPlasterAtSillTop		* gs_turn_plaster_show_3DthkPlasterAtSillBottom	= thkPlasterAtSillBottom	* gs_turn_plaster_show_3D! ==============================================================================! Double and Outside Splayed Reveal Cutting! ==============================================================================numCuts = 0bSlantedOuterSide	= (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED)if iWindowShape = SHAPE_ARCHED then	if openingArchHeight < EPS then		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape	else		if openingArchHeight > (openingWidth / 2 - EPS) then			openingArchHeight = openingWidth / 2			arcR = openingArchHeight			bHalfCircle = 1		else			arcR = (openingWidth / 2) / sin(2 * atn(openingArchHeight / (openingWidth / 2)))			bHalfCircle = 0		endif	endifendifif iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE | iRevealType = REVEAL_DOUBLE_SPLAYED then	bNeedMiddleCut = 1endifif iRevealType = REVEAL_DOUBLE_SPLAYED then	offsetInsideDepth	= WIDO_FRAME_THICKNESS	offsetOutsideDepth	= 0endifif not(curvedWall) then	! =============================================================================	! Slanted Outer Side Cut - Straight Wall	! =============================================================================	if bSlantedOuterSide then		if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then			gs_slanted_left_angle		= gs_reveal_outerLeft_angle			gs_slanted_right_angle		= gs_reveal_outerRight_angle			gs_slanted_bottom_angle		= gs_reveal_outerBottom_angle			gs_slanted_top_angle		= gs_reveal_outerTop_angle			thkPlasterAtSlantedLeft		= thkPlasterAtSillLeft			thkPlasterAtSlantedRight	= thkPlasterAtSillRight			thkPlasterAtSlantedBottom	= thkPlasterAtSillBottom			thkPlasterAtSlantedTop		= thkPlasterAtSillTop			HalfInfiniteCut				= 1			slantedDepth		= WIDO_SILL - gs_reveal_outer_jamb_depth			slantedDepthBottom	= WIDO_SILL !- bHaveMountingFrame * (gs_mountingFrame_depth)			slantedCutDepth		= slantedDepth			offsetDepth		= offsetOutsideDepth			offsetRight		= gs_reveal_right			offsetLeft		= gs_reveal_left			offsetTop		= gs_reveal_top			offsetBott		= gs_reveal_bottom - (not(bHaveMountingFrame) * gs_reveal_outer_jamb_depth + bHaveMountingFrame * (gs_reveal_outer_jamb_depth - gs_mountingFrame_depth)) * tan(gs_reveal_outerBottom_angle)			bWallInsetCut	= 0			mulz -1			addz WIDO_SILL			gosub 1000	! Slanted Reveal cutting body			del 2		endif	endifelse	! =============================================================================	! Slanted Outer Side Cut - Curved Left Wall	! =============================================================================	if bSlantedOuterSide then		if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then			gs_slanted_left_angle		= gs_reveal_outerLeft_angle	 + alfaLeftOs  - alfaLeftJamb			gs_slanted_right_angle		= gs_reveal_outerRight_angle + alfaRightOs - alfaRightJamb			gs_slanted_bottom_angle		= gs_reveal_outerBottom_angle			gs_slanted_top_angle		= gs_reveal_outerTop_angle			thkPlasterAtSlantedLeft		= thkPlasterAtSillLeft			thkPlasterAtSlantedRight	= thkPlasterAtSillRight			thkPlasterAtSlantedBottom	= thkPlasterAtSillBottom			thkPlasterAtSlantedTop		= thkPlasterAtSillTop			thkPlasterAtSlanted			= 0			HalfInfiniteCut				= 1			slantedDepth		= WIDO_SILL - gs_reveal_outer_jamb_depth			slantedDepthBottom	= WIDO_SILL - bHaveMountingFrame * (gs_mountingFrame_depth)			slantedCutDepth		= slantedDepth			offsetDepth		= offsetOutsideDepth			offsetRight		= rightWidth - (abs(WOD) + gs_reveal_outer_jamb_depth) * tan(alfaRightOs - alfaRightJamb)			offsetLeft		= leftWidth  - (abs(WOD) + gs_reveal_outer_jamb_depth) * tan(alfaLeftOs  - alfaLeftJamb)			offsetTop		= gs_reveal_top			offsetBott		= gs_reveal_bottom !- (not(bHaveMountingFrame) * gs_reveal_outer_jamb_depth + bHaveMountingFrame * (gs_reveal_outer_jamb_depth - gs_mountingFrame_depth)) * tan(gs_reveal_outerBottom_angle)			bWallInsetCut	= 0			mulz -1			addz WIDO_SILL			gosub 1000	! Slanted Reveal cutting body			del 2		endif	endifendif! ==============================================================================! Calculations for Corner Window! ==============================================================================if bRightCornerFunction & abs(rightCornerAngle) > EPS then	gs_stack_right = 1	rx = 1 / tan(rightCornerAngle / 2)	if rightCornerAngle > 180 then		rightCwDx = WIDO_FRAME_THICKNESS / tan(-rightCornerAngle / 2)	else		rightCwDx = 0	endif	rightCwDx2 = 0	if abs(WALL_THICKNESS - rightConnWallThk) > EPS then		rightCwDx2 = (WALL_THICKNESS - rightConnWallThk) / cos(rightCornerAngle - 90)	endif	bFitMode = (rightConnWallThk > WALL_THICKNESS + EPS)!	if SYMB_MIRRORED exor WIDO_REVEAL_SIDE then!		! --- Swap Left and Right Attributes!		gs_tw_left_in		= gs_tw_right_in!		gs_tw_left_out		= gs_tw_right_out!		gs_sill_ovhg_left	= gs_sill_ovhg_right!		gs_stack_left		= gs_stack_right!		gs_left_oversize	= gs_right_oversize!	endif	gs_right_oversize = 0	gs_reveal_right = 0	corrright = gs_masonry_arch_proj * rx * (rightCornerAngle > 0) - gs_masonry_arch_depth *  rx * (rightCornerAngle < 0)	gs_masonry_arch_ovhg_right = rightCwDx + (WIDO_FRAME_THICKNESS + WIDO_SILL) * rx  + corrrightendifif bLeftCornerFunction & abs(leftCornerAngle) > EPS then	gs_stack_left = 1	lx = 1 / tan(leftCornerAngle / 2)	if leftCornerAngle > 180 then		leftCwDx = WIDO_FRAME_THICKNESS / tan(-leftCornerAngle / 2)	else		leftCwDx = 0	endif	leftCwDx2 = 0	if abs(WALL_THICKNESS - leftConnWallThk) > EPS then		leftCwDx2 = (WALL_THICKNESS - leftConnWallThk) / cos(leftCornerAngle - 90)	endif	bFitMode = (leftConnWallThk > WALL_THICKNESS + EPS)	gs_left_oversize = 0	gs_reveal_left = 0	corrleft = gs_masonry_arch_proj * lx * (leftCornerAngle > 0) - gs_masonry_arch_depth * lx * (leftCornerAngle < 0)	gs_masonry_arch_ovhg_left = leftCwDx + (WIDO_FRAME_THICKNESS + WIDO_SILL) * lx + corrleftendifif iWindowShape = SHAPE_RECTANGULAR then	openingArchHeight = gs_masonry_arch_riseendifif gs_masonry_arch_int = MASONRY_SEGMENT_ARCH			& openingArchHeight < EPS then gs_masonry_arch_int = MASONRY_ARCHif gs_masonry_arch_int = MASONRY_SEGMENT_ARCH_KEYSTONE	& openingArchHeight < EPS then gs_masonry_arch_int = MASONRY_JACK_ARCH_KEYSTONEif WIDO_REVEAL_SIDE then	addz WIDO_SILL - WALL_THICKNESS + WIDO_FRAME_THICKNESS    ! Flipelse	addz -WIDO_SILLendifif WIDO_REVEAL_SIDE then	mulz -1	addz -WALL_THICKNESSendifif WIDO_REVEAL_SIDE then	matRevealSide	= WALL_MAT_A	matOppositeSide = WALL_MAT_Belse	matRevealSide	= WALL_MAT_B	matOppositeSide = WALL_MAT_Aendif_nicheSurface	= matRevealSideif bCustomMatNicheTop then _nicheSurface	= matNicheTop! --- Cutplanes in case of corner windows ---if bCornerWindow or bRightCornerFunction then	addx rightWidth + gs_masonry_arch_ovhg_right - corrright	roty rightCornerAngle /2	pen gs_masonry_arch_pen	material gs_masonry_arch_brick_mat	cutplane 1, 1, 0, (rightCornerAngle < 0)	del 2endifif bLeftCornerFunction then	addx -leftWidth - gs_masonry_arch_ovhg_left + corrleft	roty  -leftCornerAngle /2	pen gs_masonry_arch_pen	material gs_masonry_arch_brick_mat	cutplane 1, 1, 0, (leftCornerAngle < 0)	del 2endif! =============================================================================! Curved Walls! =============================================================================if abs (WIDO_ORIG_DIST) < eps then	bCurvedWall = 0else	bCurvedWall = 1endif! =============================================================================! Reveal Points Indexes! =============================================================================idxFrameStartRevealLeft		= iRevealPointsIdx[3]idxFrameStartRevealRight	= iRevealPointsIdx[13]add 0, B - gs_reveal_top + gs_upper_oversize, -gs_masonry_arch_projif not(gs_AutomaticArchHeight) then	addy gs_MasonryArch_heightendif! =============================================================================! Masonry Arch! =============================================================================if gs_masonry_arch_int = MASONRY_ARCH then	pen WALL_VIEW_PEN	material matRevealSide	if bCurvedWall then		addz WOD + WIDO_SILL + gs_masonry_arch_proj 		! moving origo to the center of curved wall		if WOD > 0 then			rrrOut = radSill + gs_masonry_arch_proj  + 1			rrrIn  = rrrOut  - gs_masonry_arch_depth - 1 - gs_masonry_arch_rearHoleDepth		else			rrrOut = radSill - gs_masonry_arch_proj  - 1			rrrIn  = rrrOut  + gs_masonry_arch_depth + 1 + gs_masonry_arch_rearHoleDepth		endif		leftlength = leftWallholeRevealPnts[idxFrameStartRevealLeft][1]		rightlength = rightWallholeRevealPnts[idxFrameStartRevealRight][1]		alfaLeft  = atn (leftlength  / (WOD))		alfaRight = atn (rightlength / (WOD))		alfaOverhangLeft =  360 * (gs_masonry_arch_ovhg_left  / (2 * pi * radSill))		alfaOverhangRight = 360 * (gs_masonry_arch_ovhg_right / (2 * pi * radSill))		xo = 0 : yo = 0 : ro = rrrIn		x1 = 0 : y1 = 0		x2 = radSill * sin (alfaLeft - signWallIsLeft * (not (gs_stack_left)) * alfaOverhangLeft)		y2 = radSill * cos (alfaLeft - signWallIsLeft * (not (gs_stack_left)) * alfaOverhangLeft)		gosub 300		gosub 301		plix = cx		pliy = cy		xo = 0 : yo = 0 : ro = rrrOut		x1 = 0 : y1 = 0		x2 = radSill * sin (alfaLeft - signWallIsLeft * (not (gs_stack_left)) * alfaOverhangLeft)		y2 = radSill * cos (alfaLeft - signWallIsLeft * (not (gs_stack_left)) * alfaOverhangLeft)		gosub 300		gosub 301		plox = cx		ploy = cy		xo = 0 : yo = 0 : ro = rrrIn		x1 = 0 : y1 = 0		x2 = radSill * sin (alfaRight + signWallIsLeft * (not (gs_stack_right)) * alfaOverhangRight)		y2 = radSill * cos (alfaRight + signWallIsLeft * (not (gs_stack_right)) * alfaOverhangRight)		gosub 300		gosub 301		prix = cx		priy = cy		xo = 0 : yo = 0 : ro = rrrOut		x1 = 0 : y1 = 0		x2 = radSill * sin (alfaRight + signWallIsLeft * (not (gs_stack_right)) * alfaOverhangRight)		y2 = radSill * cos (alfaRight + signWallIsLeft * (not (gs_stack_right)) * alfaOverhangRight)		gosub 300		gosub 301		prox = cx		proy = cy		rotx -90		material gs_masonry_arch_brick_mat		wallniche 6, 1, 2,			0, 0, 1, gs_masonry_arch_height,			plix, pliy, 15,			0, 0, 915,			prix, priy, 3015,			prox, proy, 15,			0, 0, 915,			plox, ploy, 3015! Control prism - visualize points!		prism_ 6, gs_masonry_arch_height,!			plix, pliy, 15,!			0, 0, 915,!			prix, priy, 3015,!			prox, proy, 15,!			0, 0, 915,!			plox, ploy, 3015		if WOD > 0 then			rrrOut = radSill + gs_masonry_arch_proj  + 1			rrrIn  = rrrOut  - gs_masonry_arch_depth - 1		else			rrrOut = radSill - gs_masonry_arch_proj  - 1			rrrIn  = rrrOut  + gs_masonry_arch_depth + 1		endif		del 2	else		wallniche 4, 1, 2 + 16,			0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,			-leftWidth  + gs_reveal_left  - gs_masonry_arch_ovhg_left,	0, 31,			 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right,	0, 31,			 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right,	gs_masonry_arch_height, 31,			-leftWidth  + gs_reveal_left  - gs_masonry_arch_ovhg_left,	gs_masonry_arch_height, 31	endif	if gs_NicheBelowArch & gs_MasonryArch_height > 0 then		cornerx = 2.0 * bCornerWindow		material _nicheSurface		wallniche 4, 1, 2 + 16 + 256,			0, 0, 1, min(gs_masonry_arch_depth, WIDO_SILL + gs_masonry_arch_proj),			-leftWidth  + gs_reveal_left,				-gs_MasonryArch_height, 31, matRevealSide,			 rightWidth - gs_reveal_right + cornerx,	-gs_MasonryArch_height, 31, matRevealSide,			 rightWidth - gs_reveal_right + cornerx,	0, 31, matRevealSide,			-leftWidth  + gs_reveal_left,				0, 31, matRevealSide	endif	pen gs_masonry_arch_pen	sect_fill gs_masonry_arch_fill, gs_masonry_arch_pen_bg, gs_masonry_arch_pen_fg, WALL_SECT_PEN	if iArchDetail = 1 then		! Stucco Arch		material gs_masonry_arch_brick_mat		if bCurvedWall = 1 then			leftAngle  = (alfaLeft - signWallIsLeft * (not (gs_stack_left)) * alfaOverhangLeft)			rightAngle = (alfaRight + signWallIsLeft * (not (gs_stack_right)) * alfaOverhangRight)			masLength = (abs (leftAngle) + abs (rightAngle)) / 360 * 2 * rrrIn * pi			addz WOD + WIDO_SILL + gs_masonry_arch_proj 		! moving origo to the center or curved wall			rotx -90			rotz -leftAngle			addy signWallisLeft * rrrIn			if wallIsLeft then muly -1			bwall_  gs_masonry_arch_brick_mat, gs_masonry_arch_brick_mat, gs_masonry_arch_brick_mat,					gs_masonry_arch_height, 0, masLength, masLength, 0, -signWallIsLeft * gs_masonry_arch_depth, rrrIn,					15, 15, 15, 15, 0, 0			txAngle = 90 : gosub 201			del 3			if wallIsLeft then del 1		else			prism 4, gs_masonry_arch_depth,				-leftWidth  + gs_reveal_left  - gs_masonry_arch_ovhg_left,	0,				 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right,	0,				 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right,	gs_masonry_arch_height,				-leftWidth  + gs_reveal_left  - gs_masonry_arch_ovhg_left,	gs_masonry_arch_height			txAngle = 90: gosub 200		endif	endif	if iArchDetail = 2 then		! Brick Arch		if bCurvedWall then			alfaBrick = 360 * gs_masonry_arch_brick_thk / (2 * (rrrIn + signWallisLeft * gs_masonry_arch_depth) * pi)			alfaMortar = 360 * gs_masonry_arch_mort_thk / (2 * (rrrIn + signWallisLeft * (gs_masonry_arch_depth - masonryArchMortInset)) * pi)			leftAngle  = (alfaLeft - signWallIsLeft * (not (gs_stack_left)) * alfaOverhangLeft) + signWallIsLeft * gs_stack_left * alfaBrick/2			rightAngle = (alfaRight + signWallIsLeft * (not (gs_stack_right)) * alfaOverhangRight) - signWallIsLeft * gs_stack_right * alfaBrick/2			mainAngle = (abs (leftAngle) + abs (rightAngle))			numBricks = int ((abs (leftAngle) + abs (rightAngle)) / (alfaBrick + alfaMortar))			alfaMortar = (mainAngle - numBricks * alfaBrick) / (numBricks - 1 + gs_stack_left + gs_stack_right)			alfaStep = alfaBrick + alfaMortar			addz WOD + WIDO_SILL + gs_masonry_arch_proj 		! moving origo to the center or curved wall			rotx -90			rotz -leftAngle			if wallIsLeft then muly -1			if gs_stack_left then				rotz -alfaBrick / 2				addy - rrrIn - signWallisLeft * gs_masonry_arch_depth				bwall_  gs_masonry_arch_brick_mat, gs_masonry_arch_brick_mat, gs_masonry_arch_brick_mat,						gs_masonry_arch_height, 0, gs_masonry_arch_brick_thk / 2, gs_masonry_arch_brick_thk / 2, 0,						signWallIsLeft * gs_masonry_arch_depth, (rrrIn + signWallIsLeft * gs_masonry_arch_depth),						15, 15, 15, 15, 0, 0				addx -gs_masonry_arch_brick_thk / 2 		! correction of texture !				txAngle = 90 : gosub 201				del 3				rotz alfaMortar			endif			for i = 1 to numBricks				addy - rrrIn - signWallisLeft * gs_masonry_arch_depth				bwall_  gs_masonry_arch_brick_mat, gs_masonry_arch_brick_mat, gs_masonry_arch_brick_mat,						gs_masonry_arch_height, 0, gs_masonry_arch_brick_thk, gs_masonry_arch_brick_thk, 0,						signWallIsLeft * gs_masonry_arch_depth, (rrrIn + signWallIsLeft * gs_masonry_arch_depth),						15, 15, 15, 15, 0, 0				txAngle = 90 : gosub 201				del 1				rotz alfastep			next i			if gs_stack_right then				addy - rrrIn - signWallisLeft * gs_masonry_arch_depth				bwall_  gs_masonry_arch_brick_mat, gs_masonry_arch_brick_mat, gs_masonry_arch_brick_mat,						gs_masonry_arch_height, 0, gs_masonry_arch_brick_thk / 2, gs_masonry_arch_brick_thk / 2, 0,						signWallIsLeft * gs_masonry_arch_depth, (rrrIn + signWallIsLeft * gs_masonry_arch_depth),						15, 15, 15, 15, 0, 0				txAngle = 90 : gosub 201				del 1			endif			del numBricks			if gs_stack_left then del 1			for  i = 1 to numBricks - 1 + gs_stack_left + gs_stack_right				mortarThk = (alfaMortar / 360) * (2 * (rrrIn + signWallIsLeft * (gs_masonry_arch_depth - masonryArchMortInset)) * pi)				if not (gs_stack_left) then rotz +alfaBrick				addy - rrrIn - signWallisLeft * (gs_masonry_arch_depth - masonryArchMortInset)				bwall_  gs_masonry_arch_mort_mat, gs_masonry_arch_mort_mat, gs_masonry_arch_mort_mat,						gs_masonry_arch_height, 0, mortarThk, mortarThk, 0,						signWallIsLeft * (gs_masonry_arch_depth - masonryArchMortInset), rrrIn + signWallIsLeft * (gs_masonry_arch_depth - masonryArchMortInset),						15, 15, 15, 15, 0, 0				txAngle = 90 : gosub 201				if not (gs_stack_left) then del 1				del 1				rotz alfastep			next i			del 3			if wallIsLeft then del 1		else			masonryL  = leftWidth + rightWidth - gs_reveal_left - gs_reveal_right + gs_masonry_arch_ovhg_left + gs_masonry_arch_ovhg_right \							- (gs_stack_left + gs_stack_right) * gs_masonry_arch_brick_thk / 2			numBricks = int(masonryL / (gs_masonry_arch_brick_thk + gs_masonry_arch_mort_thk))			mortarThk  = (masonryL - (numBricks * gs_masonry_arch_brick_thk)) / (numBricks - 1 + gs_stack_left + gs_stack_right)			addx -leftWidth + gs_reveal_left - gs_masonry_arch_ovhg_left			if gs_stack_left then				material gs_masonry_arch_brick_mat				block gs_masonry_arch_brick_thk / 2, gs_masonry_arch_height, gs_masonry_arch_depth				addx -gs_masonry_arch_brick_thk / 2				txAngle = 90 : gosub 200				del 1				addx  gs_masonry_arch_brick_thk / 2				material gs_masonry_arch_mort_mat				block mortarThk, gs_masonry_arch_height, gs_masonry_arch_depth - masonryArchMortInset				addx mortarThk			endif			material gs_masonry_arch_brick_mat			for i=1 to numBricks				block gs_masonry_arch_brick_thk, gs_masonry_arch_height, gs_masonry_arch_depth				txAngle = 90: gosub 200				addx gs_masonry_arch_brick_thk + mortarThk			next i			if gs_stack_right then				material gs_masonry_arch_mort_mat				addx -mortarThk				block mortarThk, gs_masonry_arch_height, gs_masonry_arch_depth - masonryArchMortInset				del 1				material gs_masonry_arch_brick_mat				block gs_masonry_arch_brick_thk / 2, gs_masonry_arch_height, gs_masonry_arch_depth				txAngle = 90 : gosub 200			endif			del numBricks + gs_stack_left * 2			material gs_masonry_arch_mort_mat			for i=1 to numBricks - 1				add gs_masonry_arch_brick_thk + gs_stack_left * (gs_masonry_arch_brick_thk / 2 + mortarThk), 0, masonryArchMortInset				block mortarThk, gs_masonry_arch_height, gs_masonry_arch_depth - masonryArchMortInset				del 1				addx gs_masonry_arch_brick_thk + mortarThk			next i			del numBricks - 1			txAngle = 90: gosub 200			del 1		endif	endifendif! =============================================================================! Masonry Jack Arch! =============================================================================if gs_masonry_arch_int = MASONRY_JACK_ARCH then	dx_right = gs_masonry_arch_height / tan(gs_masonry_arch_skewback_angle) * not (gs_stack_right)	dx_left  = gs_masonry_arch_height / tan(gs_masonry_arch_skewback_angle) * not (gs_stack_left)	pen WALL_VIEW_PEN	material matRevealSide	wallniche 4, 1, 2 + 16,		0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,		-leftWidth  + gs_reveal_left  - gs_masonry_arch_ovhg_left,			0, 31,		 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right,			0, 31,		 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right + dx_right,	gs_masonry_arch_height, 31,		-leftWidth  + gs_reveal_left  - gs_masonry_arch_ovhg_left  - dx_left,	gs_masonry_arch_height, 31	if gs_NicheBelowArch & gs_MasonryArch_height > 0 then		cornerx = 2.0 * bCornerWindow		material _nicheSurface		wallniche 4, 1, 2 + 16 +256,			0, 0, 1, min(gs_masonry_arch_depth, WIDO_SILL + gs_masonry_arch_proj),			-leftWidth  + gs_reveal_left,				-gs_MasonryArch_height, 31, matRevealSide,			 rightWidth - gs_reveal_right + cornerx,	-gs_MasonryArch_height, 31, matRevealSide,			 rightWidth - gs_reveal_right + cornerx,	0, 31, matRevealSide,			-leftWidth  + gs_reveal_left,				0, 31, matRevealSide	endif	pen gs_masonry_arch_pen	sect_fill gs_masonry_arch_fill, gs_masonry_arch_pen_bg, gs_masonry_arch_pen_fg, WALL_SECT_PEN	if iArchDetail = 1 then		! Stucco Arch		material gs_masonry_arch_brick_mat		prism 4, gs_masonry_arch_depth,			-leftWidth  + gs_reveal_left  - gs_masonry_arch_ovhg_left,			0,			 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right,			0,			 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right + dx_right,	gs_masonry_arch_height,			-leftWidth  + gs_reveal_left  - gs_masonry_arch_ovhg_left  - dx_left,	gs_masonry_arch_height		txAngle = 90: gosub 200	endif	if iArchDetail = 2 then		! Brick Arch		masonryL = leftWidth + rightWidth - gs_reveal_left - gs_reveal_right + gs_masonry_arch_ovhg_left + gs_masonry_arch_ovhg_right \				- (gs_stack_left + gs_stack_right) * (gs_masonry_arch_brick_thk / 2 + gs_masonry_arch_mort_thk)		topL = masonryL + dx_left + dx_right		numBricks = max(1, int(topL / (gs_masonry_arch_brick_thk + gs_masonry_arch_mort_thk)))		brickTopThk = (topL - (numBricks - 1) * gs_masonry_arch_mort_thk) / numBricks		alpha_left = -gs_masonry_arch_skewback_angle		alpha_right = -gs_masonry_arch_skewback_angle		if gs_stack_left then alpha_left = -90		if gs_stack_right then alpha_right = -90		da = (180 + alpha_left + alpha_right) / numBricks		alpha = alpha_left		add -leftWidth + gs_reveal_left- gs_masonry_arch_ovhg_left - dx_left, gs_masonry_arch_height, 0		if gs_stack_left then			material gs_masonry_arch_brick_mat			prism 4, gs_masonry_arch_depth,				0,								 0,				gs_masonry_arch_brick_thk/ 2, 	 0,				gs_masonry_arch_brick_thk/ 2,	-gs_masonry_arch_height,				0,								-gs_masonry_arch_height			addx - gs_masonry_arch_brick_thk/ 2			txAngle = -90 : gosub 200			del 1			addz masonryArchMortInset			material gs_masonry_arch_mort_mat			prism 4, gs_masonry_arch_depth - masonryArchMortInset,				 gs_masonry_arch_brick_thk/ 2, 								0,				 gs_masonry_arch_brick_thk/ 2 + gs_masonry_arch_mort_thk, 	0,				 gs_masonry_arch_brick_thk/ 2 + gs_masonry_arch_mort_thk,	-gs_masonry_arch_height,				 gs_masonry_arch_brick_thk/ 2,								-gs_masonry_arch_height			del 1			addx gs_masonry_arch_brick_thk/ 2 + gs_masonry_arch_mort_thk		endif		material gs_masonry_arch_brick_mat		for i=1 to numBricks			prism 4, gs_masonry_arch_depth,				 0,															0,				 brickTopThk, 												0,				 brickTopThk - gs_masonry_arch_height / tan(alpha - da),	-gs_masonry_arch_height,				-gs_masonry_arch_height / tan(alpha),						-gs_masonry_arch_height			txAngle = alpha: gosub 200			alpha = alpha - da			addx brickTopThk + gs_masonry_arch_mort_thk		next i		if gs_stack_right then			material gs_masonry_arch_mort_mat			addz masonryArchMortInset			prism 4, gs_masonry_arch_depth - masonryArchMortInset,				0, 								0,				0 - gs_masonry_arch_mort_thk, 	0,				0 - gs_masonry_arch_mort_thk,	-gs_masonry_arch_height,				0,								-gs_masonry_arch_height			del 1			material gs_masonry_arch_brick_mat			prism 4, gs_masonry_arch_depth,				0,								 0,				gs_masonry_arch_brick_thk/ 2, 	 0,				gs_masonry_arch_brick_thk/ 2,	-gs_masonry_arch_height,				0,								-gs_masonry_arch_height			txAngle = -90 : gosub 200		endif		del numBricks		addz masonryArchMortInset		material gs_masonry_arch_mort_mat		alpha_left  = -gs_masonry_arch_skewback_angle		alpha_right = -gs_masonry_arch_skewback_angle		if gs_stack_left  then alpha_left  = -90		if gs_stack_right then alpha_right = -90		da = (180 + alpha_left + alpha_right) / numBricks		alpha = alpha_left		for i=1 to numBricks - 1			prism 4, gs_masonry_arch_depth - masonryArchMortInset,				 brickTopThk, 																		0,				 brickTopThk + gs_masonry_arch_mort_thk, 											0,				 brickTopThk + gs_masonry_arch_mort_thk - gs_masonry_arch_height / tan(alpha - da),	-gs_masonry_arch_height,				 brickTopThk - gs_masonry_arch_height / tan(alpha - da),							-gs_masonry_arch_height			alpha = alpha - da			addx brickTopThk + gs_masonry_arch_mort_thk		next i		del numBricks + 1 + gs_stack_left	endifendif! =============================================================================! Masonry Jack Arch with Keystone! =============================================================================if gs_masonry_arch_int = MASONRY_JACK_ARCH_KEYSTONE then	gs_masonry_arch_keystone_angle = gs_masonry_arch_skewback_angle	dx = gs_masonry_arch_height / tan(gs_masonry_arch_skewback_angle)	dx_left  = gs_masonry_arch_height / tan(gs_masonry_arch_skewback_angle) * not (gs_stack_left)	dx_right = gs_masonry_arch_height / tan(gs_masonry_arch_skewback_angle) * not (gs_stack_right)	if not (gs_stack_left) and not (gs_stack_right) then		cx = (gs_reveal_left - gs_masonry_arch_ovhg_left - gs_reveal_right + gs_masonry_arch_ovhg_right) / 2	! Keystone center position	else		if gs_stack_left then			cx = - leftWidth - gs_masonry_arch_ovhg_left		else			cx = rightWidth + gs_masonry_arch_ovhg_right		endif	endif	ky  = gs_masonry_arch_height + gs_masonry_arch_keystone_osize	kdx = ky / tan(gs_masonry_arch_keystone_angle)	pen WALL_VIEW_PEN	material matRevealSide	wallniche 4, 1, 2 + 16,		0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,		-leftWidth  + gs_reveal_left  - gs_masonry_arch_ovhg_left,				0, 31,		 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right,				0, 31,		 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right + dx_right,	gs_masonry_arch_height, 31,		-leftWidth  + gs_reveal_left  - gs_masonry_arch_ovhg_left  - dx_left,	gs_masonry_arch_height, 31	if gs_NicheBelowArch & gs_MasonryArch_height > 0 then		cornerx = 2.0 * bCornerWindow		material _nicheSurface		wallniche 4, 1, 2 + 16 +256,			0, 0, 1, min(gs_masonry_arch_depth, WIDO_SILL + gs_masonry_arch_proj),			-leftWidth  + gs_reveal_left,				-gs_MasonryArch_height, 31, matRevealSide,			 rightWidth - gs_reveal_right + cornerx,	-gs_MasonryArch_height, 31, matRevealSide,			 rightWidth - gs_reveal_right + cornerx,	0, 31, matRevealSide,			-leftWidth  + gs_reveal_left,				0, 31, matRevealSide	endif	if gs_masonry_arch_keystone_osize > EPS then		addx cx		wallniche 4, 1, 2 + 16,			0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,			(-gs_masonry_arch_keystone_width/2) * not (gs_stack_left),			0,	31,			(-gs_masonry_arch_keystone_width/2 - kdx) * not (gs_stack_left),	ky,	31,			( gs_masonry_arch_keystone_width/2 + kdx) * not (gs_stack_right),	ky,	31,			( gs_masonry_arch_keystone_width/2) * not (gs_stack_right),			0,	31		del 1	endif	pen gs_masonry_arch_pen	sect_fill gs_masonry_arch_fill, gs_masonry_arch_pen_bg, gs_masonry_arch_pen_fg, WALL_SECT_PEN	addx cx	gosub 100	! Keystone	del 1	if iArchDetail = 1 then		! Stucco Arch		material gs_masonry_arch_brick_mat		if not (gs_stack_left) then			prism 4, gs_masonry_arch_depth,				-leftWidth + gs_reveal_left  - gs_masonry_arch_ovhg_left,				0,				-leftWidth + gs_reveal_left  - gs_masonry_arch_ovhg_left  - dx_left,	gs_masonry_arch_height,				cx - gs_masonry_arch_keystone_width/2 - dx_left,						gs_masonry_arch_height,				cx - gs_masonry_arch_keystone_width/2,									0			txAngle = -gs_masonry_arch_keystone_angle: gosub 200		endif		if not (gs_stack_right) then			prism 4, gs_masonry_arch_depth,				 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right,				0,				 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right + dx_right,	gs_masonry_arch_height,				 cx + gs_masonry_arch_keystone_width/2 + dx_right,						gs_masonry_arch_height,				 cx + gs_masonry_arch_keystone_width/2,									0			txAngle = gs_masonry_arch_keystone_angle: gosub 200		endif	else		! iArchDetail = 2 - Brick arch		brickThk = gs_masonry_arch_brick_thk / sin(gs_masonry_arch_skewback_angle)		masonryL  = (leftWidth + rightWidth - (gs_masonry_arch_keystone_width / (1 + (gs_stack_left or gs_stack_right)))  - gs_reveal_left - gs_reveal_right + gs_masonry_arch_ovhg_left + gs_masonry_arch_ovhg_right) / (2 - (gs_stack_left or gs_stack_right))		numBricks = max(1, int(masonryL / (brickThk + gs_masonry_arch_mort_thk / sin(gs_masonry_arch_skewback_angle))))		mortarThk  = (masonryL - (numBricks * brickThk)) / numBricks		add -leftWidth + gs_reveal_left - gs_masonry_arch_ovhg_left - dx, gs_masonry_arch_height, 0		material gs_masonry_arch_brick_mat		if not (gs_stack_left) then			for i=1 to numBricks				prism 4, gs_masonry_arch_depth,					0,				0,					brickThk,		0,					brickThk + dx,	-gs_masonry_arch_height,					dx,				-gs_masonry_arch_height				txAngle = -gs_masonry_arch_skewback_angle: gosub 200				addx brickThk + mortarThk			next i			del numBricks			addz masonryArchMortInset			material gs_masonry_arch_mort_mat			for i=1 to numBricks				prism 4, gs_masonry_arch_depth - masonryArchMortInset,					brickThk + mortarThk,		 0,					brickThk + dx + mortarThk,	-gs_masonry_arch_height,					dx + brickThk,				-gs_masonry_arch_height,					brickThk,					 0				addx brickThk + mortarThk			next i			del numBricks + 1		endif		del 1		add rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right + dx, gs_masonry_arch_height, 0		material gs_masonry_arch_brick_mat		if not (gs_stack_right) then			for i=1 to numBricks				prism 4, gs_masonry_arch_depth,					 0,				0,					-brickThk,		0,					-brickThk - dx,	-gs_masonry_arch_height,					-dx,			-gs_masonry_arch_height				txAngle = gs_masonry_arch_skewback_angle: gosub 200				addx -brickThk - mortarThk			next i			del numBricks			addz masonryArchMortInset			material gs_masonry_arch_mort_mat			for i=1 to numBricks				prism 4, gs_masonry_arch_depth - masonryArchMortInset,					-brickThk - mortarThk,		 0,					-brickThk - dx - mortarThk,	-gs_masonry_arch_height,					-dx - brickThk,				-gs_masonry_arch_height,					-brickThk,					 0				addx -brickThk - mortarThk			next i			del numBricks + 1		endif		del 1	endifendif! =============================================================================! Masonry Segmented Arch! =============================================================================if gs_masonry_arch_int = MASONRY_SEGMENT_ARCH then	gs_masonry_arch_ovhg_left	= max(EPS, gs_masonry_arch_ovhg_left)	! #118029 workaround	gs_masonry_arch_ovhg_right	= max(EPS, gs_masonry_arch_ovhg_right)	masonrySpan = leftWidth + rightWidth - gs_reveal_left - gs_reveal_right + gs_masonry_arch_ovhg_left + gs_masonry_arch_ovhg_right	nominalMasonrySpan = leftWidth + rightWidth + gs_masonry_arch_ovhg_left + gs_masonry_arch_ovhg_right	Ri = (nominalMasonrySpan / 2) / sin(2 * atn(openingArchHeight / (nominalMasonrySpan / 2))) - gs_reveal_top		! Intrados radius	cx = (gs_reveal_left - gs_masonry_arch_ovhg_left - gs_reveal_right + gs_masonry_arch_ovhg_right) / 2	! Keystone center position	if Ri - openingArchHeight + gs_reveal_top > EPS then		alpha = acs(masonrySpan/2 / Ri)	else		alpha = 0	endif	Re = Ri + gs_masonry_arch_height	! Extrados radius	add cx, -Ri, 0	if iWindowShape = SHAPE_RECTANGULAR then		addy Ri - sqr(Ri^2 - (masonrySpan / 2)^2 )	endif	if iArchDetail = 1 then		! Stucco Arch		px1 = Ri * cos(alpha)		py1 = Ri * sin(alpha)		px2 = Re * cos(alpha)		py2 = Re * sin(alpha)		pen WALL_VIEW_PEN		material matRevealSide		if iWindowShape = SHAPE_ARCHED then			resol nArchResolution		else			toler 0.001 + (90 - alpha) / 225000	! range: 0.001 - 0.005		endif		if iWindowShape = SHAPE_RECTANGULAR | (iWindowShape = SHAPE_ARCHED & (abs(gs_MasonryArch_height)>EPS & not(gs_AutomaticArchHeight))) then			wallniche 6, 1, 2 + 16,				0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,				 px1,	py1,	31,				 px2,	py2,	95,				 0,		0,		900,				-px2,	py2,	3095,				-px1,	py1,	95,				 px1,	py1,	3095			if gs_NicheBelowArch then				alf_a = asn(px1 / Ri)				alf_r = asn((px1 - gs_masonry_arch_ovhg_right) / Ri)				aaa = (refwidth) - WIDO_RIGHT_JAMB - WIDO_LEFT_JAMB				oha = aaa + gs_masonry_arch_ovhg_right + gs_masonry_arch_ovhg_left				tdcR = oha/2 - gs_masonry_arch_ovhg_right - aaa/2				tdcL = oha/2 - gs_masonry_arch_ovhg_left  - aaa/2				if px1 < Ri then					xxkR =  px1 - gs_masonry_arch_ovhg_right					xxkL = -px1 + gs_masonry_arch_ovhg_left				else					xxkR =  px1 - Ri + tdcR + aaa/2					xxkL = -px1 + Ri - tdcL - aaa/2				endif				material _nicheSurface				wallniche 6, 1, 2 + 16 + 256,					0, 0, 1, min(gs_masonry_arch_depth, WIDO_SILL + gs_masonry_arch_proj),					xxkR, py1 - gs_MasonryArch_height - EPS, 31, matRevealSide,					xxkL, py1 - gs_MasonryArch_height - EPS, 31, matRevealSide,					xxkL, sqr(Ri*Ri-(xxkL)*(xxkL)) + gs_masonry_arch_height/2, 0, matRevealSide,					0, 0, 900, matRevealSide,					xxkR, sqr(Ri*Ri-(xxkR)*(xxkR)) + gs_masonry_arch_height/2, 3095, matRevealSide,					xxkR, sqr(Ri*Ri-(xxkR)*(xxkR)), 31, matRevealSide			endif		else			wallniche 5, 1, 2 + 16,				0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,				 px1,	py1,	31,				 px2,	py2,	95,				 0,		0,		900,				-px2,	py2,	3095,				-px1,	py1,	31		endif		pen gs_masonry_arch_pen		sect_fill gs_masonry_arch_fill, gs_masonry_arch_pen_bg, gs_masonry_arch_pen_fg, WALL_SECT_PEN		material gs_masonry_arch_brick_mat		prism_ 7, gs_masonry_arch_depth,			 px1,	py1,	15,			 px2,	py2,	79,			 0,		0,		900,			-px2,	py2,	3079,			-px2,	py2,	15,			-px1,	py1,	79,			 px1,	py1,	3079		txAngle = 90: gosub 200	endif	if iArchDetail = 2 then		! Brick Arch		masonryL = Re * (2 * (90 - alpha)) * PI / 180		! arch length of extrados		numBricks = max(1, int(masonryL / (gs_masonry_arch_brick_thk + gs_masonry_arch_mort_thk)))		mortarThk  = (masonryL - (numBricks * gs_masonry_arch_brick_thk)) / (numBricks - 1)		ArcLengthExtradosToAngle = 180 / Re / PI		brickAngle  = gs_masonry_arch_brick_thk * ArcLengthExtradosToAngle		mortarAngle = mortarThk * ArcLengthExtradosToAngle		! Wallhole ============================================================		px1 = Ri * cos(alpha)		py1 = Ri * sin(alpha)		actAlpha = alpha		for i=1 to numBricks			put Re * cos(actAlpha),				 Re * sin(actAlpha),			  95,				Re * cos(actAlpha + brickAngle), Re * sin(actAlpha + brickAngle), 95			actAlpha = actAlpha + brickAngle + mortarAngle		next i		pen WALL_VIEW_PEN		material matRevealSide		if iWindowShape = SHAPE_RECTANGULAR | (iWindowShape = SHAPE_ARCHED & (abs(gs_MasonryArch_height)>EPS & not(gs_AutomaticArchHeight))) then			for i=1 to numBricks				put Ri * cos(actAlpha - mortarAngle),				Ri * sin(actAlpha - mortarAngle),				95,					Ri * cos(actAlpha - brickAngle - mortarAngle),	Ri * sin(actAlpha - brickAngle - mortarAngle),	95				actAlpha = actAlpha - brickAngle - mortarAngle			next i			wallniche nsp/3, 1, 2 + 16,				0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,				 get(nsp)			if gs_NicheBelowArch then				if iWindowShape = SHAPE_ARCHED then					resol nArchResolution				else					toler 0.001 + (90 - alpha) / 225000	! range: 0.001 - 0.005				endif				alf_a=asn(px1 / Ri)				alf_r=asn((px1 - gs_masonry_arch_ovhg_right) / Ri)				aaa = (refwidth) - WIDO_RIGHT_JAMB - WIDO_LEFT_JAMB				oha = aaa + gs_masonry_arch_ovhg_right + gs_masonry_arch_ovhg_left				tdcR = oha/2 - gs_masonry_arch_ovhg_right - aaa/2				tdcL = oha/2 - gs_masonry_arch_ovhg_left  - aaa/2				if px1 < Ri then					xxkR =  px1 - gs_masonry_arch_ovhg_right					xxkL = -px1 + gs_masonry_arch_ovhg_left				else					xxkR =  px1 - Ri + tdcR + aaa/2					xxkL = -px1 + Ri - tdcL - aaa/2				endif				material _nicheSurface				wallniche 6, 1, 2 + 16 + 256,					0, 0, 1, min(gs_masonry_arch_depth, WIDO_SILL + gs_masonry_arch_proj),					xxkR, py1-gs_MasonryArch_height-eps, 31, matRevealSide,					xxkL, py1-gs_MasonryArch_height-eps, 31, matRevealSide,					xxkL, sqr(Ri*Ri-(xxkL)*(xxkL))+gs_masonry_arch_height/2, 0, matRevealSide,					0, 0, 900, matRevealSide,					xxkR, sqr(Ri*Ri-(xxkR)*(xxkR))+gs_masonry_arch_height/2, 3095, matRevealSide,					xxkR, sqr(Ri*Ri-(xxkR)*(xxkR)), 31, matRevealSide			endif		else			wallniche nsp/3 + 2, 1, 2 + 16,				0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,				 px1,	py1,	31,				 get(nsp),				-px1,	py1,	31		endif		! Bricks ==============================================================		pen gs_masonry_arch_pen		sect_fill gs_masonry_arch_fill, gs_masonry_arch_pen_bg, gs_masonry_arch_pen_fg, WALL_SECT_PEN		rotz alpha - 90		material gs_masonry_arch_brick_mat		px1 = -Ri * sin(brickAngle)		py1 =  Ri * cos(brickAngle)		px2 = -Re * sin(brickAngle)		py2 =  Re * cos(brickAngle)		for i=1 to numBricks			prism 4, gs_masonry_arch_depth,				0,		Re,				0,		Ri,				px1,	py1,				px2,	py2			rotz brickAngle + mortarAngle			txAngle = 90 - brickAngle/2: gosub 200		next i		del numBricks + 1		! Mortar ==============================================================		rotz alpha - 90 + brickAngle		addz masonryArchMortInset		px1 = -Ri * sin(mortarAngle)		py1 =  Ri * cos(mortarAngle)		px2 = -Re * sin(mortarAngle)		py2 =  Re * cos(mortarAngle)		material gs_masonry_arch_mort_mat		for i=1 to numBricks - 1			prism 4, gs_masonry_arch_depth - masonryArchMortInset,				0,		Re,				0,		Ri,				px1,	py1,				px2,	py2			rotz brickAngle + mortarAngle			txAngle = 90 - brickAngle/2: gosub 200		next i		del numBricks - 1	endif	del 1endif! =============================================================================! Masonry Segmented Arch with Keystone! =============================================================================if gs_masonry_arch_int = MASONRY_SEGMENT_ARCH_KEYSTONE then	gs_masonry_arch_ovhg_left	= max(EPS, gs_masonry_arch_ovhg_left)	! #118029 workaround	gs_masonry_arch_ovhg_right	= max(EPS, gs_masonry_arch_ovhg_right)	masonrySpan = leftWidth + rightWidth - gs_reveal_left - gs_reveal_right + gs_masonry_arch_ovhg_left + gs_masonry_arch_ovhg_right	nominalMasonrySpan = leftWidth + rightWidth + gs_masonry_arch_ovhg_left + gs_masonry_arch_ovhg_right	Ri = (nominalMasonrySpan / 2) / sin(2 * atn(openingArchHeight / (nominalMasonrySpan / 2))) - gs_reveal_top		! Intrados radius	cx = (gs_reveal_left - gs_masonry_arch_ovhg_left - gs_reveal_right + gs_masonry_arch_ovhg_right) / 2	! Keystone center position	if Ri - openingArchHeight + gs_reveal_top > EPS then		alpha = asn(masonrySpan/2 / Ri)	else		alpha = 90	endif	Re = Ri + gs_masonry_arch_height	! Extrados radius	gs_masonry_arch_keystone_angle = 90 - acs(gs_masonry_arch_keystone_width/2 / Ri)	ky  = (gs_masonry_arch_height + gs_masonry_arch_keystone_osize) * cos(gs_masonry_arch_keystone_angle)	kdx = ky / tan(90 - gs_masonry_arch_keystone_angle)	cy = sqr(Ri^2 - (gs_masonry_arch_keystone_width/2)^2)	add cx, -Ri, 0	if iWindowShape = SHAPE_RECTANGULAR then		addy Ri - sqr(Ri^2 - (masonrySpan / 2)^2 )	endif	! Keystone's wallhole	if gs_masonry_arch_keystone_osize > EPS then		addy cy		pen WALL_VIEW_PEN		material matRevealSide		wallniche 4, 1, 2 + 16,			0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,			-gs_masonry_arch_keystone_width/2,			0,	31,			-gs_masonry_arch_keystone_width/2 - kdx,	ky,	31,			 gs_masonry_arch_keystone_width/2 + kdx,	ky,	31,			 gs_masonry_arch_keystone_width/2,			0,	31		del 1	endif	if iArchDetail = 1 then		! Stucco Arch		px1 = Ri * sin(alpha)		py1 = Ri * cos(alpha)		px2 = Re * sin(alpha)		py2 = Re * cos(alpha)		px3 = Ri * sin(gs_masonry_arch_keystone_angle)		py3 = Ri * cos(gs_masonry_arch_keystone_angle)		px4 = Re * sin(gs_masonry_arch_keystone_angle)		py4 = Re * cos(gs_masonry_arch_keystone_angle)		pen WALL_VIEW_PEN		material matRevealSide		if iWindowShape = SHAPE_ARCHED then			resol nArchResolution		else			toler 0.001 + alpha / 22500	! range: 0.001 - 0.005		endif		if iWindowShape = SHAPE_RECTANGULAR | (iWindowShape = SHAPE_ARCHED & (abs(gs_MasonryArch_height)>EPS & not(gs_AutomaticArchHeight))) then			wallniche 10, 1, 2 + 16,				0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,				 px1,	py1,	31,				 px2,	py2,	95,				 0,		0,		900,				 px4,	py4,	3095,				-px4,	py4,	95,				-px2,	py2,	3095,				-px1,	py1,	31,				-px3,	py3,	3095,				 px3,	py3,	95,				 px1,	py1,	3095			if gs_NicheBelowArch then				alf_a = asn(px1 / Ri)				alf_r = asn((px1 - gs_masonry_arch_ovhg_right) / Ri)				aaa = (refwidth) - WIDO_RIGHT_JAMB - WIDO_LEFT_JAMB				oha = aaa + gs_masonry_arch_ovhg_right + gs_masonry_arch_ovhg_left				tdcR = oha/2 - gs_masonry_arch_ovhg_right - aaa/2				tdcL = oha/2 - gs_masonry_arch_ovhg_left  - aaa/2				if px1 < Ri then					xxkR =  px1 - gs_masonry_arch_ovhg_right					xxkL = -px1 + gs_masonry_arch_ovhg_left				else					xxkR =  px1 - Ri + tdcR + aaa/2					xxkL = -px1 + Ri - tdcL - aaa/2				endif				material _nicheSurface				wallniche 6, 1, 2 + 16 + 256,					0, 0, 1, min(gs_masonry_arch_depth, WIDO_SILL + gs_masonry_arch_proj),					xxkR, py1-gs_MasonryArch_height-eps, 31, matRevealSide,					xxkL, py1-gs_MasonryArch_height-eps, 31, matRevealSide,					xxkL, sqr(Ri*Ri-(xxkL)*(xxkL))+gs_masonry_arch_height/2, 0, matRevealSide,					0, 0, 900, matRevealSide,					xxkR, sqr(Ri*Ri-(xxkR)*(xxkR))+gs_masonry_arch_height/2, 3095, matRevealSide,					xxkR, sqr(Ri*Ri-(xxkR)*(xxkR)), 31, matRevealSide			endif		else			wallniche 7, 1, 2 + 16,				0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,				 px1,	py1,	31,				 px2,	py2,	95,				 0,		0,		900,				 px4,	py4,	3095,				-px4,	py4,	95,				-px2,	py2,	3095,				-px1,	py1,	31		endif		pen gs_masonry_arch_pen		sect_fill gs_masonry_arch_fill, gs_masonry_arch_pen_bg, gs_masonry_arch_pen_fg, WALL_SECT_PEN		material gs_masonry_arch_brick_mat		prism_ 7, gs_masonry_arch_depth,			 px1,	py1,	15,			 px2,	py2,	79,			 0,		0,		900,			 px4,	py4,	3079,			 px4,	py4,	15,			 px3,	py3,	79,			 px1,	py1,	3079		txAngle = 90 - alpha/2: gosub 200		prism_ 7, gs_masonry_arch_depth,			-px1,	py1,	15,			-px2,	py2,	79,			 0,		0,		900,			-px4,	py4,	3079,			-px4,	py4,	15,			-px3,	py3,	79,			-px1,	py1,	3079		txAngle = 90 + alpha/2: gosub 200		addy cy		gosub 100	! Keystone		del 1	endif	if iArchDetail = 2 then		! Brick Arch		masonryL = Re * ((alpha - gs_masonry_arch_keystone_angle)) * PI / 180		! arch length of extrados		numBricks = max(1, int(masonryL / (gs_masonry_arch_brick_thk + gs_masonry_arch_mort_thk)))		mortarThk  = (masonryL - (numBricks * gs_masonry_arch_brick_thk)) / (numBricks - 0)		ArcLengthExtradosToAngle = 180 / Re / PI		brickAngle  = gs_masonry_arch_brick_thk * ArcLengthExtradosToAngle		mortarAngle = mortarThk * ArcLengthExtradosToAngle		! Wallhole ============================================================		actAlpha = 90 - alpha		for i=1 to numBricks			put Re * cos(actAlpha),				 Re * sin(actAlpha),			  95,				Re * cos(actAlpha + brickAngle), Re * sin(actAlpha + brickAngle), 95			actAlpha = actAlpha + brickAngle + mortarAngle		next i		actAlpha = 90 + gs_masonry_arch_keystone_angle		for i=1 to numBricks			put Re * cos(actAlpha),				  Re * sin(actAlpha),				95,				Re * cos(actAlpha + mortarAngle), Re * sin(actAlpha + mortarAngle), 95			actAlpha = actAlpha + brickAngle + mortarAngle		next i		put Re * cos(actAlpha),				  Re * sin(actAlpha),				95		pen WALL_VIEW_PEN		material matRevealSide		if iWindowShape = SHAPE_RECTANGULAR | (iWindowShape = SHAPE_ARCHED & (abs(gs_MasonryArch_height)>EPS & not(gs_AutomaticArchHeight))) then			for i=1 to numBricks				put Ri * cos(actAlpha),					Ri * sin(actAlpha),					95,					Ri * cos(actAlpha - brickAngle),	Ri * sin(actAlpha - brickAngle),	95				actAlpha = actAlpha - brickAngle - mortarAngle			next i			put Ri * cos(actAlpha),				  Ri * sin(actAlpha),				95			actAlpha = 90 - gs_masonry_arch_keystone_angle			for i=1 to numBricks				put Ri * cos(actAlpha),				  Ri * sin(actAlpha),				95,					Ri * cos(actAlpha - mortarAngle), Ri * sin(actAlpha - mortarAngle), 95				actAlpha = actAlpha - brickAngle - mortarAngle			next i			put Ri * cos(actAlpha),				  Ri * sin(actAlpha),				95			wallniche nsp/3, 1, 2 + 16,				0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,				 get(nsp)			if gs_NicheBelowArch then				if iWindowShape = SHAPE_ARCHED then					resol nArchResolution				else					toler 0.001 + (90 - alpha) / 225000	! range: 0.001 - 0.005				endif				px1 = Ri * sin(alpha)				py1 = Ri * cos(alpha)				alf_a = asn(px1 / Ri)				alf_r = asn((px1 - gs_masonry_arch_ovhg_right) / Ri)				aaa = (refwidth) - WIDO_RIGHT_JAMB - WIDO_LEFT_JAMB				oha = aaa + gs_masonry_arch_ovhg_right + gs_masonry_arch_ovhg_left				tdcR = oha/2 - gs_masonry_arch_ovhg_right - aaa/2				tdcL = oha/2 - gs_masonry_arch_ovhg_left  - aaa/2				if px1 < Ri then					xxkR =  px1 - gs_masonry_arch_ovhg_right					xxkL = -px1 + gs_masonry_arch_ovhg_left				else					xxkR =  px1 - Ri + tdcR + aaa/2					xxkL = -px1 + Ri - tdcL - aaa/2				endif				material _nicheSurface				wallniche 6, 1, 2 + 16 + 256,					0, 0, 1, min(gs_masonry_arch_depth, WIDO_SILL + gs_masonry_arch_proj),					xxkR, py1-gs_MasonryArch_height-eps, 31, matRevealSide,					xxkL, py1-gs_MasonryArch_height-eps, 31, matRevealSide,					xxkL, sqr(Ri*Ri-(xxkL)*(xxkL))+gs_masonry_arch_height/2, 0, matRevealSide,					0, 0, 900, matRevealSide,					xxkR, sqr(Ri*Ri-(xxkR)*(xxkR))+gs_masonry_arch_height/2, 3095, matRevealSide,					xxkR, sqr(Ri*Ri-(xxkR)*(xxkR)), 31, matRevealSide			endif		else			px1 = Ri * sin(alpha)			py1 = Ri * cos(alpha)			wallniche nsp/3 + 2, 1, 2 + 16,				0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,				 px1,	py1,	31,				 get(nsp),				-px1,	py1,	31		endif		! Bricks ==============================================================		pen gs_masonry_arch_pen		sect_fill gs_masonry_arch_fill, gs_masonry_arch_pen_bg, gs_masonry_arch_pen_fg, WALL_SECT_PEN		material gs_masonry_arch_brick_mat		px1 = -Ri * sin(brickAngle)		py1 =  Ri * cos(brickAngle)		px2 = -Re * sin(brickAngle)		py2 =  Re * cos(brickAngle)		for j=1 to 2			rotz -alpha			for i=1 to numBricks				prism 4, gs_masonry_arch_depth,					0,		Re,					0,		Ri,					px1,	py1,					px2,	py2				rotz brickAngle + mortarAngle				txAngle = 90 - brickAngle/2: gosub 200			next i			del numBricks + 1			mulx -1		next j		del 2		! Mortar ==============================================================		px1 = -Ri * sin(mortarAngle)		py1 =  Ri * cos(mortarAngle)		px2 = -Re * sin(mortarAngle)		py2 =  Re * cos(mortarAngle)		material gs_masonry_arch_mort_mat		for j=1 to 2			rotz -alpha + brickAngle			addz masonryArchMortInset			for i=1 to numBricks				prism 4, gs_masonry_arch_depth - masonryArchMortInset,					0,		Re,					0,		Ri,					px1,	py1,					px2,	py2				rotz brickAngle + mortarAngle				txAngle = 90 - brickAngle/2: gosub 200			next i			del numBricks + 2			mulx -1		next j		del 2		addy cy		gosub 100	! Keystone		del 1	endifendif! =============================================================================! Masonry Bullseye Arch! =============================================================================if gs_masonry_arch_int = MASONRY_BULLSEYE_ARCH then	Ra = (leftWidth + rightWidth) / 2 - gs_reveal_right + gs_masonry_arch_height	Rb = B / 2 - gs_reveal_top + gs_masonry_arch_height	addy gs_reveal_top - B/2	if iArchDetail = 1 then		! Stucco Arch		pen WALL_VIEW_PEN		material matRevealSide		mulx Ra/Rb		wallniche 2, 1, 2 + 16,			0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,			0,0, 995,			Rb, 360, 4095		del 1		mulx (Ra - gs_masonry_arch_height) / (Rb - gs_masonry_arch_height)		cutpolya 2,1,0,			0,0, 979,			Rb - gs_masonry_arch_height, 360, 4079		del 1		pen gs_masonry_arch_pen		sect_fill gs_masonry_arch_fill, gs_masonry_arch_pen_bg, gs_masonry_arch_pen_fg, WALL_SECT_PEN		material gs_masonry_arch_brick_mat		mulx Ra/Rb		prism_ 2, gs_masonry_arch_depth,			0,0, 979,			Rb, 360, 4079		txAngle = 90 - alpha/2: gosub 200		del 1		cutend	endif	if iArchDetail = 2 then		! Brick Arch		masonryL = PI * (3 * (Ra + Rb) - sqr((Ra + 3 * Rb) * (3 * Ra + Rb)))		! arch length of extrados (approximation: Ramanujan II)		numBricks = max(1, int(masonryL / (gs_masonry_arch_brick_thk + gs_masonry_arch_mort_thk)))		mortarThk  = (masonryL - (numBricks * gs_masonry_arch_brick_thk)) / (numBricks - 0)		Rc = sqr(abs(Ra^2 - Rb^2))		if Ra > Rb then			Rca = Rc			Rcb = 0		else			Rca = 0			Rcb = Rc		endif		ArcLengthExtradosToAngle = 180 / ((Ra + Rb) / 2) / PI		brickAngle  = gs_masonry_arch_brick_thk * ArcLengthExtradosToAngle		mortarAngle = 360 / numBricks - brickAngle		! Wallhole ============================================================		if Ra > Rb then			actAlpha = 90-brickAngle/2		else			actAlpha = -brickAngle/2		endif		for i=1 to numBricks			put	Rb * sin(actAlpha),	-Rb * cos(actAlpha),								95,				Rb * sin(actAlpha + brickAngle),	-Rb * cos(actAlpha + brickAngle),	95			actAlpha = actAlpha + brickAngle + mortarAngle		next i		pen WALL_VIEW_PEN		material matRevealSide		mulx Ra/Rb		wallniche nsp/3, 1, 2 + 16,			0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,			 get(nsp)		del 1		! Cutpoly =============================================================		mulx (Ra - gs_masonry_arch_height) / (Rb - gs_masonry_arch_height)		cutpolya 2,1,0,			0,0, 979,			Rb - gs_masonry_arch_height, 360, 4079		del 1		! Bricks ==============================================================		pen gs_masonry_arch_pen		sect_fill gs_masonry_arch_fill, gs_masonry_arch_pen_bg, gs_masonry_arch_pen_fg, WALL_SECT_PEN		material gs_masonry_arch_brick_mat		px1 = -Rb * sin(brickAngle)		py1 =  Rb * cos(brickAngle)		mulx Ra/Rb		if Ra > Rb then			actAlpha = 90-brickAngle/2		else			actAlpha = -brickAngle/2		endif		for i=1 to numBricks			RefAlpha = actAlpha + brickAngle/2			t = sin(RefAlpha) / 2			cx = t * Rca / 2			t = -cos(RefAlpha) / 2			cy = t * Rcb / 2			prism 3, gs_masonry_arch_depth,				cx,		cy,				Rb * sin(actAlpha),	-Rb * cos(actAlpha),				Rb * sin(actAlpha + brickAngle),	-Rb * cos(actAlpha + brickAngle)			actAlpha = actAlpha + brickAngle + mortarAngle			txAngle = 90 + RefAlpha: gosub 200		next i		del 1		! Mortar ==============================================================		material gs_masonry_arch_mort_mat		mulx Ra/Rb		if Ra > Rb then			actAlpha = 90-brickAngle/2		else			actAlpha = -brickAngle/2		endif		for i=1 to numBricks			RefAlpha = actAlpha + brickAngle/2			t = sin(RefAlpha) / 2			cx = t * Rca / 2			t = -cos(RefAlpha) / 2			cy = t * Rcb / 2			t = sin(RefAlpha + brickAngle + mortarAngle) / 2			cx2 = t * Rca / 2			t = -cos(RefAlpha + brickAngle + mortarAngle) / 2			cy2 = t * Rcb / 2			prism 4, gs_masonry_arch_depth,				cx,		cy,				Rb * sin(actAlpha + brickAngle),	-Rb * cos(actAlpha + brickAngle),				Rb * sin(actAlpha + brickAngle + mortarAngle),	-Rb * cos(actAlpha + brickAngle + mortarAngle),				cx2,	cy2			actAlpha = actAlpha + brickAngle + mortarAngle			txAngle = 90 - brickAngle/2: gosub 200		next i		del 1		cutend	endif	del 1endif! ==============================================================================if not(gs_AutomaticArchHeight) then	del 1endifif bCornerWindow or bRightCornerFunction then cutendif bLeftCornerFunction then cutendfor i = 1 to numCuts	cutendnext iend100:! ==============================================================================! Keystone! ------------------------------------------------------------------------------! Input Parameters:!	ky:								height of keystone!	kdy:							width extent of the keystone's top edge!	gs_masonry_arch_depth:			depth of brick arch!	gs_masonry_arch_keystone_proj:	projection of keystone!	gs_masonry_arch_keystone_width	width of keystone at the bottom!	gs_masonry_arch_keystone_mat:	keystone material! ==============================================================================	if gs_masonry_arch_keystone_width < EPS & kdx < EPS then return	material gs_masonry_arch_keystone_mat	addz -gs_masonry_arch_keystone_proj	prism 4, gs_masonry_arch_depth + gs_masonry_arch_keystone_proj,		(-gs_masonry_arch_keystone_width/2) * (not (gs_stack_left) or (gs_masonry_arch_int = MASONRY_SEGMENT_ARCH_KEYSTONE)),			0,		(-gs_masonry_arch_keystone_width/2 - kdx) * (not (gs_stack_left) or (gs_masonry_arch_int = MASONRY_SEGMENT_ARCH_KEYSTONE)),	ky,		 (gs_masonry_arch_keystone_width/2 + kdx) * (not (gs_stack_right) or (gs_masonry_arch_int = MASONRY_SEGMENT_ARCH_KEYSTONE)),	ky,		 (gs_masonry_arch_keystone_width/2) * (not (gs_stack_right) or (gs_masonry_arch_int = MASONRY_SEGMENT_ARCH_KEYSTONE)),			0	txAngle = 0 : gosub 200	del 1return200:! ==============================================================================! Texture alignment! ------------------------------------------------------------------------------! Input Parameters:!	txAngle:			rotation angle of texture! ==============================================================================	base	rotz txAngle	vert 0, 0, 0	vert 1, 0, 0	vert 0, 1, 0	vert 0, 0, 1	coor 2 + 256, -1, -2, -3, -4	body 1	del 1return201:! ==============================================================================! Texture alignment! ------------------------------------------------------------------------------! Input Parameters:!	txAngle:			rotation angle of texture! ==============================================================================	base	roty txAngle	vert 0, 0, 0	vert 1, 0, 0	vert 0, 1, 0	vert 0, 0, 1	coor 2 + 256, -1, -2, -3, -4	body 1	del 1return300:! ==============================================================================! Circle - Line intersection! ------------------------------------------------------------------------------! Input variables:!	EPS:				epsylon!	xo,yo,ro:			circle!	x1,y1, x2,y2		line!! Returned variables:!	state:				0 = no intersection point!						1 = one intersection point (tangential line)!						2 = two intersection points!	xa, ya:				intersection point #1!	xb, yb:				intersection point #2! ==============================================================================	tempX1 = x1 - xo: tempY1 = y1 - yo	tempX2 = x2 - xo: tempY2 = y2 - yo	if abs(tempX2 - tempX1) < EPS then		if abs(ro - abs(tempX1)) < EPS then			state = 1			xa = tempX1			ya = 0			xb = tempX1			yb = 0		else			if abs(ro) - abs(tempX1) < 0 then				state = 0: xa = 0: ya = 0: xb = 0: yb = 0			else				state = 2				xa = tempX1				ya = sqr(ro^2 - tempX1^2)				xb = tempX1				yb = -sqr(ro^2 - tempX1^2)			endif		endif	else		kf = (tempY2 - tempY1) / (tempX2 - tempX1)		ad = 1 + kf^2		bd = 2 * tempY1 * kf - 2 * tempX1 * kf^2		cd = tempY1^2 - 2 * tempX1 * tempY1 * kf + tempX1^2 * kf^2 - ro^2		if bd^2 - 4 * ad * cd < 0 then			state = 0: xa = 0: ya = 0: xb = 0: yb = 0		else			xa = (-bd + sqr(bd^2 - 4 * ad * cd)) / (2 * ad)			ya = tempY1 + (xa - tempX1) * kf			xb = (-bd - sqr(bd^2 - 4 * ad * cd)) / (2 * ad)			yb = tempY1 + (xb - tempX1) * kf			if abs(xa - xb) < EPS then state = 1 else state = 2		endif	endif	if state = 2 then		da = sqr((tempX1 - xa)^2 + (tempY1 - ya)^2)		db = sqr((tempX1 - xb)^2 + (tempY1 - yb)^2)		if db < da then			xxo = xa: yyo = ya			xa = xb:  ya = yb			xb = xxo: yb = yyo		endif	endif	xa = xa + xo: ya = ya + yo	xb = xb + xo: yb = yb + yoreturn301:! ==============================================================================! Select good intersection point after Circle - Line intersection! ------------------------------------------------------------------------------! Input variables:!	state:				intersection status!	wallIsLeft:!	xa, ya:				intersection point #1!	xb, yb:				intersection point #2!! Returned variables:!	cx, cy:				selected intersection point! ==============================================================================	cx = 0	cy = 0	if state = 1 then		cx = xa		cy = ya	endif	if state = 2 then		if wallIsLeft then			if ya < yb then				cx = xb				cy = yb			else				cx = xa				cy = ya			endif		else			if ya > yb then				cx = xb				cy = yb			else				cx = xa				cy = ya			endif		endif	endifreturn1000:! ==============================================================================! Slanted Reveal cutting body! ==============================================================================! Similar as in WallHoleCut macro	if gs_stack_top		then gs_slanted_top_angle	 = 0	if gs_stack_bottom	then gs_slanted_bottom_angle = 0	! 3D turn plaster offsets	if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED then		offsetSlantedLeft	= offsetLeft  + not(bLeftCornerFunction  | gs_stack_left)  * (thkPlasterAtSlantedLeft  / cos(gs_slanted_left_angle))		offsetSlantedRight	= offsetRight + not(bRightCornerFunction | gs_stack_right) * (thkPlasterAtSlantedRight / cos(gs_slanted_right_angle))		offsetSlantedBott	= offsetBott  + not(gs_stack_bottom) * (thkPlasterAtSlantedBottom / cos(gs_slanted_bottom_angle))		offsetSlantedTop	= offsetTop   + not(gs_stack_top)    * (thkPlasterAtSlantedTop    / cos(gs_slanted_top_angle))	else		offsetSlantedLeft	= offsetLeft  - not(bLeftCornerFunction  | gs_stack_left)  * (thkPlasterAtSlanted * tan(gs_slanted_left_angle)  - thkPlasterAtSlantedLeft  / cos(gs_slanted_left_angle))		offsetSlantedRight	= offsetRight - not(bRightCornerFunction | gs_stack_right) * (thkPlasterAtSlanted * tan(gs_slanted_right_angle) - thkPlasterAtSlantedRight / cos(gs_slanted_right_angle))		offsetSlantedBott	= offsetBott  - not(gs_stack_bottom) * (thkPlasterAtSlanted * tan(gs_slanted_bottom_angle) - thkPlasterAtSlantedBottom / cos(gs_slanted_bottom_angle))		offsetSlantedTop	= offsetTop   - not(gs_stack_top)    * (thkPlasterAtSlanted * tan(gs_slanted_top_angle)    - thkPlasterAtSlantedTop    / cos(gs_slanted_top_angle))	endif	if abs(SYMB_POS_Y) < EPS then		offsetSlantedBott = offsetSlantedBott - EPS	endif	dxl = (not(bLeftCornerFunction  | gs_stack_left)  | curvedWall) * slantedDepth * tan(gs_slanted_left_angle)		! --- Left	dxr = (not(bRightCornerFunction | gs_stack_right) | curvedWall) * slantedDepth * tan(gs_slanted_right_angle)	! --- Right	dxt = not(gs_stack_top)    * slantedDepth * tan(gs_slanted_top_angle)											! --- Top	dxb = not(gs_stack_bottom) * slantedDepth * tan(gs_slanted_bottom_angle)										! --- Bottom	if bLeftCornerFunction	then gs_slanted_left_angle	= 0	if bRightCornerFunction	then gs_slanted_right_angle	= 0	if iWindowShape = SHAPE_ARCHED then		if bHalfCircle then			arcRComponentY = 0		else			arcRComponentY = sqr(arcR^2 - rightWidth^2)		endif		shm = sqr((arcR + dxr - offsetSlantedRight)^2 - (rightWidth + dxl - offsetSlantedRight)^2) - arcRComponentY	endif! Cut type selection -----------------------------------------------------------	slantedOpeningWidth	 = openingWidth  - offsetSlantedRight - offsetSlantedLeft	! Width at frame	slantedOpeningHeight = openingHeight - offsetSlantedBott  - offsetSlantedTop	! Height at frame	slantedOpeningWidthSide	 = slantedOpeningWidth  + dxr + dxl	! Width at wall side	slantedOpeningHeightSide = slantedOpeningHeight + dxb + dxt	! Height at wall side	magicRatioH = 0.95	magicRatioV = 0.95	wallBodyThkHorizontal = slantedDepth * (tan(gs_slanted_left_angle) + tan(gs_slanted_right_angle)) - slantedOpeningWidth	wallBodyThkVertical   = slantedDepth * (tan(gs_slanted_top_angle) + tan(gs_slanted_bottom_angle)) - slantedOpeningHeight	bCutEdgesOnly = ((wallBodyThkHorizontal < EPS & wallBodyThkVertical < EPS) & not(curvedWall))! Vertical Cutting Body --------------------------------------------------------	if gs_slanted_top_angle > EPS | gs_slanted_bottom_angle > EPS then		if iWindowShape = SHAPE_RECTANGULAR then			if gs_slanted_bottom_angle > EPS & gs_slanted_top_angle > EPS then				m = ((tan(gs_slanted_top_angle) / tan(gs_slanted_bottom_angle)) * (B + dxt + dxb - (offsetSlantedTop + offsetSlantedBott))) / (1 + (tan(gs_slanted_top_angle) / tan(gs_slanted_bottom_angle)))			else				m = B/2 + dxt - offsetSlantedTop			endif			method = 1			rxv = m - B/2 - dxt + offsetSlantedTop			ryv = 0			if gs_slanted_top_angle > EPS then				rzv = -m / tan(gs_slanted_top_angle)			else				rzv = -m / tan(gs_slanted_bottom_angle)			endif			dv = -sqr(rxv^2 + rzv^2) * slantedCutDepth / rzv		endif		if iWindowShape = SHAPE_ARCHED then			if gs_slanted_bottom_angle > EPS then m = (B - archHeight + dxb - offsetSlantedBott) / tan(gs_slanted_bottom_angle)			rxv = (B - archHeight)			ryv = 0			rzv = -m			dv = slantedCutDepth		endif		method = 2	else		rxv = 0		ryv = 0		rzv = -slantedDepth		dv	=  slantedCutDepth		method = 1	endif! Top - Right Corner Cutting Body ----------------------------------------------	if iWindowShape = SHAPE_RECTANGULAR then		if abs(gs_slanted_top_angle) > EPS then			ratioTL = tan(gs_slanted_right_angle) / tan(gs_slanted_top_angle)			if openingWidth > B * ratioTL then				rytl = 2 * B / 3				rxtl = rytl * ratioTL			else				rxtl = 2 * openingWidth / 3				rytl = rxtl / ratioTL			endif			if abs(gs_slanted_right_angle) > EPS then				rztl = rxtl / tan(gs_slanted_right_angle)			else				rztl = rytl / tan(gs_slanted_top_angle)			endif		else			if abs(gs_slanted_right_angle) > EPS then				rxtl = 3 * openingWidth / 4				rytl = 0				rztl = rxtl / tan(gs_slanted_right_angle)			else				rxtl = 0				rytl = 0				rztl = 1			endif		endif		vx = (slantedDepth) * tan(gs_slanted_right_angle)		vy = (slantedDepth) * tan(gs_slanted_top_angle)		vz = (slantedCutDepth)		dtl = sqr(vx*vx + vy*vy + vz*vz)		ratioV = max(1, dtl / sqr(rxtl^2 + rytl^2 + rztl^2) * 2)		rxtl = rxtl * ratioV		rytl = rytl * ratioV		rztl = rztl * ratioV		if bCutEdgesOnly then			add rightWidth + gs_right_oversize - offsetSlantedRight, B + gs_upper_oversize - offsetSlantedTop, -slantedDepth			if bRightCornerFunction then				pxR = 10			else				pxR = 0			endif			cutform 4, 1, 1 + HalfInfiniteCut * 16,				-rxtl,-rytl,-rztl, -not(HalfInfiniteCut) * dtl,				 pxR,					 0,						31,				-slantedOpeningWidth,	 0,						31,				-slantedOpeningWidth,	-slantedOpeningHeight,	31,				 pxR,					-slantedOpeningHeight,	31			numCuts = numCuts + 1			del 1		else			add rightWidth + gs_right_oversize + dxr - offsetSlantedRight, B + gs_upper_oversize + dxt - offsetSlantedTop, 0			cutform 4, 2, 1 + HalfInfiniteCut * 16 + 128,				-rxtl,-rytl,-rztl, dtl,				leftDx,											 0,				31,				magicRatioH * (-slantedOpeningWidthSide + dxl),	 0,				31,				magicRatioH * (-slantedOpeningWidthSide + dxl),	magicRatioV * (-slantedOpeningHeightSide + dxb),	31,				leftDx,											magicRatioV * (-slantedOpeningHeightSide + dxb),	31			numCuts = numCuts + 1			del 1		endif! Top - Left Corner Cutting Body -----------------------------------------------		if abs(gs_slanted_top_angle) > EPS then			ratioTR = tan(gs_slanted_left_angle) / tan(gs_slanted_top_angle)			if openingWidth > B * ratioTR then				rytr = 2 * B / 3				rxtr = rytr * ratioTR			else				rxtr = 2 * openingWidth / 3				rytr = rxtr / ratioTR			endif			if abs(gs_slanted_left_angle) > EPS then				rztr = rxtr / tan(gs_slanted_left_angle)			else				rztr = rytr / tan(gs_slanted_top_angle)			endif		else			if abs(gs_slanted_left_angle) > EPS then				rxtr = 3 * openingWidth / 4				rytr = 0				rztr = rxtr / tan(gs_slanted_left_angle)			else				rxtr = 0				rytr = 0				rztr = 1			endif		endif		vx = (slantedDepth) * tan(gs_slanted_left_angle)		vy = (slantedDepth) * tan(gs_slanted_top_angle)		vz = (slantedCutDepth)		dtr = sqr(vx*vx + vy*vy + vz*vz)		ratioV = max(1, dtr / sqr(rxtr^2 + rytr^2 + rztr^2) * 2)		rxtr = rxtr * ratioV		rytr = rytr * ratioV		rztr = rztr * ratioV		if bCutEdgesOnly then			add -leftWidth - gs_left_oversize + offsetSlantedLeft, B + gs_upper_oversize - offsetSlantedTop, -slantedDepth			if bLeftCornerFunction then				pxL = -10			else				pxL = 0			endif			cutform 4, 1, 1 + HalfInfiniteCut * 16,				rxtr,-rytr,-rztr, -not(HalfInfiniteCut) * dtr,				pxL,				 0,						31,				slantedOpeningWidth, 0,						31,				slantedOpeningWidth, -slantedOpeningHeight,	31,				pxL,				 -slantedOpeningHeight,	31			numCuts = numCuts + 1			del 1		else			add -leftWidth - gs_left_oversize - dxl + offsetSlantedLeft, B + gs_upper_oversize + dxt - offsetSlantedTop, 0			if bRightCornerFunction then				cutform 4, 2, 1 + HalfInfiniteCut * 16 + 128,					rxtr,-rytr,-rztr, dtr,					rightDx,			 0,				31,					openingWidth + 10,	 0,				31,					openingWidth + 10,	-3*B/4 - dxt,	31,					rightDx,			-3*B/4 - dxt,	31				numCuts = numCuts + 1			else				cutform 4, 2, 1 + HalfInfiniteCut * 16 + 128,					rxtr,-rytr,-rztr, dtr,					rightDx,										 0,				31,					magicRatioH * (slantedOpeningWidthSide - dxr),	 0,				31,					magicRatioH * (slantedOpeningWidthSide - dxr),	magicRatioV * (-slantedOpeningHeightSide + dxb),	31,					rightDx,										magicRatioV * (-slantedOpeningHeightSide + dxb),	31				numCuts = numCuts + 1			endif			del 1		endif	endif	if iWindowShape = SHAPE_ARCHED & gs_slanted_right_angle > EPS & slantedDepth > EPS then		! --- Top Arched Cut ---		shm2 = sqr((arcR - offsetSlantedRight)^2 - (rightWidth - offsetSlantedRight)^2) - arcRComponentY		rxh = 0		rzh = -(rightWidth + dxr - offsetSlantedRight) / tan(gs_slanted_right_angle)		ryh = (shm - shm2) * (rzh / slantedDepth)		dh	=  slantedCutDepth * ((sqr(ryh^2 + rzh^2))/abs(rzh))		x11 = 0		y11 = 0		x12 = rzh		y12 = ryh		x21 = 0		y21 = archHeight - offsetSlantedTop + dxt - shm		x22 = -cos(gs_slanted_right_angle)		y22 = -sin(gs_slanted_right_angle) + y21		gosub 500	! Line - Line intersection!addy (B - archHeight) + shm!roty -90!lin_ x11,y11,0, x12,y12,0!lin_ x21,y21,0, x22,y22,0!del 2		rxh2 = 0		rzh2 = cx		ryh2 = cy		dh	=  slantedCutDepth * ((sqr(ryh2^2 + rzh2^2))/abs(rzh2))		addy (B - archHeight) + shm		cutform 5, 2, 1 + HalfInfiniteCut * 16,			rxh2, ryh2, rzh2, dh,			(-leftWidth - dxr + offsetSlantedLeft),		openingHeight - B-0.1,							11,			(-leftWidth - dxr + offsetSlantedLeft),		openingHeight - B,								95,			0, 											openingHeight - arcR - ((B - archHeight) + shm),995,			(rightWidth + dxl - offsetSlantedRight),	openingHeight - B,								3095,			(rightWidth + dxl - offsetSlantedRight),	openingHeight - B-0.1,							11		numCuts = numCuts + 1		del 1	endif	if abs(gs_slanted_bottom_angle) < EPS then	! Space for Board		dxb = dxb + overSizeLower	endif! Wall Inset cutting body for Slanted Reveal - Right Side --------------	if bWallInsetCut & bParapetWallInset & SYMB_POS_Y > overSizeLower & not(WALL_INCL > EPS) & gs_parapet_autodim & parapet_height > EPS then		if curvedWall & wallIsLeft then			dy = WOD - radBoard		else			dy = radBoard + WOD		endif		dd = (dy - (WALL_THICKNESS - WIDO_SILL)) * curvedWall		vx = (parapetWallInsetDepth - dd) * tan(gs_slanted_right_angle)		vy = (parapetWallInsetDepth - dd) * tan(gs_slanted_bottom_angle)		vz = (parapetWallInsetDepth - dd)		dbl = sqr(vx*vx + vy*vy + vz*vz)		if abs(gs_slanted_right_angle) > EPS then			rxbl = 3 * openingWidth / 4			rzbl = rxbl / tan(gs_slanted_right_angle)		else			rxbl = 0			rzbl = 1		endif		rybl = rzbl * tan(gs_slanted_bottom_angle)		add rightWidth + gs_right_oversize + dxr - offsetSlantedRight, -dxb - gs_lower_oversize + offsetSlantedBott, 0		cutform 4, 2, 1 + HalfInfiniteCut * 16 + 128,			-rxbl, rybl,-rzbl, dbl,			 leftDx,					-parapet_height*3/4,	31,			-3 * openingWidth/4 - dxl,	-parapet_height*3/4,	31,			-3 * openingWidth/4 - dxl,	 0,						31,			 leftDx,					 0,						31		numCuts = numCuts + 1		del 1		db2 = sqr(vx*vx + vz*vz)		add rightWidth + gs_right_oversize + dxr - offsetSlantedRight, -parapet_height, 0		cutform 4, 2, 1 + HalfInfiniteCut * 16 + 128,			-rxbl, 0,-rzbl, db2,			 leftDx,					 parapet_height*3/4,	31,			-3 * openingWidth/4 - dxl,	 parapet_height*3/4,	31,			-3 * openingWidth/4 - dxl,	 0,						31,			 leftDx,					 0,						31		numCuts = numCuts + 1		del 1		isParIns = 1	endif! Wall Inset cutting body for Slanted Reveal - Left Side ---------------	if bWallInsetCut & bParapetWallInset & SYMB_POS_Y > overSizeLower & not(WALL_INCL > EPS) & gs_parapet_autodim & parapet_height > EPS then		if curvedWall & wallIsLeft then			dy = WOD - radBoard		else			dy = radBoard + WOD		endif		dd = (dy - (WALL_THICKNESS - WIDO_SILL)) * curvedWall		vx = (parapetWallInsetDepth - dd) * tan(gs_slanted_left_angle)		vy = (parapetWallInsetDepth - dd) * tan(gs_slanted_bottom_angle)		vz = (parapetWallInsetDepth - dd)		dbl = sqr(vx*vx + vy*vy + vz*vz)		if abs(gs_slanted_left_angle) > EPS then			rxbr = 3 * openingWidth / 4			rzbr = rxbr / tan(gs_slanted_left_angle)		else			rxtr = 0			rztr = 1		endif		rybr = rzbr * tan(gs_slanted_bottom_angle)		add -leftWidth - gs_left_oversize - dxl + offsetSlantedLeft, -dxb - gs_lower_oversize + offsetSlantedBott, 0		cutform 4, 2, 1 + HalfInfiniteCut * 16 + 128,			 rxbr, rybr, -rzbr, dbl,			 rightDx,					-parapet_height*3/4,	31,			 3 * openingWidth/4 + dxl,	-parapet_height*3/4,	31,			 3 * openingWidth/4 + dxl,	 0,						31,			 rightDx,					 0,						31		numCuts = numCuts + 1		del 1		db2 = sqr(vx*vx + vz*vz)		add -leftWidth - gs_left_oversize - dxl + offsetSlantedLeft, -parapet_height, 0		cutform 4, 2, 1 + HalfInfiniteCut * 16 + 128,			 rxbr, 0, -rzbr, db2,			 rightDx,					 parapet_height*3/4,	31,			 3 * openingWidth/4 + dxl,	 parapet_height*3/4,	31,			 3 * openingWidth/4 + dxl,	 0,						31,			 rightDx,					 0,						31		numCuts = numCuts + 1		del 1	endifreturn! ==============================================================================! Line - Line intersection! ------------------------------------------------------------------------------! Input variables:!	EPS:				epsylon!	x11,y11, x12,y12	line #1!	x21,y21, x22,y22	line #2!! Returned variables:!	state:				0 = no intersection point!						1 = valid intersection point!	cx, cy:				intersection point! ==============================================================================500:	lliDiv = (x11-x12) * (y21-y22) - (y11-y12) * (x21-x22)	if abs(lliDiv) > EPS then		! Intersection		temp1 = x11 * y12 - y11 * x12		temp2 = x21 * y22 - y21 * x22		tempx = temp1 * (x21-x22) - (x11-x12) * temp2		tempy = temp1 * (y21-y22) - (y11-y12) * temp2		state = 1		cx = (tempx / lliDiv)		cy = (tempy / lliDiv)	else		! No Intersection		state = 0		cx = 0		cy = 0	endifreturn