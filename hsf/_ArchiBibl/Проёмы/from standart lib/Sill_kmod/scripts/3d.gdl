! Contact person: <NJ>! ==============================================================================! This macro draws the Sill! ------------------------------------------------------------------------------! Input parameters:! Geometry ---------------------------------------------------------------------!	A:						wallhole width (length) (Obsolete)!	B:						wallhole height (length)!	refWidth:				reference width in curved walls (length)!	leftWidth:				wallhole's side distance from the origin at the left side (length)!	rightWidth:				wallhole's side distance from the origin at the right side (length)!	AC_Hole_Position_Angle:	Position angle of the window in a curved wall!	offsY:					for positioning 3D along y (length)! Functions --------------------------------------------------------------------!	gs_IsCurved:			Does the window follow the curvature of the wall? (0 / 1)!	iWindowShape:			Shape of the window (integer)!								0 = rectangular (default)!								1 = arched!							Note: only the rectangular shape can be a Corner Window! Reveal -----------------------------------------------------------------------!	iRevealType:!	gs_reveal_left_angle:!	gs_reveal_right_angle:! Corner Function --------------------------------------------------------------!	bLeftCornerFunction:	Turn macro in Corner Window mode at the left side (0 / 1)!	leftCornerAngle:		Angle between connected walls in case of Corner Window (angle)!	leftConnWallThk:		Thickness of the connected wall in case of Corner Window (length)!	bRightCornerFunction:	Turn macro in Corner Window mode at the right side (0 / 1)!	rightCornerAngle:		Angle between connected walls in case of Corner Window (angle)!	rightConnWallThk:		Thickness of the connected wall in case of Corner Window (length)! Oversize ---------------------------------------------------------------------!	gs_left_oversize:		Left opening oversize (length)!	gs_right_oversize:		Right opening oversize (length)!	gs_lower_oversize:		Lower opening oversize (length)! Sill -------------------------------------------------------------------------!	gs_SillTypeEnable:		Enables sill types for the objects!								(integer; j1 + 2*j2 + 4*j3 + 8*j4 + 16*j5 + 32*j6 + 64*j7 )!								(j1: Standard Sill, j2: Brick Sill, j3: Stone Sill, j4: Ceramic Sill)!								(j5: Eternite Sill, j6: Concrete Tub, j7: Aluminum Sill)!	iSillType:				Identifies the type of the Sill.!								(integer; 1 = Standard Sill, 2 = Brick Sill, 3 = Stone Sill, 4 = Ceramic Sill)!								(5 = Eternite Sill, 6 = Concrete Tub, 7 = Aluminum Sill)!	gs_sill_thk:			Thickness of the Sill. (length)!	gs_sill_nosing:			Nosing of the Sill. (length)!	gs_sill_angle:			Sill slope. (angle)!	gs_sill_drip:			Drip in Sills (Only effective in Stone Sill)  (0 / 1)!	gs_sill_ovhg_left:		Sill overhang on the left side. (length)!	gs_sill_ovhg_right:		Sill overhang on the right side. (length)!	gs_sill_slip_in:		Slip in of the Sill. Only effective when iSillType = 2 or iSillType = 3 (length)!	gs_sill_slip_wall:		Slip in of the Sill counted by the walledge (and not from frame edge like gs_sill_slip_in)!	gs_sill_width:			Width of the Brick or Timber Sill. Only effective when iSillType = 2 (length)!	gs_sill_topWidth:		Sill Top Width!	gs_sill_topHeight:		Sill Top Height!	gs_sill_curved:			Sill edge is curved or straight. (0 / 1)!	bShowSillSplice:		Show or hide the Sill's joint line in case of Corner Window  (0 / 1)!	gs_sill_endthk:			Outer thickness (CHE profile parameters)!	gs_sill_elev:			Insulation thickness under the sill (CHE profile parameters)!	gs_sill_dripnos:		Drin hanging height (CHE profile parameters)!	gs_sill_dripwidth:		Drin width (CHE profile parameters)! Ganging ----------------------------------------------------------------------!	gs_stack_left:			Align to door/window on left side (0 / 1)!	gs_stack_right:			Align to door/window on right side (0 / 1)!	gs_stack_bottom:		Align to door/window on bottom side (0 / 1)! 2D Representation ------------------------------------------------------------!	gs_sill_fill:			Type of the fill on the Sill. (fill type)!	gs_sill_pen_fg:			Fill pen on the Sill. (pen)!	gs_sill_pen_bg:			Fill background pen on the Sill. (pen)!	gs_sill_pen_sectcont:	Section contour pen of the sill! 3D Representation ------------------------------------------------------------!	lod3D:					Level of detail. Not used. (integer)!	gs_frame_pen:			Drawing pen of 3D. (pen)! Materials --------------------------------------------------------------------!	gs_sill_mat:			Sill material (material)! Section Representation Parameters (CHE profile parameters) --------------------!	gs_sill_pen_ins_sectcont:	Section contour pen of the insulation under the sill!	gs_sill_fill_ins_fg:		Section fill type of the insulation under the sill!	gs_sill_pen_ins_fg:			Section fill pen of the insulation under the sill!	gs_sill_pen_ins_bg:			Section fill background of the insulation under the sill!! Related Global Variables:!	GLOB_SCRIPT_TYPE!	GLOB_CONTEXT!	WALL_THICKNESS!	WALL_INCL!	WALL_RESOL!	WIDO_FRAME_THICKNESS!	WIDO_SILL!	WIDO_LEFT_JAMB!	WIDO_RIGHT_JAMB!	WIDO_THRES_DEPTH!	WIDO_HEAD_DEPTH!	WIDO_ORIG_DIST!	WIDO_REVEAL_SIDE!	SYMB_MIRRORED!	SYMB_ROTANGLE!	SYMB_FILL!	SYMB_SECT_PEN!	SYMB_FILL_PEN!	SYMB_FBGD_PEN! ==============================================================================sillRight			= 0sillLeft			= 0sillLeft_sL			= 0sillRight_sL		= 0sillLeft_sR			= 0sillRight_sR		= 0sillBottom			= 0sillBottomOutside	= 0sillSideHeight		= 0sillSideAngle		= 0dim sillPoly[]	sillPoly[1] = 0! Draw Sill --------------------------------------------------------------------if lod3D > 0 & bDrawSill & not(gs_stack_bottom) then	if gs_sill_fill			< 1 then gs_sill_fill			= SYMB_FILL	if gs_sill_pen_bg		< 1 then gs_sill_pen_bg			= SYMB_FBGD_PEN	if gs_sill_pen_fg		< 1 then gs_sill_pen_fg			= SYMB_FILL_PEN	if gs_sill_pen_3D		< 1 then gs_sill_pen_3D			= gs_frame_pen		! Compatibility	rotx -90	resol WALL_RESOL	sillElevation = -overSizeLower + WIDO_THRES_DEPTH	if not(gs_turn_plaster_show_3D) then		thkPlasterAtSillLeft	= 0		thkPlasterAtSillRight	= 0	endif	if gs_stack_left then		thkPlasterAtSillLeft	= 0	endif	if gs_stack_right then		thkPlasterAtSillRight	= 0	endif! ==============================================================================! Draw Sill! ==============================================================================	if abs(gs_sill_slip_wall) > EPS then		SillSlipin			= gs_sill_width - (WIDO_SILL + gs_sill_nosing)	else		SillSlipin			= gs_sill_slip_in	endif! ==============================================================================! CHE simple sill in 1:100 elevation view! ==============================================================================	if lod3D_Sill = 1 then		if WIDO_REVEAL_SIDE then			addy -WIDO_FRAME_THICKNESS		else			muly -1		endif		pen gs_sill_pen_3D		!sect_fill gs_sill_fill, gs_sill_pen_bg, gs_sill_pen_fg, gs_sill_pen_sectcont		sillH = gs_sill_thk		sillOffset = 0		sillOnWall = gs_sill_oversize & (iLoD3D <> SYMBW_3D_MULTIPLANES_FRAME)		if iSillType = SILL_BRICK then			sillH = gs_sill_width * sin(gs_sill_angle) + gs_sill_thk * cos(gs_sill_angle)			sillOffset = -sillH			sillOnWall = 1		endif		if iSillType = SILL_STONE then			sillH = gs_sill_thk			sillOffset = -gs_sill_thk			sillOnWall = 1		endif		if iSillType = SILL_TIMBER | iSillType = SILL_SOLID_11 | iSillType = SILL_SOLID_12 then			if gs_sill_oversize & gs_reveal_nominal then				sillH = gs_sill_thk				sillOffset = gs_sill_elev			else				sillH = gs_sill_thk + gs_sill_elev				sillOffset = 0			endif		endif		if iSillType = SILL_SOLID_22 then			if gs_sill_oversize & gs_reveal_nominal then				sillH = gs_sill_thk + gs_sill_dripnos				sillOffset = gs_sill_elev - gs_sill_dripnos			else				sillH = gs_sill_thk + max(gs_sill_dripnos, gs_sill_elev)				sillOffset = -gs_sill_dripnos * (gs_sill_dripnos > gs_sill_elev)			endif			if gs_sill_dripnos - gs_sill_elev > 0 then				sillOnWall = 1			endif		endif		if iSillType = SILL_METAL_1 | iSillType = SILL_METAL_2 then			sillH = max(gs_sill_thk, gs_sill_thk - gs_sill_endthk + gs_sill_dripnos)			sillOffset = min(0, gs_sill_endthk - gs_sill_dripnos)			if gs_sill_dripnos > gs_sill_endthk then				sillOnWall = 1			endif		endif		if iSillType = SILL_PARALLEL then			if gs_sill_oversize & gs_reveal_nominal then				sillH = (WIDO_SILL + gs_sill_nosing) * tan(gs_sill_angle) + gs_sill_element_thk * cos(gs_sill_angle)				sillOffset = gs_sill_thk - sillH			else				sillH = gs_sill_thk				sillOffset = 0			endif		endif		if iSillType = SILL_PARALLEL_2 then			sillH = gs_sill_width * sin(gs_reveal_outerBottom_angle) + gs_sill_element_thk * cos(gs_reveal_outerBottom_angle) - gs_mountingFrame_depth * gs_mountingFrame * tan(gs_reveal_outerBottom_angle)			sillOffset = not(gs_mountingFrame) * original_gs_reveal_bottom - sillH + gs_sill_element_thk / cos(gs_reveal_outerBottom_angle)			sillOnWall = 1		endif		material gs_sill_mat		addz sillOffset + sillElevation		if sillOnWall then			if curvedWall then				alfaEnd		= -signWallIsLeft * atn(spx3 / (spy3 - WOD))				alfaStart	= -signWallIsLeft * atn(spx6 / (spy6 - WOD))				arcRadius	= radSill				bMiddlePoints = 1				firstStatus	= 8 + 7 * not(gs_stack_right)				lastStatus	= 10 + 5 * not(gs_stack_left)				gosub 100				alfaStart	= -signWallIsLeft * atn(spx3 / (spy3 - WOD))				alfaEnd		= -signWallIsLeft * atn(spx6 / (spy6 - WOD))				arcRadius	= radSill + signWallIsLeft * 0.001				bMiddlePoints = 1				firstStatus	= 13 + 2 * not(gs_stack_left)				lastStatus	= 8 + 7 * not(gs_stack_right)				gosub 100				prism_ nsp/3, sillH, get(nsp)			else				addy -WIDO_SILL				rotx 90				if bLeftCornerFunction then					pxL = leftRevealPnts[idxSillStartRevealLeft][1]				else					pxL = leftRevealPnts[idxSillStartRevealLeft][1] - not(gs_stack_left) * gs_sill_ovhg_left				endif				if bRightCornerFunction then					pxR = rightRevealPnts[idxSillStartRevealRight][1]				else					pxR = rightRevealPnts[idxSillStartRevealRight][1] + not(gs_stack_right) * gs_sill_ovhg_right				endif				prism_ 4,0.0001,					pxL, 0,		15,					pxL, sillH, 15,					pxR, sillH, 15,					pxR, 0,		15				del 2			endif		else			rotx 90			if bLeftCornerFunction then				pxL = -leftWidth - WIDO_FRAME_THICKNESS * lx			else				pxL = leftRevealPnts[idxSillEndRevealLeft][1] - (not(gs_stack_left) & WIDO_SILL < EPS) * gs_sill_ovhg_left			endif			if bRightCornerFunction then				pxR = rightWidth + WIDO_FRAME_THICKNESS * rx			else				pxR = rightRevealPnts[idxSillEndRevealRight][1] + (not(gs_stack_right) & WIDO_SILL < EPS) * gs_sill_ovhg_rigth			endif			prism_ 4,0.0001,				pxL, 0,		15,				pxL, sillH, 15,				pxR, sillH, 15,				pxR, 0,		15			del 1		endif		del 1		end! ==============================================================================! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end! ==============================================================================	endif! Draw Sill --------------------------------------------------------------------	_bSillBelowSLight = 1	if bTShapedOpening then		if gs_sill_outside_sl_left & gs_sidelight_left & gs_sidelight_parapet_hgt_left > EPS then			addz gs_sidelight_parapet_hgt_left + (gs_reveal_bottom_sL - gs_reveal_bottom)			sidelightCutLeft  = 0			sidelightCutRight = 1			sidelightCutPosElevBodyRight = -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_left_sL*(iSillType <> SILL_DUTCH) + thkPlasterAtSillSlLeft * gs_turn_plaster_show_3D			sidelightCutPosRight		 = sidelightCutPosElevBodyRight + bDrawOutsideTrim * gs_trim_width_out			stackLeft	= gs_stack_left			stackRight	= 0			gosub "DrawSill"			del 1			sillLeft_sL	 = sillLeft			sillRight_sL =  - sidelightCutPosRight		else			sillLeft_sL	 = 0			sillRight_sL = 0		endif		for i = 1 to nsp			dummy = get(1)		next i		if gs_sill_outside_sl_right & gs_sidelight_right & gs_sidelight_parapet_hgt_right > EPS then			addz gs_sidelight_parapet_hgt_right + (gs_reveal_bottom_sR - gs_reveal_bottom)			sidelightCutLeft  = 1			sidelightCutRight = 0			sidelightCutPosElevBodyLeft	= rightWidth - gs_sidelight_WHole_width_right - gs_reveal_right_sR*(iSillType <> SILL_DUTCH) - thkPlasterAtSillSlRight * gs_turn_plaster_show_3D			sidelightCutPosLeft			= sidelightCutPosElevBodyLeft - bDrawOutsideTrim * gs_trim_width_out			stackLeft	= 0			stackRight	= gs_stack_right			gosub "DrawSill"			del 1			sillLeft_sR	 = sidelightCutPosLeft			sillRight_sR = sillRight		else			sillLeft_sR	 = 0			sillRight_sR = 0		endif		for i = 1 to nsp			dummy = get(1)		next i		if gs_sill_outside then			_bNeedCutBack = not((iSillType = SILL_DUTCH) & ((iRevealType = REVEAL_NEGATIVE) |\														    ((iRevealType = REVEAL_DOUBLE) & (iSillRevealType = REVEAL_NEGATIVE))))			_bSillBelowSLight = 0			addz -thresholdExtraHole3D			sidelightCutLeft  = 2 * (gs_sidelight_left & gs_sidelight_parapet_hgt_left > EPS)			sidelightCutRight = 2 * (gs_sidelight_right & gs_sidelight_parapet_hgt_right > EPS)			sidelightCutPosElevBodyRight = rightWidth - gs_sidelight_WHole_width_right - gs_reveal_right_sR*_bNeedCutBack			sidelightCutPosRight		 = sidelightCutPosElevBodyRight			sidelightCutPosElevBodyLeft	 = -leftWidth  + gs_sidelight_WHole_width_left  + gs_reveal_left_sL*_bNeedCutBack			sidelightCutPosLeft			 = sidelightCutPosElevBodyLeft			stackLeft	= 0			stackRight	= 0			gosub "DrawSill"		else			sillLeft  = 0			sillRight = 0		endif	else		addz -thresholdExtraHole3D		sidelightCutLeft  = 0		sidelightCutRight = 0		sidelightCutPosElevBodyLeft	 = 0		sidelightCutPosElevBodyRight = 0		stackLeft	= gs_stack_left		stackRight	= gs_stack_right		gosub "DrawSill"		sillLeft_sL  = 0		sillRight_sL = 0		sillLeft_sR  = 0		sillRight_sR = 0	endifendiffor i = 1 to nsp	dummy = get(1)next iend sillRight,	sillLeft,	sillLeft_sL,	sillRight_sL,	sillLeft_sR,	sillRight_sR,	sillBottom,	sillBottomOutside,	sillSideHeight,	sillSideAngle,	sillPoly! ==============================================================================! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end! ==============================================================================! ==============================================================================! Timber Sill! =============================================================================="DrawSill":if WIDO_REVEAL_SIDE then	addy -WIDO_FRAME_THICKNESSelse	muly -1endifpen gs_sill_pen_3D!sect_fill gs_sill_fill, gs_sill_pen_bg, gs_sill_pen_fg, gs_sill_pen_sectcontif iSillType = SILL_TIMBER & (WIDO_SILL > EPS | gs_sill_nosing > EPS) then	if maxSillAngle > -EPS & gs_sill_angle > maxSillAngle then gs_sill_angle = maxSillAngle	if gs_sill_angle < 0 then gs_sill_angle = 0	if abs (gs_sill_angle) > EPS then		sillPoly[1] = 0 									: sillPoly[2] = -sillElevation - gs_sill_elev		sillPoly[3] = 0 									: sillPoly[4] = -sillElevation - gs_sill_elev - gs_sill_thk - WIDO_SILL * tan(gs_sill_angle) * gs_fsill		sillPoly[5] = (gs_sill_thk + WIDO_SILL * tan(gs_sill_angle) * gs_fsill) / tan (gs_sill_angle)		sillPoly[6] = -sillElevation - gs_sill_elev	else		sillPoly[1] = 0 									: sillPoly[2] = -sillElevation - gs_sill_elev		sillPoly[3] = 0 									: sillPoly[4] = -sillElevation - gs_sill_elev - gs_sill_thk		sillPoly[5] = max(0, WIDO_SILL) + 1					: sillPoly[6] = -sillElevation - gs_sill_elev - gs_sill_thk		sillPoly[7] = max(0, WIDO_SILL) + 1					: sillPoly[8] = -sillElevation - gs_sill_elev	endif	sillLeft			= abs(leftRevealPnts[1][1]  - gs_sill_ovhg_left)	sillRight			= abs(rightRevealPnts[1][1] + gs_sill_ovhg_right)	sillBottom			= sillElevation	sillBottomOutside	= sillElevation + gs_sill_elev	sillSideHeight		= gs_sill_thk + gs_sill_elev	sillSideAngle		= gs_sill_angle	sillElev		= sillElevation + gs_sill_elev	angleSill		= gs_sill_angle 	! Sill Angle	hSill			= gs_sill_thk	bSillCurved		= gs_sill_curved	matSill			= gs_sill_mat	bElevBody		= 0	addz sillElev	gosub "DrawSill_Timber"			 	! modelling Sill body	del 1	if gs_sill_elev > EPS then	! gs_sill_elev is negative at USA Timber Sill, then do not draw Sill Elevation body		angleSill   = 0 		! Sill Angle		hSill       = gs_sill_elev		bSillCurved = 0		sillNosing  = 0		resol WALL_RESOL		if WIDO_REVEAL_SIDE then			matSill = WALL_MAT_A		else			matSill = WALL_MAT_B		endif		pen WALL_VIEW_PEN		!sect_fill gs_sill_fill_ins_fg, gs_sill_pen_ins_bg, gs_sill_pen_ins_fg, gs_sill_pen_ins_sectcont		bElevBody = 1		sidelightCutPosLeft	 = sidelightCutPosElevBodyLeft		sidelightCutPosRight = sidelightCutPosElevBodyRight		addz sillElev - hSill		gosub "DrawSill_Timber"				! modelling Sill Elevation body		del 1	endifendif! ==============================================================================! Brick Sill, Stone Sill, Ceramic Sill, Eternite Sill, Concrete Tub, Aluminum Sill! ==============================================================================numCuts = 0if	bTShapedOpening then	gs_frame_width_left_2	= ABS(rightWidth - sidelightCutPosElevBodyLeft - rightFrameOffset)	gs_frame_width_right_2	= ABS(leftWidth + sidelightCutPosElevBodyRight - leftFrameOffset)endifif (iSillType <> SILL_TIMBER) & gs_sill_thk > EPS then	material gs_sill_mat! Cuts for Door Frame -------------------------------------------------------	if	bTShapedOpening then		roty 180		if sidelightCutLeft then			addx -sidelightCutPosElevBodyLeft			cutpolya 4, 1, 0,				0,						0, 15,				gs_frame_width_left_2,	0, 15,				gs_frame_width_left_2,	WIDO_FRAME_THICKNESS, 15,				0,						WIDO_FRAME_THICKNESS, 15			numCuts = numCuts + 1			del 1		endif		if sidelightCutRight then			addx -sidelightCutPosElevBodyRight			cutpolya 4, 1, 0,				0,						0, 15,				-gs_frame_width_right_2,	0, 15,				-gs_frame_width_right_2,	WIDO_FRAME_THICKNESS, 15,				0,						WIDO_FRAME_THICKNESS, 15			numCuts = numCuts + 1			del 1		endif		del 1	endif	if not(curvedWall) then! Cuts for Corner Window -------------------------------------------------------		if bRightCornerFunction then			add rightRevealPnts[idxSillStartRevealRight][1], rightRevealPnts[idxSillStartRevealRight][2], 0			rotx 90			roty -rightCornerAngle / 2			cutplane 180			numCuts = numCuts + 1			del 3		endif		if bLeftCornerFunction then			add leftRevealPnts[idxSillStartRevealLeft][1], leftRevealPnts[idxSillStartRevealLeft][2], 0			rotx 90			roty leftCornerAngle / 2			cutplane 180			numCuts = numCuts + 1			del 3		endif! Cuts for Overhanged Brick and Stone Sill -------------------------------------		if AC_WallType <> 2 then			if not(bLeftCornerFunction) then				if abs(idxSillStartRevealLeft - idxSillEndRevealLeft) > 1 then					if thkPlasterAtSillLeft > EPS then						startIdx = idxSillEndPlasterLeft						endIdx	 = idxSillStartPlasterLeft					else						startIdx = idxSillEndRevealLeft						endIdx	 = idxSillStartRevealLeft					endif					put leftRevealPnts[startIdx][1] - 1, leftRevealPnts[startIdx][2] + 1, 15					put leftRevealPnts[startIdx][1],	 leftRevealPnts[startIdx][2] + 1, 15					for i = startIdx to endIdx step -1						put leftRevealPnts[i][1], leftRevealPnts[i][2], 15					next i					put leftRevealPnts[endIdx][1] - 1, leftRevealPnts[endIdx][2], 15					cutpolya nsp/3, 1, 0, get(nsp)					numCuts = numCuts + 1				else					if (gs_sill_ovhg_left > EPS | thkPlasterAtSillLeft > EPS) then						pxL = leftRevealPnts[idxSillStartRevealLeft][1]						cutpolya 4, 1, 0,							pxL + thkPlasterAtSillLeft,						 WALL_THICKNESS,	15,							pxL + thkPlasterAtSillLeft,						-WIDO_SILL,			15,							pxL - abs(widoLeftJamb) - gs_sill_ovhg_left,	-WIDO_SILL,			15,							pxL - abs(widoLeftJamb) - gs_sill_ovhg_left,	 WALL_THICKNESS,	15						numCuts = numCuts + 1					endif				endif			endif			if not(bRightCornerFunction) then				if abs(idxSillStartRevealRight - idxSillEndRevealRight) > 1 then					if thkPlasterAtSillRight > EPS then						startIdx = idxSillStartPlasterRight						endIdx	 = idxSillEndPlasterRight					else						startIdx = idxSillStartRevealRight						endIdx	 = idxSillEndRevealRight					endif					put rightRevealPnts[startIdx][1] + 1, rightRevealPnts[startIdx][2], 15					for i = startIdx to endIdx						put rightRevealPnts[i][1], rightRevealPnts[i][2], 15					next i					put rightRevealPnts[endIdx][1],		rightRevealPnts[endIdx][2] + 1, 15					put rightRevealPnts[endIdx][1] + 1, rightRevealPnts[endIdx][2] + 1, 15					cutpolya nsp/3, 1, 0, get(nsp)					numCuts = numCuts + 1				else					if (gs_sill_ovhg_right > EPS | thkPlasterAtSillRight > EPS) then						pxR = rightRevealPnts[idxSillStartRevealRight][1]						cutpolya 4, 1, 0,							pxR - thkPlasterAtSillRight,					 WALL_THICKNESS,	15,							pxR - thkPlasterAtSillRight,					-WIDO_SILL,			15,							pxR + abs(widoRightJamb) + gs_sill_ovhg_right,	-WIDO_SILL,			15,							pxR + abs(widoRightJamb) + gs_sill_ovhg_right,	 WALL_THICKNESS,	15						numCuts = numCuts + 1					endif				endif			endif		else			if gs_sill_ovhg_left > EPS | gs_sill_ovhg_right > EPS | \			! Cut sill in case of overhangs				abs(idxSillStartRevealLeft  - idxSillEndRevealLeft)  > 1 | \	! Cut sill in case of Double Splayed Reveal or Outside Splayed Reveal too				abs(idxSillStartRevealRight - idxSillEndRevealRight) > 1 then				ch = initaddonscope ("PolyOperations", "", "")! Generate Sill Cutting Wall Part Polygons -------------------------------------				bGetWallCutPolygons = 1				bPolyFor3D = 1				gosub 2000! Cut Wall Parts from the Sill Model -------------------------------------------				defaultStatusCode = 15				dim statusCodes[]				dim resPolyIDArr[]				numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)				for i = 1 to numPoly					polygonID = resPolyIDArr[i]					gosub 1000	! Get GDL Polygon					cutpolya nsp/3, 1,0, get(nsp)					numCuts = numCuts + 1				next i! Close channel ----------------------------------------------------------------				closeaddonscope ch			endif		endif! Cuts for Overhanged Brick and Stone Sill - at Sidelights ---------------------		if sidelightCutLeft = 2 & gs_turn_plaster_show_3D then			cutpolya 4, 1,0,				sidelightCutPosLeft + thkPlasterAtSillSlLeft,	 0,			15,				sidelightCutPosLeft + thkPlasterAtSillSlLeft,	-WIDO_SILL,	15,				sidelightCutPosLeft - 1,						-WIDO_SILL,	15,				sidelightCutPosLeft - 1,						 0,			15				numCuts = numCuts + 1		endif		if sidelightCutRight = 2 & gs_turn_plaster_show_3D then			cutpolya 4, 1,0,				sidelightCutPosRight - thkPlasterAtSillSlRight,	 0,			15,				sidelightCutPosRight - thkPlasterAtSillSlRight,	-WIDO_SILL,	15,				sidelightCutPosRight + 1,						-WIDO_SILL,	15,				sidelightCutPosRight + 1,						 0,			15				numCuts = numCuts + 1		endif		maxSillLength = WIDO_SILL	else! Curved Wall ------------------------------------------------------------------! Cuts for Corner Window -------------------------------------------------------		if bRightCornerFunction then			addx rightCwDx + rightWidth + WIDO_FRAME_THICKNESS * rx			roty rightCornerAngle / 2			cutplane			numCuts = numCuts + 1			del 2		endif		if bLeftCornerFunction then			addx -leftCwDx - leftWidth - WIDO_FRAME_THICKNESS * lx			roty -leftCornerAngle / 2			cutplane			numCuts = numCuts + 1			del 2		endif! ------------------------------------------------------------------------------		alfaR = alfaRight - alfaRightJamb + alfaSillRightOvhg		if stackRight then			if wallIsLeft then				pxR = radSill * sin(alfaR) + (spy6 - spy5) * tan(alfaR)			else				pxR = -(WOD - SillSlipin - gs_sill_thk * sin(gs_sill_angle)) * tan(alfaR)			endif			! --- Cut on right side when window is Stacked			add 0,WOD,0			rotz (wallIsLeft - not(wallIsLeft)) * alfaR			roty 90			cutplane			numCuts = numCuts + 1			del 3		else			if bParalellInCurvedWalls = 0 then				pxR = radSill * sin(alfaR)			else				pxR = spx5			endif		endif		pyR = ySign * radSill * cos(alfaR)		alfaL = -alfaLeft + alfaLeftJamb - alfaSillLeftOvhg		if stackLeft then			if wallIsLeft then				pxL = radSill * sin(alfaL) + (spy3 - spy4) * tan(alfaL)			else				pxL = -(WOD - SillSlipin - gs_sill_thk * sin(gs_sill_angle)) * tan(alfaL)			endif			! --- Cut on left side when window is Stacked			add 0,WOD,0			rotz (wallIsLeft - not(wallIsLeft)) * alfaL			roty 90			cutplane 180			numCuts = numCuts + 1			del 3		else			if bParalellInCurvedWalls = 0 then				pxL = radSill * sin(alfaL)			else				pxL = spx4			endif		endif		pyL = ySign * radSill * cos(alfaL)! Cuts for Overhanged Brick and Stone Sill -------------------------------------		if sidelightCutLeft = 2 & gs_turn_plaster_show_3D then			px = sidelightCutPosLeft + thkPlasterAtSillSlLeft			py = WOD - iArchSign * sqr(radSill^2 - px^2)			alfaStart	= atn(px / (-signWallIsLeft * py + abs(WOD)))			alfaEnd		= alfaStart - 2 * alfaSillLeftOvhg - 10			if abs(alfaStart - alfaEnd) > EPS then				arcRadius		= radSill				bMiddlePoints	= 1				firstStatus		= 15				lastStatus		= 79				gosub 100	! Arch Segmentation			endif			if wallIsLeft then				put px - 0.1,	WOD, 15,					px,			WOD, 15			else				put px - 2, -WIDO_SILL, 15,					px - 2,  py + 1,	15,					px,		 py + 1,	15			endif!!!			prism_ nsp/3, 1, use(nsp)			cutpolya nsp/3, 1,0, get(nsp)			numCuts = numCuts + 1		endif		if not(stackLeft | sidelightCutLeft) then			if thkPlasterAtSillLeft > EPS then				startIdx = idxSillEndPlasterLeft				endIdx	 = idxSillStartPlasterLeft			else				startIdx = idxSillEndRevealLeft				endIdx	 = idxSillStartRevealLeft			endif			for i = startIdx to endIdx step -1				put leftRevealPnts[i][1], leftRevealPnts[i][2], 15			next i			alfaStart = atn(leftRevealPnts[endIdx][1] / (-signWallIsLeft * leftRevealPnts[endIdx][2] + abs(WOD)))			if not(bParalellInCurvedWalls) | (bParalellInCurvedWalls & stackLeft) then				alfaEnd		=  alfaStart - 2 * alfaSillLeftOvhg - 10		!!!- wallIsLeft * 10			else				alfaEnd		= -asn((leftWidth  + overSizeLeft + not(stackLeft) * 2 * gs_sill_ovhg_left) / radSill) + alfaLeftJamb - 10			endif			if abs(alfaStart - alfaEnd) > EPS then				arcRadius		= radSill				bMiddlePoints	= 1				firstStatus		= 15				lastStatus		= 79				gosub 100	! Arch Segmentation			endif			if wallIsLeft then				if bParalellInCurvedWalls then					put leftRevealPnts[idxSillStartRevealLeft][1] - 1.0,	WOD, 15,						leftRevealPnts[idxSillStartRevealLeft][1],			WOD, 15				else					put -0.1,	WOD, 15,						 0,		WOD, 15				endif			else				x3 = leftRevealPnts[idxSillStartRevealLeft][1]				y3 = leftRevealPnts[idxSillStartRevealLeft][2] + 1.0				x4 = x3 - 2.0				y4 = y3				put x4, -WIDO_SILL, 15,					x4, y4,	15,					x3, y3,	15			endif!!!			prism_ nsp/3, 1, use(nsp)			cutpolya nsp/3, 1,0, get(nsp)			numCuts = numCuts + 1		endif		if sidelightCutRight = 2 & gs_turn_plaster_show_3D then			px = sidelightCutPosRight - thkPlasterAtSillSlRight			py = WOD - iArchSign * sqr(radSill^2 - px^2)			alfaStart	= atn(px / (-signWallIsLeft * py + abs(WOD)))			alfaEnd		= alfaStart + 2 * alfaSillRightOvhg + 10			if abs(alfaStart - alfaEnd) > EPS then				arcRadius		= radSill				bMiddlePoints	= 1				firstStatus		= 15				lastStatus		= 79				gosub 100	! Arch Segmentation			endif			if wallIsLeft then				put px + 0.1,	WOD, 15,					px,			WOD, 15			else				put px + 2, -WIDO_SILL, 15,					px + 2,  py + 1,	15,					px,		 py + 1,	15			endif!!!			prism_ nsp/3, 1, use(nsp)			cutpolya nsp/3, 1,0, get(nsp)			numCuts = numCuts + 1		endif		if not(stackRight | sidelightCutRight) then			if thkPlasterAtSillRight > EPS then				startIdx = idxSillEndPlasterRight				endIdx	 = idxSillStartPlasterRight			else				startIdx = idxSillEndRevealRight				endIdx	 = idxSillStartRevealRight			endif			for i = startIdx to endIdx step -1				put rightRevealPnts[i][1], rightRevealPnts[i][2], 15			next i			alfaStart= atn(rightRevealPnts[endIdx][1] / (-signWallIsLeft * rightRevealPnts[endIdx][2] + abs(WOD)))			if not(bParalellInCurvedWalls) | (bParalellInCurvedWalls & stackRight) then				alfaEnd	= alfaRight - alfaRightJamb + 2 * alfaSillRightOvhg + 10		! wallIsLeft * 10			else				alfaEnd	= asn((rightWidth  + overSizeRight + not(stackRight) * 2 * gs_sill_ovhg_right) / radSill) - alfaRightJamb + 10			endif			if abs(alfaStart - alfaEnd) > EPS then				arcRadius		= radSill				bMiddlePoints	= 1				firstStatus		= 15				lastStatus		= 79				gosub 100	! Arch Segmentation			endif			if wallIsLeft then				if bParalellInCurvedWalls then					put	rightRevealPnts[idxSillStartRevealRight][1] + 1.0,	WOD, 15,						rightRevealPnts[idxSillStartRevealRight][1],		WOD, 15				else					put 0.1,WOD, 15,						0,	WOD, 15				endif			else				x3 = rightRevealPnts[idxSillStartRevealRight][1]				y3 = rightRevealPnts[idxSillStartRevealRight][2] + 1.0				x4 = x3 + 2.0				y4 = y3				put x4, -WIDO_SILL, 15,					x4, y4,	15,					x3, y3,	15			endif			cutpolya nsp/3, 1,0, get(nsp)			numCuts = numCuts + 1		endif		if wallIsLeft then			maxSillLength = abs(radSill - abs(WOD))		else			maxSillLength = max((abs(WOD) - pyL), (abs(WOD) - pyR))		endif	endif! ==============================================================================! Drawing Sills! ==============================================================================	if sidelightCutRight then		pxR = sidelightCutPosRight	else		if bRightCornerFunction then			pxR = max(rightRevealPnts[idxSillStartRevealRight][1], rightRevealPnts[idxSillEndRevealRight][1]) + 1.0		else			if curvedWall & stackRight then				pxR = rightRevealPnts[idxSillStartRevealRight][1] + 1.0			else				pxR = rightRevealPnts[idxSillStartRevealRight][1] + gs_sill_ovhg_right			endif		endif	endif	if sidelightCutLeft then		pxL = sidelightCutPosLeft	else		if bLeftCornerFunction then			pxL = min(leftRevealPnts[idxSillStartRevealLeft][1], leftRevealPnts[idxSillEndRevealLeft][1]) - 1.0		else			if curvedWall & stackLeft then				pxL = leftRevealPnts[idxSillStartRevealLeft][1] - 1.0			else				pxL = leftRevealPnts[idxSillStartRevealLeft][1] - gs_sill_ovhg_left			endif		endif	endif	addx pxL	roty 90	rotz -90	mask = 15	if stackLeft  then mask = bitset(mask, 0, 0)	if stackRight then mask = bitset(mask, 2, 0)	mask_str = mask	if iSillType = SILL_BRICK then		gs_sill_width = gs_sill_thk * tan(gs_sill_angle) + (maxSillLength + SillSlipin + gs_sill_nosing) / cos(gs_sill_angle)		sillElevation = 0		gosub 10200	endif	if iSillType = SILL_STONE then		gs_sill_width = SillSlipin + maxSillLength + gs_sill_nosing		sillElevation = 0		gosub 10300	endif	if iSillType = SILL_CERAMIC then		sillElevation = 0		gosub 10400	endif	if iSillType = SILL_ETHERNIT then		gs_sill_endthk = max(0, gs_sill_thk - gs_sill_topHeight - (gs_sill_width - gs_sill_topWidth) * tan(gs_sill_angle))		sillElevation = 0		gosub 10500	endif	if iSillType = SILL_CONCRETE_TUB then		sillElevation = 0		gosub 10600	endif	if iSillType = SILL_ALUMINIUM then		sillElevation = 0		thk = 0.002		gosub 10700	endif	if iSillType = SILL_SOLID_11 | iSillType = SILL_SOLID_12 | iSillType = SILL_SOLID_22 | iSillType = SILL_METAL_1 | iSillType = SILL_METAL_2 then		if WIDO_REVEAL_SIDE then			material WALL_MAT_A		else			material WALL_MAT_B		endif		pen WALL_VIEW_PEN		!!sect_fill gs_sill_fill_ins_fg, gs_sill_pen_ins_bg, gs_sill_pen_ins_fg, gs_sill_pen_ins_sectcont		! Metal Sheet / Metallfensterbank 1.1 (CHE) geometry		fbn	= gs_sill_topHeight		xh	= gs_sill_thk - fbn		if abs(WIDO_SILL) > EPS then			xh2 = gs_sill_width * (xh - gs_sill_endthk) / WIDO_SILL		else			xh2 = 0		endif		if iSillType <> SILL_METAL_1 & iSillType <> SILL_METAL_2 then			addy -sillElevation			gosub 11111			del 1		endif		base		vert 0, 0, 0		vert 1, 0, 0		vert 0, 0, -sgn((SYMB_MIRRORED exor (SYMB_ROTANGLE > EPS)) - 0.5)		vert 0, -1, 0		coor 2, -1, -2, -3, -4		body -1		material gs_sill_mat		pen gs_sill_pen_3D		!!sect_fill gs_sill_fill, gs_sill_pen_bg, gs_sill_pen_fg, gs_sill_pen_sectcont	endif	if iSillType = SILL_SOLID_11 then	! Solid Sill 1.1 --- Massiv-Fensterbank 1.1 (CHE)		gosub 10800	endif	if iSillType = SILL_SOLID_12 then	! Solid Sill 1.2 --- Massiv-Fensterbank 1.2 (CHE)		gosub 10900	endif	if iSillType = SILL_SOLID_22 then	! Solid Sill 2.2 / Massiv-Fensterbank 2.2 (CHE)		gosub 11000	endif	if iSillType = SILL_METAL_1 | iSillType = SILL_METAL_2 then	! Metal Sheet / Metallfensterbank 1.1 (CHE) - Metal Sheet 2 (CHE)		gosub 11100	endif	if iSillType = SILL_PARALLEL | iSillType = SILL_PARALLEL_2 then	! Solid Parallel (CHE)		gosub 11200	endif	if iSillType = SILL_SIMPLEBLOCK then		gs_sill_width = maxSillLength + SillSlipin + gs_sill_nosing		sillElevation = 0		iBrickSilldetlevel = BRICKSILL_SIMPLE		gs_sill_angle = 0		gosub 10200	endif	if iSillType = SILL_BLOCK then		gs_sill_width = WIDO_FRAME_THICKNESS + gs_sill_nosing		sillElevation = 0		gs_sill_ovhg_left = 0		gs_sill_ovhg_right = 0		gs_sill_angle = 0		gosub 11300	endif	if iSillType = SILL_DUTCH then		gs_sill_width = WIDO_FRAME_THICKNESS + gs_sill_nosing		sillElevation = 0		gs_sill_ovhg_left = 0		gs_sill_ovhg_right = 0		gosub 11400	endif	del 3endiffor i=1 to numCuts	cutendnext inumCuts = 0del 1! ==============================================================================! Cut Space in Wall for Brick Sill and Stone Sill! ==============================================================================if bDrawSill & \   ((iSillType = SILL_TIMBER & gs_sill_elev < -EPS) | \		! to USA Timber Sill	iSillType = SILL_BRICK | \	iSillType = SILL_STONE | \	iSillType = SILL_CERAMIC | \	iSillType = SILL_ETHERNIT | \	iSillType = SILL_CONCRETE_TUB | \	iSillType = SILL_ALUMINIUM | \	iSillType = SILL_SIMPLEBLOCK | \	iSillType = SILL_BLOCK | \	iSillType = SILL_DUTCH) & not(gs_stack_bottom) then	if AC_HoleSideMaterial then		if WIDO_REVEAL_SIDE then			matRevealSide	= WALL_MAT_A		else			matRevealSide	= WALL_MAT_B		endif	else		matRevealSide	= WALL_MAT_EDGE	endif	pen WALL_VIEW_PEN	if not(curvedWall) then! Straight Wall ================================================================		if iSillType = SILL_TIMBER then		! to USA Timber Sill			cy = abs(gs_sill_elev + sillElevation)			cx = 0		endif		if iSillType = SILL_BRICK then	! Brick Sill			cy = gs_sill_thk / cos(gs_sill_angle) + tan(gs_sill_angle) * (WIDO_SILL + gs_sill_slip_in)			cx = max(gs_sill_holeDepthBehind, sin(gs_sill_angle) * gs_sill_thk)		endif		if iSillType = SILL_SIMPLEBLOCK then	! Brick Sill			cy = gs_sill_thk			cx = gs_sill_holeDepthBehind		endif		if iSillType = SILL_CERAMIC then			cy = gs_sill_topHeight * cos(gs_sill_angle) + tan(gs_sill_angle) * (WIDO_SILL + gs_sill_slip_in) + gs_sill_endthk / cos(gs_sill_angle)			cx = gs_sill_holeDepthBehind		endif		if iSillType = SILL_STONE | iSillType = SILL_ETHERNIT | iSillType = SILL_CONCRETE_TUB then			cy = gs_sill_thk			cx = gs_sill_holeDepthBehind		endif		if iSillType = SILL_ALUMINIUM then			cy = max(0, gs_sill_topHeight) + max(0, (WIDO_SILL - thk + gs_sill_slip_in) * tan(gs_sill_angle)) + thk / cos(gs_sill_angle) - gs_sill_dripnos * (WIDO_SILL + gs_sill_slip_in) / (gs_sill_width - thk)			cx = gs_sill_holeDepthBehind		endif		if iSillType = SILL_BLOCK | iSillType = SILL_DUTCH then			gs_sill_slip_in = WIDO_FRAME_THICKNESS			cx = 0			cy = gs_sill_thk		endif		if gs_sill_slip_wall > EPS then			cx = max(cx, gs_sill_slip_wall - WIDO_SILL - gs_sill_slip_in)		endif		material matRevealSide		if WIDO_REVEAL_SIDE then			muly -1			addy WIDO_FRAME_THICKNESS		endif		if abs(cy) > EPS then			bExtraWallnicheOnLeft	= 0			bExtraWallnicheOnRight	= 0			if sidelightCutLeft then				if sidelightCutLeft = 1 then					leftCutLimit = sidelightCutPosLeft - 0.1				else					leftCutLimit = sidelightCutPosLeft + gs_turn_plaster_show_3D * thkPlasterAtSillSlLeft				endif				if (iSillType = SILL_DUTCH) & ((iRevealType = REVEAL_NEGATIVE) |\											   ((iRevealType = REVEAL_DOUBLE) & (iSillRevealType = REVEAL_NEGATIVE))) then					leftCutLimit2 = leftCutLimit + gs_reveal_left_sL					bExtraWallnicheOnLeft = 1				endif			else				if bLeftCornerFunction | stackLeft then					leftCutLimit = pxL				else					if (iSillType = SILL_DUTCH) & ((iRevealType = REVEAL_NEGATIVE) |\												   ((iRevealType = REVEAL_DOUBLE) & (iSillRevealType = REVEAL_NEGATIVE))) then						leftCutLimit = leftRevealPnts[idxFrameStartRevealLeft][1]						leftCutLimit2 = leftRevealPnts[idxSillStartRevealLeft][1] + thkPlasterAtSillLeft						bExtraWallnicheOnLeft = 1					else						leftCutLimit = leftRevealPnts[idxSillStartRevealLeft][1] + thkPlasterAtSillLeft					endif				endif			endif			if sidelightCutRight then				if sidelightCutRight = 1 then					rightCutLimit = sidelightCutPosRight + 0.1				else					rightCutLimit = sidelightCutPosRight - gs_turn_plaster_show_3D * thkPlasterAtSillSlRight				endif				if (iSillType = SILL_DUTCH) & ((iRevealType = REVEAL_NEGATIVE) |\											   ((iRevealType = REVEAL_DOUBLE) & (iSillRevealType = REVEAL_NEGATIVE))) then					rightCutLimit2 = rightCutLimit - gs_reveal_right_sR					bExtraWallnicheOnRight = 1				endif			else				if bRightCornerFunction | stackRight then					rightCutLimit = pxR				else					if (iSillType = SILL_DUTCH) & ((iRevealType = REVEAL_NEGATIVE) |\												   ((iRevealType = REVEAL_DOUBLE) & (iSillRevealType = REVEAL_NEGATIVE))) then						rightCutLimit = rightRevealPnts[idxFrameStartRevealRight][1]						rightCutLimit2 = rightRevealPnts[idxSillStartRevealRight][1] - thkPlasterAtSillRight						bExtraWallnicheOnRight = 1					else						rightCutLimit = rightRevealPnts[idxSillStartRevealRight][1] - thkPlasterAtSillRight					endif				endif			endif			rotx 90			wallniche 4, 1, 2 + 16,				0,0,1, gs_sill_slip_in + cx,				rightCutLimit,	 0,		31,				rightCutLimit,	-cy,	31,				leftCutLimit,	-cy,	31,				leftCutLimit,	 0,		31			if bExtraWallnicheOnLeft then				wallniche 4, 1, 2 + 16,					0,0,1, cx,					leftCutLimit,	 0,		31,					leftCutLimit,	-cy,	31,					leftCutLimit2,	-cy,	31,					leftCutLimit2,	 0,		31			endif			if bExtraWallnicheOnRight then				wallniche 4, 1, 2 + 16,					0,0,1, cx,					rightCutLimit,	 0,		31,					rightCutLimit,	-cy,	31,					rightCutLimit2,	-cy,	31,					rightCutLimit2,	 0,		31			endif			del 1		endif		if WIDO_REVEAL_SIDE then del 2	else! Curved Wall ==================================================================		if WIDO_REVEAL_SIDE then muly -1		maxSillLength = max(WIDO_SILL, abs(radSill - abs(WOD)))		if iSillType = SILL_BRICK then			cy = gs_sill_thk / cos(gs_sill_angle) + tan(gs_sill_angle) * (maxSillLength + gs_sill_slip_in)			cx = sin(gs_sill_angle) * gs_sill_thk		endif		if iSillType = SILL_SIMPLEBLOCK then	! Brick Sill			cy = gs_sill_thk			cx = gs_sill_holeDepthBehind		endif		if iSillType = SILL_CERAMIC then			cy = gs_sill_thk / cos(gs_sill_angle) + tan(gs_sill_angle) * (maxSillLength + gs_sill_slip_in)			cx = 0		endif		if iSillType = SILL_STONE | iSillType = SILL_ETHERNIT | iSillType = SILL_CONCRETE_TUB then			cy = gs_sill_thk			cx = 0		endif		if iSillType = SILL_ALUMINIUM then			cy = max(0, gs_sill_topHeight) + max(0, (WIDO_SILL - thk) * tan(gs_sill_angle)) + thk / cos(gs_sill_angle)		endif		if iSillType = SILL_BLOCK | iSillType = SILL_DUTCH then			gs_sill_slip_in = WIDO_FRAME_THICKNESS			cx = 0			cy = gs_sill_thk		endif		if gs_sill_slip_wall > EPS then			cx = max(cx, gs_sill_slip_wall - WIDO_SILL - gs_sill_slip_in)		endif		if wallIsLeft then			leftJamb	= leftWidth  + WOD * tan(alfaLeftOs  - alfaLeftJamb)  + gs_left_oversize			rightJamb	= rightWidth + WOD * tan(alfaRightOs - alfaRightJamb) + gs_right_oversize			if stackLeft  then leftJamb  = leftJamb			if stackRight then rightJamb = rightJamb			if sidelightCutRight then				if sidelightCutRight = 1 then					leftCutLimit = sidelightCutPosRight + 0.1				else					leftCutLimit = sidelightCutPosRight - gs_turn_plaster_show_3D * thkPlasterAtSillSlRight				endif			else				leftCutLimit = -leftWidth  + rightJamb - overSizeRight			endif			if sidelightCutLeft then				if sidelightCutLeft = 1 then					rightCutLimit = sidelightCutPosLeft - 0.1				else					rightCutLimit = sidelightCutPosLeft + gs_turn_plaster_show_3D * thkPlasterAtSillSlLeft				endif			else				rightCutLimit = rightWidth - leftJamb  + overSizeLeft			endif			addy WIDO_FRAME_THICKNESS * WIDO_REVEAL_SIDE			rotx 90			material matRevealSide			if sidelightCutRight = 2 then				leftEnd = leftCutLimit - 0.1				wallniche 4, 1, 2 + 16,					0,0,1, gs_sill_slip_in + cx,					leftCutLimit - 0.15,	 0,		31,					leftCutLimit - 0.15,	-cy,	31,					leftCutLimit,			-cy,	31,					leftCutLimit,			 0,		31			else				leftEnd = leftCutLimit			endif			if sidelightCutLeft = 2 then				rightEnd = rightCutLimit + 0.1				wallniche 4, 1, 2 + 16,					0,0,1, gs_sill_slip_in + cx,					rightCutLimit + 0.15,	 0,		31,					rightCutLimit + 0.15,	-cy,	31,					rightCutLimit,			-cy,	31,					rightCutLimit,			 0,		31			else				rightEnd = rightCutLimit			endif			wallniche 4, 3, 2 + 16,				0,0,WOD, gs_sill_slip_in + cx,				rightEnd,	 0,		31,				rightEnd,	-cy,	31,				leftEnd,	-cy,	31,				leftEnd,	 0,		31			del 2		else			dy = gs_sill_slip_in + cx			dxL = dy * tan(alfaLeftOs - alfaLeftJamb)			dxR = dy * tan(alfaRightOs - alfaRightJamb)			leftJamb	= leftWidth  + WOD * tan(alfaLeftOs  - alfaLeftJamb)  + gs_left_oversize			rightJamb	= rightWidth + WOD * tan(alfaRightOs - alfaRightJamb) + gs_right_oversize			if stackLeft  then leftJamb  = 0			if stackRight then rightJamb = 0			if sidelightCutLeft then				if sidelightCutLeft = 1 then					leftCutLimit = sidelightCutPosLeft - 0.1				else					leftCutLimit = sidelightCutPosLeft + gs_turn_plaster_show_3D * thkPlasterAtSillSlLeft				endif			else				leftCutLimit = -leftWidth  - dxL + leftJamb  - overSizeLeft			endif			if sidelightCutRight then				if sidelightCutRight = 1 then					rightCutLimit = sidelightCutPosRight + 0.1				else					rightCutLimit = sidelightCutPosRight - gs_turn_plaster_show_3D * thkPlasterAtSillSlRight				endif			else				rightCutLimit = rightWidth + dxR - rightJamb + overSizeRight			endif			addy WIDO_FRAME_THICKNESS * WIDO_REVEAL_SIDE - dy			rotx 90			if sidelightCutLeft = 2 then				leftEnd = leftCutLimit + 0.1				wallniche 4, 1, 2 + 16,					0,0,1, 0,					leftCutLimit + 0.15,	 0,		31,					leftCutLimit + 0.15,	-cy,	31,					leftCutLimit,			-cy,	31,					leftCutLimit,			 0,		31			else				leftEnd = leftCutLimit			endif			if sidelightCutRight = 2 then				rightEnd = rightCutLimit - 0.1				wallniche 4, 1, 2 + 16,					0,0,1, 0,					rightCutLimit - 0.15,	 0,		31,					rightCutLimit - 0.15,	-cy,	31,					rightCutLimit,			-cy,	31,					rightCutLimit,			 0,		31			else				rightEnd = rightCutLimit			endif			material matRevealSide			wallniche 4, 3, 2,				0,0,WOD - dy, 16 * WIDO_SILL,				rightEnd,	 0,		31,				rightEnd,	-cy,	31,				leftEnd,	-cy,	31,				leftEnd,	 0,		31			del 2		endif		del WIDO_REVEAL_SIDE	endifendifreturn! ==============================================================================! Arch Segmentation! ------------------------------------------------------------------------------! Input parameters:!	alfaStart:		Start angle (angle)!	alfaEnd:		End angle (angle)!	arcRadius:		Arc radius (length)!	bMiddlePoints:	Generate middle points (0 / 1)!	firstStatus:	Status of the first segment (integer)!	lastStatus:		Status of the last segment (integer)! ==============================================================================100:	if not(wallIsLeft) then		alfaStart = 180 - alfaStart		alfaEnd = 180 - alfaEnd	endif	segmentAngle = 360 / WALL_RESOL	! --- Point at Start Angle ---	if WIDO_REVEAL_SIDE then		if SYMB_ROTANGLE < EPS then			difAngle = (AC_Hole_Position_Angle + alfaStart) mod segmentAngle		else			difAngle = -(AC_Hole_Position_Angle - 180 - alfaStart) mod segmentAngle		endif	else		if SYMB_ROTANGLE < EPS then			difAngle = -(AC_Hole_Position_Angle - alfaStart + 180) mod segmentAngle		else			difAngle = (AC_Hole_Position_Angle + alfaStart) mod segmentAngle		endif	endif	difAngle2 = difAngle	if abs(difAngle) > segmentAngle / 2 then difAngle = -segmentAngle / 2 + abs(difAngle mod (segmentAngle / 2))	segmentR = arcRadius / cos(difAngle)	put segmentR * sin(alfaStart), -segmentR * cos(alfaStart) + WOD, firstStatus	if bMiddlePoints then		! --- Middle Points ---		segmentR = arcRadius / cos(segmentAngle / 2)		if alfaStart > alfaEnd then			alfaActual = alfaStart - difAngle2 + segmentAngle / 2			if alfaActual > alfaStart then alfaActual = alfaActual - segmentAngle			if alfaActual > alfaStart then alfaActual = alfaActual - segmentAngle			if alfaActual < alfaEnd then alfaActual = alfaActual + segmentAngle			if alfaActual < alfaStart & alfaActual > alfaEnd then				do					put segmentR * sin(alfaActual), -segmentR * cos(alfaActual) + WOD, 79					alfaActual = alfaActual - segmentAngle				while alfaActual > alfaEnd			endif		else			alfaActual = alfaStart - difAngle2 - segmentAngle / 2			if alfaActual < alfaStart then alfaActual = alfaActual + segmentAngle			if alfaActual > alfaEnd then alfaActual = alfaActual - segmentAngle			if alfaActual > alfaStart & alfaActual < alfaEnd then				do					put segmentR * sin(alfaActual), -segmentR * cos(alfaActual) + WOD, 79					alfaActual = alfaActual + segmentAngle				while alfaActual < alfaEnd			endif		endif	endif	! --- Point at End Angle ---	if WIDO_REVEAL_SIDE then		if SYMB_ROTANGLE < EPS then			difAngle = (AC_Hole_Position_Angle + alfaEnd) mod segmentAngle		else			difAngle = -(AC_Hole_Position_Angle + 180 - alfaEnd) mod segmentAngle		endif	else		if SYMB_ROTANGLE < EPS then			difAngle = -(AC_Hole_Position_Angle - alfaEnd + 180) mod segmentAngle		else			difAngle = (AC_Hole_Position_Angle + alfaEnd) mod segmentAngle		endif	endif	if abs(difAngle) > segmentAngle / 2 then difAngle = -segmentAngle / 2 + abs(difAngle mod (segmentAngle / 2))	segmentR = arcRadius / cos(difAngle)	put segmentR * sin(alfaEnd), -segmentR * cos(alfaEnd) + WOD, lastStatusreturn1000:! ==============================================================================! Get GDL Polygon! ------------------------------------------------------------------------------! Input variables:!	ch:					Channel!	polygonID:			Polygon index!	defaultStatusCode:	Default status code!	statusCodes[]:		Status code array!! Returned variables:!	GDL stack:			GDL polygon! ==============================================================================	dim resVertices[]	numVertices = callfunction(ch, "GetVertices", polygonID, resVertices)	numVertices = numVertices / 3	dim contArr[]	numContours = callfunction(ch, "GetContourEnds", polygonID, contArr)	dim inhEdgeInfos[]	numEdges = callfunction(ch, "GetInhEdgeInfos", polygonID, inhEdgeInfos)	for contIndex = 1 to numContours		if contIndex = 1 then			begIdx = 0		else			begIdx = contArr[contIndex] - 1		endif		if contIndex = numContours then			endIdx = numVertices - 1		else			endIdx = contArr[contIndex + 1] - 2		endif		bClosed = 0		bStartWithLast = 0		index = endIdx * 3		lastVertX	= resVertices[index + 1]		lastVertY	= resVertices[index + 2]		lastVertA	= resVertices[index + 3]		edgeInfo	= inhEdgeInfos[begIdx + 1]		if abs(lastVertA) > EPS then			put lastVertX, lastVertY, 1			bStartWithLast = 1		endif		for vertIndex = begIdx to endIdx			index = vertIndex * 3			actVertX = resVertices[index + 1]			actVertY = resVertices[index + 2]			actVertA = resVertices[index + 3]			if edgeInfo > 0 & edgeInfo <= vardim1(statusCodes) then				statusCode = statusCodes[edgeInfo]			else				statusCode = defaultStatusCode			endif			if vertIndex = begIdx then				if bStartWithLast then					ac2gdl_spx = lastVertX					ac2gdl_spy = lastVertY				else					ac2gdl_spx = actVertX					ac2gdl_spy = actVertY				endif			endif			if abs(lastVertA) > EPS then				ac2gdl_mx = (actVertX + lastVertX) / 2				ac2gdl_my = (actVertY + lastVertY) / 2				ac2gdl_ratio = 1 / 2 / tan (lastVertA / 2)				ac2gdl_cx = ac2gdl_mx - ac2gdl_ratio * (actVertY - lastVertY)	! Arc center				ac2gdl_cy = ac2gdl_my + ac2gdl_ratio * (actVertX - lastVertX)				put ac2gdl_cx,	ac2gdl_cy,	900,					0,			lastVertA,	4000 + statusCode + 64			endif			if vertIndex > begIdx & abs(ac2gdl_spx - actVertX) < EPS & abs(ac2gdl_spy - actVertY) < EPS then!!!				put actVertX, actVertY, -1	! Sill polygon never contains holes				bClosed = 1			else				if vertIndex < endIdx | not(bStartWithLast) then					put actVertX, actVertY, statusCode				endif			endif			lastVertX	= actVertX			lastVertY	= actVertY			lastVertA	= actVertA			edgeInfo	= inhEdgeInfos[vertIndex + 2]		next vertIndex		if not(bClosed) & numContours > 1 then	! Close the polygon if it has holes			put ac2gdl_spx, ac2gdl_spy, -1		endif	next contIndexreturn! ------------------------------------------------------------------------------! Timber Sill & Sill Elevation for Timber Sill! ------------------------------------------------------------------------------! Input variables:!	sillElevation:			Sill Elevation!	angleSill: 				Sill Angle!	sidelightCutLeft:		Need cut on left side!	sidelightCutPosLeft:	Cutting position on left side!	sidelightCutRight:		Need cut on right side!	sidelightCutPosRight:	Cutting position on right side!	hSill:					Sill Thickness!	bSillCurved:			Sill in Curved Wall, 0: straight, 1: curved!	sillNosing:				Sill Nosing!	matSill:				Sill Material! ------------------------------------------------------------------------------"DrawSill_Timber":! cutting shape for casing -----------------------------------------------------	if not(gs_fsill) then		! Bottom frame at sill option in USA windows		if AC_WallType <> 2 then			if not(curvedWall) then				if sidelightCutLeft then					if not(bElevBody) then						py = spy4 - (spy4 - spy5) / (spx5 - spx4) * (sidelightCutPosLeft - spx4)					else						py = spy3 - (spy3 - spy6) / (spx6 - spx3) * (sidelightCutPosLeft - spx3)					endif					if sidelightCutLeft = 2 & (gs_turn_plaster_show_3D | gs_sill_ovhg_left > EPS) then						put sidelightCutPosLeft + thkPlasterAtSillSlLeft * gs_turn_plaster_show_3D,	 0,			15,							sidelightCutPosLeft + thkPlasterAtSillSlLeft * gs_turn_plaster_show_3D,	-WIDO_SILL,	15,							sidelightCutPosLeft - gs_sill_ovhg_left,								-WIDO_SILL,	15,							sidelightCutPosLeft - gs_sill_ovhg_left,								 py,		15					else						put sidelightCutPosLeft,	0,	15,							sidelightCutPosLeft,	py,	15					endif				else					if (thkPlasterAtSillLeft > EPS) & gs_turn_plaster_show_3D then						startIdx = idxSillEndPlasterLeft						endIdx	 = idxSillStartPlasterLeft					else						startIdx = idxSillEndRevealLeft						endIdx	 = idxSillStartRevealLeft					endif					for i = startIdx to endIdx step -1						put leftRevealPnts[i][1], leftRevealPnts[i][2], 8 + 7 * not(stackLeft)	! 15 or 8					next i					put	spx3, spy3,	 8 + 7 * not(stackLeft)								! 15 or 8					if not(bElevBody) then put spx4, spy4, 13 + 2 * not(stackLeft)		! 15 or 13				endif				if sidelightCutRight then					if not(bElevBody) then						py = spy4 - (spy4 - spy5) / (spx5 - spx4) * (sidelightCutPosRight - spx4)					else						py = spy3 - (spy3 - spy6) / (spx6 - spx3) * (sidelightCutPosRight - spx3)					endif					if sidelightCutRight = 2 & (gs_turn_plaster_show_3D | gs_sill_ovhg_right > EPS) then						put sidelightCutPosRight + gs_sill_ovhg_right,									 py,		15,							sidelightCutPosRight + gs_sill_ovhg_right,									-WIDO_SILL,	15,							sidelightCutPosRight - thkPlasterAtSillSlRight * gs_turn_plaster_show_3D,	-WIDO_SILL,	15,							sidelightCutPosRight - thkPlasterAtSillSlRight * gs_turn_plaster_show_3D,	 0,			15					else						put sidelightCutPosRight,	py,	15,							sidelightCutPosRight,	0,	15					endif				else					if not(bElevBody) then put spx5, spy5,  8 + 7 * not(stackRight)		! 15 or 8					put	spx6, spy6,  8 + 7 * not(stackRight)							! 15 or 8					if (thkPlasterAtSillRight > EPS) & gs_turn_plaster_show_3D then						startIdx = idxSillStartPlasterRight						endIdx	 = idxSillEndPlasterRight					else						startIdx = idxSillStartRevealRight						endIdx	 = idxSillEndRevealRight					endif					for i = startIdx to endIdx						if i = endIdx then							put rightRevealPnts[i][1], rightRevealPnts[i][2], 13 + 2 * not(stackRight)	! 15 or 13						else							put rightRevealPnts[i][1], rightRevealPnts[i][2], 8 + 7 * not(stackRight)	! 15 or 8						endif					next i				endif			else				bCurvedAtSillSide		= (curvedWall & iSillType = SILL_TIMBER & bSillCurved)				bCurvedAtWindowFrame	= (curvedWall & gs_IsCurved)				if bCurvedAtSillSide & not(bCurvedAtWindowFrame) & not(wallIsLeft) then					if abs(WOD) < radSill - sillNosing + EPS then						bCurvedAtSillSide = 0					endif				endif! Calculation for curved wall --------------------------------------------------				if sidelightCutLeft then					if bCurvedAtSillSide then						pLy = WOD - iArchSign * sqr((radSill + iArchSign * gs_sill_nosing)^2 - (sidelightCutPosLeft - gs_sill_ovhg_left * (sidelightCutLeft = 2))^2)					else						pLy = spy4 - (spy4 - spy5) / (spx5 - spx4) * (sidelightCutPosLeft - spx4)					endif					if sidelightCutLeft = 2 & (gs_turn_plaster_show_3D | gs_sill_ovhg_left > EPS) then						pLy1 = WOD - iArchSign * sqr(radSill^2 - (sidelightCutPosLeft + thkPlasterAtSillSlLeft * gs_turn_plaster_show_3D)^2)						pLy2 = WOD - iArchSign * sqr(radSill^2 - (sidelightCutPosLeft - gs_sill_ovhg_left)^2)					endif					pLy3 = WOD - iArchSign * sqr(radSill^2 - sidelightCutPosLeft^2)				endif				if sidelightCutRight then					if bCurvedAtSillSide then						pRy = WOD - iArchSign * sqr((radSill + iArchSign * gs_sill_nosing)^2 - (sidelightCutPosRight + gs_sill_ovhg_right * (sidelightCutRight = 2))^2)					else						pRy = spy4 - (spy4 - spy5) / (spx5 - spx4) * (sidelightCutPosRight - spx4)					endif					pRy1 = WOD - iArchSign * sqr(radSill^2 - (sidelightCutPosRight + gs_sill_ovhg_right)^2)					pRy2 = WOD - iArchSign * sqr(radSill^2 - (sidelightCutPosRight - thkPlasterAtSillSlRight * gs_turn_plaster_show_3D)^2)					pRy3 = WOD - iArchSign * sqr(radSill^2 - sidelightCutPosRight^2)				endif! Sill Body points -------------------------------------------------------------				if not(bElevBody) then					put 0, WOD, 900					if sidelightCutLeft then						if sidelightCutLeft = 2 & (gs_turn_plaster_show_3D | gs_sill_ovhg_left > EPS) then							put sidelightCutPosLeft + thkPlasterAtSillSlLeft * gs_turn_plaster_show_3D,	0,		15							put sidelightCutPosLeft + thkPlasterAtSillSlLeft * gs_turn_plaster_show_3D,	pLy1,	15							put sidelightCutPosLeft - gs_sill_ovhg_left,								pLy2,	15							if bCurvedAtSillSide then								put sidelightCutPosLeft - gs_sill_ovhg_left, pLy + iArchSign * EPS, 15							endif							put sidelightCutPosLeft - gs_sill_ovhg_left, pLy, 15 + bCurvedAtSillSide * 64						else							put sidelightCutPosLeft,	0,		15							put sidelightCutPosLeft,	pLy,	15 + bCurvedAtSillSide * 64						endif					else						if (thkPlasterAtSillLeft > EPS) & gs_turn_plaster_show_3D then							startIdx = idxSillEndPlasterLeft							endIdx	 = idxSillStartPlasterLeft						else							startIdx = idxSillEndRevealLeft							endIdx	 = idxSillStartRevealLeft						endif						for i = startIdx  to (endIdx + 1) step -1							put leftRevealPnts[i][1], leftRevealPnts[i][2],	8 + 7 * not(stackLeft)						next i						if gs_sill_ovhg_left > EPS | ((thkPlasterAtSillLeft > EPS) & gs_turn_plaster_show_3D) then							alfaStart	= -signWallIsLeft * atn(leftRevealPnts[endIdx][1] / (leftRevealPnts[endIdx][2] - WOD))							alfaEnd		= -signWallIsLeft * atn(spx3 / (spy3 - WOD))							arcRadius	= radSill							bMiddlePoints = 1							firstStatus	= 8 + 7 * not(stackLeft) + 64							lastStatus	= 8 + 7 * not(stackLeft) + 64							if abs(alfaStart - alfaEnd) > EPS then gosub 100						endif						put	spx4, spy4,	13 + 2 * not(stackRight) + bCurvedAtSillSide * 64					endif					if sidelightCutRight then						if sidelightCutRight = 2 & (gs_turn_plaster_show_3D | gs_sill_ovhg_right > EPS) then							put sidelightCutPosRight + gs_sill_ovhg_right,									pRy,	15 + 3064 * bCurvedAtSillSide							put sidelightCutPosRight + gs_sill_ovhg_right,									pRy1,	15							put sidelightCutPosRight - thkPlasterAtSillSlRight * gs_turn_plaster_show_3D,	pRy2,	15							put sidelightCutPosRight - thkPlasterAtSillSlRight * gs_turn_plaster_show_3D,	0,		15						else							put sidelightCutPosRight,	pRy,	15 + 3064 * bCurvedAtSillSide							put sidelightCutPosRight,	0,		15						endif					else						put	spx5, spy5,	3000 * bCurvedAtSillSide + 8 + 7 * not(stackRight)			! 15 or 8						if (thkPlasterAtSillRight > EPS) & gs_turn_plaster_show_3D then							startIdx = idxSillStartPlasterRight							endIdx	 = idxSillEndPlasterRight						else							startIdx = idxSillStartRevealRight							endIdx	 = idxSillEndRevealRight						endif						if gs_sill_ovhg_right > EPS | ((thkPlasterAtSillRight > EPS) & gs_turn_plaster_show_3D) then							alfaStart	= -signWallIsLeft * atn(spx6 / (spy6 - WOD))							alfaEnd		= -signWallIsLeft * atn(rightRevealPnts[startIdx][1] / (rightRevealPnts[startIdx][2] - WOD))							arcRadius	= radSill							bMiddlePoints = 1							firstStatus	= 8 + 7 * not(stackRight) + 64							lastStatus	= 8 + 7 * not(stackRight) + 64							if abs(alfaStart - alfaEnd) > EPS then gosub 100						endif						for i = (startIdx + 1) to endIdx							if i = idxSillEndRevealRight then								put rightRevealPnts[i][1], rightRevealPnts[i][2], 13 + 2 * not(stackRight) 	! 15 or 13							else								put rightRevealPnts[i][1], rightRevealPnts[i][2],  8 + 7 * not(stackLeft)	! 15 or 8							endif						next i					endif					if not(sidelightCutLeft) then						! Close polygon						if (thkPlasterAtSillLeft > EPS) & gs_turn_plaster_show_3D then							put	leftRevealPnts[idxSillEndPlasterLeft][1], leftRevealPnts[idxSillEndPlasterLeft][2], 3000 * (bCurvedAtWindowFrame) + 15						else							put	leftRevealPnts[idxSillEndRevealLeft][1],  leftRevealPnts[idxSillEndRevealLeft][2],  3000 * (bCurvedAtWindowFrame) + 15						endif					endif				else! Elevation Body points ---------------------------------------------------------					put 0, WOD, 900					if sidelightCutLeft then						if sidelightCutLeft = 2 & (gs_turn_plaster_show_3D | gs_sill_ovhg_left > EPS) then							put sidelightCutPosLeft + thkPlasterAtSillSlLeft * gs_turn_plaster_show_3D,	0, 15							alfaStartElevBody = -signWallIsLeft * atn((sidelightCutPosLeft + thkPlasterAtSillSlLeft * gs_turn_plaster_show_3D) / (pLy1 - WOD))						else							put sidelightCutPosLeft, 0, 15							alfaStartElevBody = -signWallIsLeft * atn(sidelightCutPosLeft / (pLy3 - WOD))						endif					else						if (thkPlasterAtSillLeft > EPS) & gs_turn_plaster_show_3D then							startIdx = idxSillEndPlasterLeft							endIdx	 = idxSillStartPlasterLeft							alfaStartElevBody = -signWallIsLeft * atn(leftRevealPnts[idxSillStartPlasterLeft][1] / (leftRevealPnts[idxSillStartPlasterLeft][2] - WOD))						else							startIdx = idxSillEndRevealLeft							endIdx	 = idxSillStartRevealLeft							alfaStartElevBody = -signWallIsLeft * atn(leftRevealPnts[idxSillStartRevealLeft][1]  / (leftRevealPnts[idxSillStartRevealLeft][2]  - WOD))						endif						for i = startIdx  to (endIdx + 1) step -1							put leftRevealPnts[i][1], leftRevealPnts[i][2],	8 + 7 * not(stackLeft)			! 15 or 8						next i					endif					if sidelightCutRight then						if sidelightCutRight = 2 & (gs_turn_plaster_show_3D | gs_sill_ovhg_right > EPS) then							alfaEndElevBody = -signWallIsLeft * atn((sidelightCutPosRight - thkPlasterAtSillSlRight * gs_turn_plaster_show_3D) / (pRy2 - WOD))						else							alfaEndElevBody = -signWallIsLeft * atn(sidelightCutPosRight / (pRy3 - WOD))						endif					else						if (thkPlasterAtSillRight > EPS) & gs_turn_plaster_show_3D then							alfaEndElevBody = -signWallIsLeft * atn(rightRevealPnts[idxSillStartPlasterRight][1] / (rightRevealPnts[idxSillStartPlasterRight][2] - WOD))						else							alfaEndElevBody = -signWallIsLeft * atn(rightRevealPnts[idxSillStartRevealRight][1]  / (rightRevealPnts[idxSillStartRevealRight][2]  - WOD))						endif					endif					if bElevBody then						alfaStart	= alfaStartElevBody						alfaEnd		= alfaEndElevBody						arcRadius	= radSill						bMiddlePoints = 1						firstStatus	= 15 ! 8 + 7 * not(gs_stack_right)						lastStatus	= 15 ! 10 + 5 * not(gs_stack_left)						gosub 100					endif					if sidelightCutRight then						if sidelightCutRight = 2 & (gs_turn_plaster_show_3D | gs_sill_ovhg_right > EPS) then							put sidelightCutPosRight - thkPlasterAtSillSlRight * gs_turn_plaster_show_3D, 0, 15						else							put sidelightCutPosRight, 0, 15						endif					else						if (thkPlasterAtSillRight > EPS) & gs_turn_plaster_show_3D then							startIdx = idxSillStartPlasterRight							endIdx	 = idxSillEndPlasterRight						else							startIdx = idxSillStartRevealRight							endIdx	 = idxSillEndRevealRight						endif						for i = (startIdx + 1) to endIdx							if i = idxSillEndRevealRight then								put rightRevealPnts[i][1], rightRevealPnts[i][2], 13 + 2 * not(stackRight) 	! 15 or 13							else								put rightRevealPnts[i][1], rightRevealPnts[i][2],  8 + 7 * not(stackLeft)	! 15 or 8							endif						next i					endif				endif			endif! --------------------------------------------------------			if nsp > 0 then				sprism_ matSill, matSill, matSill,					nsp/3, 0,0, 1,0, hSill, -angleSill, get(nsp)			endif! Hotspots ---------------------------------------------------------------------			if not(bElevBody) then				if sidelightCutLeft then					if sidelightCutLeft = 2 & gs_turn_plaster_show_3D then						hotspot sidelightCutPosLeft + thkPlasterAtSillSlLeft, leftRevealPnts[idxSillEndRevealLeft][2], gs_sill_thk, 10052					else						hotspot sidelightCutPosLeft, leftRevealPnts[idxSillEndRevealLeft][2], gs_sill_thk, 10051					endif				else					hotspot leftRevealPnts[idxSillEndRevealLeft][1],  leftRevealPnts[idxSillEndRevealLeft][2], gs_sill_thk, 10000				endif				if sidelightCutRight then					if sidelightCutRight = 2 & gs_turn_plaster_show_3D then						hotspot sidelightCutPosRight - thkPlasterAtSillSlRight, rightRevealPnts[ idxSillEndRevealRight][2], gs_sill_thk, 10053					else						hotspot sidelightCutPosRight, rightRevealPnts[idxSillEndRevealRight][2], gs_sill_thk, 10050					endif				else					hotspot rightRevealPnts[idxSillEndRevealRight][1], rightRevealPnts[idxSillEndRevealRight][2], gs_sill_thk, 10001				endif			endif		else			ch = initaddonscope ("PolyOperations", "", "")! Generate Sill Polygon --------------------------------------------------------			bGetWallCutPolygons = 0			bPolyFor3D = 1			gosub 2000! Draw resulting polygons ------------------------------------------------------			defaultStatusCode = 8			dim statusCodes[2]			statusCodes[1] = 15			statusCodes[2] = 15			dim resPolyIDArr[]			numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)			for i = 1 to numPoly				polygonID = resPolyIDArr[i]				gosub 1000	! Get GDL Polygon				sprism_ matSill, matSill, matSill,						nsp/3, 0,0, 1,0, hSill, -angleSill, get(nsp)			next i! Close channel ----------------------------------------------------------------			closeaddonscope ch		endif	endifreturn! ------------------------------------------------------------------------------! Brick Sill! ------------------------------------------------------------------------------10200:	if iSillType = SILL_BRICK | iSillType = SILL_SIMPLEBLOCK | iSillType = SILL_BLOCK then		gs_sill_width = gs_sill_thk * tan(gs_sill_angle) + (WIDO_SILL + SillSlipin + gs_sill_nosing) / cos(gs_sill_angle)		put 	-SillSlipin,																		0,														15,				-SillSlipin + gs_sill_width * cos(gs_sill_angle),									gs_sill_width * sin(gs_sill_angle),						15,				-SillSlipin + gs_sill_width * cos(gs_sill_angle) - gs_sill_thk * sin(gs_sill_angle),gs_sill_width * sin(gs_sill_angle) + gs_sill_thk * cos(gs_sill_angle),	15,				-SillSlipin - gs_sill_thk * sin(gs_sill_angle),										gs_sill_thk * cos(gs_sill_angle),						15		if iBrickSilldetlevel = BRICKSILL_SIMPLE then			prism_ 4, pxR - pxL,				use (nsp)		endif		for i = 1 to nsp/3			sillPoly[(i-1) * 2 + 1] = get (1)			sillPoly[(i-1) * 2 + 2] = get (1)			eeeeee = get (1)		next i		sillLeft			= abs(pxL)		sillRight			= abs(pxR)		sillBottom			= -(gs_sill_thk / cos (gs_sill_angle) + (gs_sill_slip_in + WIDO_SILL) * tan(gs_sill_angle))		sillBottomOutside	= sillBottom		sillSideHeight		= -sillBottom - SillSlipin * tan(gs_sill_angle)		sillSideAngle		= gs_sill_angle		if iBrickSilldetlevel = BRICKSILL_DETAILED then			addx -SillSlipin			rotz gs_sill_angle			if stackLeft then				rotx 90				cutpolya 4, 2, 0,						-1, -1, 10,						1, -1, 10,						1, 0, 10,						-1, 0, 10				del 1			endif			if stackRight then				rotx 90				addy (pxR - pxL)				cutpolya 4, 2, 0,						-1, 1, 10,						1, 1, 10,						1, 0, 10,						-1, 0, 10				del 2			endif			db = int((pxR - pxL) / (gs_brick_sill_br_thk + gs_brick_sill_mort_thk))			if db > 1 then				gs_mor_th2=((pxR - pxL)-(db*gs_brick_sill_br_thk))/(db-1)			else				gs_brick_sill_br_thk = pxR - pxL			endif			if stackLeft+stackRight=1 then				db=INT((pxR - pxL+gs_brick_sill_br_thk/2)/(gs_brick_sill_br_thk+gs_brick_sill_mort_thk))				gs_mor_th2=((pxR - pxL+gs_brick_sill_br_thk/2)-(db*gs_brick_sill_br_thk))/(db-1)			endif			if stackLeft+stackRight=2 then				db=INT((pxR - pxL+gs_brick_sill_br_thk)/(gs_brick_sill_br_thk+gs_brick_sill_mort_thk))				gs_mor_th2=((pxR - pxL+gs_brick_sill_br_thk)-(db*gs_brick_sill_br_thk))/(db-1)			endif			addz -gs_brick_sill_br_thk/2*(stackLeft)			material gs_sill_mat			for i=1 to db+cowi*100				prism_ 4, gs_brick_sill_br_thk,						0,				0,				15,						gs_sill_width,	0,				15,						gs_sill_width,	gs_sill_thk,	15,						0,				gs_sill_thk,	15				addz gs_brick_sill_br_thk+gs_mor_th2			next i			del db+cowi*100			del 1			addz gs_brick_sill_br_thk-gs_brick_sill_br_thk/2*(stackLeft)			material gs_brick_sill_mort_mat			for i=1 to db-1+cowi*100				prism_ 4, gs_mor_th2,						0,				0,				15,						gs_sill_width,	0,				15,						gs_sill_width,	gs_sill_thk,	15,						0,				gs_sill_thk,	15				addz gs_brick_sill_br_thk+gs_mor_th2			next i			del db-1+cowi*100			del 1			if stackLeft then cutend			if stackRight then cutend			del 2		endif		gs_sill_holeDepthBehind = max(gs_sill_holeDepthBehind, sin(gs_sill_angle) * gs_sill_thk)		rotz 90		roty -90		addx -pxL		if sidelightCutLeft then			if sidelightCutLeft = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosLeft + thkPlasterAtSillSlLeft, SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk / cos(gs_sill_angle) - tan(gs_sill_angle) * (WIDO_SILL + gs_sill_slip_in), 10052			else				hotspot sidelightCutPosLeft, SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk / cos(gs_sill_angle) - tan(gs_sill_angle) * (WIDO_SILL + gs_sill_slip_in), 10051			endif		else			hotspot leftRevealPnts[ idxSillEndRevealLeft][1], SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk / cos(gs_sill_angle) - tan(gs_sill_angle) * (WIDO_SILL + gs_sill_slip_in), 10000		endif		if sidelightCutRight then			if sidelightCutRight = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosRight - thkPlasterAtSillSlRight, SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk / cos(gs_sill_angle) - tan(gs_sill_angle) * (WIDO_SILL + gs_sill_slip_in), 10053			else				hotspot sidelightCutPosRight, SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk / cos(gs_sill_angle) - tan(gs_sill_angle) * (WIDO_SILL + gs_sill_slip_in), 10050			endif		else			hotspot rightRevealPnts[idxSillEndRevealRight][1], SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk / cos(gs_sill_angle) - tan(gs_sill_angle) * (WIDO_SILL + gs_sill_slip_in), 10001		endif		del 3	endifreturn! ------------------------------------------------------------------------------! Stone Sill! ------------------------------------------------------------------------------10300:	Sill_FrameKeep_x	= gs_sill_topWidth	SillAngle_x			= gs_sill_width - gs_sill_topWidth	if gs_sill_drip then		put	-sillSlipIn,						0,														15,			Sill_FrameKeep_x - sillSlipIn,		0,														15,			Sill_FrameKeep_x - sillSlipIn,		gs_sill_topHeight,										15,			gs_sill_width - sillSlipIn,			gs_sill_topHeight + SillAngle_x * tan(gs_sill_angle),	15,			gs_sill_width - sillSlipIn,			gs_sill_thk,											15			drip_rad	= 0.01			drip_polys	= 6			drip_segm	= 180 / drip_polys		for kk = 0 to drip_polys			put gs_sill_width - gs_sill_width / 0.16 * 0.025 + cos(kk * drip_segm) * drip_rad - sillSlipIn,				gs_sill_thk - sin(kk * drip_segm) * drip_rad,				15 + (kk <> 0) * 64		next kk		put	-sillSlipIn,						gs_sill_thk,											15		prism_ nsp/3, pxR - pxL,			get(nsp)	endif	put		-sillSlipIn,						0,														15,			Sill_FrameKeep_x - sillSlipIn,		0,														15,			Sill_FrameKeep_x - sillSlipIn,		gs_sill_topHeight,										15,			gs_sill_width - sillSlipIn,			gs_sill_topHeight + SillAngle_x * tan(gs_sill_angle),	15,			gs_sill_width - sillSlipIn,			gs_sill_thk,											15,			-sillSlipIn,						gs_sill_thk,											15	if not(gs_sill_drip) then		prism_ nsp/3, pxR - pxL,			use(nsp)	endif	for i = 1 to nsp/3		sillPoly[(i-1) * 2 + 1] = get (1)		sillPoly[(i-1) * 2 + 2] = get (1)		eeeeee = get (1)	next i	sillLeft			= abs(pxL)	sillRight			= abs(pxR)	sillBottom			= -gs_sill_thk	sillBottomOutside	= -gs_sill_thk	sillSideHeight		= -sillBottom - gs_sill_topHeight - (SillSlipin - gs_sill_topWidth) * tan (gs_sill_angle)	sillSideAngle		=  gs_sill_angle	rotz 90	roty -90	addx -pxL		if sidelightCutLeft then			if sidelightCutLeft = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosLeft + thkPlasterAtSillSlLeft, SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk, 10052			else				hotspot sidelightCutPosLeft, SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk, 10051			endif		else			hotspot leftRevealPnts[idxSillEndRevealLeft][1], SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk, 10000		endif		if sidelightCutRight then			if sidelightCutRight = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosRight - thkPlasterAtSillSlRight, SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk, 10053			else				hotspot sidelightCutPosRight, SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk, 10050			endif		else			hotspot rightRevealPnts[idxSillEndRevealRight][1], SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk, 10001		endif	del 3return! ------------------------------------------------------------------------------! Ceramic Sill! ------------------------------------------------------------------------------10400:	xDistortion = gs_sill_topWidth / 0.03	yDistortion = gs_sill_thk / 0.047	PUT	 0, 						-gs_sill_topHeight,		 0, 						 0,		 gs_sill_topWidth,				 gs_sill_endthk,		 gs_sill_width - 0.004,		 gs_sill_endthk,		 gs_sill_width, 			 gs_sill_endthk - 0.004,		 gs_sill_width, 			 0.004,		 gs_sill_width - 0.004, 	 0,		 gs_sill_topWidth, 			 0,		 0.02900 * xDistortion, 	 0,		 0.015 * xDistortion, 		-gs_sill_topHeight + 0.00905 * yDistortion,		 0.015 * xDistortion,		-gs_sill_topHeight + 0.00041 * yDistortion	for i = 1 to nsp/2		sillPoly[(i-1) * 2 + 1] = get (1)		sillPoly[(i-1) * 2 + 2] = get (1)	next i	n = i - 1	bordh_proj = gs_sill_topHeight * cos(gs_sill_angle)	for i = 1 to n		angB = 90		t = sillPoly[(i-1) * 2 + 2]		if sillPoly[(i-1) * 2 + 1] > EPS then			angB = atn (sillPoly[(i-1) * 2 + 2] / sillPoly[(i-1) * 2 + 1])			t = sillPoly[(i-1) * 2 + 1] / cos(angB)		endif		put	t * cos (angB + gs_sill_angle) - SillSlipin,			t * sin (angB + gs_sill_angle) + bordh_proj,  mask_str	next i	prism_ nsp/3, pxR - pxL,		use(nsp)	for i = 1 to nsp/3		sillPoly[(i-1) * 2 + 1] = get (1)		sillPoly[(i-1) * 2 + 2] = get (1)		eeeeee = get (1)	next i	sillLeft			= abs(pxL)	sillRight			= abs(pxR)	sillBottom			= -( gs_sill_topHeight * cos(gs_sill_angle) + tan(gs_sill_angle) * (WIDO_SILL + gs_sill_slip_in) + gs_sill_endthk / cos(gs_sill_angle) )	sillBottomOutside	= sillBottom	sillSideHeight		= tan(gs_sill_angle) * WIDO_SILL + gs_sill_endthk / cos(gs_sill_angle)	sillSideAngle		=  gs_sill_angle	rotz 90	roty -90	addx -pxL		if sidelightCutLeft then			if sidelightCutLeft = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosLeft + thkPlasterAtSillSlLeft, SillSlipin + gs_sill_holeDepthBehind, sillBottom, 10052			else				hotspot sidelightCutPosLeft, SillSlipin + gs_sill_holeDepthBehind, sillBottom, 10051			endif		else			hotspot leftRevealPnts[idxSillEndRevealLeft][1], SillSlipin + gs_sill_holeDepthBehind, sillBottom, 10000		endif		if sidelightCutRight then			if sidelightCutRight = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosRight - thkPlasterAtSillSlRight, SillSlipin + gs_sill_holeDepthBehind, sillBottom, 10053			else				hotspot sidelightCutPosRight, SillSlipin + gs_sill_holeDepthBehind, sillBottom, 10050			endif		else			hotspot rightRevealPnts[idxSillEndRevealRight][1], SillSlipin + gs_sill_holeDepthBehind, sillBottom, 10001		endif	del 3return! ------------------------------------------------------------------------------! Eternite Sill! ------------------------------------------------------------------------------10500:	put		-SillSlipin,						 0,								mask_str,			 gs_sill_topWidth - SillSlipin,		 0,								mask_str,			 gs_sill_topWidth - SillSlipin,		 gs_sill_topHeight,					mask_str,			 gs_sill_width - SillSlipin,		 gs_sill_thk - gs_sill_endthk,	mask_str,			 gs_sill_width - SillSlipin,		 gs_sill_thk,					mask_str,			 0.015 - SillSlipin,		 		 gs_sill_thk,					mask_str,			-SillSlipin,						 gs_sill_thk - 0.015,			mask_str	prism_ nsp/3, pxR - pxL,		use(nsp)	for i = 1 to nsp/3		sillPoly[(i-1) * 2 + 1] = get (1)		sillPoly[(i-1) * 2 + 2] = get (1)		eeeeee = get (1)	next i	sillLeft			= abs(pxL)	sillRight			= abs(pxR)	sillBottom			= -gs_sill_thk	sillBottomOutside	= -gs_sill_thk	sillSideHeight		=  gs_sill_thk - gs_sill_topHeight - max(0, (SillSlipin - gs_sill_topWidth)) * tan(gs_sill_angle) - min(0, SillSlipin - gs_sill_topWidth) * tan(gs_sill_angle)	sillSideAngle		=  gs_sill_angle	rotz 90	roty -90	addx -pxL		if sidelightCutLeft then			if sidelightCutLeft = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosLeft + thkPlasterAtSillSlLeft, SillSlipin + gs_sill_holeDepthBehind, sillBottom, 10052			else				hotspot sidelightCutPosLeft, SillSlipin + gs_sill_holeDepthBehind, sillBottom, 10051			endif		else			hotspot leftRevealPnts[idxSillEndRevealLeft][1], SillSlipin + gs_sill_holeDepthBehind, sillBottom, 10000		endif		if sidelightCutRight then			if sidelightCutRight = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosRight - thkPlasterAtSillSlRight, SillSlipin + gs_sill_holeDepthBehind, sillBottom, 10053			else				hotspot sidelightCutPosRight, SillSlipin + gs_sill_holeDepthBehind, sillBottom, 10050			endif		else			hotspot rightRevealPnts[idxSillEndRevealRight][1], SillSlipin + gs_sill_holeDepthBehind, sillBottom, 10001		endif	del 3return! ------------------------------------------------------------------------------! Concrete Tub! ------------------------------------------------------------------------------10600:	xDistortion	= gs_sill_width / 0.1	yDistortion = gs_sill_thk / 0.185	put		0.1 * xDistortion - SillSlipin,		 gs_sill_thk,						mask_str,			0.1 * xDistortion - SillSlipin,		-0.17 * yDistortion + gs_sill_thk,	mask_str,			0.08 * xDistortion - SillSlipin,	-0.17 * yDistortion + gs_sill_thk,	mask_str,			0.075 * xDistortion - SillSlipin,	-0.15 * yDistortion + gs_sill_thk,	mask_str,			0.025 * xDistortion - SillSlipin,	-0.15 * yDistortion + gs_sill_thk,	mask_str,			0.02 * xDistortion - SillSlipin,	-0.185 * yDistortion + gs_sill_thk,	mask_str,			-SillSlipin,						-0.185 * yDistortion + gs_sill_thk,	mask_str,			-SillSlipin,						 gs_sill_thk,						mask_str	prism_ nsp/3, pxR - pxL,		use(nsp)	for i = 1 to nsp/3		sillPoly[(i-1) * 2 + 1] = get (1)		sillPoly[(i-1) * 2 + 2] = get (1)		eeeeee = get (1)	next i	sillLeft			= abs(pxL)	sillRight			= abs(pxR)	sillBottom			= -gs_sill_thk	sillBottomOutside	= -gs_sill_thk	sillSideHeight		= 0.15 * yDistortion	sillSideAngle		= 0	rotz 90	roty -90	addx -pxL		if sidelightCutLeft then			if sidelightCutLeft = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosLeft + thkPlasterAtSillSlLeft, SillSlipin + gs_sill_holeDepthBehind, sillBottom, 10052			else				hotspot sidelightCutPosLeft, SillSlipin + gs_sill_holeDepthBehind, sillBottom, 10051			endif		else			hotspot leftRevealPnts[idxSillEndRevealLeft][1], SillSlipin + gs_sill_holeDepthBehind, sillBottom, 10000		endif		if sidelightCutRight then			if sidelightCutRight = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosRight - thkPlasterAtSillSlRight, SillSlipin + gs_sill_holeDepthBehind, sillBottom, 10053			else				hotspot sidelightCutPosRight, SillSlipin + gs_sill_holeDepthBehind, sillBottom, 10050			endif		else			hotspot rightRevealPnts[idxSillEndRevealRight][1], SillSlipin + gs_sill_holeDepthBehind, sillBottom, 10001		endif	del 3return! ------------------------------------------------------------------------------! Aluminum Sill! ------------------------------------------------------------------------------10700:	put 	-gs_sill_slip_in,													0, 																									mask_str+64,			-gs_sill_slip_in,													gs_sill_topHeight + thk * tan((90-gs_sill_angle)/2), 													mask_str+64,			gs_sill_width - thk - gs_sill_slip_in,								gs_sill_topHeight + thk * tan((90-gs_sill_angle)/2) + (gs_sill_thk - gs_sill_topHeight) - gs_sill_dripnos, 	mask_str+64,			gs_sill_width - thk - gs_sill_slip_in,								gs_sill_thk - thk*tan(15) - thk/cos(15), 															mask_str+64,			gs_sill_width - gs_sill_dripwidth + thk*sin(15) - gs_sill_slip_in,	gs_sill_thk - gs_sill_dripwidth * tan(15) - thk*cos(15),											mask_str+64,			gs_sill_width - gs_sill_dripwidth - gs_sill_slip_in,				gs_sill_thk - gs_sill_dripwidth * tan(15),															mask_str+64,			gs_sill_width - gs_sill_slip_in,									gs_sill_thk,																						mask_str+64,			gs_sill_width - gs_sill_slip_in,									gs_sill_thk - gs_sill_dripnos,																		mask_str+64,			thk - gs_sill_slip_in,												gs_sill_topHeight,																						mask_str+64,			thk - gs_sill_slip_in,												0,																									mask_str+64	prism_ nsp/3, pxR - pxL,		use(nsp)	for i = 1 to nsp/3		sillPoly[(i-1) * 2 + 1] = get (1)		sillPoly[(i-1) * 2 + 2] = get (1)		eeeeee = get (1)	next i	sillLeft			= abs(pxL)	sillRight			= abs(pxR)	sillBottom			= -gs_sill_thk + gs_sill_nosing * tan(gs_sill_angle) - thk / cos(gs_sill_angle)	sillBottomOutside	= -gs_sill_thk	sillSideHeight		=  -sillBottom - gs_sill_topHeight + thk * tan(gs_sill_angle)	sillSideAngle		=  gs_sill_angle	cy = max(0, gs_sill_topHeight) + max(0, (WIDO_SILL - thk + gs_sill_slip_in) * tan(gs_sill_angle)) + thk / cos(gs_sill_angle) - gs_sill_dripnos * (WIDO_SILL + gs_sill_slip_in) / (gs_sill_width - thk)	rotz 90	roty -90	addx -pxL		if sidelightCutLeft then			if sidelightCutLeft = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosLeft + thkPlasterAtSillSlLeft, SillSlipin + gs_sill_holeDepthBehind, -cy, 10052			else				hotspot sidelightCutPosLeft, SillSlipin + gs_sill_holeDepthBehind, -cy, 10051			endif		else			hotspot leftRevealPnts[idxSillEndRevealLeft][1], SillSlipin + gs_sill_holeDepthBehind, -cy, 10000		endif		if sidelightCutRight then			if sidelightCutRight = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosRight - thkPlasterAtSillSlRight, SillSlipin + gs_sill_holeDepthBehind, -cy, 10053			else				hotspot sidelightCutPosRight, SillSlipin + gs_sill_holeDepthBehind, -cy, 10050			endif		else			hotspot rightRevealPnts[idxSillEndRevealRight][1], SillSlipin + gs_sill_holeDepthBehind, -cy, 10001		endif	del 3return! ------------------------------------------------------------------------------! Solid Sill 1.1 / Massiv-Fensterbank 1.1 (CHE)! ------------------------------------------------------------------------------10800:	if lod3D_Sill = 3 then		put	0, 						-sillElevation - gs_sill_elev, 									mask_str,			0, 						-sillElevation - gs_sill_elev - gs_sill_thk,					mask_str,			gs_sill_topWidth, 			-sillElevation - gs_sill_elev - gs_sill_thk, 					mask_str,			gs_sill_topWidth, 			-sillElevation - gs_sill_elev - gs_sill_thk + gs_sill_topHeight, 	mask_str,			gs_sill_width, 			-sillElevation - gs_sill_elev - gs_sill_endthk, 				mask_str,			gs_sill_width, 			-sillElevation - gs_sill_elev, 									mask_str,			gs_sill_width - 0.01, 	-sillElevation - gs_sill_elev,									mask_str,			gs_sill_width - 0.01, 	-sillElevation - gs_sill_elev - 0.007, 							mask_str,			gs_sill_width - 0.017, 	-sillElevation - gs_sill_elev - 0.007, 							mask_str,			gs_sill_width - 0.017, 	-sillElevation - gs_sill_elev, 									mask_str,			0, 						-sillElevation - gs_sill_elev, 									-1	else		put	0, 						-sillElevation - gs_sill_elev, 					mask_str,			0, 						-sillElevation - gs_sill_elev - gs_sill_thk, 	mask_str,			gs_sill_width, 			-sillElevation - gs_sill_elev - gs_sill_endthk, mask_str,			gs_sill_width, 			-sillElevation - gs_sill_elev, 					mask_str,			0, 						-sillElevation - gs_sill_elev, 					-1	endif	prism_ nsp/3, pxR - pxL,		use(nsp)	base	vert 0,	0, 0	vert 0,	0, 1	vert 0,	1, 0	vert 1,	0, 0	coor 2, -1, -2, -3, -4	body 1	for i = 1 to nsp/3		sillPoly[(i-1) * 2 + 1] = get (1)		sillPoly[(i-1) * 2 + 2] = get (1)		eeeeee = get (1)	next i	sillLeft			= abs(pxL)	sillRight			= abs(pxR)	sillBottom			= sillElevation	sillBottomOutside	= sillElevation + gs_sill_elev	if lod3D_Sill = 3 then		gs_sill_angle	= atn((gs_sill_thk - gs_sill_endthk - gs_sill_topHeight) / (gs_sill_width - gs_sill_topWidth))		sillSideHeight	= gs_sill_elev + gs_sill_thk - gs_sill_topHeight + gs_sill_topWidth * tan(gs_sill_angle)	else		gs_sill_angle	= atn((gs_sill_thk - gs_sill_endthk) / gs_sill_width)		sillSideHeight	= gs_sill_elev + gs_sill_thk	endif	sillSideAngle		= gs_sill_angle	rotz 90	roty -90	addx -pxL		if sidelightCutLeft then			if sidelightCutLeft = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosLeft + thkPlasterAtSillSlLeft, leftRevealPnts[ idxSillEndRevealLeft][2], sillElevation + gs_sill_thk, 10052			else				hotspot sidelightCutPosLeft, leftRevealPnts[ idxSillEndRevealLeft][2], sillElevation + gs_sill_thk, 10051			endif		else			hotspot leftRevealPnts[idxSillEndRevealLeft][1], leftRevealPnts[ idxSillEndRevealLeft][2], sillElevation + gs_sill_thk, 10000		endif		if sidelightCutRight then			if sidelightCutRight = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosRight - thkPlasterAtSillSlRight, rightRevealPnts[idxSillEndRevealRight][2], sillElevation + gs_sill_thk, 10053			else				hotspot sidelightCutPosRight, rightRevealPnts[idxSillEndRevealRight][2], sillElevation + gs_sill_thk, 10050			endif		else			hotspot rightRevealPnts[idxSillEndRevealRight][1], rightRevealPnts[idxSillEndRevealRight][2], sillElevation + gs_sill_thk, 10001		endif	del 3return! ------------------------------------------------------------------------------! Solid Sill 1.2 / Massiv-Fensterbank 1.2 (CHE)! ------------------------------------------------------------------------------10900:	slSill = atn((gs_sill_thk - gs_sill_topHeight - gs_sill_endthk) / (gs_sill_width-gs_sill_topWidth))	if lod3D_Sill = 3 then		put	0, 						-sillElevation - gs_sill_elev, 									mask_str,			0, 						-sillElevation - gs_sill_elev - gs_sill_thk, 					mask_str,			gs_sill_topWidth, 			-sillElevation - gs_sill_elev - gs_sill_thk, 					mask_str,			gs_sill_topWidth, 			-sillElevation - gs_sill_elev - gs_sill_thk + gs_sill_topHeight, 	mask_str,			gs_sill_width, 			-sillElevation - gs_sill_elev - gs_sill_endthk, 				mask_str,			gs_sill_width, 			-sillElevation - gs_sill_elev, 									mask_str,			gs_sill_width - 0.01, 	-sillElevation - gs_sill_elev, 									mask_str,			gs_sill_width - 0.01, 	-sillElevation - gs_sill_elev - 0.007, 							mask_str,			gs_sill_width - 0.017, 	-sillElevation - gs_sill_elev - 0.007, 							mask_str,			gs_sill_width - 0.017, 	-sillElevation - gs_sill_elev, 									mask_str,			0, 						-sillElevation - gs_sill_elev, 									-1	else		put	0, 						-sillElevation - gs_sill_elev, 					mask_str,			0, 						-sillElevation - gs_sill_elev - gs_sill_thk,	mask_str,			gs_sill_width, 			-sillElevation - gs_sill_elev - gs_sill_endthk, mask_str,			gs_sill_width, 			-sillElevation - gs_sill_elev,					mask_str,			0, 						-sillElevation - gs_sill_elev, 					-1	endif	sillIns = 0	if gs_sill_thk - 0.01 > 0.015 / cos(slSill) then		sillIns = 1		put	0.015, 					-sillElevation - gs_sill_elev - 0.015, 														mask_str,			0.015, 					-sillElevation - gs_sill_elev - gs_sill_thk + gs_sill_topHeight + 0.015 / cos(slSill), 			mask_str,			gs_sill_width - 0.06, 	-sillElevation - gs_sill_elev - gs_sill_endthk - 0.06 * tan(slSill) + 0.015 / cos(slSill), 	mask_str,			gs_sill_width - 0.06, 	-sillElevation - gs_sill_elev - 0.015, 														mask_str,			0.015, 					-sillElevation - gs_sill_elev - 0.015, 														-1	endif	!sect_fill gs_sill_fill, gs_sill_pen_bg, gs_sill_pen_fg, gs_sill_pen_sectcont	prism_ nsp/3, pxR - pxL,		use(nsp)	base	vert 0,	0, 0	vert 0,	0, 1	vert 0,	1, 0	vert 1,	0, 0	coor 2, -1, -2, -3, -4	body 1	for i=1 to nsp - sillIns * 15		delbuff = get(1)	next i	if sillIns then		!sect_fill gs_sill_fill_ins_fg, gs_sill_pen_ins_bg, gs_sill_pen_ins_fg, gs_sill_pen_ins_sectcont		prism_ nsp/3, pxR - pxL,			use(nsp)	endif	for i = 1 to nsp/3		sillPoly[(i-1) * 2 + 1] = get (1)		sillPoly[(i-1) * 2 + 2] = get (1)		eeeeee = get (1)	next i	sillLeft			= abs(pxL)	sillRight			= abs(pxR)	sillBottom			= sillElevation	sillBottomOutside	= sillElevation + gs_sill_elev	if lod3D_Sill = 3 then		gs_sill_angle	= atn((gs_sill_thk - gs_sill_endthk - gs_sill_topHeight) / (gs_sill_width - gs_sill_topWidth))		sillSideHeight	= gs_sill_elev + gs_sill_thk - gs_sill_topHeight + gs_sill_topWidth * tan (gs_sill_angle)	else		gs_sill_angle	= atn((gs_sill_thk - gs_sill_endthk) / gs_sill_width)		sillSideHeight	= gs_sill_elev + gs_sill_thk	endif	sillSideAngle		= gs_sill_angle	!sect_fill gs_sill_fill, gs_sill_pen_bg, gs_sill_pen_fg, gs_sill_pen_sectcont	rotz 90	roty -90	addx -pxL		if sidelightCutLeft then			if sidelightCutLeft = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosLeft + thkPlasterAtSillSlLeft, leftRevealPnts[ idxSillEndRevealLeft][2], sillElevation + gs_sill_thk, 10052			else				hotspot sidelightCutPosLeft, leftRevealPnts[ idxSillEndRevealLeft][2], sillElevation + gs_sill_thk, 10051			endif		else			hotspot leftRevealPnts[idxSillEndRevealLeft][1], leftRevealPnts[ idxSillEndRevealLeft][2], sillElevation + gs_sill_thk, 10000		endif		if sidelightCutRight then			if sidelightCutRight = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosRight - thkPlasterAtSillSlRight, rightRevealPnts[idxSillEndRevealRight][2], sillElevation + gs_sill_thk, 10053			else				hotspot sidelightCutPosRight, rightRevealPnts[idxSillEndRevealRight][2], sillElevation + gs_sill_thk, 10050			endif		else			hotspot rightRevealPnts[idxSillEndRevealRight][1], rightRevealPnts[idxSillEndRevealRight][2], sillElevation + gs_sill_thk, 10001		endif	del 3return! ------------------------------------------------------------------------------! Solid Sill 2.2 / Massiv-Fensterbank 2.2 (CHE)! ------------------------------------------------------------------------------11000:	if lod3D_Sill = 3 then		put	0, 											-sillElevation - gs_sill_elev, 								mask_str,			0, 											-sillElevation - gs_sill_elev - gs_sill_thk, 				mask_str,			gs_sill_topWidth, 								-sillElevation - gs_sill_elev - gs_sill_thk, 				mask_str,			gs_sill_topWidth, 								-sillElevation - gs_sill_elev - gs_sill_thk + gs_sill_topHeight,mask_str,			gs_sill_width, 								-sillElevation - gs_sill_elev - gs_sill_endthk, 			mask_str,			gs_sill_width,  							-sillElevation - gs_sill_elev + gs_sill_dripnos, 			mask_str,			gs_sill_width - gs_sill_dripwidth/2 + 2/300,-sillElevation - gs_sill_elev + gs_sill_dripnos, 			mask_str,			gs_sill_width - gs_sill_dripwidth/2 + 2/300,-sillElevation - gs_sill_elev + gs_sill_dripnos - 2/300, 	mask_str,			gs_sill_width - gs_sill_dripwidth/2, 		-sillElevation - gs_sill_elev + gs_sill_dripnos - 2/300, 	mask_str,			gs_sill_width - gs_sill_dripwidth/2, 		-sillElevation - gs_sill_elev + gs_sill_dripnos, 			mask_str,			gs_sill_width - gs_sill_dripwidth, 			-sillElevation - gs_sill_elev + gs_sill_dripnos, 			mask_str,			gs_sill_width - gs_sill_dripwidth, 			-sillElevation - gs_sill_elev, 								mask_str,			0, 											-sillElevation - gs_sill_elev, 								mask_str	else		put	0, 											-sillElevation - gs_sill_elev, 								mask_str,			0, 											-sillElevation - gs_sill_elev - gs_sill_thk, 				mask_str,			gs_sill_width, 								-sillElevation - gs_sill_elev - gs_sill_endthk, 			mask_str,			gs_sill_width,  							-sillElevation - gs_sill_elev + gs_sill_dripnos, 			mask_str,			gs_sill_width - gs_sill_dripwidth, 			-sillElevation - gs_sill_elev + gs_sill_dripnos, 			mask_str,			gs_sill_width - gs_sill_dripwidth, 			-sillElevation - gs_sill_elev, 								mask_str	endif	prism_ nsp/3, pxR - pxL,		use(nsp)	base	vert 0,	0, 0	vert 0,	0, 1	vert 0,	1, 0	vert 1,	0, 0	coor 2, -1, -2, -3, -4	body 1	for i = 1 to nsp/3		sillPoly[(i-1) * 2 + 1] = get (1)		sillPoly[(i-1) * 2 + 2] = get (1)		eeeeee = get (1)	next i	sillLeft			= abs(pxL)	sillRight			= abs(pxR)	sillBottom			= sillElevation	sillBottomOutside	= sillElevation + gs_sill_elev - gs_sill_dripnos	if lod3D_Sill = 3 then		gs_sill_angle	= atn((gs_sill_thk - gs_sill_endthk - gs_sill_topHeight) / (gs_sill_width - gs_sill_topWidth))		sillSideHeight	= gs_sill_elev + gs_sill_thk - gs_sill_topHeight + gs_sill_topWidth * tan(gs_sill_angle)	else		gs_sill_angle	= atn((gs_sill_thk - gs_sill_endthk) / gs_sill_width)		sillSideHeight	= gs_sill_elev + gs_sill_thk	endif	sillSideAngle		= gs_sill_angle	rotz 90	roty -90	addx -pxL		if sidelightCutLeft then			if sidelightCutLeft = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosLeft + thkPlasterAtSillSlLeft, 0, sillElevation + gs_sill_elev + gs_sill_thk, 10052			else				hotspot sidelightCutPosLeft, 0, sillElevation + gs_sill_elev + gs_sill_thk, 10051			endif		else			hotspot leftRevealPnts[idxSillEndRevealLeft][1], 0, sillElevation + gs_sill_elev + gs_sill_thk, 10000		endif		if sidelightCutRight then			if sidelightCutRight = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosRight - thkPlasterAtSillSlRight, 0, sillElevation + gs_sill_elev + gs_sill_thk, 10053			else				hotspot sidelightCutPosRight, 0, sillElevation + gs_sill_elev + gs_sill_thk, 10050			endif		else			hotspot rightRevealPnts[idxSillEndRevealRight][1], 0, sillElevation + gs_sill_elev + gs_sill_thk, 10001		endif	del 3return! ------------------------------------------------------------------------------! Metal Sheet / Metallfensterbank 1.1 (CHE) - Metal sheet 2 (CHE)! ------------------------------------------------------------------------------11100:	if lod3D_Sill = 3 then		inclinedEdgeSize = min(0.02, gs_sill_nosing/2, gs_sill_dripnos/2)		put	0.001, 			-sillElevation - gs_sill_thk, 					0,			0.001, 			-sillElevation - xh, 							0,			gs_sill_width, 	-sillElevation - xh + xh2, 						0,			gs_sill_width, 	-sillElevation - xh + xh2 + gs_sill_dripnos, 	0,			gs_sill_width - inclinedEdgeSize, -sillElevation - xh + xh2 + gs_sill_dripnos - inclinedEdgeSize, 	0	else		put	0,	 			-sillElevation - xh, 							0,			gs_sill_width, 	-sillElevation - xh + xh2, 						0,			gs_sill_width, 	-sillElevation - xh + xh2 + gs_sill_dripnos, 	0	endif	extrude nsp/3, 0, 0, pxR - pxL, 16+32,			get(nsp)	base	vert 0,	0, 0	vert 0,	0, 1	vert 0,	1, 0	vert 1,	0, 0	coor 2, -1, -2, -3, -4	body 1	if lod3D_Sill = 3 then		put	0, 				-sillElevation - xh + xh2 + gs_sill_dripnos, 	0,			0, 				-sillElevation - gs_sill_thk, 					0,			0.001, 			-sillElevation - gs_sill_thk, 					0,			0.001, 			-sillElevation - xh, 							0,			gs_sill_width, 	-sillElevation - xh + xh2, 						0,			gs_sill_width, 	-sillElevation - xh + xh2 + gs_sill_dripnos, 	0	else		put	0, 				-sillElevation - xh + xh2 + gs_sill_dripnos, 	0,			0,	 			-sillElevation - xh, 							0,			gs_sill_width, 	-sillElevation - xh + xh2, 						0,			gs_sill_width, 	-sillElevation - xh + xh2 + gs_sill_dripnos, 	0	endif	for i = 1 to nsp/3		sillPoly[(i-1) * 2 + 1] = get (1)		sillPoly[(i-1) * 2 + 2] = get (1)		eeeeee = get (1)	next i	gs_sill_angle = atn((xh2) / (gs_sill_width - 0.001))	if iSillType = SILL_METAL_2 then		if abs (WIDO_SILL) > EPS then			!sect_fill gs_sill_fill_ins_fg, gs_sill_pen_ins_bg, gs_sill_pen_ins_fg, gs_sill_pen_ins_sectcont			pen WALL_VIEW_PEN			if WIDO_REVEAL_SIDE then				material WALL_MAT_A			else				material WALL_MAT_B			endif			prism_ 4, pxR - pxL,				0,			-sillElevation,																								15,				WIDO_SILL,	-sillElevation,																								15,				WIDO_SILL,	-sillElevation - gs_sill_thk + gs_sill_topHeight + 0.001 / cos(gs_sill_angle) + WIDO_SILL * tan(gs_sill_angle),	15,				0,			-sillElevation - gs_sill_thk + gs_sill_topHeight + 0.001 / cos(gs_sill_angle),									15			base			vert 0, 0, 0			vert 1, 0, 0			vert 0, 0, -sgn((SYMB_MIRRORED exor (SYMB_ROTANGLE > EPS)) - 0.5)			vert 0, -1, 0			coor 2, -1, -2, -3, -4			body -1		endif	endif	sillLeft			= abs(pxL)	sillRight			= abs(pxR)	sillBottom			= sillElevation	sillBottomOutside	= sillElevation		!!!+ gs_sill_endthk	sillSideHeight		= gs_sill_thk - gs_sill_topHeight + 0.001 * tan(gs_sill_angle)	sillSideAngle		= gs_sill_angle	rotz 90	roty -90	addx -pxL		if sidelightCutLeft then			if sidelightCutLeft = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosLeft + thkPlasterAtSillSlLeft, leftRevealPnts[ idxSillEndRevealLeft][2], sillElevation + gs_sill_thk, 10052			else				hotspot sidelightCutPosLeft, leftRevealPnts[ idxSillEndRevealLeft][2], sillElevation + gs_sill_thk, 10051			endif		else			hotspot leftRevealPnts[idxSillEndRevealLeft][1], leftRevealPnts[ idxSillEndRevealLeft][2], sillElevation + gs_sill_thk, 10000		endif		if sidelightCutRight then			if sidelightCutRight = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosRight - thkPlasterAtSillSlRight, rightRevealPnts[idxSillEndRevealRight][2], sillElevation + gs_sill_thk, 10053			else				hotspot sidelightCutPosRight, rightRevealPnts[idxSillEndRevealRight][2], sillElevation + gs_sill_thk, 10050			endif		else			hotspot rightRevealPnts[idxSillEndRevealRight][1], rightRevealPnts[idxSillEndRevealRight][2], sillElevation + gs_sill_thk, 10001		endif	del 3return! ------------------------------------------------------------------------------! Sill Elevation for Solid Sills! ------------------------------------------------------------------------------11111:	if abs(gs_sill_elev) > EPS then		if not(curvedWall) then!!!!!!!!	hins = -gs_sill_elev!!!!!!!!	plane_ 10,!!!!!!!!			 pxL + gs_sill_ovhg_left + 0.0001,		-0.0001,	-K_-eps, 0,!!!!!!!!			 pxL + gs_sill_ovhg_left + 0.0001, 		hins, 		-K_-eps, 1,!!!!!!!!			 pxL + gs_sill_ovhg_left, 				hins, 		-K_-eps, 0,!!!!!!!!			 pxL + gs_sill_ovhg_left - 0.0001, 		hins, 		-K_-eps, 0,!!!!!!!!			 pxL + gs_sill_ovhg_left - 0.0001,  	0.0001, 	-K_-eps, 0,!!!!!!!!			 pxR - gs_sill_ovhg_right + 0.0001, 	0.0001, 	-K_-eps, 0,!!!!!!!!			 pxR - gs_sill_ovhg_right + 0.0001, 	hins, 		-K_-eps, 0,!!!!!!!!			 pxR - gs_sill_ovhg_right, 				hins, 		-K_-eps, 1,!!!!!!!!			 pxR - gs_sill_ovhg_right - 0.0001, 	hins, 		-K_-eps, 0,!!!!!!!!			 pxR - gs_sill_ovhg_right - 0.0001, 	-0.0001, 	-K_-eps, 0		endif		prism_ 4, pxR - pxL,			 WIDO_SILL, 		 0, 					15,			 WIDO_SILL, 		-gs_sill_elev + 0.0001, 15,			 0.0001, 			-gs_sill_elev + 0.0001, 15,			 0.0001, 			 0, 					15	endifreturn! ------------------------------------------------------------------------------! Solid Parallel (CHE) - Solid Parallel 2 (CHE)! ------------------------------------------------------------------------------11200:	if iSillType = SILL_PARALLEL then		sillAngle		= gs_sill_angle		sillThickness	= gs_sill_thk		addMountingX	= 0		addMountingY	= 0		addElevation	= -sillElevation		sillHeightDiff	= gs_sill_element_thk / cos(sillAngle)	else		sillAngle		= gs_reveal_outerBottom_angle		sillThickness	= gs_reveal_bottom		addMountingX	= gs_mountingFrame_depth * gs_mountingFrame		addMountingY	= addMountingX * tan(sillAngle)		addElevation	= 0		sillHeightDiff	= 0	endif	put addMountingX, addElevation + sillHeightDiff - sillThickness,										mask_str,		addMountingX, addElevation + sillHeightDiff - sillThickness - gs_sill_element_thk / cos(sillAngle),	mask_str	outTopPos_X = WIDO_SILL + gs_sill_nosing	if gs_sill_edge = stSillEdge[1] then	! Perpendicular		gs_sill_width = (WIDO_SILL - addMountingX + gs_sill_nosing) / cos(sillAngle)		outTopPos_Y = addElevation + sillHeightDiff - sillThickness + gs_sill_width * sin (sillAngle) - gs_sill_element_thk / cos(sillAngle)	else		gs_sill_width = (WIDO_SILL - addMountingX + gs_sill_nosing + gs_sill_element_thk * tan(sillAngle)) / cos(sillAngle)		outTopPos_Y = addElevation + sillHeightDiff - sillThickness + (gs_sill_width  - gs_sill_element_thk * tan(sillAngle)) * sin(sillAngle) - gs_sill_element_thk / cos(sillAngle)	endif	if gs_sill_edge = stSillEdge[1] then	! Perpendicular		outBottomPos_X = WIDO_SILL + gs_sill_nosing - gs_sill_element_thk * sin (sillAngle)	else		outBottomPos_X = WIDO_SILL + gs_sill_nosing	endif	outBottomPos_Y = addElevation + sillHeightDiff - sillThickness + gs_sill_width * sin (sillAngle) + gs_sill_element_thk * cos(sillAngle) - gs_sill_element_thk / cos(sillAngle)	if gs_sill_edge = stSillEdge[1] then	! Perpendicular		freeLengthForDrip = gs_sill_nosing - gs_sill_element_thk * sin (sillAngle)	else		freeLengthForDrip = gs_sill_nosing	endif	put outTopPos_X,	outTopPos_Y,	mask_str,		outBottomPos_X, outBottomPos_Y, mask_str	if lod3D_Sill = 3 and freeLengthForDrip > EPS then		dripWidth = min (freeLengthForDrip / 3, gs_sill_element_thk / 2)		drip_X = dripWidth		drip_Y = dripWidth * tan (sillAngle)		put outBottomPos_X - dripWidth,							outBottomPos_Y - dripWidth * tan(sillAngle),			mask_str,			outBottomPos_X + dripWidth * (tan (sillAngle) - 1),	outBottomPos_Y - dripWidth * (tan(sillAngle) + 1),		mask_str,			outBottomPos_X + dripWidth * (tan (sillAngle) - 2),	outBottomPos_Y - dripWidth * (tan(sillAngle) * 2 + 1),	mask_str,			outBottomPos_X - dripWidth * 2,						outBottomPos_Y - dripWidth * 2 * tan(sillAngle),		mask_str	endif	prism_ nsp/3, pxR - pxL,		use(nsp)	base	vert 0,	0, 0	vert 0,	0, 1	vert 0,	1, 0	vert 1,	0, 0	coor 2, -1, -2, -3, -4	body 1	for i = 1 to nsp/3		sillPoly[(i-1) * 2 + 1] = get (1)		sillPoly[(i-1) * 2 + 2] = get (1)		eeeeee = get (1)	next i	reorder = (AC_Wall_Direction_Type <> 1 & AC_Wall_Direction_Type <> 3)	if wallIsLeft then		if reorder then			idx = nSkinTurnOut + 1		else			idx = nSkinTurnIn + 1		endif	else		if reorder then			idx = WALL_SKINS_NUMBER - nSkinTurnIn		else			idx = WALL_SKINS_NUMBER - nSkinTurnOut		endif	endif	if bCompositeWall then		bShowSkin = not( (GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY & WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] < EPS) | \						 (GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) < EPS) )	else		bShowSkin = 1	endif	if abs(WIDO_SILL) > EPS & (iSillType = SILL_PARALLEL | (iSillType = SILL_PARALLEL_2 & gs_sill_ins_below & bShowSkin & sillThickness > EPS)) then		if gs_sill_ins_use_wall_skin & bCompositeWall then			if wallIsLeft then				baseSkinContLinePen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])				baseSkinContLineType	= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])			else				baseSkinContLinePen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN])				baseSkinContLineType	= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE])			endif			baseSkinFillType		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL])			baseSkinFillFgPen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_PEN])			baseSkinFillBgPen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_BACK_PEN])			baseSkinFillOrientation	= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_ORIENTATION])			sect_attrs baseSkinFillType, baseSkinFillBgPen, baseSkinFillFgPen, baseSkinContLinePen, baseSkinContLineType		else			!sect_fill gs_sill_fill_ins_fg, gs_sill_pen_ins_bg, gs_sill_pen_ins_fg, gs_sill_pen_ins_sectcont		endif		pen WALL_VIEW_PEN		if WIDO_REVEAL_SIDE then			material WALL_MAT_A		else			material WALL_MAT_B		endif		if iSillType = SILL_PARALLEL then			put WIDO_SILL,	addElevation,	15		else			put WIDO_SILL,	addElevation + WIDO_SILL * tan(sillAngle),	15		endif		put	WIDO_SILL,	addElevation + sillHeightDiff - sillThickness + WIDO_SILL * tan(sillAngle),	15,			0,			addElevation + sillHeightDiff - sillThickness,								15,			0,			addElevation,												15		prism_ 4, pxR - pxL, get(nsp)		base		vert 0, 0, 0		vert 1, 0, 0		vert 0, 0, -sgn((SYMB_MIRRORED exor (SYMB_ROTANGLE > EPS)) - 0.5)		vert 0, -1, 0		coor 2, -1, -2, -3, -4		body -1	endif	sillLeft			= abs(pxL)	sillRight			= abs(pxR)	sillBottom			= sillElevation	if iSillType = SILL_PARALLEL then		sillBottomOutside	= sillElevation + sillThickness - gs_sill_element_thk / cos(sillAngle) -  WIDO_SILL * tan(sillAngle)		sillSideHeight		= sillThickness	else		sillBottomOutside	= sillElevation	- (WIDO_SILL - addMountingX) * tan(sillAngle)		sillSideHeight		= addMountingY + gs_sill_element_thk / cos(sillAngle)	endif	sillSideAngle		= sillAngle	rotz 90	roty -90	addx -pxL	if iSillType = SILL_PARALLEL then		hptsHeight = sillElevation + sillThickness	else		hptsHeight = sillThickness + sillHeightDiff	endif		if sidelightCutLeft then			if sidelightCutLeft = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosLeft + thkPlasterAtSillSlLeft, leftRevealPnts[ idxSillEndRevealLeft][2], hptsHeight, 10052			else				hotspot sidelightCutPosLeft, leftRevealPnts[ idxSillEndRevealLeft][2], hptsHeight, 10051			endif		else			hotspot leftRevealPnts[idxSillEndRevealLeft][1], leftRevealPnts[ idxSillEndRevealLeft][2], hptsHeight, 10000		endif		if sidelightCutRight then			if sidelightCutRight = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosRight - thkPlasterAtSillSlRight, rightRevealPnts[idxSillEndRevealRight][2], hptsHeight, 10053			else				hotspot sidelightCutPosRight, rightRevealPnts[idxSillEndRevealRight][2], hptsHeight, 10050			endif		else			hotspot rightRevealPnts[idxSillEndRevealRight][1], rightRevealPnts[idxSillEndRevealRight][2], hptsHeight, 10001		endif	del 3return! ------------------------------------------------------------------------------! Block Sill! ------------------------------------------------------------------------------11300:	put 	-WIDO_FRAME_THICKNESS,	0, 				mask_str,			-WIDO_FRAME_THICKNESS,	gs_sill_thk, 	mask_str,			 gs_sill_nosing,		gs_sill_thk, 	mask_str,			 gs_sill_nosing,		0, 				mask_str	prism_ nsp/3, pxR - pxL,		use(nsp)	for i = 1 to nsp/3		sillPoly[(i-1) * 2 + 1] = get (1)		sillPoly[(i-1) * 2 + 2] = get (1)		eeeeee = get (1)	next i	sillLeft			= abs(pxL)	sillRight			= abs(pxR)	sillBottom			= -gs_sill_thk	sillBottomOutside	= -gs_sill_thk	sillSideHeight		=  gs_sill_thk	sillSideAngle		=  0	rotz 90	roty -90	addx -pxL		if sidelightCutLeft then			if sidelightCutLeft = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosLeft + thkPlasterAtSillSlLeft, SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk, 10052			else				hotspot sidelightCutPosLeft, SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk, 10051			endif		else			hotspot leftRevealPnts[idxSillEndRevealLeft][1], SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk, 10000		endif		if sidelightCutRight then			if sidelightCutRight = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosRight - thkPlasterAtSillSlRight, SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk, 10053			else				hotspot sidelightCutPosRight, SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk, 10050			endif		else			hotspot rightRevealPnts[idxSillEndRevealRight][1], SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk, 10001		endif	del 3return! ------------------------------------------------------------------------------! Dutch Profiled Sill! ------------------------------------------------------------------------------11400:	_leftCutBackWFrame  = max((leftFrameOffset + (leftRevealPnts[idxFrameStartRevealLeft][1] - pxL)), 0) 	_rightCutBackWFrame = max((rightFrameOffset - (rightRevealPnts[idxFrameStartRevealRight][1] - pxR)), 0)	if bTShapedOpening & _bSillBelowSLight then		_leftCutBackWFrame  = 0		_rightCutBackWFrame = 0	endif	_bSillNosing = (gs_sill_nosing > 0)	sillW = WIDO_FRAME_THICKNESS + gs_sill_nosing	sillL = pxR - pxL - ((_leftCutBackWFrame + _rightCutBackWFrame) * not(_bSillNosing))	if bTShapedOpening & _bSillBelowSLight then		if _bSillNosing then			! the sill part under frame or sidelight is thicker			_sillInclinedLength = abs(sillW - gs_sill_topWidth)			_sillInclinedHeight = gs_sill_topHeight - (gs_sill_thk - gs_sill_endthk)			_sillThkAtFrame = gs_sill_thk - gs_sill_endthk + ((_sillInclinedHeight/_sillInclinedLength) * (sillW - WIDO_FRAME_THICKNESS))			put		0,						0,								15,					WIDO_FRAME_THICKNESS,	0,								15,					WIDO_FRAME_THICKNESS,	_sillThkAtFrame,				15,					sillW,					gs_sill_thk - gs_sill_endthk,	15,					sillW,					gs_sill_thk,					15,					0,						gs_sill_thk,					15,					0,						0,								-1		else			put		0,						0,				15,					WIDO_FRAME_THICKNESS,	0,				15,					WIDO_FRAME_THICKNESS,	gs_sill_thk,	15,					0,						gs_sill_thk,	15,					0,						0,				-1		endif	else		put		0,						0,								mask_str,				0,						gs_sill_thk,					mask_str,				sillW,					gs_sill_thk,				 	mask_str,				sillW,					gs_sill_thk - gs_sill_endthk,	mask_str,				gs_sill_topWidth,		gs_sill_topHeight,				mask_str,				gs_sill_topWidth,		0,								mask_str	endif	addx -WIDO_FRAME_THICKNESS	if (_leftCutBackWFrame > 0) & (gs_sill_topWidth < WIDO_FRAME_THICKNESS) then		prism_ 5, _leftCutBackWFrame,			0,						0,				15,			WIDO_FRAME_THICKNESS,	0,				15,			WIDO_FRAME_THICKNESS,	gs_sill_thk,	15,			0,						gs_sill_thk,	15,			0,						0,				-1		if (_bSillNosing) then			cutform 5, 1, 2,					0, 0, 1, _leftCutBackWFrame,					0,						0,				31,					WIDO_FRAME_THICKNESS,	0,				31,					WIDO_FRAME_THICKNESS,	gs_sill_thk,	31,					0,						gs_sill_thk,	31,					0,						0,				-1			_numCuts = 1		endif	endif	if (_rightCutBackWFrame > 0) & (gs_sill_topWidth < WIDO_FRAME_THICKNESS)  then		addz sillL - (_rightCutBackWFrame * _bSillNosing) + (_leftCutBackWFrame * not(_bSillNosing))		prism_ 5, _rightCutBackWFrame,			0,						0,				15,			WIDO_FRAME_THICKNESS,	0,				15,			WIDO_FRAME_THICKNESS,	gs_sill_thk,	15,			0,						gs_sill_thk,	15,			0,						0,				-1		if (_bSillNosing) then			cutform 5, 1, 2,					0, 0, 1, _rightCutBackWFrame,					0,						0,				31,					WIDO_FRAME_THICKNESS,	0,				31,					WIDO_FRAME_THICKNESS,	gs_sill_thk,	31,					0,						gs_sill_thk,	31,					0,						0,				-1			_numCuts = 1		endif		del 1	endif	addz (_leftCutBackWFrame * not(_bSillNosing))	prism_ nsp/3, sillL,		get(nsp)	del 2	for i = 1 to _numCuts		cutend	next i	_numCuts = 0	sillLeft			= abs(pxL)	sillRight			= abs(pxR)	sillBottom			= -gs_sill_thk	sillBottomOutside	= -gs_sill_thk	sillSideHeight		=  gs_sill_endthk	sillSideAngle		=  0	rotz 90	roty -90	addx -pxL		if sidelightCutLeft then			if sidelightCutLeft = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosLeft + thkPlasterAtSillSlLeft, SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk, 10052			else				hotspot sidelightCutPosLeft, SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk, 10051			endif		else			hotspot leftRevealPnts[idxSillEndRevealLeft][1], SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk, 10000		endif		if sidelightCutRight then			if sidelightCutRight = 2 & gs_turn_plaster_show_3D then				hotspot sidelightCutPosRight - thkPlasterAtSillSlRight, SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk, 10053			else				hotspot sidelightCutPosRight, SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk, 10050			endif		else			hotspot rightRevealPnts[idxSillEndRevealRight][1], SillSlipin + gs_sill_holeDepthBehind, -gs_sill_thk, 10001		endif	del 3return