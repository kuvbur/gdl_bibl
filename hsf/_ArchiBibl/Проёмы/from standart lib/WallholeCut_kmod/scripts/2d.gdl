
! Contact person: <NJ>

_bValidPoly = 1

! ==============================================================================
! This macro cuts the wallhole
! ------------------------------------------------------------------------------
! Input parameters:
!
! Hotspot IDs:
!	11040:			Wall Inset left edge (at the inset depth)
!	11041:			Wall Inset right edge (at the inset depth)
!	11042:			Wall Inset left edge (at the wall side)
!	11043:			Wall Inset right edge (at the wall side)
!	11000:			Frame start left
!	11001:			Frame start right
!	11002:			Frame end left
!	11003:			Frame end right
!	11100-11199:	Reveal hotspots
!	11200-:			Polygonal wall corner points
! ==============================================================================


LINE_BEG_X		= 1
LINE_BEG_Y		= 2
LINE_END_X		= 3
LINE_END_Y		= 4
LINE_ATTRIBUTES	= 5	! bitfield, look at LINE_ATTRIBUTES_xxx for available values
LINE_PEN_IDX	= 6
LINE_LTYPE_IDX	= 7

LINE_ATTRIBUTES_GDLLINE		= 0			! Draw GDL Line in the section
LINE_ATTRIBUTES_WALLLINE	= 1			! Draw WallLine in the section
LINE_ATTRIBUTES_WALLSIDE	= 2			! The section is on the wall side (it is an arc in curved wall)
LINE_ATTRIBUTES_DRAWCC		= 3			! The section is drawn by CavityClosure macro (otherwise the WallHoleCut macro)
LINE_ATTRIBUTES_CONTOUR		= 4			! The section is contour or inner line
!!!	LINE_ATTRIBUTES_WALLEDGE	= 0			! The section is on the wall edge (always a line)


! ==============================================================================

if WIDO_REVEAL_SIDE then
	add2 0,-WIDO_FRAME_THICKNESS
else
	mul2 1,-1
endif


! ==============================================================================
! Wallhole (Frame) Hotspots
! ==============================================================================

!if gs_wallhole_hotspots then
!	hotspot2 leftRevealPnts[idxFrameStartRevealLeft][1],	leftRevealPnts[idxFrameStartRevealLeft][2],	 11000
!	hotspot2 rightRevealPnts[idxFrameStartRevealRight][1],	rightRevealPnts[idxFrameStartRevealRight][2],11001
!
!	if iRevealType <> REVEAL_SLANTED then
!		hotspot2 leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2],	11002
!		hotspot2 rightRevealPnts[idxFrameEndRevealRight][1],rightRevealPnts[idxFrameEndRevealRight][2],	11003
!	endif
!endif

if iRevealType > REVEAL_NO then
	hotspot2 leftRevealPnts[idxFrameStartRevealLeft][1],	leftRevealPnts[idxFrameStartRevealLeft][2],	 11000
	hotspot2 rightRevealPnts[idxFrameStartRevealRight][1],	rightRevealPnts[idxFrameStartRevealRight][2],11001
endif



! ==============================================================================
! Reveal Hotspots
! ------------------------------------------------------------------------------
! It skips hotspots on wall contour in case of polygonal walls (AC_WallType = 2).
! Skipped points will be drawn in the polygon operations section
! ==============================================================================

if gs_reveal_hotspots & AC_WallType <> 2 then

	unID = 11100
	for ii = idxSillStartRevealLeft - (AC_WallType = 2) to idxFrameStartRevealLeft - 1
		hotspot2 leftRevealPnts[ii][1], leftRevealPnts[ii][2], unID : unID = unID + 2
	next ii

	unID = 11101
	for ii = idxSillStartRevealRight - (AC_WallType = 2) to idxFrameStartRevealRight - 1
		hotspot2 rightRevealPnts[ii][1], rightRevealPnts[ii][2], unID : unID = unID + 2
	next ii

	! Show hotspot at frame
	bShowLastHpts = not(iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE | iRevealType = REVEAL_SLANTED)

	unID = 11150
	for ii = idxFrameEndRevealLeft + 1 to idxBoardEndRevealLeft - (AC_WallType = 2)
		hotspot2 leftRevealPnts[ii][1], leftRevealPnts[ii][2], unID : unID = unID + 2
	next ii
![#COMPATIBILITY] - START
!	for ii = idxFrameEndRevealLeft + not(bShowLastHpts) to idxBoardEndRevealLeft - (AC_WallType = 2)
!		hotspot2 leftRevealPnts[ii][1], leftRevealPnts[ii][2], unID : unID = unID + 2
!	next ii
	if bShowLastHpts then
		ii = idxFrameEndRevealLeft
		hotspot2 leftRevealPnts[ii][1], leftRevealPnts[ii][2], unID : unID = unID + 2
	endif
![#COMPATIBILITY] - END

	unID = 11151
	for ii = idxFrameEndRevealRight + 1 to idxBoardEndRevealRight - (AC_WallType = 2)
		hotspot2 rightRevealPnts[ii][1], rightRevealPnts[ii][2], unID : unID = unID + 2
	next ii
![#COMPATIBILITY] - START
!	for ii = idxFrameEndRevealRight + not(bShowLastHpts) to idxBoardEndRevealRight - (AC_WallType = 2)
!		hotspot2 rightRevealPnts[ii][1], rightRevealPnts[ii][2], unID : unID = unID + 2
!	next ii
	if bShowLastHpts then
		ii = idxFrameEndRevealRight
		hotspot2 rightRevealPnts[ii][1], rightRevealPnts[ii][2], unID : unID = unID + 2
	endif
![#COMPATIBILITY] - END

	! Show hotspot at corner of turned last plaster skin

	if gs_turn_plaster_dim_2D then

		unID = 11201
		if ((abs(leftRevealPnts[idxSillStartPlasterLeft][1] - leftRevealPnts[idxSillStartRevealLeft][1]) > EPS) |\
			(abs(leftRevealPnts[idxSillStartPlasterLeft][2] - leftRevealPnts[idxSillStartRevealLeft][2]) > EPS)) then

			hotspot2 leftRevealPnts[idxSillStartPlasterLeft][1], leftRevealPnts[idxSillStartPlasterLeft][2], unID : unID = unID + 2
!!!			circle2 leftRevealPnts[idxSillStartPlasterLeft][1], leftRevealPnts[idxSillStartPlasterLeft][2], 0.02
		else
			unID = unID + 2
		endif

		if ((abs(leftRevealPnts[idxBoardEndPlasterLeft][1] - leftRevealPnts[idxBoardEndRevealLeft][1]) > EPS) |\
			(abs(leftRevealPnts[idxBoardEndPlasterLeft][2] - leftRevealPnts[idxBoardEndRevealLeft][2]) > EPS)) then

			hotspot2 leftRevealPnts[idxBoardEndPlasterLeft][1], leftRevealPnts[idxBoardEndPlasterLeft][2], unID : unID = unID + 2
!!!			circle2 leftRevealPnts[idxBoardEndPlasterLeft][1], leftRevealPnts[idxBoardEndPlasterLeft][2], 0.02
		else
			unID = unID + 2
		endif

		unID = 11251
		if ((abs(rightRevealPnts[idxSillStartPlasterRight][1] - rightRevealPnts[idxSillStartRevealRight][1]) > EPS) |\
			(abs(rightRevealPnts[idxSillStartPlasterRight][2] - rightRevealPnts[idxSillStartRevealRight][2]) > EPS)) then

			hotspot2 rightRevealPnts[idxSillStartPlasterRight][1], rightRevealPnts[idxSillStartPlasterRight][2], unID : unID = unID + 2
!!!			circle2 rightRevealPnts[idxSillStartPlasterRight][1], rightRevealPnts[idxSillStartPlasterRight][2], 0.02
		else
			unID = unID + 2
		endif

		if ((abs(rightRevealPnts[idxBoardEndPlasterRight][1] - rightRevealPnts[idxBoardEndRevealRight][1]) > EPS) |\
			(abs(rightRevealPnts[idxBoardEndPlasterRight][2] - rightRevealPnts[idxBoardEndRevealRight][2]) > EPS)) then

			hotspot2 rightRevealPnts[idxBoardEndPlasterRight][1], rightRevealPnts[idxBoardEndPlasterRight][2], unID : unID = unID + 2
!!!			circle2 rightRevealPnts[idxBoardEndPlasterRight][1], rightRevealPnts[idxBoardEndPlasterRight][2], 0.02
		else
			unID = unID + 2
		endif

	endif
endif

polyUnID = 11200	! Hotspot unID for polygonal wall corner points


! ==============================================================================



bNeedToOffsetSkins		= (offsetSill > EPS | offsetBoard > EPS)

if isWindow then
	drawindex 30	! Draw parapet contour lines at the bottom
else
	drawindex 20	! Draw parapet contour lines at the bottom
endif


! ==============================================================================
! Cut corners in case of corner window function
! ==============================================================================

if not(curvedWall) & not(bInclinedWall) & AC_WallType <> 2 & not(gs_transom_display) then	! Not drawn when Display as Transom is ON
	if bLeftCornerFunction then
		fill 0
		if GLOB_CONTEXT = 5 then
			poly2_b 4, 2+4+64, 0, -1,
				leftRevealPnts[idxBoardEndPlasterLeft][1],  leftRevealPnts[idxBoardEndPlasterLeft][2],  0,
				leftRevealPnts[idxSillStartPlasterLeft][1], leftRevealPnts[idxSillStartPlasterLeft][2], 0,
				0, leftRevealPnts[idxSillStartPlasterLeft][2], 0,
				0, leftRevealPnts[idxBoardEndPlasterLeft][2],  0
		else
			wallhole2 4, 2 + 64, 0, -1,
				0, 0, 0,
				leftRevealPnts[idxBoardEndPlasterLeft][1],  leftRevealPnts[idxBoardEndPlasterLeft][2],  0,
				leftRevealPnts[idxSillStartPlasterLeft][1], leftRevealPnts[idxSillStartPlasterLeft][2], 0,
				0, leftRevealPnts[idxSillStartPlasterLeft][2], 0,
				0, leftRevealPnts[idxBoardEndPlasterLeft][2],  0
		endif
	endif
	if bRightCornerFunction then
		fill 0
		if GLOB_CONTEXT = 5 then
			poly2_b 4, 2+4+64, 0, -1,
				rightRevealPnts[idxBoardEndPlasterRight][1],  rightRevealPnts[idxBoardEndPlasterRight][2],  0,
				rightRevealPnts[idxSillStartPlasterRight][1], rightRevealPnts[idxSillStartPlasterRight][2], 0,
				0, rightRevealPnts[idxSillStartPlasterRight][2], 0,
				0, rightRevealPnts[idxBoardEndPlasterRight][2],  0
		else
			wallhole2 4, 2 + 64, 0, -1,
				0, 0, 0,
				rightRevealPnts[idxBoardEndPlasterRight][1],  rightRevealPnts[idxBoardEndPlasterRight][2],  0,
				rightRevealPnts[idxSillStartPlasterRight][1], rightRevealPnts[idxSillStartPlasterRight][2], 0,
				0, rightRevealPnts[idxSillStartPlasterRight][2], 0,
				0, rightRevealPnts[idxBoardEndPlasterRight][2],  0
		endif
	endif
endif


! =============================================================================
! Change visible contour line to hidden contour line
! =============================================================================

if bEnableWallContourHiddenLine then
	if bWallContHiddenLineIn then
		gs_wcont_line_in	= gs_wcont_hidden_line_in
	endif
	if bWallContHiddenLineOut then
		gs_wcont_line_out	= gs_wcont_hidden_line_out
	endif

	if bWallContHiddenLineInLeftSl then
		_wcont_line_left_sl_in	= gs_wcont_hidden_line_sl_in
	else
		_wcont_line_left_sl_in	= gs_wcont_line_sl_in
	endif
	if bWallContHiddenLineOutLeftSl then
		_wcont_line_left_sl_out	= gs_wcont_hidden_line_sl_out
	else
		_wcont_line_left_sl_out	= gs_wcont_line_sl_out
	endif

	if bWallContHiddenLineInRightSl then
		_wcont_line_right_sl_in		= gs_wcont_hidden_line_sl_in
	else
		_wcont_line_right_sl_in		= gs_wcont_line_sl_in
	endif
	if bWallContHiddenLineOutRightSl then
		_wcont_line_right_sl_out	= gs_wcont_hidden_line_sl_out
	else
		_wcont_line_right_sl_out	= gs_wcont_line_sl_out
	endif
endif


! ==============================================================================
! Cut 2D Wallhole and Draw Background Fills
! ==============================================================================

bUseOneBackgroundFill		= (bDrawSillFill = bDrawBoardFill)	! 1 - 1 or 0 - 0
bVisibleWallInsetIn2D		= (bParapetWallInset & ((bParapetWallInsetFullHeight & (bDrawBoardFill | gs_parapet_2D)) | (not(bParapetWallInsetFullHeight) & gs_parapet_2D)))
bHiddenParapetWallInsetIn2D	= (bParapetWallInset & (not(bParapetWallInsetFullHeight) | not(bDrawBoardFill)))

bSkipSillFill = (abs(WIDO_SILL) < EPS & AC_WallType <> 2 & (not(curvedWall) | (curvedWall & gs_IsCurved)))

if vardim1(leftRevealPnts) > 1 & not(gs_transom_display) then	! Not drawn when Display as Transom is ON

	if bHasSidelightLeft | bHasSidelightRight then
		wallholeFill	= gs_wallhole_fill_sl
		wallholePen_fg	= gs_wallhole_pen_sl_fg
		wallholePen_bg	= gs_wallhole_pen_sl_bg

		if bHasSidelightLeft then
			wcontLineIn			= _wcont_line_left_sl_in  * (iWallContourLineSl = 2 | iWallContourLineSl = 4)
			wcontLineOut		= _wcont_line_left_sl_out * (iWallContourLineSl = 3 | iWallContourLineSl = 4)
			sidelightCutLeft	= 0
			sidelightCutRight	= 1
			sidelightCutPosSillRight	= -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_left_sL + thkPlasterAtSillSlLeft
			sidelightCutPosMiddleRight	= -leftWidth + gs_sidelight_WHole_width_left
			sidelightCutPosBoardRight	= -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_double_innerLeft_sL + thkPlasterAtBoardSlLeft
			gosub "DrawWallholeFill"
		endif

		if bHasSidelightRight then
			wcontLineIn			= _wcont_line_right_sl_in  * (iWallContourLineSl = 2 | iWallContourLineSl = 4)
			wcontLineOut		= _wcont_line_right_sl_out * (iWallContourLineSl = 3 | iWallContourLineSl = 4)
			sidelightCutLeft 	= 1
			sidelightCutRight 	= 0
			sidelightCutPosSillLeft		= rightWidth - gs_sidelight_WHole_width_right - gs_reveal_right_sR - thkPlasterAtSillSlRight
			sidelightCutPosMiddleLeft	= rightWidth - gs_sidelight_WHole_width_right
			sidelightCutPosBoardLeft	= rightWidth - gs_sidelight_WHole_width_right - gs_reveal_double_innerRight_sR - thkPlasterAtBoardSlRight
			gosub "DrawWallholeFill"
		endif

		wallholeFill	= gs_wallhole_fill
		wallholePen_fg	= gs_wallhole_pen_fg
		wallholePen_bg	= gs_wallhole_pen_bg
		wcontLineIn		= gs_wcont_line_in  * (iWallContourLine = 2 | iWallContourLine = 4)
		wcontLineOut	= gs_wcont_line_out * (iWallContourLine = 3 | iWallContourLine = 4)

		sidelightCutLeft  = 2 * bHasSidelightLeft
		sidelightCutRight = 2 * bHasSidelightRight
		sidelightCutPosSillLeft		= -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_left_sL + thkPlasterAtSillSlLeft
		sidelightCutPosMiddleLeft	= -leftWidth + gs_sidelight_WHole_width_left
		sidelightCutPosBoardLeft	= -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_double_innerLeft_sL + thkPlasterAtBoardSlLeft
		sidelightCutPosSillRight	= rightWidth - gs_sidelight_WHole_width_right - gs_reveal_right_sR - thkPlasterAtSillSlRight
		sidelightCutPosMiddleRight	= rightWidth - gs_sidelight_WHole_width_right
		sidelightCutPosBoardRight	= rightWidth - gs_sidelight_WHole_width_right - gs_reveal_double_innerRight_sR - thkPlasterAtBoardSlRight
		gosub "DrawWallholeFill"
	else
		wallholeFill	= gs_wallhole_fill
		wallholePen_fg	= gs_wallhole_pen_fg
		wallholePen_bg	= gs_wallhole_pen_bg
		wcontLineIn		= gs_wcont_line_in  * (iWallContourLine = 2 | iWallContourLine = 4)
		wcontLineOut	= gs_wcont_line_out * (iWallContourLine = 3 | iWallContourLine = 4)

		sidelightCutLeft  = 0
		sidelightCutRight = 0
		gosub "DrawWallholeFill"
	endif
endif


! Draw Parapet Contours Outside ------------------------------------------------

bWallContourLine	= (iWallContourLine = 3 | iWallContourLine = 4)							! Outside, Both Sides
bWallContourLineSl	= ((iWallContourLineSl = 3 | iWallContourLineSl = 4) & bTShapedOpening)	! Outside, Both Sides

if AC_WallType <> 2 & (bWallContourLine | bWallContourLineSl) & not(gs_transom_display) then
	gosub "DrawContourLinesOutside"
endif


! Draw Parapet Contour Inside --------------------------------------------------

bWallContourLine	= (iWallContourLine = 2 | iWallContourLine = 4)							! Inside, Both Sides
bWallContourLineSl	= ((iWallContourLineSl = 2 | iWallContourLineSl = 4) & bTShapedOpening)	! Inside, Both Sides

if not(bVisibleWallInsetIn2D) & AC_WallType <> 2 & (bWallContourLine | bWallContourLineSl) & not(gs_transom_display) then
	gosub "DrawContourLinesInside"
endif


! Head / Threshold Plan Symbol -------------------------------------------------

if iRevealType > REVEAL_NO & gs_head_symbol & (abs(gs_reveal_top) > EPS | abs(gs_reveal_bottom) > EPS) & not(gs_transom_display) then
	gosub "DrawHeadThresholdPlanSymbol"
endif


! Drawing the wall contour lines -----------------------------------------------

drawindex 50	! Draw wall contour lines at the top
bListView = (GLOB_CONTEXT = 6 | GLOB_CONTEXT = 46)
if not(bListView) then
	gosub "DrawWallContourLines"
endif


! Draw New Wallhole Symbol (SWE symbol) -----------------------------------------

if gs_bShowNewOnCC & (iTypeDemolitionFill = RENOVATION_FILL_NEW | iTypeDemolitionFill = RENOVATION_FILL_NEW_FULL) then
	gosub "DrawSWENewWallholeSymbol"
endif


! Drawing Mounting Frame -------------------------------------------------------

if bHaveMountingFrame & lod2D_MountingFrame > 0 then
	gosub "DrawMountingFrame"
endif


! ==============================================================================
end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
! ==============================================================================


"DrawWallholeFill":

! Cut 2D Wallhole - Straight, Trapezoid and Arched Walls ----------------------

	if (bUseOneBackgroundFill | bVisibleWallInsetIn2D | bNeedToOffsetSkins) then
		gosub "DrawWallholeFillBothSides"
	endif


! Draw Sill Side Background Fill and Parapet Contours -------------------------

	bUsePolygonOperations	= 0
	bCutWallInsetWithPolyOp	= 0
	bAutoParapetInset		= 0

	if (not(bUseOneBackgroundFill) | bVisibleWallInsetIn2D | bNeedToOffsetSkins) & not(bSkipSillFill) then
		gosub "DrawWallholeFillOutside"
	endif


! Draw Board Side Background Fill and Parapet Contours ------------------------

	gosub "DrawWallholeFillInside"
return



! ==============================================================================
! Cut wallhole - both sides
! ==============================================================================

"DrawWallholeFillBothSides":

	if AC_WallType <> 2 then

		bDrawFill = ((bDrawSillFill & bDrawBoardFill) & not(bVisibleWallInsetIn2D | bNeedToOffsetSkins))

		if curvedWall then put 0,WOD,900

		if sidelightCutLeft then
			if curvedWall then
				put sidelightCutPosSillLeft, WOD - signWallIsLeft * sqr(radSill^2 - sidelightCutPosSillLeft^2), 0
			else
				put sidelightCutPosSillLeft, leftRevealPnts[idxSillStartPlasterLeft][2], 0
			endif
			if abs(sidelightCutPosSillLeft - sidelightCutPosMiddleLeft) > EPS then
				put sidelightCutPosSillLeft,	0, 0,
					sidelightCutPosMiddleLeft,	0, 0
			endif
			if abs(sidelightCutPosMiddleLeft - sidelightCutPosBoardLeft) > EPS then
				put sidelightCutPosMiddleLeft,	WIDO_FRAME_THICKNESS, 0,
					sidelightCutPosBoardLeft,	WIDO_FRAME_THICKNESS, 0
			endif
			if curvedWall then
				put sidelightCutPosBoardLeft, WOD - signWallIsLeft * sqr(radBoard^2 - sidelightCutPosBoardLeft^2), 0
			else
				if bInclinedWall then
					put sidelightCutPosBoardLeft,
						leftRevealPnts[idxBoardEndPlasterLeft][2] + (leftRevealPnts[idxBoardEndPlasterLeft][1] - sidelightCutPosBoardLeft) * \
						(leftRevealPnts[idxBoardEndPlasterLeft][2] - rightRevealPnts[idxBoardEndPlasterRight][2]) / (-leftRevealPnts[idxBoardEndPlasterLeft][1] + rightRevealPnts[idxBoardEndPlasterRight][1]),
						0
				else
					put sidelightCutPosBoardLeft, leftRevealPnts[idxBoardEndPlasterLeft][2], 0
				endif
			endif
		else
			if bLeftCornerFunction then
				put leftRevealPnts[idxSillStartPlasterLeft][1],	leftRevealPnts[idxSillStartPlasterLeft][2],	0,
					leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2],	0,
					leftRevealPnts[idxBoardEndPlasterLeft][1],	leftRevealPnts[idxBoardEndPlasterLeft][2],	0
			else
				if	(( (iRevealType = REVEAL_EDGE) | (iRevealType = REVEAL_NO) ) &\
					 ( abs(thkPlasterAtSillLeft) < EPS ) &\
					 ( abs(thkPlasterAtBoardLeft) < EPS )) then

					put leftRevealPnts[idxSillStartPlasterLeft][1], leftRevealPnts[idxSillStartPlasterLeft][2], 0
					put leftRevealPnts[idxBoardEndPlasterLeft][1], leftRevealPnts[idxBoardEndPlasterLeft][2], 0
				else
					for i=idxSillStartPlasterLeft to idxSillEndPlasterLeft
						put leftRevealPnts[i][1], leftRevealPnts[i][2], 0
					next i

					if	(abs(leftRevealPnts[idxFrameStartRevealLeft][1] - leftRevealPnts[idxSillEndPlasterLeft][1]) > EPS) | \
						(abs(leftRevealPnts[idxFrameStartRevealLeft][2] - leftRevealPnts[idxSillEndPlasterLeft][2]) > EPS) then
							put leftRevealPnts[idxFrameStartRevealLeft][1],	leftRevealPnts[idxFrameStartRevealLeft][2], 0
					endif
					if	(abs(leftRevealPnts[idxFrameEndRevealLeft][1] - leftRevealPnts[idxBoardStartPlasterLeft][1]) > EPS) | \
						(abs(leftRevealPnts[idxFrameEndRevealLeft][2] - leftRevealPnts[idxBoardStartPlasterLeft][2]) > EPS) then
							put leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2], 0
					endif

					for i=idxBoardStartPlasterLeft to idxBoardEndPlasterLeft
						put leftRevealPnts[i][1], leftRevealPnts[i][2], 0
					next i
				endif
			endif
		endif

		if sidelightCutRight then
			if curvedWall then
				put sidelightCutPosBoardRight, WOD - signWallIsLeft * sqr(radBoard^2 - sidelightCutPosBoardRight^2), 3000 * bDrawFill
			else
				if bInclinedWall then
					put sidelightCutPosBoardRight,
						rightRevealPnts[idxBoardEndPlasterRight][2] + (rightRevealPnts[idxBoardEndPlasterRight][1] - sidelightCutPosBoardRight) * \
						(leftRevealPnts[idxBoardEndPlasterLeft][2] - rightRevealPnts[idxBoardEndPlasterRight][2]) / (-leftRevealPnts[idxBoardEndPlasterLeft][1] + rightRevealPnts[idxBoardEndPlasterRight][1]),
						0
				else
					put sidelightCutPosBoardRight, rightRevealPnts[idxBoardEndPlasterRight][2], 0
				endif
			endif
			if abs(sidelightCutPosBoardRight - sidelightCutPosMiddleRight) > EPS then
				put sidelightCutPosBoardRight,	WIDO_FRAME_THICKNESS, 0,
					sidelightCutPosMiddleRight,	WIDO_FRAME_THICKNESS, 0
			endif
			if abs(sidelightCutPosMiddleRight - sidelightCutPosSillRight) > EPS then
				put sidelightCutPosMiddleRight,	0, 0,
					sidelightCutPosSillRight,	0, 0
			endif
			if curvedWall then
				put sidelightCutPosSillRight, WOD - signWallIsLeft * sqr(radSill^2 - sidelightCutPosSillRight^2), 0
			else
				put sidelightCutPosSillRight, rightRevealPnts[idxSillStartPlasterRight][2], 0
			endif
		else
			if bRightCornerFunction then
				put rightRevealPnts[idxBoardEndPlasterRight][1],  rightRevealPnts[idxBoardEndPlasterRight][2],	0,
					rightRevealPnts[idxFrameEndRevealRight][1],   rightRevealPnts[idxFrameEndRevealRight][2],	0,
					rightRevealPnts[idxSillStartPlasterRight][1], rightRevealPnts[idxSillStartPlasterRight][2],	0
			else
				if	(( (iRevealType = REVEAL_EDGE) | (iRevealType = REVEAL_NO) ) &\
					 ( abs(thkPlasterAtSillRight) < EPS ) &\
					 ( abs(thkPlasterAtBoardRight) < EPS )) then

					put rightRevealPnts[idxBoardEndPlasterRight][1], rightRevealPnts[idxBoardEndPlasterRight][2]
					if curvedWall then
						put 3000 * (bDrawFill | not(wallIsLeft))
					else
						put 0
					endif
					put rightRevealPnts[idxSillStartPlasterRight][1], rightRevealPnts[idxSillStartPlasterRight][2], 0
				else
					for i = idxBoardEndPlasterRight to idxBoardStartPlasterRight step -1
						put rightRevealPnts[i][1], rightRevealPnts[i][2]
						if curvedWall & i = idxBoardEndPlasterRight then
							put 3000 * (bDrawFill | not(wallIsLeft))
						else
							put 0
						endif
					next i

					if	(abs(rightRevealPnts[idxFrameEndRevealLeft][1] - rightRevealPnts[idxBoardStartPlasterRight][1]) > EPS) | \
						(abs(rightRevealPnts[idxFrameEndRevealLeft][2] - rightRevealPnts[idxBoardStartPlasterRight][2]) > EPS) then
							put rightRevealPnts[idxFrameEndRevealLeft][1],	rightRevealPnts[idxFrameEndRevealLeft][2], 0
					endif
					if	(abs(rightRevealPnts[idxFrameStartRevealLeft][1] - rightRevealPnts[idxSillEndPlasterRight][1]) > EPS) | \
						(abs(rightRevealPnts[idxFrameStartRevealLeft][2] - rightRevealPnts[idxSillEndPlasterRight][2]) > EPS) then
							put rightRevealPnts[idxFrameStartRevealLeft][1],	rightRevealPnts[idxFrameStartRevealLeft][2], 0
					endif

					for i = idxSillEndPlasterRight to idxSillStartPlasterRight step -1
						put rightRevealPnts[i][1], rightRevealPnts[i][2], 0
					next i
				endif
			endif
		endif

		if curvedWall then
			if sidelightCutLeft then
				put sidelightCutPosSillLeft, leftRevealPnts[idxSillStartPlasterLeft][2], 3000 * (bDrawFill | wallIsLeft)
			else
				put leftRevealPnts[idxSillStartPlasterLeft][1], leftRevealPnts[idxSillStartPlasterLeft][2], 3000 * (bDrawFill | wallIsLeft)
			endif
		endif


		! Ignore point if location of previous point is same, contour bit is always zero
!!!		define style "text01" "arial", 0.3, 5, 0
!!!		set style "text01"
!!!		line_type 1

		_num = nsp/3
		dim temp_coord[][]
		for i = 1 to _num
			temp_x = get(1)
			temp_y = get(1)
			temp_s = get(1)

!!!			text2 temp_x, temp_y, i
!!!			circle2 temp_x, temp_y, 0.01

			temp_coord[i][1] = temp_x
			temp_coord[i][2] = temp_y
			temp_coord[i][3] = temp_s
		next i

		for i = 1 to _num
			if i > 1 then
				if not((abs(temp_coord[i-1][1] - temp_coord[i][1]) < EPS) & (abs(temp_coord[i-1][2] - temp_coord[i][2]) < EPS)) then
					put temp_coord[i][1]
					put temp_coord[i][2]
					put temp_coord[i][3]

!!!					text2 temp_coord[i][1], temp_coord[i][2], i
!!!					circle2 temp_coord[i][1], temp_coord[i][2], 0.01
				endif
			else
				put temp_coord[i][1]
				put temp_coord[i][2]
				put temp_coord[i][3]
			endif
		next i

		if nsp > 8 then
			if bDrawFill then
				fill wallholeFill
				if GLOB_CONTEXT = 5 then
					poly2_b nsp/3, 2 + 4 + 64, wallholePen_fg,wallholePen_bg,
						get(nsp)
				else
					wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
						0, 0, 0, get(nsp)
				endif
			else
				fill 0
				if GLOB_CONTEXT = 5 then
					poly2_b nsp/3, 2 + 4 + 64, 0, -1,
						get(nsp)
				else
					wallhole2 nsp/3, 2 + 64, 0, -1,
						0, 0, 0, get(nsp)
				endif
			endif
		else
			for i = 1 to nsp
				temp_param = get(1)
			next i
		endif
	endif


! ==============================================================================
! Cut 2D Wallhole - Polygonal Walls
! ==============================================================================

	if AC_WallType = 2 then

		ch = initaddonscope ("PolyOperations", "", "")

		preparefunction ch, "CreateContainer", "mySourceContainer", ""
		preparefunction ch, "CreateContainer", "myDestinationContainer", ""

		preparefunction ch, "SetSourceContainer",	 	"mySourceContainer", ""
		preparefunction ch, "SetDestinationContainer",	"myDestinationContainer", ""

! Store wallhole polygon -------------------------------------------------------

		if sidelightCutLeft then
			put sidelightCutPosSillLeft, leftRevealPnts[idxSillStartPlasterLeft][2],  3 * (sidelightCutLeft = 1),
				sidelightCutPosSillLeft, 0, 0
			if abs(sidelightCutPosSillLeft - sidelightCutPosMiddleLeft) > EPS then
				put	sidelightCutPosMiddleLeft,	0, 0
			endif
			if abs(sidelightCutPosMiddleLeft - sidelightCutPosBoardLeft) > EPS then
				put sidelightCutPosMiddleLeft,	0, 0
			endif
			put	sidelightCutPosBoardLeft, 0, 2 * (sidelightCutLeft = 1),
				sidelightCutPosBoardLeft, leftRevealPnts[idxBoardEndPlasterLeft][2], -1
		else
			bHasAnySillPoint = 0
			lastSillPointX = leftRevealPnts[idxSillStartRevealLeft][1]
			lastSillPointY = leftRevealPnts[idxSillStartRevealLeft][2]
			for i=idxSillStartRevealLeft to idxSillEndRevealLeft
				if leftRevealPnts[i][2] <= 0 then
					distFromLast = abs((leftRevealPnts[i][1] - lastSillPointX)^2 + (leftRevealPnts[i][2] - lastSillPointY)^2)
					if not(bHasAnySillPoint) | distFromLast > EPS then
						put leftRevealPnts[i][1], leftRevealPnts[i][2], not(gs_stack_left)
						lastSillPointX = leftRevealPnts[i][1]
						lastSillPointY = leftRevealPnts[i][2]
						bHasAnySillPoint = 1
					endif
				endif
			next i
			if idxFrameStartRevealLeft <> idxSillEndRevealLeft | not(bHasAnySillPoint) then
				put leftRevealPnts[idxFrameStartRevealLeft][1],	leftRevealPnts[idxFrameStartRevealLeft][2],	not(gs_stack_left)
			endif
			put leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2]
			bStatusSet = 0
			bHasAnyBoardPoint = 0
			lastBoardPointX = leftRevealPnts[idxBoardStartRevealLeft + (idxFrameEndRevealLeft = idxBoardStartRevealLeft)][1]
			lastBoardPointY = leftRevealPnts[idxBoardStartRevealLeft + (idxFrameEndRevealLeft = idxBoardStartRevealLeft)][2]
			for i=idxBoardStartRevealLeft + (idxFrameEndRevealLeft = idxBoardStartRevealLeft) to idxBoardEndRevealLeft
				if leftRevealPnts[i][2] >= WIDO_FRAME_THICKNESS then
					distFromLast = abs((leftRevealPnts[i][1] - lastBoardPointX)^2 + (leftRevealPnts[i][2] - lastBoardPointY)^2)
					if not(bHasAnyBoardPoint) | distFromLast > EPS then
						if not(bStatusSet) then
							put not(gs_stack_left)
							bStatusSet = 1
						endif
						put leftRevealPnts[i][1], leftRevealPnts[i][2]
						if i = idxBoardEndRevealLeft then
							put -1
						else
							put not(gs_stack_left)
						endif
						lastBoardPointX = leftRevealPnts[i][1]
						lastBoardPointY = leftRevealPnts[i][2]
						bHasAnyBoardPoint = 1
					endif
				endif
			next i
			if not(bStatusSet) then
				put -1
				bStatusSet = 1
			endif
		endif

		if sidelightCutRight then
			put sidelightCutPosBoardRight, rightRevealPnts[idxBoardEndPlasterRight][2], 2 * (sidelightCutRight = 1),
				sidelightCutPosBoardRight,	0, 0
			if abs(sidelightCutPosBoardRight - sidelightCutPosMiddleRight) > EPS then
				put	sidelightCutPosMiddleRight,	0, 0
			endif
			if abs(sidelightCutPosMiddleRight - sidelightCutPosSillRight) > EPS then
				put sidelightCutPosMiddleRight,	0, 0
			endif
			put	sidelightCutPosSillRight, 0, 3 * (sidelightCutRight = 1),
				sidelightCutPosSillRight, rightRevealPnts[idxSillStartPlasterRight][2], -1
		else
			bHasAnyBoardPoint = 0
			for i = idxBoardEndRevealRight to idxBoardStartRevealRight step -1
				if rightRevealPnts[i][2] >= WIDO_FRAME_THICKNESS then
					distFromLast = abs((rightRevealPnts[i][1] - lastBoardPointX)^2 + (rightRevealPnts[i][2] - lastBoardPointY)^2)
					if not(bHasAnyBoardPoint) | distFromLast > EPS then
						put rightRevealPnts[i][1], rightRevealPnts[i][2], not(gs_stack_right)
						lastBoardPointX = rightRevealPnts[i][1]
						lastBoardPointY = rightRevealPnts[i][2]
						bHasAnyBoardPoint = 1
					endif
				endif
			next i
			if idxFrameEndRevealRight <> idxBoardStartRevealRight | not(bHasAnyBoardPoint) then
				put rightRevealPnts[idxFrameEndRevealRight][1],	 rightRevealPnts[idxFrameEndRevealRight][2],	not(gs_stack_right)
			endif
			put rightRevealPnts[idxFrameStartRevealRight][1],rightRevealPnts[idxFrameStartRevealRight][2],	not(gs_stack_right)
			bHasAnySillPoint = 0
			lastSillPointX = rightRevealPnts[idxFrameStartRevealRight][1]
			lastSillPointY = rightRevealPnts[idxFrameStartRevealRight][2]
			for i = idxSillEndRevealRight - (idxFrameStartRevealRight = idxSillEndRevealRight) to idxSillStartRevealRight step -1
				if rightRevealPnts[i][2] <= 0 then
					distFromLast = abs((rightRevealPnts[i][1] - lastSillPointX)^2 + (rightRevealPnts[i][2] - lastSillPointY)^2)
					if distFromLast > EPS then
						put rightRevealPnts[i][1], rightRevealPnts[i][2]
						if i = idxSillStartRevealRight then
							put -1
						else
							put not(gs_stack_right)
						endif
						lastSillPointX = rightRevealPnts[i][1]
						lastSillPointY = rightRevealPnts[i][2]
						bHasAnySillPoint = 1
					endif
				endif
			next i
		endif

		nVertices1 = nsp/3
		dim vertArr1[][3]

		defaultInhEdgeInfo = 0
		dim inhEdgeInfos1[]

		for i=1 to nVertices1
			vertarr1[i][1]	 = get(1)
			vertarr1[i][2]	 = get(1)
			vertarr1[i][3]	 = 0
			inhEdgeInfos1[i] = get(1)	! Mark wallhole edges
		next i

		nContours1 = 1
		dim contArr1[]
		contArr1[1] = nVertices1 + 1

		preparefunction ch, "Store", "wallHolePoly", nVertices1, nContours1, vertArr1, contArr1, defaultInhEdgeInfo, inhEdgeInfos1

		prevSourceContainer	= ""
		lastDestContainer	= "mySourceContainer"
		preparefunction ch, "SetDestinationContainer", lastDestContainer, ""


! Offset sill side edge --------------------------------------------------------

		if prevSourceContainer <> "" then
			preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
		endif
		preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
		prevSourceContainer	= lastDestContainer
		lastDestContainer	= "myDestContainer1"
		preparefunction ch, "CreateContainer",			lastDestContainer, ""
		preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

		preparefunction ch, "OffsetParams", "", 1, 2.00

		dim srcPolyIDArr[]
		numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

		dim tempResPolyIDArr[]
		for i=1 to numPoly
			tempNumPoly = callfunction (ch, "OffsetEdge", srcPolyIDArr[i], tempResPolyIDArr)
		next i

!!!dim resPolyIDArr[]
!!!numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!for i = 1 to numPoly
!!!	polygonID = resPolyIDArr[i]
!!!	gosub 1000	! Get GDL Polygon
!!!
!!!	ccc=0
!!!	for j=1 to nsp/3
!!!		xx=get(1)
!!!		yy=get(1)
!!!		ss=get(1)
!!!		ccc=ccc+0.003
!!!		circle2 xx,yy,ccc
!!!		text2 xx,yy,j
!!!	next j
!!!next i
!!!end

! Offset board side edge -------------------------------------------------------

		dim dstPolyIDArr[]
		numPoly = callfunction (ch, "GetDestinationPolygons", "", dstPolyIDArr)

		dim edgeIds[]
		edgeIds[numPoly] = 0
		for i=1 to numPoly

			dim inhEdgeInfos[]
			numEdges = callfunction(ch, "GetInhEdgeInfos", dstPolyIDArr[i], inhEdgeInfos)

			for j=1 to numEdges
				if inhEdgeInfos[j] = -1 then edgeIds[i] = j
			next j
		next i

		if prevSourceContainer <> "" then
			preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
		endif
		preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
		prevSourceContainer	= lastDestContainer
		lastDestContainer	= "myDestContainer2"
		preparefunction ch, "CreateContainer",			lastDestContainer, ""
		preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

		dim srcPolyIDArr[]
		numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

		dim tempResPolyIDArr[]
		for i=1 to numPoly

			preparefunction ch, "OffsetParams", "", edgeIds[i], 2.00

			tempNumPoly = callfunction (ch, "OffsetEdge", srcPolyIDArr[i], tempResPolyIDArr)
		next i

!!!dim resPolyIDArr[]
!!!numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!for i = 1 to numPoly
!!!	polygonID = resPolyIDArr[i]
!!!	gosub 1000	! Get GDL Polygon
!!!
!!!	ccc=0
!!!	for j=1 to nsp/3
!!!		xx=get(1)
!!!		yy=get(1)
!!!		ss=get(1)
!!!		ccc=ccc+0.003
!!!		circle2 xx,yy,ccc
!!!		text2 xx,yy,j
!!!	next j
!!!next i
!!!end

! Store wall contour polygon in wallhole coordinate system ---------------------

		if prevSourceContainer <> "" then
			preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
		endif
		preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
		prevSourceContainer	= lastDestContainer
		lastDestContainer	= "myDestContainer3"
		preparefunction ch, "CreateContainer",			lastDestContainer, ""
		preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

		nVertices2 = vardim1(AC_WallContourPolygon)
		dim vertArr2[][3]

		dim srcPolyIDArr[]
		numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

		defaultInhEdgeInfo = 0
		dim inhEdgeInfos2[]

		for i=1 to nVertices2
			vertarr2[i][1] = AC_WallContourPolygon[i][1]
			if WIDO_REVEAL_SIDE then
				vertarr2[i][2] = AC_WallContourPolygon[i][2] + WIDO_FRAME_THICKNESS
				vertarr2[i][3] = AC_WallContourPolygon[i][3]
			else
				vertarr2[i][2] = -AC_WallContourPolygon[i][2]
				vertarr2[i][3] = -AC_WallContourPolygon[i][3]
			endif

			inhEdgeInfos2[i] = 2 + (vertarr2[i][2] < EPS)
		next i

		nContours2 = 1
		dim contArr2[]
		contArr2[1] = nVertices2 + 1

		preparefunction ch, "Store", "wallContourPoly", nVertices2, nContours2, vertArr2, contArr2, defaultInhEdgeInfo, inhEdgeInfos2

! Intersect polygons -----------------------------------------------------------

		dim tempResPolyIDArr[]
		for i = 1 to numPoly
			tempNumPoly = callfunction (ch, "wallContourPoly / " + srcPolyIDArr[i], "", tempResPolyIDArr)
		next i

! Draw polygons ----------------------------------------------------------------

		dim resPolyIDArr[]
		numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)

		if not(gs_transom_display) then 	! Not drawn when Display as Transom is ON
			for i = 1 to numPoly
				polygonID = resPolyIDArr[i]
				gosub 1000	! Get GDL Polygon

				if _bValidPoly then
					if bDrawSillFill & bDrawBoardFill & not(bVisibleWallInsetIn2D) then
						fill wallholeFill
						if GLOB_CONTEXT = 5 then
							poly2_b nsp/3, 2+4+64, wallholePen_fg,wallholePen_bg,
								get(nsp)
						else
							wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
								0, 0, 0, get(nsp)
						endif
					else
						fill 0
						if GLOB_CONTEXT = 5 then
							poly2_b nsp/3, 2+4+64, 0, -1,
								get(nsp)
						else
							wallhole2 nsp/3, 2 + 64, 0, -1,
								0, 0, 0, get(nsp)
						endif
					endif
				endif
			next i
		endif

! Draw wall contour lines ------------------------------------------------------

		dim lineAttributes[3][4]
		lineAttributes[1][1] = WALL_SECT_PEN
		lineAttributes[1][2] = WALL_LINETYPE
		lineAttributes[1][3] = LINE_PROPERTY_CONTOUR
		lineAttributes[1][4] = bitset(0, LINE_ATTRIBUTES_WALLLINE)

		lineAttributes[2][1] = gs_wcont_line_pen * (wcontLineIn > 0) * not(bVisibleWallInsetIn2D)	! Inside, Both Sides
		lineAttributes[2][2] = wcontLineIn
		lineAttributes[2][3] = LINE_PROPERTY_GENERIC
		lineAttributes[2][4] = bitset(0, LINE_ATTRIBUTES_GDLLINE)

		lineAttributes[3][1] = gs_wcont_line_pen * (wcontLineOut > 0)	! Outside, Both Sides
		lineAttributes[3][2] = wcontLineOut
		lineAttributes[3][3] = LINE_PROPERTY_GENERIC
		lineAttributes[3][4] = bitset(0, LINE_ATTRIBUTES_GDLLINE)

		bPutHotsopts	= (AC_WallType = 2)

		for i = 1 to numPoly
			polygonID = resPolyIDArr[i]
			gosub 1001	! Draw one polygon contour line
		next i

! Close channel ----------------------------------------------------------------

		closeaddonscope ch
	endif	! if AC_WallType = 2 then

return


! =============================================================================
! Draw Sill side background fill and parapet contours
! =============================================================================

"DrawWallholeFillOutside":

	if AC_WallType = 2 then
		bUsePolygonOperations	= 1
	else
		bUsePolygonOperations	= (offsetSill > EPS & offsetSill > WIDO_SILL)

! Draw Sill Side Fill or Wallhole ----------------------------------------------

		if curvedWall then put 0,WOD,900

		if sidelightCutLeft then
			if curvedWall then
				startX = sidelightCutPosSillLeft
				startY = WOD - signWallIsLeft * sqr(radSill^2 - sidelightCutPosSillLeft^2)
				put sidelightCutPosSillLeft, WOD - signWallIsLeft * sqr(radSill^2 - sidelightCutPosSillLeft^2), 0
			else
				put sidelightCutPosSillLeft, leftRevealPnts[idxSillStartPlasterLeft][2], 0
			endif
			put sidelightCutPosSillLeft, 0, 0
		else
			if bLeftCornerFunction then
				put leftRevealPnts[idxSillStartPlasterLeft][1],	leftRevealPnts[idxSillStartPlasterLeft][2] + (bNeedToOffsetSkins & not(bUsePolygonOperations)) * offsetSill, 0,
					leftRevealPnts[idxSillEndPlasterLeft][1],	leftRevealPnts[idxSillEndPlasterLeft][2], 0
			else
				if bNeedToOffsetSkins & not(bUsePolygonOperations) then
					idx = idxSillStartPlasterLeft
					if curvedWall then
						if bParalellInCurvedWalls then
							R = radSill - offsetSill * signWallIsLeft
							startX = leftRevealPnts[idx][1]
							startY = -signWallIsLeft * sqr(R^2 - startX^2) + WOD
						else
							alpha = abs(asn(leftRevealPnts[idx][1] / radSill))
							startX = -(radSill - signWallIsLeft * offsetSill) * sin(alpha)
							startY = -signWallIsLeft * (radSill - signWallIsLeft * offsetSill) * cos(alpha) + WOD
						endif
					else
						startX = leftRevealPnts[idx][1]
						startY = leftRevealPnts[idx][2] + offsetSill
					endif

					put startX, startY, 0
					for i=idxSillStartPlasterLeft + 1 to idxSillEndPlasterLeft
						put leftRevealPnts[i][1], leftRevealPnts[i][2], 0
					next i
				else
					startX = leftRevealPnts[idxSillStartPlasterLeft][1]
					startY = leftRevealPnts[idxSillStartPlasterLeft][2]

					for i=idxSillStartPlasterLeft to idxSillEndPlasterLeft
						put leftRevealPnts[i][1], leftRevealPnts[i][2], 0
					next i
				endif
			endif
		endif

		if sidelightCutRight then
			put	sidelightCutPosSillRight,	0, 0
			if curvedWall then
				put sidelightCutPosSillRight, WOD - signWallIsLeft * sqr(radSill^2 - sidelightCutPosSillRight^2), 0
			else
				put sidelightCutPosSillRight, rightRevealPnts[idxSillStartPlasterRight][2], 0
			endif
		else
			if bRightCornerFunction then
				put rightRevealPnts[idxSillEndPlasterRight][1],		rightRevealPnts[idxSillEndPlasterRight][2], 0,
					rightRevealPnts[idxSillStartPlasterRight][1],	rightRevealPnts[idxSillStartPlasterRight][2] + (bNeedToOffsetSkins & not(bUsePolygonOperations)) * offsetSill, 0
			else
				if bNeedToOffsetSkins & not(bUsePolygonOperations) then
					for i = idxSillEndPlasterRight to idxSillStartPlasterRight + 1 step -1
						put rightRevealPnts[i][1], rightRevealPnts[i][2]
						if curvedWall & gs_IsCurved & i = idxSillEndPlasterRight then
							put 3000
						else
							put 0
						endif
					next i

					idx = idxSillStartPlasterRight
					if curvedWall then
						if bParalellInCurvedWalls then
							R = radSill - offsetSill * signWallIsLeft
							put rightRevealPnts[idx][1], -signWallIsLeft * sqr(R^2 - rightRevealPnts[idx][1]^2) + WOD, 0
						else
							alpha = abs(asn(rightRevealPnts[idx][1] / radSill))
							put  (radSill - signWallIsLeft * offsetSill) * sin(alpha),
								-signWallIsLeft * (radSill - signWallIsLeft * offsetSill) * cos(alpha) + WOD, 0
						endif
					else
						put rightRevealPnts[idx][1], rightRevealPnts[idx][2] + offsetSill, 0
					endif
				else
					for i = idxSillEndPlasterRight to idxSillStartPlasterRight step -1
						put rightRevealPnts[i][1], rightRevealPnts[i][2]
						if curvedWall & gs_IsCurved & i = idxSillEndPlasterRight then
							put 3000
						else
							put 0
						endif
					next i
				endif
			endif
		endif

		if curvedWall then
			put startX, startY, 3000
		endif
	endif

	if bUsePolygonOperations then

		ch = initaddonscope ("PolyOperations", "", "")

		preparefunction ch, "CreateContainer", "mySourceContainer", ""
		preparefunction ch, "CreateContainer", "myDestinationContainer", ""

		preparefunction ch, "SetSourceContainer",	 	"mySourceContainer", ""
		preparefunction ch, "SetDestinationContainer",	"myDestinationContainer", ""

! Store wallhole polygon -------------------------------------------------------

		dim vertArr1[][3]
		dim inhEdgeInfos1[]
		defaultInhEdgeInfo = 0

		if AC_WallType = 2 then

			if sidelightCutLeft then
				put sidelightCutPosSillLeft, leftRevealPnts[idxSillStartPlasterLeft][2],  2 * (sidelightCutLeft = 1),
					sidelightCutPosSillLeft, 0,	-1
			else
				bHasAnySillPoint = 0
				for i=idxSillStartRevealLeft to idxSillEndRevealLeft
					if leftRevealPnts[i][2] <= 0 then
						distFromLast = abs((leftRevealPnts[i][1] - lastSillPointX)^2 + (leftRevealPnts[i][2] - lastSillPointY)^2)
						if not(bHasAnySillPoint) | distFromLast > EPS then
							if bHasAnySillPoint then
								put not(gs_stack_left)	! status of the previous point
							endif
							put leftRevealPnts[i][1], leftRevealPnts[i][2]
							lastSillPointX = leftRevealPnts[i][1]
							lastSillPointY = leftRevealPnts[i][2]
							bHasAnySillPoint = 1
						endif
					endif
				next i
				if bHasAnySillPoint then
					put -1	! last status
				endif
			endif

			if sidelightCutRight then
				put	sidelightCutPosSillRight, 0, 2 * (sidelightCutRight = 1),
					sidelightCutPosSillRight, rightRevealPnts[idxSillStartPlasterRight][2], -1
			else
				bHasAnySillPoint = 0
				for i = idxSillEndRevealRight to idxSillStartRevealRight step -1
					if rightRevealPnts[i][2] <= 0 then
						distFromLast = abs((rightRevealPnts[i][1] - lastSillPointX)^2 + (rightRevealPnts[i][2] - lastSillPointY)^2)
						if not(bHasAnySillPoint) | distFromLast > EPS then
							if bHasAnySillPoint then
								put not(gs_stack_right)	! status of the previous point
							endif
							put rightRevealPnts[i][1], rightRevealPnts[i][2]
							lastSillPointX = rightRevealPnts[i][1]
							lastSillPointY = rightRevealPnts[i][2]
							bHasAnySillPoint = 1
						endif
					endif
				next i
				if bHasAnySillPoint then
					put -1	! last status
				endif
			endif

			nVertices1 = nsp/3
			for i=1 to nVertices1
				vertarr1[i][1]	 = get(1)
				vertarr1[i][2]	 = get(1)
				vertarr1[i][3]	 = 0
				inhEdgeInfos1[i] = get(1)	! Mark wallhole edges
			next i
		else

			idx = 1
			inhEdgeInfosLast = 0

			for i=1 to nsp/3
				px = get(1)
				py = get(1)
				ps = round_int (get(1))

				if idx > 1 then
					bSkipThisVertex = (abs(px - vertarr1[1][1]) < EPS & abs(py - vertarr1[1][2]) < EPS)	! Skip this vertex if this is a closing one
				else
					bSkipThisVertex = 0
				endif

				if ps < 900 | ps >= 1000 then	! Skip state '900'
					if not(bSkipThisVertex) then
						vertarr1[idx][1] = px
						vertarr1[idx][2] = py
					endif
					if ps >= 3000 & ps < 4000 then
						if idx > 1 then
							vx = vertarr1[idx-1][1] - 0
							vy = vertarr1[idx-1][2] - WOD
							gosub 103	! Direction Angle
							savedAngle = angle

							vx = px - 0
							vy = py - WOD
							gosub 103	! Direction Angle

							vertarr1[idx-1][3] = angle - savedAngle
							if not(bSkipThisVertex) then
								inhEdgeInfos1[idx] = bittest(ps, 0)
							endif
						endif
					else
						if not(bSkipThisVertex) then
							vertarr1[idx][3] = 0
							inhEdgeInfos1[idx] = bittest(ps, 0)
						endif
					endif
					if not(bSkipThisVertex) then
						idx = idx + 1
					endif
				endif
			next i
			nVertices1 = vardim1(vertarr1)
		endif

		nContours1 = 1
		dim contArr1[]
		contArr1[1] = nVertices1 + 1

		if nVertices1 >= 2 then
			preparefunction ch, "Store", "wallHolePoly", nVertices1, nContours1, vertArr1, contArr1, defaultInhEdgeInfo, inhEdgeInfos1
		endif

		prevSourceContainer	= ""
		lastDestContainer	= "mySourceContainer"
		preparefunction ch, "SetDestinationContainer", lastDestContainer, ""

!!!ccc = 0
!!!for i=1 to vardim1(vertarr1)
!!!	ccc = ccc + 0.002
!!!	circle2 vertarr1[i][1], vertarr1[i][2], ccc
!!!next i

! Offset sill side edge --------------------------------------------------------

		if AC_WallType = 2 then
			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer1"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			preparefunction ch, "OffsetParams", "", 1, 0.50

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

			dim tempResPolyIDArr[]
			for i=1 to numPoly
				tempNumPoly = callfunction (ch, "OffsetEdge", srcPolyIDArr[i], tempResPolyIDArr)
			next i

!!!dim resPolyIDArr[]
!!!numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!for i = 1 to numPoly
!!!	polygonID = resPolyIDArr[i]
!!!	gosub 1000	! Get GDL Polygon
!!!
!!!	ccc=0
!!!	for j=1 to nsp/3
!!!		xx=get(1)
!!!		yy=get(1)
!!!		ss=get(1)
!!!		ccc=ccc+0.003
!!!		circle2 xx,yy,ccc
!!!		text2 xx,yy,j
!!!	next j
!!!next i
!!!end
		endif

! Store wall contour polygon in wallhole coordinate system ---------------------

		if AC_WallType = 2 then
			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer3"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			nVertices2 = vardim1(AC_WallContourPolygon)
			dim vertArr2[][3]

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

			defaultInhEdgeInfo = 0
			dim inhEdgeInfos2[]
!!!ccc=0
			for i=1 to nVertices2
				vertarr2[i][1] = AC_WallContourPolygon[i][1]
				if WIDO_REVEAL_SIDE then
					vertarr2[i][2] = AC_WallContourPolygon[i][2] + WIDO_FRAME_THICKNESS
					vertarr2[i][3] = AC_WallContourPolygon[i][3]
				else
					vertarr2[i][2] = -AC_WallContourPolygon[i][2]
					vertarr2[i][3] = -AC_WallContourPolygon[i][3]
				endif

				inhEdgeInfos2[i] = 2
!!!ccc=ccc+0.003
!!!circle2 vertarr2[i][1], vertarr2[i][2], ccc
!!!text2 vertarr2[i][1], vertarr2[i][2], i
			next i

			nContours2 = 1
			dim contArr2[]
			contArr2[1] = nVertices2 + 1

			preparefunction ch, "Store", "wallContourPoly", nVertices2, nContours2, vertArr2, contArr2, defaultInhEdgeInfo, inhEdgeInfos2

! Intersect polygons -----------------------------------------------------------

			dim tempResPolyIDArr[]
			for i = 1 to numPoly
				tempNumPoly = callfunction (ch, "wallContourPoly / " + srcPolyIDArr[i], "", tempResPolyIDArr)
			next i
		endif

! Regularize polygon(s) --------------------------------------------------------

		if curvedWall then

			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer1"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

			dim tempResPolyIDArr[]
			for i=1 to numPoly
				tempNumPoly = callfunction (ch, "Regularize", srcPolyIDArr[i], tempResPolyIDArr)
			next i


			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer2"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			preparefunction ch, "HalfPlaneParams", "", 0, 1, 0

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

			dim tempResPolyIDArr[]
			for i = 1 to numPoly
				tempNumPoly = callfunction (ch, "PolyCut", srcPolyIDArr[i], tempResPolyIDArr)
			next i
		endif

! Cut hidden wall skins polygon ------------------------------------------------

		if AC_WallType <> 2 then

			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer3"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

! Store hidden wall skins polygon ----------------------------------------------

			if curvedWall then
				pxL1 = -radSill - signWallIsLeft * 0.1
				pyL1 = WOD

				pxL2 = -radSill + signWallIsLeft * offsetSill
				pyL2 = WOD

				pxR1 = radSill + signWallIsLeft * 0.1
				pyR1 = WOD

				pxR2 = radSill - signWallIsLeft * offsetSill
				pyR2 = WOD
			else
				pxL1 = -leftWidth - 1.0
				pyL1 = -WIDO_SILL - 0.1

				pxL2 = pxL1
				pyL2 = -WIDO_SILL + offsetSill

				pxR1 = rightWidth + 1.0
				pyR1 = -WIDO_SILL - 0.1

				pxR2 = pxR1
				pyR2 = -WIDO_SILL + offsetSill
			endif

!!!text2 0,0.2, WALL_THICKNESS
!!!circle2 0,0, 0.01
!!!fill 1
!!!pen 1
!!!poly2_b 4, 1+2+4+64, 1,0,
!!!	pxL1, pyL1, 1,
!!!	pxL2, pyL2, 1,
!!!	pxR2, pyR2, 1,
!!!	pxR1, pyR1, 1
!!!fill wallholeFill
!!!end
			nVertices2 = 4
			dim vertArr2[][3]
			vertarr2[1][1] = pxL1
			vertarr2[1][2] = pyL1
			vertarr2[1][3] = 0

			vertarr2[2][1] = pxL2
			vertarr2[2][2] = pyL2
			vertarr2[2][3] = curvedWall * signWallIsLeft * (180)

			vertarr2[3][1] = pxR2
			vertarr2[3][2] = pyR2
			vertarr2[3][3] = 0

			vertarr2[4][1] = pxR1
			vertarr2[4][2] = pyR1
			vertarr2[4][3] = curvedWall * signWallIsLeft * (-180)

			nContours2 = 1
			dim contArr2[]
			contArr2[1] = nVertices2 + 1

			preparefunction ch, "Store", "wallSkinPoly", nVertices2, nContours2, vertArr2, contArr2

! Substract polygons -----------------------------------------------------------

			dim tempResPolyIDArr[]
			for i = 1 to numPoly
				tempNumPoly = callfunction(ch, srcPolyIDArr[i] + " - wallSkinPoly", "", tempResPolyIDArr)
			next i
		endif

! Draw resulting polygons ------------------------------------------------------

		dim resPolyIDArr[]
		numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)

		for i = 1 to numPoly
			polygonID = resPolyIDArr[i]
			gosub 1000	! Get GDL Polygon

			if _bValidPoly then
				if bDrawSillFill then
					fill wallholeFill
					if GLOB_CONTEXT = 5 then
						poly2_b nsp/3, 2+4+64, wallholePen_fg,wallholePen_bg,
							get(nsp)
					else
						wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
							0,0,0, get(nsp)
					endif
				else
					fill 0
					if GLOB_CONTEXT = 5 then
						poly2_b nsp/3, 2+4+64, 0,-1,
							get(nsp)
					else
						wallhole2 nsp/3, 2 + 64, 0,-1,
							0,0,0, get(nsp)
					endif
				endif
			endif
		next i

! Draw wall contour lines ------------------------------------------------------

		if AC_WallType = 2 then
			dim lineAttributes[2][4]
			lineAttributes[1][1] = WALL_SECT_PEN
			lineAttributes[1][2] = WALL_LINETYPE
			lineAttributes[1][3] = LINE_PROPERTY_CONTOUR
			lineAttributes[1][4] = bitset(0, LINE_ATTRIBUTES_WALLLINE)

			lineAttributes[2][1] = gs_wcont_line_pen * (wcontLineOut > 0)	! Outside, Both Sides
			lineAttributes[2][2] = wcontLineOut
			lineAttributes[2][3] = LINE_PROPERTY_GENERIC
			lineAttributes[2][4] = bitset(0, LINE_ATTRIBUTES_GDLLINE)

			bPutHotsopts	= (AC_WallType = 2)

			for i = 1 to numPoly
				polygonID = resPolyIDArr[i]
				gosub 1001	! Draw one polygon contour line
			next i
		endif

! Close channel ----------------------------------------------------------------

		closeaddonscope ch
	endif	! if bUsePolygonOperations then

! Draw polygons without polygon operations -------------------------------------

	if not(bUsePolygonOperations) then
		if bDrawSillFill then
			fill wallholeFill
			if GLOB_CONTEXT = 5 then
				poly2_b nsp/3, 2+4+64, wallholePen_fg,wallholePen_bg,
					get(nsp)
			else
				wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
					0,0,0, get(nsp)
			endif
		else
			fill 0
			if GLOB_CONTEXT = 5 then
				poly2_b nsp/3, 2+4+64, 0,-1,
					get(nsp)
			else
				wallhole2 nsp/3, 2 + 64, 0,-1,
					0,0,0, get(nsp)
			endif
		endif
	endif
return


! =============================================================================
! Draw Board side background fill and parapet contours
! =============================================================================

"DrawWallholeFillInside":

	if not(bUseOneBackgroundFill) | bVisibleWallInsetIn2D | bNeedToOffsetSkins then

! Draw Board Side Fill or Wallhole =============================================

		bAutoParapetInset = (gs_parapet_autodim)

		if AC_WallType = 2 then
			bUsePolygonOperations	= 1
			bCutWallInsetWithPolyOp	= bVisibleWallInsetIn2D
		else
			bUsePolygonOperations	= (offsetBoard > EPS)

			if curvedWall then put 0,WOD,900

			if curvedWall then
				insetY = WOD - signWallIsLeft * radBoard - parapetWallInsetDepth
			endif

			if sidelightCutLeft then
				put sidelightCutPosMiddleLeft,	0, 0
				if abs(sidelightCutPosMiddleLeft - sidelightCutPosBoardLeft) > EPS then
					put sidelightCutPosMiddleLeft,	WIDO_FRAME_THICKNESS, 0,
						sidelightCutPosBoardLeft,	WIDO_FRAME_THICKNESS, 0
				endif
				if curvedWall then
					put sidelightCutPosBoardLeft, WOD - signWallIsLeft * sqr(radBoard^2 - sidelightCutPosBoardLeft^2), 0
				else
					if bInclinedWall then
						put sidelightCutPosBoardLeft,
							leftRevealPnts[idxBoardEndPlasterLeft][2] + (leftRevealPnts[idxBoardEndPlasterLeft][1] - sidelightCutPosBoardLeft) * \
							(leftRevealPnts[idxBoardEndPlasterLeft][2] - rightRevealPnts[idxBoardEndPlasterRight][2]) / (-leftRevealPnts[idxBoardEndPlasterLeft][1] + rightRevealPnts[idxBoardEndPlasterRight][1]),
							0
					else
						put sidelightCutPosBoardLeft, leftRevealPnts[idxBoardEndPlasterLeft][2], 0
					endif
				endif
			else
				if bLeftCornerFunction then
					startPointIdx = idxFrameStartRevealLeft
					put leftRevealPnts[idxFrameStartRevealLeft][1], leftRevealPnts[idxFrameStartRevealLeft][2], 0
					if bVisibleWallInsetIn2D then
						put leftRevealPnts[idxBoardEndPlasterLeft][1] - parapetWallInsetDepth * lx, leftRevealPnts[idxBoardEndPlasterLeft][2] - parapetWallInsetDepth,  1
						if gs_reveal_hotspots then
							hotspot2 leftRevealPnts[idxBoardEndPlasterLeft][1] - parapetWallInsetDepth * lx,
									 leftRevealPnts[idxBoardEndPlasterLeft][2] - parapetWallInsetDepth,
									 11040
						endif
					else
						put leftRevealPnts[idxBoardEndPlasterLeft][1], leftRevealPnts[idxBoardEndPlasterLeft][2],  1
					endif
				else
					if bAutoParapetInset & bVisibleWallInsetIn2D then
						startPointIdx = idxFrameStartRevealLeft
						put leftRevealPnts[idxFrameStartRevealLeft][1],	leftRevealPnts[idxFrameStartRevealLeft][2], 0
						put leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2], 0
						for i = idxBoardStartPlasterLeft to idxBoardEndPlasterLeft - 1
							put leftRevealPnts[i][1], leftRevealPnts[i][2], 0
						next i

						idx = idxBoardEndPlasterLeft
						if not(gs_stack_left) & (iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC) then
							if curvedWall then
								pxInsetLeft	= leftRevealPnts[idx][1] + abs(leftRevealPnts[idx][2] - insetY) * tan(gs_reveal_left_angle)
								pyInsetLeft	= insetY
							else
								pxInsetLeft	= leftRevealPnts[idx][1] + parapetWallInsetDepth * sin(gs_reveal_left_angle)
								pyInsetLeft	= leftRevealPnts[idx][2] - parapetWallInsetDepth
							endif
						else
							if curvedWall then
								if bParalellInCurvedWalls then
									pxInsetLeft	= leftRevealPnts[idx][1]
									pyInsetLeft	= insetY
								else
									alpha = abs(asn(leftRevealPnts[idx][1] / radBoard))
									pxInsetLeft	= -abs(tan(alpha) * (WOD - insetY))
									pyInsetLeft	= insetY
								endif
							else
								pxInsetLeft	= leftRevealPnts[idx][1]
								pyInsetLeft	= leftRevealPnts[idx][2] - parapetWallInsetDepth
							endif
						endif
						if curvedWall & not(wallIsLeft) & pyInsetLeft > leftRevealPnts[idx][2] then
							pxInsetLeft	= leftRevealPnts[idx][1]
							pyInsetLeft	= leftRevealPnts[idx][2]
						endif

						if not(curvedWall) | wallIsLeft then
							if gs_reveal_hotspots then
								hotspot2 pxInsetLeft, pyInsetLeft, 11040
							endif
						endif

						put pxInsetLeft, pyInsetLeft, 1

						if curvedWall then
							if not(wallIsLeft) & insetY > pyInsetLeft + EPS then
								put -sqr(radBoard^2 - (insetY - WOD)^2), insetY, 3001
								if gs_reveal_hotspots then
									hotspot2 -sqr(radBoard^2 - (insetY - WOD)^2), insetY, 11040
								endif
							endif
						endif
					else
						if WIDO_FRAME_THICKNESS > EPS then
						startPointIdx = idxFrameStartRevealLeft
							put leftRevealPnts[idxFrameStartRevealLeft][1], leftRevealPnts[idxFrameStartRevealLeft][2], 0
							put leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2], 0
						else
							startPointIdx = idxBoardStartPlasterLeft
						endif
						for i = idxBoardStartPlasterLeft to idxBoardEndPlasterLeft
							put leftRevealPnts[i][1], leftRevealPnts[i][2], (i = idxBoardEndPlasterLeft & bUseOneBackgroundFill)
						next i
					endif
				endif
			endif

! Draw not full width wall inset recess -------------------------------------- [

			bCutWallInsetWithPolyOp = 0

			if not(bAutoParapetInset) & bVisibleWallInsetIn2D then
				cx = 0
				cy = WALL_THICKNESS - WIDO_SILL

				if curvedWall then
					if bParalellInCurvedWalls then
						pxL1 = cx - opInner / 2 - parapetExtendLeft
						pyL1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxL1^2)

						pxL2 = pxL1
						pyL2 = insetY

						pxR1 = cx + opInner / 2 + parapetExtendRight
						pyR1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxR1^2)

						pxR2 = pxR1
						pyR2 = insetY

						if parapet_width > leftWidth + rightWidth then
							bUsePolygonOperations	= 1	! Lets cut it with polygon operations
							bCutWallInsetWithPolyOp	= 1
						endif
					else
						pxL1 = cx - opInner / 2 - parapetExtendLeft
						pyL1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxL1^2)

						alpha = abs(asn(pxL1 / radBoard))
						pxL2 = pxL1 - signWallIsLeft * tan(alpha) * abs(pyL1 - insetY)
						pyL2 = insetY

						pxR1 = cx + opInner / 2 + parapetExtendRight
						pyR1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxR1^2)

						alpha = abs(asn(pxR1 / radBoard))
						pxR2 = pxR1 + signWallIsLeft * tan(alpha) * abs(pyR1 - insetY)
						pyR2 = insetY

						if wallIsLeft | (bParapetWallInset & not(bAutoParapetInset)) then
							bUsePolygonOperations	= 1	! Lets cut it with polygon operations
							bCutWallInsetWithPolyOp	= 1
						endif
					endif

					if gs_reveal_hotspots then	! Show wall inset hotspot
						if pyL1 > pyL2 then
							hotspot2 pxL2, pyL2, 11040
							hotspot2 pxL1, pyL1, 11042
						else
							hotspot2 -sqr(radBoard^2 - (insetY - WOD)^2), insetY, 11040
						endif

						if pyR1 > pyR2 then
							hotspot2 pxR2, pyR2, 11041
							hotspot2 pxR1, pyR1, 11043
						else
							hotspot2 sqr(radBoard^2 - (insetY - WOD)^2), insetY, 11041
						endif
					endif

					if not(bCutWallInsetWithPolyOp) then
						if pyL1 > pyL2 then
							put pxL1, pyL1, 3001,
								pxL2, pyL2, 1
						else
							put -sqr(radBoard^2 - (insetY - WOD)^2), insetY, 3001
						endif
						if pyR1 > pyR2 then
							put pxR2, pyR2, 1,
								pxR1, pyR1, 1
							if gs_reveal_hotspots then	! Show wall inset hotspot
								hotspot2 pxR2, pyR2, 11041
								hotspot2 pxR1, pyR1, 11043
							endif
						else
							put sqr(radBoard^2 - (insetY - WOD)^2), insetY, 1
							if gs_reveal_hotspots then	! Show wall inset hotspot
								hotspot2 sqr(radBoard^2 - (insetY - WOD)^2), insetY, 11041
							endif
						endif
					endif
				else
					if bInclinedWall then
						pxL1 = -leftWidth  - overSizeLeft - revYL - parapetExtendLeft * cos(WALL_INCL)
						pyL1 = WALL_THICKNESS - WIDO_SILL - py2p

						pxL2 = pxL1 + parapetWallInsetDepth * incV
						pyL2 = pyL1 - parapetWallInsetDepth * incH

						pxR1 = rightWidth + overSizeRight + revYR + parapetExtendRight * cos(WALL_INCL)
						pyR1 = WALL_THICKNESS - WIDO_SILL - py1p

						pxR2 = pxR1 + parapetWallInsetDepth * incV
						pyR2 = pyR1 - parapetWallInsetDepth * incH
					else
						pxL1 = cx - opInner / 2 - parapetExtendLeft
						pyL1 = cy

						pxL2 = pxL1
						pyL2 = pyL1 - parapetWallInsetDepth

						pxR1 = cx + opInner / 2 + parapetExtendRight
						pyR1 = cy

						pxR2 = pxR1
						pyR2 = pyR1 - parapetWallInsetDepth
					endif

					if parapet_width > leftWidth + rightWidth then
						bUsePolygonOperations	= 1	! Lets cut it with polygon operations
						bCutWallInsetWithPolyOp	= 1
					endif

					if not(bLeftCornerFunction) then
						if not(bCutWallInsetWithPolyOp) then
							put pxL1, pyL1, 1,
								pxL2, pyL2, 1
						endif
						if gs_reveal_hotspots then	! Show wall inset hotspot
							hotspot2 pxL2, pyL2, 11040
							hotspot2 pxL1, pyL1, 11042
						endif
					endif
					if not(bRightCornerFunction) then
						if not(bCutWallInsetWithPolyOp) then
							put pxR2, pyR2, 1,
								pxR1, pyR1, 1
						endif
						if gs_reveal_hotspots then	! Show wall inset hotspot
							hotspot2 pxR2, pyR2, 11041
							hotspot2 pxR1, pyR1, 11043
						endif
					endif
				endif

!!!circle2 pxL1, pyL1, 0.005
!!!circle2 pxL2, pyL2, 0.010
!!!circle2 pxR2, pyR2, 0.015
!!!circle2 pxR1, pyR1, 0.020

			endif

! ] Draw not full width wall inset recess --------------------------------------

			if sidelightCutRight then
				if curvedWall then
					put sidelightCutPosBoardRight, WOD - signWallIsLeft * sqr(radBoard^2 - sidelightCutPosBoardRight^2), 3000
				else
					if bInclinedWall then
						put sidelightCutPosBoardRight,
							rightRevealPnts[idxBoardEndPlasterRight][2] + (rightRevealPnts[idxBoardEndPlasterRight][1] - sidelightCutPosBoardRight) * \
							(leftRevealPnts[idxBoardEndPlasterLeft][2] - rightRevealPnts[idxBoardEndPlasterRight][2]) / (-leftRevealPnts[idxBoardEndPlasterLeft][1] + rightRevealPnts[idxBoardEndPlasterRight][1]),
							0
					else
						put sidelightCutPosBoardRight, rightRevealPnts[idxBoardEndPlasterRight][2], 0
					endif
				endif
				if abs(sidelightCutPosBoardRight - sidelightCutPosMiddleRight) > EPS then
					put sidelightCutPosBoardRight,	WIDO_FRAME_THICKNESS, 0,
						sidelightCutPosMiddleRight,	WIDO_FRAME_THICKNESS, 0
				endif
				put sidelightCutPosMiddleRight,	0, 0
			else
				if bRightCornerFunction then
					if bVisibleWallInsetIn2D then
						put rightRevealPnts[idxBoardEndPlasterRight][1] + parapetWallInsetDepth * rx, rightRevealPnts[idxBoardEndPlasterRight][2] - parapetWallInsetDepth,  0
						put rightRevealPnts[idxBoardEndPlasterRight][1] + parapetWallInsetDepth * rx, rightRevealPnts[idxBoardEndPlasterRight][2] - parapetWallInsetDepth,  0

						if gs_reveal_hotspots then
							hotspot2 rightRevealPnts[idxBoardEndPlasterRight][1] + parapetWallInsetDepth * rx,
									 rightRevealPnts[idxBoardEndPlasterRight][2] - parapetWallInsetDepth,
									 11041
						endif
					else
						put rightRevealPnts[idxBoardEndPlasterRight][1], rightRevealPnts[idxBoardEndPlasterRight][2],  0
					endif
					put rightRevealPnts[idxFrameStartRevealRight][1], rightRevealPnts[idxFrameStartRevealRight][2], 0
				else
					if bAutoParapetInset & bVisibleWallInsetIn2D then
						idx = idxBoardEndPlasterRight
						psInsetRight = 0

						if not(gs_stack_right) & (iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC) then
							if curvedWall then
								pxInsetRight	= rightRevealPnts[idx][1] - abs(rightRevealPnts[idx][2] - insetY) * tan(gs_reveal_right_angle)
								pyInsetRight	= insetY
							else
								pxInsetRight	= rightRevealPnts[idx][1] - parapetWallInsetDepth * sin(gs_reveal_right_angle)
								pyInsetRight	= rightRevealPnts[idx][2] - parapetWallInsetDepth
							endif
						else
							if curvedWall then
								if bParalellInCurvedWalls then
									alpha = abs(asn(rightRevealPnts[idx][1] / radBoard))
									pxInsetRight	= rightRevealPnts[idx][1]
									pyInsetRight	= insetY
								else
									alpha = abs(asn(rightRevealPnts[idx][1] / radBoard))
									pxInsetRight	= abs(tan(alpha) * (WOD - insetY))
									pyInsetRight	= insetY
								endif
							else
								pxInsetRight	= rightRevealPnts[idx][1]
								pyInsetRight	= rightRevealPnts[idx][2] - parapetWallInsetDepth
							endif
						endif
						if curvedWall & not(wallIsLeft) & pyInsetRight > rightRevealPnts[idx][2] then
							pxInsetRight	= rightRevealPnts[idx][1]
							pyInsetRight	= rightRevealPnts[idx][2]
						endif

						if not(curvedWall) | wallIsLeft then
							if gs_reveal_hotspots then
								hotspot2 pxInsetRight, pyInsetRight, 11041
							endif
						endif

						if curvedWall then
							if not(wallIsLeft) & insetY > pyInsetRight + EPS then
								put sqr(radBoard^2 - (insetY - WOD)^2), insetY, 1
								psInsetRight = 3000
								if gs_reveal_hotspots then
									hotspot2 sqr(radBoard^2 - (insetY - WOD)^2), insetY, 11041
								endif
							endif
						endif

						put pxInsetRight, pyInsetRight, psInsetRight

						for i = idxBoardEndPlasterRight - 1 to idxBoardStartPlasterRight step -1
							put rightRevealPnts[i][1], rightRevealPnts[i][2], 0
						next i
						put rightRevealPnts[idxFrameEndRevealRight][1],		rightRevealPnts[idxFrameEndRevealRight][2], 0
						put rightRevealPnts[idxFrameStartRevealRight][1],	rightRevealPnts[idxFrameStartRevealRight][2], 0
					else
						for i = idxBoardEndPlasterRight to idxBoardStartPlasterRight step -1
							put rightRevealPnts[i][1], rightRevealPnts[i][2]
							if curvedWall & i = idxBoardEndPlasterRight then
								put 3000
							else
								put 0
							endif
						next i
						if WIDO_FRAME_THICKNESS > EPS then
							put rightRevealPnts[idxFrameEndRevealRight][1],		rightRevealPnts[idxFrameEndRevealRight][2], 0
							put rightRevealPnts[idxFrameStartRevealRight][1],	rightRevealPnts[idxFrameStartRevealRight][2], 0
						endif
					endif
				endif
			endif

			if curvedWall & gs_IsCurved then
				put leftRevealPnts[startPointIdx][1], leftRevealPnts[startPointIdx][2], 3000
			endif
		endif	! if not(AC_WallType = 2) then

		if bUsePolygonOperations then
			! If there is hidden wall skins because of actual partial structure display settings
			! If we have custom size wall inset in curved wall

			ch = initaddonscope ("PolyOperations", "", "")

			preparefunction ch, "CreateContainer",	 "mySourceContainer", ""
			preparefunction ch, "SetSourceContainer", "mySourceContainer", ""

! Store original wallhole polygon ----------------------------------------------

			dim vertArr1[][3]

			defaultInhEdgeInfo = -1
			dim inhEdgeInfos1[]

			if AC_WallType = 2 then

				if sidelightCutLeft then
					put sidelightCutPosMiddleLeft,	0, 0
					if abs(sidelightCutPosSillLeft - sidelightCutPosMiddleLeft) > EPS then
						put	sidelightCutPosMiddleLeft,	0, 0
					endif
					if abs(sidelightCutPosMiddleLeft - sidelightCutPosBoardLeft) > EPS then
						put sidelightCutPosMiddleLeft,	WIDO_FRAME_THICKNESS, 0
					endif
					put	sidelightCutPosBoardLeft, WIDO_FRAME_THICKNESS, 2 * (sidelightCutLeft = 1),
						sidelightCutPosBoardLeft, leftRevealPnts[idxBoardEndPlasterLeft][2], -1
				else
					put leftRevealPnts[idxFrameStartRevealLeft][1],	leftRevealPnts[idxFrameStartRevealLeft][2],	not(gs_stack_left)
					put leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2]

					lastBoardPointX = leftRevealPnts[idxFrameEndRevealLeft][1]
					lastBoardPointY = leftRevealPnts[idxFrameEndRevealLeft][2]
					for i=idxBoardStartRevealLeft to idxBoardEndRevealLeft
						if leftRevealPnts[i][2] >= WIDO_FRAME_THICKNESS then
							distFromLast = abs((leftRevealPnts[i][1] - lastBoardPointX)^2 + (leftRevealPnts[i][2] - lastBoardPointY)^2)
							if distFromLast > EPS then
								put not(gs_stack_left)	! previous pont status
								put leftRevealPnts[i][1], leftRevealPnts[i][2]
								lastBoardPointX = leftRevealPnts[i][1]
								lastBoardPointY = leftRevealPnts[i][2]
								bHasAnyBoardPoint = 1
							endif
						endif
					next i
					put -1	! last pont status
				endif

				if sidelightCutRight then
					put sidelightCutPosBoardRight, rightRevealPnts[idxBoardEndPlasterRight][2], 2 * (sidelightCutRight = 1),
						sidelightCutPosBoardRight,	WIDO_FRAME_THICKNESS, 0
					if abs(sidelightCutPosBoardRight - sidelightCutPosMiddleRight) > EPS then
						put	sidelightCutPosMiddleRight,	WIDO_FRAME_THICKNESS, 0
					endif
					if abs(sidelightCutPosMiddleRight - sidelightCutPosSillRight) > EPS then
						put sidelightCutPosMiddleRight,	0, 0
					endif
					put sidelightCutPosMiddleRight,	0, 0
				else
					bHasAnyBoardPoint = 0
					for i = idxBoardEndRevealRight to idxBoardStartRevealRight step -1
						if rightRevealPnts[i][2] >= WIDO_FRAME_THICKNESS then
							distFromLast = abs((rightRevealPnts[i][1] - lastBoardPointX)^2 + (rightRevealPnts[i][2] - lastBoardPointY)^2)
							if not(bHasAnyBoardPoint) | distFromLast > EPS then
								put rightRevealPnts[i][1], rightRevealPnts[i][2], not(gs_stack_right)
								lastBoardPointX = rightRevealPnts[i][1]
								lastBoardPointY = rightRevealPnts[i][2]
								bHasAnyBoardPoint = 1
							endif
						endif
					next i
					if idxBoardStartRevealRight <> idxFrameEndRevealRight then
						put rightRevealPnts[idxFrameEndRevealRight][1],	rightRevealPnts[idxFrameEndRevealRight][2],	not(gs_stack_right)
					endif
					put rightRevealPnts[idxFrameStartRevealRight][1],rightRevealPnts[idxFrameStartRevealRight][2],	0
				endif

				nVertices1 = nsp/3
				for i=1 to nVertices1
					vertarr1[i][1]	 = get(1)
					vertarr1[i][2]	 = get(1)
					vertarr1[i][3]	 = 0
					inhEdgeInfos1[i] = get(1)	! Mark wallhole edges
				next i
			else

				idx = 1
				inhEdgeInfosLast = 0

				for i=1 to nsp/3
					px = get(1)
					py = get(1)
					ps = round_int (get(1))

					if idx > 1 then
						bSkipThisVertex = (abs(px - vertarr1[1][1]) < EPS & abs(py - vertarr1[1][2]) < EPS)	! Skip this vertex if this is a closing one
						if not(bSkipThisVertex) then
							bSkipThisVertex = (abs(px - vertarr1[idx-1][1]) < EPS & abs(py - vertarr1[idx-1][2]) < EPS)
						endif
					else
						bSkipThisVertex = 0
					endif

					if ps < 900 | ps >= 1000 then	! Skip state '900'
						if not(bSkipThisVertex) then
							vertarr1[idx][1] = px
							vertarr1[idx][2] = py
						endif
						if ps >= 3000 & ps < 4000 then
							if idx > 1 then
								vx = vertarr1[idx-1][1] - 0
								vy = vertarr1[idx-1][2] - WOD
								gosub 103	! Direction Angle
								savedAngle = angle

								vx = px - 0
								vy = py - WOD
								gosub 103	! Direction Angle

								vertarr1[idx-1][3] = angle - savedAngle
								if not(bSkipThisVertex) then
									inhEdgeInfos1[idx] = 2 * bittest(ps, 0)
								endif
							endif
						else
							if not(bSkipThisVertex) then
								vertarr1[idx][3] = 0
								inhEdgeInfos1[idx] = 2 * bittest(ps, 0)
							endif
						endif
						if not(bSkipThisVertex) then
							idx = idx + 1
						endif
					endif
				next i
				nVertices1 = vardim1(vertarr1)
			endif	! if not(AC_WallType = 2) then

			nContours1 = 1
			dim contArr1[]
			contArr1[1] = nVertices1 + 1

			if nVertices1 >= 2 then
				preparefunction ch, "Store", "poly1", nVertices1, nContours1, vertArr1, contArr1, defaultInhEdgeInfo, inhEdgeInfos1
			endif

			prevSourceContainer	= ""
			lastDestContainer	= "mySourceContainer"
			preparefunction ch, "SetDestinationContainer", lastDestContainer, ""

! Offset board side edge -------------------------------------------------------

			if AC_WallType = 2 then
				dim dstPolyIDArr[]
				numPoly = callfunction (ch, "GetDestinationPolygons", "", dstPolyIDArr)

				dim edgeIds[]
				edgeIds[numPoly] = 0
				for i=1 to numPoly

					dim inhEdgeInfos[]
					numEdges = callfunction(ch, "GetInhEdgeInfos", dstPolyIDArr[i], inhEdgeInfos)

					for j=1 to numEdges
						if inhEdgeInfos[j] = -1 then edgeIds[i] = j
					next j
				next i

				if prevSourceContainer <> "" then
					preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
				endif
				preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
				prevSourceContainer	= lastDestContainer
				lastDestContainer	= "myDestContainer2"
				preparefunction ch, "CreateContainer",			lastDestContainer, ""
				preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

				dim srcPolyIDArr[]
				numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

				dim tempResPolyIDArr[]
				for i=1 to numPoly

					preparefunction ch, "OffsetParams", "", edgeIds[i], 0.50

					tempNumPoly = callfunction (ch, "OffsetEdge", srcPolyIDArr[i], tempResPolyIDArr)
				next i

!!!dim resPolyIDArr[]
!!!numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!for i = 1 to numPoly
!!!	polygonID = resPolyIDArr[i]
!!!	gosub 1000	! Get GDL Polygon
!!!
!!!	ccc=0
!!!	for j=1 to nsp/3
!!!		xx=get(1)
!!!		yy=get(1)
!!!		ss=get(1)
!!!		ccc=ccc+0.003
!!!		circle2 xx,yy,ccc
!!!		text2 xx,yy,j
!!!	next j
!!!next i
!!!end
			endif	! if AC_WallType = 2 then

! Regularize polygon(s) - avoid generating invalid polygons --------------------

			if curvedWall | WIDO_SILL + WIDO_FRAME_THICKNESS >= WALL_THICKNESS | bVisibleWallInsetIn2D | abs(WIDO_FRAME_THICKNESS) < EPS then

				if prevSourceContainer <> "" then
					preparefunction ch, "DeleteContainer",			prevSourceContainer, ""
				endif
				preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
				prevSourceContainer	= lastDestContainer
				lastDestContainer	= "myDestContainer1"
				preparefunction ch, "CreateContainer",			lastDestContainer, ""
				preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

				dim srcPolyIDArr[]
				numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

				dim tempResPolyIDArr[]
				for i=1 to numPoly
					tempNumPoly = callfunction (ch, "Regularize", srcPolyIDArr[i], tempResPolyIDArr)
				next i
			endif

			if curvedWall then

				if prevSourceContainer <> "" then
					preparefunction ch, "DeleteContainer",			prevSourceContainer, ""
				endif
				preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
				prevSourceContainer	= lastDestContainer
				lastDestContainer	= "myDestContainer2"
				preparefunction ch, "CreateContainer",			lastDestContainer, ""
				preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

				preparefunction ch, "HalfPlaneParams", "", 0, -1, 0

				dim srcPolyIDArr[]
				numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

				dim tempResPolyIDArr[]
				for i = 1 to numPoly
					tempNumPoly = callfunction (ch, "PolyCut", srcPolyIDArr[i], tempResPolyIDArr)
				next i
			endif

!!!	dim resPolyIDArr[]
!!!	numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!	text2 0,0, numPoly
!!!
!!!	for i = 1 to numPoly
!!!		polygonID = resPolyIDArr[i]
!!!		gosub 1000	! Get GDL Polygon
!!!
!!!		if bDrawBoardFill then
!!!			fill wallholeFill
!!!			wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
!!!				0,0,0, get(nsp)
!!!		else
!!!			fill 0
!!!			wallhole2 nsp/3, 2 + 64, 0,-1,
!!!				0,0,0, get(nsp)
!!!		endif
!!!	next i
!!!end

!!!ccc = 0
!!!for i=1 to vardim1(vertarr1)
!!!	ccc = ccc + 0.002
!!!	circle2 vertarr1[i][1], vertarr1[i][2], ccc
!!!next i


! Cut hidden wall skins polygon ------------------------------------------------

			if (offsetBoard > EPS) then

				if prevSourceContainer <> "" then
					preparefunction ch, "DeleteContainer",			prevSourceContainer, ""
				endif
				preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
				prevSourceContainer	= lastDestContainer
				lastDestContainer	= "myDestContainer3"
				preparefunction ch, "CreateContainer",			lastDestContainer, ""
				preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

				dim srcPolyIDArr[]
				numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

! Store hidden wall skins polygon ----------------------------------------------

				if curvedWall then
					pxL1 = -radBoard + signWallIsLeft * 0.1
					pyL1 = WOD

					pxL2 = -radBoard - signWallIsLeft * offsetBoard
					pyL2 = WOD

					pxR1 = radBoard - signWallIsLeft * 0.1
					pyR1 = WOD

					pxR2 = radBoard + signWallIsLeft * offsetBoard
					pyR2 = WOD
				else
					if bInclinedWall then
						pxL1 = -leftWidth - 1.0
						pyL1 = WALL_THICKNESS - WIDO_SILL + pxL1 * incX + 0.1

						pxL2 = pxL1
						pyL2 = WALL_THICKNESS - WIDO_SILL - offsetBoard * incFactor * incY + pxL2 * incX

						pxR1 = rightWidth + 1.0
						pyR1 = WALL_THICKNESS - WIDO_SILL + pxR1 * incX + 0.1

						pxR2 = pxR1
						pyR2 = WALL_THICKNESS - WIDO_SILL - offsetBoard * incFactor * incY + pxR2 * incX
					else
						pxL1 = -leftWidth - 1.0
						pyL1 = WALL_THICKNESS - WIDO_SILL + 0.1

						pxL2 = pxL1
						pyL2 = WALL_THICKNESS - WIDO_SILL - offsetBoard

						pxR1 = rightWidth + 1.0
						pyR1 = WALL_THICKNESS - WIDO_SILL + 0.1

						pxR2 = pxR1
						pyR2 = WALL_THICKNESS - WIDO_SILL - offsetBoard
					endif
				endif

!!!text2 0,0.2, WALL_THICKNESS
!!!circle2 0,0, 0.01
!!!fill 1
!!!pen 1
!!!poly2_b 4, 1+2+4+64, 1,0,
!!!	pxL1, pyL1, 1,
!!!	pxL2, pyL2, 1,
!!!	pxR2, pyR2, 1,
!!!	pxR1, pyR1, 1
!!!fill wallholeFill

				nVertices2 = 4
				dim vertArr2[][3]

				defaultInhEdgeInfo = -1
				dim inhEdgeInfos2[]

				vertarr2[1][1] = pxL1
				vertarr2[1][2] = pyL1
				vertarr2[1][3] = 0
				inhEdgeInfos2[1] = 2

				vertarr2[2][1] = pxL2
				vertarr2[2][2] = pyL2
				vertarr2[2][3] = curvedWall * signWallIsLeft * 180
				inhEdgeInfos2[2] = 2

				vertarr2[3][1] = pxR2
				vertarr2[3][2] = pyR2
				vertarr2[3][3] = 0
				inhEdgeInfos2[3] = 2

				vertarr2[4][1] = pxR1
				vertarr2[4][2] = pyR1
				vertarr2[4][3] = curvedWall * signWallIsLeft * (-180)
				inhEdgeInfos2[4] = 2

				nContours2 = 1
				dim contArr2[]
				contArr2[1] = nVertices2 + 1

				preparefunction ch, "Store", "poly2", nVertices2, nContours2, vertArr2, contArr2, defaultInhEdgeInfo, inhEdgeInfos2

! Substract polygons -----------------------------------------------------------

				dim tempResPolyIDArr[]
				for i = 1 to numPoly
					tempNumPoly = callfunction(ch, srcPolyIDArr[i] + " - poly2", "", tempResPolyIDArr)
				next i
			endif


!!!	dim resPolyIDArr[]
!!!	numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!	text2 0,0, numPoly
!!!
!!!	for i = 1 to numPoly
!!!		polygonID = resPolyIDArr[i]
!!!		gosub 1000	! Get GDL Polygon
!!!
!!!		if bDrawBoardFill then
!!!			fill wallholeFill
!!!			wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
!!!				0,0,0, get(nsp)
!!!		else
!!!			fill 0
!!!			wallhole2 nsp/3, 2 + 64, 0,-1,
!!!				0,0,0, get(nsp)
!!!		endif
!!!	next i
!!!end


! Store wall inset polygon -----------------------------------------------------

			if bCutWallInsetWithPolyOp then

				if prevSourceContainer <> "" then
					preparefunction ch, "DeleteContainer",			prevSourceContainer, ""
				endif
				preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
				prevSourceContainer	= lastDestContainer
				lastDestContainer	= "myDestContainer4"
				preparefunction ch, "CreateContainer",			lastDestContainer, ""
				preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

				dim srcPolyIDArr[]
				numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

				if curvedWall then
					if bParalellInCurvedWalls then
						pxL1 = cx - opInner / 2 - parapetExtendLeft
						pyL1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxL1^2)

						pxL2 = pxL1
						pyL2 = insetY

						pxR1 = cx + opInner / 2 + parapetExtendRight
						pyR1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxR1^2)

						pxR2 = pxR1
						pyR2 = insetY
					else
						pxL1 = cx - opInner / 2 - parapetExtendLeft
						pyL1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxL1^2)

						alpha = abs(asn(pxL1 / radBoard))
						pxL2 = pxL1 - signWallIsLeft * tan(alpha) * abs(pyL1 - insetY)
						pyL2 = insetY

						pxR1 = cx + opInner / 2 + parapetExtendRight
						pyR1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxR1^2)

						alpha = abs(asn(pxR1 / radBoard))
						pxR2 = pxR1 + signWallIsLeft * tan(alpha) * abs(pyR1 - insetY)
						pyR2 = insetY

						if not(wallIsLeft) then
							if pyL1 < pyL2 then
								pxL2 = -sqr(radBoard^2 - (insetY - WOD)^2)
								pyL2 = insetY

								pxL1 = pxL2
								pyL1 = pyL2
							endif
							if pyR1 < pyR2 then
								pxR2 = sqr(radBoard^2 - (insetY - WOD)^2)
								pyR2 = insetY

								pxR1 = pxR2
								pyR1 = pyR2
							endif
						endif
					endif
				else
					if bInclinedWall then
						pxL1 = -leftWidth  - overSizeLeft - revYL - parapetExtendLeft * incH
						pyL1 = WALL_THICKNESS - WIDO_SILL - py2p

						pxL2 = pxL1 + parapetWallInsetDepth * incV
						pyL2 = pyL1 - parapetWallInsetDepth * incH

						pxR1 = rightWidth + overSizeRight + revYR + parapetExtendRight * incH
						pyR1 = WALL_THICKNESS - WIDO_SILL - py1p

						pxR2 = pxR1 + parapetWallInsetDepth * incV
						pyR2 = pyR1 - parapetWallInsetDepth * incH
					else
						pxL1 = -opInner / 2 - parapetExtendLeft - 1.0 * gs_parapet_autodim
						pyL1 = WALL_THICKNESS - WIDO_SILL + 1.0 * (AC_WallType = 2)

						pxL2 = pxL1
						pyL2 = WALL_THICKNESS - WIDO_SILL - parapetWallInsetDepth

						pxR1 = opInner / 2 + parapetExtendRight + 1.0 * gs_parapet_autodim
						pyR1 = WALL_THICKNESS - WIDO_SILL + 1.0 * (AC_WallType = 2)

						pxR2 = pxR1
						pyR2 = WALL_THICKNESS - WIDO_SILL - parapetWallInsetDepth
					endif
				endif

!!!circle2 pxL1, pyL1, 0.005
!!!circle2 pxL2, pyL2, 0.010
!!!circle2 pxR2, pyR2, 0.015
!!!circle2 pxR1, pyR1, 0.020

				nVertices4 = 4 + (curvedWall & not(wallIsLeft))
				dim vertArr4[][3]

				defaultInhEdgeInfo = -1
				dim inhEdgeInfos4[]

				vertarr4[1][1] = pxL1
				vertarr4[1][2] = pyL1
				vertarr4[1][3] = 0
				inhEdgeInfos4[1] = 2

				vertarr4[2][1] = pxL2
				vertarr4[2][2] = pyL2
				vertarr4[2][3] = 0
				inhEdgeInfos4[2] = 2

				vertarr4[3][1] = pxR2
				vertarr4[3][2] = pyR2
				vertarr4[3][3] = 0
				inhEdgeInfos4[3] = 2

				vertarr4[4][1] = pxR1
				vertarr4[4][2] = pyR1
				vertarr4[4][3] = 0
				inhEdgeInfos4[4] = 2

				if curvedWall & not(wallIsLeft) then
					vertarr4[5][1] = 0
					vertarr4[5][2] = pyR1 + WALL_THICKNESS
					vertarr4[5][3] = 0
					inhEdgeInfos4[5] = -1
				endif

				nContours4 = 1
				dim contArr4[]
				contArr4[1] = nVertices4 + 1

				preparefunction ch, "Store", "WallInset", nVertices4, nContours4, vertArr4, contArr4, defaultInhEdgeInfo, inhEdgeInfos4

! Substract polygons -----------------------------------------------------------

				dim tempResPolyIDArr[]
				for i = 1 to numPoly
					tempNumPoly = callfunction(ch, srcPolyIDArr[i] + " - WallInset", "", tempResPolyIDArr)
				next i
			endif

! Store wall contour polygon in wallhole coordinate system ---------------------

			if AC_WallType = 2 then
				if prevSourceContainer <> "" then
					preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
				endif
				preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
				prevSourceContainer	= lastDestContainer
				lastDestContainer	= "myDestContainer3"
				preparefunction ch, "CreateContainer",			lastDestContainer, ""
				preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

				nVertices2 = vardim1(AC_WallContourPolygon)
				dim vertArr2[][3]

				dim srcPolyIDArr[]
				numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

				defaultInhEdgeInfo = 0
				dim inhEdgeInfos2[]
!!!ccc=0
				for i=1 to nVertices2
					vertarr2[i][1] = AC_WallContourPolygon[i][1]
					if WIDO_REVEAL_SIDE then
						vertarr2[i][2] = AC_WallContourPolygon[i][2] + WIDO_FRAME_THICKNESS
						vertarr2[i][3] = AC_WallContourPolygon[i][3]
					else
						vertarr2[i][2] = -AC_WallContourPolygon[i][2]
						vertarr2[i][3] = -AC_WallContourPolygon[i][3]
					endif

					inhEdgeInfos2[i] = 2
!!!ccc=ccc+0.003
!!!circle2 vertarr2[i][1], vertarr2[i][2], ccc
!!!text2 vertarr2[i][1], vertarr2[i][2], i
				next i

				nContours2 = 1
				dim contArr2[]
				contArr2[1] = nVertices2 + 1

				preparefunction ch, "Store", "wallContourPoly", nVertices2, nContours2, vertArr2, contArr2, defaultInhEdgeInfo, inhEdgeInfos2

! Intersect polygons -----------------------------------------------------------

				dim tempResPolyIDArr[]
				for i = 1 to numPoly
					tempNumPoly = callfunction (ch, "wallContourPoly / " + srcPolyIDArr[i], "", tempResPolyIDArr)
				next i
			endif

! Draw resulting polygons ------------------------------------------------------

			dim resPolyIDArr[]
			numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)

!!!text2 0,0, numPoly

			for i = 1 to numPoly
				polygonID = resPolyIDArr[i]
				gosub 1000	! Get GDL Polygon

				if _bValidPoly then
					if bDrawBoardFill then
						fill wallholeFill
						if GLOB_CONTEXT = 5 then
							poly2_b nsp/3, 2+64, wallholePen_fg,wallholePen_bg,
								get(nsp)
						else
							wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
								0,0,0, get(nsp)
						endif
					else
						fill 0
						if GLOB_CONTEXT = 5 then
							poly2_b nsp/3, 2+64, 0,-1,
								get(nsp)
						else
							wallhole2 nsp/3, 2 + 64, 0,-1,
								0,0,0, get(nsp)
						endif
					endif
				endif
			next i

! Draw resulting contours ------------------------------------------------------

			if ( (AC_WallType = 2) & not(bNeedToOffsetSkins) ) | bVisibleWallInsetIn2D then
				dim lineAttributes[2][4]
				lineAttributes[1][1] = WALL_SECT_PEN
				lineAttributes[1][2] = WALL_LINETYPE
				lineAttributes[1][3] = LINE_PROPERTY_CONTOUR
				lineAttributes[1][4] = bitset(0, LINE_ATTRIBUTES_WALLLINE)

				lineAttributes[2][1] = gs_wcont_line_pen * (wcontLineIn > 0)	! Inside, Both Sides
				if bHiddenParapetWallInsetIn2D then
					lineAttributes[2][2] = gs_parapet_line
				else
					lineAttributes[2][2] = wcontLineIn
				endif
				lineAttributes[2][3] = LINE_PROPERTY_GENERIC
				lineAttributes[2][4] = bitset(0, LINE_ATTRIBUTES_GDLLINE)

				bPutHotsopts	= (AC_WallType = 2)

				for i = 1 to numPoly
					polygonID = resPolyIDArr[i]
					gosub 1001	! Draw one polygon contour line
				next i
			endif
		endif	! if bUsePolygonOperations then

		if not(bUsePolygonOperations) then
			if (wcontLineIn > 0) then		! Inside, Both Sides
				pen gs_wcont_line_pen
				line_property 0
				if bHiddenParapetWallInsetIn2D then
					line_type gs_parapet_line
				else
					line_type wcontLineIn
				endif

				poly2_ nsp/3, 1,use(nsp)
			endif

			if bDrawBoardFill then
				fill wallholeFill
				if GLOB_CONTEXT = 5 then
					poly2_b nsp/3, 2+4+64, wallholePen_fg,wallholePen_bg,
						get(nsp)
				else
					wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
						0,0,0, get(nsp)
				endif
			else
				fill 0
				if GLOB_CONTEXT = 5 then
					poly2_b nsp/3, 2+4+64, 0, -1,
						get(nsp)
				else
					wallhole2 nsp/3, 2 + 64, 0,-1,
						0,0,0, get(nsp)
				endif
			endif

		endif

	endif

!-------------------------------------------------------------------------------
! Draw hidden parts of Wall Inset
!-------------------------------------------------------------------------------

	if gs_parapet_2D & bUsePolygonOperations & bParapetWallInset & bCutWallInsetWithPolyOp & not(bAutoParapetInset) & \
		not((gs_stack_left | bLeftCornerFunction) & (gs_stack_right | bRightCornerFunction)) then

		if prevSourceContainer <> "" then
			preparefunction ch, "DeleteContainer", prevSourceContainer, ""
		endif
		if lastDestContainer <> "" then
			preparefunction ch, "DeleteContainer", lastDestContainer, ""
		endif

		preparefunction ch, "CreateContainer",	 "mySourceContainer", ""
		preparefunction ch, "SetSourceContainer", "mySourceContainer", ""

		prevSourceContainer	= ""
		lastDestContainer	= "mySourceContainer"
		preparefunction ch, "SetDestinationContainer", lastDestContainer, ""

! Store wallhole polygon -------------------------------------------------------

		bHasAnySillPoint = 0
		for i=idxSillStartPlasterLeft to idxSillEndPlasterLeft
			if leftRevealPnts[i][2] <= 0 then
				distFromLast = abs((leftRevealPnts[i][1] - lastSillPointX)^2 + (leftRevealPnts[i][2] - lastSillPointY)^2)
				if not(bHasAnySillPoint) | distFromLast > EPS then
					put leftRevealPnts[i][1], leftRevealPnts[i][2], not(gs_stack_left)
					lastSillPointX = leftRevealPnts[i][1]
					lastSillPointY = leftRevealPnts[i][2]
					bHasAnySillPoint = 1
				endif
			endif
		next i
		if idxFrameStartRevealLeft <> idxSillEndPlasterLeft | not(bHasAnySillPoint) then
			put leftRevealPnts[idxFrameStartRevealLeft][1],	leftRevealPnts[idxFrameStartRevealLeft][2],	not(gs_stack_left)
		endif
		put leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2],	not(gs_stack_left)
		bHasAnyBoardPoint = 0
		for i=idxBoardStartPlasterLeft + (idxFrameEndRevealLeft = idxBoardStartPlasterLeft) to idxBoardEndPlasterLeft
			if leftRevealPnts[i][2] >= WIDO_FRAME_THICKNESS then
				distFromLast = abs((leftRevealPnts[i][1] - lastBoardPointX)^2 + (leftRevealPnts[i][2] - lastBoardPointY)^2)
				if not(bHasAnyBoardPoint) | distFromLast > EPS then
					put leftRevealPnts[i][1], leftRevealPnts[i][2]
					if i = idxBoardEndPlasterLeft then
						put -1
					else
						put not(gs_stack_left)
					endif
					lastBoardPointX = leftRevealPnts[i][1]
					lastBoardPointY = leftRevealPnts[i][2]
					bHasAnyBoardPoint = 1
				endif
			endif
		next i

		bHasAnyBoardPoint = 0
		for i = idxBoardEndPlasterRight to idxBoardStartPlasterRight step -1
			if rightRevealPnts[i][2] >= WIDO_FRAME_THICKNESS then
				distFromLast = abs((rightRevealPnts[i][1] - lastBoardPointX)^2 + (rightRevealPnts[i][2] - lastBoardPointY)^2)
				if not(bHasAnyBoardPoint) | distFromLast > EPS then
					put rightRevealPnts[i][1], rightRevealPnts[i][2], not(gs_stack_right)
					lastBoardPointX = rightRevealPnts[i][1]
					lastBoardPointY = rightRevealPnts[i][2]
					bHasAnyBoardPoint = 1
				endif
			endif
		next i
		if idxFrameEndRevealRight <> idxBoardStartPlasterRight | not(bHasAnyBoardPoint) then
			put rightRevealPnts[idxFrameEndRevealRight][1],	 rightRevealPnts[idxFrameEndRevealRight][2],	not(gs_stack_right)
		endif
		put rightRevealPnts[idxFrameStartRevealRight][1],rightRevealPnts[idxFrameStartRevealRight][2],	not(gs_stack_right)
		bHasAnySillPoint = 0
		lastSillPointX = rightRevealPnts[idxFrameStartRevealRight][1]
		lastSillPointY = rightRevealPnts[idxFrameStartRevealRight][2]
		for i = idxSillEndPlasterRight - (idxFrameStartRevealRight = idxSillEndPlasterRight) to idxSillStartPlasterRight step -1
			if rightRevealPnts[i][2] <= 0 then
				distFromLast = abs((rightRevealPnts[i][1] - lastSillPointX)^2 + (rightRevealPnts[i][2] - lastSillPointY)^2)
				if distFromLast > EPS then
					put rightRevealPnts[i][1], rightRevealPnts[i][2]
					if i = idxSillStartPlasterRight then
						put -1
					else
						put not(gs_stack_right)
					endif
					lastSillPointX = rightRevealPnts[i][1]
					lastSillPointY = rightRevealPnts[i][2]
					bHasAnySillPoint = 1
				endif
			endif
		next i

		nVertices1 = nsp/3
		dim vertArr1[][3]

		defaultInhEdgeInfo = 0
		dim inhEdgeInfos1[]

		idx = 1
		for i=1 to nVertices1
			px = get(1)
			py = get(1)
			ps = get(1)
			if i = 1 then
				bSkipThisPoint = 0
			else
				bSkipThisPoint = (abs(px - vertarr1[idx-1][1]) < EPS & abs(py - vertarr1[idx-1][2]) < EPS)
			endif
			if not(bSkipThisPoint) then
				vertarr1[idx][1]	 = px
				vertarr1[idx][2]	 = py
				vertarr1[idx][3]	 = 0
				inhEdgeInfos1[idx] = ps	! Mark wallhole edges
				idx = idx + 1
			endif
		next i
		nVertices1 = idx - 1

		nContours1 = 1
		dim contArr1[]
		contArr1[1] = nVertices1 + 1

		preparefunction ch, "Store", "wallHolePoly", nVertices1, nContours1, vertArr1, contArr1, defaultInhEdgeInfo, inhEdgeInfos1

! Regularize polygon(s) - avoid generating invalid polygons --------------------

		if curvedWall then

			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer1"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

			dim tempResPolyIDArr[]
			for i=1 to numPoly
				tempNumPoly = callfunction (ch, "Regularize", srcPolyIDArr[i], tempResPolyIDArr)
			next i
		endif

! Offset board side edge -------------------------------------------------------

		dim srcPolyIDArr2[]
		numPoly = callfunction (ch, "GetDestinationPolygons", "", srcPolyIDArr2)

		dim edgeIds[]
		edgeIds[numPoly] = 0
		for i=1 to numPoly
			dim inhEdgeInfos[]
			numEdges = callfunction(ch, "GetInhEdgeInfos", srcPolyIDArr2[i], inhEdgeInfos)

			for j=1 to numEdges
				if inhEdgeInfos[j] = -1 then edgeIds[i] = j
			next j
		next i

		if prevSourceContainer <> "" then
			preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
		endif
		preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
		prevSourceContainer	= lastDestContainer
		lastDestContainer	= "myDestContainer2"
		preparefunction ch, "CreateContainer",			lastDestContainer, ""
		preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

		dim srcPolyIDArr[]
		numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

		dim tempResPolyIDArr[]
		for i=1 to numPoly

			preparefunction ch, "OffsetParams", "", edgeIds[i], 0.50

			tempNumPoly = callfunction (ch, "OffsetEdge", srcPolyIDArr[i], tempResPolyIDArr)
		next i

!!!dim resPolyIDArr[]
!!!numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!for i = 1 to numPoly
!!!	polygonID = resPolyIDArr[i]
!!!	gosub 1000	! Get GDL Polygon
!!!
!!!	ccc=0
!!!	for j=1 to nsp/3
!!!		xx=get(1)
!!!		yy=get(1)
!!!		ss=get(1)
!!!		ccc=ccc+0.003
!!!		circle2 xx,yy,ccc
!!!		text2 xx,yy,j
!!!	next j
!!!next i
!!!end

! Store wall inset polygon -----------------------------------------------------

		if prevSourceContainer <> "" then
			preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
		endif
		preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
		prevSourceContainer	= lastDestContainer
		lastDestContainer	= "myDestContainer3"
		preparefunction ch, "CreateContainer",			lastDestContainer, ""
		preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

		dim srcPolyIDArr[]
		numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

		nVertices4 = 4 + (curvedWall & not(wallIsLeft))
		dim vertArr4[][3]

		defaultInhEdgeInfo = -1
		dim inhEdgeInfos4[]

		vertarr4[1][1] = pxL1 * not(gs_stack_left | bLeftCornerFunction)
		vertarr4[1][2] = pyL1
		vertarr4[1][3] = 0
		inhEdgeInfos4[1] = 2

		vertarr4[2][1] = pxL2 * not(gs_stack_left | bLeftCornerFunction)
		vertarr4[2][2] = pyL2
		vertarr4[2][3] = 0
		inhEdgeInfos4[2] = 2

		vertarr4[3][1] = pxR2 * not(gs_stack_right | bRightCornerFunction)
		vertarr4[3][2] = pyR2
		vertarr4[3][3] = 0
		inhEdgeInfos4[3] = 2

		vertarr4[4][1] = pxR1 * not(gs_stack_right | bRightCornerFunction)
		vertarr4[4][2] = pyR1
		vertarr4[4][3] = 0
		inhEdgeInfos4[4] = 0

		if curvedWall & not(wallIsLeft) then
			vertarr4[5][1] = 0
			vertarr4[5][2] = pyR1 + WALL_THICKNESS
			vertarr4[5][3] = 0
			inhEdgeInfos4[5] = 0
		endif

		nContours4 = 1
		dim contArr4[]
		contArr4[1] = nVertices4 + 1

		preparefunction ch, "Store", "WallInset", nVertices4, nContours4, vertArr4, contArr4, defaultInhEdgeInfo, inhEdgeInfos4

! Substract polygons -----------------------------------------------------------

		dim tempResPolyIDArr[]
		for i = 1 to numPoly
			tempNumPoly = callfunction(ch, "WallInset - " + srcPolyIDArr[i], "", tempResPolyIDArr)
		next i

!!!! Substract polygons -----------------------------------------------------------
!!!
!!!	dim srcPolyIDArr[]
!!!	numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)
!!!
!!!	dim operandPolygonNames[]
!!!		operandPolygonNames[1] = "WallInset"
!!!	numOperandPolygonNames = 1
!!!	containerIdx = 10
!!!
!!!	while numPoly > 0 do
!!!
!!!		for i = 2 to numPoly
!!!			tempNumPoly = callfunction (ch, "CopyPolygon", srcPolyIDArr[i], tempResPolyIDArr)
!!!		next i
!!!		lastNumPoly = numPoly - 1
!!!
!!!		for i=1 to numOperandPolygonNames
!!!			tempNumPoly = callfunction (ch, operandPolygonNames[i] + " - " + srcPolyIDArr[1], "", tempResPolyIDArr)
!!!		next i
!!!
!!!		numResPoly = tempNumPoly - lastNumPoly + 1
!!!
!!!		dim resPolyIDArr[]
!!!		tempNumPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!		numOperandPolygonNames = tempNumPoly - lastNumPoly
!!!
!!!		for i=1 to numOperandPolygonNames
!!!			operandPolygonNames[i] = resPolyIDArr[lastNumPoly + i]
!!!		next i
!!!
!!!		numPoly = numPoly - 1
!!!
!!!		if numPoly > 0 then
!!!			if prevSourceContainer <> "" then
!!!				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
!!!			endif
!!!			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
!!!			prevSourceContainer	= lastDestContainer
!!!			lastDestContainer	= "myDestContainer" + str(containerIdx, 1, 0)
!!!			preparefunction ch, "CreateContainer",			lastDestContainer, ""
!!!			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""
!!!			containerIdx = containerIdx + 1
!!!		endif
!!!	endwhile

! Store wall contour polygon in wallhole coordinate system ---------------------

		if AC_WallType = 2 then

			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer4"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			nVertices2 = vardim1(AC_WallContourPolygon)
			dim vertArr2[][3]

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

			defaultInhEdgeInfo = 0
			dim inhEdgeInfos2[]
!!!ccc=0
			for i=1 to nVertices2
				vertarr2[i][1] = AC_WallContourPolygon[i][1]
				if WIDO_REVEAL_SIDE then
					vertarr2[i][2] = AC_WallContourPolygon[i][2] + WIDO_FRAME_THICKNESS
					vertarr2[i][3] = AC_WallContourPolygon[i][3]
				else
					vertarr2[i][2] = -AC_WallContourPolygon[i][2]
					vertarr2[i][3] = -AC_WallContourPolygon[i][3]
				endif

				inhEdgeInfos2[i] = 2
!!!ccc=ccc+0.003
!!!circle2 vertarr2[i][1], vertarr2[i][2], ccc
!!!text2 vertarr2[i][1], vertarr2[i][2], i
			next i

			nContours2 = 1
			dim contArr2[]
			contArr2[1] = nVertices2 + 1

			preparefunction ch, "Store", "wallContourPoly", nVertices2, nContours2, vertArr2, contArr2, defaultInhEdgeInfo, inhEdgeInfos2

! Intersect polygons -----------------------------------------------------------

			dim tempResPolyIDArr[]
			for i = 1 to numPoly
				tempNumPoly = callfunction (ch, "wallContourPoly / " + srcPolyIDArr[i], "", tempResPolyIDArr)
			next i
		endif

! Cut hidden wall skins polygon ------------------------------------------------

		if (offsetBoard > EPS) then

			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",			prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer5"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

! Store hidden wall skins polygon ----------------------------------------------

			if curvedWall then
				pxL1 = -radBoard + signWallIsLeft * 0.1
				pyL1 = WOD

				pxL2 = -radBoard - signWallIsLeft * offsetBoard
				pyL2 = WOD

				pxR1 = radBoard - signWallIsLeft * 0.1
				pyR1 = WOD

				pxR2 = radBoard + signWallIsLeft * offsetBoard
				pyR2 = WOD
			else
				if bInclinedWall then
					pxL1 = -leftWidth - 1.0
					pyL1 = WALL_THICKNESS - WIDO_SILL + pxL1 * incX + 0.1

					pxL2 = pxL1
					pyL2 = WALL_THICKNESS - WIDO_SILL - offsetBoard * incFactor * incY + pxL2 * incX

					pxR1 = rightWidth + 1.0
					pyR1 = WALL_THICKNESS - WIDO_SILL + pxR1 * incX + 0.1

					pxR2 = pxR1
					pyR2 = WALL_THICKNESS - WIDO_SILL - offsetBoard * incFactor * incY + pxR2 * incX
				else
					pxL1 = -leftWidth - 1.0
					pyL1 = WALL_THICKNESS - WIDO_SILL + 0.1

					pxL2 = pxL1
					pyL2 = WALL_THICKNESS - WIDO_SILL - offsetBoard

					pxR1 = rightWidth + 1.0
					pyR1 = WALL_THICKNESS - WIDO_SILL + 0.1

					pxR2 = pxR1
					pyR2 = WALL_THICKNESS - WIDO_SILL - offsetBoard
				endif
			endif

!!!text2 0,0.2, WALL_THICKNESS
!!!circle2 0,0, 0.01
!!!fill 1
!!!pen 1
!!!poly2_b 4, 1+2+4+64, 1,0,
!!!	pxL1, pyL1, 1,
!!!	pxL2, pyL2, 1,
!!!	pxR2, pyR2, 1,
!!!	pxR1, pyR1, 1
!!!fill wallholeFill

			nVertices2 = 4
			dim vertArr2[][3]

			defaultInhEdgeInfo = -1
			dim inhEdgeInfos2[]

			vertarr2[1][1] = pxL1
			vertarr2[1][2] = pyL1
			vertarr2[1][3] = 0
			inhEdgeInfos2[1] = 0

			vertarr2[2][1] = pxL2
			vertarr2[2][2] = pyL2
			vertarr2[2][3] = curvedWall * signWallIsLeft * 180
			inhEdgeInfos2[2] = 0

			vertarr2[3][1] = pxR2
			vertarr2[3][2] = pyR2
			vertarr2[3][3] = 0
			inhEdgeInfos2[3] = 0

			vertarr2[4][1] = pxR1
			vertarr2[4][2] = pyR1
			vertarr2[4][3] = curvedWall * signWallIsLeft * (-180)
			inhEdgeInfos2[4] = 0

			nContours2 = 1
			dim contArr2[]
			contArr2[1] = nVertices2 + 1

			preparefunction ch, "Store", "poly2", nVertices2, nContours2, vertArr2, contArr2, defaultInhEdgeInfo, inhEdgeInfos2

! Substract polygons -----------------------------------------------------------

			dim tempResPolyIDArr[]
			for i = 1 to numPoly
				tempNumPoly = callfunction(ch, srcPolyIDArr[i] + " - poly2", "", tempResPolyIDArr)
			next i
		endif

! Draw wall contour lines ------------------------------------------------------

		dim resPolyIDArr[]
		numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)

		dim lineAttributes[2][4]
		lineAttributes[1][1] = 0
		lineAttributes[1][2] = 0
		lineAttributes[1][3] = 0
		lineAttributes[1][4] = 0

		lineAttributes[2][1] = gs_wcont_line_pen * (wcontLineIn > 0)
		lineAttributes[2][2] = gs_parapet_line
		lineAttributes[2][3] = LINE_PROPERTY_GENERIC
		lineAttributes[2][4] = bitset(0, LINE_ATTRIBUTES_GDLLINE)

		bPutHotsopts	= 0

		for i = 1 to numPoly
			polygonID = resPolyIDArr[i]
			gosub 1001	! Draw one polygon contour line
		next i

	endif

! Close channel ----------------------------------------------------------------

	if bUsePolygonOperations then
		closeaddonscope ch
	endif
return


! ==============================================================================
! Draw Wall Contour Outside
! ==============================================================================

"DrawContourLinesOutside":

	pen gs_wcont_line_pen
	line_property 0

	if curvedWall then
		R = sqr(leftRevealPnts[idxSillStartPlasterLeft][1]^2 + (leftRevealPnts[idxSillStartPlasterLeft][2] - WOD)^2) - offsetSill * signWallIsLeft

		if wallContourLineOffsetLeftOut > EPS then
			x1 = leftRevealPnts[idxSillStartPlasterLeft][1] + signWallIsLeft * wallContourLineOffsetLeftOut / cos(alpha-270)
			y1 = leftRevealPnts[idxSillStartPlasterLeft][2]
			x2 = x1 - signWallIsLeft * sin(alpha-270)
			y2 = y1 + signWallIsLeft * cos(alpha-270)
			xo = 0
			yo = WOD
			ro = R
			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			vx = cx
			vy = cy - WOD
		else
			if bNeedToOffsetSkins & bParalellInCurvedWalls then
				vx = leftRevealPnts[idxSillStartPlasterLeft][1]
				vy = -signWallIsLeft * sqr(R^2 - vx^2)
			else
				vx = leftRevealPnts[idxSillStartPlasterLeft][1]
				vy = leftRevealPnts[idxSillStartPlasterLeft][2] - WOD
			endif
		endif
		gosub 103	! Direction Angle
		alpha = angle


		if wallContourLineOffsetRightOut > EPS then
			x1 = rightRevealPnts[idxSillStartPlasterRight][1] - signWallIsLeft * wallContourLineOffsetRightOut / cos(beta-270)
			y1 = rightRevealPnts[idxSillStartPlasterRight][2]
			x2 = x1 - signWallIsLeft * sin(beta-270)
			y2 = y1 + signWallIsLeft * cos(beta-270)
			xo = 0
			yo = WOD
			ro = R
			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			vx = cx
			vy = cy - WOD
		else
			if bNeedToOffsetSkins & bParalellInCurvedWalls then
				vx = rightRevealPnts[idxSillStartPlasterRight][1]
				vy = -signWallIsLeft * sqr(R^2 - vx^2)
			else
				vx = rightRevealPnts[idxSillStartPlasterRight][1]
				vy = rightRevealPnts[idxSillStartPlasterRight][2] - WOD
			endif
		endif
		gosub 103	! Direction Angle
		beta = angle


		if bHasSidelightLeft then
			vx = -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_left_sL + thkPlasterAtSillSlLeft
			vy = -signWallIsLeft * sqr((radSill - offsetSill * signWallIsLeft)^2 - vx^2)
			gosub 103	! Direction Angle
			if bWallContourLineSl then
				line_type _wcont_line_left_sl_out
				if abs(angle - alpha) > EPS then
					arc2 0,WOD, R, min(angle,alpha), max(angle,alpha)
				endif
				if (vy + WOD) < -EPS then
					line2 vx, vy + WOD, vx, 0
					if abs(thkPlasterAtBoardSlLeft + gs_reveal_left_sL) > EPS then
						line2 vx, 0, -leftWidth + gs_sidelight_WHole_width_left, 0
					endif
				endif
			endif
			hotspot2 vx, vy + WOD, 11070
			alpha = angle
		endif
		if bHasSidelightRight then
			vx = rightWidth - gs_sidelight_WHole_width_right - gs_reveal_right_sR - thkPlasterAtSillSlRight
			vy = -signWallIsLeft * sqr((radSill - offsetSill * signWallIsLeft)^2 - vx^2)
			gosub 103	! Direction Angle
			if bWallContourLineSl then
				line_type _wcont_line_right_sl_out
				if abs(angle - beta) > EPS then
					arc2 0,WOD, R, min(angle,beta), max(angle,beta)
				endif
				if (vy + WOD) < -EPS then
					line2 vx, vy + WOD, vx, 0
					if abs(thkPlasterAtBoardSlRight + gs_reveal_right_sR) > EPS then
						line2 vx, 0, rightWidth - gs_sidelight_WHole_width_right, 0
					endif
				endif
			endif
			hotspot2 vx, vy + WOD, 11071
			beta = angle
		endif

! We have to draw this line!
!		if (gs_IsCurved & abs(R - radSill) < WIDO_SILL) | \
!			(not(gs_IsCurved) & WOD - R * signWallIsLeft < 0) | \
!			 not(isWindow) | WIDO_FRAME_THICKNESS < EPS then

			if bWallContourLine & abs(alpha - beta) > EPS then
				line_type gs_wcont_line_out
				arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
			endif
!		endif
	else
		if bNeedToOffsetSkins then
			pxL = leftRevealPnts[idxSillStartPlasterLeft][1] + bLeftCornerFunction * lx * offsetSill
			pyL = leftRevealPnts[idxSillStartPlasterLeft][2] + offsetSill

			pxR = rightRevealPnts[idxSillStartPlasterRight][1] - bRightCornerFunction * rx * offsetSill
			pyR = rightRevealPnts[idxSillStartPlasterRight][2] + offsetSill
		else
			pxL = leftRevealPnts[idxSillStartPlasterLeft][1]
			pyL = leftRevealPnts[idxSillStartPlasterLeft][2]

			pxR = rightRevealPnts[idxSillStartPlasterRight][1]
			pyR = rightRevealPnts[idxSillStartPlasterRight][2]
		endif

		if wallContourLineOffsetLeftOut > EPS then
			pxL = pxL + wallContourLineOffsetLeftOut
		endif
		if wallContourLineOffsetRightOut > EPS then
			pxR = pxR - wallContourLineOffsetRightOut
		endif

		if bHasSidelightLeft then
			px = -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_left_sL + thkPlasterAtSillSlLeft
			if bWallContourLineSl then
				line_type _wcont_line_left_sl_out
				line2 pxL,pyL, px, pyL
				if pyL < -EPS then
					line2 px, pyL, px, 0
				endif
				if abs(thkPlasterAtBoardSlLeft + gs_reveal_left_sL) > EPS then
					line2 px, 0, -leftWidth + gs_sidelight_WHole_width_left, 0
				endif
			endif
			hotspot2 px, pyL, 11070
			pxL = px
		endif
		if bHasSidelightRight then
			px = rightWidth - gs_sidelight_WHole_width_right - gs_reveal_right_sR - thkPlasterAtSillSlRight
			if bWallContourLineSl then
				line_type _wcont_line_right_sl_out
				line2 pxR,pyR, px, pyR
				if pyR < -EPS then
					line2 px, pyR, px, 0
				endif
				if abs(thkPlasterAtBoardSlRight + gs_reveal_right_sR) > EPS then
					line2 px, 0, rightWidth - gs_sidelight_WHole_width_right, 0
				endif
			endif
			hotspot2 px, pyR, 11071
			pxR = px
		endif

! We have to draw this line!
!		! We must draw this line in case of doors [not(isWindow)]
!		! and in case of window openings [where WIDO_FRAME_THICKNESS < EPS]
!		if (pyL < 0 & pyR < 0) | not(isWindow) | WIDO_FRAME_THICKNESS < EPS then
		if bWallContourLine then
			line_type gs_wcont_line_out
			line2 pxL,pyL, pxR,pyR
		endif
	endif
return


! ==============================================================================
! Draw Wall Contour Inside
! ==============================================================================

"DrawContourLinesInside":

	pen gs_wcont_line_pen
	line_property 0

	if curvedWall then
		R = sqr(leftRevealPnts[idxBoardEndPlasterLeft][1]^2 + (leftRevealPnts[idxBoardEndPlasterLeft][2] - WOD)^2) + offsetBoard * signWallIsLeft

		if wallContourLineOffsetLeftIn > EPS then
			x1 = leftRevealPnts[idxBoardEndPlasterLeft][1] + signWallIsLeft * wallContourLineOffsetLeftIn / cos(alpha-270)
			y1 = leftRevealPnts[idxBoardEndPlasterLeft][2]
			x2 = x1 - signWallIsLeft * sin(alpha-270)
			y2 = y1 + signWallIsLeft * cos(alpha-270)
			xo = 0
			yo = WOD
			ro = R
			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			vx = cx
			vy = cy - WOD
		else
			if bNeedToOffsetSkins & bParalellInCurvedWalls then
				vx = leftRevealPnts[idxBoardEndPlasterLeft][1]
				vy = -signWallIsLeft * sqr(R^2 - vx^2)
			else
				vx = leftRevealPnts[idxBoardEndPlasterLeft][1]
				vy = leftRevealPnts[idxBoardEndPlasterLeft][2] - WOD
			endif
		endif
		gosub 103	! Direction Angle
		alpha = angle

		if wallContourLineOffsetRightIn > EPS then
			x1 = rightRevealPnts[idxBoardEndPlasterRight][1] - signWallIsLeft * wallContourLineOffsetRightIn / cos(beta-270)
			y1 = rightRevealPnts[idxBoardEndPlasterRight][2]
			x2 = x1 - signWallIsLeft * sin(beta-270)
			y2 = y1 + signWallIsLeft * cos(beta-270)
			xo = 0
			yo = WOD
			ro = R
			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			vx = cx
			vy = cy - WOD
		else
			if bNeedToOffsetSkins & bParalellInCurvedWalls then
				vx = rightRevealPnts[idxBoardEndPlasterRight][1]
				vy = -signWallIsLeft * sqr(R^2 - vx^2)
			else
				vx = rightRevealPnts[idxBoardEndPlasterRight][1]
				vy = rightRevealPnts[idxBoardEndPlasterRight][2] - WOD
			endif
		endif
		gosub 103	! Direction Angle
		beta = angle

		if bHasSidelightLeft then
			vx = -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_double_innerLeft_sL + thkPlasterAtBoardSlLeft
			vy = -signWallIsLeft * sqr((radBoard + offsetBoard * signWallIsLeft)^2 - vx^2)
			gosub 103	! Direction Angle
			if bWallContourLineSl then
				line_type _wcont_line_left_sl_in
				if abs(angle - alpha) > EPS then
					arc2 0,WOD, R, min(angle,alpha), max(angle,alpha)
				endif
				if (vy + WOD) > WIDO_FRAME_THICKNESS then
					if abs(gs_reveal_double_innerLeft_sL + thkPlasterAtBoardSlLeft) > EPS then
						line2 vx, vy + WOD, vx, WIDO_FRAME_THICKNESS
						line2 vx - gs_reveal_double_innerLeft_sL - thkPlasterAtBoardSlLeft, WIDO_FRAME_THICKNESS, vx, WIDO_FRAME_THICKNESS
						line2 vx - gs_reveal_double_innerLeft_sL - thkPlasterAtBoardSlLeft, WIDO_FRAME_THICKNESS, vx - gs_reveal_double_innerLeft_sL - thkPlasterAtBoardSlLeft, 0
					else
						vy2 = max(0 - WOD, -signWallIsLeft * sqr((radSill - offsetSill * signWallIsLeft)^2 - vx^2))
						line2 vx, vy + WOD, vx, vy2 + WOD
					endif
				endif
			endif
			hotspot2 vx, vy + WOD, 11072
			alpha = angle
		endif
		if bHasSidelightRight then
			vx = rightWidth - gs_sidelight_WHole_width_right - gs_reveal_double_innerRight_sR - thkPlasterAtBoardSlRight
			vy = -signWallIsLeft * sqr((radBoard + offsetBoard * signWallIsLeft)^2 - vx^2)
			gosub 103	! Direction Angle
			if bWallContourLineSl then
				line_type _wcont_line_right_sl_in
				if abs(angle - beta) > EPS then
					arc2 0,WOD, R, min(angle,beta), max(angle,beta)
				endif
				if (vy + WOD) > WIDO_FRAME_THICKNESS then
					if abs(gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight) > EPS then
						line2 vx, vy + WOD, vx, WIDO_FRAME_THICKNESS
						line2 vx + gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight, WIDO_FRAME_THICKNESS, vx, WIDO_FRAME_THICKNESS
						line2 vx + gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight, WIDO_FRAME_THICKNESS, vx + gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight, 0
					else
						vy2 = max(0 - WOD, -signWallIsLeft * sqr((radSill - offsetSill * signWallIsLeft)^2 - vx^2))
						line2 vx, vy + WOD, vx, vy2 + WOD
					endif
				endif
			endif
			hotspot2 vx, vy + WOD, 11073
			beta = angle
		endif

!		if (gs_IsCurved & abs(R - radSill) < WIDO_SILL) | (not(gs_IsCurved) & WOD - R * signWallIsLeft < 0) then
			if bWallContourLine & abs(alpha - beta) > EPS then
				line_type gs_wcont_line_in
				arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
			endif
!		endif
	else
		if bNeedToOffsetSkins then
			pxL = leftRevealPnts[idxBoardEndPlasterLeft][1] - bLeftCornerFunction * lx * offsetBoard
			if bInclinedWall then
				pyL = leftRevealPnts[idxBoardEndPlasterLeft][2] - offsetBoard / incH
			else
				pyL = leftRevealPnts[idxBoardEndPlasterLeft][2] - offsetBoard
			endif

			pxR = rightRevealPnts[idxBoardEndPlasterRight][1] + bRightCornerFunction * rx * offsetBoard
			if bInclinedWall then
				pyR = rightRevealPnts[idxBoardEndPlasterRight][2] - offsetBoard / incH
			else
				pyR = rightRevealPnts[idxBoardEndPlasterRight][2] - offsetBoard
			endif
		else
			pxL = leftRevealPnts[idxBoardEndPlasterLeft][1]
			pyL = leftRevealPnts[idxBoardEndPlasterLeft][2]

			pxR = rightRevealPnts[idxBoardEndPlasterRight][1]
			pyR = rightRevealPnts[idxBoardEndPlasterRight][2]
		endif

		if wallContourLineOffsetLeftIn > EPS then
			pxL = pxL + wallContourLineOffsetLeftIn
			if bInclinedWall then
				pyL = pyL  + iDir * wallContourLineOffsetLeftIn * tan(WALL_INCL)
			endif
		endif
		if wallContourLineOffsetRightIn > EPS then
			pxR = pxR - wallContourLineOffsetRightIn
			if bInclinedWall then
				pyR = pyR  - iDir * wallContourLineOffsetRightIn * tan(WALL_INCL)
			endif
		endif

		if pyL > 0 & pyR > 0 then

			if bHasSidelightLeft then
				px = -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_double_innerLeft_sL + thkPlasterAtBoardSlLeft
				py = pyL + (pxL - px) * (pyL - pyR) / (-pxL + pxR)
				if bWallContourLineSl then
					line_type _wcont_line_left_sl_in
					line2 pxL,pyL, px, py
					if abs(gs_reveal_double_innerLeft_sL + thkPlasterAtBoardSlLeft) > EPS then
						line2 px, py, px, WIDO_FRAME_THICKNESS
						line2 px - gs_reveal_double_innerLeft_sL - thkPlasterAtBoardSlLeft, WIDO_FRAME_THICKNESS, px, WIDO_FRAME_THICKNESS
						line2 px - gs_reveal_double_innerLeft_sL - thkPlasterAtBoardSlLeft, WIDO_FRAME_THICKNESS, px - gs_reveal_double_innerLeft_sL - thkPlasterAtBoardSlLeft, 0
					else
						line2 px, py, px, 0
					endif
				endif
				hotspot2 px, py, 11072
				pxL = px
				pyL = py
			endif
			if bHasSidelightRight then
				px = rightWidth - gs_sidelight_WHole_width_right - gs_reveal_double_innerRight_sR - thkPlasterAtBoardSlRight
				py = pyR + (pxR - px) * (pyL - pyR) / (-pxL + pxR)
				if bWallContourLineSl then
					line_type _wcont_line_right_sl_in
					line2 pxR,pyR, px, py
					if abs(gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight) > EPS then
						line2 px, py, px, WIDO_FRAME_THICKNESS
						line2 px + gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight, WIDO_FRAME_THICKNESS, px, WIDO_FRAME_THICKNESS
						line2 px + gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight, WIDO_FRAME_THICKNESS, px + gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight, 0
					else
						line2 px, py, px, 0
					endif
				endif
				hotspot2 px, py, 11073
				pxR = px
				pyR = py
			endif

			if bWallContourLine then
				line_type gs_wcont_line_in
				line2 pxL,pyL, pxR,pyR
			endif
		endif
	endif
return


! ==============================================================================
! Head / Threshold Plan Symbol
! ==============================================================================

"DrawHeadThresholdPlanSymbol":

	line_type gs_head_symbol_line
	pen gs_head_symbol_pen

	if curvedWall & gs_IsCurved then
		if iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE | iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE then
			R = sqr(leftRevealPnts[idxSillEndPlasterLeft][1]^2 + (leftRevealPnts[idxSillEndPlasterLeft][2] - WOD)^2) - thkFinishSkinCorrection * ySign

			vx = leftRevealPnts[idxSillEndPlasterLeft][1]
			vy = leftRevealPnts[idxSillEndPlasterLeft][2] - WOD
			gosub 103	! Direction Angle
			alpha = angle

			vx = rightRevealPnts[idxSillEndPlasterRight][1]
			vy = rightRevealPnts[idxSillEndPlasterRight][2] - WOD
			gosub 103	! Direction Angle
			beta = angle

			if abs(alpha - beta) > EPS then
				arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
			endif
		endif
		if iRevealType = REVEAL_SPLAYED | ((iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE) & WIDO_FRAME_THICKNESS > EPS) then
			R = sqr(leftRevealPnts[idxBoardStartRevealLeft][1]^2 + (leftRevealPnts[idxBoardStartRevealLeft][2] - WOD)^2) - thkFinishSkinCorrection * ySign

			vx = leftRevealPnts[idxBoardStartRevealLeft][1]
			vy = leftRevealPnts[idxBoardStartRevealLeft][2] - WOD
			gosub 103	! Direction Angle
			alpha = angle

			vx = rightRevealPnts[idxBoardStartRevealRight][1]
			vy = rightRevealPnts[idxBoardStartRevealRight][2] - WOD
			gosub 103	! Direction Angle
			beta = angle

			if abs(alpha - beta) > EPS then
				arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
			endif
		endif
	else
		if iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE | iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE then
			line2 leftRevealPnts[idxSillEndRevealLeft][1],  leftRevealPnts[idxSillEndRevealLeft][2],
				 rightRevealPnts[idxSillEndRevealRight][1], rightRevealPnts[idxSillEndRevealRight][2]
		endif
		if iRevealType = REVEAL_SPLAYED | ((iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE) & WIDO_FRAME_THICKNESS > EPS) then
			line2 leftRevealPnts[idxBoardStartRevealLeft][1],  leftRevealPnts[idxBoardStartRevealLeft][2],
				 rightRevealPnts[idxBoardStartRevealRight][1], rightRevealPnts[idxBoardStartRevealRight][2]
		endif
	endif
return


! ==============================================================================
! Drawing the wall contour lines
! ==============================================================================

"DrawWallContourLines":

	dim tempLineSections[]

	call "WallContourDivider_kmod" parameters AC_Wall_Direction_Type = AC_Wall_Direction_Type,
		radSill			= radSill,
		radBoard		= radBoard,
		WOD				= WOD,
		offsetSill		= offsetSill,
		offsetBoard		= offsetBoard,
		lineSections	= lineSections,
	returned_parameters tempLineSections

	numLineSections = round_int(vardim1(tempLineSections) / 7)
	dim lineSections[][7]
	idx = 0
	for i=1 to numLineSections
		for j=1 to 7
			lineSections[i][j] = tempLineSections[idx + j]
		next j
		idx = idx + 7
	next i

	nSectNum = vardim1(lineSections)

	for i = 1 to nSectNum

		iBitField = round_int(lineSections[i][LINE_ATTRIBUTES])

		if not(bittest(iBitField, LINE_ATTRIBUTES_DRAWCC)) then

			if not(gs_transom_display) then
				penIdx		= round_int(lineSections[i][LINE_PEN_IDX])
				lineTypeIdx	= round_int(lineSections[i][LINE_LTYPE_IDX])
			else
				penIdx		= gs_transom_display_pen
				lineTypeIdx	= gs_transom_display_linetype
			endif

			if penIdx > 0 then
				pen				penIdx
				line_type		lineTypeIdx
				line_property	LINE_PROPERTY_CONTOUR

				if bittest(iBitField, LINE_ATTRIBUTES_WALLSIDE) & curvedWall then

! Curved line-------------------------------------------------------------------

					R = sqr(lineSections[i][LINE_END_X]^2 + (lineSections[i][LINE_END_Y] - WOD)^2)

					vx = lineSections[i][LINE_BEG_X]
					vy = lineSections[i][LINE_BEG_Y] - WOD
					gosub 103	! Direction Angle
					alpha = angle

					vx = lineSections[i][LINE_END_X]
					vy = lineSections[i][LINE_END_Y] - WOD
					gosub 103	! Direction Angle
					beta = angle

					if abs(alpha - beta) > EPS then
						if bittest(iBitField, LINE_ATTRIBUTES_GDLLINE) then
							if not(gs_transom_display) then
								arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
							endif
						endif
						if bittest(iBitField, LINE_ATTRIBUTES_WALLLINE) then
							if (GLOB_PREVIEW_MODE = 0) then
								arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
							endif
							wallarc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
						endif
					endif

				else

! Straight line-----------------------------------------------------------------

					if bittest(iBitField, LINE_ATTRIBUTES_GDLLINE) then
						if not(gs_transom_display) then
							line2	lineSections[i][LINE_BEG_X], lineSections[i][LINE_BEG_Y],
									lineSections[i][LINE_END_X], lineSections[i][LINE_END_Y]
						endif
					endif

					if bittest(iBitField, LINE_ATTRIBUTES_WALLLINE) & AC_WallType <> 2 then
						if (GLOB_PREVIEW_MODE = 0) then
							line2	lineSections[i][LINE_BEG_X], lineSections[i][LINE_BEG_Y],
									lineSections[i][LINE_END_X], lineSections[i][LINE_END_Y]
						endif
						wallline2	lineSections[i][LINE_BEG_X], lineSections[i][LINE_BEG_Y],
									lineSections[i][LINE_END_X], lineSections[i][LINE_END_Y]
					endif
				endif
			endif
		endif
	next i
return


! ===============================================================================
!	New Wallhole Symbol (SWE symbol)
! ===============================================================================

"DrawSWENewWallholeSymbol":

	openingWidth	= leftWidth + rightWidth

	fill gs_new_symb_fill

	if abs(WIDO_ORIG_DIST) < EPS then					!!! Straight wall

		mul2 1,-1

		if ABS(WALL_INCL) < EPS then

			WALLBLOCK2 4, 6+16+32, gs_new_symb_pen_Fg, gs_new_symb_pen_Bg,
						0, 0, 0,
						-openingWidth/2, WIDO_SILL, 32,
						-openingWidth/2 - gs_new_symb_width_r, WIDO_SILL, 32,
						-openingWidth/2 - gs_new_symb_width_r, WIDO_SILL-WALL_THICKNESS, 32,
						-openingWidth/2, WIDO_SILL-WALL_THICKNESS, 32
			WALLBLOCK2 4, 6+16+32, gs_new_symb_pen_Fg, gs_new_symb_pen_Bg,
						0, 0, 0,
						openingWidth/2, WIDO_SILL, 32,
						openingWidth/2 + gs_new_symb_width_l, WIDO_SILL, 32,
						openingWidth/2 + gs_new_symb_width_l, WIDO_SILL-WALL_THICKNESS, 32,
						openingWidth/2, WIDO_SILL-WALL_THICKNESS, 32

			if WALL_SKINS_NUMBER = 0 then
				pen WALL_SECT_PEN
				LINE_TYPE 1
			else
				if abs(SYMB_ROTANGLE-180) < EPS then
					pen WALL_SKINS_PARAMS[1][7]
					LINE_TYPE WALL_SKINS_PARAMS[1][8]
				else
					pen WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][9]
					LINE_TYPE WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][10]
				endif
			endif

			LINE_PROPERTY 2

			WALLLINE2 openingWidth/2, WIDO_SILL, openingWidth/2 + gs_new_symb_width_l, WIDO_SILL
			WALLLINE2 -openingWidth/2, WIDO_SILL, -openingWidth/2 - gs_new_symb_width_r, WIDO_SILL


			if WALL_SKINS_NUMBER <> 0 then
				if abs(SYMB_ROTANGLE-180) < EPS then
					pen WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][9]
					LINE_TYPE WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][10]
				else
					pen WALL_SKINS_PARAMS[1][7]
					LINE_TYPE WALL_SKINS_PARAMS[1][8]
				endif
			endif

			WALLLINE2 openingWidth/2, WIDO_SILL-WALL_THICKNESS, openingWidth/2 + gs_new_symb_width_l, WIDO_SILL-WALL_THICKNESS
			WALLLINE2 -openingWidth/2, WIDO_SILL-WALL_THICKNESS, -openingWidth/2 - gs_new_symb_width_r, WIDO_SILL-WALL_THICKNESS

		else								!!!inclined wall


			if SYMB_MIRRORED exor abs(SYMB_ROTANGLE) < EPS then
				incl_sign = -1
			else
				incl_sign = 1
			endif

			if WIDO_REVEAL_SIDE then
				mul2 1,-1
				add2 0, WALL_THICKNESS - 2*WIDO_SILL
			endif

			WALLBLOCK2 4, 6+16+32, gs_new_symb_pen_Fg, gs_new_symb_pen_Bg,
						0, 0, 0,
						-openingWidth/2, WIDO_SILL + WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * openingWidth/2, 32,
						-openingWidth/2 - gs_new_symb_width_r, WIDO_SILL + WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_r), 32,
						-openingWidth/2 - gs_new_symb_width_r, WIDO_SILL-WALL_THICKNESS - not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_r), 32,
						-openingWidth/2, WIDO_SILL-WALL_THICKNESS - not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * openingWidth/2, 32

			WALLBLOCK2 4, 6+16+32, gs_new_symb_pen_Fg, gs_new_symb_pen_Bg,
						0, 0, 0,
						openingWidth/2, WIDO_SILL - WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * openingWidth/2, 32,
						openingWidth/2 + gs_new_symb_width_l, WIDO_SILL - WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_l), 32,
						openingWidth/2 + gs_new_symb_width_l, WIDO_SILL-WALL_THICKNESS + not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_l), 32,
						openingWidth/2, WIDO_SILL-WALL_THICKNESS + not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * openingWidth/2, 32

			if WALL_SKINS_NUMBER = 0 then
				pen WALL_SECT_PEN
				LINE_TYPE 1
			else
				if abs(SYMB_ROTANGLE-180) < EPS then
					pen WALL_SKINS_PARAMS[1][7]
					LINE_TYPE WALL_SKINS_PARAMS[1][8]
				else
					pen WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][9]
					LINE_TYPE WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][10]
				endif
			endif

			LINE_PROPERTY 2


			WALLLINE2	-openingWidth/2, WIDO_SILL + WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * openingWidth/2,
						-openingWidth/2 - gs_new_symb_width_r, WIDO_SILL + WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_r)
			WALLLINE2	openingWidth/2, WIDO_SILL - WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * openingWidth/2,
						openingWidth/2 + gs_new_symb_width_l, WIDO_SILL - WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_l)

			if WALL_SKINS_NUMBER <> 0 then
				if abs(SYMB_ROTANGLE-180) < EPS then
					pen WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][9]
					LINE_TYPE WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][10]
				else
					pen WALL_SKINS_PARAMS[1][7]
					LINE_TYPE WALL_SKINS_PARAMS[1][8]
				endif
			endif

			WALLLINE2	-openingWidth/2 - gs_new_symb_width_r, WIDO_SILL-WALL_THICKNESS - not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_r),
						-openingWidth/2, WIDO_SILL-WALL_THICKNESS - not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * openingWidth/2
			WALLLINE2	openingWidth/2 + gs_new_symb_width_l, WIDO_SILL-WALL_THICKNESS + not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_l),
						openingWidth/2, WIDO_SILL-WALL_THICKNESS + not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * openingWidth/2

			if WIDO_REVEAL_SIDE then del 2

		endif


	else									!!!Curved wall

		if WIDO_REVEAL_SIDE exor abs(SYMB_ROTANGLE) < EPS then
			shf_sign = -1
		else
			shf_sign = 1
		endif


		if abs(SYMB_ROTANGLE-180) < EPS then
			shf_sign2 = 1
			frame_shf2 = WIDO_FRAME_THICKNESS
		else
			shf_sign2 = -1
			frame_shf2 = 0
		endif

		if WIDO_REVEAL_SIDE then
			frame_shf = WIDO_SILL + WIDO_FRAME_THICKNESS !/ COS(leftAlfa) - WIDO_FRAME_THICKNESS
		else
			frame_shf = WIDO_SILL
		endif


		leftAlfa	= ATN((openingWidth/2) / (WIDO_ORIG_DIST + frame_shf2))
		rightAlfa	= ATN((openingWidth/2) / (WIDO_ORIG_DIST + frame_shf2))

		leftnewsymbAlfa	= ATN((openingWidth/2 + gs_new_symb_width_r) / (WIDO_ORIG_DIST + frame_shf2))
		rightnewsymbAlfa= ATN((openingWidth/2 + gs_new_symb_width_l) / (WIDO_ORIG_DIST + frame_shf2))



		radOppSide = SQR( ((openingWidth/2)^2) + (WIDO_ORIG_DIST^2) ) + shf_sign * frame_shf

		if not (WIDO_REVEAL_SIDE) then
			mul2 1,-1
		else
			add2 0,WIDO_FRAME_THICKNESS
		endif

		ADD2 0, WIDO_ORIG_DIST

		WALLBLOCK2 5, 6+16+32, gs_new_symb_pen_Fg, gs_new_symb_pen_Bg,
					0, 0, 0,
					0,0, 901,
					SIN(leftAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), shf_sign2 * COS(leftAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), 1,
					SIN(leftnewsymbAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), shf_sign2 * COS(leftnewsymbAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), 3001,
					SIN(leftnewsymbAlfa) * radOppSide, shf_sign2 * COS(leftnewsymbAlfa) * radOppSide, 1,
					SIN(leftAlfa) * radOppSide, shf_sign2 * COS(leftAlfa) * radOppSide, 3001

		WALLBLOCK2 5, 6+16+32, gs_new_symb_pen_Fg, gs_new_symb_pen_Bg,
					0, 0, 0,
					0,0, 901,
					-1 * SIN(rightAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), shf_sign2 * COS(rightAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), 1,
					-1 * SIN(rightnewsymbAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), shf_sign2 * COS(rightnewsymbAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), 3001,
					-1 * SIN(rightnewsymbAlfa) * radOppSide, shf_sign2 * COS(rightnewsymbAlfa) * radOppSide, 1,
					-1 * SIN(rightAlfa) * radOppSide, shf_sign2 * COS(rightAlfa) * radOppSide, 3001


			if WALL_SKINS_NUMBER = 0 then
				pen WALL_SECT_PEN
				LINE_TYPE 1
			else
				if WIDO_REVEAL_SIDE exor abs(SYMB_ROTANGLE) < EPS then
					pen WALL_SKINS_PARAMS[1][7]
					LINE_TYPE WALL_SKINS_PARAMS[1][8]
				else
					pen WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][9]
					LINE_TYPE WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][10]
				endif
			endif

			LINE_PROPERTY 2

			if abs(SYMB_ROTANGLE-180) < EPS then
				WALLARC2 0, 0, radOppSide - shf_sign * WALL_THICKNESS, shf_sign2 * 90+leftnewsymbAlfa, shf_sign2 * 90+leftAlfa
				WALLARC2 0, 0, radOppSide - shf_sign * WALL_THICKNESS, shf_sign2 * 90-rightAlfa, shf_sign2 * 90-rightnewsymbAlfa
			else
				WALLARC2 0, 0, radOppSide - shf_sign * WALL_THICKNESS, shf_sign2 * 90+leftAlfa, shf_sign2 * 90+leftnewsymbAlfa
				WALLARC2 0, 0, radOppSide - shf_sign * WALL_THICKNESS, shf_sign2 * 90-rightnewsymbAlfa, shf_sign2 * 90-rightAlfa
			endif



			if WALL_SKINS_NUMBER <> 0 then
				if WIDO_REVEAL_SIDE exor abs(SYMB_ROTANGLE) < EPS then
					pen WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][9]
					LINE_TYPE WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][10]
				else
					pen WALL_SKINS_PARAMS[1][7]
					LINE_TYPE WALL_SKINS_PARAMS[1][8]
				endif
			endif


			if abs(SYMB_ROTANGLE-180) < EPS then
				WALLARC2 0, 0, radOppSide, shf_sign2 * 90+leftnewsymbAlfa, shf_sign2 * 90+leftAlfa
				WALLARC2 0, 0, radOppSide, shf_sign2 * 90-rightAlfa, shf_sign2 * 90-rightnewsymbAlfa
			else
				WALLARC2 0, 0, radOppSide, shf_sign2 * 90+leftAlfa, shf_sign2 * 90+leftnewsymbAlfa
				WALLARC2 0, 0, radOppSide, shf_sign2 * 90-rightnewsymbAlfa, shf_sign2 * 90-rightAlfa
			endif

			del 1

			del 1

	endif
return


! ==============================================================================
! Mounting Frame
! ==============================================================================

"DrawMountingFrame":

	pen gs_mountingFrame_pen_cont
	fill gs_mountingFrame_fill
	line_property LINE_PROPERTY_GENERIC
	line_type 1

	if not(gs_stack_left | bLeftCornerFunction) then
		if abs(gs_mountingFrame_depth) > EPS then
			poly2_b 4, 1+2+4+64, gs_mountingFrame_pen_fg, gs_mountingFrame_pen_bg,
				-leftWidth,									-gs_mountingFrame_depth,	1+32,
				-leftWidth + gs_mountingFrame_width_left,	-gs_mountingFrame_depth,	1+32,
				-leftWidth + gs_mountingFrame_width_left,	0,							1+32,
				-leftWidth,									0,							1+32

			if lod2D_MountingFrame = 2 then
				line2 -leftWidth,0,-leftWidth + gs_mountingFrame_width_left,-gs_mountingFrame_depth
				line2 -leftWidth,-gs_mountingFrame_depth,-leftWidth + gs_mountingFrame_width_left,0
			endif
		endif
		pxL = -leftWidth + gs_mountingFrame_width_left

		hotspot2 pxL, 0, 11050
	else
		pxL = -leftWidth - bLeftCornerFunction * lx * (WIDO_FRAME_THICKNESS + gs_mountingFrame_depth)
	endif

	if not(gs_stack_right | bRightCornerFunction) then
		if abs(gs_mountingFrame_depth) > EPS then
			poly2_b 4, 1+2+4+64, gs_mountingFrame_pen_fg, gs_mountingFrame_pen_bg,
				rightWidth,									-gs_mountingFrame_depth,	1+32,
				rightWidth - gs_mountingFrame_width_right,	-gs_mountingFrame_depth,	1+32,
				rightWidth - gs_mountingFrame_width_right,	0,							1+32,
				rightWidth,									0,							1+32

			if lod2D_MountingFrame = 2 then
				line2 rightWidth,0,rightWidth - gs_mountingFrame_width_right,-gs_mountingFrame_depth
				line2 rightWidth,-gs_mountingFrame_depth,rightWidth - gs_mountingFrame_width_right,0
			endif
		endif
		pxR = rightWidth - gs_mountingFrame_width_right

		hotspot2 pxR, 0, 11051
	else
		pxR = rightWidth + bRightCornerFunction * rx * (WIDO_FRAME_THICKNESS + gs_mountingFrame_depth)
	endif

	pen gs_mountingFrame_pen_view
	line_property LINE_PROPERTY_GENERIC
	line2 pxL,-gs_mountingFrame_depth, pxR,-gs_mountingFrame_depth
	if bMountingFrame_DrawInsideLine then
		line2 pxL,0, pxR,0
	endif
return


! ==============================================================================
! Line - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12	line #1
!	x21,y21, x22,y22	line #2
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = valid intersection point
!	cx, cy:				intersection point
! ==============================================================================

100:
	lliDiv = (x11-x12) * (y21-y22) - (y11-y12) * (x21-x22)

	if abs(lliDiv) > EPS then
		! Intersection

		temp1 = x11 * y12 - y11 * x12
		temp2 = x21 * y22 - y21 * x22

		tempx = temp1 * (x21-x22) - (x11-x12) * temp2
		tempy = temp1 * (y21-y22) - (y11-y12) * temp2

		state = 1
		cx = (tempx / lliDiv)
		cy = (tempy / lliDiv)
	else
		! No Intersection
		state = 0
		cx = 0
		cy = 0
	endif
return


! ==============================================================================
! Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	xo,yo,ro:			circle
!	x1,y1, x2,y2		line
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = one intersection point (tangential line)
!						2 = two intersection points
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
! ==============================================================================

101:
	tempX1 = x1 - xo: tempY1 = y1 - yo
	tempX2 = x2 - xo: tempY2 = y2 - yo

	if abs(tempX2 - tempX1) < EPS then
		if abs(ro - abs(tempX1)) < EPS then
			state = 1
			xa = tempX1
			ya = 0
			xb = tempX1
			yb = 0
		else
			if abs(ro) - abs(tempX1) < 0 then
				state = 0: xa = 0: ya = 0: xb = 0: yb = 0
			else
				state = 2
				xa = tempX1
				ya = sqr(ro^2 - tempX1^2)
				xb = tempX1
				yb = -sqr(ro^2 - tempX1^2)
			endif
		endif
	else
		kf = (tempY2 - tempY1) / (tempX2 - tempX1)
		ad = 1 + kf^2
		bd = 2 * tempY1 * kf - 2 * tempX1 * kf^2
		cd = tempY1^2 - 2 * tempX1 * tempY1 * kf + tempX1^2 * kf^2 - ro^2

		if bd^2 - 4 * ad * cd < 0 then
			state = 0: xa = 0: ya = 0: xb = 0: yb = 0
		else
			xa = (-bd + sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			ya = tempY1 + (xa - tempX1) * kf
			xb = (-bd - sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			yb = tempY1 + (xb - tempX1) * kf

			if abs(xa - xb) < EPS then state = 1 else state = 2
		endif
	endif

	if state = 2 then
		da = sqr((tempX1 - xa)^2 + (tempY1 - ya)^2)
		db = sqr((tempX1 - xb)^2 + (tempY1 - yb)^2)

		if db < da then
			xxo = xa: yyo = ya
			xa = xb:  ya = yb
			xb = xxo: yb = yyo
		endif
	endif

	xa = xa + xo: ya = ya + yo
	xb = xb + xo: yb = yb + yo
return


! ==============================================================================
! Select good intersection point after Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	state:				intersection status
!	wallIsLeft:
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
!
! Returned variables:
!	cx, cy:				selected intersection point
! ==============================================================================

102:
	cx = 0
	cy = 0
	if state = 1 then
		cx = xa
		cy = ya
	endif
	if state = 2 then
		if wallIsLeft then
			if ya < yb then
				cx = xa
				cy = ya
			else
				cx = xb
				cy = yb
			endif
		else
			if ya > yb then
				cx = xa
				cy = ya
			else
				cx = xb
				cy = yb
			endif
		endif
	endif
return


! ==============================================================================
! Direction Angle
! ------------------------------------------------------------------------------
! Input variables:
!	vx, vy:				vector
!
! Returned variables:
!	alpha:				selected intersection point
! ==============================================================================

103:

if abs(vx) < EPS & abs(vy) < EPS then
	angle = 0
	return
endif

if abs(vx) < EPS then
	if vy > 0 then
		angle = 90
	else
		angle = 270
	endif
else
	angle = atn(vy / vx)
	if vx >= 0 then
		if angle < 0 then
			angle = angle + 360
		endif
	else
		angle = 180 + angle
	endif
endif

return




1000:
! ==============================================================================
! Get GDL Polygon
! ------------------------------------------------------------------------------
! Input variables:
!	polygonID:			Polygon index
!
! Returned variables:
!	GDL stack:			GDL polygon
! ==============================================================================

	_bValidPoly = 1

	dim resVertices[]
	numVertices = callfunction(ch, "GETVERTICES", polygonID, resVertices)
	numVertices = numVertices / 3

	dim contArr[]
	numContours = callfunction(ch, "GETCONTOURENDS", polygonID, contArr)

!!	dim inhEdgeInfos[]
!!	numEdges = callfunction(ch, "GetInhEdgeInfos", polygonID, inhEdgeInfos)

	for contIndex = 1 to numContours

		if contIndex = 1 then
			begIdx = 0
		else
			begIdx = contArr[contIndex] - 1
		endif
		if contIndex = numContours then
			endIdx = numVertices - 1
		else
			endIdx = contArr[contIndex + 1] - 2
		endif

		bClosed = 0
		bStartWithLast = 0

		index = endIdx * 3
		ac2gdl_lpx = resVertices[index + 1]
		ac2gdl_lpy = resVertices[index + 2]
		ac2gdl_lpa = resVertices[index + 3]
!!		edgeInfo	= inhEdgeInfos[endIdx + 1]

		if abs(ac2gdl_lpa) > EPS then
			if abs(ac2gdl_lpa - 360) > EPS then			!!! Valid Curved contour line (arc angle <> 360)
				put ac2gdl_lpx, ac2gdl_lpy, 1
				bStartWithLast = 1
			else										!!! Invalid Curved contour line (arc angle = 360)
				_bValidPoly = 0
			endif
		endif

		for vertIndex = begIdx to endIdx
			index = vertIndex * 3
			ac2gdl_px = resVertices[index + 1]
			ac2gdl_py = resVertices[index + 2]
			ac2gdl_pa = resVertices[index + 3]

			if vertIndex = begIdx then
				if bStartWithLast then
					ac2gdl_spx = ac2gdl_lpx
					ac2gdl_spy = ac2gdl_lpy
				else
					ac2gdl_spx = ac2gdl_px
					ac2gdl_spy = ac2gdl_py
				endif
			endif

			if abs(ac2gdl_lpa) > EPS then			!!! Curved contour line
				ac2gdl_mx = (ac2gdl_px + ac2gdl_lpx) / 2
				ac2gdl_my = (ac2gdl_py + ac2gdl_lpy) / 2
				ac2gdl_ratio = 1 / 2 / tan (ac2gdl_lpa / 2)

				ac2gdl_cx = ac2gdl_mx - ac2gdl_ratio * (ac2gdl_py - ac2gdl_lpy)	! Arc center
				ac2gdl_cy = ac2gdl_my + ac2gdl_ratio * (ac2gdl_px - ac2gdl_lpx)

				if abs(ac2gdl_lpa - 360) > EPS then
					put ac2gdl_cx,	ac2gdl_cy,	900,
						0,			ac2gdl_lpa,	4001
				endif
			endif

			if vertIndex > begIdx & bStartWithLast & abs(ac2gdl_spx - ac2gdl_px) < EPS & abs(ac2gdl_spy - ac2gdl_py) < EPS then
				put ac2gdl_px, ac2gdl_py, -1
				bClosed = 1
			else
				if vertIndex < endIdx | not(bStartWithLast) then
					put ac2gdl_px, ac2gdl_py, 1
				endif
			endif

			ac2gdl_lpx = ac2gdl_px
			ac2gdl_lpy = ac2gdl_py
			ac2gdl_lpa = ac2gdl_pa
!!			edgeInfo	= inhEdgeInfos[vertIndex + 1]
		next vertIndex

		if not(bClosed) & numContours > 1 then	! Close the polygon if it has holes
			put ac2gdl_spx, ac2gdl_spy, -1
		endif

		if not(_bValidPoly) then
			dim _invalidPoints[]
			for ii = 1 to nsp
				_invalidPoints[ii] = get(1)
			next ii

			contIndex = numContours
		endif
	next contIndex
return


1001:
! ==============================================================================
! Draw one polygon contour line
! ------------------------------------------------------------------------------
! Input variables:
!	polygonID:				Polygon ID
!	lineAttributes[][3]:	Line attribute array
!								[][1] = pen color
!								[][2] = line type
!								[][3] = line property
!								[][4] = additional line attributes
! bPutHotsopts:				Draw hotspots (boolean)
! polyUnID:					Hotspot start unID
! ==============================================================================

	dim resVertices[]
	numVertices = callfunction(ch, "GetVertices", polygonID, resVertices)
	numVertices = numVertices / 3

	dim contArr[]
	numContours = callfunction(ch, "GetContourEnds", polygonID, contArr)

	dim inhEdgeInfos[]
	numEdges = callfunction(ch, "GetInhEdgeInfos", polygonID, inhEdgeInfos)

	for contIndex = 1 to numContours

		if contIndex = 1 then
			begIdx = 0
		else
			begIdx = contArr[contIndex] - 1
		endif
		if contIndex = numContours then
			endIdx = numVertices - 1
		else
			endIdx = contArr[contIndex + 1] - 2
		endif

		bClosed = 0
		bStartWithLast = 0

		index = endIdx * 3
		lastVertX	= resVertices[index + 1]
		lastVertY	= resVertices[index + 2]
		lastVertA	= resVertices[index + 3]
		edgeInfo	= inhEdgeInfos[endIdx + 1]

		for vertIndex = begIdx to endIdx

			index = vertIndex * 3
			actVertX = resVertices[index + 1]
			actVertY = resVertices[index + 2]
			actVertA = resVertices[index + 3]

!!!text2	(lastVertX + actVertX) / 2,
!!!		(lastVertY + actVertY) / 2,
!!!		edgeInfo

!!!ccc=ccc+0.1
!!!circle2 lastVertX, lastVertY, ccc
!!!circle2 actVertX, actVertY, ccc

			if edgeInfo > 0 & edgeInfo <= vardim1(lineAttributes) then

				if lineAttributes[edgeInfo][1] > 0 then
					if not(gs_transom_display) then
						pen				lineAttributes[edgeInfo][1]
						line_type		lineAttributes[edgeInfo][2]
					else
						pen				gs_transom_display_pen
						line_type		gs_transom_display_linetype
					endif

					line_property	lineAttributes[edgeInfo][3]
					iAttributes = round_int(lineAttributes[edgeInfo][4])

					if abs(lastVertA) > EPS then
						ac2gdl_mx = (actVertX + lastVertX) / 2
						ac2gdl_my = (actVertY + lastVertY) / 2
						ac2gdl_ratio = 1 / 2 / tan (lastVertA / 2)

						ac2gdl_cx = ac2gdl_mx - ac2gdl_ratio * (actVertY - lastVertY)	! Arc center
						ac2gdl_cy = ac2gdl_my + ac2gdl_ratio * (actVertX - lastVertX)
						ac2gdl_rad = sqr((ac2gdl_cx - actVertX)^2 + (ac2gdl_cy - actVertY)^2)

						vx = actVertX - ac2gdl_cx
						vy = actVertY - ac2gdl_cy
						gosub 103	! Direction Angle
						alpha = angle

						vx = lastVertX - ac2gdl_cx
						vy = lastVertY - ac2gdl_cy
						gosub 103	! Direction Angle
						beta = angle

						if abs(alpha - beta) > EPS then
							if abs(alpha - beta) > 180 + EPS then
								angleStart	= max(alpha,beta)
								angleEnd	= min(alpha,beta)
							else
								angleStart	= min(alpha,beta)
								angleEnd	= max(alpha,beta)
							endif
							if bittest(iAttributes, LINE_ATTRIBUTES_GDLLINE) then
								if not(gs_transom_display) then 			! Not drawed when Display as Transom is ON
									arc2 ac2gdl_cx,	ac2gdl_cy, ac2gdl_rad, angleStart, angleEnd
								endif
							endif
							if bittest(iAttributes, LINE_ATTRIBUTES_WALLLINE) then
								if (GLOB_PREVIEW_MODE = 0) then
									arc2 ac2gdl_cx,	ac2gdl_cy, ac2gdl_rad, angleStart, angleEnd
								endif
								wallarc2 ac2gdl_cx,	ac2gdl_cy, ac2gdl_rad, angleStart, angleEnd
							endif
						endif
					else
						if bittest(iAttributes, LINE_ATTRIBUTES_GDLLINE) then
							if not(gs_transom_display) then 			! Not drawed when Display as Transom is ON
								line2 lastVertX, lastVertY, actVertX, actVertY
							endif
						endif
						if bittest(iAttributes, LINE_ATTRIBUTES_WALLLINE) then
							if (GLOB_PREVIEW_MODE = 0) then
								line2 lastVertX, lastVertY, actVertX, actVertY
							endif
							wallline2 lastVertX, lastVertY, actVertX, actVertY
						endif
					endif
				endif
			endif

			if bPutHotsopts & edgeInfo <> inhEdgeInfos[vertIndex + 1] then
				hotspot2 actVertX, actVertY, polyUnID: polyUnID = polyUnID + 1
!ccc=ccc+0.003
!circle2 actVertX, actVertY,ccc
			endif

			lastVertX	= actVertX
			lastVertY	= actVertY
			lastVertA	= actVertA
			edgeInfo	= inhEdgeInfos[vertIndex + 1]

		next vertIndex
	next contIndex
return

