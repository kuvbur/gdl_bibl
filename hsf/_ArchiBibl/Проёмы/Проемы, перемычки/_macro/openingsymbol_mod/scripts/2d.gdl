						if not(haskey(OPENING_SYMBOL_GEOMETRY.polygon2D)) | not(haskey(OPENING_SYMBOL_GEOMETRY.boundingBox2D)) then	endendifif GLOB_DIAGNOSTICS_MODE then gosub "diagnostics"BEGPOINT	= 1ENDPOINT	= 2! declarations of variables used in subroutines_polygonID = ""gosub "setAttributes"	! returns _fillAttributes for current OPENING_SYMBOL_DISPLAYgosub "setGeometry"		! returns _symbolPoly relevant to settingsgosub "draw"! =============================================================================end		! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end! =============================================================================! ============================================================================="setAttributes":! -----------------------------------------------------------------------------! returns _fillAttributes for current OPENING_SYMBOL_DISPLAY! -----------------------------------------------------------------------------! output:!	_fillAttributes!		.bg .fg					Fill1 is foreground, Fill2 is background!			.type!			.pen!			.bgPen!	_lineAttributes!		.type!		.pen!	_iOrientation				with flipHiddenOrientation modifications!	_drawContour! =============================================================================	dict _fillAttributes, _lineAttributes	if OPENING_SYMBOL_DISPLAY = SYMB_VISIBLE then		_fillAttributes.fg.type		= fill1Visible		_fillAttributes.fg.pen		= fill1PenVisible		_fillAttributes.fg.bgPen	= fill1BgpenVisible		_fillAttributes.bg.type		= fill2Visible		_fillAttributes.bg.pen		= fill2PenVisible		_fillAttributes.bg.bgPen	= fill2BgpenVisible		_lineAttributes.pen			= penVisible		_lineAttributes.type		= lineVisible		_drawContour				= drawContourVisible | _symbol.forceShowContour		_iOrientation				= iOrientation	endif	if OPENING_SYMBOL_DISPLAY = SYMB_HIDDEN | OPENING_SYMBOL_DISPLAY = SYMB_OVERHEAD then		_fillAttributes.fg.type		= fill1Hidden		_fillAttributes.fg.pen		= fill1PenHidden		_fillAttributes.fg.bgPen	= fill1BgpenHidden		_fillAttributes.bg.type		= fill2Hidden		_fillAttributes.bg.pen		= fill2PenHidden		_fillAttributes.bg.bgPen	= fill2BgpenHidden		_lineAttributes.pen			= penHidden		_lineAttributes.type		= lineHidden		_drawContour				= drawContourHidden | _symbol.forceShowContour		if flipHiddenOrientation & (_symbol.type # SYMBOL_X) then ! flip orientation			if _symbol.type = SYMBOL_DIAG then				_iOrientation = ORIENT_UPRIGHT + ORIENT_DOWNRIGHT - iOrientation			else	! SYMBOL_BREAK | SYMBOL_SHADOW				if iOrientation = ORIENT_UPRIGHT_FILL1LEFT then _iOrientation = ORIENT_UPRIGHT_FILL1RIGHT				if iOrientation = ORIENT_UPRIGHT_FILL1RIGHT then _iOrientation = ORIENT_UPRIGHT_FILL1LEFT				if iOrientation = ORIENT_DOWNRIGHT_FILL1LEFT then _iOrientation = ORIENT_DOWNRIGHT_FILL1RIGHT				if iOrientation = ORIENT_DOWNRIGHT_FILL1RIGHT then _iOrientation = ORIENT_DOWNRIGHT_FILL1LEFT			endif		else			_iOrientation = iOrientation		endif	endifreturn! ============================================================================="setGeometry":! -----------------------------------------------------------------------------! returns global or custom coordinates to use,!	and fixed topology regardless of orientation! -----------------------------------------------------------------------------! output:!	_symbolPoly				contour!		.regularized!		.PO!			.isClosed!			.contour!				.edges[]!					.type		0 straight 1 arced!					.begPoint!					.arcAngle	when .type = 1!	_boundingBox!		.xmin .ymin!		.xmax .ymax!	_boundingboxPoly		bounding box as polygon!	_symbolRim				polygon between OPENING_SYMBOL_GEOMETRY.boundingBox2D, and shrunk _symbolPoly!								empty polygon in case of GLOB_DIAGNOSTICS_MODE!	_diagonalPoly			polygon on diagonals!								non-rectangle when _symbolPoly has 4 vertices!	_diagTopology			order of relevant points on _diagonalPoly!		.diagonals[]!			.ends[2]			beg, end!			.role			maps to _diagTopology.directions[] (only for SYMBOL_X | SMYBOL_X_2FILL)!	_diagVectors			direction vectors of diagonals (only for SYMBOL_X | SMYBOL_X_2FILL)!		.directions[]!	_isCurvedRectangle!	_has4Edges!	_isAllArced! =============================================================================	dict _boundingBox, _boundingboxPoly, _diagonalPoly, _symbolPoly	_boundingBox = OPENING_SYMBOL_GEOMETRY.boundingBox2D	! _boundingboxPoly from original boundingBox	dict _symbolRim	gosub "createBoundingBoxPoly"	! returns _boundingboxPoly	_symbolRim = _boundingboxPoly	! shrink contour	_symbolPoly.PO			= OPENING_SYMBOL_GEOMETRY.polygon2D	_symbolPoly.regularized	= 1		if shrinkOffset > 0 then		gosub "shrinkSymbol"	! returns _boundingBox, _symbolPoly		! _symbolRim hole is shrunk contour - reverse to be regularized		_nEdge = vardim1(_symbolPoly.PO.contour.edges)		for _iEdge = 1 to _nEdge			! begpoint is same			_symbolRim.PO.holes[1].edges[_iEdge].begPoint		= _symbolPoly.PO.contour.edges[(_nEdge - _iEdge + 1) % _nEdge + 1].begPoint			! type and angle according to next point			_symbolRim.PO.holes[1].edges[_iEdge].type			= _symbolPoly.PO.contour.edges[(_nEdge - _iEdge) % _nEdge + 1].type			if _symbolRim.PO.holes[1].edges[_iEdge].type = EDGE_CURVED then				_symbolRim.PO.holes[1].edges[_iEdge].arcAngle	= -_symbolPoly.PO.contour.edges[(_nEdge - _iEdge) % _nEdge + 1].arcAngle			endif		next _iEdge	endif	! _boundingboxPoly from shrunk _boundingBox	gosub "createBoundingBoxPoly"	! returns _boundingboxPoly	! diagonals	_needToFixDiagonalOrientation = (_symbol.type = SYMBOL_X)	_has4Edges = (vardim1(_symbolPoly.PO.contour.edges) = 4)	_isAllArced = _has4Edges	! only relevant with _has4Edges	if _has4Edges then 			! check if all edges are curved (probably a circle)		for _i = 1 to 4			_isAllArced = _isAllArced & (_symbolPoly.PO.contour.edges[_i].type = EDGE_CURVED)		next _i	endif	if _has4Edges & not(_isAllArced) then	! auto qaudrilateral		_diagonalPoly = _symbolPoly		_needToFixDiagonalOrientation = 1 	! doesn't necessarily match orientation of boundingbox	else									! use boundingbox for diagonals		_diagonalPoly = _boundingboxPoly	endif	! check if opposite edges are curved / straight respectively	_isCurvedRectangle = 0	if _has4Edges then		dict _contour : _contour = _symbolPoly.PO.contour		_isCurvedRectangle =  (  _contour.edges[1].type = _contour.edges[3].type &\								 _contour.edges[2].type = _contour.edges[4].type &\								 _contour.edges[1].type # _contour.edges[2].type &\								(_contour.edges[1].type = EDGE_CURVED   | _contour.edges[2].type = EDGE_CURVED)	&\								(_contour.edges[1].type = EDGE_STRAIGHT | _contour.edges[2].type = EDGE_STRAIGHT) )	endif	! automatic orientation for diagonals	if _needToFixDiagonalOrientation then		! direction vector of diagonals		dict _diagVectors		for _iDiag = 1 to 2			dict _direction			dict _pointFrom, _pointTo			_pointFrom		= _diagonalPoly.PO.contour.edges[_iDiag].begPoint			_pointFrom.z	= 0			_pointTo		= _diagonalPoly.PO.contour.edges[_iDiag + 2].begPoint			_pointTo.z		= 0			call "BasicGeometry_25" parameters	iFunction	= BasicGeometry_25.DIRECTION_POINTS_3D,											PointFrom	= _pointFrom,											PointTo		= _pointTo,								returned_parameters 	_direction,														_unused				! length			_diagVectors.directions[_iDiag] = _direction		next _iDiag		! fix orientation of diagonals		for _iDiag = 1 to 2			! flip if vy < 0 -> will go up			if _diagVectors.directions[_iDiag].uy < 0 then				! reverse vector				_diagVectors.directions[_iDiag].ux = -_diagVectors.directions[_iDiag].ux				_diagVectors.directions[_iDiag].uy = -_diagVectors.directions[_iDiag].uy				! swap points (all edges are straight)				dict _tempPoint				_tempPoint											= _diagonalPoly.PO.contour.edges[_iDiag].begPoint				_diagonalPoly.PO.contour.edges[_iDiag].begPoint		= _diagonalPoly.PO.contour.edges[_iDiag + 2].begPoint				_diagonalPoly.PO.contour.edges[_iDiag + 2].begPoint	= _tempPoint			endif		next _iDiag		! swap diagonals if first is less rightward-y (steeper) than second		if _diagVectors.directions[1].ux < _diagVectors.directions[2].ux then			! swap vectors			dict _tempDirection			_tempDirection				= _diagVectors.directions[1]			_diagVectors.directions[1]	= _diagVectors.directions[2]			_diagVectors.directions[2]	= _tempDirection			! swap points (all edges are straight)			for _iPoint = 1 to 3 step 2				dict _tempPoint				_tempPoint												= _diagonalPoly.PO.contour.edges[_iPoint].begPoint				_diagonalPoly.PO.contour.edges[_iPoint].begPoint		= _diagonalPoly.PO.contour.edges[_iPoint + 1].begPoint				_diagonalPoly.PO.contour.edges[_iPoint + 1].begPoint	= _tempPoint			next _iPoint		endif	endif	! order of relevant points on _diagonalPoly.PO.contour.edges[]	dict _diagTopology, _diag1, _diag2	if _symbol.type = SYMBOL_DIAG then		if _iOrientation = ORIENT_UPRIGHT then			_diag1.ends[BEGPOINT]	= 1			_diag1.ends[ENDPOINT]	= 3			_diag2.ends[BEGPOINT]	= 4			_diag2.ends[ENDPOINT]	= 2		else			! ORIENT_DOWNRIGHT			_diag1.ends[BEGPOINT]	= 4			_diag1.ends[ENDPOINT]	= 2			_diag2.ends[BEGPOINT]	= 3			_diag2.ends[ENDPOINT]	= 1		endif	endif	if _symbol.type = SYMBOL_X then		if _iOrientation = ORIENT_FILL1SIDE then			_diag1.ends[BEGPOINT]	= 1		! maps to _diagonalPoly.PO.contour.edges[]			_diag1.ends[ENDPOINT]	= 3			_diag2.ends[BEGPOINT]	= 4			_diag2.ends[ENDPOINT]	= 2			_diag1.role				= 1		! maps to _diagVectors.directions[]			_diag2.role				= 2		else			! ORIENT_FILL1TOP			_diag1.ends[BEGPOINT]	= 2		! maps to _diagonalPoly.PO.contour.edges[]			_diag1.ends[ENDPOINT]	= 4			_diag2.ends[BEGPOINT]	= 1			_diag2.ends[ENDPOINT]	= 3			_diag1.role				= 2		! maps to _diagVectors.directions[]			_diag2.role				= 1		endif	endif	if _symbol.type = SYMBOL_BREAK | _symbol.type = SYMBOL_SHADOW then		if _iOrientation = ORIENT_UPRIGHT_FILL1LEFT then			_diag1.ends[BEGPOINT]	= 1			_diag1.ends[ENDPOINT]	= 3			_diag2.ends[BEGPOINT]	= 4			_diag2.ends[ENDPOINT]	= 2		endif		if _iOrientation = ORIENT_UPRIGHT_FILL1RIGHT then			_diag1.ends[BEGPOINT]	= 3			_diag1.ends[ENDPOINT]	= 1			_diag2.ends[BEGPOINT]	= 2			_diag2.ends[ENDPOINT]	= 4		endif		if _iOrientation = ORIENT_DOWNRIGHT_FILL1LEFT then			_diag1.ends[BEGPOINT]	= 2			_diag1.ends[ENDPOINT]	= 4			_diag2.ends[BEGPOINT]	= 1			_diag2.ends[ENDPOINT]	= 3		endif		if _iOrientation = ORIENT_DOWNRIGHT_FILL1RIGHT then			_diag1.ends[BEGPOINT]	= 4			_diag1.ends[ENDPOINT]	= 2			_diag2.ends[BEGPOINT]	= 3			_diag2.ends[ENDPOINT]	= 1		endif	endif	_diagTopology.diagonals[1] = _diag1	_diagTopology.diagonals[2] = _diag2return! ============================================================================="draw":! -----------------------------------------------------------------------------! input:!	_lineAttributes					Line parameters!	_fillAttributes					Fill parameters!	from "setGeometry":!		_symbolPoly!			.regularized!			.PO!				.isClosed!				.contour!					.edges[]!						.type		0 straight 1 arced!						.begPoint!						.arcAngle	when .type = 1!		_symbolRim					polygon between OPENING_SYMBOL_GEOMETRY.boundingBox2D and shrunk _symbolPoly!										empty polygon in case of GLOB_DIAGNOSTICS_MODE!		_diagonalPoly!		_diagVectors				unit vectors along diagonals!			.directions[]!		_boundingboxPoly			bounding box as polygon!		_diagTopology				order of relevant points on _diagonalPoly!			.diagonals[]!				.ends[]! =============================================================================	dict _useFillAttributes, _status		! set and used in subroutines	! predefined statuses for poly2_b	dict _statusContour, _statusFill, _statusContourFill	_statusContour.contour 		= 1	_statusContour.fill			= 0	_statusContour.autoClose	= 1	_statusFill.contour 		= 0	_statusFill.fill			= 1	_statusFill.autoClose		= 1	_statusContourFill.contour 	= 1	_statusContourFill.fill		= 1	_statusContourFill.autoClose= 1	_status = _statusContour	! unshrunk contour	! show only as reference, normally element draws it	if GLOB_PREVIEW_MODE = 1 | (GLOB_DIAGNOSTICS_MODE & bShowDiagnostics) then	! show unshrunk contour		dict _polygon		_polygon.PO				= OPENING_SYMBOL_GEOMETRY.polygon2D		_polygon.regularized	= 1		_unused = removekey(_polygon.PO.holes)	! contour only		_drawAsPolyline	= 0		gosub "drawPolygon"	endif	if vardim1(_symbolPoly.PO.contour.edges) > 0 then				! shrunk contour		if shrinkOffset > 0 & _drawContour then			gosub "drawSymbolContour"		endif			! inside		if _symbol.type = SYMBOL_DIAG	then gosub "drawDiagonalType"		if _symbol.type = SYMBOL_X		then gosub "drawXType"		if _symbol.type = SYMBOL_BREAK	then gosub "drawBreakType"		if _symbol.type = SYMBOL_SHADOW	then gosub "drawShadowType"	endifreturn! ============================================================================="drawDiagonalType":! -----------------------------------------------------------------------------! input:!	_lineAttributes					Line parameters!	_fillAttributes					Fill parameters!	from "setGeometry":!		_symbolPoly!			.regularized!			.PO!				.isClosed!				.contour!					.edges[]!						.type		0 straight 1 arced!						.begPoint!						.arcAngle	when .type = 1!		_diagTopology				order of relevant points on _diagonalPoly!			.diagonals[]!				.ends[]!		_diagonalPoly!		_boundingboxPoly			bounding box as polygon! =============================================================================	! compute midpoint of _symbolPoly for curved diagonals	dict _midPoint	if _isCurvedRectangle then		gosub "getMidPoint"	! returns _midPoint		!circle2 _midPoint.x, _midPoint.y, 0.01	endif	dict _diag1, _diag2	_diag1.beg	= _diagTopology.diagonals[1].ends[BEGPOINT]	_diag1.end	= _diagTopology.diagonals[1].ends[ENDPOINT]	_diag2.beg	= _diagTopology.diagonals[2].ends[BEGPOINT]	_diag2.end	= _diagTopology.diagonals[2].ends[ENDPOINT]	pen			_lineAttributes.pen	line_type	_lineAttributes.type	dict _diagonalArc	_useCurvedDiagonal = 0	if _isCurvedRectangle then	! curved diagonals		! create arc from three points		dict _onArc, _arc		_onArc.points[1] = _diagonalPoly.PO.contour.edges[_diag1.beg].begPoint		_onArc.points[2] = _midPoint		_onArc.points[3] = _diagonalPoly.PO.contour.edges[_diag1.end].begPoint		dict _diagonalArc		call "BasicGeometry_25" parameters	iFunction	= BasicGeometry_25.ARC_THROUGH_POINTS_2D,										points2D	= _onArc,							returned_parameters		_diagonalArc		! returns .exists, .center, .radius, .begAngle, .midAngle, .endAngle		if _diagonalArc.exists then			_useCurvedDiagonal = 1			! arc angle from beginning to end (0 or 360 arc not possible, beginning and end aren't the same)			_diagonalArc.angle	= _diagonalArc.endAngle - _diagonalArc.begAngle		endif	endif	if not(_useCurvedDiagonal) then	_diagonalArc.angle = 0.0	! inner lines	if _drawContour then		! put poPoly		put	_diagonalPoly.PO.contour.edges[_diag1.beg].begPoint.x, _diagonalPoly.PO.contour.edges[_diag1.beg].begPoint.y, _diagonalArc.angle,			_diagonalPoly.PO.contour.edges[_diag1.end].begPoint.x, _diagonalPoly.PO.contour.edges[_diag1.end].begPoint.y, 0			dict _polygon		gosub "getIntoPolygon"	! fills _polygon.PO.contour.edges[]			_polygon.PO.isClosed					= 0		gosub "clip_and_DrawPolyline"	endif	! fills	_status = _statusFill	if not(_symbol.hasTwoFills) then				if drawFill2 then	! has only "background" fill			_useFillAttributes = _fillAttributes.bg			gosub "drawSymbolContour"		endif	else		if drawFill1 then			! put poPoly			put	_boundingboxPoly.PO.contour.edges[_diag1.beg].begPoint.x, _boundingboxPoly.PO.contour.edges[_diag1.beg].begPoint.y, 0,				_diagonalPoly.PO.contour.edges   [_diag1.beg].begPoint.x, _diagonalPoly.PO.contour.edges   [_diag1.beg].begPoint.y, _diagonalArc.angle,				_diagonalPoly.PO.contour.edges   [_diag1.end].begPoint.x, _diagonalPoly.PO.contour.edges   [_diag1.end].begPoint.y, 0,				_boundingboxPoly.PO.contour.edges[_diag1.end].begPoint.x, _boundingboxPoly.PO.contour.edges[_diag1.end].begPoint.y, 0,				_boundingboxPoly.PO.contour.edges[_diag2.beg].begPoint.x, _boundingboxPoly.PO.contour.edges[_diag2.beg].begPoint.y, 0			dict _polygon			gosub "getIntoPolygon"	! fills _polygon.PO.contour.edges[]			_polygon.PO.isClosed = 1			_polygon.regularized = 0		! needs regularization			_useFillAttributes = _fillAttributes.fg			gosub "clip_and_DrawPolygon"		endif		if drawFill2 then			! put poPoly			put	_boundingboxPoly.PO.contour.edges[_diag1.beg].begPoint.x, _boundingboxPoly.PO.contour.edges[_diag1.beg].begPoint.y, 0,				_boundingboxPoly.PO.contour.edges[_diag2.end].begPoint.x, _boundingboxPoly.PO.contour.edges[_diag2.end].begPoint.y, 0,				_boundingboxPoly.PO.contour.edges[_diag1.end].begPoint.x, _boundingboxPoly.PO.contour.edges[_diag1.end].begPoint.y, 0,				_diagonalPoly.PO.contour.edges   [_diag1.end].begPoint.x, _diagonalPoly.PO.contour.edges   [_diag1.end].begPoint.y, -_diagonalArc.angle,				_diagonalPoly.PO.contour.edges   [_diag1.beg].begPoint.x, _diagonalPoly.PO.contour.edges   [_diag1.beg].begPoint.y, 0			dict _polygon			gosub "getIntoPolygon"	! fills _polygon.PO.contour.edges[]			_polygon.PO.isClosed = 1			_polygon.regularized = 0		! needs regularization			_useFillAttributes = _fillAttributes.bg			gosub "clip_and_DrawPolygon"		endif	endifreturn! ============================================================================="drawXType":! -----------------------------------------------------------------------------! input:!	_lineAttributes					Line parameters!	_fillAttributes					Fill parameters!	from "setGeometry":!		_symbolPoly!			.regularized!			.PO!				.isClosed!				.contour!					.edges[]!						.type		0 straight 1 arced!						.begPoint!						.arcAngle	when .type = 1!		_diagonalPoly!		_boundingboxPoly			bounding box as polygon!		_diagTopology				order of relevant points on _diagonalPoly!			.diagonals[]!				.ends[]!				.role				maps to _diagVectors.directions[]!		_diagVectors				unit vectors along diagonals!			.directions[]! =============================================================================	! compute midpoint of _symbolPoly for curved diagonals	dict _midPoint	if _isCurvedRectangle then		gosub "getMidPoint"	! returns _midPoint		!circle2 _midPoint.x, _midPoint.y, 0.01	endif	dict _diag1, _diag2	_diag1		= _diagTopology.diagonals[1]	_diag1.beg	= _diag1.ends[BEGPOINT]	_diag1.end	= _diag1.ends[ENDPOINT]	_diag2		= _diagTopology.diagonals[2]	_diag2.beg	= _diag2.ends[BEGPOINT]	_diag2.end	= _diag2.ends[ENDPOINT]	! diagonals	pen			_lineAttributes.pen	line_type	_lineAttributes.type	dict _diagonalArcs	dim _useCurvedDiagonal[2]	_useCurvedDiagonal[1] = 0	_useCurvedDiagonal[2] = 0	if _isCurvedRectangle then	! curved diagonals			for _iDiag = 1 to 2			dict _diag			_diag.beg	= _diagTopology.diagonals[_iDiag].ends[BEGPOINT]			_diag.end	= _diagTopology.diagonals[_iDiag].ends[ENDPOINT]			! create arc from three points			dict _onArc			_onArc.points[1] = _diagonalPoly.PO.contour.edges[_diag.beg].begPoint			_onArc.points[2] = _midPoint			_onArc.points[3] = _diagonalPoly.PO.contour.edges[_diag.end].begPoint			dict _diagonalArc			call "BasicGeometry_25" parameters	iFunction	= BasicGeometry_25.ARC_THROUGH_POINTS_2D,											points2D	= _onArc,								returned_parameters		_diagonalArc			! returns .exists, .center, .radius, .begAngle, .midAngle, .endAngle					if _diagonalArc.exists then				_useCurvedDiagonal[_iDiag] = 1				! arc angle from beginning to end (0 or 360 arc not possible, beginning and end aren't the same)				_diagonalArc.angle			= _diagonalArc.endAngle - _diagonalArc.begAngle				_diagonalArc.partAngle[1]	= _diagonalArc.midAngle - _diagonalArc.begAngle				_diagonalArc.partAngle[2]	= _diagonalArc.endAngle - _diagonalArc.midAngle			endif			_diagonalArcs.diagonal[_iDiag] = _diagonalArc		next _iDiag	endif		if not(_useCurvedDiagonal[1] | _useCurvedDiagonal[2]) then		! both diagonals straight, compute intersection point		if _symbol.hasTwoFills then			! intersection of two diagonals - only needed for fills			dict _lineA, _lineB			_lineA.point		= _diagonalPoly.PO.contour.edges[_diag1.beg].begPoint			_lineA.direction	= _diagVectors.directions[_diag1.role]			_lineB.point		= _diagonalPoly.PO.contour.edges[_diag2.beg].begPoint			_lineB.direction	= _diagVectors.directions[_diag2.role]			dict _intersection			call "BasicGeometry_25" parameters	iFunction	= BasicGeometry_25.INTERSECT_LINE_LINE_2D,											lineA		= _lineA,											lineB		= _lineB,								returned_parameters		_intersection			if vardim1(_intersection.points) = 1 then				_midPoint = _intersection.points[1]			else				! centre of gravity of diagonal boundingbox				_midPoint.x = (	_diagonalPoly.PO.contour.edges[1].begPoint.x +	\								_diagonalPoly.PO.contour.edges[2].begPoint.x +	\								_diagonalPoly.PO.contour.edges[3].begPoint.x +	\								_diagonalPoly.PO.contour.edges[4].begPoint.x	) / 4				_midPoint.y = (	_diagonalPoly.PO.contour.edges[1].begPoint.y +	\								_diagonalPoly.PO.contour.edges[2].begPoint.y +	\								_diagonalPoly.PO.contour.edges[3].begPoint.y +	\								_diagonalPoly.PO.contour.edges[4].begPoint.y	) / 4			endif		endif	endif	for _iDiag = 1 to 2		if not(_useCurvedDiagonal[_iDiag]) then			_diagonalArcs.diagonal[_iDiag].angle = 0			_diagonalArcs.diagonal[_iDiag].partAngle[1] = 0			_diagonalArcs.diagonal[_iDiag].partAngle[2] = 0		endif	next _iDiag	! inner lines	if _drawContour then		for _iDiag = 1 to 2			dict _diag			_diag.beg	= _diagTopology.diagonals[_iDiag].ends[BEGPOINT]			_diag.end	= _diagTopology.diagonals[_iDiag].ends[ENDPOINT]				! put poPoly			put	_diagonalPoly.PO.contour.edges[_diag.beg].begPoint.x, _diagonalPoly.PO.contour.edges[_diag.beg].begPoint.y, _diagonalArcs.diagonal[_iDiag].angle, 				_diagonalPoly.PO.contour.edges[_diag.end].begPoint.x, _diagonalPoly.PO.contour.edges[_diag.end].begPoint.y, 0				dict _polygon			gosub "getIntoPolygon"	! fills _polygon.PO.contour.edges[]				_polygon.PO.isClosed					= 0			gosub "clip_and_DrawPolyline"			next _iDiag	endif	! fills	_status = _statusFill	if not(_symbol.hasTwoFills) then		if drawFill2 then	! has only "background" fill			_useFillAttributes = _fillAttributes.bg			gosub "drawSymbolContour"		endif	else				dict _diagonalArc1, _diagonalArc2		_diagonalArc1 = _diagonalArcs.diagonal[1]		_diagonalArc2 = _diagonalArcs.diagonal[2]		if drawFill1 then			_useFillAttributes = _fillAttributes.fg			! two triangles defined by intersection and same endpoints of diagonals			for _iEnd = BEGPOINT to ENDPOINT	! 1 to 2				_sgnArc = 3 - 2 * _iEnd	! beg -> 1	end -> -1				! put poPoly				put	_boundingboxPoly.PO.contour.edges[_diag1.ends[_iEnd]].begPoint.x,	_boundingboxPoly.PO.contour.edges[_diag1.ends[_iEnd]].begPoint.y,	0,					_diagonalPoly.PO.contour.edges   [_diag1.ends[_iEnd]].begPoint.x,	_diagonalPoly.PO.contour.edges   [_diag1.ends[_iEnd]].begPoint.y,						_useCurvedDiagonal[1] * _sgnArc * _diagonalArc1.partAngle[_iEnd],					_midPoint.x,														_midPoint.y,						_useCurvedDiagonal[2] * (-_sgnArc * _diagonalArc2.partAngle[_iEnd]),					_diagonalPoly.PO.contour.edges[_diag2.ends[_iEnd]].begPoint.x,		_diagonalPoly.PO.contour.edges   [_diag2.ends[_iEnd]].begPoint.y,	0,					_boundingboxPoly.PO.contour.edges[_diag2.ends[_iEnd]].begPoint.x,	_boundingboxPoly.PO.contour.edges[_diag2.ends[_iEnd]].begPoint.y,	0				dict _polygon				gosub "getIntoPolygon"	! fills _polygon.PO.contour.edges[]				_polygon.PO.isClosed = 1				_polygon.regularized = 0		! needs regularization				gosub "clip_and_DrawPolygon"			next _iEnd		endif		if drawFill2 then			_useFillAttributes = _fillAttributes.bg			! two triangles defined by intersection and different endpoints of diagonals			for _iEnd = BEGPOINT to ENDPOINT	! 1 to 2				_iOtherEnd = BEGPOINT + ENDPOINT - _iEnd				_sgnArc = 3 - 2 * _iEnd	! beg -> 1	end -> -1				! put poPoly				put	_boundingboxPoly.PO.contour.edges[_diag2.ends[_iEnd]].begPoint.x,		_boundingboxPoly.PO.contour.edges[_diag2.ends[_iEnd]].begPoint.y,		0,					_diagonalPoly.PO.contour.edges   [_diag2.ends[_iEnd]].begPoint.x,		_diagonalPoly.PO.contour.edges   [_diag2.ends[_iEnd]].begPoint.y,						_useCurvedDiagonal[2] * _sgnArc * _diagonalArc2.partAngle[_iEnd],					_midPoint.x,															_midPoint.y,						_useCurvedDiagonal[1] * _sgnArc * _diagonalArc1.partAngle[_iOtherEnd],					_diagonalPoly.PO.contour.edges	 [_diag1.ends[_iOtherEnd]].begPoint.x,	_diagonalPoly.PO.contour.edges	 [_diag1.ends[_iOtherEnd]].begPoint.y,	0,					_boundingboxPoly.PO.contour.edges[_diag1.ends[_iOtherEnd]].begPoint.x,	_boundingboxPoly.PO.contour.edges[_diag1.ends[_iOtherEnd]].begPoint.y,	0				dict _polygon				gosub "getIntoPolygon"	! fills _polygon.PO.contour.edges[]				_polygon.PO.isClosed = 1				_polygon.regularized = 0		! needs regularization				gosub "clip_and_DrawPolygon"			next _iEnd		endif	endifreturn! ============================================================================="drawBreakType":! -----------------------------------------------------------------------------! input:!	_lineAttributes					Line parameters!	_fillAttributes					Fill parameters!	from "setGeometry":!		_symbolPoly!			.regularized!			.PO!				.isClosed!				.contour!					.edges[]!						.type		0 straight 1 arced!						.begPoint!						.arcAngle	when .type = 1!		_diagonalPoly!		_boundingboxPoly			bounding box as polygon!		_diagTopology				order of relevant points on _diagonalPoly!			.diagonals[]!				.ends[]!				.role				maps to _diagVectors.directions[]!		_diagVectors!			.directions[]! =============================================================================	dict _diag1, _diag2	_diag1.beg	= _diagTopology.diagonals[1].ends[BEGPOINT]	_diag1.end	= _diagTopology.diagonals[1].ends[ENDPOINT]	_diag2.beg	= _diagTopology.diagonals[2].ends[BEGPOINT]	_diag2.end	= _diagTopology.diagonals[2].ends[ENDPOINT]	! param editing of breakpoint	dict _break	gosub "editBreakPoint"	! returns _break	! inner lines	if _drawContour then		pen			_lineAttributes.pen		line_type	_lineAttributes.type			! put poPoly		put	_diagonalPoly.PO.contour.edges[_diag1.beg].begPoint.x,	_diagonalPoly.PO.contour.edges[_diag1.beg].begPoint.y,	0,			_break.point.x,											_break.point.y,											0,			_diagonalPoly.PO.contour.edges[_diag1.end].begPoint.x,	_diagonalPoly.PO.contour.edges[_diag1.end].begPoint.y,	0			dict _polygon		gosub "getIntoPolygon"	! fills _polygon.PO.contour.edges[]			_polygon.PO.isClosed = 0		gosub "clip_and_DrawPolyline"	endif		! fills	_status = _statusFill	if not(_symbol.hasTwoFills) then				if drawFill2 then	! has only "background" fill			_useFillAttributes = _fillAttributes.bg			gosub "drawSymbolContour"		endif		else		if drawFill1 then			! put poPoly			put	_boundingboxPoly.PO.contour.edges[_diag1.beg].begPoint.x,	_boundingboxPoly.PO.contour.edges[_diag1.beg].begPoint.y,	0,				_diagonalPoly.PO.contour.edges   [_diag1.beg].begPoint.x,	_diagonalPoly.PO.contour.edges   [_diag1.beg].begPoint.y,	0,				_break.point.x,												_break.point.y,												0,				_diagonalPoly.PO.contour.edges   [_diag1.end].begPoint.x,	_diagonalPoly.PO.contour.edges   [_diag1.end].begPoint.y,	0,				_boundingboxPoly.PO.contour.edges[_diag1.end].begPoint.x,	_boundingboxPoly.PO.contour.edges[_diag1.end].begPoint.y,	0,				_boundingboxPoly.PO.contour.edges[_diag2.beg].begPoint.x,	_boundingboxPoly.PO.contour.edges[_diag2.beg].begPoint.y,	0							dict _polygon			gosub "getIntoPolygon"	! fills _polygon.PO.contour.edges[]			_polygon.PO.isClosed = 1			_polygon.regularized = 0		! needs regularization			_useFillAttributes = _fillAttributes.fg			gosub "clip_and_DrawPolygon"		endif		if drawFill2 then			! put poPoly			put	_diagonalPoly.PO.contour.edges   [_diag1.beg].begPoint.x,	_diagonalPoly.PO.contour.edges   [_diag1.beg].begPoint.y,	0,				_boundingboxPoly.PO.contour.edges[_diag1.beg].begPoint.x,	_boundingboxPoly.PO.contour.edges[_diag1.beg].begPoint.y,	0,				_boundingboxPoly.PO.contour.edges[_diag2.end].begPoint.x,	_boundingboxPoly.PO.contour.edges[_diag2.end].begPoint.y,	0,				_boundingboxPoly.PO.contour.edges[_diag1.end].begPoint.x,	_boundingboxPoly.PO.contour.edges[_diag1.end].begPoint.y,	0,				_diagonalPoly.PO.contour.edges   [_diag1.end].begPoint.x,	_diagonalPoly.PO.contour.edges   [_diag1.end].begPoint.y,	0,				_break.point.x,												_break.point.y,												0							dict _polygon			gosub "getIntoPolygon"	! fills _polygon.PO.contour.edges[]			_polygon.PO.isClosed = 1			_polygon.regularized = 0		! needs regularization			_useFillAttributes = _fillAttributes.bg			gosub "clip_and_DrawPolygon"		endif	endifreturn! ============================================================================="drawShadowType":! -----------------------------------------------------------------------------! input:!	_lineAttributes					Line parameters!	_fillAttributes					Fill parameters!	from "setGeometry":!		_symbolPoly!			.regularized!			.PO!				.isClosed!				.contour!					.edges[]!						.type		0 straight 1 arced!						.begPoint!						.arcAngle	when .type = 1!		_diagonalPoly!		_boundingboxPoly			bounding box as polygon!		_diagTopology				order of relevant points on _diagonalPoly!			.diagonals[]!				.ends[]! =============================================================================	dict _diag1, _diag2	_diag1.beg	= _diagTopology.diagonals[1].ends[BEGPOINT]	_diag1.end	= _diagTopology.diagonals[1].ends[ENDPOINT]	_diag2.beg	= _diagTopology.diagonals[2].ends[BEGPOINT]	_diag2.end	= _diagTopology.diagonals[2].ends[ENDPOINT]	! portal type - easter egg, waiting for fix of 258038	!_bbw = abs(OPENING_SYMBOL_GEOMETRY.boundingBox2D.xmax - OPENING_SYMBOL_GEOMETRY.boundingBox2D.xmin)	!_bbh = abs(OPENING_SYMBOL_GEOMETRY.boundingBox2D.ymax - OPENING_SYMBOL_GEOMETRY.boundingBox2D.ymin)	!if	(abs(min(_bbw, _bbh) / max(_bbw, _bbh) - 0.57) < EPS) &\	!	(_symbol.hasTwoFills & (drawFill2 + drawFill1) = 1) &\	!	(percBreakpoint = 0) \	!then	!	_isAllArced = 1	!	for _i = 1 to vardim1(_symbolPoly.PO.contour.edges)	!		_isAllArced = _isAllArced & (_symbolPoly.PO.contour.edges[_i].type = EDGE_CURVED)	!	next _i	!	!	if _isAllArced then	!		if drawFill1 then	!			_GLaDOS.version = 1	!		else	!			_GLaDOS.version = 2	!		endif	!	!		gosub "drawPortal"	!		return	!	endif	!endif	! param editing of shadow offset	gosub "editBreakPoint"	! returns _break	dict _offset : _offset = _break.offset	! _shadow polygons	dict _shadow	gosub "createShadow"			! returns _shadow	! unify _shadow polygons into _shadowed, and subtract from _symbolPoly as _unshadowed	dict _shadowed, _unshadowed	gosub "createShadowedPoly"		! returns _shadowed.polygons[], _unshadowed.polygons[]	! shadowed polygon	_status.contour	= _drawContour						! draw contour if needed	_status.fill	= _symbol.hasTwoFills & drawFill1	! draw fill1 if exists	_useFillAttributes = _fillAttributes.fg	_drawAsPolyline = 0	for _iPoly = 1 to vardim1(_shadowed.polygons)		dict _polygon		_polygon = _shadowed.polygons[_iPoly]		gosub "drawPolygon"	next _iPoly	! fill2	if drawFill2 then		_status = _statusFill		_useFillAttributes = _fillAttributes.bg		if not(_symbol.hasTwoFills) then	! has only "background" fill			gosub "drawSymbolContour"		else			for _iPoly = 1 to vardim1(_unshadowed.polygons)				dict _polygon				_polygon = _unshadowed.polygons[_iPoly]				gosub "drawPolygon"			next _iPoly		endif	endifreturn! ============================================================================="editBreakPoint":! -----------------------------------------------------------------------------! param editing of breakpoint / shadow offset! input (from setGeometry):!	_diagonalPoly!		.regularized!		.PO!			.isClosed!			.contour!				.edges[]!					.type		0 straight 1 arced!					.begPoint!					.arcAngle	when .type = 1!	_diagTopology				order of relevant points on _diagonalPoly!		.diagonals[]!			.ends[]! output:!	_break!		.point					breakpoint coordinates!			.x .y!		.offset					breakpoint offset from corner!			.dx .dy! =============================================================================	_sqrper2 = sqr(0.5)	_sqr2 = sqr(2)	dict _offsetAnchor, _offsetVector, _cornerPoint	gosub "getOffsetLimit"	! returns _offsetAnchor, _offsetVector, _offsetLimit, _cornerPoint	! actual distance of breakpoint from corner, within limit	! use % parameter	_dBreakPoint	= _offsetLimit * percBreakpoint / 100	dict _break	! breakpoint offset from corner	_break.offset.dx = _offsetVector.ux * _dBreakPoint	_break.offset.dy = _offsetVector.uy * _dBreakPoint	! breakpoint coordinates	_break.point.x = _offsetAnchor.x + _break.offset.dx	_break.point.y = _offsetAnchor.y + _break.offset.dy	if GLOB_DIAGNOSTICS_MODE & bShowDiagnostics then		! hotspot anchor		pen 20		circle2 _offsetAnchor.x, _offsetAnchor.y, 0.01		! hotspot can move on this segment		pen 20		line2	_offsetAnchor.x, _offsetAnchor.y,				_offsetAnchor.x + _offsetVector.ux * abs(_offsetLimit),				_offsetAnchor.y + _offsetVector.uy * abs(_offsetLimit)	endifreturn ! ========================================================================"getOffsetLimit":! ------------------------------------------------------------------------! get distance of diagonal from corner! input:!	_diagonalPoly!		.regularized!		.PO!			.isClosed!			.contour!				.edges[]!					.type			0 straight 1 arced!					.begPoint!					.arcAngle		when .type = 1!	_diagTopology					order of relevant points on _diagonalPoly!		.diagonals[]				-> duplicated _diag1, _diag2 in callers!			.ends[]! output:!	_offsetAnchor	(point)			anchor point of offset!	_offsetVector	(unitvector)	bisector of sides from corner!		.ux .uy!	_offsetLimit	(length)		< 0 for no limit!	_cornerPoint! ========================================================================	! init return values	dict _offsetVector	_offsetVector.ux = 0	_offsetVector.uy = 0	_offsetLimit = 0	dict _useContour	if _symbol.type = SYMBOL_BREAK then		! needs bisector of _diagonalPoly		_useContour = _diagonalPoly.PO.contour	else	! SYMBOL_SHADOW | SYMBOL_SHADOW_2FILL		! needs 45° - bisector of boundingbox		_useContour = _boundingboxPoly.PO.contour	endif	dict _cornerPoint, _point1, _point2	_cornerPoint	= _useContour.edges[_diag2.beg].begPoint	_point1			= _useContour.edges[_diag1.beg].begPoint	_point2			= _useContour.edges[_diag1.end].begPoint	_cornerPoint.z	= 0	_point1.z		= 0	_point2.z		= 0	dict _side1		! _diag2.beg to _diag1.beg (unit vector)	call "BasicGeometry_25" parameters iFunction	= BasicGeometry_25.DIRECTION_POINTS_3D,									pointFrom	= _cornerPoint,									pointTo		= _point1,						returned_parameters		_side1,												_side1Length		dict _side2		! _diag2.beg to _diag1.end (unit vector)	call "BasicGeometry_25" parameters iFunction	= BasicGeometry_25.DIRECTION_POINTS_3D,									pointFrom	= _cornerPoint,									pointTo		= _point2,						returned_parameters		_side2,												_side2Length	! bisector is diagonal of rhombus from unitvectors	dict _bisector	_bisector.dx = _side1.ux + _side2.ux	_bisector.dy = _side1.uy + _side2.uy	_bisector.dz = 0	_bisector.length = sqr(_bisector.dx **2 + _bisector.dy **2)	if abs(_bisector.length) < EPS then return	! bisector is zero length, limit is _cornerPoint	_bisector.ux = _bisector.dx / _bisector.length	_bisector.uy = _bisector.dy / _bisector.length	_bisector.uz = 0	! diagonal that limits offset	dict _diagonalVector	! _diag1.beg to _diag1.end (unit vector)	call "BasicGeometry_25" parameters iFunction	= BasicGeometry_25.DIRECTION_POINTS_3D,									pointFrom	= _point1,									pointTo		= _point2,						returned_parameters		_diagonalVector,												_unused		! intersect bisector with diagonal	dict _lineBisector, _lineDiagonal, _intersection	_lineBisector.point = _cornerPoint	_lineBisector.direction = _bisector	_lineDiagonal.point = _point1	_lineDiagonal.direction = _diagonalVector	call "BasicGeometry_25" parameters iFunction	= BasicGeometry_25.INTERSECT_LINE_LINE_2D,									lineA		= _lineBisector,									lineB		= _lineDiagonal,						returned_parameters		_intersection	if vardim1(_intersection.points) = 0 then return	! _diagonalVector || with _bisector, _side1 is on _side2, limit is _cornerPoint	_intersection.points[1].z = 0	call "BasicGeometry_25" parameters iFunction	= BasicGeometry_25.DIRECTION_POINTS_3D,									pointFrom	= _cornerPoint,									pointTo		= _intersection.points[1],						returned_parameters		_offsetVector,												_offsetLimit	dict _offsetAnchor	_offsetAnchor = _diagonalPoly.PO.contour.edges[_diag2.beg].begPointreturn! ============================================================================="getMidPoint":! -----------------------------------------------------------------------------! input:!	_symbolPoly					with 4 edges!		.regularized!		.PO!			.isClosed!			.contour!				.edges[]!					.type		0 straight 1 arced!					.begPoint!					.arcAngle	when .type = 1! output:!	_midPoint!		.x .y! =============================================================================	dict _midPoint	! find arcs in _symbolPoly	_out = 1	dict _opposingSides : _opposingSides.arc = EMPTYARRAY	for _i = 1 to 4		if _symbolPoly.PO.contour.edges[_i].type = EDGE_CURVED then			! compute arc center and end tangents			dict _segment			_segment			= _symbolPoly.PO.contour.edges[_i]			_segment.endPoint	= _symbolPoly.PO.contour.edges[_i % 4 + 1].begPoint			dict _begDirection, _endDirection, _center			call "BasicGeometry_25" parameters iFunction	= BasicGeometry_25.DIRECTION_SEGMENT_2D,											segment		= _segment,								returned_parameters		_begDirection,														_endDirection, 														_center			_segment.arc.center		= _center			_segment.arc.radius		= sqr((_center.x - _segment.begPoint.x) **2 + (_center.y - _segment.begPoint.y) **2)			! adding beginning & end directions gives radius direction to midpoint			dict _midDirection			_midDirection.ux = _begDirection.ux + _endDirection.ux			_midDirection.uy = _begDirection.uy + _endDirection.uy			if abs(_midDirection.ux) > EPS | abs(_midDirection.uy) > EPS then	! they add to 0 vector only at 0 and 360 arc				! set _midDirection to unit length				_lengthRec = 1 / sqr(_midDirection.ux **2 + _midDirection.uy **2)				_midDirection.ux = _midDirection.ux * _lengthRec				_midDirection.uy = _midDirection.uy * _lengthRec								! adding radius to _center in direction of _midDirection gives midpoint of arc				_segment.arc.midPoint.x = _center.x + _segment.arc.radius * _midDirection.ux				_segment.arc.midPoint.y = _center.y + _segment.arc.radius * _midDirection.uy				! store result				_opposingSides.arc[_out] = _segment.arc				_out = _out + 1			endif		endif	next _i	! midpoint of edge connecting opposing side midpoints	if vardim1(_opposingSides.arc) = 2 then		_midPoint.x = (_opposingSides.arc[1].midPoint.x + _opposingSides.arc[2].midPoint.x) / 2		_midPoint.y = (_opposingSides.arc[1].midPoint.y + _opposingSides.arc[2].midPoint.y) / 2	else		_midPoint.x = 0		_midPoint.y = 0	endifreturn! ============================================================================="drawSymbolContour":! -----------------------------------------------------------------------------! input:!	_symbolPoly!		.regularized!		.PO!			.isClosed!			.contour!				.edges[]!					.type		0 straight 1 arced!					.begPoint!					.arcAngle	when .type = 1!	_lineAttributes				Line attributes!	_useFillAttributes			Fill attributes!	_status						for poly2_b!		.contour!		.fill! =============================================================================		dict _polygon : _polygon = _symbolPoly	_drawAsPolyline = 0	gosub "drawPolygon"return! ============================================================================="regularize_and_DrawPolygon":! -----------------------------------------------------------------------------! input:!	_polygon!		.PO!			.isClosed!			.contour!				.edges[]!					.type			0 straight 1 arced!					.begPoint!					.arcAngle		when .type = 1!			.holes[]				(optional) same structure as contour! for "drawRegularPolygon":!	_status!	_lineAttributes!	_useFillAttributes! =============================================================================	_inputContainer = "inputContainer"	_regularizedContainer = "regularizedContainer"	! initialize PolyOperations	_poChannel = initaddonscope ("PolyOperations", "", "")	preparefunction _poChannel, "CreateContainer", _inputContainer, ""	preparefunction _poChannel, "CreateContainer", _regularizedContainer, ""	! store polygon	_container = _inputContainer	_polygonID = "polygon"	gosub "poStorePolygon"	! regularize - possibly multiple result polygons	dim _resultIDs[]	_sourceContainer = _inputContainer	_destinationContainer = _regularizedContainer	gosub "poRegularize"	! returns _nResult, _resultIDs in _destinationContainer	! get and draw each result	dict _temp : _temp = _status	_status.autoClose = _polygon.PO.isClosed	_drawAsPolyline = 0	for _iResult = 1 to _nResult		dict _polygon, _PolyOpPolygon		_nVertices = callfunction (_poChannel, "GetDestinationDictPolygon", _resultIDs[_iResult], _PolyOpPolygon)		_polygon.PO = _PolyOpPolygon			gosub "drawRegularPolygon"	next _iResult	_status = _temp	closeaddonscope (_poChannel)return! ============================================================================="getIntoPolygon":! -----------------------------------------------------------------------------! input:!	parameter buffer		polyop polygon without holes!	_polygon				initialized as dict! output:!	_polygon!		.PO!			.contour!				.edges[]! =============================================================================	dict _contour	_iEdge = 1	while NSP > 2 do 		_contour.edges[_iEdge].begPoint.x = get(1)		_contour.edges[_iEdge].begPoint.y = get(1)		_arcangle = get(1)		if abs(_arcangle) < EPS then			_contour.edges[_iEdge].type = EDGE_STRAIGHT		else			_contour.edges[_iEdge].type = EDGE_CURVED			_contour.edges[_iEdge].arcAngle = _arcangle		endif		_iEdge = _iEdge + 1	endwhile	_polygon.PO.contour = _contourreturn! ============================================================================="drawPolygon":! -----------------------------------------------------------------------------! input:!	_drawAsPolyline!	_polygon!		.regularized		skip regularization if set!		.PO!			.isClosed!			.contour!				.edges[]!					.type			0 straight 1 arced!					.begPoint!					.arcAngle		when .type = 1!			.holes[]				(optional) same structure as contour!	for "drawFill"!		_lineAttributes			Line attributes!		_useFillAttributes		Fill attributes!		_status					for poly2_b! =============================================================================	if not(_drawAsPolyline) then		_bRegularize = not(_polygon.regularized)	else		_bRegularize = 0	endif	if _bRegularize then		gosub "regularize_and_DrawPolygon"	! calls "drawRegularPolygon" for each regularized _polygon	else		gosub "drawRegularPolygon"	endifreturn! ============================================================================="drawRegularPolygon":! -----------------------------------------------------------------------------!	_polygon	!		.PO!			.isClosed!			.contour!				.edges[]!					.type			0 straight 1 arced!					.begPoint!					.arcAngle		when .type = 1!			.holes[]				(optional) same structure as contour!	for "drawFill"!		_lineAttributes				Line attributes!		_useFillAttributes			Fill attributes!		_status						for poly2_b! =============================================================================	! auto-close in "ProfileConverter_mod"	! drop closing point after return	! draw with auto-close if was closed	_status.autoClose	 = _polygon.PO.isClosed	_polygon.PO.isClosed = 1	if vardim1(_polygon.PO.contour.edges) > 1 then		! at least two points		! convert to status-coded polygon		dim _outflat[]		call "ProfileConverter_mod" parameters	bProfileToPolyOp	= 0,											bPolyOpDict			= 1,											PolyOpPolygon		= _polygon.PO,									returned_parameters _nOut,														_outflat		! put results		nCoords = 3 * _nOut		for _i = 1 to _nOut - 1	! drop closing point			_k = (_i - 1) * 3			put _outflat[_k + 1],				_outflat[_k + 2]			! visibility flag			if _outflat[_k + 3] # -1 then				put _outflat[_k + 3] + 1			else				put -1			endif		next _i		gosub "drawFill"	endifreturn! ============================================================================="drawPortal":! easter egg, waiting for fix of 258038! =============================================================================!!	mul2 _bbw / 0.57, _bbh / 1!!	if _GLaDOS.version = 1 then!		DEFINE IMAGE_FILL "portalblue" "Openingsymbol_b",!							0,0,0,0,0,0,0,0,!							0.684, 1.21, 0, 0!!		fill "portalblue"!		_tx = -0.085!		_ty = -0.13!	else!		DEFINE IMAGE_FILL "portalorange" "Openingsymbol_o",!							0,0,0,0,0,0,0,0,!							0.684, 1.21, 0, 0!		fill "portalorange"!		_tx = -0.04!		_ty = -0.14!	endif!!	poly2_b{3}	4, 2 + 4 + 8 + 128,!				1, 0,!				_tx, _ty,!				1, 0, 0, 1,!!				0, 0, 1,!				0.57, 0, 1,!				0.57, 1, 1,!				0,	  1, 1!!	del 1return! ============================================================================="drawFill":! -----------------------------------------------------------------------------! input:!	polygon in internal parameter buffer!	_lineAttributes			Line attributes!	_useFillAttributes		Fill attributes!	_status					for poly2_b!		.contour!		.fill!		.autoClose! =============================================================================		pen			_lineAttributes.pen	line_type	_lineAttributes.type	if _status.fill then		fill		  _useFillAttributes.type		_fillPen	= _useFillAttributes.pen		_fillBgPen	= _useFillAttributes.bgPen	else	! irrelevant		_fillPen	= 1		_fillBgPen	= 0	endif	poly2_b NSP / 3, _status.contour + 2 * _status.fill + 4 * _status.autoClose,		_fillPen, _fillBgPen,		get(NSP)return! ========================================================================"createBoundingBoxPoly":! ------------------------------------------------------------------------! input:!	_boundingBox! output:!	_boundingboxPoly! ========================================================================	_boundingboxPoly.PO.contour.edges[1].type		= EDGE_STRAIGHT	_boundingboxPoly.PO.contour.edges[1].begPoint.x	= _boundingBox.xmin	_boundingboxPoly.PO.contour.edges[1].begPoint.y	= _boundingBox.ymin	_boundingboxPoly.PO.contour.edges[2].type		= EDGE_STRAIGHT	_boundingboxPoly.PO.contour.edges[2].begPoint.x	= _boundingBox.xmax	_boundingboxPoly.PO.contour.edges[2].begPoint.y	= _boundingBox.ymin	_boundingboxPoly.PO.contour.edges[3].type		= EDGE_STRAIGHT	_boundingboxPoly.PO.contour.edges[3].begPoint.x	= _boundingBox.xmax	_boundingboxPoly.PO.contour.edges[3].begPoint.y	= _boundingBox.ymax	_boundingboxPoly.PO.contour.edges[4].type		= EDGE_STRAIGHT	_boundingboxPoly.PO.contour.edges[4].begPoint.x	= _boundingBox.xmin	_boundingboxPoly.PO.contour.edges[4].begPoint.y	= _boundingBox.ymax	_boundingboxPoly.PO.isClosed = 1	_boundingboxPoly.regularized = 1return! ========================================================================"shrinkSymbol":! ------------------------------------------------------------------------! shrinks symbol by an offset! input:!	_symbolPoly!		.regularized!		.PO!			.isClosed!			.contour!				.edges[]!					.type		0 straight 1 arced!					.begPoint!					.arcAngle	when .type = 1!	_boundingBox!		.xmin .ymin .xmax .ymax! output:!	_symbolPoly					shrunk by shrinkOffset!	_boundingBox				shrunk by shrinkOffset! ========================================================================	_inputContainer = "inputContainer"	_resultContainer = "resultContainer"	! initialize PolyOperations	_poChannel = initaddonscope ("PolyOperations", "", "")	preparefunction _poChannel, "CreateContainer", _inputContainer, ""	preparefunction _poChannel, "CreateContainer", _resultContainer, ""	_container = _inputContainer	_polygonID = "polygon"	dict _polygon	_polygon = _symbolPoly	_unused = removekey(_polygon.PO.holes)	! shrink contour only	gosub "poStorePolygon"	preparefunction _poChannel, "SetDestinationContainer", _resultContainer, ""	preparefunction _poChannel, "OffsetParams", "", 1, -shrinkOffset	dim _resultIDs[]	_nResult = callfunction (_poChannel, "ResizeContour", _polygonID, _resultIDs)	! read result	! initialize for no result - offset is so big that polygon disappears	dict _symbolPoly	_symbolPoly.PO.contour.edges = EMPTYARRAY	_symbolPoly.PO.isClosed		 = 0	_symbolPoly.regularized		 = 0	! find the result that has the most edges - no holes in input	_nMaxEdges = 0	for _iResult = 1 to _nResult		dict _PolyOpPolygon		_nVertices = callfunction (_poChannel, "GetDestinationDictPolygon", _resultIDs[_iResult], _PolyOpPolygon)		if _nVertices > _nMaxEdges then			_nMaxEdges		= _nVertices			_symbolPoly.PO	= _PolyOpPolygon		endif	next _iResult	if _nMaxEdges > 0 then		_symbolPoly.PO.isClosed = 1	! auto-close		_symbolPoly.regularized = 1	! "ResizeContour" gives regularized result		endif	closeaddonscope _poChannel	! shrink bounding box (approximation, not the tightest fit, but nothing is outside it)	! don't allow to shrink into 0 area	_shrinkX = min(shrinkOffset, (_boundingBox.xmax - _boundingBox.xmin) / 2 - EPS)	_shrinkY = min(shrinkOffset, (_boundingBox.ymax - _boundingBox.ymin) / 2 - EPS)	_boundingBox.xmin = _boundingBox.xmin + _shrinkX	_boundingBox.ymin = _boundingBox.ymin + _shrinkY	_boundingBox.xmax = _boundingBox.xmax - _shrinkX	_boundingBox.ymax = _boundingBox.ymax - _shrinkYreturn! ========================================================================"clip_and_DrawPolyline":! ------------------------------------------------------------------------! clip _polygon (polyline) with _symbolPoly and draw result! input:!	_symbolPoly!	_polygon				will be overwritten!	_useFillAttributes!	_status! ========================================================================	dict _temp : _temp = _status	_status.autoClose = 0	_drawAsPolyline = 1	if GLOB_DIAGNOSTICS_MODE | not(shrinkOffset > 0) then	! don't clip, just draw		gosub "drawPolygon"	else		_inputIsClosed = _polygon.PO.isClosed		! work in same source and destination containers		_container	= "container"		_poChannel = initaddonscope ("PolyOperations", "", "")		preparefunction _poChannel, "CreateContainer", _container, ""		preparefunction _poChannel, "SetSourceContainer", _container, ""		preparefunction _poChannel, "SetDestinationContainer", _container, ""		! store _polygon in _container		_polygonID = "poly"		gosub "poStorePolyline"	! stores _polygon as _polygonID in _container		_subtractFromID = _polygonID	! for "poSubPolygon"		! store _symbolPoly in _destinationContainer		_polygonID = "clip"		dict _polygon : _polygon = _symbolPoly		gosub "poStorePolygon"	! stores _polygon as _polygonID in _container		! subtract		dim _resultIDs[]		_subtractID = _polygonID		nPline = callfunction (_poChannel, "ClipPolyline", _subtractFromID + " " + _subtractID, _resultIDs)		! draw results		for _iResult = 1 to vardim1(_resultIDs)						dict _PolyOpPolygon, _polygon			_nVertices = callfunction (_poChannel, "GetDestinationDictPolyline", _resultIDs[_iResult], _PolyOpPolygon)			_polygon.regularized = 1			_polygon.PO			 = _PolyOpPolygon			_polygon.PO.isClosed = _inputIsClosed			gosub "drawPolygon"		next _iResult		closeaddonscope (_poChannel)	endif	_status = _tempreturn! ========================================================================"clip_and_DrawPolygon":! ------------------------------------------------------------------------! subtract _symbolRim from _polygon and draw result! input:!	_symbolRim!	_polygon				will be overwritten!	_useFillAttributes!	_status! ========================================================================	_drawAsPolyline = 0	if GLOB_DIAGNOSTICS_MODE | not(shrinkOffset > 0) then	! don't clip, just draw		gosub "drawPolygon"	else		! work in same source and destination containers		_container	= "container"		_poChannel = initaddonscope ("PolyOperations", "", "")		preparefunction _poChannel, "CreateContainer", _container, ""		preparefunction _poChannel, "SetSourceContainer", _container, ""		preparefunction _poChannel, "SetDestinationContainer", _container, ""		! store _polygon in _container		_polygonID = "poly"		gosub "poStorePolygon"	! stores _polygon as _polygonID in _container		dim _clippedResultIDs[], _resultIDs[]		_sourceContainer		= _container		_destinationContainer	= _container		gosub "poRegularize"	! retruns _nResult, _resultIDs		_clippedResultIDs = _resultIDs		for _iClipped = 1 to vardim1(_clippedResultIDs)			_subtractFromID = _clippedResultIDs[_iClipped]			! store _symbolRim in _destinationContainer			_container = _destinationContainer			_polygonID = "clip"			dict _polygon : _polygon = _symbolRim			gosub "poStorePolygon"	! stores _polygon as _polygonID in _container			! subtract			_subtractID = _polygonID			dim _resultIDs[]			gosub "poSubPolygon"	! returns _resultIDs, _nResult			! draw results			for _iResult = 1 to vardim1(_resultIDs)								dict _polygon, _PolyOpPolygon				_nVertices = callfunction (_poChannel, "GetDestinationDictPolygon", _resultIDs[_iResult], _PolyOpPolygon)				_polygon.PO			 = _PolyOpPolygon				_polygon.regularized = 1				gosub "drawPolygon"			next _iResult		next _iClipped		closeaddonscope (_poChannel)	endifreturn! ============================================================================="createShadow":! -----------------------------------------------------------------------------! creates shadow polygons on each edge of _symbolPoly! input:!	_offset							shadow vector!		.dx .dy!	_symbolPoly!		.regularized!		.PO!			.isClosed!			.contour!				.edges[]!					.type			0 straight 1 arced!					.begPoint!					.arcAngle		when .type = 1! ouput:!	_shadow!		.polygons[]!			.regularized			0!			.PO!				.isClosed			1!				.contour!					.edges[]! =============================================================================	dict _shadow : _shadow.polygons = EMPTYARRAY	if abs(_offset.dx) > EPS | abs(_offset.dy) > EPS then	! non-zero shadow		! offset contour (without holes)		_nEdges = vardim1(_symbolPoly.PO.contour.edges)		_iOut = 1		for _i = 1 to _nEdges				! edge as segment			dict _fullSegment			_fullSegment			= _symbolPoly.PO.contour.edges[_i]			_fullSegment.endPoint	= _symbolPoly.PO.contour.edges[_i % _nEdges + 1].begPoint				! divide arc with points where _offset is tangential to curve			if _fullSegment.type = EDGE_STRAIGHT then				_fullSegment.parts[1]	= _fullSegment			else				_fullSegment.arcAngle	= _symbolPoly.PO.contour.edges[_i].arcAngle					dict _segment : _segment = _fullSegment				dict _divided				gosub "divideArc"	! returns _divided.segments[]					_fullSegment.parts = _divided.segments			endif				! make open polygon of each part with its offset			for _iPart = 1 to vardim1(_fullSegment.parts)					dict _segment : _segment = _fullSegment.parts[_iPart]				dict _contour					! beginning point				_contour.edges[1].begPoint = _segment.begPoint				_contour.edges[1].type = _fullSegment.type				if _fullSegment.type = EDGE_CURVED then _contour.edges[1].arcAngle = _segment.arcAngle								! endpoint				_contour.edges[2].begPoint = _segment.endPoint				_contour.edges[2].type = EDGE_STRAIGHT					! offset endpoint				_contour.edges[3].begPoint.x = _segment.endPoint.x + _offset.dx				_contour.edges[3].begPoint.y = _segment.endPoint.y + _offset.dy				_contour.edges[3].type = _fullSegment.type				if _fullSegment.type = EDGE_CURVED then _contour.edges[3].arcAngle = -_segment.arcAngle	! reverse angle					! offset beginning point				_contour.edges[4].begPoint.x = _segment.begPoint.x + _offset.dx				_contour.edges[4].begPoint.y = _segment.begPoint.y + _offset.dy				_contour.edges[4].type = EDGE_STRAIGHT					! store				_shadow.polygons[_iOut].PO.contour	= _contour				_shadow.polygons[_iOut].PO.isClosed = 1				_shadow.polygons[_iOut].regularized = 0				_iOut = _iOut + 1				next _iPart		next _i	endif	return! ============================================================================="divideArc":! -----------------------------------------------------------------------------! divide arc with points  where _offset is tangential to curve! input:!	_segment!		.begPoint!		.endPoint!		.arcAngle!	_offset!		.dx .dy! output:!	_divided!		.segments[]! =============================================================================	dict _divided		! compute arc center and end tangents	dict _begDirection, _endDirection, _center	call "BasicGeometry_25" parameters iFunction	= BasicGeometry_25.DIRECTION_SEGMENT_2D,									segment		= _segment,						returned_parameters		_begDirection,												_endDirection, 												_center	_segment.arc.center		= _center	_segment.arc.radius		= sqr((_center.x - _segment.begPoint.x) **2 + (_center.y - _segment.begPoint.y) **2)	! intersect arc with diagonal perpendicular to offset	dict _perpendicular	_perpendicular.length = sqr(_offset.dx **2 + _offset.dy **2)	if _perpendicular.length > EPS then		_perpendicular.ux = -_offset.dy / _perpendicular.length		_perpendicular.uy =  _offset.dx / _perpendicular.length	else	! intersection will return 0 results		_perpendicular.ux = 0		_perpendicular.uy = 0	endif	dict _shadowDivider	_shadowDivider.direction = _perpendicular	_shadowDivider.point	 = _center	dict _intersection	call "BasicGeometry_25" parameters iFunction	= BasicGeometry_25.INTERSECT_SEGMENT_LINE_2D,									segment		= _segment,									lineA		= _shadowDivider,						returned_parameters		_intersection	! beginning of segment	_divided.segments[1].begPoint = _segment.begPoint	! store angles with arc beginning (on arc direction)	dict _vectorToBeg	_vectorToBeg.dx = _segment.begPoint.x - _segment.arc.center.x	_vectorToBeg.dy = _segment.begPoint.y - _segment.arc.center.y	! length can't be 0 - would be 0 radius	_vectorToBeg.length = sqr(_vectorToBeg.dx **2 + _vectorToBeg.dy **2)	_vectorToBeg.ux = _vectorToBeg.dx / _vectorToBeg.length	_vectorToBeg.uy = _vectorToBeg.dy / _vectorToBeg.length	for _iPoint = 1 to vardim1(_intersection.points)		! vector of intersection from center		dict _vectorPoint		_vectorPoint.dx = _intersection.points[_iPoint].x - _segment.arc.center.x		_vectorPoint.dy = _intersection.points[_iPoint].y - _segment.arc.center.y		! length can't be 0 - would be 0 radius		_vectorPoint.length = sqr(_vectorPoint.dx **2 + _vectorPoint.dy **2)		_vectorPoint.ux = _vectorPoint.dx / _vectorPoint.length		_vectorPoint.uy = _vectorPoint.dy / _vectorPoint.length		! scalar product of _vectorPoint and _begDirection is >= 0 if angle to beginning is <= 180		_scalarDir = _begDirection.ux * _vectorPoint.ux + _begDirection.uy * _vectorPoint.uy		_scalarBeg = _vectorToBeg.ux * _vectorPoint.ux + _vectorToBeg.uy * _vectorPoint.uy		_dAngle = acs(max(-1, min(1, _scalarBeg)))									! [0, 180] 		if sgn(_scalarDir) < 0 then _dAngle = 360 - _dAngle							! (180, 360)		_intersection.points[_iPoint].dAngleBeg = sgn(_segment.arcAngle) * _dAngle	! (-360, 360)	next _iPoint	! sort by abs(.dAngleBeg)	if vardim1(_intersection.points) = 2 then		if abs(_intersection.points[2].dAngleBeg) < abs(_intersection.points[1].dAngleBeg) then	! swap points			dict _temp			_temp = _intersection.points[1]			_intersection.points[1] = _intersection.points[2]			_intersection.points[2] = _temp		endif	endif	! store sorted division	_prevAngle = 0	for _iPoint = 1 to vardim1(_intersection.points)		_divided.segments[_iPoint].type				= EDGE_CURVED		_divided.segments[_iPoint].endPoint.x		= _intersection.points[_iPoint].x		_divided.segments[_iPoint].endPoint.y		= _intersection.points[_iPoint].y		_divided.segments[_iPoint].arcAngle			= _intersection.points[_iPoint].dAngleBeg - _prevAngle		_divided.segments[_iPoint + 1].begPoint.x	= _intersection.points[_iPoint].x		_divided.segments[_iPoint + 1].begPoint.y	= _intersection.points[_iPoint].y		_prevAngle = _intersection.points[_iPoint].dAngleBeg	next _iPoint	! end of segment - _iPoint incremented after last loop	_divided.segments[_iPoint].type		= EDGE_CURVED	_divided.segments[_iPoint].endPoint	= _segment.endPoint	_divided.segments[_iPoint].arcAngle	= _segment.arcAngle - _prevAnglereturn! ============================================================================="createShadowedPoly":! -----------------------------------------------------------------------------! input:!	_symbolPoly					holes disregarded!		.regularized!		.PO!			.isClosed!			.contour!				.edges[]!					.type		0 straight 1 arced!					.begPoint!					.arcAngle	when .type = 1!	_shadow!		.polygons[]! output:!	_unshadowed					_shadow subtracted from _symbolPoly!		.polygons[]				can have multiple distinct unshadowed polygons!			.regularized!			.PO!				.contour!					.edges[]!				.holes[]!					.edges[]!	_shadowed					_unshadowed subtracted from _symbolPoly!		.polygons[]! =============================================================================	_inputContainer	= "inputContainer"	_workContainer	= "workContainer"	_contourID		= "contour"	_poChannel = initaddonscope ("PolyOperations", "", "")	preparefunction _poChannel, "CreateContainer", _inputContainer, ""	preparefunction _poChannel, "CreateContainer", _workContainer, ""	! store symbol contour polygon in _workContainer	_container	= _workContainer	_polygonID = _contourID	dict _polygon	_polygon = _symbolPoly	_unused = removekey(_polygon.PO.holes)	! without holes	gosub "poStorePolygon"	! stores _polygonID in _container	! store shadow polygons in _inputContainer	_container = _inputContainer	dim _shadowPolyIDs[]	for _iPoly = 1 to vardim1(_shadow.polygons)		_polygonID = "shadow" + str(_iPoly, 1, 0)		_shadowPolyIDs[_iPoly] = _polygonID		dict _polygon		_polygon = _shadow.polygons[_iPoly]		gosub "poStorePolygon"	! stores _polygonID in _container	next _iPoly	! regularize each to _workContainer - arced shadows can self-intersect	_sourceContainer		= _inputContainer	_destinationContainer	= _workContainer	dim _regularShadowPolyIDs[]	_outPoly = 1	for _inPoly = 1 to vardim1(_shadow.polygons)		! regularize polygon		dim _resultIDs[]		_polygonID = _shadowPolyIDs[_inPoly]		gosub "poRegularize"	! returns _nResult, _resultIDs in _destinationContainer		for _pgon = 1 to _nResult			_regularShadowPolyIDs[_outPoly] = _resultIDs[_pgon]			_outPoly = _outPoly + 1		next _pgon		!print "regularized ", _shadowPolyIDs[_inPoly], " as ", _resultIDs, " at inputContainer -> workContainer"	next _inPoly	! work in same source and destination containers, intermediate results are re-used	_container = _destinationContainer	preparefunction _poChannel, "SetSourceContainer", _container, ""	preparefunction _poChannel, "SetDestinationContainer", _container, ""	! subtract _regularShadowPolyIDs from _contourID	!print "creating _unshadowed polygons"	dim _subtractIDs[] : _subtractIDs = _regularShadowPolyIDs	_subtractFromID = _contourID	_isClosed = 1	! for "poMultiSubPolygon"	dim _resultPolyIDs[]	_resultPolyIDs[1] = ""	! for check script in case no _shadow.polygons[]	dict _result	gosub "poMultiSubPolygon"	! returns _result.polygons, _resultPolyIDs in _container	dict _unshadowed	_unshadowed = _result	! subtract _resultPolyIDs from _contourID	!print "creating _shadowed polygons"	_container = _workContainer	dim _subtractIDs[] : _subtractIDs = _resultPolyIDs	! from previous "poMultiSubPolygon"	_subtractFromID = _contourID	dict _result	gosub "poMultiSubPolygon"	! returns _result.polygons, _resultPolyIDs in _container	dict _shadowed	_shadowed = _result	closeaddonscope (_poChannel)return! ============================================================================="poStorePolyline":! -----------------------------------------------------------------------------! input:!	_poChannel!	_container					set as source cntainer!	_polylineID					set id of polygon!	_polygon!		.PO!			.isClosed!			.contour!				edges[]! =============================================================================!	print "storing polyline ", _polygonID, " at ", _container	preparefunction _poChannel, "SetSourceContainer", _container, ""	dict _PolyOpPolygon	_PolyOpPolygon				= _polygon.PO	_PolyOpPolygon.useEdgeInfo	= 0	_unused = removekey(_PolyOpPolygon.PO.holes)		! no holes for polylines	preparefunction _poChannel, "StoreDictPolyline", _polygonID, _PolyOpPolygonreturn! ============================================================================="poStorePolygon":! -----------------------------------------------------------------------------! input:!	_poChannel!	_container					set as source cntainer!	_polygonID					set id of polygon!	_polygon!		.PO!			.isClosed!			.contour!				edges[]!			.holes[]			(optional) same structure as contour! =============================================================================!	print "storing polygon ", _polygonID, " at ", _container	preparefunction _poChannel, "SetSourceContainer", _container, ""	dict _PolyOpPolygon	_PolyOpPolygon				= _polygon.PO	_PolyOpPolygon.useEdgeInfo	= 0	preparefunction _poChannel, "StoreDictPolygon", _polygonID, _PolyOpPolygonreturn	! ============================================================================="poMultiSubPolygon":! -----------------------------------------------------------------------------! input:!	_poChannel!	_container				same source and destination!	_subtractFromID, _subtractIDs	id of regularized polygons in _container!	_isClosed				auto-close if yes! output:!	_resultPolyIDs[]		in _container!	_result					polygon corresponding _subtractFromID if _subtractIDs is empty!		.polygons[]			empty array when no result!			.regularized!			.PO!				.isClosed!				.contour!					.edges[]!				.holes[]!					.edges[]! =============================================================================	dict _result	dim _resultPolyIDs[]	_resultPolyIDs[1] = _subtractFromID	! subtract each _subtractIDs from _subtractFromID	for _pgon = 1 to vardim1(_subtractIDs)		_subtractID = _subtractIDs[_pgon]		! subtract _subtractID from each _resultPolyIDs, subtraction can have multiple polygon results		dim _allResultIDs[]		_out = 1		for _fromPgon = 1 to vardim1(_resultPolyIDs)			dim _resultIDs[]			_subtractFromID = _resultPolyIDs[_fromPgon]			gosub "poSubPolygon"	! returns _resultIDs, _nResult			! append _resultIDs to end of _allResultIDs			for _iResult = 1 to _nResult				_allResultIDs[_out] = _resultIDs[_iResult]				_out = _out + 1			next _iResult		next _fromPgon		! work with new results at next _pgon		dim _resultPolyIDs[]		_resultPolyIDs = _allResultIDs	next _pgon 	! get results from _container	dict _result	_result.polygons = EMPTYARRAY	for _iResult = 1 to vardim1(_resultPolyIDs)		dict _PolyOpPolygon		_nVertices = callfunction (_poChannel, "GetDestinationDictPolygon", _resultPolyIDs[_iResult], _PolyOpPolygon)		_result.polygons[_iResult].regularized	= 1			! used regularized input		_result.polygons[_iResult].PO			= _PolyOpPolygon	next _iResultreturn! ============================================================================="poSubPolygon":! -----------------------------------------------------------------------------! input:!	_poChannel!	_container						same source and destination!	_subtractFromID, _subtractID	id of regularized polygons in source container! output:!	_resultIDs[] = _subtractFromID - _subtractID!	_nResult						number of result polygons! =============================================================================	!print "subtracting ", _subtractID, " from ", _subtractFromID , " at ", _container	dim _resultIDs[]	_nResult = callfunction (_poChannel, _subtractFromID + " - " + _subtractID, "", _resultIDs)		!print "subtracted as ", _resultIDsreturn! ============================================================================="poRegularize":! -----------------------------------------------------------------------------! input:!	_sourceContainer!	_destinationContainer!	_polygonID					id of polygon in source container! output:!	_resultIDs[]!	_nResult					number of result polygons! =============================================================================	preparefunction _poChannel, "SetSourceContainer", _sourceContainer, ""	preparefunction _poChannel, "SetDestinationContainer", _destinationContainer, ""	dim _resultIDs[]	_nResult = callfunction (_poChannel, "Regularize", _polygonID, _resultIDs)return! ===============================================================================! rotation of (_x, _y) around (0, 0), beginning from x axis, counterclockwise +!"atan2_180":! -------------------------------------------------------------------------------! input:!	_direction!		.ux .uy! output:!	_atan2		degrees, range (-180...180]! ===============================================================================	_x = _direction.ux	_y = _direction.uy	if abs(_x) > 0 then		_atan2 = atn(_y / _x) + 90 * (1 - sgn(_x)) * (1 - 2 * (sgn(_y) < 0))	else		_atan2 = sgn(_y * (abs(_y) > 0)) * 90	endifreturn! ============================================================================="diagnostics":! =============================================================================	if bShowDiagnostics then		pen 5		for _i = 1 to vardim1(OPENING_SYMBOL_GEOMETRY.polygon2D.contour.edges)			dict _point : _point = OPENING_SYMBOL_GEOMETRY.polygon2D.contour.edges[_i].begPoint			circle2 _point.x, _point.y, 0.02		next _i		print	"GLOB_SCRIPT_TYPE: ",			GLOB_SCRIPT_TYPE, "\n",				"OPENING_SYMBOL_DISPLAY: ",		OPENING_SYMBOL_DISPLAY, "\n",				"OPENING_SYMBOL_GEOMETRY: ",	OPENING_SYMBOL_GEOMETRY, "\n"		! show axes with little offset so it won't be cut		pen 2: line2 0,0.01,	1,0.01		pen 3: line2 0.01,0,	0.01,1	endifreturn