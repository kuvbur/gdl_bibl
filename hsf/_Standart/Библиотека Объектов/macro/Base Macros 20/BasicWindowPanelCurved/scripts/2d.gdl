
! Contact person: <NJ>

! ==============================================================================
! Draws a curved window panel in 2D view
! ------------------------------------------------------------------------------
! Input parameters:
!	A:						width of panel (width value)
!	gs_IsCurved:
!	bDisabeMirroring:		(only for curved window panel)
!	gs_frame_thk:
!	gs_frame_width:
!	gs_frame_cut_width:
!	gs_frame_cut_depth:
!	gs_frame_ovhg_left_out:
!	gs_frame_ovhg_right_out:
!	gs_frame_ovhg_left_in:
!	gs_frame_ovhg_right_in:
!	iLoD2D:
!	gs_pen_2D:				pen for 2D contours (pen)
!	gs_frame_pen_cont:		contour pen of the frame and sash - if 0 then drawn with gs_pen_2D (pen)
!	gs_fillFr:				frame fill pattern type (fill)
!	gs_penFr_fg:			frame fill foreground pen
!	gs_penFr_bg:			frame fill background pen
!	gs_fillShCover:
!	gs_penShCov_fg:
!	gs_penShCov_bg:
!
! Related Global Variables:
!	GLOB_CONTEXT
!	SYMB_ROTANGLE
!	SYMB_MIRRORED
!	WIDO_FRAME_THICKNESS
!	WIDO_LEFT_JAMB
!	WIDO_RIGHT_JAMB
!	WIDO_ORIG_DIST
!	WIDO_REVEAL_SIDE
! ==============================================================================

lod2D					= DET2D_FS_OFF
iSymbolGlassType		= SYMBGLASS_SIMPLEGLASS

if iLoD2D = SYMBW_S_1LINE then				lod2D = DET2D_FS_SIMPLE_ONE 		! Simple - One Line --> INT 200
if iLoD2D = SYMBW_S_CENTERLINE then			lod2D = DET2D_FS_SIMPLE_ONE 		! Simple - Centerline --> SWE 200
if iLoD2D = SYMBW_S_2LINE_ACC then			lod2D = DET2D_FS_SIMPLE_TWO 		! Simple - Two Lines
if iLoD2D = SYMBW_S_2LINE then				lod2D = DET2D_FS_SIMPLE_CHI			! Chinese Simple
if iLoD2D = SYMBW_M_2LINE_GLASS then		lod2D = DET2D_FS_MIDDLE 			! Middle - without acc
if iLoD2D = SYMBW_M_2LINE_NOGLASS then		lod2D = DET2D_FS_SIMPLE_TWO 		! Middle - with acc --> INT 100
if iLoD2D = SYMBW_M_FRAMESASH then			lod2D = DET2D_FS_DETAILED			! NLD Middle
if iLoD2D = SYMBW_D_SGLASS then				lod2D = DET2D_FS_DETAILED 			! Detailed --> INT 50, DAN 20
if iLoD2D = SYMBW_D_REBATEONGLASS then		lod2D = DET2D_FS_DETAILED 			! Detailed --> NLD Detailed
if iLoD2D = SYMBW_D_SGLASS then				lod2D = DET2D_FS_DETAILED 			! Detailed --> INT 50, DAN 20
if iLoD2D = SYMBW_D_2GLASS then				lod2D = DET2D_FS_DETAILED 			! Detailed --> NOR 50
if iLoD2D = SYMBW_D_2LINE_HS then			lod2D = DET2D_FS_DETAILED_CHI		! Chinese Detailed

if iLoD2D = SYMBW_D_2GLASS then 			! Detailed --> NOR 50
	iSymbolGlassType		= SYMBGLASS_DOUBLEGLASS
endif


!!!!	Chinese Symbol	!!!
if lod2D = DET2D_FS_SIMPLE_CHI | lod2D = DET2D_FS_DETAILED_CHI then

	pen gs_pen_2d
	fill gs_fillShCover


	if GLOB_SCRIPT_TYPE <> 2 & GLOB_CONTEXT <> 22 then
		widoOrigDist = -WIDO_ORIG_DIST
	else
		widoOrigDist =  WIDO_ORIG_DIST
	endif


	signrotangle = (ABS(SYMB_ROTANGLE-180) < EPS) - not(SYMB_ROTANGLE)
	signrevealside = not(WIDO_REVEAL_SIDE) - WIDO_REVEAL_SIDE
	SymbolMid_shiftDy = (WIDO_SILL - WALL_THICKNESS / 2 + WIDO_FRAME_THICKNESS / 2) * signrevealside
	wallIsLeft		= (SYMB_ROTANGLE > EPS) exor WIDO_REVEAL_SIDE
	signWallIsLeft	= wallIsleft - not(wallIsleft)


	WOD = abs(widoOrigDist) + signrotangle * (SymbolMid_shiftDy)

	halfA = A / 2

	alpha = atn(halfA / (WOD - (ABS(SYMB_ROTANGLE-180) < EPS) * WIDO_FRAME_THICKNESS))



	Rad = halfA / sin(alpha) - signrotangle * (SymbolMid_shiftDy)/ cos(alpha) + signrotangle * (SymbolMid_shiftDy)

			poly2_b{2} 5, 1 + 2 * (gs_fillFr > 0) + 4 + 8 + 16 + 32, gs_penShCov_fg, gs_penShCov_bg,
				0, 0, 0,
				0, -signrotangle * WOD, 901,
				(Rad + WIDO_FRAME_THICKNESS) * sin(alpha), -signrotangle * (WOD - (Rad + WIDO_FRAME_THICKNESS) * cos(alpha)), 1,
				-(Rad + WIDO_FRAME_THICKNESS) * sin(alpha), -signrotangle * (WOD - (Rad + WIDO_FRAME_THICKNESS) * cos(alpha)), 3000,
				-Rad * sin(alpha), -signrotangle * (WOD - Rad * cos(alpha)), 1,
				Rad * sin(alpha), -signrotangle * (WOD - Rad * cos(alpha)), 3000


endif





if gs_frame_pen_cont = 0 then gs_frame_pen_cont = gs_pen_2D

bGlass 	= (lod2D > 20) & iMullionStyle <> MULLION_SOLID_PANEL
s1_bEndLines = 1		! was: bListView

if WIDO_REVEAL_SIDE = (SYMB_ROTANGLE > EPS) then
	iSign = -1
	NWOD = WOD - WIDO_REVEAL_SIDE * WIDO_FRAME_THICKNESS
else
	iSign = 1
	NWOD = WOD + WIDO_REVEAL_SIDE * WIDO_FRAME_THICKNESS
endif

alpha = atn(refWidth / 2 / NWOD)
Rad = NWOD / cos(alpha)

add2 0, WIDO_ORIG_DIST
if (SYMB_ROTANGLE > EPS) then
	mul2 1,1
else
	mul2 1,-1
endif

!!!circle2 0,0, Rad

ArcLengthToAngle = 180 / Rad / PI
alfaFrameWidth = (gs_frame_width) * ArcLengthToAngle

alfa_left_ovh_in = gs_frame_ovhg_left_in
alfa_left_ovh_out = gs_frame_ovhg_left_out

alfa_right_ovh_in = gs_frame_ovhg_right_in
alfa_right_ovh_out = gs_frame_ovhg_right_out


sideA = Rad
sideB = Rad - iSign * gs_frame_thk
sideBSolidPanel = Rad - iSign * (gs_frame_thk - gs_sash_thk * (iMullionStyle = MULLION_SOLID_PANEL))

toleranceLeft	= leftWidth - A/2
toleranceRight	= rightWidth - A/2
dx = (toleranceRight - toleranceLeft) / 2

alfaLeft  = atn((A / 2 + dx) / (NWOD - (WIDO_REVEAL_SIDE = (SYMB_ROTANGLE < EPS)) * WIDO_FRAME_THICKNESS))
alfaRight = atn((A / 2 - dx) / (NWOD - (WIDO_REVEAL_SIDE = (SYMB_ROTANGLE < EPS)) * WIDO_FRAME_THICKNESS))


! =============================================================================
! Curved window panel - Simple symbol
! =============================================================================

if lod2D = DET2D_FS_SIMPLE_ONE then
	pen gs_pen_2D
	line_property 0

	arc2 0,0, Rad, 90 - alfaRight, 90 + alfaLeft

	if bShowUnitHotspots then
		hotspot2 Rad * sin(-alfaLeft - gs_frame_ovhg_left_out),  Rad * cos(-alfaLeft - gs_frame_ovhg_left_out),  100
		hotspot2 Rad * sin(alfaRight + gs_frame_ovhg_right_out), Rad * cos(alfaRight + gs_frame_ovhg_right_out), 101
	endif

	end ! =============================================================== END =
endif


! =============================================================================
! Curved window panel - Basic and Detailed symbol
! =============================================================================

if lod2D > DET2D_FS_SIMPLE_ONE & lod2D<>DET2D_FS_SIMPLE_CHI & lod2D <> DET2D_FS_DETAILED_CHI then

	sAlfa = sin(alfaFrameWidth)
	cAlfa = cos(alfaFrameWidth)

	pen gs_frame_pen_cont
	line_property 2
	fill gs_fillFr

	! left window frame
	if gs_bFrameLeft then
		rot2 alfaLeft

		px1 = sideB * sin(-alfa_left_ovh_in)
		py1 = sideB * cos(-alfa_left_ovh_in)
		px2 = sideA * sin(-alfa_left_ovh_out)
		py2 = sideA * cos(-alfa_left_ovh_out)

		poly2_b 6, 1+2+4+16+32, gs_penFr_fg, gs_penFr_bg,
				px1,			py1,			32 + s1_bEndLines,
				px2,			py2,			32 + 1,
				0,				0,				32 + 901,
				sideA * sAlfa,	sideA * cAlfa,	32 + 3001,
				sideB * sAlfa,	sideB * cAlfa,	32 + 1,
				0,				sideB,			32 + 3001

		!!! Tolerance separator line
		line2 0, sideA, 0, sideB


		!!! Unit hotspots
		if bShowUnitHotspots then
			hotspot2 0, sideA, 100
			hotspot2 0, sideB, 102
		endif

		del 1
	endif

	! right window frame
	if gs_bFrameRight then
		rot2 -alfaRight

		px1 = -sideB * sin(-alfa_right_ovh_in)
		py1 =  sideB * cos(-alfa_right_ovh_in)
		px2 = -sideA * sin(-alfa_right_ovh_out)
		py2 =  sideA * cos(-alfa_right_ovh_out)

		poly2_b 6, 1+2+4+16+32, gs_penFr_fg, gs_penFr_bg,
				px1,			py1,			32 + s1_bEndLines,
				px2,			py2,			32 + 1,
				0,				0,				32 + 901,
				-sideA * sAlfa,	sideA * cAlfa,	32 + 3001,
				-sideB * sAlfa,	sideB * cAlfa,	32 + 1,
				0,				sideB,			32 + 3001

		!!! Tolerance separator line
		line2 0, sideA, 0, SideB

		!!! Unit hotspots
		if bShowUnitHotspots then
			hotspot2 0, sideA, 101
			hotspot2 0, SideB, 103
		endif

		del 1
	endif

	pen gs_pen_2D

	alfaRightPos = alfaRight - gs_bFrameRight * (alfaFrameWidth)
	alfaLeftPos  = alfaLeft  - gs_bFrameLeft  * (alfaFrameWidth)

	! --- glass line in the center of the frame ---
	if iSymbolGlassType = SYMBGLASS_DOUBLEGLASS then
		line_property 2
		arc2 0, 0, sideA - iSign * gs_frame_thk / 2 + gs_glass_thk / 2, 90 - alfaRightPos, 90 + alfaLeftPos
		arc2 0, 0, sideA - iSign * gs_frame_thk / 2 - gs_glass_thk / 2, 90 - alfaRightPos, 90 + alfaLeftPos
	else
		line_property 1
		if not(bShowVertGrid) | iVertGrid = 0 then
			arc2 0,0, sideA - iSign * gs_frame_thk / 2, 90 - alfaRightPos, 90 + alfaLeftPos
		else
			for i = 1 to iVertGrid+1
				VertGridAngle = atn((gs_vert_grid_curved[i][2]) / (NWOD - (WIDO_REVEAL_SIDE = (SYMB_ROTANGLE < EPS)) * WIDO_FRAME_THICKNESS))

				if i = 1 then
					arc2 0,0, sideA - iSign * gs_frame_thk / 2, 90 - alfaRightPos, 90 - alfaRight + gs_vert_grid_curved[1][1] - VertGridAngle / 2
				else
					arc2 0,0, sideA - iSign * gs_frame_thk / 2, 90 - alfaRight + gs_vert_grid_curved[i-1][1] + VertGridAngle / 2, 90 - alfaRight + gs_vert_grid_curved[i][1] - VertGridAngle/2
				endif

			next i
		endif
	endif

	! --- horizontal lines and cover fill ---
	fill gs_fillShCover

	if iMullionStyle = MULLION_SOLID_PANEL then
		poly2_b 5, 1 + 2 * (gs_fillShCover > 0) + 4 + 16 + 64, gs_penShCov_fg, gs_penShCov_bg,
			0,0, 901,
			sideA * sin(-alfaLeftPos),				sideA * cos(-alfaLeftPos),	1,
			sideA * sin(alfaRightPos),				sideA * cos(alfaRightPos),	3000,
			sideBSolidPanel * sin(alfaRightPos),	sideBSolidPanel * cos(alfaRightPos),	1,
			sideBSolidPanel * sin(-alfaLeftPos),	sideBSolidPanel * cos(-alfaLeftPos),	3000

		fill gs_fillSh
		line_property 2
		poly2_b 5, 1 + 2 * (gs_fillSh > 0) + 4 + 16 + 64, gs_penSh_fg, gs_penSh_bg,
			0,0, 901,
			sideB * sin(-alfaLeftPos),				sideB * cos(-alfaLeftPos),	32 + 1,
			sideB * sin(alfaRightPos),				sideB * cos(alfaRightPos),	3032 + 1,
			sideBSolidPanel * sin(alfaRightPos),	sideBSolidPanel * cos(alfaRightPos),	32 + 1,
			sideBSolidPanel * sin(-alfaLeftPos),	sideBSolidPanel * cos(-alfaLeftPos),	3032 + 1
	else
		poly2_b 5, 1 + 2 * (gs_fillShCover > 0) + 4 + 16 + 64, gs_penShCov_fg, gs_penShCov_bg,
			0,0, 901,
			sideA * sin(-alfaLeftPos),	sideA * cos(-alfaLeftPos),	1,
			sideA * sin(alfaRightPos),	sideA * cos(alfaRightPos),	3000,
			sideB * sin(alfaRightPos),	sideB * cos(alfaRightPos),	1,
			sideB * sin(-alfaLeftPos),	sideB * cos(-alfaLeftPos),	3000
	endif

	! --- Vertical Grids----------------------
	if bShowVertGrid then
		fill gs_fillShCover
		rot2 alfaLeft
		for i = 1 to iVertGrid
			rot2 -gs_vert_grid_curved[i][1]
			add2 0, sideA - iSign * ( gs_frame_thk / 2) + VertGridThk / 2

			poly2_b 4, 1+2+4+16+32, gs_penFr_fg, gs_penFr_bg,
					- gs_vert_grid_curved [i][2] / 2, 0,            32 + 1,
					+ gs_vert_grid_curved [i][2] / 2, 0,            32 + 1,
					+ gs_vert_grid_curved [i][2] / 2, -VertGridThk, 32 + 1,
					- gs_vert_grid_curved [i][2] / 2, -VertGridThk, 32 + 1
			del 2
		next i
		del 1
	endif

endif

del 2




