
! Contact person: <NJ>

! ==============================================================================
! This macro draws the Casing
! ------------------------------------------------------------------------------
! Input parameters:
! Geometry ---------------------------------------------------------------------
!	A:						wallhole width (length) (Obsolete)
!	B:						wallhole height (length)
!	refWidth:				reference width in curved walls (length)
!	leftWidth:				wallhole's side distance from the origin at the left side (length)
!	rightWidth:				wallhole's side distance from the origin at the right side (length)
!	AC_Hole_Position_Angle:	Position angle of the window in a curved wall
!	offsY:					for positioning 3D along y (length)
! Functions --------------------------------------------------------------------
!	gs_IsCurved:			Does the window follow the curvature of the wall? (0 / 1)
!	iWindowShape:			Shape of the window (integer)
!								0 = rectangular (default)
!								1 = arched
!							Note: only the rectangular shape can be a Corner Window
!	archHeight:				Height of the arc (length)
!	nArchResolution:		Arc resolution for arched windows (integer)
!								if nArchResolution < 3 then WALL_RESOL used instead
! Reveal -----------------------------------------------------------------------
!	iRevealType:
!	gs_reveal_left_angle:
!	gs_reveal_right_angle:
! Corner Function --------------------------------------------------------------
!	bLeftCornerFunction:		Turn macro in Corner Window mode at the left side (0 / 1)
!	leftCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	leftConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
!	bRightCornerFunction:	Turn macro in Corner Window mode at the right side (0 / 1)
!	rightCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	rightConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
! Oversize ---------------------------------------------------------------------
!	gs_left_oversize:		Left opening oversize (length)
!	gs_right_oversize:		Right opening oversize (length)
!	gs_upper_oversize:		Upper opening oversize (length)
!	gs_lower_oversize:		Lower opening oversize (length)
! Casing -----------------------------------------------------------------------
!	gs_trim_inside:
!	gs_trim_outside:
!	gs_trim_width_in:		Width of inside Trim. (length)
!	gs_trim_width_out:		Width of outside Trim. (length)
!	gs_trim_offs_in:		Offset of Casing inside. (length)
!	gs_trim_offs_out:		Offset of Casing outside. (length)
!	gs_trim_thk_in:			Thickness of inside Trim. (length)
!	gs_trim_thk_out:		Thickness of outside Trim. (length)
!	gs_tw_left_in:			Width of inside casing on the left (length)
!	gs_tw_right_in:			Width of inside casing on the right (length)
!	gs_tw_top_in:			Width of inside head casing (length)
!	gs_tw_bottom_in:		Width of inside casing on the bottom (length)
!	gs_tw_left_out:			Width of outside casing on the left (length)
!	gs_tw_right_out:		Width of outside casing on the right (length)
!	gs_tw_top_out:			Width of outside head casing (length)
!	gs_tw_bottom_out:		Width of outside casing on the bottom (length)
! Sill -------------------------------------------------------------------------
!	iSillType:				Identifies the type of the Sill.
!								(integer; 1 = Standard Sill, 2 = Brick Sill, 3 = Stone Sill, 4 = Ceramic Sill)
!								(5 = Eternite Sill, 6 = Concrete Tub, 7 = Aluminum Sill)
!	gs_board_thk:			Thickness of the Board. (length)
! Ganging ----------------------------------------------------------------------
!	gs_stack_left:			Align to door/window on left side (0 / 1)
!	gs_stack_right:			Align to door/window on right side (0 / 1)
!	gs_stack_top:			Align to door/window on upper side (0 / 1)
!	gs_stack_bottom:		Align to door/window on bottom side (0 / 1)
! 2D Representation ------------------------------------------------------------
!	gs_trim_pen_cont:		Cotour pen of the cutted Trim.
!								If it is zero then SYMB_FILL_PEN defines the cutted contour pen. (pen)
!	gs_trim_fill_in:		Type of the fill on the inside Trim. (fill type)
!	gs_trim_pen_fg_in:		Fill pen on the inside Trim. (pen)
!	gs_trim_pen_bg_in:		Fill background pen on the inside Trim. (pen)
!	gs_trim_fill_out:		Type of the fill on the outside Trim. (fill type)
!	gs_trim_pen_fg_out:		Fill pen on the outside Trim. (pen)
!	gs_trim_pen_bg_out:		Fill background pen on the outside Trim. (pen)
! 3D Representation ------------------------------------------------------------
!	lod3D:					Level of detail. Not used. (integer)
!	gs_frame_pen:			Drawing pen of 3D. (pen)
! Materials --------------------------------------------------------------------
!	gs_trim_in_mat:			Inside trim material (material)
!	gs_trim_out_mat:		Outside trim material (material)
!
! Related Global Variables:
!	GLOB_SCRIPT_TYPE
!	GLOB_CONTEXT
!	WALL_THICKNESS
!	WALL_INCL
!	WALL_RESOL
!	WIDO_FRAME_THICKNESS
!	WIDO_SILL
!	WIDO_ORIG_DIST
!	WIDO_REVEAL_SIDE
!	SYMB_MIRRORED
!	SYMB_ROTANGLE
!	SYMB_FILL
!	SYMB_SECT_PEN
!	SYMB_FILL_PEN
!	SYMB_FBGD_PEN
! ==============================================================================

if	iWindowShape <> SHAPE_RECTANGULAR &\
	iWindowShape <> SHAPE_ARCHED &\
	iWindowShape <> SHAPE_ELLIPSEARCH &\
	iWindowShape <> SHAPE_T &\
	iWindowShape <> SHAPE_HALF_T_LEFT &\
	iWindowShape <> SHAPE_ARCHED_T &\
	iWindowShape <> SHAPE_ARCHED_HALF_T_LEFT &\
	iWindowShape <> SHAPE_HALF_T_RIGHT &\
	iWindowShape <> SHAPE_ARCHED_HALF_T_RIGHT then end

if lod3D = 0 then end
if (bInsideCasingNotAvailableByReveal |\
	bInsideCasingNotAvailableByWallType |\
	bInsideCasingNotAvailableByFrameStyle) then
	bDrawInsideTrim  = 0
endif
if (bOutsideCasingNotAvailableByReveal |\
	bOutsideCasingNotAvailableByFrameStyle) then
	bDrawOutsideTrim = 0
endif
if not(bDrawInsideTrim | bDrawOutsideTrim) then end

bShapeEnablesStraightBottomTrim = (	iWindowShape = SHAPE_RECTANGULAR | \
									iWindowShape = SHAPE_ARCHED | \
									iWindowShape = SHAPE_ELLIPSEARCH )
bShapeEnablesStraightLeftTrim   = (	iWindowShape = SHAPE_RECTANGULAR | \
									iWindowShape = SHAPE_ARCHED | \
									iWindowShape = SHAPE_ELLIPSEARCH | \
									iWindowShape = SHAPE_T | \
									iWindowShape = SHAPE_HALF_T_LEFT | \
									iWindowShape = SHAPE_HALF_T_RIGHT | \
									iWindowShape = SHAPE_ARCHED_T | \
									iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | \
									iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT )
bShapeEnablesStraightRightTrim  = (	iWindowShape = SHAPE_RECTANGULAR | \
									iWindowShape = SHAPE_ARCHED | \
									iWindowShape = SHAPE_ELLIPSEARCH | \
									iWindowShape = SHAPE_T | \
									iWindowShape = SHAPE_HALF_T_LEFT | \
									iWindowShape = SHAPE_HALF_T_RIGHT | \
									iWindowShape = SHAPE_ARCHED_T | \
									iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | \
									iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT )
bShapeEnablesStraightTopTrim    = (	iWindowShape = SHAPE_RECTANGULAR | \
									iWindowShape = SHAPE_T | \
									iWindowShape = SHAPE_HALF_T_LEFT | \
									iWindowShape = SHAPE_HALF_T_RIGHT )
bShapeEnablesArchedTopTrim 		= (	iWindowShape = SHAPE_ARCHED | \
									iWindowShape = SHAPE_ARCHED_T | \
									iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | \
									iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT )

! === wido jamb values =========================================================

widoLeftJamb	= gs_reveal_left
widoRightJamb	= gs_reveal_right


! === Initialized variables ====================================================[

archTrimDiff	= 0
bHalfCircle		= 0
pocketThkLeft	= 0
pocketThkRight	= 0

! ]=== End of initialized variables ============================================


! Save the current parameter buffer ============================================

dim savedQueueValues[]
call "SaveQueue" parameters returned_parameters savedQueueValues


gs_trim_pen_cont_out	= gs_trim_pen_cont
gs_trim_pen_cont_in		= gs_trim_pen_cont

if gs_trim_fill_in		< 1 then gs_trim_fill_in	= SYMB_FILL
if gs_trim_pen_bg_in	< 1 then gs_trim_pen_bg_in	= SYMB_FBGD_PEN
if gs_trim_pen_fg_in	< 1 then gs_trim_pen_fg_in	= SYMB_FILL_PEN
if gs_trim_fill_out		< 1 then gs_trim_fill_out	= SYMB_FILL
if gs_trim_pen_bg_out	< 1 then gs_trim_pen_bg_out	= SYMB_FBGD_PEN
if gs_trim_pen_fg_out	< 1 then gs_trim_pen_fg_out	= SYMB_FILL_PEN

if AC_HoleSideMaterial then
	if WIDO_REVEAL_SIDE then
		matWallOut	= WALL_MAT_A
		matWallIn	= WALL_MAT_B
	else
		matWallOut	= WALL_MAT_B
		matWallIn	= WALL_MAT_A
	endif
else
	matWallOut	= WALL_MAT_EDGE
	matWallIn	= WALL_MAT_EDGE
endif

muly -1
if WIDO_REVEAL_SIDE then
	mulz -1
	addz -WIDO_FRAME_THICKNESS
endif

! === Window Shape related definitions ========================================[

if nArchResolution < 3 then nArchResolution = WALL_RESOL

if	bShapeEnablesArchedTopTrim then
	if archHeight < EPS then
		if iWindowShape = SHAPE_ARCHED				then iWindowShape = SHAPE_RECTANGULAR
		if iWindowShape = SHAPE_ARCHED_T			then iWindowShape = SHAPE_T
		if iWindowShape = SHAPE_ARCHED_HALF_T_LEFT	then iWindowShape = SHAPE_HALF_T_LEFT
		if iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT	then iWindowShape = SHAPE_HALF_T_RIGHT
	else
		if archHeight > ((leftWidth + rightWidth) / 2 - EPS) then
			archHeight = (leftWidth + rightWidth) / 2
			arcR = archHeight
			bHalfCircle = 1
		else
			arcR = ((leftWidth + rightWidth) / 2) / sin(2 * atn((archHeight) / ((leftWidth + rightWidth) / 2)))
			bHalfCircle = 0
		endif
	endif
endif

if iWindowShape = SHAPE_ELLIPSEARCH then
	openingWidth = (leftWidth + rightWidth - tolerOffsetLeftIn - tolerOffsetRightIn)

	middleRadiusEllips = (openingWidth * openingWidth / 4 - openingWidth * smallRadiusEllips + archHeight * archHeight) / (2 * archHeight - 2 * smallRadiusEllips)

	alphaSide = atn ((middleRadiusEllips - archHeight) / (openingWidth / 2 - smallRadiusEllips))
	alphaMiddle = (90 - alphaSide) * 2
endif

if	iWindowShape <> SHAPE_ARCHED &\
	iWindowShape <> SHAPE_ELLIPSEARCH &\
	iWindowShape <> SHAPE_ARCHED_T &\
	iWindowShape <> SHAPE_ARCHED_HALF_T_LEFT &\
	iWindowShape <> SHAPE_ARCHED_HALF_T_RIGHT then archHeight = 0

! ]=== Window Shape related definitions ========================================


! ==============================================================================
! Common Calculations for Trims
! ==============================================================================

bHolePosSign = (SYMB_MIRRORED exor (SYMB_ROTANGLE > EPS) exor (AC_Hole_Position_Angle < 0))
iHolePosSign = (not(bHolePosSign) - bHolePosSign)

if bLeftCornerFunction then
	! --- Push left side trim ---
	beta_left = atn ((leftConnWallThk * sin(leftCornerAngle)) / (WALL_THICKNESS + leftConnWallThk * cos(leftCornerAngle)))

	if leftCornerAngle > 180 then
		overSizeLeft = max (0, WALL_THICKNESS / tan(360 - leftCornerAngle + beta_left) + WIDO_SILL / tan(leftCornerAngle / 2))
	else
		overSizeLeft = (WIDO_FRAME_THICKNESS + WIDO_SILL) * lx + max (0, WALL_THICKNESS * tan(leftCornerAngle - beta_left - 90))
	endif
	overSizeLeft = overSizeLeft + abs(gs_trim_thk_in / tan(leftCornerAngle / 2)) + gs_tw_left_out + gs_tw_left_in + 0.1
	overSizeLeftOut = overSizeLeft
	overSizeLeftIn 	= overSizeLeft
endif


if bRightCornerFunction then
	! --- Push right side trim ---
	beta = atn ((rightConnWallThk * sin(rightCornerAngle)) / (WALL_THICKNESS + rightConnWallThk * cos(rightCornerAngle)))

	if rightCornerAngle > 180 then
		overSizeRight = max (0, WALL_THICKNESS / tan(360 - rightCornerAngle + beta) + WIDO_SILL / tan(rightCornerAngle / 2))
	else
		overSizeRight = (WIDO_FRAME_THICKNESS + WIDO_SILL) * rx + max (0, WALL_THICKNESS * tan(rightCornerAngle - beta - 90))
	endif
	overSizeRight = overSizeRight + abs(gs_trim_thk_in / tan(rightCornerAngle / 2)) + gs_tw_right_out + gs_tw_right_in + 0.1
	overSizeRightOut = overSizeRight
	overSizeRightIn	 = overSizeRight
endif


if gs_stack_top then
	overSizeTop = gs_upper_oversize
	overSizeTopIn = gs_upper_oversize
else
	overSizeTop = 0
	overSizeTopIn = 0 - widoInnerTopJamb + sfty
endif

if gs_stack_bottom then
	overSizeBottom = gs_lower_oversize
	overSizeBottomIn = gs_lower_oversize
else
	overSizeBottom = 0
	overSizeBottomIn = -not(bDrawBoard) * widoInnerBottomJamb + sfby - bDrawBoard * boardBottom
endif

if gs_trim_show_cover_in then
	gs_trim_jambext_nosing_in = 0
endif
if gs_trim_show_cover_out then
	gs_trim_jambext_nosing_out = 0
endif


resol WALL_RESOL

bCutWall = not (GLOB_CONTEXT > 40 & GLOB_CONTEXT < 50)

bDrawLeftTrimatGangingIn	= not(bLeftCornerFunction) & bShapeEnablesStraightLeftTrim & gs_stack_left & gs_trim_stack_left
bDrawRightTrimatGangingIn	= not(bRightCornerFunction) & bShapeEnablesStraightRightTrim & gs_stack_right & gs_trim_stack_right
bDrawBottTrimatGangingIn	= isWindow & bShapeEnablesStraightBottomTrim & abs(tolerOffsStackCasLowerIn + trinB - gs_trim_offs_in) > EPS & gs_stack_bottom & gs_trim_stack_bottom
bDrawTopTrimatGangingIn		= bShapeEnablesStraightTopTrim & gs_stack_top & abs(-tolerOffsStackCasUpperIn - trinT + gs_trim_offs_in) > EPS & gs_trim_stack_top

bDrawLeftTrimatGangingOut	= not(bLeftCornerFunction) & bShapeEnablesStraightLeftTrim & gs_stack_left & gs_trim_stack_left
bDrawRightTrimatGangingOut	= not(bRightCornerFunction) & bShapeEnablesStraightRightTrim & gs_stack_right & gs_trim_stack_right
bDrawBottTrimatGangingOut	= bShapeEnablesStraightBottomTrim & gs_stack_bottom & ABS(tolerOffsStackCasLowerOut + trim_offs_out_modify - gs_trim_offs_out)>EPS & (iSillType < 2 | not(bDrawBoard)) & gs_trim_stack_bottom
bDrawTopTrimatGangingOut	= bShapeEnablesStraightTopTrim & gs_stack_top & ABS(-tolerOffsStackCasUpperOut - trim_offs_out_modify + gs_trim_offs_out)>EPS & gs_trim_stack_top

bGangedCasingonFrame = abs(WIDO_FRAME_THICKNESS - WALL_THICKNESS) > EPS

! ==============================================================================
!	Draw Trims
! ==============================================================================

if (gs_trimtype_out_int = CASING_COMPLEX) then
	if bArchitraveCapital then
		if	(iArchitraveCapitalType = ARCH_CAPITAL_SQUARE_ONSIDE |\
			 iArchitraveCapitalType = ARCH_CAPITAL_SQUARE_NEXTSIDE) then

			_offsetTop		= 0.01
			_thickBracket	= 0.06
		endif

		if	(iArchitraveCapitalType = ARCH_CAPITAL_DECOR_ONSIDE |\
			 iArchitraveCapitalType = ARCH_CAPITAL_DECOR_NEXTSIDE) then

			_offsetTop		= 0.01
			_thickBracket	= 0.07
		endif

!!!		if iArchitraveCapitalType = 0 then
!!!			_offsetTop		= 0.021
!!!			_thickBracket	= 0.039
!!!		endif
	else
		_offsetTop		= 0.01
		_thickBracket	= 0.035
	endif
endif

if gs_stack_top then
	overSizeTop = gs_upper_oversize
else
	overSizeTop = 0
endif

if gs_stack_bottom then
	overSizeBottom = gs_lower_oversize
else
	if bDrawSill then
		overSizeBottom = -sillBottomOutside + widoThresDepth
	else
		overSizeBottom = - widoThresDepth * not(isWindow)
	endif
endif
overSizeBottomLeft	= overSizeBottom
overSizeBottomRight	= overSizeBottom
if	(bPShapedLeftOpening & not(bDrawLeftSLSill))		| \
	(bTShapedOpening & gs_sidelight_parapet_hgt_left < EPS)		| \
	(bPShapedRightOpening & iWindowShape <> SHAPE_T)		then overSizeBottomLeft = 0
if	(bPShapedRightOpening & not(bDrawRightSLSill))		| \
	(bTShapedOpening & gs_sidelight_parapet_hgt_right < EPS)	| \
	(bPShapedLeftOpening & iWindowShape <> SHAPE_T)			then overSizeBottomRight = 0

! Calculate overhangs to cutting of top and bottom casing in case of corner opening

if gs_trim_show_cover_in then
	casingOverhangIn = gs_trim_thk_in
else
	casingOverhangIn = gs_trim_jambext_nosing_in
endif
if gs_trim_show_cover_out then
	if (gs_trimtype_out_int = CASING_COMPLEX) & (iCasingHeadTypeOut <> CASING_HEAD_RECT) then
		casingOverhangOut = gs_trim_thk_out + _thickBracket + _offsetTop
	else
		casingOverhangOut = gs_trim_thk_out
	endif
else
	casingOverhangOut = gs_trim_jambext_nosing_out
endif


bHasCasingSetBackIn	 = (casingSetBackOnSides_in  > EPS & casingSetBackOnSides_in  < WALL_THICKNESS - (WIDO_SILL + WIDO_FRAME_THICKNESS))
bHasCasingSetBackOut = (casingSetBackOnSides_out > EPS & casingSetBackOnSides_out < WIDO_SILL)

bShowEdgesAtFrame = (not(bDrawOutsideTrim & bDrawInsideTrim  ) |\
					 abs(gs_trim_width_in - gs_trim_width_out) > EPS |\
					 (gs_trim_in_mat <> gs_trim_out_mat) |\
					 abs(WIDO_FRAME_THICKNESS) > EPS |\
					 (bHasCasingSetBackIn | bHasCasingSetBackOut))

! ==============================================================================
! Cut on Board side
! ==============================================================================

numCuts = 0

material gs_trim_in_mat

if bRightCornerFunction then

	! --- Cut right side in case of Corner Window ---

	if bFitModeRight then
		add rightCwDx + rightCwDx2 + rightWidth - (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS + casingOverhangIn) * rx, 0, WALL_THICKNESS - WIDO_SILL + casingOverhangIn
		rotx 90

!!!		maxDist = WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS + casingOverhangIn + EPS
		maxDist = WALL_THICKNESS - min(0, WIDO_SILL) + casingOverhangOut + casingOverhangIn

		if abs(maxDist) > EPS then
			cutpolya 4, 2, 0,
				0, 0, 10,
				maxDist / tan(rightCornerAngle / 2), -maxDist, 10,
				10 * A, -maxDist, 8,
				10 * A, 0, 8

			numCuts = numCuts + 1
		endif
		del 2
	else
		rotx 90

		if WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS < -EPS then
			cutpolya 4, 2, 0,
				10 * A,																									WALL_THICKNESS - WIDO_SILL - EPS,	8,
				rightCwDx + rightCwDx2 + rightWidth - (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS - EPS) * rx,	WALL_THICKNESS - WIDO_SILL - EPS,	10,
				rightCwDx + rightWidth,																					WIDO_FRAME_THICKNESS,				8,
				10 * A,																									WIDO_FRAME_THICKNESS,				8
		else
			cutpolya 5, 2, 0,
				10 * A, 																											WALL_THICKNESS - WIDO_SILL + casingOverhangIn,				8,
				rightCwDx + rightCwDx2 + rightWidth - (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS + casingOverhangIn) * rx,	WALL_THICKNESS - WIDO_SILL + casingOverhangIn,				10,
				rightCwDx + rightWidth - rightCwDx2 * cos(rightCornerAngle),														WIDO_FRAME_THICKNESS + rightCwDx2 * sin(rightCornerAngle),	8,
				rightCwDx + rightWidth,																								WIDO_FRAME_THICKNESS,										8,
				10 * A,																												WIDO_FRAME_THICKNESS,										8
		endif

		numCuts = numCuts + 1
		del 1
	endif
endif

if bLeftCornerFunction then

	! --- Cut left side in case of Corner Window ---

	if bFitModeLeft then
		add -leftCwDx - leftCwDx2 - leftWidth + (WALL_THICKNESS - WIDO_SILL- WIDO_FRAME_THICKNESS + casingOverhangIn) * lx, 0, WALL_THICKNESS - WIDO_SILL + casingOverhangIn
		rotx 90

!!!		maxDist = WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS + casingOverhangIn + EPS
		maxDist = WALL_THICKNESS - min(0, WIDO_SILL) + casingOverhangOut + casingOverhangIn

		if abs(maxDist) > EPS then
			cutpolya 4, 1, 0,
				0, 0, 10,
				-maxDist / tan(leftCornerAngle / 2), -maxDist, 10,
				-10 * A, -maxDist, 8,
				-10 * A, 0, 8

			numCuts = numCuts + 1
		endif
		del 2
	else

		rotx 90

		if WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS < -EPS then
			cutpolya 4, 1, 0,
				-10 * A, 																							WALL_THICKNESS - WIDO_SILL - EPS,	8,
				-leftCwDx - leftCwDx2 - leftWidth + (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS - EPS) * lx,	WALL_THICKNESS - WIDO_SILL - EPS,	10,
				-leftCwDx - leftWidth,																				WIDO_FRAME_THICKNESS,				8,
				-10 * A,																							WIDO_FRAME_THICKNESS,				8
		else
			cutpolya 5, 1, 0,
				-10 * A, 																										WALL_THICKNESS - WIDO_SILL + casingOverhangIn,				8,
				-leftCwDx - leftCwDx2 - leftWidth + (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS + casingOverhangIn) * lx,WALL_THICKNESS - WIDO_SILL + casingOverhangIn,				10,
				-leftCwDx - leftWidth + leftCwDx2 * cos(leftCornerAngle),														WIDO_FRAME_THICKNESS + leftCwDx2 * sin(leftCornerAngle),	8,
				-leftCwDx - leftWidth,																							WIDO_FRAME_THICKNESS,										8,
				-10 * A,																										WIDO_FRAME_THICKNESS,										8
		endif

		numCuts = numCuts + 1
		del 1
	endif
endif

! --- Casing Set Back on Sides ---
if bHasCasingSetBackIn then
	add 0, -gs_trim_width_in * isWindow, casingSetBackOnSides_in + WIDO_FRAME_THICKNESS
	rotx 90

	material gs_trim_in_mat
	cutform 4, 1, 1+2,
		0, 0, 1, B*2,
		lengthCasingSetback/2,	0,							1,
		lengthCasingSetback/2,	-casingSetBackOnSides_in,	1,
		-lengthCasingSetback/2,	-casingSetBackOnSides_in,	1,
		-lengthCasingSetback/2,	0,							1
	numCuts = numCuts + 1
	del 2
endif


! ==============================================================================
!	Draw Inside Trim
! ==============================================================================

if bDrawInsideTrim then

	material gs_trim_in_mat

	if	bPShapedLeftOpening & not(gs_trim_below_boardLeft)then

		add -boardRight_sL, -gs_sidelight_parapet_hgt_left - boardSideHeight + (gs_reveal_double_innerBottom_sL - gs_reveal_bottom), WIDO_FRAME_THICKNESS
		roty 90
		rotz -90

		cutform 4, 1, 2+16,
			0, 0, 1, EPS,
			0,0,15,
			-0.5 * tan(boardSideAngle), -0.5, 15,
			-0.5 * tan(boardSideAngle) - 0.5, -0.5, 15,
			-0.5 * tan(boardSideAngle) - 0.5, 0, 15
		numCuts = numCuts + 1
		del 3
	endif

	if	bPShapedRightOpening & not(gs_trim_below_boardRight) then

		add boardLeft_sR, -gs_sidelight_parapet_hgt_right - boardSideHeight + (gs_reveal_double_innerBottom_sR - gs_reveal_bottom), WIDO_FRAME_THICKNESS
		roty 90
		rotz -90
		mulz -1

		cutform 4, 1, 2+16,
			0, 0, 1, EPS,
			0,0,15,
			-0.5 * tan(boardSideAngle), -0.5, 15,
			-0.5 * tan(boardSideAngle) - 0.5, -0.5, 15,
			-0.5 * tan(boardSideAngle) - 0.5, 0, 15
		numCuts = numCuts + 1
		del 4
	endif

	if bBoardPlaneCut then
		add 0, -boardSideHeight, WIDO_FRAME_THICKNESS
		rotx -90 - boardSideAngle
		cutplane
		numCuts = numCuts + 1
		del 2
	endif

	if bThresholdBoardPlaneCut then
		add 0, -ThresholdBoardSideHeight, WIDO_FRAME_THICKNESS
		rotx -90
		cutplane
		numCuts = numCuts + 1
		del 2
	endif

	gosub 1000

endif


! ==============================================================================
!	Draw Apron
! ==============================================================================

if gs_apron then
	gosub 3000
endif

! ==============================================================================

for i = 1 to numCuts
	cutend
next i


! ==============================================================================
! Cut on Sill side
! ==============================================================================

numCuts = 0

material gs_trim_out_mat

if bRightCornerFunction then

	! --- Cut right side in case of Corner Window ---

	add rightCwDx + rightWidth + WIDO_FRAME_THICKNESS * rx, 0, 0
	rotx 90

	maxDist  = WIDO_SILL + casingOverhangOut

	if abs(maxDist) > EPS then
		cutpolya 4, 1, 0,
			0, 0, 8,
			maxDist / tan(rightCornerAngle / 2), -maxDist, 10,
			10 * A, -maxDist, 8,
			10 * A, 0, 8

		numCuts = numCuts + 1
	endif

	del 2
endif

if bLeftCornerFunction then

	! --- Cut left side in case of Corner Window ---

	add -leftCwDx - leftWidth - WIDO_FRAME_THICKNESS * lx, 0, 0
	rotx 90

	maxDist  = WIDO_SILL + casingOverhangOut

	if abs(maxDist) > EPS then
		cutpolya 4, 1, 0,
			0, 0, 8,
			-maxDist / tan(leftCornerAngle / 2), -maxDist, 10,
			-10 * A, -maxDist, 8,
			-10 * A, 0, 8

		numCuts = numCuts + 1
	endif

	del 2
endif

! --- Casing Set Back on Sides ---
if bHasCasingSetBackOut then
	add 0, -gs_trim_width_ou * isWindow, -casingSetBackOnSides_out
	rotx 90

	material gs_trim_out_mat
	cutform 4, 1, 1+2,
		0, 0, 1, B*2,
		lengthCasingSetback/2,	0,							1,
		lengthCasingSetback/2,	casingSetBackOnSides_out,	1,
		-lengthCasingSetback/2,	casingSetBackOnSides_out,	1,
		-lengthCasingSetback/2,	0,							1
	numCuts = numCuts + 1
	del 2
endif


! ==============================================================================
!	Draw Outside Trim
! ==============================================================================

if bDrawOutsideTrim then


	material gs_trim_out_mat

	if	bPShapedLeftOpening & not(gs_trim_below_sillLeft) then

		add -sillRight_sL, -gs_sidelight_parapet_hgt_left - sillBottom - sillSideHeight - (gs_reveal_bottom_sR - gs_reveal_bottom), 0
		roty 90
		rotz 90

		cutform 4, 1, 2+16,
			0, 0, 1, EPS,
			0,0,15,
			0.5 * tan(sillSideAngle), -0.5, 15,
			0.5 * tan(sillSideAngle) + 0.5, -0.5, 15,
			0.5 * tan(sillSideAngle) + 0.5, 0, 15
		numCuts = numCuts + 1
		del 3
	endif

	if	bPShapedRightOpening & not(gs_trim_below_sillRight) then

		add sillLeft_sR, -gs_sidelight_parapet_hgt_right - sillBottom - sillSideHeight - (gs_reveal_bottom_sR - gs_reveal_bottom), 0
		roty 90
		rotz 90
		mulz -1

		cutform 4, 1, 2+16,
			0, 0, 1, EPS,
			0,0,15,
			0.5 * tan(sillSideAngle), -0.5, 15,
			0.5 * tan(sillSideAngle) + 0.5, -0.5, 15,
			0.5 * tan(sillSideAngle) + 0.5, 0, 15
		numCuts = numCuts + 1
		del 4
	endif


	if bSillPlaneCut then
		if bDrawSill then
			add 0, -sillBottom-sillSideHeight, 0
			rotx -90 + sillSideAngle
			cutplane
			numCuts = numCuts + 1
			del 2
		endif
	endif

	if bThresholdSillPlaneCut then
		add 0, -ThresholdSillSideHeight, 0
		rotx -90
		cutplane
		numCuts = numCuts + 1
		del 2
	endif

	gosub 2000

endif

! ==============================================================================

for i = 1 to numCuts
	cutend
next i


! Restore the saved parameter buffer ===========================================

call "LoadQueue" parameters savedQueueValues = savedQueueValues

! ==============================================================================
 end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
! ==============================================================================


1000:
! ==============================================================================
!	Draw Inside Trim
! ==============================================================================

	pen gs_frame_pen

	numCutsCornerColumn = 0

	if gs_corner_column then
		matTrim = gs_trim_in_mat

		material gs_trim_in_mat
		sect_fill gs_trim_fill_in, gs_trim_pen_bg_in, gs_trim_pen_fg_in, gs_trim_pen_cont_in

		gosub 100
	endif

	rotx 180

	! ===== Draw Trim Inside =====

	if not(curvedWall) | (curvedWall & gs_trim_atframe_in) then

		! ======================================
		! Inside Trim - Straight Walls
		! ======================================

		addz (-WALL_THICKNESS + WIDO_SILL) * not(gs_trim_atframe_in) - WIDO_FRAME_THICKNESS *gs_trim_atframe_in

		if bTelescopic then
			thk = WALL_THICKNESS
		else
			thk = WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS + gs_trim_jambext_nosing_in + WIDO_FRAME_THICKNESS * gs_sectgar
		endif
		wallIncl = iDir * WALL_INCL

		mask = 10 +\
				1 * bShowEdgesAtFrame +\
				4 * (gs_trim_offs_in > EPS | not(bShowJambExtension) | abs(WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS) < EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS)

		if gs_trim_width_in > EPS & thk > EPS & bShowJambExtension & not(gs_trim_atframe_in) then

			matTrim = gs_trim_in_mat

			material gs_trim_in_mat
			sect_fill gs_trim_fill_in, gs_trim_pen_bg_in, gs_trim_pen_fg_in, gs_trim_pen_cont_in

			! ===== Inside Trim - Straight Walls - Jamb Extensions =====

			maxx = 0
			if abs(wallIncl) > EPS then maxx = abs(thk / tan(wallIncl))		! Maximal distance from origin where the sprism doesn't intersects itself

			addz thk - gs_trim_jambext_nosing_in
			mulz -1

			leftNosingDx   = gs_trim_jambext_nosing_in * tan(gs_reveal_left_angle)   * not(gs_stack_left)
			rightNosingDx  = gs_trim_jambext_nosing_in * tan(gs_reveal_right_angle)  * not(gs_stack_right)
			topNosingDx    = gs_trim_jambext_nosing_in * tan(gs_reveal_top_angle)    * not(gs_stack_top)
			bottomNosingDx = gs_trim_jambext_nosing_in * tan(gs_reveal_bottom_angle) * not(gs_stack_bottom)

			if not(	gs_stack_left | \
					gs_stack_right | \
					gs_stack_top | \
					gs_stack_bottom | \
					bDrawBoard | \
					bLeftCornerFunction | \
					bRightCornerFunction | \
					iWindowShape = SHAPE_ARCHED | \
					iWindowShape = SHAPE_ARCHED_T | \
					iWindowShape = SHAPE_ELLIPSEARCH | \
					not(isWindow)) then
				! --- Not Stacked Window, have no Sill and not a Special Window (eg. Arched) ---

				if not(bInclinedWall) then
					if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then
						cprism_{2} matTrim, matTrim, matTrim,
							10, thk,
							-leftWidth  - overSizeLeftIn  + tolerOffsetLeftIn,		-overSizeBottomIn + tolerOffsetLowerIn, 0, 15, gs_trim_in_mat,
							-leftWidth  - overSizeLeftIn  + tolerOffsetLeftIn,		B + overSizeTopIn - tolerOffsetUpperIn, 0, 15, gs_trim_in_mat,
							 rightWidth + overSizeRightIn - tolerOffsetRightIn,		B + overSizeTopIn - tolerOffsetUpperIn, 0, 15, gs_trim_in_mat,
							 rightWidth + overSizeRightIn - tolerOffsetRightIn,		-overSizeBottomIn + tolerOffsetLowerIn, 0, 15, gs_trim_in_mat,
							-leftWidth  - overSizeLeftIn  + tolerOffsetLeftIn,		-overSizeBottomIn + tolerOffsetLowerIn, 0, -1, gs_trim_in_mat,
							-leftWidth  - overSizeLeftIn  + tolerOffsetLeftIn  + gs_trim_width_in,	-overSizeBottomIn + tolerOffsetLowerIn + gs_trim_width_in, 0, mask, gs_trim_in_mat,
							-leftWidth  - overSizeLeftIn  + tolerOffsetLeftIn  + gs_trim_width_in,	B + overSizeTopIn - tolerOffsetUpperIn - gs_trim_width_in, 0, mask, gs_trim_in_mat,
							 rightWidth + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in,	B + overSizeTopIn - tolerOffsetUpperIn - gs_trim_width_in, 0, mask, gs_trim_in_mat,
							 rightWidth + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in,	-overSizeBottomIn + tolerOffsetLowerIn + gs_trim_width_in, 0, mask, gs_trim_in_mat,
							-leftWidth  - overSizeLeftIn  + tolerOffsetLeftIn  + gs_trim_width_in,	-overSizeBottomIn + tolerOffsetLowerIn + gs_trim_width_in, 0, -1, gs_trim_in_mat
					else
						ruled{2} 4, 1 + 2 + 4 + 16 + 32 * not(gs_trim_show_cover_in) + 64,
							leftRevealPnts[idxBoardEndRevealLeft - 1][1] + tolerOffsetLeftIn,			-overSizeBottomIn + tolerOffsetLowerIn + bDrawBoard * boardBottom, 1,
							leftRevealPnts[idxBoardEndRevealLeft - 1][1] + tolerOffsetLeftIn + trinL,	-overSizeBottomIn + tolerOffsetLowerIn + bDrawBoard * boardBottom + trinB, 1,
							leftRevealPnts[idxBoardEndRevealLeft - 1][1] + tolerOffsetLeftIn + trinL,	B + overSizeTopIn - tolerOffsetUpperIn - trinT, 1,
							leftRevealPnts[idxBoardEndRevealLeft - 1][1] + tolerOffsetLeftIn,			B + overSizeTopIn - tolerOffsetUpperIn, 1,

							leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn - leftNosingDx,			-overSizeBottomIn + tolerOffsetLowerIn - sjby - bottomNosingDx + bDrawBoard * boardBottom, thk,
							leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn - leftNosingDx + trinL,	-overSizeBottomIn + tolerOffsetLowerIn - sjby - bottomNosingDx + bDrawBoard * boardBottom + trinB, thk,
							leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn - leftNosingDx + trinL,	B + overSizeTopIn - tolerOffsetUpperIn + sjty + topNosingDx - trinT, thk,
							leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn - leftNosingDx,			B + overSizeTopIn - tolerOffsetUpperIn + sjty + topNosingDx, thk

						ruled{2} 4, 1 + 2 + 4 + 16 + 32 * not(gs_trim_show_cover_in) + 64,
							rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn,			-overSizeBottomIn + tolerOffsetLowerIn + bDrawBoard * boardBottom, 1,
							rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn - trinR,	-overSizeBottomIn + tolerOffsetLowerIn + bDrawBoard * boardBottom + trinB, 1,
							rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn - trinR,	B + overSizeTopIn - tolerOffsetUpperIn - trinT, 1,
							rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn,			B + overSizeTopIn - tolerOffsetUpperIn, 1,

							rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn + rightNosingDx,		 -overSizeBottomIn + tolerOffsetLowerIn - sjby - bottomNosingDx + bDrawBoard * boardBottom, thk,
							rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn + rightNosingDx - trinR, -overSizeBottomIn + tolerOffsetLowerIn - sjby - bottomNosingDx + bDrawBoard * boardBottom + trinB, thk,
							rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn + rightNosingDx - trinR, B + overSizeTopIn - tolerOffsetUpperIn + sjty + topNosingDx - trinT, thk,
							rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn + rightNosingDx,		 B + overSizeTopIn - tolerOffsetUpperIn + sjty + topNosingDx, thk

						ruled{2} 4, 1 + 2 + 4 + 16 + 32 * not(gs_trim_show_cover_in) + 64,
							 leftRevealPnts[idxBoardEndRevealLeft  - 1][1] + tolerOffsetLeftIn,			 -overSizeBottomIn + tolerOffsetLowerIn + bDrawBoard * boardBottom, 1,
							rightRevealPnts[idxBoardEndRevealRight - 1][1] - tolerOffsetRightIn,		 -overSizeBottomIn + tolerOffsetLowerIn + bDrawBoard * boardBottom, 1,
							rightRevealPnts[idxBoardEndRevealRight - 1][1] - tolerOffsetRightIn - trinR, -overSizeBottomIn + tolerOffsetLowerIn + bDrawBoard * boardBottom + trinB, 1,
							 leftRevealPnts[idxBoardEndRevealLeft  - 1][1] + tolerOffsetLeftIn  + trinL, -overSizeBottomIn + tolerOffsetLowerIn + bDrawBoard * boardBottom + trinB, 1,

							 leftRevealPnts[idxBoardEndRevealLeft ][1] + tolerOffsetLeftIn  - leftNosingDx,			 -overSizeBottomIn + tolerOffsetLowerIn - sjby - bottomNosingDx + bDrawBoard * boardBottom, thk,
							rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + rightNosingDx,		 -overSizeBottomIn + tolerOffsetLowerIn - sjby - bottomNosingDx + bDrawBoard * boardBottom, thk,
							rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + rightNosingDx - trinR, -overSizeBottomIn + tolerOffsetLowerIn - sjby - bottomNosingDx + bDrawBoard * boardBottom + trinB, thk,
							 leftRevealPnts[idxBoardEndRevealLeft ][1] + tolerOffsetLeftIn  - leftNosingDx  + trinL, -overSizeBottomIn + tolerOffsetLowerIn - sjby - bottomNosingDx + bDrawBoard * boardBottom + trinB, thk

						ruled{2} 4, 1 + 2 + 4 + 16 + 32 * not(gs_trim_show_cover_in) + 64,
							 leftRevealPnts[idxBoardEndRevealLeft  - 1][1] + tolerOffsetLeftIn,			 B + overSizeTopIn - tolerOffsetUpperIn, 1,
							rightRevealPnts[idxBoardEndRevealRight - 1][1] - tolerOffsetRightIn,		 B + overSizeTopIn - tolerOffsetUpperIn, 1,
							rightRevealPnts[idxBoardEndRevealRight - 1][1] - tolerOffsetRightIn - trinR, B + overSizeTopIn - tolerOffsetUpperIn - trinT, 1,
							 leftRevealPnts[idxBoardEndRevealLeft  - 1][1] + tolerOffsetLeftIn  + trinL, B + overSizeTopIn - tolerOffsetUpperIn - trinT, 1,

							 leftRevealPnts[idxBoardEndRevealLeft ][1] + tolerOffsetLeftIn  - leftNosingDx,			 B + overSizeTopIn - tolerOffsetUpperIn + sjty + topNosingDx, thk,
							rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + rightNosingDx,		 B + overSizeTopIn - tolerOffsetUpperIn + sjty + topNosingDx, thk,
							rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + rightNosingDx - trinR, B + overSizeTopIn - tolerOffsetUpperIn + sjty + topNosingDx - trinT, thk,
							 leftRevealPnts[idxBoardEndRevealLeft ][1] + tolerOffsetLeftIn  - leftNosingDx  + trinL, B + overSizeTopIn - tolerOffsetUpperIn + sjty + topNosingDx - trinT, thk
					endif
				else
					if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then
						sprism_ matTrim, matTrim, matTrim,
							10, 0,0, 0,1, thk, wallIncl,
							-leftWidth  - overSizeLeftIn + tolerOffsetLeftIn,		-overSizeBottomIn + tolerOffsetLowerIn, 15,
							-leftWidth  - overSizeLeftIn + tolerOffsetLeftIn,		B + overSizeTopIn - tolerOffsetUpperIn, 15,
							 rightWidth + overSizeRightIn - tolerOffsetRightIn,	B + overSizeTopIn - tolerOffsetUpperIn, 15,
							 rightWidth + overSizeRightIn - tolerOffsetRightIn,	-overSizeBottomIn + tolerOffsetLowerIn, 15,
							-leftWidth  - overSizeLeftIn + tolerOffsetLeftIn,		-overSizeBottomIn + tolerOffsetLowerIn, -1,
							-leftWidth  - overSizeLeftIn + tolerOffsetLeftIn  + gs_trim_width_in,	-overSizeBottomIn + tolerOffsetLowerIn + gs_trim_width_in, mask,
							-leftWidth  - overSizeLeftIn + tolerOffsetLeftIn  + gs_trim_width_in,	B + overSizeTopIn - gs_trim_width_in - tolerOffsetUpperIn, mask,
							 rightWidth + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in,	B + overSizeTopIn - gs_trim_width_in - tolerOffsetUpperIn, mask,
							 rightWidth + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in,	-overSizeBottomIn + tolerOffsetLowerIn + gs_trim_width_in, mask,
							-leftWidth  - overSizeLeftIn + tolerOffsetLeftIn  + gs_trim_width_in,	-overSizeBottomIn + tolerOffsetLowerIn + gs_trim_width_in, -1
					endif
				endif
			else
				! --- Stacked Window or Window with Board or Corner Window ---


				! --- Draw left side Jamb Extension ---

				px1 = leftRevealPnts[idxBoardEndRevealright-1][1] + tolerOffsetLeftIn
				px2 = px1 + gs_trim_width_in * not(gs_stack_left)

				if	bShapeEnablesStraightTopTrim then
					py1 = B + overSizeTopIn - tolerOffsetUpperIn
					py2 = py1 - not(gs_stack_top) * gs_trim_width_in

					s1 = 8 + 2 * not(gs_stack_top)		! 15 or 8
					s2 = bitset (mask, 1, not(gs_stack_top))
				endif

				if	bShapeEnablesArchedTopTrim then
					ta = leftWidth + overSizeTopIn - tolerOffsetLeftIn
					tc = arcR + overSizeTopIn
					py1 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))

					ta = ta - gs_trim_width_in
					tc = tc - gs_trim_width_in
					py2 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))

					archTrimDiff = py1 - py2

					s1 = 8
					s2 = mask - 2
				endif

				if iWindowShape = SHAPE_ELLIPSEARCH then
					py1 = B - archHeight		! + overSizeTopIn
					py2 = py1

					s1 = 8
					s2 = mask - 2
				endif

				if	isWindow | \
					(bPShapedLeftOpening & gs_trim_below_boardLeft) then
					py3 = -overSizeBottomIn + not(gs_stack_bottom | bDrawLeftSLBoard) * (gs_trim_width_in + tolerOffsetLowerIn)
					py4 = -overSizeBottomIn + not(gs_stack_bottom | bDrawLeftSLBoard) * tolerOffsetLowerIn

					s3 = 8 + 7 * not(gs_stack_bottom) * bDrawBoard * isWindow + 2 * not(isWindow) 		! 15 or 8
					s4 = 13 + 2 * not(gs_stack_bottom)		! 15 or 13
				else
					py3 = -overSizeBottomIn
					py4 = -overSizeBottomIn

					s3 = 15
					s4 = 15
				endif

				py1r = (-overSizeBottomIn + (tolerOffsetLowerIn * not(bDrawLeftSLBoard)) ) * ((isWindow & not(gs_stack_bottom))) - overSizeBottomIn * not(isWindow) * not(bPShapedLeftOpening)
				py2r = py1r + trinB * ( (isWindow & not(gs_stack_bottom) & not(bDrawBoard)) | (bPShapedLeftOpening & gs_trim_below_boardLeft) )
				py3r = B + (overSizeTopIn - tolerOffsetUpperIn - trinT * (iWindowShape = SHAPE_RECTANGULAR) - (archHeight) - archTrimDiff * not(bHalfCircle)) * not(gs_stack_top)				! tok - belso - felso
				py4r = B + (overSizeTopIn - tolerOffsetUpperIn - (archHeight)) * not(gs_stack_top)					! tok - fal - felso
				py5r = (-overSizeBottomIn + (tolerOffsetLowerIn * not(bDrawLeftSLBoard)) - sjby) * (isWindow & not(gs_stack_bottom)) - overSizeBottomIn * not(isWindow) * not(bPShapedLeftOpening)
				py6r = py5r + trinB * ( (isWindow & not(gs_stack_bottom) & not(bDrawBoard)) | (bPShapedLeftOpening & gs_trim_below_boardLeft) )
				py7r = B + (overSizeTopIn - tolerOffsetUpperIn - trinT * (iWindowShape = SHAPE_RECTANGULAR) + sjty - (archHeight) - archTrimDiff * not(bHalfCircle)) * not(gs_stack_top)	! falsik - belso - felso
				py8r = B + (overSizeTopIn - tolerOffsetUpperIn + sjty - (archHeight)) * not(gs_stack_top)				! falsik - fal - felso

				if	bShapeEnablesArchedTopTrim | \
					iWindowShape = SHAPE_ELLIPSEARCH then
					py3r = py2
					py4r = py1
				endif

				if	bPShapedLeftOpening then
					py1r = py1r + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL
					py2r = py2r + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL
					py5r = py2r + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL
					py6r = py2r + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL
					py3 = py3 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
					py4 = py4 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
				endif

				if not(gs_stack_left | bLeftCornerFunction) & bShapeEnablesStraightLeftTrim then

					if maxx < EPS | ((sgn(px1) = sgn(wallIncl) | abs(px1) < maxx) & (sgn(px2) = sgn(wallIncl) | abs(px2) < maxx)) then
						addz (not(isWindow) & not(WIDO_REVEAL_SIDE)) * pocketThkLeft

						if bInclinedWall then
							if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then
								sprism_ matTrim, matTrim, matTrim,
									4, 0,0, 0,1, thk - pocketThkLeft, wallIncl,
									px1,	py1, 	s1,
									px2,	py2, 	s2,
									px2,	py3,	s3,
									px1,	py4, 	s4
							endif
						else
							if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then
								cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
									4, thk,
									leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn,			py4,	0, 8 + 7 * not(bPShapedLeftOpening) * not(isWindow), gs_trim_in_mat,
									leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn + trinL,	py3,	0, 8 + 1 * bShowEdgesAtFrame + 2 * not(gs_stack_bottom) + 4 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS), gs_trim_in_mat,
									leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn + trinL,	py3r,	0, s1, gs_trim_in_mat,
									leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn,			py4r,	0, 15, gs_trim_in_mat
							else
								ruled{2} 4, 1 + 2 + 4 + 16 + 32 * not(gs_trim_show_cover_in) + 64,
									leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn,			py1r, 1,
									leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn + trinL,	py2r, 1,
									leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn + trinL,	py3r, 1,
									leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn,			py4r, 1,

									leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn - leftNosingDx,			py5r - bottomNosingDx, thk,
									leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn - leftNosingDx + trinL,	py6r - bottomNosingDx, thk,
									leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn - leftNosingDx + trinL,	py7r + topNosingDx, thk,
									leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn - leftNosingDx,			py8r + topNosingDx, thk

								if abs(gs_trim_offs_in) > EPS | abs(gs_trim_thk_in) < EPS then
									lin_ leftRevealPnts[idxBoardEndRevealleft][1] + tolerOffsetLeftIn - leftNosingDx + trinL, py6r - bottomNosingDx, thk,
										 leftRevealPnts[idxBoardEndRevealleft][1] + tolerOffsetLeftIn - leftNosingDx + trinL, py7r + topNosingDx, thk
								endif
							endif
						endif

						gosub "TextCoord_Vert"

						del 1
					endif
				endif
				if	bPShapedLeftOpening & gs_trim_below_boardLeft then
					! --- Draw Door's Left side Jamb Extension ---
					px1LSL = leftRevealPnts[idxBoardEndRevealright-1][1] + gs_sidelight_WHole_width_left
					px2LSL = px1LSL + gs_trim_width_in
					px1LSLW = leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn
					px2LSLW = leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn + trinL * not(gs_stack_left)

					py1 = -overSizeBottomIn
					py2 = -overSizeBottomIn

					sprism_ matTrim, matTrim, matTrim,
						4, 0,0, 0,1, thk - pocketThkRight, wallIncl,
						 px1LSL,	py1,	15,
						 px2LSL,	py2,	mask,
						 px2LSL,	py3,	s3,
						 px1LSL,	py4,	s4
					gosub "TextCoord_Vert"

					if	not(bDrawLeftSLBoard) then
						! --- Draw Left Sidelight lower side Jamb Extension ---
						sprism_ matTrim, matTrim, matTrim,
							4, 0,0, 0,1, thk - pocketThkRight, wallIncl,
							 px2LSL,	py3,	15,
							 px1LSL,	py4,	15,
							 px1LSLW,	py4,	15,
							 px2LSLW,	py3,	mask - 2 * gs_stack_left
						gosub "TextCoord_Hor"
					endif
				endif


				! --- Draw right side Jamb Extension ---

				px1 = rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn
				px2 = px1 - gs_trim_width_in * not(gs_stack_right)

				if	bShapeEnablesStraightTopTrim then
					py1 = B + overSizeTopIn - tolerOffsetUpperIn
					py2 = py1 - not(gs_stack_top) * gs_trim_width_in

					s1 = 8 + 2 * not(gs_stack_top)			! 15 or 8
					s2 = bitset (mask, 1, not(gs_stack_top))
				endif

				if	bShapeEnablesArchedTopTrim then
					ta = rightWidth + overSizeTopIn - tolerOffsetRightIn
					tc = arcR + overSizeTopIn
					py1 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))

					ta = ta - gs_trim_width_in
					tc = tc - gs_trim_width_in
					py2 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))

					archTrimDiff = py1 - py2

					s1 = 8
					s2 = mask - 2
				endif

				if iWindowShape = SHAPE_ELLIPSEARCH then
					py1 = B - archHeight	! + overSizeTopIn
					py2 = py1

					s1 = 8
					s2 = mask - 2
				endif

				if	isWindow | \
					(bPShapedRightOpening & gs_trim_below_boardRight) then
					py3 = -overSizeBottomIn + not(gs_stack_bottom | bDrawRightSLBoard) * (gs_trim_width_in + tolerOffsetLowerIn)
					py4 = -overSizeBottomIn + not(gs_stack_bottom | bDrawRightSLBoard) * tolerOffsetLowerIn

					s3 = 8 + 7 * not(gs_stack_bottom) * bDrawBoard * isWindow + 2 * not(isWindow)		! 15 or 8
					s4 = 13 + 2 * not(gs_stack_bottom)		! 15 or 13
				else
					py3 = -overSizeBottomIn
					py4 = -overSizeBottomIn

					s3 = 15
					s4 = 15
				endif

				py1r = (-overSizeBottomIn + (tolerOffsetLowerIn * not(bDrawRightSLBoard)) ) * ((isWindow & not(gs_stack_bottom))) - overSizeBottomIn * not(isWindow) * not(bPShapedRightOpening)
				py2r = py1r + trinB * ( (isWindow & not(gs_stack_bottom) & not(bDrawBoard)) | (bPShapedRightOpening & gs_trim_below_boardRight ) )
				py3r = B + (overSizeTopIn - tolerOffsetUpperIn - trinT * (iWindowShape = SHAPE_RECTANGULAR) - (archHeight) - archTrimDiff * not(bHalfCircle)) * not(gs_stack_top)
				py4r = B + (overSizeTopIn - tolerOffsetUpperIn - (archHeight)) * not(gs_stack_top)
				py5r = (-overSizeBottomIn + (tolerOffsetLowerIn * not(bDrawRightSLBoard)) - sjby) * (isWindow & not(gs_stack_bottom)) - overSizeBottomIn * not(isWindow) * not(bPShapedRightOpening)
				py6r = py5r + trinB * ( (isWindow & not(gs_stack_bottom) & not(bDrawBoard)) | (bPShapedRightOpening & gs_trim_below_boardRight) )
				py7r = B + (overSizeTopIn - tolerOffsetUpperIn - trinT * (iWindowShape = SHAPE_RECTANGULAR) + sjty - (archHeight) - archTrimDiff * not(bHalfCircle)) * not(gs_stack_top)
				py8r = B + (overSizeTopIn - tolerOffsetUpperIn + sjty - (archHeight)) * not(gs_stack_top)

				if	bShapeEnablesArchedTopTrim | \
					iWindowShape = SHAPE_ELLIPSEARCH then
					py3r = py2
					py4r = py1
				endif

				if	bPShapedRightOpening then
					py1r = py1r + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR
					py2r = py2r + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR
					py5r = py2r + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR
					py6r = py2r + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR
					py3 = py3 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
					py4 = py4 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
				endif

				if not(gs_stack_right | bRightCornerFunction) & bShapeEnablesStraightRightTrim then

					if maxx < EPS | ((sgn(px1) = sgn(wallIncl) | abs(px1) < maxx) & (sgn(px2) = sgn(wallIncl) | abs(px2) < maxx)) then
						addz (not(isWindow) & not(WIDO_REVEAL_SIDE)) * pocketThkRight

						if bInclinedWall then
							if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then
								sprism_ matTrim, matTrim, matTrim,
									4, 0,0, 0,1, thk - pocketThkRight, wallIncl,
									 px1,	py1,	s1,
									 px2,	py2,	s2,
									 px2,	py3,	s3,
									 px1,	py4,	s4
							endif
						else
							if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then
								cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
									4,thk,
									rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn,			py4,	0, 8 + 7 * not(bPShapedLeftOpening) * not(isWindow), gs_trim_in_mat,
									rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn - trinR,	py3,	0, 8 + 1 * bShowEdgesAtFrame + 2 * not(gs_stack_bottom) + 4 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS), gs_trim_in_mat,
									rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn - trinR,	py3r,	0, s1, gs_trim_in_mat,
									rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn,			py4r,	0, 15, gs_trim_in_mat
							else
								ruled{2} 4, 1 + 2 + 4 + 16 + 32 * not(gs_trim_show_cover_in) + 64,
									rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn,			py1r, 1,
									rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn - trinR,	py2r, 1,
									rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn - trinR,	py3r, 1,
									rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn,			py4r, 1,

									rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn + rightNosingDx,			py5r - bottomNosingDx, thk,
									rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn + rightNosingDx - trinR,	py6r - bottomNosingDx, thk,
									rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn + rightNosingDx - trinR,	py7r + topNosingDx, thk,
									rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn + rightNosingDx,			py8r + topNosingDx, thk

								if abs(gs_trim_offs_in) > EPS | abs(gs_trim_thk_in) < EPS then
									lin_ rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn + rightNosingDx - trinR, py6r - bottomNosingDx, thk,
										 rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn + rightNosingDx - trinR, py7r + topNosingDx, thk
								endif
							endif
						endif
						gosub "TextCoord_Vert"

						del 1
					endif
				endif

				if	bPShapedRightOpening & gs_trim_below_boardRight then
					! --- Draw Door's Right side Jamb Extension ---
					px1RSL = rightRevealPnts[idxBoardEndRevealright - 1][1] - gs_sidelight_WHole_width_right - gs_trim_width_in
					px2RSL = px1RSL + gs_trim_width_in
					px1RSLW = rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn
					px2RSLW = rightRevealPnts[idxBoardEndRevealright - 1][1] - tolerOffsetRightIn - trinR * not(gs_stack_right)

					py1 = -overSizeBottomIn
					py2 = -overSizeBottomIn

					sprism_ matTrim, matTrim, matTrim,
						4, 0,0, 0,1, thk - pocketThkRight, wallIncl,
						 px2RSL,	py1,	15,
						 px1RSL,	py2,	mask,
						 px1RSL,	py3,	s3,
						 px2RSL,	py4,	s4
					gosub "TextCoord_Vert"

					if	not(bDrawRightSLBoard) then
						! --- Draw Right Sidelight lower side Jamb Extension ---
						sprism_ matTrim, matTrim, matTrim,
							4, 0,0, 0,1, thk - pocketThkRight, wallIncl,
							px1RSL,	py3,	15,
							px2RSL,	py4,	15,
							px1RSLW,py4,	15,
							px2RSLW,py3,	mask - 2 * gs_stack_right
						gosub "TextCoord_Hor"
					endif
				endif

				if bShapeEnablesStraightTopTrim & not(gs_stack_top) then
					! --- Draw upper side Jamb Extension ---

					px1 = -leftWidth - overSizeLeftIn + tolerOffsetLeftIn
					px2 = px1 + not(gs_stack_left) * gs_trim_width_in
					px4 = rightWidth + overSizeRightIn - tolerOffsetRightIn
					px3 = px4 - not(gs_stack_right) * gs_trim_width_in

					if maxx > EPS then
						if sgn(wallIncl) < 0 then
							px1 = min(maxx - EPS, px1)
							px2 = min(maxx - EPS, px2)
							px3 = min(maxx - EPS, px3)
							px4 = min(maxx - EPS, px4)
						else
							px1 = max(-maxx + EPS, px1)
							px2 = max(-maxx + EPS, px2)
							px3 = max(-maxx + EPS, px3)
							px4 = max(-maxx + EPS, px4)
						endif
					endif

					py1 = B + overSizeTopIn - tolerOffsetUpperIn
					py2 = B + overSizeTopIn - tolerOffsetUpperIn - gs_trim_width_in
					py3 = B + overSizeTopIn - tolerOffsetUpperIn - gs_trim_width_in
					py4 = B + overSizeTopIn - tolerOffsetUpperIn

					py1r = B + overSizeTopIn - tolerOffsetUpperIn
					py2r = B + overSizeTopIn - tolerOffsetUpperIn
					py3r = B + overSizeTopIn - tolerOffsetUpperIn - trinT
					py4r = B + overSizeTopIn - tolerOffsetUpperIn - trinT
					py5r = B + overSizeTopIn - tolerOffsetUpperIn + sjty
					py6r = B + overSizeTopIn - tolerOffsetUpperIn + sjty
					py7r = B + overSizeTopIn - tolerOffsetUpperIn + sjty - trinT
					py8r = B + overSizeTopIn - tolerOffsetUpperIn + sjty - trinT

					s1 = mask	!8 + 7 * not(gs_stack_left)
					s2 = 8 + 2 * not(gs_stack_right)
					s3 = 10 + 1 * bShowEdgesAtFrame + 4 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS) - 2 * gs_stack_right
					s4 = 8 + 2 * not(gs_stack_left)

					if bInclinedWall then
						if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then
							sprism_ matTrim, matTrim, matTrim,
								4, 0,0, 0,1, thk, wallIncl,
								px1,	py1,	8 + 2 * not(gs_stack_left),			! 15 or 8
								px2,	py2,	bitset(bitset (mask, 1, not(gs_stack_left)), 0, not(bRightCornerFunction) | not(bFitModeRight)),
								px3,	py3,	8 + 2 * not(gs_stack_right),		! 15 or 8
								px4,	py4,	13 + 2 * not(gs_stack_right)		! 15 or 13
						endif
					else
						if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then
							if bLeftCornerFunction then
								pxL = min(leftRevealPnts[idxBoardEndRevealLeft][1], leftRevealPnts[idxBoardEndRevealLeft - 1][1]) - 1.0
							else
								pxL = leftRevealPnts[idxBoardEndRevealLeft - 1][1]
							endif
							if bRightCornerFunction then
								pxR = max(rightRevealPnts[idxBoardEndRevealRight][1], rightRevealPnts[idxBoardEndRevealRight - 1][1]) + 1.0
							else
								pxR = rightRevealPnts[idxBoardEndRevealRight - 1][1]
							endif
							cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								4, thk,
								pxL + tolerOffsetLeftIn,														py1r, 0, s1, gs_trim_in_mat,
								pxR - tolerOffsetRightIn,														py2r, 0, s2, gs_trim_in_mat,
								pxR - tolerOffsetRightIn - not(gs_stack_right | bRightCornerFunction) * trinR,	py3r, 0, s3, gs_trim_in_mat,
								pxL + tolerOffsetLeftIn  + not(gs_stack_left  | bLeftCornerFunction)  * trinL,	py4r, 0, s4, gs_trim_in_mat
						else
							ruled{2} 4, 1 + 2 + 4 + 16 + 32 * not(gs_trim_show_cover_in),
								 leftRevealPnts[idxBoardEndRevealLeft  - 1][1] + tolerOffsetLeftIn,  py1r, 1,
								rightRevealPnts[idxBoardEndRevealRight - 1][1] - tolerOffsetRightIn, py2r, 1,
								rightRevealPnts[idxBoardEndRevealRight - 1][1] - tolerOffsetRightIn - not(gs_stack_right | bRightCornerFunction) * trinR, py3r, 1,
								 leftRevealPnts[idxBoardEndRevealLeft  - 1][1] + tolerOffsetLeftIn  + not(gs_stack_left  | bLeftCornerFunction)  * trinL, py4r, 1,

								 leftRevealPnts[idxBoardEndRevealLeft] [1] + tolerOffsetLeftIn  - leftNosingDx,  py5r + topNosingDx, thk,
								rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + rightNosingDx, py6r + topNosingDx, thk,
								rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + rightNosingDx - not(gs_stack_right | bRightCornerFunction) * trinR, py7r + topNosingDx, thk,
								 leftRevealPnts[idxBoardEndRevealLeft ][1] + tolerOffsetLeftIn  - leftNosingDx  + not(gs_stack_left  | bLeftCornerFunction)  * trinL, py8r + topNosingDx, thk

							if abs(gs_trim_offs_in) > EPS | abs(gs_trim_thk_in) < EPS then
								lin_ leftRevealPnts[idxBoardEndRevealLeft ][1] + tolerOffsetLeftIn  - leftNosingDx  + not(gs_stack_left  | bLeftCornerFunction)  * trinL, py8r + topNosingDx, thk,
									rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + rightNosingDx - not(gs_stack_right | bRightCornerFunction) * trinR, py7r + topNosingDx, thk
							endif
						endif
					endif
				endif
				if	bShapeEnablesArchedTopTrim then

					resol nArchResolution
					addy B - archHeight - tolerOffsetUpperIn

					px1L = -leftWidth - overSizeLeftIn + tolerOffsetLeftIn
					px2L = px1L + gs_trim_width_in

					px1R = rightWidth + overSizeRightIn - tolerOffsetRightIn
					px2R = px1R - gs_trim_width_in

					if maxx < EPS | abs(px1L) < maxx | abs(px1R) < maxx then

						if bHalfCircle then

							sprism_ matTrim, matTrim, matTrim,
								9, 0,0, 0,1, thk, wallIncl,
								px1L,	0, 	   8 + 7 * gs_stack_left,		! 15 or 8
								px2L,	0,	  62 + mask,
								 0,		0,	 900,
								 0,	archHeight - gs_trim_width_in,	3062 + mask,		! 1015 or 1008
								 px2R,	0,	3008 + 7 * gs_stack_right,		! 1015 or 1008
								 px1R,	-EPS,  8 + 7 * gs_stack_right,		! 15 or 8
								 px1R,	0,	  79,
								 0,		archHeight, 	3079,
								px1L,	0, 	3015

							! --- Draw missing lines ---
							if gs_stack_left then lin_ px2L,0,0, px2L,0,thk + px2L * tan(wallIncl)
						else
							ta = leftWidth + overSizeTopIn - tolerOffsetLeftIn
							tc = arcR + overSizeTopIn
							py1L = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight - tolerOffsetUpper

							ta = ta - gs_trim_width_in
							tc = tc - gs_trim_width_in
							py2L = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight - tolerOffsetUpper

							ta = rightWidth + overSizeTopIn - tolerOffsetRightIn
							tc = arcR + overSizeTopIn
							py1R = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight - tolerOffsetUpper

							ta = ta - gs_trim_width_in
							tc = tc - gs_trim_width_in
							py2R = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight - tolerOffsetUpper

							sprism_ matTrim, matTrim, matTrim,
								8, 0,0, 0,1, thk, wallIncl,
								 0,		archHeight - arcR, 900,
								px1L,	py1L, 	  8 + 7 * gs_stack_left,		! 15 or 8
								px2L,	py2L,	  62 + mask,
								 0,		archHeight - gs_trim_width_in,	3062 + mask,		! 1015 or 1008
								 px2R,	py2R,	3010 + 5 * gs_stack_right,		! 1015 or 1008
								 px1R,	py1R,	  79,
								 0,		archHeight, 	3079,
								px1L,	py1L, 	3015

							lin_ px2L,py2L,0, px2L,py2L,thk + px2L * tan(wallIncl)
						endif

					endif

					del 1
				endif
				if iWindowShape = SHAPE_ELLIPSEARCH then

					resol nArchResolution

					px1 = -leftWidth - overSizeLeftIn + tolerOffsetLeftIn
					px2 = px1 + not(gs_stack_left) * gs_trim_width_in
					px4 = rightWidth + overSizeRightIn - tolerOffsetRightIn
					px3 = px4 - not(gs_stack_right) * gs_trim_width_in

					pxcL = -leftWidth + smallRadiusEllips
					pxcR = rightWidth - smallRadiusEllips

					py1 = B - tolerOffsetUpperIn

					s3 = 9 + 4 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS) - 2 * gs_stack_right

					sprism_ matTrim, matTrim, matTrim,
						13, 0,0, 0,1, thk, wallIncl,
						px4,	py1 - archHeight,			13,
						pxcR,	py1 - archHeight,			913,
						0,		alphaSide,					4013,
						0,		py1 - middleRadiusEllips, 	913,
						0,		alphaMiddle,				4013,
						pxcL,	py1 - archHeight,			913,
						0,		alphaSide,					4008,
						px2,	py1 - archHeight,			s3,
						0,		-alphaSide,					4000+s3,
						0,		py1 - middleRadiusEllips, 	900+s3,
						0,		-alphaMiddle,				4000+s3,
						pxcR,	py1 - archHeight,			900+s3,
						0,		-alphaSide,					4000+s3
				endif
				gosub "TextCoord_Hor"

				if not(gs_stack_bottom) & isWindow & bShapeEnablesStraightBottomTrim & not (bDrawBoard) then
					! --- Draw lower side Jamb Extension ---

					px1 = -leftWidth - overSizeLeftIn + tolerOffsetLeftIn
					px2 = px1 + not(gs_stack_left) * gs_trim_width_in
					px4 = rightWidth + overSizeRightIn - tolerOffsetRightIn
					px3 = px4 - not(gs_stack_right) * gs_trim_width_in

					if  maxx > EPS then
						if sgn(wallIncl) < 0 then
							px1 = min(maxx - EPS, px1)
							px2 = min(maxx - EPS, px2)
							px3 = min(maxx - EPS, px3)
							px4 = min(maxx - EPS, px4)
						else
							px1 = max(-maxx + EPS, px1)
							px2 = max(-maxx + EPS, px2)
							px3 = max(-maxx + EPS, px3)
							px4 = max(-maxx + EPS, px4)
						endif
					endif

					if bInclinedWall then
						if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then
							sprism_ matTrim, matTrim, matTrim,
								4, 0,0, 0,1, thk, wallIncl,
								px1,	-overSizeBottomIn + tolerOffsetLowerIn, 						8 + 2 * not(gs_stack_left),		! 15 or 8
								px2,	-overSizeBottomIn + tolerOffsetLowerIn + gs_trim_width_in,		bitset(bitset (mask, 1, not(gs_stack_left)), 0, not(bRightCornerFunction) | not(bFitModeRight)),
								px3,	-overSizeBottomIn + tolerOffsetLowerIn + gs_trim_width_in,		8 + 2 * not(gs_stack_right),		! 15 or 8
								px4,	-overSizeBottomIn + tolerOffsetLowerIn, 						13 + 2 * not(gs_stack_right)		! 15 or 13
						endif
					else
						if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then
							if bLeftCornerFunction then
								pxL = min(leftRevealPnts[idxBoardEndRevealLeft][1], leftRevealPnts[idxBoardEndRevealLeft - 1][1]) - 1.0
							else
								pxL = leftRevealPnts[idxBoardEndRevealLeft - 1][1]
							endif
							if bRightCornerFunction then
								pxR = max(rightRevealPnts[idxBoardEndRevealRight][1], rightRevealPnts[idxBoardEndRevealRight - 1][1]) + 1.0
							else
								pxR = rightRevealPnts[idxBoardEndRevealRight - 1][1]
							endif

							cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								4,thk,
								pxL + tolerOffsetLeftIn,														-overSizeBottomIn + tolerOffsetLowerIn,		0, 15, gs_trim_in_mat,
								pxR - tolerOffsetRightIn,														-overSizeBottomIn + tolerOffsetLowerIn,		0, 8 + 2 * not(gs_stack_right), gs_trim_in_mat,
								pxR - tolerOffsetRightIn - not(gs_stack_right | bRightCornerFunction) * trinR,	-overSizeBottomIn + tolerOffsetLowerIn + trinB,	0, mask, gs_trim_in_mat,
								pxL + tolerOffsetLeftIn  + not(gs_stack_left  | bLeftCornerFunction)  * trinL,	-overSizeBottomIn + tolerOffsetLowerIn + trinB,	0, 8 + 2 * not(gs_stack_left),  gs_trim_in_mat
						else
							ruled{2} 4, 1 + 2 + 4 + 16 + 32 * not(gs_trim_show_cover_in),
								 leftRevealPnts[idxBoardEndRevealLeft  - 1][1] + tolerOffsetLeftIn, -overSizeBottomIn + tolerOffsetLowerIn, 1,
								rightRevealPnts[idxBoardEndRevealRight - 1][1] - tolerOffsetRightIn, -overSizeBottomIn + tolerOffsetLowerIn, 1,
								rightRevealPnts[idxBoardEndRevealRight - 1][1] - tolerOffsetRightIn - not(gs_stack_right | bRightCornerFunction) * trinR, -overSizeBottomIn + tolerOffsetLowerIn + trinB, 1,
								 leftRevealPnts[idxBoardEndRevealLeft  - 1][1] + tolerOffsetLeftIn  + not(gs_stack_left  | bLeftCornerFunction)  * trinL, -overSizeBottomIn + tolerOffsetLowerIn + trinB, 1,

								 leftRevealPnts[idxBoardEndRevealLeft ][1] + tolerOffsetLeftIn  - leftNosingDx,											 -overSizeBottomIn + tolerOffsetLowerIn - bottomNosingDx - sjby, thk,
								rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + rightNosingDx,										 -overSizeBottomIn + tolerOffsetLowerIn - bottomNosingDx - sjby, thk,
								rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + rightNosingDx - not(gs_stack_right | bRightCornerFunction) * trinR, -overSizeBottomIn + tolerOffsetLowerIn - bottomNosingDx - sjby + trinB, thk,
								 leftRevealPnts[idxBoardEndRevealLeft ][1] + tolerOffsetLeftIn  - leftNosingDx  + not(gs_stack_left  | bLeftCornerFunction)  * trinL, -overSizeBottomIn + tolerOffsetLowerIn - bottomNosingDx - sjby + trinB, thk

							if abs(gs_trim_offs_in) > EPS | abs(gs_trim_thk_in) < EPS then
								lin_ rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + rightNosingDx - not(gs_stack_right | bRightCornerFunction) * trinR, -overSizeBottomIn + tolerOffsetLowerIn - bottomNosingDx + trinB - sjby, thk,
									  leftRevealPnts[idxBoardEndRevealLeft ][1] + tolerOffsetLeftIn  - leftNosingDx  + not(gs_stack_left  | bLeftCornerFunction)  * trinL, -overSizeBottomIn + tolerOffsetLowerIn - bottomNosingDx + trinB - sjby, thk
							endif
						endif
					endif
				endif
				gosub "TextCoord_Hor"
			endif

			del 2
		endif

		mask = 11 + 4 * (gs_trim_offs_in > EPS | not(bShowJambExtension) | abs(WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS) < EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS)

		if gs_trim_thk_in > EPS & gs_trim_show_cover_in & gs_sectgar = 0 then

			material gs_trim_in_mat
			sect_fill gs_trim_fill_in, gs_trim_pen_bg_in, gs_trim_pen_fg_in, gs_trim_pen_cont_in

			! ===== Inside Trim - Straight Walls - Casing =====

			maskTop		= 8 + 2 * not(gs_stack_top)
			maskBottom	= 8 + 2 * not(gs_stack_bottom)
			maskLeft	= 8 + 2 * not(gs_stack_left)
			maskRight	= 8 + 2 * not(gs_stack_right)

			maskLeft2	= bDrawBoard*(not(bTrimovbotleftin)*(15-7*gs_stack_left)+bTrimovbotleftin*(10-2*gs_stack_left))
			maskRight2	= bDrawBoard*(not(bTrimovbotrightin)*(15-7*gs_stack_right)+bTrimovbotrightin*(10-2*gs_stack_right))

			TrimLeftTopMiterAngle	= atn(gs_tw_top_in / gs_tw_left_in)
			TrimRightTopMiterAngle	= atn(gs_tw_top_in / gs_tw_right_in)
			TrimLeftBotMiterAngle	= atn(gs_tw_bottom_in / gs_tw_left_in)
			TrimRightBotMiterAngle	= atn(gs_tw_bottom_in / gs_tw_right_in)

			! --- Stacked Window or Window with Board or Corner Window ---

			if bInclinedWall & not(gs_trim_atframe_in) then
				if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then
					roty wallIncl
					addz -gs_trim_thk_in


					! --- Draw left side Trim Inclined Wall ---

					px2 = -(leftWidth - tolerOffsetLeftIn + overSizeLeftIn - gs_trim_width_in + gs_trim_offs_in) / cos(wallIncl) + gs_trim_thk_in * tan(wallIncl)
					px1 = px2 - gs_tw_left_in

					if	bShapeEnablesStraightTopTrim then
						py1 = B + overSizeTopIn + not(gs_stack_top) * (-gs_trim_width_in - tolerOffsetUpperIn + gs_trim_offs_in + gs_tw_top_in*not(bTrimovtopleftin))
						py2 = B + overSizeTopIn + not(gs_stack_top) * (- gs_trim_width_in - tolerOffsetUpperIn + gs_trim_offs_in)

						s1 = 15 - 7 * (gs_stack_top | bTrimovtopleftin)
						s2 = bitset (mask, 1, not(gs_stack_top))
					endif

					if	bShapeEnablesArchedTopTrim then
						ta = leftWidth + overSizeTopIn - tolerOffsetLeftIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
						tc = arcR + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
						py1 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))

						ta = ta - gs_tw_right_in
						tc = tc - gs_tw_right_in
						py2 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))

						s1 = 8
						s2 = mask - 2
					endif

					if iWindowShape = SHAPE_ELLIPSEARCH then
						py1 = B + overSizeTopIn - archHeight
						py2 = py1

						s1 = 8
						s2 = mask - 2
					endif

					if	isWindow | \
						(bPShapedLeftOpening & gs_trim_below_boardLeft) then
						py3 = -overSizeBottomIn + not(bDrawLeftSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawLeftSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawLeftSLBoard)\
							- gs_trimov_bot_left_in - gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) - gs_apron_width * bTrimovbotleftin * gs_apron) - sjby
						py4 = -overSizeBottomIn + not(bDrawLeftSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawLeftSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawLeftSLBoard)\
							- gs_trimov_bot_left_in - gs_tw_bottom_in * (not(bDrawLeftSLBoard) | (bDrawLeftSLBoard & (bTrimovbotleftin | gs_trim_below_boardLeft))) * not(gs_apron) - gs_apron_width * bTrimovbotleftin * gs_apron) - sjby

						py5=py3 + not(gs_stack_bottom) * (gs_trimov_bot_left_in + gs_tw_bottom_in*bTrimovbotleftin * not(gs_apron) + gs_apron_width * bTrimovbotleftin * gs_apron)
						py6=py3 + not(gs_stack_bottom) * gs_trimov_bot_left_in

						s3 = 15	* isWindow + 15 * bPShapedLeftOpening					! 15 or 10 or 8
						s4 = 13 + 2 * not(gs_stack_bottom)	! 15 or 13
					else
						py3 = -overSizeBottomIn
						py4 = -overSizeBottomIn

						s3 = 15
						s4 = 15
					endif

					if	bPShapedLeftOpening then
						py3 = py3 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
						py4 = py4 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
						py5 = py5 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
						py6 = py6 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
					endif

					if not(gs_stack_left | bLeftCornerFunction) & bShapeEnablesStraightLeftTrim then
						! mitered joint of inclined casing
						addz gs_trim_thk_in
						roty -wallIncl + 90
						numMiterCuts = 0
						if bShapeEnablesStraightTopTrim & not(gs_stack_top) then
							if	not(gs_stack_top) & not(bTrimovtoprightin) then
								add 0, B + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in, -leftWidth - overSizeLeftIn + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in
								py2 = py1
								cutplane{2} 270 + TrimLeftTopMiterAngle, 4
								numMiterCuts = numMiterCuts + 1
								del 1
							endif
						endif
						if	bShapeEnablesArchedTopTrim then
							ta = leftWidth + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in
							tc = arcR + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in
							py1L = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

							ta = ta + gs_tw_right_in
							tc = tc + gs_tw_right_in
							py2L = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

							! mitered joint of inclined casing
							TrimLeftTopMiterAngle	= atn( (py2L - py1L) / (gs_tw_right_in * cos(wallIncl) - bDir * gs_trim_thk_in*incV) )

							py1 = py1 + gs_tw_right_in
							py2 = py1

							add 0, py1L + B - archHeight - tolerOffsetUpperIn, -leftWidth - overSizeLeftIn + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in
							cutplane{2} 270 + TrimLeftTopMiterAngle, 4
							numMiterCuts = numMiterCuts + 1
							del 1
						endif
						if	((bPShapedLeftOpening & gs_trim_below_boardLeft) | isWindow) & not(bTrimovbotleftin) then
							add 0, gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL - (gs_trim_width_in - gs_trim_offs_in) * bDrawLeftSLBoard + gs_trim_width_in - gs_trim_offs_in, \
									-leftWidth - overSizeLeftIn + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in
							py3 = py4
							cutplane{2} TrimLeftbotMiterAngle, 4
							numMiterCuts = numMiterCuts + 1
							del 1
						endif
						del 2

						body -1
						if (gs_apron & abs(gs_trim_thk_in - gs_apron_thk) < EPS) | (not(gs_apron) & (not(bDrawLeftSLBoard) | gs_trim_below_boardLeft)) then
							croof_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								4+2, 0,0, 1,0, 0, 0, -gs_trim_thk_in,
								px1,	py1,	0,			s1,
								px2,	py2,	wallIncl,	s2,
								px2,	py5,	wallIncl,	8,
								px2,	py6,	wallIncl,	15-2 * (gs_stack_bottom),
								px2,	py3,	0,			s3*not(bTrimovbotleftin) + bTrimovbotleftin * (15-7*gs_stack_bottom),
								px1,	py4,	0,			s4
						else
							croof_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								4+1, 0,0, 1,0, 0, 0, -gs_trim_thk_in,
								px1,	py1,	0,	s1,
								px2,	py2,	wallIncl*bTrimovbotleftin,	s2,
								px2,	py3+gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron)+gs_trimov_bot_left_in, wallIncl*(bTrimovbotleftin), 15-6 * (gs_stack_bottom | ABS(gs_trim_offs_in) < EPS),
								px2,	py3+gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron),	0, 15-7*gs_stack_bottom,
								px1,	py3+gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron),	0, s4

							if not(gs_stack_bottom) & ABS(gs_trim_offs_in) < EPS & bTrimovbotleftin then
								lin_ px2-gs_trim_thk_in * tan(wallIncl),	py3+gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron),							gs_trim_thk_in,
									 px2-gs_trim_thk_in * tan(wallIncl),	py3+gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron)+gs_trimov_bot_left_in,	gs_trim_thk_in
								lin_ px2,	py3+gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron)+gs_trimov_bot_left_in,	gs_trim_thk_in,
									 px2,	py3+gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron)+gs_trimov_bot_left_in,	0
							endif
						endif
						gosub "TextCoord_Vert"
						for i = 1 to numMiterCuts
							cutend
						next i
					endif

					! --- Draw Door's Left side Trim Inclined Wall ---
					py1 = -overSizeBottomIn
					py2 = -overSizeBottomIn
					py3LSL = gs_reveal_double_innerBottom_sL + tolerOffsetLowerIn + gs_sidelight_parapet_hgt_left + not(gs_stack_bottom) * (trinB*not(bDrawLeftSLBoard) \
							 - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawLeftSLBoard)) - sjBy
					py4LSL = gs_reveal_double_innerBottom_sL + tolerOffsetLowerIn + gs_sidelight_parapet_hgt_left + not(gs_stack_bottom) * (trinB*not(bDrawLeftSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawLeftSLBoard) - gs_tw_bottom_in) - sjBy

					if	bPShapedLeftOpening & gs_trim_below_boardLeft then
						px2 = -(leftWidth - gs_sidelight_WHole_width_left - tolerOffsetLeftIn + overSizeLeftIn - gs_trim_width_in + gs_trim_offs_in) / cos(wallIncl) + gs_trim_thk_in * tan(wallIncl)
						px1 = px2 - gs_tw_left_in

						! mitered joint of inclined casing
						addz gs_trim_thk_in
						roty -wallIncl + 90
						add 0, gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL - (gs_trim_width_in - gs_trim_offs_in) * bDrawLeftSLBoard + gs_trim_width_in - gs_trim_offs_in, \
								-leftWidth + gs_sidelight_WHole_width_left - overSizeLeftIn + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in
						cutplane{2} 270 - TrimLeftBotMiterAngle, 4
						del 3
						croof_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							4, 0,0, 1,0, 0, 0, -gs_trim_thk_in,
							px1,	py1,	0,			15,
							px2,	py2,	wallIncl,	s2,
							px2,	py3LSL,	0,			10,
							px1,	py3LSL,	-wallIncl,	s4
						gosub "TextCoord_Vert"

						cutend
					endif

					! --- Draw right side Trim Inclined Wall ---

					px2 = (rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in + gs_trim_offs_in) / cos(wallIncl) + gs_trim_thk_in * tan(wallIncl)
					px1 = px2 + gs_tw_right_in

					if	bShapeEnablesStraightTopTrim then
						py1 = B + overSizeTopIn + not(gs_stack_top) * (-gs_trim_width_in - tolerOffsetUpperIn + gs_trim_offs_in + gs_tw_top_in*not(bTrimovtoprightin))
						py2 = B + overSizeTopIn + not(gs_stack_top) * (-gs_trim_width_in - tolerOffsetUpperIn + gs_trim_offs_in)

						s1 = 15 - 7 * (gs_stack_top | bTrimovtoprightin)
						s2 = bitset (mask, 1, not(gs_stack_top))
					endif

					if	bShapeEnablesArchedTopTrim then
						ta = rightWidth + overSizeTopIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
						tc = arcR + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
						py1 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))

						ta = ta - gs_tw_right_in
						tc = tc - gs_tw_right_in
						py2 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))

						s1 = 8
						s2 = mask - 2
					endif

					if iWindowShape = SHAPE_ELLIPSEARCH then
						py1 = B + overSizeTopIn - archHeight
						py2 = py1

						s1 = 8
						s2 = mask - 2
					endif

					if	isWindow | \
						(bPShapedRightOpening & gs_trim_below_boardRight) then
						py3 = -overSizeBottomIn + not(bDrawRightSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawRightSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawRightSLBoard) \
						- gs_trimov_bot_right_in - gs_tw_bottom_in*bTrimovbotrightin * not(gs_apron) - gs_apron_width*bTrimovbotrightin * gs_apron) - sjBy
						py4 = -overSizeBottomIn + not(bDrawRightSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawRightSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawRightSLBoard) \
						- gs_trimov_bot_right_in - gs_tw_bottom_in * (not(bDrawRightSLBoard) | (bDrawRightSLBoard & (bTrimovbotrightin | gs_trim_below_boardRight))) * not(gs_apron) - gs_apron_width * bTrimovbotleftin * gs_apron) - sjBy

						py5=py3 + not(gs_stack_bottom) * (gs_trimov_bot_right_in + gs_tw_bottom_in*bTrimovbotrightin)
						py6=py3 + not(gs_stack_bottom) * gs_trimov_bot_right_in

						s3 = 15 * isWindow + 15 * bPShapedRightOpening					! 15 or 10 or 8
						s4 = 13 + 2 * not(gs_stack_bottom)	! 15 or 13
					else
						py3 = -overSizeBottomIn
						py4 = -overSizeBottomIn

						s3 = 15
						s4 = 15
					endif

					if	bPShapedRightOpening then
						py3 = py3 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
						py4 = py4 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
						py5 = py5 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
						py6 = py6 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
					endif

					if not(gs_stack_right | bRightCornerFunction) then
						! mitered joint of inclined casing
						addz gs_trim_thk_in
						roty -wallIncl + 90
						numMiterCuts = 0
						if bShapeEnablesStraightTopTrim & not(gs_stack_top) then
							if	not(gs_stack_top) & not(bTrimovtoprightin) then
								add 0, B + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in, rightWidth + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in
								py2 = py1
								cutplane{2} 270 - TrimRightTopMiterAngle, 4
								numMiterCuts = numMiterCuts + 1
								del 1
							endif
						endif

						if	bShapeEnablesArchedTopTrim then
							ta = rightWidth + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in
							tc = arcR + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in
							py1R = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

							ta = ta + gs_tw_right_in
							tc = tc + gs_tw_right_in
							py2R = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

							! mitered joint of inclined casing
							TrimRightTopMiterAngle	= atn( (py2R - py1R) / (gs_tw_right_in * cos(wallIncl) + not(bDir) * gs_trim_thk_in*incV) )

							py1 = py1 + gs_tw_right_in
							py2 = py1

							add 0, py1R + B - archHeight - tolerOffsetUpperIn, rightWidth + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in
							cutplane{2} 270 - TrimRightTopMiterAngle, 4
							numMiterCuts = numMiterCuts + 1
							del 1
						endif

						if	((bPShapedRightOpening & gs_trim_below_boardRight) | isWindow) & not(bTrimovbotrightin) then
							add 0, gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR - (gs_trim_width_in - gs_trim_offs_in) * bDrawRightSLBoard + gs_trim_width_in - gs_trim_offs_in, \
									rightWidth + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in
							py3 = py4
							cutplane{2} 180 - TrimRightBotMiterAngle, 4
							numMiterCuts = numMiterCuts + 1
							del 1
						endif

						del 2

						body -1
						if (gs_apron & abs(gs_trim_thk_in - gs_apron_thk) < EPS) | (not(gs_apron) & (not(bDrawRightSLBoard) | gs_trim_below_boardRight)) then
							croof_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								4+2, 0,0, 1,0, 0, 0, -gs_trim_thk_in,
								px1,	py1,	0,			s1,
								px2,	py2,	-wallIncl,	s2,
								px2,	py5,	-wallIncl,	8,
								px2,	py6,	-wallIncl,	15-2 * gs_stack_bottom,
								px2,	py3,	0,			s3*not(bTrimovbotrightin)+bTrimovbotrightin*(15-7*gs_stack_bottom),
								px1,	py4,	0,			s4
						else
							croof_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								4+1, 0,0, 1,0, 0, 0, -gs_trim_thk_in,
								px1,	py1,	0,			s1,
								px2,	py2,	-wallIncl,	s2,
								px2,	py3+gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron)+gs_trimov_bot_right_in, 0, 15-6 * (gs_stack_bottom | ABS(gs_trim_offs_in) < EPS),
								px2,	py3+gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron),	0, 15-7*gs_stack_bottom,
								px1,	py3+gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron),	0, s4

							if not(gs_stack_bottom) & ABS(gs_trim_offs_in) < EPS & bTrimovbotrightin then
								lin_ px2-gs_trim_thk_in * tan(wallIncl),	py3+gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron),						gs_trim_thk_in,
									 px2-gs_trim_thk_in * tan(wallIncl),	py3+gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron)+gs_trimov_bot_right_in, gs_trim_thk_in
								lin_ px2,	py3+gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron)+gs_trimov_bot_right_in, gs_trim_thk_in,
									 px2,	py3+gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron)+gs_trimov_bot_right_in, 0
							endif
						endif
						gosub "TextCoord_Vert"
						for i = 1 to numMiterCuts
							cutend
						next i
					endif

					! --- Draw Door's Right side Trim Inclined Wall ---
					py1 = -overSizeBottomIn
					py2 = -overSizeBottomIn
					py3RSL = gs_reveal_double_innerBottom_sR + tolerOffsetLowerIn + gs_sidelight_parapet_hgt_right + not(gs_stack_bottom) * (trinB*not(bDrawRightSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawRightSLBoard)) - sjBy
					py4RSL = gs_reveal_double_innerBottom_sR + tolerOffsetLowerIn + gs_sidelight_parapet_hgt_right + not(gs_stack_bottom) * (trinB*not(bDrawRightSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawRightSLBoard) - gs_tw_bottom_in) - sjBy

					if	bPShapedRightOpening & gs_trim_below_boardRight then
						px2 = (rightWidth - gs_sidelight_WHole_width_right - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in + gs_trim_offs_in) / cos(wallIncl) + gs_trim_thk_in * tan(wallIncl)
						px1 = px2 + gs_tw_right_in

						! mitered joint of inclined casing
						addz gs_trim_thk_in
						roty -wallIncl + 90
						add 0, gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR - (gs_trim_width_in - gs_trim_offs_in) * bDrawRightSLBoard + gs_trim_width_in - gs_trim_offs_in, \
									rightWidth - gs_sidelight_WHole_width_right + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in

						cutplane{2}   TrimRightBotMiterAngle - 90, 4
						del 3

						croof_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							4, 0,0, 1,0, 0, 0, -gs_trim_thk_in,
							px1,	py1,	0,			15,
							px2,	py2,	-wallIncl,	s2,
							px2,	py3RSL,	0,			10,
							px1,	py3RSL,	wallIncl,	s4
						gosub "TextCoord_Vert"
						cutend
					endif

					if	bPShapedLeftOpening & gs_trim_below_boardLeft then
						! --- Draw Left lower Trim Inclined Wall ---
						px2 = (gs_trim_width_in - gs_trim_offs_in) / cos(wallIncl)
						px1 = px2 - gs_tw_left_in * not(bTrimovbotleftin)
						px3 = gs_tw_left_in
						pxL = -(leftWidth - tolerOffsetLeftIn + overSizeLeftIn)  / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)
						pxR = -(leftWidth - gs_sidelight_WHole_width_left - gs_trim_width_in + gs_trim_offs_in + overSizeLeftIn)  / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)

						! mitered joint of inclined casing
						if	not(gs_stack_left) & not(gs_trimov_bot_left_in) then
							lin_ pxL + not(gs_stack_left)  * px2,	py3LSL,	0,
								 pxL + not(gs_stack_left)  * px2 - gs_trim_thk_in * tan(wallIncl),	py3LSL,	gs_trim_thk_in
						endif
						lin_ pxR - gs_tw_left_in,	py4LSL,	0,
							 pxR - gs_tw_left_in - gs_trim_thk_in * tan(wallIncl),	py4LSL,	gs_trim_thk_in

						addz gs_trim_thk_in
						roty -wallIncl + 90
						numMiterCuts = 0
						if	not(gs_stack_left) & not(bTrimovbotleftin) then
							add 0, gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL - (gs_trim_width_in - gs_trim_offs_in) * bDrawLeftSLBoard + gs_trim_width_in - gs_trim_offs_in, \
									-leftWidth - overSizeLeftIn + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in
							px2 = px1
							cutplane{2} 180 + TrimLeftBotMiterAngle, 4
							numMiterCuts = numMiterCuts + 1
							del 1
						endif
						add 0, gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL - (gs_trim_width_in - gs_trim_offs_in) * bDrawLeftSLBoard + gs_trim_width_in - gs_trim_offs_in, \
								-leftWidth + gs_sidelight_WHole_width_left - overSizeLeftIn + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in
						px4 = px3
						cutplane{2} 90 - TrimLeftBotMiterAngle, 4
						numMiterCuts = numMiterCuts + 1
						del 1
						del 2

						croof_ bBottomtriminmat, bBottomtriminmat, bBottomtriminmat,
							4, 0,0, 1,0, 0, 0, -bBottomtriminthk,
							pxL + not(gs_stack_left)  * px1,	py4LSL, 	-gs_stack_left * wallIncl * not(bTrimovbotleftin),	15,
							pxL + not(gs_stack_left)  * px2,	py3LSL,		0,													mask - 2 * gs_stack_left,
							pxR + px3,							py3LSL,		wallIncl * bTrimovbotrightin,						maskRight + 5 * not(gs_trim_below_boardLeft),
							pxR + px3,							py4LSL, 	0,													13
						gosub "TextCoord_Hor"
						for i = 1 to numMiterCuts
							cutend
						next i
					endif

					if	bPShapedRightOpening & gs_trim_below_boardRight then
						! --- Draw Right lower Trim Inclined Wall ---
						px2 = -(gs_trim_width_in - gs_trim_offs_in) / cos(wallIncl)
						px1 = px2 + gs_tw_right_in * not(bTrimovbotrightin)
						px3 = -gs_tw_right_in
						pxL = (rightWidth - tolerOffsetRightIn + overSizeRightIn)  / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)
						pxR = (rightWidth - gs_sidelight_WHole_width_right - gs_trim_width_in + gs_trim_offs_in + overSizeRightIn)  / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)

						! mitered joint of inclined casing
						if	not(gs_stack_right) & not(gs_trimov_bot_right_in) then
							lin_ pxL + not(gs_stack_right)  * px2,	py3RSL,	0,
								 pxL + not(gs_stack_right)  * px2 - gs_trim_thk_in * tan(wallIncl),	py3RSL,	gs_trim_thk_in
						endif
						lin_ pxR + gs_tw_right_in,	py4RSL,	0,
							 pxR + gs_tw_right_in - gs_trim_thk_in * tan(wallIncl),	py4RSL,	gs_trim_thk_in

						addz gs_trim_thk_in
						roty -wallIncl + 90
						numMiterCuts = 0
						if	not(gs_stack_right) & not(bTrimovbotrightin) then
							add 0, gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR - (gs_trim_width_in - gs_trim_offs_in) * bDrawRightSLBoard + gs_trim_width_in - gs_trim_offs_in, \
									rightWidth + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in
							px2 = px1
							cutplane{2} 360 - TrimRightBotMiterAngle, 4
							numMiterCuts = numMiterCuts + 1
							del 1
						endif
						add 0, gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR - (gs_trim_width_in - gs_trim_offs_in) * bDrawRightSLBoard + gs_trim_width_in - gs_trim_offs_in, \
									rightWidth - gs_sidelight_WHole_width_right + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in
						cutplane{2} TrimRightBotMiterAngle + 90, 4
						numMiterCuts = numMiterCuts + 1
						del 1
						del 2

						croof_ bBottomtriminmat, bBottomtriminmat, bBottomtriminmat,
							4, 0,0, 1,0, 0, 0, -bBottomtriminthk,
							pxL + not(gs_stack_right)  * px1,	py4RSL, 	-gs_stack_right * wallIncl * not(bTrimovbotrightin),	15,
							pxL + not(gs_stack_right)  * px2,	py3RSL,		0,		mask - 2 * gs_stack_right,
							pxR + px3,							py3RSL,		wallIncl * bTrimovbotrightin,	maskRight + 5 * not(gs_trim_below_boardRight),
							pxR + px3,							py4RSL, 	0,				13
						gosub "TextCoord_Hor"
						for i = 1 to numMiterCuts
							cutend
						next i
					endif


					! --- Draw upper Trim  Inclined Wall ---

					px2 = (gs_trim_width_in - gs_trim_offs_in) / cos(wallIncl)
					px1 = px2 - gs_tw_left_in
					px3 = -px2
					px4 = px3 + gs_tw_right_in
					pxL = -(leftWidth - tolerOffsetLeftIn + overSizeLeftIn)  / cos(wallIncl) + gs_trim_thk_in * tan(wallIncl)
					pxR =  (rightWidth - tolerOffsetRightIn + overSizeRightIn) / cos(wallIncl) + gs_trim_thk_in * tan(wallIncl)

					py2 = B - tolerOffsetUpperIn + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in
					py1 = py2 + gs_tw_top_in

					numMiterCuts = 0

					if bShapeEnablesStraightTopTrim & not(gs_stack_top) then

						! mitered joint of inclined casing
						if	not(gs_stack_left) & not(bTrimovtopleftin) then
							lin_ pxL + not(gs_stack_left)  * px2,	py2,	0,
								 pxL + not(gs_stack_left)  * px2 - gs_trim_thk_in * tan(wallIncl),	py2,	gs_trim_thk_in
						endif
						if	not(gs_stack_right) & not(bTrimovtoprightin) then
							lin_ pxR - not(gs_stack_right)  * px2,	py2,	0,
								 pxR - not(gs_stack_right)  * px2 - gs_trim_thk_in * tan(wallIncl),	py2,	gs_trim_thk_in
						endif
						addz gs_trim_thk_in
						roty -wallIncl + 90
						if	not(gs_stack_left) & not(bTrimovtopleftin) then
							add 0, B + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in, -leftWidth - overSizeLeftIn + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in
							px2 = px1
							cutplane{2} 90 + TrimLeftTopMiterAngle, 4
							numMiterCuts = numMiterCuts + 1
							del 1
						endif
						if	not(gs_stack_right) & not(bTrimovtoprightin) then
							add 0, B + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in, rightWidth + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in
							px3 = px4
							cutplane{2} 90 - TrimRightTopMiterAngle, 4
							numMiterCuts = numMiterCuts + 1
							del 1
						endif
						del 2

						if not(bTrimovtopleftin) and not(bTrimovtoprightin) then
							croof_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								4, 0,0, 1,0, 0, 0, -gs_trim_thk_in,
								pxL + not(gs_stack_left)  * px1,	py1,	-gs_stack_left * wallIncl,	8 + 7 * not(gs_stack_left),
								pxL + not(gs_stack_left)  * px2,	py2,	0,							bitset (mask, 1, not(gs_stack_left)),
								pxR + not(gs_stack_right) * px3,	py2,	gs_stack_right * wallIncl,	8 + 7 * not(gs_stack_right),
								pxR + not(gs_stack_right) * px4,	py1, 	0,							13 + 2 * not(gs_stack_right)
						endif
						if bTrimovtopleftin and not(bTrimovtoprightin) then
							croof_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								4+2, 0,0, 1,0, 0, 0, -gs_trim_thk_in,
								pxL + not(gs_stack_left)  * px1-gs_trimov_top_left_in*not(gs_stack_left),	py1,	-gs_stack_left * wallIncl,	8 + 7 * not(gs_stack_left),
								pxL + not(gs_stack_left)  * px1-gs_trimov_top_left_in*not(gs_stack_left),	py2,	0,						15,
								pxL + not(gs_stack_left)  * px1,											py2,	0,						10,
								pxL + not(gs_stack_left)  * px2,											py2,	0,						bitset (mask, 1, not(gs_stack_left)),
								pxR + not(gs_stack_right) * px3,											py2,	gs_stack_right * wallIncl,	8 + 7 * not(gs_stack_right),
								pxR + not(gs_stack_right) * px4,											py1, 	0,						13 + 2 * not(gs_stack_right)
						endif
						if not(bTrimovtopleftin) and bTrimovtoprightin then
							croof_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								4+2, 0,0, 1,0, 0, 0, -gs_trim_thk_in,
								pxL + not(gs_stack_left)  * px1,											py1,	-gs_stack_left * wallIncl,	8 + 7 * not(gs_stack_left),
								pxL + not(gs_stack_left)  * px2,											py2,	0,						bitset (mask, 1, not(gs_stack_left)),
								pxR + not(gs_stack_right) * px3,											py2,	gs_stack_right * wallIncl,	10,
								pxR + not(gs_stack_right) * px4,											py2, 	0,						15,
								pxR + not(gs_stack_right) * px4+gs_trimov_top_right_in*not(gs_stack_right),	py2, 	0,						8 + 7 * not(gs_stack_right),
								pxR + not(gs_stack_right) * px4+gs_trimov_top_right_in*not(gs_stack_right),	py1, 	0,						15
						endif
						if bTrimovtopleftin and bTrimovtoprightin then
							if gs_trimtype_in_int = CASING_NORMAL then				! Rectangular casing type
								croof_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
									4+4, 0,0, 1,0, 0, 0, -gs_trim_thk_in,
									pxL + not(gs_stack_left)  * px1-gs_trimov_top_left_in*not(gs_stack_left),	py1,	-gs_stack_left * wallIncl,	8 + 7 * not(gs_stack_left),
									pxL + not(gs_stack_left)  * px1-gs_trimov_top_left_in*not(gs_stack_left),	py2,	0,						15,
									pxL + not(gs_stack_left)  * px1,											py2,	0,						maskLeft,
									pxL + not(gs_stack_left)  * px2,											py2,	0,						bitset (mask, 1, not(gs_stack_left)),

									pxR + not(gs_stack_right) * px3,											py2,	gs_stack_right * wallIncl,	maskRight,
									pxR + not(gs_stack_right) * px4,											py2, 	0,						15,
									pxR + not(gs_stack_right) * px4+gs_trimov_top_right_in*not(gs_stack_right),	py2, 	0,						8 + 7 * not(gs_stack_right),
									pxR + not(gs_stack_right) * px4+gs_trimov_top_right_in*not(gs_stack_right),	py1, 	0,						15
							endif

							if gs_trimtype_in_int = CASING_OVERHANG then				! SWE traditional casing type
								croof_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
									5+5, 0,0, 1,0, 0, 0, -gs_trim_thk_in,
									pxL + not(gs_stack_left)  * (px1-gs_trimov_top_left_in),	py1,		-gs_stack_left * wallIncl,	8 + 7 * not(gs_stack_left),
									pxL + not(gs_stack_left)  * (px1-gs_trimov_top_left_in),	py1-0.04,	-gs_stack_left * wallIncl,	8 + 7 * not(gs_stack_left),
									pxL + not(gs_stack_left)  * (px1-gs_trimov_top_left_in/2),	py2,		0,							15,
									pxL + not(gs_stack_left)  * px1,							py2,		0,							maskLeft,
									pxL + not(gs_stack_left)  * px2,							py2,		0,							bitset (mask, 1, not(gs_stack_left)),

									pxR + not(gs_stack_right) * px3,							py2,		gs_stack_right * wallIncl,	maskRight,
									pxR + not(gs_stack_right) * px4,							py2, 		0,							15,
									pxR + not(gs_stack_right) * (px4+gs_trimov_top_right_in/2),	py2, 		0,							8 + 7 * not(gs_stack_right),
									pxR + not(gs_stack_right) * (px4+gs_trimov_top_right_in),	py1-0.04, 	0,							15,
									pxR + not(gs_stack_right) * (px4+gs_trimov_top_right_in),	py1, 		0,							15
							endif
						endif
					endif

					if	bShapeEnablesArchedTopTrim then

						resol nArchResolution

						pxL = (-leftWidth - overSizeLeftIn + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in) / cos(wallIncl)
						pxR = (rightWidth + overSizeLeftIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in) / cos(wallIncl)
						px1 = gs_trim_thk_in * tan(wallIncl)

						IncModifiedRad = ((leftWidth / cos(wallIncl))^2 + archHeight^2) / (2 * archHeight)

						addy B - archHeight - tolerOffsetUpperIn

						ta = leftWidth + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in
						tc = arcR + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in
						py1L = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						ta = ta + gs_tw_right_in
						tc = tc + gs_tw_right_in
						py2L = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						ta = rightWidth + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in
						tc = arcR + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in
						py1R = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						ta = ta + gs_tw_right_in
						tc = tc + gs_tw_right_in
						py2R = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						! mitered joint of inclined casing
						TrimLeftTopMiterAngle	= atn( (py2L - py1L) / (gs_tw_right_in * cos(wallIncl) - bDir * gs_trim_thk_in*incV) )
						TrimRightTopMiterAngle	= atn( (py2R - py1R) / (gs_tw_right_in * cos(wallIncl) + not(bDir) * gs_trim_thk_in*incV) )
						addz gs_trim_thk_in
						roty -wallIncl + 90

						add 0, py1L, -leftWidth - overSizeLeftIn + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in
						cutplane{2} 90 + TrimLeftTopMiterAngle, 4
						numMiterCuts = numMiterCuts + 1
						del 1
						add 0, py1R, rightWidth + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in
						cutplane{2} 90 - TrimRightTopMiterAngle, 4
						numMiterCuts = numMiterCuts + 1
						del 1

						del 2

						cutform 5,1,1 + 2 + 8 + 16,
							-sin(wallIncl), 0, cos(wallIncl),	0,
							px1,		archHeight - IncModifiedRad,	900,
							pxL + px1,	py1L-0.5,	  		8,
							pxR + px1,	py1L-0.5,			8,
!							pxR + px1,	py1R-0.00001,	  	15,
							pxR + px1,	py1R,	  			62 + mask,
							pxL + px1,	py1L,	  			3015 - 7 * bHalfCircle

						prism_ 10, gs_trim_thk_in,
							px1,						archHeight - IncModifiedRad,	900,
							pxL + px1,					py1L-1,	  			15,
							pxL + px1,					py1L,	  			15,
							pxR + px1,					py1R,				15,
							pxR + px1,					py1R-1,				15,
							pxR + px1 + gs_tw_right_in,	py1R-1,				15,
							pxR + px1 + gs_tw_right_in,	py2R-0.0001,		15,
							pxR + px1 + gs_tw_right_in,	py2R,				79,
							pxL + px1 - gs_tw_right_in,	py2L,				3015 - 7 * bHalfCircle,
							pxL + px1 - gs_tw_right_in,	py1L-1,	  			15

						cutend

						del 1
					endif

					if iWindowShape = SHAPE_ELLIPSEARCH then

						resol nArchResolution

						pxt = gs_trim_thk_in * tan(wallIncl)
						px1 = -leftWidth - overSizeLeftIn + tolerOffsetLeftIn - gs_trim_offs_in + gs_trim_width_in
						px2 =  rightWidth + overSizeLeftIn - tolerOffsetRightIn + gs_trim_offs_in - gs_trim_width_in
						px3 = -leftWidth - overSizeLeftIn + tolerOffsetLeftIn
						px4 = rightWidth + overSizeLeftIn - tolerOffsetRightIn
						py1 = B + overSizeTopIn - tolerOffsetUpperIn

						pxcL = -leftWidth + smallRadiusEllips
						pxcR = rightWidth - smallRadiusEllips

						s1 = 9 + 4 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS)

						addx pxt
						roty -wallIncl
						cutform 7,1,1 + 2 + 8 + 16,
							0, 0, 1,	0,
							px2,					py1 - archHeight,			s1,
							pxcR,					py1 - archHeight,			900+s1,
							0,		 				alphaSide,					4000+s1,
							0,						py1 - middleRadiusEllips, 	900+s1,
							0,		 				alphaMiddle,				4000+s1,
							pxcL,					py1 - archHeight,			900+s1,
							0,		 				alphaSide,					4000+s1
						del 2

						mulx 1 / cos(wallIncl)

						prism_ 7,gs_trim_thk_in,
							px2 + (gs_tw_right_in + pxt) * cos(wallIncl),	py1 - archHeight,			13+64,
							pxcR + pxt * cos(wallIncl),						py1 - archHeight,			915+64,
							0,		 										alphaSide,					4015+64,
							0 + pxt * cos(wallIncl),						py1 - middleRadiusEllips, 	915+64,
							0,		 										alphaMiddle,				4015+64,
							pxcL + pxt * cos(wallIncl),						py1 - archHeight,			915+64,
							0,		 										alphaSide,					4008+64
						del 1

						cutend
					endif
					gosub "TextCoord_Hor"
					for i = 1 to numMiterCuts
						cutend
					next i

					! --- Draw lower Trim  Inclined Wall ---
					px2 = (gs_trim_width_in - gs_trim_offs_in) / cos(wallIncl)
					px1 = px2 - gs_tw_left_in * not(bTrimovbotleftin)
					px3 = -px2
					px4 = px3 + gs_tw_right_in * not(bTrimovbotrightin)


					py1 = -overSizeBottomIn + not(gs_stack_bottom) * (gs_trim_width_in*not(bDrawBoard) + tolerOffsetLowerIn - gs_trim_offs_in - gs_tw_bottom_in)
					py2 = -overSizeBottomIn + not(gs_stack_bottom) * (gs_trim_width_in*not(bDrawBoard) + tolerOffsetLowerIn - gs_trim_offs_in)

					addz gs_trim_thk_in
					roty -wallIncl + 90
					numMiterCuts = 0
					if	not(gs_stack_left) & not(bTrimovbotleftin) then
						add 0, -overSizeBottomIn + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL - (gs_trim_width_in - gs_trim_offs_in) * bDrawLeftSLBoard + gs_trim_width_in - gs_trim_offs_in, \
								-leftWidth - overSizeLeftIn + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in
						px2 = px1

						cutplane{2} 180 + TrimLeftBotMiterAngle, 4
						numMiterCuts = numMiterCuts + 1
						del 1
					endif
					if	not(gs_stack_right) & not(bTrimovbotrightin) then
						add 0, -overSizeBottomIn + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR - (gs_trim_width_in - gs_trim_offs_in) * bDrawRightSLBoard + gs_trim_width_in - gs_trim_offs_in, \
								rightWidth + overSizeRightIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in
						px3 = px4
						cutplane{2} 360 - TrimRightBotMiterAngle, 4
						numMiterCuts = numMiterCuts + 1
						del 1
					endif
					del 2

					if not(gs_stack_bottom | not(isWindow)) & bShapeEnablesStraightBottomTrim & abs(gs_tw_bottom_in) > EPS then
						if (not(gs_apron) & not(bDrawBoard)) then
							material bBottomtriminmat
							if abs(gs_trim_thk_in - gs_apron_thk) < EPS | (not(gs_apron) & not(bDrawBoard)) then
								pxL = -(leftWidth - tolerOffsetLeftIn + overSizeLeftIn)  / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)
								pxR =  (rightWidth - tolerOffsetRightIn + overSizeRightIn) / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)

								croof_ bBottomtriminmat, bBottomtriminmat, bBottomtriminmat,
									4+2, 0,0, 1,0, 0, 0, -bBottomtriminthk,
									pxL + not(gs_stack_left)  * px1,	py1, 	-gs_stack_left * wallIncl * not(bTrimovbotleftin),	maskLeft*not(bDrawBoard)+maskLeft2*bDrawBoard,
									pxL + not(gs_stack_left)  * px1,	py1 + gs_tw_bottom_in*bDrawBoard, 	-wallIncl*(bTrimovbotleftin), 15 - 7 * gs_stack_left,
									pxL + not(gs_stack_left)  * px2,	py2,				0,				bitset (mask, 1, not(gs_stack_left)),
									pxR + not(gs_stack_right) * px3,	py2,				wallIncl * bTrimovbotrightin,	15 - 7 * gs_stack_right,
									pxR + not(gs_stack_right) * px4,	py1 + gs_tw_bottom_in*bDrawBoard, 	wallIncl*bTrimovbotrightin, maskRight*not(bDrawBoard)+maskRight2*bDrawBoard,
									pxR + not(gs_stack_right) * px4,	py1, 	0,				13 + 2 * not(gs_stack_right)	! 15 or 13
							else
								pxL = -(leftWidth  + overSizeLeftIn)  / cos(wallIncl) + (gs_trim_thk_in*not(bTrimovbotleftin)+bBottomtriminthk*bTrimovbotleftin) * tan(wallIncl)
								pxR =  (rightWidth + overSizeRightIn) / cos(wallIncl) + (gs_trim_thk_in*not(bTrimovbotrightin)+bBottomtriminthk*bTrimovbotrightin) * tan(wallIncl)

								addz (gs_trim_thk_in - gs_apron_thk)
								croof_ bBottomtriminmat, bBottomtriminmat, bBottomtriminmat,
									4, 0,0, 1,0, 0, 0, -bBottomtriminthk,
									pxL + not(gs_stack_left)  * px1,	py1, 	-wallIncl*bTrimovbotleftin,	8 + 7 * not(gs_stack_left),
									pxL + not(gs_stack_left)  * px1,	py2, 	0, 13 + 2 * not(gs_stack_left),
									pxR + not(gs_stack_right) * px4,	py2, 	wallIncl*bTrimovbotrightin, 8 + 7 * not(gs_stack_right),
									pxR + not(gs_stack_right) * px4,	py1, 	0,	13 + 2 * not(gs_stack_right)
								del 1
							endif
							material gs_trim_in_mat
						endif
					endif
					gosub "TextCoord_Hor"
					for i = 1 to numMiterCuts
						cutend
					next i

					del 2
				endif
			else		! Straight wall

				addz -gs_trim_thk_in


				! --- Draw left side Trim ---

				px2 = leftRevealPnts[idxBoardEndRevealLeft][1]  + tolerOffsetLeftIn + trinL - gs_trim_offs_in
				px1 = px2 - gs_tw_left_in

				if	bShapeEnablesStraightTopTrim then
					py1 = B + overSizeTopIn + not(gs_stack_top) * (- tolerOffsetUpperIn - trinT + gs_trim_offs_in + gs_tw_top_in*not(bTrimovtopleftin)) + sjty
					py2 = B + overSizeTopIn + not(gs_stack_top) * (- tolerOffsetUpperIn - trinT + gs_trim_offs_in) + sjty
					py22 = py2 - gs_stack_top * gs_trim_stack_top * gs_tw_top_in / 2

					s1 = maskTop				! 15 or 10 or 8
					if not(gs_stack_top) then
						s2 = bitset (mask, 1, not(gs_stack_top)) + 4 * gs_trim_atframe_in
					else
						s2 = 9 + 4 * gs_trim_atframe_in
					endif
					s22 = bitset (mask, 1, not(gs_stack_top)) + 4 * gs_trim_atframe_in
					if iWindowShape = SHAPE_RECTANGULAR then
						s5 = 9 + 4 * gs_trim_atframe_in
					else
						s5 = 10
					endif
				endif
				if	bShapeEnablesArchedTopTrim then
					ta = leftWidth + overSizeTopIn - tolerOffsetLeftIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
					tc = arcR + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
					py1 = B - arcR - tolerOffsetUpperIn + sqr(max(0, (tc * tc - ta * ta))) - tolerOffsetUpper * not(bHalfCircle)

					ta = ta - gs_tw_right_in
					tc = tc - gs_tw_right_in
					py2 = B - arcR - tolerOffsetUpperIn + sqr(max(0, (tc * tc - ta * ta))) - tolerOffsetUpper * not(bHalfCircle)
					py22 = py2

					s1 = 8
					s2 = mask - 2
					s22 = mask - 2
					if iWindowShape = SHAPE_ARCHED then
						s5 = 9 + 4 * gs_trim_atframe_in
					else
						s5 = 10
					endif
				endif
				if iWindowShape = SHAPE_ELLIPSEARCH then
					py1 = B - archHeight
					py2 = B - archHeight
					py22 = py2

					s1 = 8
					s2 = mask - 2
					s22 = 9 + 4 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS)
					s5 = 9 + 4 * gs_trim_atframe_in
				endif
				if	isWindow | \
					(bPShapedLeftOpening & gs_trim_below_boardLeft) then
					py3 = -overSizeBottomIn + not(bDrawLeftSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawLeftSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawLeftSLBoard)\
					  - gs_trimov_bot_left_in - gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) - gs_apron_width * bTrimovbotleftin * gs_apron) - sjby
					py4 = -overSizeBottomIn + not(bDrawLeftSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawLeftSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawLeftSLBoard)\
					 - gs_trimov_bot_left_in - gs_tw_bottom_in * (not(bDrawLeftSLBoard) | (bDrawLeftSLBoard & (bTrimovbotleftin | gs_trim_below_boardLeft))) * not(gs_apron) - gs_apron_width * bTrimovbotleftin * gs_apron) - sjby

					s3 = maskBottom						! 15 or 10 or 8
					s4 = 13 + 2 * not(gs_stack_bottom)	! 15 or 13
				else
					py3 = -overSizeBottomIn
					py4 = -overSizeBottomIn

					s3 = 15-7*gs_stack_bottom
					s4 = 15
				endif

				py5 = py3 + not(gs_stack_bottom) * bTrimovbotleftin * (gs_trimov_bot_left_in + gs_tw_bottom_in * not(gs_apron) + gs_apron_width * gs_apron) + gs_stack_bottom * gs_trim_stack_bottom * gs_tw_bottom_in / 2
				py6 = py3 + not(gs_stack_bottom) * bTrimovbotleftin * gs_trimov_bot_left_in

				if	bPShapedLeftOpening then
					py3 = py3 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
					py4 = py4 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
					py5 = py5 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
					py6 = py6 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
				endif

				if bDrawBottTrimatGangingIn * not(bGangedCasingonFrame) then
					py6 = py6 + tolerOffsStackCasLowerIn + trinB - gs_trim_offs_in
					s5 = 13
				endif
				if bDrawTopTrimatGangingIn then
					py22 = py2
					if not(bGangedCasingonFrame) then
						py22 = py2 - tolerOffsStackCasUpperIn - trinT + gs_trim_offs_in
						s2 = 10
						s5 = 13
					endif
				endif

				pxWCutTopLeftIn		= px1
				pxWCutTopOHLeftIn	= px1
				pxWCutMidLeftIn		= px1
				pxWCutMidOHLeftIn	= px2
				pxWCutBotLeftIn		= px1
				pyWCutTopLeftIn		= py1
				pyWCutTopOHIn		= py1
				pyWCutMidLeftIn		= py4

				if not(gs_stack_left | bLeftCornerFunction) & bShapeEnablesStraightLeftTrim then

					body -1
					if (gs_apron & abs(gs_trim_thk_in - gs_apron_thk) < EPS) | (not(gs_apron) & (not(bDrawLeftSLBoard) | gs_trim_below_boardLeft) & (isWindow | bPShapedLeftOpening)) then
						if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE_SPLAYED then
							ruled{2} 7, 1+2+4,
								px1,	py1 + scTy * bTrimovtopleftin,	0,
								px2 - scLx,	py2 + scTy,	0,
								px2 - scLx,	py22 + scTy,	0,
								px2 - scLx,	py5 - scBy,	0,
								px2 - scLx,	py6 - scBy,	0,
								px2 - scLx,	py3 - scBy,	0,
								px1,	py4,	0,

								px1,	py1,	gs_trim_thk_in,
								px2,	py2,	gs_trim_thk_in,
								px2,	py22,	gs_trim_thk_in,
								px2,	py5,	gs_trim_thk_in,
								px2,	py6,	gs_trim_thk_in,
								px2,	py3,	gs_trim_thk_in,
								px1,	py4,	gs_trim_thk_in

							lin_ px2 - scLx, py2 + scTy, 0, px2 - scLx, py3 - scBy, 0
							lin_ px1, py1 + scTy * bTrimovtopleftin, 0, px1, py4, 0
							lin_ px1, py1 + scTy * bTrimovtopleftin, gs_trim_thk_in, px1, py4, gs_trim_thk_in
						else
							cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								7, gs_trim_thk_in,
								px1,	py1,	0, s1, gs_trim_in_mat,
								px2,	py2,	0, s2, gs_trim_in_mat,
								px2,	py22,	0, s22, gs_trim_in_mat,
								px2,	py5,	0, s5, gs_trim_in_mat,
								px2,	py6,	0, s3*not(bTrimovbotleftin)+bTrimovbotleftin*15, gs_trim_in_mat,
								px2,	py3,	0, (s3+5*not(gs_tw_bottom_in))*not(bTrimovbotleftin)+bTrimovbotleftin*(15-7*gs_stack_bottom), gs_trim_in_mat,
								px1,	py4,	0, s4, gs_trim_in_mat
						endif
					else
						if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE_SPLAYED then
							ruled{2} 6, 1+2+4,
								px1,	py1 + scTy * bTrimovtopleftin,	0,
								px2 - scLx,	py2 + scTy,	0,
								px2 - scLx,	py22 + scTy,	0,
								px2 - scLx,	py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) + gs_trimov_bot_left_in * bTrimovbotleftin,	1,
								px2 - scLx,	py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron),	1,
								px1,		py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron),	1,

								px1,	py1,	gs_trim_thk_in,
								px2,	py2,	gs_trim_thk_in,
								px2,	py22,	gs_trim_thk_in,
								px2,	py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) + gs_trimov_bot_left_in * bTrimovbotleftin,	gs_trim_thk_in,
								px2,	py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron),	gs_trim_thk_in,
								px1,	py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron),	gs_trim_thk_in

							lin_ px2 - scLx,	py2 + scTy,						0,						px2 - scLx, py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) + gs_trimov_bot_left_in * bTrimovbotleftin, 0
							lin_ px1, 			py1 + scTy * bTrimovtopleftin,	0,						px1,		py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron), 0
							lin_ px1,			py1 + scTy * bTrimovtopleftin,	gs_trim_thk_in, 		px1,		py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron), gs_trim_thk_in
						else
							cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								6, gs_trim_thk_in,
								px1,	py1,	0, s1, gs_trim_in_mat,
								px2,	py2,	0, s2, gs_trim_in_mat,
								px2,	py22,	0, s22, gs_trim_in_mat,
								px2,	py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) + gs_trimov_bot_left_in * bTrimovbotleftin,	0, 15-6*gs_stack_bottom, gs_trim_in_mat,
								px2,	py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron),	0, 15-7*gs_stack_bottom, gs_trim_in_mat,
								px1,	py3 + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron),	0, s4, gs_trim_in_mat
						endif
					endif
					gosub "TextCoord_Vert"
				endif


				! --- Draw Door's Left side Trim ---

				py1 = -overSizeBottomIn
				py2 = -overSizeBottomIn
				py3 = py4 + gs_trimov_bot_left_in
				py4 = py3 + gs_tw_bottom_in

				if	bPShapedLeftOpening & gs_trim_below_boardLeft then
					px1 = leftRevealPnts[idxBoardEndRevealLeft][1] + gs_sidelight_WHole_width_left + trinL - gs_trim_offs_in  !+ tolerOffsetLeftIn
					px2 = px1 - gs_tw_left_in

					prism_ 	4, gs_trim_thk_in,
						px1,	py1,	15,
						px2,	py2,	s4,
						px2,	py3,	s3,
						px1,	py4,	s2
					gosub "TextCoord_Vert"

					! --- Draw Left lower Trim in Straight Wall ---

					px1 = leftRevealPnts[idxBoardEndRevealLeft][1] + not(gs_stack_left) * (tolerOffsetLeftIn - gs_trim_offs_in - gs_tw_left_in * not(bTrimovbotleftin)) + trinL * not(gs_stack_left)
					px2 = leftRevealPnts[idxBoardEndRevealLeft][1] + not(gs_stack_left) * (tolerOffsetLeftIn - gs_trim_offs_in) + trinL * not(gs_stack_left)
					px3 = leftRevealPnts[idxBoardEndRevealLeft][1] + gs_sidelight_WHole_width_left + trinL - gs_trim_offs_in  !+ tolerOffsetLeftIn
					px4 = px3 - gs_tw_left_in * gs_trim_below_boardLeft


					if (not(gs_apron) & not(bDrawLeftSLBoard)) | gs_trim_below_boardLeft then
						addz (WIDO_FRAME_THICKNESS - WALL_THICKNESS + WIDO_SILL) * gs_trim_atframe_in

						if abs(gs_trim_thk_in - gs_apron_thk) < EPS | (not(gs_apron) & not(bDrawLeftSLBoard)) | gs_trim_below_boardLeft then
							prism_ 	4, bBottomtriminthk,
								px1,	py3,	10,
								px2,	py4,	mask - 2 * gs_stack_left,
								px3,	py4,	10 + 5 * not(gs_trim_below_boardLeft),
								px4,	py3,	15
						else
							addz gs_trim_thk_in - gs_apron_thk
							prism_ 4, bBottomtriminthk,
								px1,	py3, 	8 + 7 * not(gs_stack_left),
								px1,	py4,	13 + 2 * not(gs_stack_left),
								px4,	py4,	8 + 7 * not(gs_stack_right),
								px4,	py3, 	13 + 2 * not(gs_stack_right)
							del 1
						endif
						gosub "TextCoord_Hor"

						del 1
					endif
					pxWCutBotLeftIn = px4
				endif

				pyWCutBotLeftIn = py1


				! --- Draw right side Trim ---

				px2 = rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn - trinR + gs_trim_offs_in
				px1 = px2 + gs_tw_right_in

				if	bShapeEnablesStraightTopTrim then
					py1 = B + overSizeTopIn + not(gs_stack_top) * (- tolerOffsetUpperIn - trinT + gs_trim_offs_in + gs_tw_top_in*not(bTrimovtoprightin)) + sjty
					py2 = B + overSizeTopIn + not(gs_stack_top) * (- tolerOffsetUpperIn - trinT + gs_trim_offs_in) + sjty
					py22 = py2 - gs_stack_top * gs_trim_stack_top * gs_tw_top_in / 2

					s1 = maskTop						! 15 or or 10 8
					if not(gs_stack_top) then
						s2 = bitset (mask, 1, not(gs_stack_top)) + 4 * gs_trim_atframe_in
					else
						s2 = 9 + 4 * gs_trim_atframe_in
					endif
					s22 = bitset (mask, 1, not(gs_stack_top)) + 4 * gs_trim_atframe_in
					if iWindowShape = SHAPE_RECTANGULAR then
						s5 = 9 + 4 * gs_trim_atframe_in
					else
						s5 = 10
					endif
				endif
				if	bShapeEnablesArchedTopTrim then
					ta = rightWidth + overSizeTopIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
					tc = arcR + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
					py1 = B - arcR - tolerOffsetUpperIn + sqr(max(0, (tc * tc - ta * ta))) - tolerOffsetUpper * not(bHalfCircle)

					ta = ta - gs_tw_right_in
					tc = tc - gs_tw_right_in
					py2 = B - arcR - tolerOffsetUpperIn + sqr(max(0, (tc * tc - ta * ta))) - tolerOffsetUpper * not(bHalfCircle)
					py22 = py2

					s1 = 8
					s2 = mask - 2
					s22 = mask - 2
					if iWindowShape = SHAPE_ARCHED then
						s5 = 9 + 4 * gs_trim_atframe_in
					else
						s5 = 10
					endif
				endif
				if iWindowShape = SHAPE_ELLIPSEARCH then
					py1 = B - archHeight
					py2 = B - archHeight
					py22 = py2

					s1 = 8
					s2 = mask - 2
					s22 = 9 + 4 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS)
					s5 = 9 + 4 * gs_trim_atframe_in
				endif

				if	isWindow | \
					(bPShapedRightOpening & gs_trim_below_boardRight) then
					py3 = -overSizeBottomIn + not(bDrawRightSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawRightSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawRightSLBoard)\
					 - gs_trimov_bot_right_in - gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron) - gs_apron_width*bTrimovbotrightin * gs_apron) - sjBy
					py4 = -overSizeBottomIn + not(bDrawRightSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawRightSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawRightSLBoard)\
					 - gs_trimov_bot_right_in - gs_tw_bottom_in * (not(bDrawRightSLBoard) | (bDrawRightSLBoard & (bTrimovbotrightin | gs_trim_below_boardRight))) * not(gs_apron) - gs_apron_width * bTrimovbotleftin * gs_apron) - sjBy

					s3 = maskBottom						! 15 or 10 or 8
					s4 = 13 + 2 * not(gs_stack_bottom)	! 15 or 13
				else
					py3 = -overSizeBottomIn
					py4 = -overSizeBottomIn

					s3 = 15-7*gs_stack_bottom
					s4 = 15
				endif

				py5 = py3 + not(gs_stack_bottom) * bTrimovbotrightin * (gs_trimov_bot_right_in + gs_tw_bottom_in * not(gs_apron) + gs_apron_width * gs_apron) + gs_stack_bottom * gs_trim_stack_bottom * gs_tw_bottom_in / 2
				py6 = py3 + not(gs_stack_bottom) * bTrimovbotrightin  * gs_trimov_bot_right_in

				if	bPShapedRightOpening then
					py3 = py3 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
					py4 = py4 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
					py5 = py5 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
					py6 = py6 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
				endif

				if bDrawBottTrimatGangingIn * not(bGangedCasingonFrame) then
					py6 = py6 + tolerOffsStackCasLowerIn + trinB - gs_trim_offs_in
					s5 = 13
				endif
				if bDrawTopTrimatGangingIn then
					py22 = py2
					if not(bGangedCasingonFrame) then
						py22 = py2 - tolerOffsStackCasUpperIn - trinT + gs_trim_offs_in
						s2 = 10
						s5 = 13
					endif
				endif

				pxWCutTopRightIn	= px1
				pxWCutBotRightIn	= px1
				pxWCutMidRightIn	= px1
				pxWCutMidOHRightIn	= px2
				pyWCutTopRightIn 	= py1
				pyWCutMidRightIn	= py4

				if not(gs_stack_right | bRightCornerFunction) & bShapeEnablesStraightRightTrim then

					body -1
					if (gs_apron & abs(gs_trim_thk_in - gs_apron_thk) < EPS) | (not(gs_apron) & (not(bDrawRightSLBoard) | gs_trim_below_boardRight) & (isWindow | bPShapedRightOpening)) then
						if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE_SPLAYED then
							ruled{2} 7, 1+2+4,
								px1,	py1 + scTy * bTrimovtoprightin,	0,
								px2 + scRx,	py2 + scTy,	1,
								px2 + scRx,	py22 + scTy,	1,
								px2 + scRx,	py5 - scBy,	1,
								px2 + scRx,	py6 - scBy,	1,
								px2 + scRx,	py3 - scBy,	1,
								px1,	py4,	1,

								px1,	py1,	gs_trim_thk_in,
								px2,	py2,	gs_trim_thk_in,
								px2,	py22,	gs_trim_thk_in,
								px2,	py5,	gs_trim_thk_in,
								px2,	py6,	gs_trim_thk_in,
								px2,	py3,	gs_trim_thk_in,
								px1,	py4,	gs_trim_thk_in

							lin_ px2 + scRx, py2 + scTy, 0, px2 + scRx, py3 - scBy, 0
							lin_ px1, py1 + scTy * bTrimovtoprightin, 0, px1, py4, 0
							lin_ px1, py1 + scTy * bTrimovtoprightin, gs_trim_thk_in, px1, py4, gs_trim_thk_in
						else
							cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								7, gs_trim_thk_in,
								px1,	py1,	0, s1, gs_trim_in_mat,
								px2,	py2,	0, s2, gs_trim_in_mat,
								px2,	py22, 	0, s22, gs_trim_in_mat,
								px2,	py5,	0, s5, gs_trim_in_mat,
								px2,	py6,	0, s3*not(bTrimovbotrightin)+bTrimovbotrightin*15, gs_trim_in_mat,
								px2,	py3,	0, (s3+5*not(gs_tw_bottom_in))*not(bTrimovbotrightin)+bTrimovbotrightin*(15-7*gs_stack_bottom), gs_trim_in_mat,
								px1,	py4,	0, s4, gs_trim_in_mat
						endif
					else
						if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE_SPLAYED then
							ruled{2} 6, 1+2+4,
								px1,	py1 + scTy * bTrimovtoprightin,	0,
								px2 + scRx,	py2 + scTy,	1,
								px2 + scRx,	py22 + scTy,	1,
								px2 + scRx,	py3 + gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron) + gs_trimov_bot_right_in * bTrimovbotrightin,	1,
								px2 + scRx,	py3 + gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron),	1,
								px1,	py3 + gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron),	1,

								px1,	py1,	gs_trim_thk_in,
								px2,	py2,	gs_trim_thk_in,
								px2,	py22,	gs_trim_thk_in,
								px2,	py3 + gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron) + gs_trimov_bot_right_in * bTrimovbotrightin,	gs_trim_thk_in,
								px2,	py3 + gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron),	gs_trim_thk_in,
								px1,	py3 + gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron),	gs_trim_thk_in

							lin_ px2 + scRx,	py2 + scTy,						0,				px2 + scRx, py3 + gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron) + gs_trimov_bot_right_in * bTrimovbotrightin, 0
							lin_ px1, 			py1 + scTy * bTrimovtoprightin, 0,				px1,		py3 + gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron), 0
							lin_ px1,			py1 + scTy * bTrimovtoprightin, gs_trim_thk_in, px1,		py3 + gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron), gs_trim_thk_in
						else
							cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								6, gs_trim_thk_in,
								px1,	py1,	0, s1, gs_trim_in_mat,
								px2,	py2,	0, s2, gs_trim_in_mat,
								px2,    py22,   0, s22, gs_trim_in_mat,
								px2,	py3+gs_tw_bottom_in*bTrimovbotrightin* not(gs_apron)+gs_trimov_bot_right_in*bTrimovbotrightin,	0, 15-6*gs_stack_bottom, gs_trim_in_mat,
								px2,	py3+gs_tw_bottom_in*bTrimovbotrightin* not(gs_apron),	0, 15-7*gs_stack_bottom, gs_trim_in_mat,
								px1,	py3+gs_tw_bottom_in*bTrimovbotrightin* not(gs_apron),	0, s4, gs_trim_in_mat
						endif
					endif
					gosub "TextCoord_Vert"
				endif

				! --- Draw Door's Right side Trim ---
				py1 = -overSizeBottomIn
				py2 = -overSizeBottomIn
				py3 = py4 + gs_trimov_bot_right_in
				py4 = py3 + gs_tw_bottom_in

				if	bPShapedRightOpening & gs_trim_below_boardRight then
					px1 = rightRevealPnts[idxBoardEndRevealright][1] - gs_sidelight_WHole_width_right - trinR + gs_trim_offs_in  !- tolerOffsetRightIn
					px2 = px1 + gs_tw_right_in

					prism_ 	4, gs_trim_thk_in,
						px1,	py1,	15,
						px2,	py2,	s4,
						px2,	py3,	s3,
						px1,	py4,	s2
					gosub "TextCoord_Vert"

					! --- Draw Right lower Trim in Straight Wall ---

					px1 = rightRevealPnts[idxBoardEndRevealRight][1] - not(gs_stack_right) * (tolerOffsetRightIn - gs_trim_offs_in - gs_tw_right_in * not(bTrimovbotrightin)) - trinR * not(gs_stack_right)
					px2 = rightRevealPnts[idxBoardEndRevealRight][1] - not(gs_stack_right) * (tolerOffsetRightIn - gs_trim_offs_in) - trinR * not(gs_stack_right)
					px3 = rightRevealPnts[idxBoardEndRevealRight][1] - gs_sidelight_WHole_width_right - trinR + gs_trim_offs_in  !- tolerOffsetRightIn
					px4 = px3 + gs_tw_right_in * gs_trim_below_boardRight

					if (not(gs_apron) & not(bDrawRightSLBoard)) | gs_trim_below_boardRight then
						addz (WIDO_FRAME_THICKNESS - WALL_THICKNESS + WIDO_SILL) * gs_trim_atframe_in

						if abs(gs_trim_thk_in - gs_apron_thk) < EPS | (not(gs_apron) & not(bDrawRightSLBoard)) | gs_trim_below_boardRight then
							prism_ 	4, bBottomtriminthk,
								px1,	py3,	10,
								px2,	py4,	mask - 2 * gs_stack_right,
								px3,	py4,	10 + 5 * not(gs_trim_below_boardRight),
								px4,	py3,	15
						else
							addz gs_trim_thk_in - gs_apron_thk
							prism_ 4, bBottomtriminthk,
								px1,	py3, 	8 + 7 * not(gs_stack_right),
								px1,	py4,	13 + 2 * not(gs_stack_right),
								px4,	py4,	8 + 7 * not(gs_stack_left),
								px4,	py3, 	13 + 2 * not(gs_stack_left)
							del 1
						endif
						gosub "TextCoord_Hor"
						del 1
					endif
					pxWCutBotRightIn = px4
				endif

				pyWCutBotRightIn = py1


				! --- Draw lower Trim/Apron in Straight Wall ---

				py1 = -overSizeBottomIn + tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) - gs_tw_bottom_in) - sjBy
				py2 = -overSizeBottomIn + tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawBoard) - gs_trim_offs_in * not(gs_trim_atframe_in)) - sjBy

				px1 = leftRevealPnts[idxBoardEndRevealLeft][1] + not(gs_stack_left) * (tolerOffsetLeftIn - gs_trim_offs_in - gs_tw_left_in * not(bTrimovbotleftin)) + trinL * not(gs_stack_left| bLeftCornerFunction)
				px2 = leftRevealPnts[idxBoardEndRevealLeft][1] + not(gs_stack_left) * (tolerOffsetLeftIn - gs_trim_offs_in - gs_tw_left_in * (bLeftCornerFunction)) + trinL * not(gs_stack_left| bLeftCornerFunction)
				px3 = rightRevealPnts[idxBoardEndRevealright][1] + not(gs_stack_right) * (- tolerOffsetRightIn + gs_trim_offs_in + gs_tw_right_in * (bRightCornerFunction)) - trinR * not(gs_stack_right | bRightCornerFunction)
				px4 = rightRevealPnts[idxBoardEndRevealright][1] + not(gs_stack_right) * (- tolerOffsetRightIn + gs_trim_offs_in + gs_tw_right_in * not(bTrimovbotrightin)) - trinR * not(gs_stack_right | bRightCornerFunction)

				if bDrawLeftTrimatGangingIn * not(bGangedCasingonFrame) then
					px2 = leftRevealPnts[2][1] + tolerOffsStackCasLeftIn + trinL - gs_trim_offs_in
				endif
				if bDrawRightTrimatGangingIn * not(bGangedCasingonFrame) then
					px3 = rightRevealPnts[2][1] - tolerOffsStackCasRightIn - trinR + gs_trim_offs_in
				endif

				if not(gs_stack_bottom | not(isWindow)) & bShapeEnablesStraightBottomTrim & abs(gs_tw_bottom_in) > EPS & not(bInclinedWall) then
					if (not(gs_apron) & not(bDrawBoard)) then
						material bBottomtriminmat

						addz (WIDO_FRAME_THICKNESS - WALL_THICKNESS + WIDO_SILL) * gs_trim_atframe_in

						if abs(gs_trim_thk_in - gs_apron_thk) < EPS | (not(gs_apron) & not(bDrawBoard)) then
							if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE_SPLAYED then
								ruled{2} 6, 1+2+4,
									px1,	py1, 	0,
									px1,	py1 + gs_tw_bottom_in*bDrawBoard, 	0,
									px2 - not(gs_stack_left) * scLx,	py2 - scBy,	0,
									px3 + not(gs_stack_right) * scRx,	py2 - scBy,	0,
									px4,	py1 + gs_tw_bottom_in*bDrawBoard, 	0,
									px4,	py1, 	0,

									px1,	py1, 	bBottomtriminthk,
									px1,	py1 + gs_tw_bottom_in*bDrawBoard, 	bBottomtriminthk,
									px2,	py2,	bBottomtriminthk,
									px3,	py2,	bBottomtriminthk,
									px4,	py1 + gs_tw_bottom_in*bDrawBoard, 	bBottomtriminthk,
									px4,	py1, 	bBottomtriminthk

								lin_ px2 - not(gs_stack_left) * scLx, py2 - scBy, 0, px3 + not(gs_stack_right) * scRx, py2 - scBy, 0
								lin_ px1, py1, 0, px4, py1, 0
								lin_ px1, py1, bBottomtriminthk, px4, py1, bBottomtriminthk
							else
								cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
									4+2, bBottomtriminthk,
									px1,	py1, 																0, maskLeft*not(bDrawBoard)+maskLeft2*bDrawBoard, gs_trim_in_mat,
									px1,	py1 + gs_tw_bottom_in * (bDrawBoard | bDrawLeftTrimatGangingIn), 	0, maskLeft, gs_trim_in_mat,						! 15 or 8
									px2,	py2,																0, bitset (mask, 1, not(gs_stack_left)), gs_trim_in_mat,
									px3,	py2,																0, maskRight, gs_trim_in_mat,						! 15 or 8
									px4,	py1 + gs_tw_bottom_in * (bDrawBoard | bDrawRightTrimatGangingIn), 	0, maskRight*not(bDrawBoard)+maskRight2*bDrawBoard, gs_trim_in_mat,
									px4,	py1,																0, 13 + 2 * not(gs_stack_right), gs_trim_in_mat	! 15 or 13
							endif
						else
							addz gs_trim_thk_in - gs_apron_thk
							prism_ 4, bBottomtriminthk,
								px1,	py1, 	8 + 7 * not(gs_stack_left),
								px1,	py2,	13 + 2 * not(gs_stack_left),
								px4,	py2,	8 + 7 * not(gs_stack_right),
								px4,	py1, 	13 + 2 * not(gs_stack_right)
							del 1
						endif

						del 1
						material gs_trim_in_mat
					endif
					gosub "TextCoord_Hor"
				endif


				! --- Draw lower Trim/Apron in Inclined Wall ---

				px2 = (gs_trim_width_in - gs_trim_offs_in) / cos(wallIncl)
				px1 = px2 - gs_tw_left_in * not(bTrimovbotleftin)
				px3 = -px2
				px4 = px3 + gs_tw_right_in * not(bTrimovbotrightin)
				pxL = -(leftWidth  + overSizeLeftIn)  / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)
				pxR =  (rightWidth + overSizeRightIn) / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)

				py1 = -overSizeBottomIn + not(gs_stack_bottom) * (gs_trim_width_in*not(bDrawBoard) - gs_trim_offs_in * not(gs_trim_atframe_in)- gs_tw_bottom_in)
				py2 = -overSizeBottomIn + not(gs_stack_bottom) * (gs_trim_width_in*not(bDrawBoard) - gs_trim_offs_in * not(gs_trim_atframe_in))

				if not(gs_stack_bottom | not(isWindow)) & bShapeEnablesStraightBottomTrim & abs(gs_tw_bottom_in) > EPS & bInclinedWall then
					if (not(gs_apron) & not(bDrawBoard)) then
						material bBottomtriminmat

						addz (WIDO_FRAME_THICKNESS - WALL_THICKNESS + WIDO_SILL) * gs_trim_atframe_in + gs_trim_thk_in
						roty wallIncl
						addz -gs_trim_thk_in

						if abs(gs_trim_thk_in - gs_apron_thk) < EPS | (not(gs_apron) & not(bDrawBoard)) then
							croof_ bBottomtriminmat, bBottomtriminmat, bBottomtriminmat,
								4+2, 0,0, 1,0, 0, 0, -bBottomtriminthk,
								pxL + not(gs_stack_left)  * px1,	py1, 	-gs_stack_left * wallIncl*not(bTrimovbotleftin),	maskLeft*not(bDrawBoard)+maskLeft2*bDrawBoard,
								pxL + not(gs_stack_left)  * px1,	py1 + gs_tw_bottom_in*bDrawBoard, 	-wallIncl*(bTrimovbotleftin), maskLeft,						! 15 or 8
								pxL + not(gs_stack_left)  * px2,	py2,				0,				bitset (mask, 1, not(gs_stack_left)),
								pxR + not(gs_stack_right) * px3,	py2,				gs_stack_right * wallIncl*not(bTrimovbotrightin),	maskRight,				! 15 or 8
								pxR + not(gs_stack_right) * px4,	py1 + gs_tw_bottom_in*bDrawBoard, 	wallIncl*bTrimovbotrightin, maskRight*not(bDrawBoard)+maskRight2*bDrawBoard,
								pxR + not(gs_stack_right) * px4,	py1, 	0,				13 + 2 * not(gs_stack_right)	! 15 or 13
						else
							addz gs_trim_thk_in - gs_apron_thk
							croof_ bBottomtriminmat, bBottomtriminmat, bBottomtriminmat,
								4, 0,0, 1,0, 0, 0, -bBottomtriminthk,
								pxL + not(gs_stack_left)  * px1,	py1, 	-wallIncl*bTrimovbotleftin,	8 + 7 * not(gs_stack_left),
								pxL + not(gs_stack_left)  * px1,	py2, 	0, 9 + 2 * not(gs_stack_left),
								pxR + not(gs_stack_right) * px4,	py2, 	wallIncl*bTrimovbotrightin, 8 + 7 * not(gs_stack_right),
								pxR + not(gs_stack_right) * px4,	py1, 	0,	13 + 2 * not(gs_stack_right)
							del 1
						endif

						del 3
						material gs_trim_in_mat
					endif
					gosub "TextCoord_Hor"
				endif

				! --- Draw upper Trim ---

				if gs_stack_left then
					px1 = leftRevealPnts[idxBoardEndRevealLeft-1][1] - gs_trim_thk_in * tan(alfaLeft)
					px2 = leftRevealPnts[idxBoardEndRevealLeft-1][1] - gs_trim_thk_in * tan(alfaLeft)
					px22 = leftRevealPnts[idxBoardEndRevealLeft-1][1]
					px3 = leftRevealPnts[idxBoardEndRevealLeft-1][1] - gs_trim_thk_in * tan(alfaLeft)
					px4 = leftRevealPnts[idxBoardEndRevealLeft-1][1] + gs_tw_left_in /2

					s1 = 8
					s2 = 8 + 5 * not(gs_trim_stack_left)
					s3 = maskLeft + 1 * not(gs_trim_atframe_in)
					s4 = bitset (mask, 1, not(gs_stack_left)) + 4 * gs_trim_atframe_in
				else
					px1 = leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn + not(bLeftCornerFunction) * trinL - gs_trim_offs_in - gs_tw_left_in - gs_trimov_top_left_in * bTrimovtopleftin
					px2 = leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn + not(bLeftCornerFunction) * trinL - gs_trim_offs_in - (gs_tw_left_in + gs_trimov_top_left_in) * (bTrimovtopleftin | bLeftCornerFunction)
					px22 = 0
					px3 = leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn + not(bLeftCornerFunction) * trinL - gs_trim_offs_in - gs_tw_left_in * bTrimovtopleftin
					px4 = leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn + not(bLeftCornerFunction) * trinL - gs_trim_offs_in

					s1 = 8 + 7 * bTrimovtopleftin
					s2 = 13 + 2 * bTrimovtopleftin
					s3 = maskLeft
					s4 = bitset (mask, 1, not(gs_stack_left))
				endif

				if gs_stack_right then
					px5 = rightRevealPnts[idxBoardEndRevealRight-1][1] - gs_tw_right_in /2
					px6 = rightRevealPnts[idxBoardEndRevealRight-1][1] + gs_trim_thk_in * tan(alfaRight)
					px77 = rightRevealPnts[idxBoardEndRevealRight-1][1]
					px7 = rightRevealPnts[idxBoardEndRevealRight-1][1] + gs_trim_thk_in * tan(alfaRight)
					px8 = rightRevealPnts[idxBoardEndRevealRight-1][1] + gs_trim_thk_in * tan(alfaRight)

					s5 = maskRight + 1 * not(gs_trim_atframe_in) !- 2
					s6 = 8 + 5 * not(gs_trim_stack_right)
					s7 = 8
					s8 = 13
				else
					px5 = rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn - not(bRightCornerFunction) * trinR + gs_trim_offs_in
					px6 = rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn - not(bRightCornerFunction) * trinR + gs_trim_offs_in + gs_tw_right_in * bTrimovtoprightin
					px7 = rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn - not(bRightCornerFunction) * trinR + gs_trim_offs_in + (gs_tw_right_in + gs_trimov_top_right_in) * (bTrimovtoprightin | bRightCornerFunction)
					px8 = rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn - not(bRightCornerFunction) * trinR + gs_trim_offs_in + gs_tw_right_in + gs_trimov_top_right_in * bTrimovtoprightin

					s5 = maskRight
					s6 = 15
					s7 = 8 + 7 * bTrimovtoprightin
					s8 = 15
				endif

				py2 = B + overSizeTopIn - tolerOffsetUpperIn - trinT + gs_trim_offs_in + sjTy
				py1 = py2 + gs_tw_top_in

				pyWCutTopOHIn = py1

				if bDrawLeftTrimatGangingIn * not(bGangedCasingonFrame) then
					px3 = leftRevealPnts[2][1] + tolerOffsStackCasLeftIn + trinL - gs_trim_offs_in
					px4 = leftRevealPnts[2][1] + tolerOffsStackCasLeftIn + trinL - gs_trim_offs_in
				endif
				if bDrawRightTrimatGangingIn * not(bGangedCasingonFrame) then
					px6 = rightRevealPnts[2][1] - tolerOffsStackCasRightIn - trinR + gs_trim_offs_in
				endif

				if bShapeEnablesStraightTopTrim & not(gs_stack_top) then

					add px22, 0, gs_trim_thk_in
					roty  alfaLeft * ySign - 90
					if gs_stack_left then cutplane 1, 1, 0
					del 2

					if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE_SPLAYED then
						if gs_trimtype_in_int = CASING_NORMAL then				! Rectangular casing type
							ruled{2} 8, 1+2+4,
								px1,	py1,	0,
								px2 - scLx * not(bTrimovtopleftin),	py2 + scTy,	0,
								px3 - scLx * not(bTrimovtopleftin),	py2 + scTy,	0,
								px4 - scLx,	py2 + scTy,	1,
								px5 + scRx,	py2 + scTy,	1,
								px6 + scRx * not(bTrimovtoprightin),	py2 + scTy, 	0,
								px7 + scRx * not(bTrimovtoprightin),	py2 + scTy, 	0,
								px8,	py1, 	0,

								px1,	py1,	gs_trim_thk_in,
								px2,	py2,	gs_trim_thk_in,
								px3,	py2,	gs_trim_thk_in,
								px4,	py2,	gs_trim_thk_in,
								px5,	py2,	gs_trim_thk_in,
								px6,	py2, 	gs_trim_thk_in,
								px7,	py2, 	gs_trim_thk_in,
								px8,	py1, 	gs_trim_thk_in

							if bTrimovtopleftin & not(gs_stack_left) then lin_ px2, py2 + scTy, 0, px3, py2 + scTy, 0
							if bTrimovtopleftin then lin_ px2, py2, gs_trim_thk_in, px3, py2, gs_trim_thk_in
							if bTrimovtopleftin & not(gs_stack_left) then lin_ px1, py1, 0, px1, py2 + scTy, 0
							if bTrimovtopleftin & not(gs_stack_left) then lin_ px1, py1, gs_trim_thk_in, px1, py2, gs_trim_thk_in
							if bTrimovtoprightin then lin_ px7, py2 + scTy, 0, px6, py2 + scTy, 0
							if bTrimovtoprightin then lin_ px7, py2, gs_trim_thk_in, px6, py2, gs_trim_thk_in
							if bTrimovtoprightin then lin_ px8, py1, 0, px8, py2 + scTy, 0
							if bTrimovtoprightin then lin_ px8, py1, gs_trim_thk_in, px8, py2, gs_trim_thk_in
						endif
						if gs_trimtype_in_int = CASING_OVERHANG then				! SWE traditional casing type
							ruled{2} 10, 1+2+4,
								px1,	py1,	0,
								px1,	py1-0.04 + scTy,	0,
								px3 + (px1 - px3)/2 - scLx * not(bTrimovtopleftin),	py2 + scTy,	0,
								px3 - scLx * not(bTrimovtopleftin),	py2 + scTy,	0,
								px4 - scLx,	py2 + scTy,	1,
								px5 + scRx,	py2 + scTy,	1,
								px6 + scRx * not(bTrimovtoprightin),	py2 + scTy, 	0,
								px6 + (px8 - px6)/2 + scRx * not(bTrimovtoprightin),	py2 + scTy, 	0,
								px8,	py1-0.04 + scTy, 	0,
								px8,	py1, 	0,

								px1,	py1,	gs_trim_thk_in,
								px1,	py1-0.04,	gs_trim_thk_in,
								px3 + (px1 - px3)/2,	py2,	gs_trim_thk_in,
								px3,	py2,	gs_trim_thk_in,
								px4,	py2,	gs_trim_thk_in,
								px5,	py2,	gs_trim_thk_in,
								px6,	py2, 	gs_trim_thk_in,
								px6 + (px8 - px6)/2,	py2, 	gs_trim_thk_in,
								px8,	py1-0.04, 	gs_trim_thk_in,
								px8,	py1, 	gs_trim_thk_in


							if bTrimovtopleftin & not(gs_stack_left) then lin_ px3 + (px1 - px3)/2, py2 + scTy, 0, px3, py2 + scTy, 0
							if bTrimovtopleftin then lin_ px3 + (px1 - px3)/2, py2, gs_trim_thk_in, px3, py2, gs_trim_thk_in
							if bTrimovtopleftin & not(gs_stack_left) then lin_ px1, py1-0.04 + scTy, 0, px3 + (px1 - px3)/2, py2 + scTy, 0
							if bTrimovtopleftin & not(gs_stack_left) then lin_ px1, py1-0.04, gs_trim_thk_in, px3 + (px1 - px3)/2, py2, gs_trim_thk_in
							if bTrimovtopleftin & not(gs_stack_left) then lin_ px1, py1-0.04 + scTy, 0, px1, py1, 0
							if bTrimovtopleftin & not(gs_stack_left) then lin_ px1, py1-0.04, gs_trim_thk_in, px1, py1, gs_trim_thk_in

							if bTrimovtoprightin then lin_ px6 + (px8 - px6)/2, py2 + scTy, 0, px6, py2 + scTy, 0
							if bTrimovtoprightin then lin_ px6 + (px8 - px6)/2, py2, gs_trim_thk_in, px6, py2, gs_trim_thk_in
							if bTrimovtoprightin then lin_ px8, py1-0.04 + scTy, 0, px6 + (px8 - px6)/2, py2 + scTy, 0
							if bTrimovtoprightin then lin_ px8, py1-0.04, gs_trim_thk_in, px6 + (px8 - px6)/2, py2, gs_trim_thk_in
							if bTrimovtoprightin then lin_ px8, py1-0.04 + scTy, 0, px8, py1, 0
							if bTrimovtoprightin then lin_ px8, py1-0.04, gs_trim_thk_in, px8, py1, gs_trim_thk_in
						endif

							lin_ px4 - not(gs_stack_left) * scLx, py2 + scTy, 0, px5 + not(gs_stack_right) * scRx, py2 + scTy, 0
	!						lin_ px1, py2 + scTy, 0, px8, py2 + scTy, 0
							lin_ px1, py1, 0, px8, py1, 0
							lin_ px1, py1, gs_trim_thk_in, px8, py1, gs_trim_thk_in

					else
						if gs_trimtype_in_int = CASING_NORMAL then				! Rectangular casing type
							cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								8, gs_trim_thk_in,
								px1,	py1,	0, s1, gs_trim_in_mat,
								px2,	py2,	0, s2, gs_trim_in_mat,
								px3,	py2,	0, s3, gs_trim_in_mat,
								px4,	py2,	0, s4, gs_trim_in_mat,
								px5,	py2,	0, s5, gs_trim_in_mat,
								px6,	py2, 	0, s6, gs_trim_in_mat,
								px7,	py2, 	0, s7, gs_trim_in_mat,
								px8,	py1, 	0, s8, gs_trim_in_mat
						endif
						if gs_trimtype_in_int = CASING_OVERHANG then				! SWE traditional casing type
							cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
								10, gs_trim_thk_in,
								px1,	py1,			0, s1, gs_trim_in_mat,
								px1,	py1-0.04,		0, s1, gs_trim_in_mat,
								px3 + (px1 - px3)/2,py2,0, s2, gs_trim_in_mat,
								px3,	py2,			0, s3, gs_trim_in_mat,
								px4,	py2,			0, s4, gs_trim_in_mat,
								px5,	py2,			0, s5, gs_trim_in_mat,
								px6,	py2, 			0, s6, gs_trim_in_mat,
								px6 + (px8 - px6)/2,py2,0, s7, gs_trim_in_mat,
								px8,	py1-0.04, 		0, s7, gs_trim_in_mat,
								px8,	py1, 			0, s8, gs_trim_in_mat
						endif
					endif

					if gs_stack_left then cutend
				endif

				if	bShapeEnablesArchedTopTrim then

					resol nArchResolution
					addy B - archHeight - tolerOffsetUpperIn

					px1 = -leftWidth  - overSizeLeftIn  + tolerOffsetLeftIn  - gs_trim_offs_in + gs_trim_width_in
					px2 =  rightWidth + overSizeRightIn - tolerOffsetRightIn + gs_trim_offs_in - gs_trim_width_in

					if bHalfCircle then
						cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							11, gs_trim_thk_in,
							px1,					0,		0, 8 + 7 * gs_stack_left, gs_trim_in_mat,
							px1 - gs_tw_right_in,	-EPS,	0, 8 + 7 * gs_stack_left, gs_trim_in_mat,
							px1 - gs_tw_right_in,	0,		0, 79,	gs_trim_in_mat,
							0,						0,		0, 900,	gs_trim_in_mat,
							0, archHeight + gs_trim_offs_in - gs_trim_width_in + gs_tw_right_in, 0, 3079, gs_trim_in_mat,
							px2 + gs_tw_right_in,	0,		0, 3079, gs_trim_in_mat,
							px2 + gs_tw_right_in,	-EPS,	0, 8 + 7 * gs_stack_right, gs_trim_in_mat,
							px2,					0,		0, 62 + mask, gs_trim_in_mat,
							0, archHeight + gs_trim_offs_in - gs_trim_width_in, 0, 3062 + mask, gs_trim_in_mat,
							px1,					0,		0, 3013 + 2 * gs_stack_left, gs_trim_in_mat,
							px1,					0,		0, -1, gs_trim_in_mat

						! --- Draw missing lines ---
						if gs_stack_left  then lin_ px1 - gs_tw_right_in,0,0, px1 - gs_tw_right_in,0,gs_trim_thk_in
						if gs_stack_right then lin_ px2,0,0, px2,0,gs_trim_thk_in
					else
						ta = leftWidth + overSizeTopIn - tolerOffsetLeftIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
						tc = arcR + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
						py1L = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight - tolerOffsetUpper

						ta = ta - gs_tw_right_in
						tc = tc - gs_tw_right_in
						py2L = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight - tolerOffsetUpper

						ta = rightWidth + overSizeTopIn - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
						tc = arcR + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
						py1R = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight - tolerOffsetUpper

						ta = ta - gs_tw_right_in
						tc = tc - gs_tw_right_in
						py2R = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight - tolerOffsetUpper

						cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							8, gs_trim_thk_in,
							0,						archHeight - arcR, 0, 900, gs_trim_in_mat,
							px1,					py2L,		0, 8 + 7 * gs_stack_left, gs_trim_in_mat,
							px1 - gs_tw_right_in,	py1L,		0, 79, gs_trim_in_mat,
							0,						archHeight + gs_trim_offs_in - gs_trim_width_in + gs_tw_right_in,	0, 3079, gs_trim_in_mat,
							px2 + gs_tw_right_in,	py1R,		0, 3010 + 5 * gs_stack_right, gs_trim_in_mat,
							px2,					py2R,		0, 62 + mask, gs_trim_in_mat,
							0,						archHeight + gs_trim_offs_in - gs_trim_width_in,	0, 3062 + mask, gs_trim_in_mat,
							px1,					py2L,		0, 3015, gs_trim_in_mat

						lin_ px2,py2R,0, px2,py2R,gs_trim_thk_in
					endif

					del 1
				endif

				if iWindowShape = SHAPE_ELLIPSEARCH then

					resol nArchResolution

					px1 = -leftWidth - overSizeLeftIn + tolerOffsetLeftIn - gs_trim_offs_in + gs_trim_width_in
					px2 =  rightWidth + overSizeLeftIn - tolerOffsetRightIn + gs_trim_offs_in - gs_trim_width_in
					px3 = -leftWidth - overSizeLeftIn + tolerOffsetLeftIn
					px4 = rightWidth + overSizeLeftIn - tolerOffsetRightIn

					pxcL = -leftWidth + smallRadiusEllips
					pxcR = rightWidth - smallRadiusEllips

					py1 = B - tolerOffsetUpperIn

					s1 = 9 + 4 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS)

					cprism_{2} gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
						13,gs_trim_thk_in,
						px2,					py1 - archHeight,			0, s1, gs_trim_in_mat,
						pxcR,					py1 - archHeight,			0, 900+s1, gs_trim_in_mat,
						0,		 				alphaSide,					0, 4000+s1, gs_trim_in_mat,
						0,						py1 - middleRadiusEllips, 	0, 900+s1, gs_trim_in_mat,
						0,		 				alphaMiddle,				0, 4000+s1, gs_trim_in_mat,
						pxcL,					py1 - archHeight,			0, 900+s1, gs_trim_in_mat,
						0,		 				alphaSide,					0, 4008, gs_trim_in_mat,
						px1 - gs_tw_right_in,	py1 - archHeight,			0, 13+64, gs_trim_in_mat,
						0,		 				-alphaSide,					0, 4015+64, gs_trim_in_mat,
						0,						py1 - middleRadiusEllips, 	0, 915+64, gs_trim_in_mat,
						0,		 				-alphaMiddle,				0, 4015+64, gs_trim_in_mat,
						pxcR,					py1 - archHeight,			0, 908+64, gs_trim_in_mat,
						0,		 				-alphaSide,					0, 4008+64, gs_trim_in_mat
				endif
				gosub "TextCoord_Hor"

				del 1


				if bCutWall then
					pen WALL_VIEW_PEN
					material matWallIn

					if	bShapeEnablesArchedTopTrim | \
						iWindowShape = SHAPE_ELLIPSEARCH then

						if iWindowShape = SHAPE_ELLIPSEARCH then
							put	pxWCutTopRightIn, pyWCutTopRightIn, 79,
								pxcR,				pyWCutTopRightIn,			979,
								0,		 			alphaSide,					4079,
								0,					py1 - middleRadiusEllips, 	979,
								0,		 			alphaMiddle,				4079,
								pxcL,				py1 - archHeight,			979,
								0,		 			alphaSide,					4079
						else
							if bHalfCircle then
								put	pxWCutTopRightIn, pyWCutTopRightIn, 79,
									0, B - tolerOffsetUpperIn - archHeight, 900,
									pxWCutTopLeftIn, pyWCutTopLeftIn, 3079
							else
								put pxWCutTopRightIn, pyWCutTopRightIn-EPS, 31,
									pxWCutTopRightIn, pyWCutTopRightIn, 79,
									0, B - tolerOffsetUpperIn - arcR, 900,
									pxWCutTopLeftIn, pyWCutTopLeftIn, 3031,
									pxWCutTopLeftIn, pyWCutTopLeftIn-EPS, 31
							endif
						endif
					else
						put pxWCutTopRightIn, pyWCutTopRightIn, 31
						if gs_trimtype_in_int = CASING_OVERHANG then
							put	pxWCutTopRightIn	+ gs_trimov_top_right_in/2, pyWCutTopRightIn, 31,
								pxWCutTopRightIn	+ gs_trimov_top_right_in,	pyWCutTopOHIn - 0.04, 31,
								pxWCutTopRightIn	+ gs_trimov_top_right_in,	pyWCutTopOHIn, 31,
								pxWCutTopLeftIn	- gs_trimov_top_left_in,	pyWCutTopOHIn, 31,
								pxWCutTopLeftIn	- gs_trimov_top_left_in,	pyWCutTopOHIn - 0.04, 31,
								pxWCutTopLeftIn	- gs_trimov_top_left_in/2, pyWCutTopRightIn, 31
						endif
						put	pxWCutTopLeftIn,	pyWCutTopLeftIn,	31
					endif

					put	pxWCutMidLeftIn, pyWCutMidLeftIn, 31

					if gs_trimtype_in_int = CASING_OVERHANG then
						put	pxWCutMidOHLeftIn, pyWCutMidLeftIn, 31,
							pxWCutMidOHLeftIn, pyWCutMidLeftIn + gs_trimov_bot_left_in, 31
					endif
					if not(isWindow) & bPShapedLeftOpening then
						put	pxWCutBotLeftIn, pyWCutMidLeftIn + gs_trimov_bot_left_in, 31,
							pxWCutBotLeftIn, pyWCutBotLeftIn, 31
					endif
					if not(isWindow) & bPShapedRightOpening then
						put	pxWCutBotRightIn, pyWCutBotRightIn, 31,
							pxWCutBotRightIn, pyWCutMidRightIn + gs_trimov_bot_right_in, 31
					endif
					if gs_trimtype_in_int = CASING_OVERHANG then
						put	pxWCutMidOHRightIn, pyWCutMidRightIn + gs_trimov_bot_right_in, 31,
							pxWCutMidOHRightIn, pyWCutMidRightIn, 31
					endif

					put	pxWCutMidRightIn, pyWCutMidRightIn, 31

!					prism_ nsp/3,-1,
!						use(nsp)

					wallniche nsp/3,1,16,
						0,0,1,0,
						get(nsp)

					pen gs_frame_pen
					material gs_trim_in_mat
				endif

			endif ! bInclinedWall
		endif

		del 1

	else	! not(curvedWall)
		if iRevealType <> REVEAL_SLANTED & iRevealType <> REVEAL_SPLAYED & iRevealType <> REVEAL_HISTORIC & iRevealType <> REVEAL_DOUBLE_SPLAYED then

			! ======================================
			! Inside Trim - Curved Walls
			! ======================================

			resol WALL_RESOL

			offsArc = iHolePosSign * AC_Hole_Position_Angle / 180 * PI * rBoard

			matTrim = gs_trim_in_mat

			material gs_trim_in_mat
			sect_fill gs_trim_fill_in, gs_trim_pen_bg_in, gs_trim_pen_fg_in, gs_trim_pen_cont_in

			if gs_IsCurved then
				thk = WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS
			else
				thk = WALL_THICKNESS

				addz -WIDO_FRAME_THICKNESS

				material matTrim

				cutplane
				del 1
				numCutsFrame = 1
			endif

			if wallIsLeft then
				mask = 14 + (gs_trim_offs_in > EPS | not(bShowJambExtension) | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS)
			else
				mask = 11 + 4 * (gs_trim_offs_in > EPS | not(bShowJambExtension) | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS)
			endif

			if gs_trim_width_in > EPS & thk > EPS & bShowJambExtension then

				! ===== Inside Trim - Curved Walls - Jamb Extensions =====

				addz -WOD
				bCondition = WIDO_REVEAL_SIDE exor SYMB_MIRRORED
				roty (not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) + not(wallIsLeft) * 180
				addz rBoard

				! --- Draw Left side Jamb Extension ---

				if	isWindow then
					py4 = -overSizeBottomIn + not(gs_stack_bottom | bDrawBoard) * (gs_trim_width_in + tolerOffsetLowerIn) * bParalellInCurvedWalls
					py3 = py4 + not(gs_stack_bottom | bDrawBoard) * gs_trim_width_in * not(bParalellInCurvedWalls)
					py3l = py3
					py4l = py4
					py3r = py3
					py4r = py4

					s3 = 8 + 2 * not(gs_stack_bottom)		! 15 or 8
					s4 = 13 + 2 * not(gs_stack_bottom)		! 15 or 13
				else
					if	bPShapedLeftOpening then
						py4l = -overSizeBottomIn + not(bDrawLeftSLBoard) * (gs_trim_width_in + tolerOffsetLowerIn) * bParalellInCurvedWalls \
								+ gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
						py3l = py4l + not(bDrawLeftSLBoard) * gs_trim_below_boardLeft * gs_trim_width_in * not(bParalellInCurvedWalls)
					else
						py4l = -overSizeBottomIn
						py3l = -overSizeBottomIn
					endif
					if	bPShapedRightOpening then
						py4r = -overSizeBottomIn + not(bDrawLRightSLBoard) * (gs_trim_width_in + tolerOffsetLowerIn) * bParalellInCurvedWalls \
								 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
						py3r = py4r + not(bDrawRightSLBoard) * gs_trim_below_boardRight * gs_trim_width_in * not(bParalellInCurvedWalls)
					else
						py4r = -overSizeBottomIn
						py3r = -overSizeBottomIn
					endif

					s3 = 15
					s4 = 15
				endif

				px1 = signWallIsLeft * (offsArc - rBoard * alfaLeftIn * DegRad) - leftWidth * bParalellInCurvedWalls
				px2 = px1 + signWallIsLeft * gs_trim_width_in + 2 * leftWidth * bParalellInCurvedWalls

				if	bShapeEnablesStraightTopTrim then
					py1 = B + overSizeTopIn - not(gs_stack_top) * gs_trim_width_in * bParalellInCurvedWalls - tolerOffsetUpperIn
					py2 = py1 - not(gs_stack_top) * gs_trim_width_in * not(bParalellInCurvedWalls)

					s1 = 8 + 2 * not(gs_stack_top)		! 15 or 8
					s2 = bitset (mask, 1, not(gs_stack_top))
				endif
				if	bShapeEnablesArchedTopTrim then
					ta = leftWidth
					tc = arcR + tolerOffsetUpper
					if tc > ta then
						py1 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))
					else
						py1 = B - arcR - tolerOffsetUpper
					endif

					ta = ta - gs_trim_width_in
					tc = tc - gs_trim_width_in
					if tc > ta then
						py2 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))
					else
						py2 = B - arcR - tolerOffsetUpper
					endif
					s1 = 8
					s2 = mask - 2
				endif
				if iWindowShape = SHAPE_ELLIPSEARCH then
					py1 = B - archHeight - tolerOffsetUpper
					py2 = B - archHeight - tolerOffsetUpper

					s1 = 8
					s2 = mask - 2
				endif

				if not(gs_stack_left | bLeftCornerFunction) & bShapeEnablesStraightLeftTrim then
					if bParalellInCurvedWalls then
						addz -rBoard
						roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

						cutpolya 4, 1, 0,
							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn,  -overSizeBottomIn,  0,
							-leftWidth * 3,  -overSizeBottomIn,  0,
							-leftWidth * 3, B + overSizeTopIn, 0,
							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn,  B + overSizeTopIn,  5

						cutpolya 4, 1, 0,
							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in,  -overSizeBottomIn,  7,
							rightWidth,  -overSizeBottomIn,  7,
							rightWidth, B + overSizeTopIn, 7,
							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in,  B + overSizeTopIn,  4! * not(bHalfCircle)
						del 2
					endif

					body -1
					bprism_ matTrim, matTrim, matTrim,
						4, signWallIsLeft * thk, rBoard,
						px1,	py1,	s1,
						px2,	py2,	s2,
						px2,	py3l,	s3,
						px1,	py4l,	s4
					gosub "TextCoord_Vert"

					if bParalellInCurvedWalls then
						cutend
						cutend
					endif
				endif

				! --- Draw Right side Jamb Extension ---

				px1 = signWallIsLeft * (offsArc + rBoard * alfaRightIn * DegRad) + rightWidth * bParalellInCurvedWalls
				px2 = px1 - signWallIsLeft * gs_trim_width_in - rightWidth * bParalellInCurvedWalls * 2

				if	bShapeEnablesStraightTopTrim then
					py1 = B + overSizeTopIn - not(gs_stack_top) * gs_trim_width_in * bParalellInCurvedWalls - tolerOffsetUpperIn
					py2 = py1 - not(gs_stack_top) * gs_trim_width_in * not(bParalellInCurvedWalls)

					s1 = 8 + 2 * not(gs_stack_top)		! 15 or 8
					s2 = bitset (mask, 1, not(gs_stack_top))
				endif
				if	bShapeEnablesArchedTopTrim then
					ta = rightWidth
					tc = arcR + tolerOffsetUpper
					if tc > ta then
						py1 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))
					else
						py1 = B - arcR - tolerOffsetUpper
					endif
					ta = ta - gs_trim_width_in
					tc = tc - gs_trim_width_in
					if tc > ta then
						py2 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))
					else
						py2 = B - arcR - tolerOffsetUpper
					endif
					s1 = 8
					s2 = mask - 2
				endif

				if not(gs_stack_right | bRightCornerFunction) & bShapeEnablesStraightRightTrim then
					if bParalellInCurvedWalls then
						addz -rBoard
						roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

						cutpolya 4, 1, 0,
							rightWidth - tolerOffsetRightIn + overSizeRightIn,  -overSizeBottomIn,  0,
							rightWidth * 3,  -overSizeBottomIn,  0,
							rightWidth * 3, B + overSizeTopIn, 0,
							rightWidth - tolerOffsetRightIn + overSizeRightIn,  B + overSizeTopIn,  5

						cutpolya 4, 1, 0,
							rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in,  -overSizeBottomIn,  7,
							-leftWidth,  -overSizeBottomIn,  7,
							-leftWidth, B + overSizeTopIn, 7,
							rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in,  B + overSizeTopIn,  4
						del 2
					endif

					body -1
					bprism_ matTrim, matTrim, matTrim,
						4, signWallIsLeft * thk, rBoard,
						px1,	py1,	s1,
						px2,	py2,	s2,
						px2,	py3r,	s3,
						px1,	py4r,	s4
					gosub "TextCoord_Vert"

					if bParalellInCurvedWalls then
						cutend
						cutend
					endif
				endif

				if	bTShapedOpening then

					del 3

					alphaLeft = abs(asn(leftRevealPnts[idxBoardEndRevealLeft][1]  / radBoard)) + 10
					alphaRight = abs(asn(rightRevealPnts[idxBoardEndRevealright][1] / radBoard)) + 10

					alfaEnd		= alphaRight
					alfaStart	= -alphaLeft
					arcRadius	= radBoard
					bMiddlePoints = 1
					firstStatus	= 31
					midStatus	= 10 + 5 * (gs_trim_offs_in > EPS) + 64 + 16
					lastStatus	= 31
					if abs(alfaStart - alfaEnd) > EPS then
						gosub 110

						rotx 90
						muly -1
						addz -overSizeBottomIn

						cutDepth = MAX(py3l, py3r)
						if wallIsLeft then
!								prism_ NSP/3 + 2,-cutDepth,
!									radBoard * sin(alphaRight), 2*WOD, 15,
!									-radBoard * sin(alphaLeft), 2*WOD, 15,
!									use(nsp)
							cutpolya NSP/3 + 2,1,0,
								radBoard * sin(alphaRight), 2*WOD, 15,
								-radBoard * sin(alphaLeft), 2*WOD, 15,
								get(nsp)
						else
!								prism_ NSP/3 + 2,-cutDepth,
!									 radBoard * sin(alphaRight) + 3, radBoard * cos(alphaRight) + WOD + 2, 15,
!									-radBoard * sin(alphaLeft) - 3,  radBoard * cos(alphaLeft)  + WOD + 2, 15,
!									use(nsp)
							cutpolya NSP/3 + 2,1,0,
								radBoard * sin(alphaRight) + 3, radBoard * cos(alphaRight) + WOD + 2, 31,
								-radBoard * sin(alphaLeft) - 3,  radBoard * cos(alphaLeft)  + WOD + 2, 31,
								get(nsp)
						endif
						del 3
					endif

					if	bPShapedLeftOpening & gs_trim_below_boardLeft then
						! --- Draw Door's Left side Jamb Extension ---

						px1lP = -leftWidth - overSizeLeftIn + gs_sidelight_WHole_width_left ! + tolerOffsetLeftIn
						px2lP = px1lP + gs_trim_width_in
						py1 = -overSizeBottomIn
						py2 = -overSizeBottomIn

						addz -thk - 1
						body -1
						sprism_ matTrim, matTrim, matTrim,
							4, 0,0, 0,1, thk - pocketThkLeft + 1, wallIncl,
							 px1lP,	py1,	s1,
							 px2lP,	py2,	mask,
							 px2lP,	py3l,	s3,
							 px1lP,	py4l,	s4
						gosub "TextCoord_Vert"
						del 1

						if	not(bDrawLeftSLBoard) then
							! --- Draw Left Sidelight lower side Jamb Extension ---

							if not(bParalellInCurvedWalls) then
								addz -WOD
								roty -alfaLeftIn * signWallIsLeft
								addz rBoard * signWallIsLeft
								addy py4l
								roty 90
								rotx 180 + 45 * not(gs_stack_left)

								!rect 1,1
								cutplane

								del 6
							endif

							addz -thk - 1

							px1l = -leftWidth - overSizeLeftIn - 1 * not(bParalellInCurvedWalls)
							px2l = px1l + gs_trim_width_in

							sprism_ matTrim, matTrim, matTrim,
								4, 0,0, 0,1, thk - pocketThkLeft + 1, wallIncl,
								px2lP,	py3l,	15,
								px1lP,	py4l,	15,
								px1l,	py4l,	15,
								px2l,	py3l,	mask
							gosub "TextCoord_Hor"

							del 1

							if not(bParalellInCurvedWalls) then cutend

						endif
					endif

					if	bPShapedRightOpening & gs_trim_below_boardRight then
						! --- Draw Door's Right side Jamb Extension ---

						px1rP = rightWidth + overSizeRightIn - gs_sidelight_WHole_width_right
						px2rP = px1rP - gs_trim_width_in
						py1 = -overSizeBottomIn
						py2 = -overSizeBottomIn

						addz -thk - 1

						body -1
						sprism_ matTrim, matTrim, matTrim,
							4, 0,0, 0,1, thk - pocketThkRight + 1, wallIncl,
							 px1rP,	py1,	s1,
							 px2rP,	py2,	mask,
							 px2rP,	py3r,	s3,
							 px1rP,	py4r,	s4
						gosub "TextCoord_Vert"
						del 1

						if	not(bDrawRightSLBoard) then
							! --- Draw Right Sidelight lower side Jamb Extension ---

							if not(bParalellInCurvedWalls) then
								addz -WOD
								roty alfaRightIn * signWallIsLeft
								addz rBoard * signWallIsLeft

								addy py4r
								roty 90
								rotx 360 - 45 * not(gs_stack_right)

								!rect 1,1
								cutplane

								del 6
							endif

							addz -thk - 1

							px1r = rightWidth + 1 * not(bParalellInCurvedWalls)
							px2r = px1r - gs_trim_width_in

							sprism_ matTrim, matTrim, matTrim,
								4, 0,0, 0,1, thk - pocketThkLeft + 1, wallIncl,
								px2rP,	py3r,	15,
								px1rP,	py4r,	15,
								px1r,	py4r,	15,
								px2r,	py3r,	mask
							gosub "TextCoord_Hor"

							del 1

							if not(bParalellInCurvedWalls) then cutend

						endif
					endif

					if abs(alfaStart - alfaEnd) > EPS then cutend

					addz -WOD
					roty (not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) + not(wallIsLeft) * 180
					addz rBoard
				endif

				if not(bParalellInCurvedWalls) then
					px1 = signWallIsLeft * (offsArc - rBoard * alfaLeftIn * DegRad)
					px2 = px1 + signWallIsLeft * not(gs_stack_left) * gs_trim_width_in
					px4 = signWallIsLeft * (offsArc + rBoard * alfaRightIn * DegRad)
					px3 = px4 - signWallIsLeft * not(gs_stack_right) * gs_trim_width_in
				else
					px1 = signWallIsLeft * (offsArc - rBoard * alfaLeftIn * DegRad - (leftWidth - tolerOffsetLeftIn) * not(gs_stack_left))
					px2 = px1
					px4 = signWallIsLeft * (offsArc + rBoard * alfaRightIn * DegRad + (rightWidth - tolerOffsetRightIn) * not(gs_stack_right))
					px3 = px4
				endif

				if not(gs_stack_bottom | bDrawBoard | not(isWindow)) & bShapeEnablesStraightBottomTrim then
					if bParalellInCurvedWalls then
						addz -rBoard
						roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

						if not(gs_stack_left) then
							cutpolya 4, 1, 0,
								-leftWidth + tolerOffsetLeftIn - overSizeLeftIn,  -overSizeBottomIn,  7,
								-leftWidth * 3,  -overSizeBottomIn,  7,
								-leftWidth * 3, B + overSizeTopIn, 7,
								-leftWidth + tolerOffsetLeftIn - overSizeLeftIn,  B + overSizeTopIn,  7
						endif

						if not(gs_stack_right) then
							cutpolya 4, 1, 0,
								rightWidth - tolerOffsetRightIn + overSizeRightIn,  -overSizeBottomIn,  7,
								rightWidth * 3,  -overSizeBottomIn,  7,
								rightWidth * 3, B + overSizeTopIn, 7,
								rightWidth - tolerOffsetRightIn + overSizeRightIn,  B + overSizeTopIn,  4
						endif
						del 2
					endif

					py1 = -overSizeBottomIn + tolerOffsetLowerIn
					py2 = py1 + gs_trim_width_in

					bprism_ matTrim, matTrim, matTrim,
						4, signWallIsLeft * thk, rBoard,
						px1,	py1, 	8 + 2 * not(gs_stack_left),		! 15 or 8
						px2,	py2,	bitset (mask, 1, not(gs_stack_left)),
						px3,	py2,	8 + 2 * not(gs_stack_right),		! 15 or 8
						px4,	py1,	13 + 2 * not(gs_stack_right)		! 15 or 13
					gosub "TextCoord_Hor"

					if bParalellInCurvedWalls then
						if not(gs_stack_left) then cutend
						if not(gs_stack_right) then cutend
					endif
				endif



				if bShapeEnablesStraightTopTrim & not(gs_stack_top) then

					if bParalellInCurvedWalls then
						addz -rBoard
						roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

						if not(gs_stack_left) then
							cutpolya 4, 1, 0,
								-leftWidth + tolerOffsetLeftIn - overSizeLeftIn,  -overSizeBottomIn,  7,
								-leftWidth * 3,  -overSizeBottomIn,  7,
								-leftWidth * 3, B + overSizeTopIn, 7,
								-leftWidth + tolerOffsetLeftIn - overSizeLeftIn,  B + overSizeTopIn,  7
						endif

						if not(gs_stack_right) then
							cutpolya 4, 1, 0,
								rightWidth - tolerOffsetRightIn + overSizeRightIn,  -overSizeBottomIn,  7,
								rightWidth * 3,  -overSizeBottomIn,  7,
								rightWidth * 3, B + overSizeTopIn, 7,
								rightWidth - tolerOffsetRightIn + overSizeRightIn,  B + overSizeTopIn,  4
						endif
						del 2
					endif

					py1 = B + overSizeTopIn - tolerOffsetUpperIn
					py2 = py1 - gs_trim_width_in

					bprism_ matTrim, matTrim, matTrim,
						4, signWallIsLeft * thk, rBoard,
						px1,	py1,	8 + 2 * not(gs_stack_left),		! 15 or 8
						px2,	py2,	bitset (mask, 1, not(gs_stack_left)),
						px3,	py2,	8 + 2 * not(gs_stack_right),		! 15 or 8
						px4,	py1,	13 + 2 * not(gs_stack_right)		! 15 or 13

					if bParalellInCurvedWalls then
						if not(gs_stack_left) then cutend
						if not(gs_stack_right) then cutend
					endif
				endif

				if	bShapeEnablesArchedTopTrim then

					resol WALL_RESOL

					px1 = signWallIsLeft * (offsArc - rBoard * alfaLeftIn * DegRad)
					px2 = px1 + signWallIsLeft * gs_trim_width_in
					px4 = signWallIsLeft * (offsArc + rBoard * alfaRightIn * DegRad)
					px3 = px4 - signWallIsLeft * gs_trim_width_in

					mulRatio = (leftWidth + rightWidth + overSizeLeftIn + overSizeRightIn - tolerOffsetLeft - tolerOffsetRight) / abs(px1 - px4)
					addy B - archHeight - tolerOffsetUpper
					muly mulRatio

					if bHalfCircle then
						if not(bParalellInCurvedWalls) then
							bprism_ matTrim, matTrim, matTrim,
								8, signWallIsLeft * thk, rBoard,
								px1,	0, 	   8 + 7 * gs_stack_left,		! 15 or 8
								px2,	0,	  62 + mask,
								0,		1,	 800,
								px3,	0,	1008 + 7 * gs_stack_right,		! 1015 or 1008
								px4,	-EPS,  8 + 7 * gs_stack_right,		! 15 or 8
								px4,	0,	  79,
								0,		1,	 800,
								px1,	0, 	1015
						else

							px1_grbody = signWallIsLeft * (offsArc - rBoard * PI/2)
							px4_grbody = signWallIsLeft * (offsArc + rBoard * PI/2)

							addz -rBoard
							roty -1*(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180
							addz WOD

							cutpolya 3, 1, 0,
								-leftWidth + tolerOffsetLeft + gs_trim_width_in,	0,	  62 + mask,
								0,		1,	 800,
								rightWidth - tolerOffsetRight - gs_trim_width_in,	0,	1008 + 7 * gs_stack_right

							cutpolya 7, 1, 0,
								rBoard + WALL_THICKNESS + 1, 0, 15,
								rBoard + WALL_THICKNESS + 1, rightWidth, 15,
								-rBoard - WALL_THICKNESS - 1, rightWidth, 15,
								-rBoard - WALL_THICKNESS - 1, 0, 15,
								-leftWidth + tolerOffsetLeft,	0,	  62 + mask,
								0,		1,	 800,
								rightWidth - tolerOffsetRight,	0,	1008 + 7 * gs_stack_right

							del 3

							bprism_ matTrim, matTrim, matTrim,
								4, signWallIsLeft * thk, rBoard,
								px1_grbody,0,8,
								px4_grbody, 0, 8,
								px4_grbody, rightWidth,8,
								px1_grbody, rightWidth,8

							cutend
							cutend

						endif
					else

						ta = (leftWidth + rightWidth) / 2
						tc = arcR
						py1 = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						ta = ta - gs_trim_width_in
						tc = tc - gs_trim_width_in
						py2 = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						bprism_ matTrim, matTrim, matTrim,
							6, signWallIsLeft * thk, rBoard,
							(px2 + px3) / 2,		(archHeight - arcR) / mulRatio, 900,
							px2,	py2, 	   8 + 7 * gs_stack_left,	! 15 or 8
							px1,	py1,	  79,
							px4,	py1,	3010 + 5 * gs_stack_right,	! 15 or 8
							px3,	py2,	  62 + mask,
							px2,	py2, 	3015
					endif

					del 2
				endif

				if iWindowShape = SHAPE_ELLIPSEARCH then

					px1 = offsArc - rBoard * alfaLeft * DegRad
					px4 = offsArc + rBoard * alfaRight * DegRad

					offs = (leftWidth + overSizeLeftIn - (rBoard * alfaLeft * DegRad))
					if wallIsLeft then
						s3 = 12 + 1 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS) - 2 * gs_stack_right
					else
						s3 = 9 + 4 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS) - 2 * gs_stack_right
					endif
					mulRatio = (archHeight / (archHeight + overSizeLeftIn - offs))

					addy B - tolerOffsetUpper + ((archHeight * mulRatio) - archHeight)
					muly mulRatio

					bprism_ matTrim, matTrim, matTrim,
						13, signWallIsLeft * thk, rBoard,
						signWallIsLeft * offsArc + leftWidth + overSizeLeftIn - tolerOffsetLeft - offs,						-archHeight,			13,
						signWallIsLeft * offsArc + leftWidth - smallRadiusEllips,											-archHeight,			913,
						0,		 																							 alphaSide,				4013,
						signWallIsLeft * offsArc - (leftWidth - rightWidth)/2,												-middleRadiusEllips, 	913,
						0,		 																							 alphaMiddle,			4013,
						signWallIsLeft * offsArc - rightWidth + smallRadiusEllips, 											-archHeight,			913,
						0,		 																							 alphaSide,				4008,
						signWallIsLeft * offsArc - rightWidth - overSizeLeftIn - tolerOffsetLeft + offs + gs_trim_width_in,	-archHeight,			s3,
						0,		 																							-alphaSide,				4000+s3,
						signWallIsLeft * offsArc - (leftWidth - rightWidth)/2,												-middleRadiusEllips, 	900+s3,
						0,		 																							-alphaMiddle,			4000+s3,
						signWallIsLeft * offsArc + leftWidth - smallRadiusEllips,											-archHeight,			900+s3,
						0,		 																							-alphaSide,				4000+s3

					del 2
				endif
				gosub "TextCoord_Hor"

				del 3
			endif

			if numCutsFrame then
				cutend
				numCutsFrame = 0
			endif

			if not(gs_stack_left) then
				alfaLeftParallelIn = abs (asn ( (leftRevealPnts[idxBoardEndRevealLeft][1] + gs_trim_width_in) / rBoard))
			else
				alfaLeftParallelIn = alfaLeft
			endif
			if not(gs_stack_right) then
				alfaRightParallelIn = abs (asn ( (rightRevealPnts[idxBoardEndRevealRight][1] - gs_trim_width_in) / rBoard))
			else
				alfaRightParallelIn = alfaRight
			endif

			if gs_trim_thk_in > EPS & gs_trim_show_cover_in then

				material gs_trim_in_mat
				sect_fill gs_trim_fill_in, gs_trim_pen_bg_in, gs_trim_pen_fg_in, gs_trim_pen_cont_in

				! ===== Inside Trim - Curved Walls - Casing =====

				if wallIsLeft then
					mask = 11 + 4 * (gs_trim_offs_in > EPS)
				else
					mask = 14 + (gs_trim_offs_in > EPS)
				endif

				maskTop		= 8 + 2 * not(gs_stack_top) * not(bParalellInCurvedWalls)
				maskBottom	= 8 + 2 * not(gs_stack_bottom)
				maskLeft	= 8 + (2 + 5 * bParalellInCurvedWalls) * not(gs_stack_left)
				maskRight	= 8 + 2 * not(gs_stack_right)

				maskLeft2	= bDrawBoard*(not(bTrimovbotleftin)*(15-7*gs_stack_left)+bTrimovbotleftin*(10-2*gs_stack_left))
				maskRight2	= bDrawBoard*(not(bTrimovbotrightin)*(15-7*gs_stack_right)+bTrimovbotrightin*(10-2*gs_stack_right))

				if	iWindowShape = SHAPE_RECTANGULAR | \
					bPShapedLeftOpening then

					if gs_stack_left then
						pxL = leftRevealPnts[idxBoardEndRevealLeft][1]
					else
						pxL = leftRevealPnts[idxBoardEndRevealLeft][1] + gs_trim_width_in + not(gs_stack_left) * (-gs_trim_offs_in + tolerOffsetLeftIn)
						alphaLeft = abs(asn(pxL / rBoard)) + ArcLengthBoardToAngle * gs_tw_left_in
						pxL = -rBoard * sin(alphaLeft)
						pyL = -sqr(rBoard^2 - pxL^2) - WOD
					endif
					if gs_stack_right then
						pxR = rightRevealPnts[idxBoardEndRevealright][1]
					else
						pxR = rightRevealPnts[idxBoardEndRevealright][1] - gs_trim_width_in - not(gs_stack_right) * (-gs_trim_offs_in + tolerOffsetRightIn)
						alphaRight = abs(asn(pxR / rBoard)) + ArcLengthBoardToAngle * gs_tw_right_in
						pxR = rBoard * sin(alphaRight)
						pyR = -sqr(rBoard^2 - pxR^2) - WOD
					endif
					if isWindow then
						pyB = -overSizeBottomIn - not(gs_stack_bottom) * (-tolerOffsetLowerIn - trinB + gs_trim_offs_in + gs_tw_bottom_in*not(bTrimovbotleftin)) - sjby
					else
						pyB = 0
					endif
					pyT = B + overSizeTopIn + not(gs_stack_top) * (- tolerOffsetUpperIn - trinT + gs_trim_offs_in + gs_tw_top_in*not(bTrimovtopleftin)) + sjty

					if bCutWall then
						pen WALL_VIEW_PEN
						material matWallIn

						alfaEnd		= alphaRight
						alfaStart	= -alphaLeft
						arcRadius	= radBoard
						bMiddlePoints = 1
						firstStatus	= 31
						midStatus	= 95
						lastStatus	= 31
						if abs(alfaStart - alfaEnd) > EPS then
							gosub 110

							rotx 90
							muly -1
							addz -pyB

							cutDepth = pyT - pyB
							if wallIsLeft then
!								prism_ NSP/3 + 1,-cutDepth,
!									0,WOD,15,
!									use(nsp)
								wallniche NSP/3 + 1,1,0,
									0,0,-cutDepth,cutDepth,
									0,WOD,31,
									get(nsp)
							else
!								prism_ NSP/3 + 2,-cutDepth,
!									 (rBoard + WALL_THICKNESS) * sin(alphaLeft),  (rBoard + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 15,
!									-(rBoard + WALL_THICKNESS) * sin(alphaRight), (rBoard + WALL_THICKNESS) * cos(alphaRight) + WOD, 15,
!									use(nsp)
								wallniche NSP/3 + 2,1,0,
									0,0,-cutDepth,cutDepth,
									 (rBoard + WALL_THICKNESS) * sin(alphaLeft),  (rBoard + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 31,
									-(rBoard + WALL_THICKNESS) * sin(alphaRight), (rBoard + WALL_THICKNESS) * cos(alphaRight) + WOD, 31,
								get(nsp)
							endif
							del 3
						endif

						pen gs_frame_pen
						material gs_trim_in_mat
					endif
				endif

				if bShapeEnablesStraightTopTrim & not(gs_stack_top) & gs_trimtype_in_int = CASING_NORMAL & (bTrimovtopleftin | bTrimovtoprightin) then
					if gs_stack_left then
						pxL = leftRevealPnts[idxBoardEndRevealLeft][1]
					else
						pxL = leftRevealPnts[idxBoardEndRevealLeft][1] + gs_trim_width_in + not(gs_stack_left) * (-gs_trim_offs_in + tolerOffsetLeftIn)
						alphaLeft = abs(asn(pxL / rBoard)) + ArcLengthBoardToAngle * (gs_tw_left_in + gs_trimov_top_left_in)
						pxL = -rBoard * sin(alphaLeft)
						pyL = -sqr(rBoard^2 - pxL^2) - WOD
					endif
					if gs_stack_right then
						pxR = rightRevealPnts[idxBoardEndRevealright][1]
					else
						pxR = rightRevealPnts[idxBoardEndRevealright][1] - gs_trim_width_in - not(gs_stack_right) * (-gs_trim_offs_in + tolerOffsetRightIn)
						alphaRight = abs(asn(pxR / rBoard)) + ArcLengthBoardToAngle * (gs_tw_right_in + gs_trimov_top_right_in)
						pxR = rBoard * sin(alphaRight)
						pyR = -sqr(rBoard^2 - pxR^2) - WOD
					endif
					pyB = B + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in - tolerOffsetUpperIn
					pyT = pyB + gs_tw_top_in

					if bCutWall then
						pen WALL_VIEW_PEN
						material matWallIn

						alfaEnd		= alphaRight
						alfaStart	= -alphaLeft
						arcRadius	= radBoard
						bMiddlePoints = 1
						firstStatus	= 31
						midStatus	= 95
						lastStatus	= 31
						if abs(alfaStart - alfaEnd) > EPS then
							gosub 110

							rotx 90
							muly -1
							addz -pyB

							cutDepth = pyT - pyB
							if wallIsLeft then
!								prism_ NSP/3 + 1,-cutDepth,
!									0,WOD,15,
!									use(nsp)
								wallniche NSP/3 + 1,1,0,
									0,0,-cutDepth,cutDepth,
									0,WOD,31,
									get(nsp)
							else
!								prism_ NSP/3 + 2,-cutDepth,
!									 (rBoard + WALL_THICKNESS) * sin(alphaLeft),  (rBoard + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 15,
!									-(rBoard + WALL_THICKNESS) * sin(alphaRight), (rBoard + WALL_THICKNESS) * cos(alphaRight) + WOD, 15,
!									use(nsp)
								wallniche NSP/3 + 2,1,0,
									0,0,-cutDepth,cutDepth,
									 (rBoard + WALL_THICKNESS) * sin(alphaLeft),  (rBoard + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 31,
									-(rBoard + WALL_THICKNESS) * sin(alphaRight), (rBoard + WALL_THICKNESS) * cos(alphaRight) + WOD, 31,
									get(nsp)
							endif
							del 3
						endif

						pen gs_frame_pen
						material gs_trim_in_mat
					endif
				endif


				pxL = leftRevealPnts[idxBoardEndRevealLeft][1] + gs_trim_width_in + not(gs_stack_left) * (-gs_trim_offs_in + tolerOffsetLeftIn)
				alphaLeft = abs(asn(pxL / rBoard)) + ArcLengthBoardToAngle * gs_tw_left_in
				pxL = -rBoard * sin(alphaLeft)
				pyL = -sqr(rBoard^2 - pxL^2) - WOD

				pxR = leftRevealPnts[idxBoardEndRevealLeft][1] + gs_trim_width_in + not(gs_stack_left) * (-gs_trim_offs_in + tolerOffsetLeftIn)
				alphaRight = abs(asn(pxR / rBoard))
				pxR = -rBoard * sin(alphaRight)
				pyR = -sqr(rBoard^2 - pxR^2) - WOD

				pyB = B + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in - tolerOffsetUpperIn
				if isWindow then
					pyB = -overSizeBottomIn + not(bDrawBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawBoard)\
						 - not(bDrawBoard) * gs_trim_offs_in * not(gs_trim_atframe_in) - gs_trimov_bot_left_in - gs_tw_bottom_in*(not(bDrawBoard) or (bDrawBoard and bTrimovbotleftin)) * not(gs_apron) - gs_apron_width * bTrimovbotleftin * gs_apron) - sjby
				else
					pyB = 0
				endif

				pyT = B + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in - tolerOffsetUpperIn + gs_tw_top_in

				if not(gs_stack_left | bLeftCornerFunction) & bShapeEnablesStraightLeftTrim & gs_trimtype_in_int = CASING_NORMAL & bTrimovtopleftin then
					if bCutWall then
						pen WALL_VIEW_PEN
						material matWallIn

						alfaEnd		= -alphaRight
						alfaStart	= -alphaLeft
						arcRadius	= radBoard
						bMiddlePoints = 1
						firstStatus	= 31
						midStatus	= 95
						lastStatus	= 31
						if abs(alfaStart - alfaEnd) > EPS then
							gosub 110

							rotx 90
							muly -1
							addz -pyB

							cutDepth = pyT - pyB
							if wallIsLeft then
!								prism_ NSP/3 + 1,-cutDepth,
!									0,WOD,15,
!									use(nsp)
								wallniche NSP/3 + 1,1,0,
									0,0,-cutDepth,cutDepth,
									0,WOD,31,
									get(nsp)
							else
!								prism_ NSP/3 + 2,-cutDepth,
!									-(rBoard + WALL_THICKNESS) * sin(alphaRight), (rBoard + WALL_THICKNESS) * cos(alphaRight) + WOD, 15,
!									-(rBoard + WALL_THICKNESS) * sin(alphaLeft),  (rBoard + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 15,
!									use(nsp)
								wallniche NSP/3 + 2,1,0,
									0,0,-cutDepth,cutDepth,
									-(rBoard + WALL_THICKNESS) * sin(alphaRight), (rBoard + WALL_THICKNESS) * cos(alphaRight) + WOD, 31,
									-(rBoard + WALL_THICKNESS) * sin(alphaLeft),  (rBoard + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 31,
									get(nsp)
							endif
							del 3
						endif

						pen gs_frame_pen
						material gs_trim_in_mat
					endif
				endif


				pxR = rightRevealPnts[idxBoardEndRevealRight][1] - gs_trim_width_in - not(gs_stack_right) * (-gs_trim_offs_in + tolerOffsetRightIn)
				alphaRight = abs(asn(pxR / rBoard)) + ArcLengthBoardToAngle * gs_tw_right_in
				pxR = -rBoard * sin(alphaRight)
				pyR = -sqr(rBoard^2 - pxR^2) - WOD

				pxL = rightRevealPnts[idxBoardEndRevealRight][1] - gs_trim_width_in - not(gs_stack_right) * (-gs_trim_offs_in + tolerOffsetRightIn)
				alphaLeft = abs(asn(pxL / rBoard))
				pxL = -rBoard * sin(alphaLeft)
				pyL = -sqr(rBoard^2 - pxL^2) - WOD

				pyB = B + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in - tolerOffsetUpperIn
				if isWindow then
					pyB = -overSizeBottomIn + not(bDrawBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawBoard)\
						 - not(bDrawBoard) * gs_trim_offs_in * not(gs_trim_atframe_in) - gs_trimov_bot_right_in - gs_tw_bottom_in*(not(bDrawBoard) or (bDrawBoard and bTrimovbotrightin)) * not(gs_apron) - gs_apron_width * bTrimovbotrightin * gs_apron) - sjby
				else
					pyB = 0
				endif

				pyT = B + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in - tolerOffsetUpperIn + gs_tw_top_in

				if not(gs_stack_right | bRightCornerFunction) & bShapeEnablesStraightRightTrim & gs_trimtype_in_int = CASING_NORMAL & bTrimovtoprightin then
					if bCutWall then
						pen WALL_VIEW_PEN
						material matWallIn

						alfaEnd		= alphaRight
						alfaStart	= alphaLeft
						arcRadius	= radBoard
						bMiddlePoints = 1
						firstStatus	= 31
						midStatus	= 95
						lastStatus	= 31
						if abs(alfaStart - alfaEnd) > EPS then
							gosub 110

							rotx 90
							muly -1
							addz -pyB

							cutDepth = pyT - pyB
							if wallIsLeft then
!								prism_ NSP/3 + 1,-cutDepth,
!									0,WOD,15,
!									use(nsp)
								wallniche NSP/3 + 1,1,0,
									0,0,-cutDepth,cutDepth,
									0,WOD,31,
									get(nsp)
							else
!								prism_ NSP/3 + 2,-cutDepth,
!									(rBoard + WALL_THICKNESS) * sin(alphaRight), (rBoard + WALL_THICKNESS) * cos(alphaRight) + WOD, 15,
!									(rBoard + WALL_THICKNESS) * sin(alphaLeft),  (rBoard + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 15,
!									use(nsp)
								wallniche NSP/3 + 2,1,0,
									0,0,-cutDepth,cutDepth,
									(rBoard + WALL_THICKNESS) * sin(alphaRight), (rBoard + WALL_THICKNESS) * cos(alphaRight) + WOD, 31,
									(rBoard + WALL_THICKNESS) * sin(alphaLeft),  (rBoard + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 31,
									get(nsp)
							endif
							del 3
						endif

						pen gs_frame_pen
						material gs_trim_in_mat
					endif
				endif

				addz -WOD
				bCondition = WIDO_REVEAL_SIDE exor SYMB_MIRRORED
				roty (not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) + not(wallIsLeft) * 180
				addz rBoard


				! ===== Inside Trim - Curved Walls - Casing - Top and Bottom Sides =====

				if not(gs_stack_bottom | not(isWindow)) & bShapeEnablesStraightBottomTrim & abs(gs_tw_bottom_in) > EPS then
					if not(bParalellInCurvedWalls) then
						px1 = signWallIsLeft * (offsArc - rBoard * alfaLeftIn * DegRad + not(gs_stack_left) * (gs_trim_width_in - gs_trim_offs_in - gs_tw_left_in*not(bTrimovbotleftin)))

						px2 = px1
						px3 = signWallIsLeft * (offsArc - rBoard * alfaLeftIn * DegRad + not(gs_stack_left) * (gs_trim_width_in - gs_trim_offs_in))
						px4 = signWallIsLeft * (offsArc + rBoard * alfaRightIn * DegRad + not(gs_stack_right) * (-gs_trim_width_in + gs_trim_offs_in))
						px5 = signWallIsLeft * (offsArc + rBoard * alfaRightIn * DegRad + not(gs_stack_right) * (-gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in*not(bTrimovbotrightin)))
						px6 = px5

						py1 = -overSizeBottomIn + not(gs_stack_bottom) * (gs_trim_width_in*not(bDrawBoard) - gs_trim_offs_in - gs_tw_bottom_in)
						py2 = py1 + gs_tw_bottom_in*bDrawBoard
						py3 = -overSizeBottomIn + not(gs_stack_bottom) * (gs_trim_width_in*not(bDrawBoard) - gs_trim_offs_in)
						py4 = py3
						py5 = py2
						py6 = py1

						s1 = maskLeft*not(bDrawBoard)+maskLeft2*bDrawBoard
						s2 = maskLeft
						s3 = bitset (mask, 1, not(gs_stack_left))
						s4 = maskRight
						s5 = maskRight*not(bDrawBoard)+maskRight2*bDrawBoard
						s6 = 13 + 2 * not(gs_stack_right)
					else
						px1 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad + not(gs_stack_left) * (gs_trim_width_in*0 - gs_trim_offs_in - gs_tw_left_in + tolerOffsetLeftIn))
						px2 = px1
						px3 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad + not(gs_stack_left) * (gs_trim_width_in*0 - gs_trim_offs_in - gs_tw_left_in + tolerOffsetLeftIn))
						px4 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + not(gs_stack_right) * (-gs_trim_width_in*0 + gs_trim_offs_in + gs_tw_right_in - tolerOffsetRightIn))
						px5 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + not(gs_stack_right) * (-gs_trim_width_in*0 + gs_trim_offs_in + gs_tw_right_in - tolerOffsetRightIn))
						px6 = px5

						py1 = -overSizeBottomIn + not(gs_stack_bottom) * ((gs_trim_width_in + tolerOffsetLowerIn)*not(bDrawBoard) - gs_trim_offs_in - gs_tw_bottom_in)
						py2 = py1 + gs_tw_bottom_in * bDrawBoard
						py3 = -overSizeBottomIn + not(gs_stack_bottom) * ((gs_trim_width_in + tolerOffsetLowerIn)*not(bDrawBoard) - gs_trim_offs_in) + EPS
						py4 = py3 + EPS
						py5 = py2
						py6 = py1

						s1 = maskLeft * not(bDrawBoard) + maskLeft2 * bDrawBoard
						s2 = maskLeft
						s3 = bitset (mask, 1, not(gs_stack_left))
						s4 = 13	+ 2 * bDrawBoard
						s5 = maskRight * not(bDrawBoard) + maskRight2 * bDrawBoard
						s6 = 13 + 2 * not(gs_stack_right)
					endif

					if not(gs_apron) & not(bDrawBoard) then
						if bParalellInCurvedWalls then
							addz -rBoard
							roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

							cutpolya 4, 1, 0,
								-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in + gs_trim_offs_in,  py3 - EPS - gs_tw_bottom_in * bTrimovbotleftin,  0,
								-leftWidth * 3,  py3 - EPS - gs_tw_bottom_in * bTrimovbotleftin,  7,
								-leftWidth * 3, B + overSizeTopIn, 7,
								-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in + gs_trim_offs_in,  B + overSizeTopIn,  1 * not(bTrimovbotleftin)

							cutpolya 4, 1, 0,
								-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in - gs_trim_offs_in,  py3 - EPS,  3,
								rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in - gs_trim_offs_in,  py3 - EPS,  7,
								rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in - gs_trim_offs_in, B + overSizeTopIn, 7,
								-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in - gs_trim_offs_in,  B + overSizeTopIn,  1

							cutpolya 4, 1, 0,
								rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in - gs_trim_offs_in,  py3 - EPS - gs_tw_bottom_in * bTrimovbotrightin,  0,
								rightWidth * 3,  py3 - EPS - gs_tw_bottom_in * bTrimovbotrightin,  7,
								rightWidth * 3, B + overSizeTopIn, 7,
								rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in - gs_trim_offs_in,  B + overSizeTopIn,  1 * not(bTrimovbotrightin)

							del 2
						endif

						bprism_ bBottomtriminmat, bBottomtriminmat, bBottomtriminmat,
							4+2, -signWallIsLeft * bBottomtriminthk, rBoard,
							px1,	py1, 	s1,
							px2,	py2, 	s2,
							px3,	py3,	s3,
							px4,	py4,	s4,
							px5,	py5, 	s5,
							px6,	py6, 	s6
						gosub "TextCoord_Hor"

						if bParalellInCurvedWalls then
							cutend
							cutend
							cutend
						endif
						material gs_trim_in_mat
					endif
				endif

				if bShapeEnablesStraightTopTrim & not(gs_stack_top) then

					if not(bParalellInCurvedWalls) then
						px1 = signWallIsLeft * (offsArc - rBoard * alfaLeftIn * DegRad + not(gs_stack_left) * (gs_trim_width_in - gs_trim_offs_in - gs_tw_left_in - gs_trimov_top_left_in * bTrimovtopleftin))
						px2 = signWallIsLeft * (offsArc - rBoard * alfaLeftIn * DegRad + not(gs_stack_left) * (gs_trim_width_in - gs_trim_offs_in - (gs_tw_left_in + gs_trimov_top_left_in) * bTrimovtopleftin))
						px3 = signWallIsLeft * (offsArc - rBoard * alfaLeftIn * DegRad + not(gs_stack_left) * (gs_trim_width_in - gs_trim_offs_in - gs_tw_left_in * bTrimovtopleftin))
						px4 = signWallIsLeft * (offsArc - rBoard * alfaLeftIn * DegRad + not(gs_stack_left) * (gs_trim_width_in - gs_trim_offs_in))
						px5 = signWallIsLeft * (offsArc + rBoard * alfaRightIn * DegRad + not(gs_stack_right) * (-gs_trim_width_in + gs_trim_offs_in))
						px6 = signWallIsLeft * (offsArc + rBoard * alfaRightIn * DegRad + not(gs_stack_right) * (-gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in * bTrimovtoprightin))
						px7 = signWallIsLeft * (offsArc + rBoard * alfaRightIn * DegRad + not(gs_stack_right) * (-gs_trim_width_in + gs_trim_offs_in + (gs_tw_right_in + gs_trimov_top_right_in) * bTrimovtoprightin))
						px8 = signWallIsLeft * (offsArc + rBoard * alfaRightIn * DegRad + not(gs_stack_right) * (-gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in + gs_trimov_top_right_in * bTrimovtoprightin))

						py2 = B + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in
						py1 = py2 + gs_tw_top_in
						py3 = py2
						py4 = py2
						py5 = py2
						py6 = py2
						py7 = py2
						py8 = py1

						s1 = 8 + 7 * not(gs_stack_left) * bTrimovtopleftin
						s2 = 15
						s3 = maskLeft
						s4 = bitset (mask, 1, not(gs_stack_left))
						s5 = maskRight
						s6 = 15
						s7 = 8 + 7 * not(gs_stack_right) * bTrimovtoprightin
						s8 = 13 + 2 * not(gs_stack_right)
					else
						px1 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad + not(gs_stack_left) * (- gs_trim_offs_in - gs_tw_left_in - gs_trimov_top_left_in * bTrimovtopleftin + tolerOffsetLeftIn))
						px2 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad + not(gs_stack_left) * (- gs_trim_offs_in - gs_tw_left_in - gs_trimov_top_left_in * bTrimovtopleftin + tolerOffsetLeftIn))
						px3 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad + not(gs_stack_left) * (- gs_trim_offs_in - gs_tw_left_in + tolerOffsetLeftIn))
						px4 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad + not(gs_stack_left) * (- gs_trim_offs_in - gs_tw_left_in + tolerOffsetLeftIn))

						px5 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + not(gs_stack_right) * (gs_trim_offs_in + gs_tw_right_in - tolerOffsetRightIn))
						px6 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + not(gs_stack_right) * (gs_trim_offs_in + gs_tw_right_in - tolerOffsetRightIn))
						px7 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + not(gs_stack_right) * (gs_trim_offs_in + gs_tw_right_in + gs_trimov_top_right_in * bTrimovtoprightin - tolerOffsetRightIn))
						px8 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + not(gs_stack_right) * (gs_trim_offs_in + gs_tw_right_in + gs_trimov_top_right_in * bTrimovtoprightin - tolerOffsetRightIn))

						py2 = B + overSizeTopIn - gs_trim_width_in + gs_trim_offs_in - EPS - tolerOffsetUpperIn
						py1 = py2 + gs_tw_top_in + EPS
						py3 = py2
						py4 = py2
						py5 = py2
						py6 = py2 + EPS
						py7 = py2 + EPS
						py8 = py1

						s1 = 8 + 7 * not(gs_stack_left)
						s2 = 15
						s3 = maskLeft
						s4 = 10	!bitset (mask, 1, not(gs_stack_left))
						s5 = maskRight
						s6 = 15
						s7 = 8 + 7 * not(gs_stack_right)
						s8 = 13 + 2 * not(gs_stack_right)
					endif

					if bParalellInCurvedWalls then
						add 0, 0, -rBoard
						roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

!						cutpolya 4, 1, 0,
!							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in + gs_trim_offs_in,  py3 - EPS - gs_tw_bottom_in * bTrimovbotleftin,  0,
!							-leftWidth * 3,  py3 - EPS - gs_tw_bottom_in * bTrimovbotleftin,  7,
!							-leftWidth * 3, py2 + EPS, 2,
!							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in + gs_trim_offs_in,  py2 + EPS,  1 * not(bTrimovbotleftin)

						cutpolya 4, 1, 0,
							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in - gs_trim_offs_in,  0,  3,
							rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in - gs_trim_offs_in,  0,  7,
							rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in - gs_trim_offs_in, py2 + EPS, 1 + 2 * not(gs_stack_right),
							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in - gs_trim_offs_in,  py2 + EPS,  2 * not(gs_stack_left)

						cutpolya 4, 1, 0,
							rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in - gs_trim_offs_in,  py3 - EPS - gs_tw_bottom_in * bTrimovbotrightin,  0,
							rightWidth * 3,  py3 - EPS - gs_tw_bottom_in * bTrimovbotrightin,  7,
							rightWidth * 3, py2 + EPS, 2,
							rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in - gs_trim_offs_in,  py2 + EPS,  1 * not(bTrimovbotrightin)
						del 2
					endif

					if gs_trimtype_in_int = CASING_NORMAL then				! Rectangular casing type
						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							8, -signWallIsLeft * gs_trim_thk_in, rBoard,
								px1, py1, s1,
								px2, py2, s2,
								px3, py3, s3,
								px4, py4, s4,
								px5, py5, s5,
								px6, py6, s6,
								px7, py7, s7,
								px8, py8, s8
					endif

					if gs_trimtype_in_int = CASING_OVERHANG then				! SWE traditional casing type
						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							10, -signWallIsLeft * gs_trim_thk_in, rBoard,
								px1, py1, s1,
								px1, py1-0.04, s1,
								px3 + (px1 - px3)/2, py2, s2,
								px3, py3, s3,
								px4, py4, s4,
								px5, py5, s5,
								px6, py6, s6,
								px6 + (px8 - px6)/2, py7, s7,
								px8, py8-0.04, s7,
								px8, py8, s8
					endif

					if bParalellInCurvedWalls then
!						cutend
						cutend
						cutend
					endif
				endif

				if	bShapeEnablesArchedTopTrim then

					resol WALL_RESOL


					px1 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad - gs_trim_offs_in - gs_tw_left_in + tolerOffsetLeftIn)
					px2 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad - gs_trim_offs_in + tolerOffsetLeftIn)

					px3 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + gs_trim_offs_in - tolerOffsetRightIn)
					px4 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + gs_tw_right_in + gs_trim_offs_in - tolerOffsetRightIn)



					mulRatio = (leftWidth + rightWidth - tolerOffsetLeft - tolerOffsetRight) / (2 * abs(signWallIsLeft * rBoard * alfaLeft * DegRad))
					addy B - archHeight - tolerOffsetUpper
					muly mulRatio

					if bHalfCircle then
						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							9, -signWallIsLeft * gs_trim_thk_in, rBoard,
							px1,	-EPS, 	   8 + 7 * gs_stack_left,		! 15 or 8
							px1,	0, 	   8 + 7 * gs_stack_left,		! 15 or 8
							px2,	0,	  62 + mask,
							0,		1,	 800,
							px3,	0,	1008 + 7 * gs_stack_right,		! 1015 or 1008
							px4,	-EPS,  8 + 7 * gs_stack_right,		! 15 or 8
							px4,	0,	  79,
							0,		1,	 800,
							px1,	0, 	1079
					else

						ta = (leftWidth + rightWidth) / 2 - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
						tc = arcR - gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in
						py1 = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						ta = ta - gs_tw_right_in
						tc = tc - gs_tw_right_in
						py2 = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							6, -signWallIsLeft * gs_trim_thk_in, rBoard,
							(px2 + px3) / 2,		(archHeight - arcR) / mulRatio, 900,
							px2,	py2, 	   8 + 7 * gs_stack_left,	! 15 or 8
							px1,	py1,	  79,
							px4,	py1,	3010 + 5 * gs_stack_right,	! 15 or 8
							px3,	py2,	  62 + mask,
							px2,	py2, 	3015
					endif

					del 2
				endif

				if iWindowShape = SHAPE_ELLIPSEARCH then

					px1 = offsArc - rBoard * alfaLeftParallelIn * DegRad - gs_trim_offs_in - gs_tw_left_in + tolerOffsetLeftIn
					px4 = offsArc + rBoard * alfaRightParallelIn * DegRad + gs_tw_right_in + gs_trim_offs_in - tolerOffsetRightIn

					s3 = 9 + 4 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS) - 2 * gs_stack_right

					offs = (leftWidth + overSizeLeftIn - (rBoard * alfaLeft * DegRad))
					if wallIsLeft then
						s3 = 9 + 4 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS) - 2 * gs_stack_right
					else
						s3 = 12 + 1 * (abs(gs_trim_offs_in) > EPS | not(gs_trim_show_cover_in) | abs(gs_trim_thk_in) < EPS) - 2 * gs_stack_right
					endif
					mulRatio = (archHeight / (archHeight + overSizeLeftIn - offs))

					addy B - tolerOffsetUpper + ((archHeight * mulRatio) - archHeight)
					muly mulRatio
					offs = (leftWidth + overSizeLeftIn - (rBoard * alfaLeft * DegRad + gs_trim_offs_in - gs_trim_width_in))

					bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
						13, -signWallIsLeft * gs_trim_thk_in, rBoard,
						signWallIsLeft * offsArc + leftWidth + overSizeLeftIn - offs - tolerOffsetLeft,					-archHeight,			s3,
						signWallIsLeft * offsArc + leftWidth - smallRadiusEllips,										-archHeight,			900+s3,
						0,		 																						 alphaSide,				4000+s3,
						signWallIsLeft * offsArc - (leftWidth - rightWidth)/2,											-middleRadiusEllips, 	900+s3,
						0,		 																						 alphaMiddle,			4000+s3,
						signWallIsLeft * offsArc - rightWidth + smallRadiusEllips, 										-archHeight,			900+s3,
						0,		 																						 alphaSide,				4008,
						signWallIsLeft * offsArc - rightWidth - overSizeLeftIn + tolerOffsetRight + offs - gs_tw_left_in,-archHeight,			79,
						0,		 																						-alphaSide,				4079,
						signWallIsLeft * offsArc - (leftWidth - rightWidth)/2,											-middleRadiusEllips, 	979,
						0,		 																						-alphaMiddle,			4079,
						signWallIsLeft * offsArc + leftWidth - smallRadiusEllips,										-archHeight,			979,
						0,		 																						-alphaSide,				4008

					del 2

				endif
				gosub "TextCoord_Hor"


				! ===== Inside Trim - Curved Walls - Casing - Sides =====


				if not(bParalellInCurvedWalls) then
					px2 = signWallIsLeft * (offsArc - rBoard * alfaLeftIn * DegRad + gs_trim_width_in - gs_trim_offs_in)
					px1 = px2 - signWallIsLeft * gs_tw_left_in
				else
					px2 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad + gs_trim_width_in - gs_trim_offs_in + tolerOffsetLeftIn)
					px1 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad - gs_trim_offs_in - gs_tw_left_in + tolerOffsetLeftIn)
				endif
				if gs_stack_left then
					px1LUp = px2 - gs_trim_width_in + gs_trim_offs_in
					px2LUp = px1LUp
				else
					px1LUp = px1 * not(bTrimovbotleftin) + px2 * bTrimovbotleftin
					px2LUp = px2
				endif


				py3 = 0
				py4 = 0
				if	isWindow  | \
					bTShapedOpening then

					s3 = maskBottom						! 15 or 10 or 8
					if not(bParalellInCurvedWalls) then
						s4 = 13 + 2 * (not(gs_stack_bottom)) 	! 15 or 13
					else
						s4 = 13 + 2 * (not(gs_stack_bottom)) * bDrawLeftSLBoard
					endif
				else
					s3 = 15
					s4 = 15
				endif


				if	isWindow | \
					(bPShapedLeftOpening & gs_trim_below_boardLeft) then
					py3l = -overSizeBottomIn + not(bDrawLeftSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawLeftSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawLeftSLBoard)\
					  - gs_trimov_bot_left_in - gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) - gs_apron_width * bTrimovbotleftin * gs_apron) - sjby
					py4l = -overSizeBottomIn + not(bDrawLeftSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawLeftSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawLeftSLBoard)\
					 - gs_trimov_bot_left_in - gs_tw_bottom_in * (not(bDrawLeftSLBoard) | (bDrawLeftSLBoard & (bTrimovbotleftin | gs_trim_below_boardLeft))) * not(gs_apron) - gs_apron_width * bTrimovbotleftin * gs_apron) - sjby

					s3 = maskBottom						! 15 or 10 or 8
					s4 = 13 + 2 * not(gs_stack_bottom)	! 15 or 13
				else
					py3l = 0
					py4l = 0

					s3 = 15-7*gs_stack_bottom
					s4 = 15
				endif

				py5 = py3l + not(gs_stack_bottom) * bTrimovbotleftin * (gs_trimov_bot_left_in + gs_tw_bottom_in * not(gs_apron) + gs_apron_width * gs_apron) + gs_stack_bottom * gs_trim_stack_bottom * gs_tw_bottom_in / 2
				py6 = py3l + not(gs_stack_bottom) * bTrimovbotleftin * gs_trimov_bot_left_in

				if iWindowShape = SHAPE_ARCHED then py22 = py5

				if	bPShapedLeftOpening then
					py3l = py3l + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
					py4l = py4l + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
					py5 = py5 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
					py6 = py6 + gs_sidelight_parapet_hgt_left + gs_reveal_double_innerBottom_sL + overSizeBottomIn
				endif


				if	bShapeEnablesStraightTopTrim then
					py2 = B + overSizeTopIn + not(gs_stack_top) * (-gs_trim_width_in + gs_trim_offs_in - tolerOffsetUpperIn)
					if not(bParalellInCurvedWalls) then
						py1 = B + overSizeTopIn + not(gs_stack_top) * (-gs_trim_width_in + gs_trim_offs_in + gs_tw_top_in*not(bTrimovtoprightin))
					else
						py1 = py2
					endif

					s1 = maskTop
					s2 = bitset (mask, 1, not(gs_stack_top))
					s5 = 8
				endif
				if	bShapeEnablesArchedTopTrim then
					ta = leftWidth - gs_trim_width_in
					tc = arcR + tolerOffsetUpper - gs_trim_width_in
					if tc > ta then
						py = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))
					else
						py = B - arcR - tolerOffsetUpper
					endif

					ta = ta + gs_trim_offs_in
					tc = tc + gs_trim_offs_in
					if tc > ta then
						py2 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))
					else
						py2 = B - arcR - tolerOffsetUpper
					endif


					ta = ta + gs_tw_right_in
					tc = tc + gs_tw_right_in
					if tc > ta then
						py1 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))
					else
						py1 = B - arcR - tolerOffsetUpper
					endif


					py1 = py1 - (py1 - py) * (1 - mulRatio)		! Correct y coords with mulRatio
					py2 = py2 - (py2 - py) * (1 - mulRatio)

					s1 = 8
					s2 = mask - 2
					s5 = 8
				endif
				if iWindowShape = SHAPE_ELLIPSEARCH then
					py1 = B - archHeight - tolerOffsetUpper
					py2 = B - archHeight - tolerOffsetUpper

					s1 = 8
					s2 = mask - 2
				endif

				if not(gs_stack_left | bLeftCornerFunction) & bShapeEnablesStraightLeftTrim then
					if bParalellInCurvedWalls then
						add 0, 0, -rBoard
						roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

						cutpolya 6, 1, 0,
							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in - gs_trim_offs_in,  py5,  2,
							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in - gs_trim_offs_in,  py6,  7 - 2 * ( not(gs_apron) & bDrawLeftSLBoard),
							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in - gs_trim_offs_in,  -overSizeBottomIn - (gs_trimov_bot_left_in + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) + gs_apron_width * bTrimovbotleftin * gs_apron),  7,
							rightWidth - tolerOffsetRightIn + overSizeRightIn, -overSizeBottomIn - (gs_trimov_bot_left_in + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) + gs_apron_width * bTrimovbotleftin * gs_apron),  7,
							rightWidth - tolerOffsetRightIn + overSizeRightIn, B + overSizeTopIn, 1,
							-leftWidth + tolerOffsetLeftIn - overSizeLeftIn + gs_trim_width_in - gs_trim_offs_in,  B + overSizeTopIn,  1
						del 2
					endif

					body -1
					if (gs_apron & abs(gs_trim_thk_in - gs_apron_thk) < EPS) | (not(gs_apron) & (not(bDrawLeftSLBoard) | gs_trim_below_boardLeft)) then
						if bTrimovbotleftin then
							s6 = 15 - 7*gs_stack_bottom
						else
							if gs_tw_bottom_in then
								s6 = s3
							else
								s6 = bitset(s3, 0)
								s6 = bitset(s6, 2)
							endif
						endif
						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							4, -signWallIsLeft * gs_trim_thk_in, rBoard,
							px1,	py1,	s1,
							px2,	py2,	s2,
!							px2,	py5,	s5,
!							px2,	py6,	s3*not(bTrimovbotleftin)+bTrimovbotleftin*15,
							px2,	py3l,	s6,
							px1,	py4l,	s4
					else
						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							4+1, -signWallIsLeft * gs_trim_thk_in, rBoard,
							px1,	py1,	s1,
							px2,	py2,	s2,
							px2,	py3l+gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) + gs_apron_width * bTrimovbotleftin * gs_apron + gs_trimov_bot_left_in,	15-6*gs_stack_bottom,
							px2,	py3l+gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) + gs_apron_width * bTrimovbotleftin * gs_apron,	15-7*gs_stack_bottom,
							px1,	py3l+gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) + gs_apron_width * bTrimovbotleftin * gs_apron,	s4

					endif
					gosub "TextCoord_Vert"

					if bParalellInCurvedWalls then
						cutend
					endif
				endif


				if not(bParalellInCurvedWalls) then
					px2 = signWallIsLeft * (offsArc + rBoard * alfaRightIn * DegRad - gs_trim_width_in + gs_trim_offs_in)
					px1 = px2 + signWallIsLeft * gs_tw_right_in
				else
					px2 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + gs_trim_offs_in - gs_trim_width_in - tolerOffsetRightIn)
					px1 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + gs_trim_offs_in + gs_tw_right_in - tolerOffsetRightIn)
				endif
				if gs_stack_right then
					px1RUp = px2 + gs_trim_width_in - gs_trim_offs_in
					px2RUp = px1RUp
				else
					px1RUp = px1 * not(bTrimovbotrightin) + px2 * bTrimovbotrightin
					px2RUp = px2
				endif

				if	isWindow | \
					(bPShapedRightOpening & gs_trim_below_boardRight) then
					py3r = -overSizeBottomIn + not(bDrawRightSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawRightSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawRightSLBoard)\
					 - gs_trimov_bot_right_in - gs_tw_bottom_in * bTrimovbotrightin * not(gs_apron) - gs_apron_width*bTrimovbotrightin * gs_apron) - sjBy
					py4r = -overSizeBottomIn + not(bDrawRightSLBoard) * tolerOffsetLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawRightSLBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * not(bDrawRightSLBoard)\
					 - gs_trimov_bot_right_in - gs_tw_bottom_in * (not(bDrawRightSLBoard) | (bDrawRightSLBoard & (bTrimovbotrightin | gs_trim_below_boardRight))) * not(gs_apron) - gs_apron_width * bTrimovbotleftin * gs_apron) - sjBy

					s3 = maskBottom						! 15 or 10 or 8
					s4 = 13 + 2 * not(gs_stack_bottom)	! 15 or 13
				else
					py3r = 0
					py4r = 0

					s3 = 15-7*gs_stack_bottom
					s4 = 15
				endif

				py5 = py3r + not(gs_stack_bottom) * bTrimovbotrightin * (gs_trimov_bot_right_in + gs_tw_bottom_in * not(gs_apron) + gs_apron_width * gs_apron) + gs_stack_bottom * gs_trim_stack_bottom * gs_tw_bottom_in / 2
				py6 = py3r + not(gs_stack_bottom) * bTrimovbotrightin  * gs_trimov_bot_right_in

				if iWindowShape = SHAPE_ARCHED then py22 = py5

				if	bPShapedRightOpening then
					py3r = py3r + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
					py4r = py4r + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
					py5 = py5 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
					py6 = py6 + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR + overSizeBottomIn
				endif



				if	bShapeEnablesStraightTopTrim then
					py2 = B + overSizeTopIn + not(gs_stack_top) * (-gs_trim_width_in + gs_trim_offs_in - tolerOffsetUpperIn)
					if not(bParalellInCurvedWalls) then
						py1 = B + overSizeTopIn + not(gs_stack_top) * (-gs_trim_width_in + gs_trim_offs_in + gs_tw_top_in*not(bTrimovtoprightin))
					else
						py1 = py2
					endif

					s1 = maskTop
					s2 = bitset (mask, 1, not(gs_stack_top))
					s5 = 8
				endif
				if	bShapeEnablesArchedTopTrim then
					ta = rightWidth - gs_trim_width_in
					tc = arcR + tolerOffsetUpper - gs_trim_width_in
					if tc > ta then
						py = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))
					else
						py = B - arcR - tolerOffsetUpper
					endif

					ta = ta + gs_trim_offs_in
					tc = tc + gs_trim_offs_in
					if tc > ta then
						py2 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))
					else
						py2 = B - arcR - tolerOffsetUpper
					endif

					ta = ta + gs_tw_right_in
					tc = tc + gs_tw_right_in
					if tc > ta then
						py1 = B - arcR - tolerOffsetUpper + sqr(max(0, (tc * tc - ta * ta)))
					else
						py1 = B - arcR - tolerOffsetUpper
					endif

					py1 = py1 - (py1 - py) * (1 - mulRatio)		! Correct y coords with mulRatio
					py2 = py2 - (py2 - py) * (1 - mulRatio)

					s1 = 8
					s2 = mask - 2
					s5 = 8
				endif

				if not(gs_stack_right | bRightCornerFunction) & bShapeEnablesStraightRightTrim then
					if bParalellInCurvedWalls then
						add 0, 0, -rBoard
						roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

						cutpolya 6, 1, 0,
							rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in + gs_trim_offs_in,  py5,  2,
							rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in + gs_trim_offs_in,  py6,  7 - 2 * ( not(gs_apron) & bDrawRightSLBoard),
							rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in + gs_trim_offs_in,  -overSizeBottomIn - (gs_trimov_bot_right_in + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) + gs_apron_width * bTrimovbotleftin * gs_apron),  7,
							-leftWidth + tolerOffsetLeftIn, -overSizeBottomIn - (gs_trimov_bot_right_in + gs_tw_bottom_in * bTrimovbotleftin * not(gs_apron) + gs_apron_width * bTrimovbotleftin * gs_apron),  7,
							-leftWidth + tolerOffsetLeftIn, B + overSizeTopIn, 1,
							rightWidth - tolerOffsetRightIn + overSizeRightIn - gs_trim_width_in + gs_trim_offs_in,  B + overSizeTopIn,  1
						del 2
					endif

					body -1
					if (gs_apron & abs(gs_trim_thk_in - gs_apron_thk) < EPS) | (not(gs_apron) & (not(bDrawRightSLBoard) | gs_trim_below_boardRight)) then
						if bTrimovbotrightin then
							s6 = 15 - 7*gs_stack_bottom
						else
							if gs_tw_bottom_in then
								s6 = s3
							else
								s6 = bitset(s3, 0)
								s6 = bitset(s6, 2)
							endif
						endif
						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							4, -signWallIsLeft * gs_trim_thk_in, rBoard,
							px1,	py1,	s1,
							px2,	py2,	s2,
!							px2,	py5,	s5,
!							px2,	py6,	s3*not(bTrimovbotrightin)+bTrimovbotrightin*15,
							px2,	py3r,	s6,
							px1,	py4r,	s4
					else
						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							4+1, -signWallIsLeft * gs_trim_thk_in, rBoard,
							px1,	py1,	s1,
							px2,	py2,	s2,
							px2,	py3r+gs_tw_bottom_in * bTrimovbotrightin* not(gs_apron)+gs_trimov_bot_right_in,	15-6*gs_stack_bottom,
							px2,	py3r+gs_tw_bottom_in * bTrimovbotrightin* not(gs_apron),	15-7*gs_stack_bottom,
							px1,	py3r+gs_tw_bottom_in * bTrimovbotrightin* not(gs_apron),	s4
					endif
					gosub "TextCoord_Vert"

					if bParalellInCurvedWalls then
						cutend
					endif
				endif


				if	bTShapedOpening then

					py1 = -overSizeBottomIn
					py2 = -overSizeBottomIn

					px1l = 0
					px2l = 0
					if bPShapedLeftOpening then
						px1l = signWallIsLeft * (offsArc - leftWidth - overSizeLeftIn + gs_sidelight_WHole_width_left + trinL - gs_trim_offs_in)
						px2l = px1l - signWallIsLeft * gs_trim_below_boardLeft * gs_tw_left_in
						py3l = py4l + gs_trimov_bot_left_in
						py4l = py3l + gs_tw_bottom_in
					endif
					px1r = 0
					px2r = 0
					if bPShapedRightOpening then
						px1r = signWallIsLeft * (offsArc + rightWidth + overSizeRightIn - gs_sidelight_WHole_width_right - trinR + gs_trim_offs_in)
						px2r = px1r + signWallIsLeft * gs_trim_below_boardRight * gs_tw_right_in
						py3r = py4r + gs_trimov_bot_right_in
						py4r = py3r + gs_tw_bottom_in
					endif

					add 0, -gs_tw_bottom_in, -rBoard
					roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

!						prism_ 4,7,
!							- leftWidth - overSizeLeftIn + gs_sidelight_WHole_width_left + gs_trim_width_in - gs_trim_offs_in,  py1,  15,
!							rightWidth + overSizeRightIn - gs_sidelight_WHole_width_right - gs_trim_width_in + gs_trim_offs_in,  py1,  (11 + 4 * (gs_trim_offs_in > EPS))*bCondition + (14 + (gs_trim_offs_in > EPS))*not(bCondition),
!							rightWidth + overSizeRightIn - gs_sidelight_WHole_width_right - gs_trim_width_in + gs_trim_offs_in,  MAX(py4l, py4r) + gs_tw_bottom_in,  15,
!							- leftWidth - overSizeLeftIn + gs_sidelight_WHole_width_left + gs_trim_width_in - gs_trim_offs_in, MAX(py4l, py4r) + gs_tw_bottom_in,  (11 + 4 * (gs_trim_offs_in > EPS))*bCondition + (14 + (gs_trim_offs_in > EPS))*not(bCondition)

					cutpolya 4, 1, 0,
						-leftWidth - overSizeLeftIn + gs_sidelight_WHole_width_left + gs_trim_width_in - gs_trim_offs_in,  py1,  15,
						rightWidth + overSizeRightIn - gs_sidelight_WHole_width_right - gs_trim_width_in + gs_trim_offs_in,  py1,  (11 + 4 * (gs_trim_offs_in > EPS))*not(WIDO_REVEAL_SIDE) + (14 + (gs_trim_offs_in > EPS))*WIDO_REVEAL_SIDE,
						rightWidth + overSizeRightIn - gs_sidelight_WHole_width_right - gs_trim_width_in + gs_trim_offs_in,  MAX(py4l, py4r) + gs_tw_bottom_in,  15,
						-leftWidth - overSizeLeftIn + gs_sidelight_WHole_width_left + gs_trim_width_in - gs_trim_offs_in, MAX(py4l, py4r) + gs_tw_bottom_in,  (11 + 4 * (gs_trim_offs_in > EPS))*not(WIDO_REVEAL_SIDE) + (14 + (gs_trim_offs_in > EPS))*WIDO_REVEAL_SIDE

					del 2

					if bPShapedLeftOpening & gs_trim_below_boardLeft then
						! --- Draw Door's Left side Trim  Curved Wall---
						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							4, -signWallIsLeft * gs_trim_thk_in, rBoard,
							px1l,	py1,	15,
							px2l,	py2,	s4,
							px2l,	py3l,	10,
							px1l,	py4l,	s2
						gosub "TextCoord_Vert"
					endif

					if bPShapedRightOpening & gs_trim_below_boardRight then
						! --- Draw Door's Right side Trim  Curved Wall---
						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							4, -signWallIsLeft * gs_trim_thk_in, rBoard,
							px1r,	py1,	15,
							px2r,	py2,	s4,
							px2r,	py3r,	10,
							px1r,	py4r,	s2
						gosub "TextCoord_Vert"
					endif

					if bPShapedLeftOpening & gs_trim_below_boardLeft then
						! --- Draw Left lower Trim  Curved Wall---
						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							4, -signWallIsLeft * gs_trim_thk_in, rBoard,
							px2LUp,	py4l,	10 - 2 * gs_stack_left,
							px1LUp,	py3l,	15,
							px2l,	py3l,	10 + 5 * not(gs_trim_below_boardLeft),
							px1l,	py4l,	mask
						gosub "TextCoord_Hor"
					endif

					if bPShapedRightOpening & gs_trim_below_boardRight then
						! --- Draw Right lower Trim  Curved Wall---
						bprism_ gs_trim_in_mat, gs_trim_in_mat, gs_trim_in_mat,
							4, -signWallIsLeft * gs_trim_thk_in, rBoard,
							px2RUp,	py4r,	10 - 2 * gs_stack_left,
							px1RUp,	py3r,	15,
							px2r,	py3r,	10 + 5 * not(gs_trim_below_boardRight),
							px1r,	py4r,	mask
						gosub "TextCoord_Hor"
					endif

					cutend
				endif

				del 3
			endif
		endif
	endif	! not(curvedWall)


	if bDrawLeftTrimatGangingIn then
		! --- Draw left side Trim at Ganging ---

		px2 = leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsStackCasLeftIn + trinL - gs_trim_offs_in
		px1 = leftRevealPnts[idxBoardEndRevealLeft-1][1]
		px3 = leftRevealPnts[idxBoardEndRevealLeft-1][1] - gs_trim_thk_in * tan(alfaLeft)

		if iWindowShape = SHAPE_RECTANGULAR then

			if gs_stack_top then
				py1 = B + overSizeTopIn + sjTy
				py2 = py1
				py5 = py2 - ( tolerOffsStackCasUpperIn + trinT - gs_trim_offs_in) * gs_trim_stack_top
			else
				py1 = B + overSizeTopIn - tolerOffsetUpperIn - trinT + (gs_trim_offs_in* not(gs_trim_atframe_in) * (ABS(thk)<EPS)) + sjTy
				py2 = py1
				py5 = py2
			endif

			py = -overSizeBottomIn + tolerOffsStackCasLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawBoard) - gs_trim_offs_in * not(gs_trim_atframe_in) * (ABS(thk)<EPS)) - sjBy

			if gs_stack_bottom then
				py3 = py
				py4 = py
				py6 = py3 + ( tolerOffsStackCasLowerIn + trinB - gs_trim_offs_in) * gs_trim_stack_bottom
			else
				py3 = py
				py4 = py3
				py6 = py3
			endif

			s1 = 8 + 5 * (not(gs_stack_top) & bGangedCasingonFrame)
			s2 = 8
			s5 = 13 + 2 * (gs_trim_stack_top | (not(gs_trim_stack_top) & not(gs_trim_atframe_in)))
			s3 = 8 + 7 * (not(gs_stack_bottom) & bGangedCasingonFrame)
			s4 = 8
			s6 = 8 + 7 * (not(gs_stack_bottom) & bGangedCasingonFrame)
		endif

		addz - WIDO_FRAME_THICKNESS - gs_trim_thk_in

		add px1, 0, gs_trim_thk_in
		roty  alfaLeft * ySign - 90
		cutplane 1, 1, 0
		del 2

		body -1

		prism_ 	6, gs_trim_thk_in,
			px3,	py1,	s1,
			px2,	py2,	s2,
			px2,	py5,	s5,
			px2,	py6,	s6,
			px2,	py3,	s3,
			px3,	py4,	s4

		gosub "TextCoord_Vert"

		cutend

		del 1
	endif

	if bDrawRightTrimatGangingIn then
		! --- Draw right side Trim at Ganging ---

		px2 = rightRevealPnts[idxBoardEndRevealRight-1][1]  - tolerOffsStackCasRightIn - trinR + gs_trim_offs_in
		px1 = rightRevealPnts[idxBoardEndRevealRight-1][1]
		px3 = rightRevealPnts[idxBoardEndRevealRight-1][1] + gs_trim_thk_in * tan(alfaRight)

		if iWindowShape = SHAPE_RECTANGULAR then
			if gs_stack_top then
				py1 = B + overSizeTopIn  + sjTy
				py2 = py1
				py5 = py2 - ( tolerOffsStackCasUpperIn  + trinT - gs_trim_offs_in) * gs_trim_stack_top
			else
				py1 = B + overSizeTopIn - tolerOffsetUpperIn - trinT + (gs_trim_offs_in * not(gs_trim_atframe_in) * (ABS(thk)<EPS)) + sjTy
				py2 = py1
				py5 = py2
			endif

			py = -overSizeBottomIn + tolerOffsStackCasLowerIn + not(gs_stack_bottom) * (trinB*not(bDrawBoard)- gs_trim_offs_in * not(gs_trim_atframe_in) * (ABS(thk)<EPS)) - sjBy

			if gs_stack_bottom then
				py3 = py
				py4 = py
				py6 = py3 + ( tolerOffsStackCasLowerIn + trinB - gs_trim_offs_in) * gs_trim_stack_bottom
			else
				py3 = py
				py4 = py3
				py6 = py3
			endif

			s1 = 8 + 5 * (not(gs_stack_top) & bGangedCasingonFrame)
			s2 = 8
			s5 = 13 + 2 * (gs_trim_stack_top | (not(gs_trim_stack_top) & not(gs_trim_atframe_in)))
			s3 = 8 + 7 * (not(gs_stack_bottom) & bGangedCasingonFrame)
			s4 = 8
			s6 = 8 + 7 * (not(gs_stack_bottom) & bGangedCasingonFrame)
		endif

		addz - WIDO_FRAME_THICKNESS - gs_trim_thk_in

		add px1, 0, gs_trim_thk_in
		roty  90 - alfaRight * ySign
		cutplane 1, 1, 0
		del 2

		body -1

		prism_ 	6, gs_trim_thk_in,
			px3,	py1,	s1,
			px2,	py2,	s2,
			px2,	py5,	s5,
			px2,	py6,	s6,
			px2,	py3,	s3,
			px3,	py4,	s4

		gosub "TextCoord_Vert"

		cutend

		del 1
	endif

	if bDrawBottTrimatGangingIn then
	! --- Draw lower Trim at Ganging ---

		if not(gs_stack_left) then
			px1 = leftRevealPnts[idxBoardEndRevealLeft][1]  + tolerOffsetLeftIn + trinL - gs_trim_offs_in * (ABS(thk)<EPS)
			px11 = leftRevealPnts[idxBoardEndRevealLeft-1][1]
		else
			px1 = leftRevealPnts[idxBoardEndRevealLeft-1][1] + (tolerOffsStackCasLeftIn + trinL - gs_trim_offs_in) * gs_trim_stack_left - (gs_trim_thk_in) * tan(alfaLeft) * not(gs_trim_stack_left)
			px11 = leftRevealPnts[idxBoardEndRevealLeft-1][1]
		endif

		if not(gs_stack_right) then
			px2 = rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn - trinR + gs_trim_offs_in * (ABS(thk)<EPS)
			px22 = rightRevealPnts[idxBoardEndRevealRight-1][1]
		else
			px2 = rightRevealPnts[idxBoardEndRevealRight-1][1] - (tolerOffsStackCasRightIn + trinR - gs_trim_offs_in) * gs_trim_stack_right  + (gs_trim_thk_in) * tan(alfaRight) * not(gs_trim_stack_right)
			px22 = rightRevealPnts[idxBoardEndRevealRight-1][1]
		endif

		py2 = -overSizeBottomIn
		py1 = py2 + tolerOffsStackCasLowerIn + trinB - gs_trim_offs_in

		s1 = 15 - 2 * (gs_stack_right & not(gs_trim_stack_right))
		s2 = 10 + 5 * (not(gs_stack_right) & bGangedCasingonFrame) - 2 * (gs_stack_right & not(gs_trim_stack_right))
		s3 = 8
		s4 = 8 + 5 * (not(gs_stack_left) & bGangedCasingonFrame)

		addz - WIDO_FRAME_THICKNESS - gs_trim_thk_in

		add px11, 0, gs_trim_thk_in
		roty  alfaLeft * ySign - 90
		cutplane 1, 1, 0
		del 2

		add px22, 0, gs_trim_thk_in
		roty  90 - alfaRight * ySign
		cutplane 1, 1, 0
		del 2

		prism_ 4, gs_trim_thk_in,
			px1,	py1, 	s1,
			px2,	py1, 	s2,
			px2,	py2,	s3,
			px1,	py2,	s4
		gosub "TextCoord_Hor"

		cutend
		cutend

		del 1
	endif

	if bDrawTopTrimatGangingIn then
		! --- Draw upper Trim at Ganging ---

		if not(gs_stack_left) then
			px1 = leftRevealPnts[idxBoardEndRevealLeft][1]  + tolerOffsetLeftIn + trinL - gs_trim_offs_in * (ABS(thk)<EPS)
			px11 = leftRevealPnts[idxBoardEndRevealLeft-1][1]
		else
			px1 = leftRevealPnts[idxBoardEndRevealLeft-1][1] + (tolerOffsStackCasLeftIn + trinL - gs_trim_offs_in) * gs_trim_stack_left - (gs_trim_thk_in) * tan(alfaLeft) * not(gs_trim_stack_left)
			px11 = leftRevealPnts[idxBoardEndRevealLeft-1][1]
		endif

		if not(gs_stack_right) then
			px2 = rightRevealPnts[idxBoardEndRevealright][1] - tolerOffsetRightIn - trinR + gs_trim_offs_in * (ABS(thk)<EPS)
			px22 = rightRevealPnts[idxBoardEndRevealRight-1][1]
		else
			px2 = rightRevealPnts[idxBoardEndRevealRight-1][1] - (tolerOffsStackCasRightIn + trinR - gs_trim_offs_in) * gs_trim_stack_right + (gs_trim_thk_in) * tan(alfaRight) * not(gs_trim_stack_right)
			px22 = rightRevealPnts[idxBoardEndRevealRight-1][1]
		endif


		py2 = B + overSizeTopIn
		py1 = py2  - tolerOffsStackCasUpperIn - trinT + gs_trim_offs_in

		s1 = 15 - 2 * (gs_stack_right & not(gs_trim_stack_right))
		s2 = 10 + 5 * (not(gs_stack_right) & bGangedCasingonFrame) - 2 * (gs_stack_right & not(gs_trim_stack_right))
		s3 = 8
		s4 = 8 + 5 * (not(gs_stack_left) & bGangedCasingonFrame)

		addz - WIDO_FRAME_THICKNESS - gs_trim_thk_in

		add px11, 0, gs_trim_thk_in
		roty  alfaLeft * ySign - 90
		cutplane 1, 1, 0
		del 2

		add px22, 0, gs_trim_thk_in
		roty  90 - alfaRight * ySign
		cutplane 1, 1, 0
		del 2

		prism_ 4, gs_trim_thk_in,
			px1,	py1, 	s1,
			px2,	py1, 	s2,
			px2,	py2,	s3,
			px1,	py2,	s4
		gosub "TextCoord_Hor"

		cutend
		cutend

		del 1
	endif

	del 1

	for i=1 to numCutsCornerColumn
		cutend
	next i
return


2000:
! ==============================================================================
!	Draw Outside Trim
! ==============================================================================

	pen gs_frame_pen

	numCutsCornerColumn = 0

	if gs_corner_column then
		matTrim = gs_trim_out_mat

		material gs_trim_out_mat
		sect_fill gs_trim_fill_out, gs_trim_pen_bg_out, gs_trim_pen_fg_out, gs_trim_pen_cont_out

		gosub 100
	endif

	if not(curvedWall) | (curvedWall & gs_trim_atframe_out) then

		! ======================================
		! Outside Trim - Straight Walls
		! ======================================

		if gs_sectgar = 0 then thk = WIDO_SILL + gs_trim_jambext_nosing_out
		if gs_sectgar = 1 then thk = WALL_THICKNESS - WIDO_SILL

		mask = 10 +\
				1 * bShowEdgesAtFrame +\
				4 * (gs_trim_offs_out > EPS | not(bShowJambExtension) | abs(WIDO_SILL) < EPS | not(gs_trim_show_cover_out) | abs(gs_trim_thk_out) < EPS)

		rotx 180
		addz WIDO_SILL * (gs_trim_atframe_out = 0)
		mulz -1

		if gs_trim_width_out > EPS & thk > EPS & bShowJambExtension & (gs_trim_atframe_out = 0 |\
			(gs_trim_atframe_out = 1 & gs_sectgar)) then

			matTrim = gs_trim_out_mat

			material gs_trim_out_mat
			sect_fill gs_trim_fill_out, gs_trim_pen_bg_out, gs_trim_pen_fg_out, gs_trim_pen_cont_out

			! ===== Outside Trim - Straight Walls - Jamb Extensions =====

			addz thk - gs_trim_jambext_nosing_out
			mulz -1

			if not(gs_stack_left | gs_stack_right | gs_stack_top | gs_stack_bottom | not(bCasingBottomOutside) | bDrawSill | bLeftCornerFunction | bRightCornerFunction | iWindowShape <> SHAPE_RECTANGULAR | not(isWindow)) then
				! --- Not Stacked Window ---
				px1 = -leftWidth - overSizeLeft  + widoLeftJamb + tolerOffsetLeftOut
				px2 = rightWidth + overSizeRight - widoRightJamb - tolerOffsetRightOut
				px3 = px1 + gs_trim_width_out
				px4 = px2 - gs_trim_width_out

				py1 = -overSizeBottom + widoThresDepth + tolerOffsetLowerOut
				py2 = B + overSizeTop - widoHeadDepth - tolerOffsetUpperOut
				py3 = py1 + gs_trim_width_out
				py4 = py2 - gs_trim_width_out

				cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					10, thk,
					px1,	py1, 0, 15, gs_trim_out_mat,
					px1,	py2, 0, 15, gs_trim_out_mat,
					px2,	py2, 0, 15, gs_trim_out_mat,
					px2,	py1, 0, 15, gs_trim_out_mat,
					px1,	py1, 0, -1, gs_trim_out_mat,
					px3,	py3, 0, mask, gs_trim_out_mat,
					px3,	py4, 0, mask, gs_trim_out_mat,
					px4,	py4, 0, mask, gs_trim_out_mat,
					px4,	py3, 0, mask, gs_trim_out_mat,
					px3,	py3, 0, -1, gs_trim_out_mat
			else
				! --- Stacked Window or Window with Sill or Corner Window ---

				if	isWindow | \
					(bPShapedLeftOpening & gs_trim_below_sillLeft) then
					py4 = -overSizeBottomLeft + not(gs_stack_bottom) * widoThresDepth + tolerOffsetLowerOut
					py3 = py4 + not(gs_stack_bottom | not(bCasingBottomOutside) | bDrawLeftSLSill) * gs_trim_width_out

					s3 = 8 + 2 * not(gs_stack_bottom)	! 15 or 8
					s4 = 13 + 2 * not(gs_stack_bottom)	! 15 or 13
				else
					py3 = -overSizeBottomLeft + bDrawSill * widoThresDepth
					py4 = -overSizeBottomLeft + bDrawSill * widoThresDepth

					s3 = 15
					s4 = 15
				endif

				! --- Draw Left Side Jamb extension ---
				px1 = -leftWidth
				if not(gs_sectgar) then
					px1 = px1 + widoLeftJamb + tolerOffsetLeftOut
				else
					if bCasingTolerance then
						px1 = px1 + gs_tolerance_left
					endif
				endif
				px2 = px1 + gs_trim_width_out * not(gs_stack_left)


				if	bShapeEnablesStraightTopTrim then
					py1 = B
					if not(gs_sectgar) then
						py1 = py1 + overSizeTop - not(gs_stack_top) * widoHeadDepth - tolerOffsetUpperOut
					else
						py1 = py1 - bCasingTolerance * gs_tolerance_upper
					endif
					py2 = py1 - not(gs_stack_top) * gs_trim_width_out

					s1 = 8 + 2 * not(gs_stack_top)		! 15 or 8
					s2 = bitset (mask, 1, not(gs_stack_top))
				endif

				if	bShapeEnablesArchedTopTrim then
					ta = leftWidth - not(bHalfCircle) * widoHeadDepth
					tc = arcR - not(bHalfCircle) * widoHeadDepth
					py1 = B - arcR + sqr(max(0, (tc * tc - ta * ta)))

					ta = ta - gs_trim_width_out
					tc = tc - gs_trim_width_out
					py2 = B - arcR + sqr(max(0, (tc * tc - ta * ta)))

					s1 = 8
					s2 = mask - 2
				endif

				if iWindowShape = SHAPE_ELLIPSEARCH then
					py1 = B + overSizeTopOut - tolerOffsetUpperOut - archHeight
					py2 = py1

					s1 = 8
					s2 = mask - 2
				endif

				if	bPShapedLeftOpening then
					py3 = py3 + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL - gs_reveal_bottom
					py4 = py4 + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL - gs_reveal_bottom
				endif

				if bShapeEnablesStraightLeftTrim & not(gs_stack_left | bLeftCornerFunction) then
					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, thk,
						px1,	py1, 	0, s1, gs_trim_out_mat,
						px2,	py2, 	0, s2, gs_trim_out_mat,
						px2,	py3,	0, s3, gs_trim_out_mat,
						px1,	py4, 	0, s4, gs_trim_out_mat
					gosub "TextCoord_Vert"
				endif

				if	bPShapedLeftOpening & gs_trim_below_sillLeft then
					! --- Draw Door's Left side Jamb Extension ---
					px1LSL = leftRevealPnts[idxSillStartRevealLeft][1] + gs_sidelight_WHole_width_left
					px2LSL = px1LSL + gs_trim_width_out
					px1LSLW = leftRevealPnts[idxSillStartRevealLeft][1] + tolerOffsetLeftIn
					px2LSLW = leftRevealPnts[idxSillStartRevealLeft][1] + tolerOffsetLeftIn + gs_trim_width_out * not(gs_stack_left)

					py1 = widoThresDepth
					py2 = widoThresDepth

					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, thk,
						px1LSL,	py1, 	0, 15, gs_trim_out_mat,
						px2LSL,	py2, 	0, mask, gs_trim_out_mat,
						px2LSL,	py3,	0, s3, gs_trim_out_mat,
						px1LSL,	py4, 	0, s4, gs_trim_out_mat
					gosub "TextCoord_Vert"

					if	not(bDrawLeftSLSill) then
						! --- Draw Left Sidelight lower side Jamb Extension ---
						cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
							4, thk,
							 px2LSL,	py3,	0, 15, gs_trim_out_mat,
							 px1LSL,	py4,	0, 15, gs_trim_out_mat,
							 px1LSLW,	py4,	0, 15, gs_trim_out_mat,
							 px2LSLW,	py3,	0, mask - 2 * gs_stack_left, gs_trim_out_mat
					gosub "TextCoord_Hor"
					endif
				endif

				! --- Draw Right Side Jamb extension ---
				if	isWindow | \
					(bPShapedRightOpening & gs_trim_below_sillRight) then
					py4 = -overSizeBottomRight + not(gs_stack_bottom) * widoThresDepth + tolerOffsetLowerOut
					py3 = py4 + not(gs_stack_bottom | not(bCasingBottomOutside) | bDrawRightSLSill) * gs_trim_width_out
				else
					py3 = -overSizeBottomRight + bDrawSill * widoThresDepth
					py4 = -overSizeBottomRight + bDrawSill * widoThresDepth
				endif


				px1 = rightWidth - (widoRightJamb + tolerOffsetRightOut) * not(gs_sectgar) - bCasingTolerance * gs_tolerance_right * gs_sectgar
				px2 = px1 - gs_trim_width_out * not(gs_stack_right)

				if	bShapeEnablesStraightTopTrim then
					py1 = B + (overSizeTop - not(gs_stack_top) * widoHeadDepth - tolerOffsetUpperOut) * not(gs_sectgar) - bCasingTolerance * gs_tolerance_upper * gs_sectgar
					py2 = py1 - not(gs_stack_top) * gs_trim_width_out

					s1 = 8 + 2 * not(gs_stack_top)		! 15 or 8
					s2 = bitset (mask, 1, not(gs_stack_top))
				endif
				if	bShapeEnablesArchedTopTrim then
					ta = rightWidth - not(bHalfCircle) * widoHeadDepth
					tc = arcR - not(bHalfCircle) * widoHeadDepth
					py1 = B - arcR + sqr(max(0, (tc * tc - ta * ta)))

					ta = ta - gs_trim_width_out
					tc = tc - gs_trim_width_out
					py2 = B - arcR + sqr(max(0, (tc * tc - ta * ta)))

					s1 = 8
					s2 = mask - 2
				endif

				if	bPShapedRightOpening then
					py3 = py3 + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR - gs_reveal_bottom
					py4 = py4 + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR - gs_reveal_bottom
				endif

				if bShapeEnablesStraightRightTrim & not(gs_stack_right | bRightCornerFunction) then
					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, thk,
						 px1,	py1,	0, s1, gs_trim_out_mat,
						 px2,	py2,	0, s2, gs_trim_out_mat,
						 px2,	py3,	0, s3, gs_trim_out_mat,
						 px1,	py4, 	0, s4, gs_trim_out_mat
					gosub "TextCoord_Vert"
				endif
				if	bPShapedRightOpening & gs_trim_below_sillRight then
					! --- Draw Door's Right side Jamb Extension ---
					px1RSL = rightRevealPnts[idxSillStartRevealRight][1] - gs_sidelight_WHole_width_right
					px2RSL = px1RSL - gs_trim_width_out
					px1RSLW = rightRevealPnts[idxSillStartRevealRight][1] - tolerOffsetRightIn
					px2RSLW = rightRevealPnts[idxSillStartRevealRight][1] - tolerOffsetRightIn - gs_trim_width_out * not(gs_stack_right)

					py1 = widoThresDepth
					py2 = widoThresDepth

					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, thk,
						px1RSL,	py1, 	0, 15, gs_trim_out_mat,
						px2RSL,	py2, 	0, mask, gs_trim_out_mat,
						px2RSL,	py3,	0, s3, gs_trim_out_mat,
						px1RSL,	py4, 	0, s4, gs_trim_out_mat
					gosub "TextCoord_Vert"

					if	not(bDrawRightSLSill) then
						! --- Draw Right Sidelight lower side Jamb Extension ---
						cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
							4, thk,
							 px2RSL,	py3,	0, 15, gs_trim_out_mat,
							 px1RSL,	py4,	0, 15, gs_trim_out_mat,
							 px1RSLW,	py4,	0, 15, gs_trim_out_mat,
							 px2RSLW,	py3,	0, mask - 2 * gs_stack_right, gs_trim_out_mat
						gosub "TextCoord_Hor"
					endif
				endif
				! --- Draw Bottom Jamb extension ---
				if bLeftCornerFunction then
					px1 = -leftWidth - overSizeLeft + widoLeftJamb + tolerOffsetLeftOut - 1.0
				else
					px1 = -leftWidth + (widoLeftJamb + tolerOffsetLeftOut) * not(gs_sectgar) + bCasingTolerance * gs_tolerance_left * gs_sectgar
				endif
				if bRightCornerFunction then
					px2 = rightWidth + overSizeRight - widoRightJamb - tolerOffsetRightOut + 1.0
				else
					px2 = rightWidth - (widoRightJamb + tolerOffsetRightOut) * not(gs_sectgar) - bCasingTolerance * gs_tolerance_right * gs_sectgar
				endif

				if bShapeEnablesStraightBottomTrim & not(gs_stack_bottom | not(bCasingBottomOutside) | not(isWindow)) & not(bDrawSill) then
					py1 = -overSizeBottom + widoThresDepth + tolerOffsetLowerOut
					py2 = py1 + gs_trim_width_out

					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, thk,
						px1,																	py1,	0, 8 + 2 * not(gs_stack_left), gs_trim_out_mat,
						px1 + not(gs_stack_left  | bLeftCornerFunction)  * gs_trim_width_out,	py2,	0, bitset(bitset (mask, 1, not(gs_stack_left)), 0, (bShowEdgesAtFrame & (not(bRightCornerFunction) | not(bFitModeRight)))), gs_trim_out_mat,
						px2 - not(gs_stack_right | bRightCornerFunction) * gs_trim_width_out,	py2,	0, 8 + 2 * not(gs_stack_right), gs_trim_out_mat,
						px2,																	py1,	0, 13 + 2 * not(gs_stack_right), gs_trim_out_mat
					gosub "TextCoord_Hor"
				endif
				! --- Draw Top Jamb extension ---
				if	(bShapeEnablesStraightTopTrim) & \
					not(gs_stack_top) then

					py1 = B + (overSizeTop - widoHeadDepth - tolerOffsetUpperOut) * not(gs_sectgar) - bCasingTolerance * gs_tolerance_upper * gs_sectgar
					py2 = py1 - gs_trim_width_out

					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, thk,
						px1,																	py1,	0, 8 + 2 * not(gs_stack_left), gs_trim_out_mat,
						px1 + not(gs_stack_left  | bLeftCornerFunction)  * gs_trim_width_out,	py2,	0, bitset(bitset (mask, 1, not(gs_stack_left)), 0, (bShowEdgesAtFrame & (not(bRightCornerFunction) | not(bFitModeRight)))), gs_trim_out_mat,
						px2 - not(gs_stack_right | bRightCornerFunction) * gs_trim_width_out,	py2,	0, 8 + 2 * not(gs_stack_right), gs_trim_out_mat,
						px2,																	py1,	0, 13 + 2 * not(gs_stack_right), gs_trim_out_mat
				endif
				if	bShapeEnablesArchedTopTrim then

					resol nArchResolution

					px1L = leftWidth - widoRightJamb
					px2L = px1L - gs_trim_width_out

					px1R = leftWidth - widoRightJamb
					px2R = px1R - gs_trim_width_out

					if bHalfCircle then
						addy B - archHeight

						cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
							9, thk,
							-px1L,	0,			0,    8 + 7 * gs_stack_left, gs_trim_out_mat,
							-px2L,	0,			0,   62 + mask, gs_trim_out_mat,
							 0,		0,			0,  900, gs_trim_out_mat,
							 0,		archHeight - gs_trim_width_out,	0, 3062 + mask, gs_trim_out_mat,
							 px2R,	0,			0, 3008 + 7 * gs_stack_right, gs_trim_out_mat,
							 px1R,	-EPS,		0,    8 + 7 * gs_stack_right, gs_trim_out_mat,
							 px1R,	0,			0,   79, gs_trim_out_mat,
							 0,		archHeight, 0, 3079, gs_trim_out_mat,
							-px1L,	0,			0, 1015, gs_trim_out_mat

						! --- Draw missing lines ---
						if gs_stack_left then lin_ -px2L,0,0, -px2L,0,thk
					else
						addy B - archHeight

						ta = leftWidth - widoHeadDepth
						tc = arcR - widoHeadDepth
						py1L = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						ta = ta - gs_trim_width_out
						tc = tc - gs_trim_width_out
						py2L = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						ta = rightWidth - widoHeadDepth
						tc = arcR - widoHeadDepth
						py1R = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						ta = ta - gs_trim_width_out
						tc = tc - gs_trim_width_out
						py2R = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

						cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
							8, thk,
							 0,		archHeight - arcR, 0, 900, gs_trim_out_mat,
							-px1L,	py1L, 	0,  8 + 7 * gs_stack_left, gs_trim_out_mat,
							-px2L,	py2L,	0,  62 + mask, gs_trim_out_mat,
							 0,		archHeight - widoHeadDepth - gs_trim_width_out,	0, 3062 + mask, gs_trim_out_mat,
							 px2R,	py2R,	0,3010 + 5 * gs_stack_right, gs_trim_out_mat,
							 px1R,	py1R,	0,  79, gs_trim_out_mat,
							 0,		archHeight - widoHeadDepth,	0, 3079, gs_trim_out_mat,
							-px1L,	py1L, 	0,3015, gs_trim_out_mat

						lin_ -px2L,py2L,0, -px2L,py2L,thk
					endif

					del 1
				endif

				if iWindowShape = SHAPE_ELLIPSEARCH then
					resol nArchResolution

					px1 = -leftWidth + widoRightJamb + tolerOffsetLeftOut
					px2 = px1 + not(gs_stack_left) * gs_trim_width_Out
					px4 = rightWidth - widoRightJamb - tolerOffsetRightOut
					px3 = px4 - not(gs_stack_right) * gs_trim_width_out

					pxcL = -leftWidth + smallRadiusEllips
					pxcR = rightWidth - smallRadiusEllips

					py1 = B + overSizeTopOut - tolerOffsetUpperOut

					s3 = 9 + 4 * (abs(gs_trim_offs_out) > EPS | not(gs_trim_show_cover_out) | abs(gs_trim_thk_out) < EPS) - 2 * gs_stack_right

					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						13,thk,
						px4,	py1 - archHeight,			0, 13,		gs_trim_out_mat,
						pxcR,	py1 - archHeight,			0, 913,		gs_trim_out_mat,
						0,		alphaSide,					0, 4013,	gs_trim_out_mat,
						0,		py1 - middleRadiusEllips, 	0, 913,		gs_trim_out_mat,
						0,		alphaMiddle,				0, 4013,	gs_trim_out_mat,
						pxcL,	py1 - archHeight,			0, 913,		gs_trim_out_mat,
						0,		alphaSide,					0, 4008,	gs_trim_out_mat,
						px2,	py1 - archHeight,			0, s3,		gs_trim_out_mat,
						0,		-alphaSide,					0, 4000+s3,	gs_trim_out_mat,
						0,		py1 - middleRadiusEllips, 	0, 900+s3,	gs_trim_out_mat,
						0,		-alphaMiddle,				0, 4000+s3,	gs_trim_out_mat,
						pxcR,	py1 - archHeight,			0, 900+s3,	gs_trim_out_mat,
						0,		-alphaSide,					0, 4000+s3,	gs_trim_out_mat
				endif
				gosub "TextCoord_Hor"
			endif

			del 2
		endif

		mask = 11 + 4 * (gs_trim_offs_out > EPS | not(bShowJambExtension) | abs(WIDO_SILL) < EPS | not(gs_trim_show_cover_out) | abs(gs_trim_thk_out) < EPS)

		if gs_trim_thk_out > EPS & gs_trim_show_cover_out & (gs_trimtype_out_int <> CASING_COMPLEX) then

			material gs_trim_out_mat
			pen gs_frame_pen
			sect_fill gs_trim_fill_out, gs_trim_pen_bg_out, gs_trim_pen_fg_out, gs_trim_pen_cont_out

			! ===== Outside Trim - Straight Walls - Casing =====

			maskTop		= 8 + 2 * not(gs_stack_top)
			maskBottom	= 8 + 2 * not(gs_stack_bottom)
			maskLeft	= 8 + 2 * not(gs_stack_left)
			maskRight	= 8 + 2 * not(gs_stack_right)

			maskLeft2	= bDrawSill*(not(bTrimovbotleftout)*(15-7*gs_stack_left)+bTrimovbotleftout*(10-2*gs_stack_left))
			maskRight2	= bDrawSill*(not(bTrimovbotrightout)*(15-7*gs_stack_right)+bTrimovbotrightout*(10-2*gs_stack_right))

			addz -gs_trim_thk_out
			! --- Stacked Window or Window with Sill or Corner Window ---

			if	isWindow | \
				bTShapedOpening then
				py = -overSizeBottomLeft + not(gs_stack_bottom) * widoThresDepth + gs_trim_offs_out_bottom * bCasingBottomOutside

				s3 = maskBottom						! 15 or 10 or 8
				s4 = 13 + 2 * not(gs_stack_bottom)	! 15 or 13
			else
				py	= -overSizeBottomLeft + bDrawSill * widoThresDepth
				py3 = -overSizeBottomLeft + bDrawSill * widoThresDepth
				py4 = -overSizeBottomLeft + bDrawSill * widoThresDepth

				s3 = 15
				s4 = 15
			endif

			! --- Draw left side Trim ---
			py3l = py
			py4l = py

			px2 = -leftWidth + gs_trim_width_out - gs_trim_offs_out + widoLeftJamb + tolerOffsetLeftOut
			px1 = px2 - gs_tw_left_out

			if gs_stack_bottom then
				py3l = -overSizeBottom
				py4l = py3l
				py5 = py3l
				py6 = py3l
			else
				if not(bCasingBottomOutside) then
					py3l = py
					py4l = py3l
					py5 = py3l
					py6 = py3l
				else
					if	isWindow | \
						(bPShapedLeftOpening & gs_trim_below_sillLeft) then
						py3l = py \
								+ gs_trim_width_out * not(bDrawLeftSLSill) \
								- gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawLeftSLSill) \
								- gs_tw_bottom_out * bTrimovbotleftout \
								- gs_trimov_bot_left_out

						if not(gs_trim_atframe_out) then
							py4l = py \
									+ gs_trim_width_out * not(bDrawLeftSLSill) \
									- gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawLeftSLSill) \
									- gs_tw_bottom_out * (not(bDrawLeftSLSill) | (bDrawLeftSLSill & (bTrimovbotleftout | gs_trim_below_sillLeft))) \
									- gs_trimov_bot_left_out

						else
							py4l = py3l - (gs_trimov_bot_left_out + gs_tw_bottom_out * (bTrimovbotleftout=0) * gs_trimb_atframe_out * not(bDrawLeftSLSill))
						endif
					endif

					py5 = py3l + (gs_trimov_bot_left_out + gs_tw_bottom_out) * bTrimovbotleftout
					py6 = py3l + gs_trimov_bot_left_out * bTrimovbotleftout
				endif
			endif

			if	bPShapedLeftOpening then
				py3l = py3l + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL - gs_reveal_bottom
				py4l = py4l + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL - gs_reveal_bottom
				py5 = py5 + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL - gs_reveal_bottom
				py6 = py6 + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL - gs_reveal_bottom
			endif

			if	bShapeEnablesStraightTopTrim then
				py1 = B + overSizeTop + not(gs_stack_top) * (-widoHeadDepth - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out + gs_trim_offs_out_top + gs_tw_top_out*not(bTrimovtopleftout))
				py2 = B + overSizeTop + not(gs_stack_top) * (-widoHeadDepth - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out + gs_trim_offs_out_top)

				if	isWindow | \
					(bPShapedLeftOpening & gs_trim_below_sillLeft) then
					s6 = maskBottom*not(bTrimovbotleftout)+(15-2*not(gs_tw_bottom_out))*bTrimovbotleftout
					if gs_stack_bottom then
						s3 = 8
					else
						if not(bCasingBottomOutside) then
							s3 = 15
						else
							s3 = (maskBottom+5*(not(gs_tw_bottom_out) | gs_trim_atframe_out))*not(bTrimovbotleftout)+bTrimovbotleftout*15-5*gs_trim_atframe_out*not(bDrawLeftSLSill)*not(gs_stack_bottom)\
							+5*not(bTrimovbotleftout)*(WIDO_SILL>0) * (gs_trim_atframe_out) * not(gs_trimb_atframe_out)
						endif
					endif
				else
					s6 = 15
					s3 = 15
				endif

				s1 = maskTop				! 15 or 10 or 8
				s2 = bitset (mask, 1, not(gs_stack_top)) + 4 * gs_trim_atframe_out * (WIDO_SILL>0)
				s5 = 8
			endif
			if	bShapeEnablesArchedTopTrim then
				ta = leftWidth - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out - not(bHalfCircle) * widoHeadDepth - tolerOffsetUpperOut * not(bHalfCircle)
				tc = arcR - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out - not(bHalfCircle) * widoHeadDepth - tolerOffsetUpperOut * not(bHalfCircle)
				py1 = B - arcR + sqr(max(0, tc * tc - ta * ta))

				ta = ta - gs_tw_right_out
				tc = tc - gs_tw_right_out
				py2 = B - arcR + sqr(max(0, tc * tc - ta * ta))

				if	isWindow | \
					(bPShapedLeftOpening & gs_trim_below_sillLeft) then
					s6 = maskBottom*not(bTrimovbotleftout)+(15-2*not(gs_tw_bottom_out))*bTrimovbotleftout
					if gs_stack_bottom then
						s3 = 8
					else
						if not(bCasingBottomOutside) then
							s3 = 15
						else
							s3 = (maskBottom+5*(not(gs_tw_bottom_out) | gs_trim_atframe_out))*not(bTrimovbotleftout)+bTrimovbotleftout*(15-7*gs_stack_bottom)-5*gs_trim_atframe_out*not(bDrawLeftSLSill)*not(gs_stack_bottom)\
							+5*not(bTrimovbotleftout)*(WIDO_SILL>0) * (gs_trim_atframe_out) * not(gs_trimb_atframe_out)
						endif
					endif
				else
					s6 = 15
					s3 = 15
				endif

				s1 = 8
				s2 = mask - 2 + 4 * gs_trim_atframe_out * (WIDO_SILL>0)
				s5 = 8
			endif

			if iWindowShape = SHAPE_ELLIPSEARCH then
				py1 = B + overSizeTopOut - archHeight
				py2 = B + overSizeTopOut - archHeight

				s1 = 8
				s2 = mask - 2
				s5 = 9 + 4 * gs_trim_atframe_out
			endif

			pxWCutTopLeftOut	= px1
			pxWCutTopOHLeftOut	= px1
			pxWCutMidLeftOut	= px1
			pxWCutMidOHLeftOut	= px2
			pxWCutBotLeftOut	= px1
			pyWCutTopLeftOut	= py1
			pyWCutTopOHOut		= py1
			pyWCutMidLeftOut	= py4l

			if bShapeEnablesStraightLeftTrim & not(gs_stack_left | bLeftCornerFunction) then
				body -1
				if bDrawBottTrimatGangingOut then
					py6 = py6 + tolerOffsStackCasLowerOut + trim_offs_out_modify - gs_trim_offs_out
					py5 = py2
					s5 = 13
				endif
				if bDrawTopTrimatGangingOut then
					py5 = py2 - tolerOffsStackCasUpperOut - trim_offs_out_modify + gs_trim_offs_out
					s2 = 10
					s5 = 13
				endif
				cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					6, gs_trim_thk_out,
					px1,	py1,	0, s1, gs_trim_out_mat,
					px2,	py2,	0, s2, gs_trim_out_mat,
					px2,	py5,	0, s5, gs_trim_out_mat,
					px2,	py6,	0, s6, gs_trim_out_mat,
					px2,	py3l,	0, s3, gs_trim_out_mat,
					px1,	py4l,	0, s4, gs_trim_out_mat
				gosub "TextCoord_Vert"
			endif

			! --- Draw Door's Left side Trim ---
			py1 = widoThresDepth
			py2 = widoThresDepth
			py3l = py4l + gs_trimov_bot_left_out
			py4l = py3l + gs_tw_bottom_out

			if	bPShapedLeftOpening & gs_trim_below_sillLeft then
				px1 = leftRevealPnts[idxSillStartRevealLeft][1] + gs_sidelight_WHole_width_left  + gs_trim_width_out - gs_trim_offs_out
				px2 = px1 - gs_tw_left_out

				cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					4, gs_trim_thk_out,
					px1,	py1,	0, 15, gs_trim_out_mat,
					px2,	py2,	0, s4, gs_trim_out_mat,
					px2,	py3l,	0, s5, gs_trim_out_mat,
					px1,	py4l,	0, s2, gs_trim_out_mat
				gosub "TextCoord_Vert"

				pxWCutBotLeftOut = px2
			endif

			pyWCutBotLeftOut = py1


			! --- Draw right side Trim ---

			if	isWindow | \
				bPShapedRightOpening then
				py = -overSizeBottomRight + not(gs_stack_bottom) * widoThresDepth + gs_trim_offs_out_bottom * bCasingBottomOutside
			else
				py	= -overSizeBottomRight + bDrawSill * widoThresDepth
				py3 = -overSizeBottomRight + bDrawSill * widoThresDepth
				py4 = -overSizeBottomRight + bDrawSill * widoThresDepth
			endif
			py3r = py
			py4r = py

			px2 = rightWidth - gs_trim_width_out + gs_trim_offs_out - widoRightJamb - tolerOffsetRightOut
			px1 = px2 + gs_tw_right_out

			if gs_stack_bottom then
				py3r = -overSizeBottom
				py4r = py3r
				py5 = py3r
				py6 = py3r
			else
				if not(bCasingBottomOutside) then
					py3l = py
					py4l = py3l
					py5 = py3l
					py6 = py3l
				else
					if	isWindow | \
						(bPShapedRightOpening & gs_trim_below_sillRight) then
						py3r = py \
								+ gs_trim_width_out * not(bDrawRightSLSill) \
								- gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawRightSLSill) \
								- gs_tw_bottom_out * bTrimovbotrightout \
!!!									- 1 * (iSillType > 1 & bDrawBoard) \
								- gs_trimov_bot_right_out
						if not(gs_trim_atframe_out) then
							py4r = py \
									+ gs_trim_width_out * not(bDrawRightSLSill) \
									- gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawRightSLSill) \
									- gs_tw_bottom_out*(not(bDrawRightSLSill) | (bDrawRightSLSill & (bTrimovbotrightout | gs_trim_below_sillRight))) \
!!!										- 1 * (iSillType > 1 & bDrawBoard) \
									- gs_trimov_bot_right_out
						else
							py4r = py3r - (gs_trimov_bot_left_out + gs_tw_bottom_out * (bTrimovbotleftout=0) * gs_trimb_atframe_out * not(bDrawRightSLSill))
						endif
					endif

					py5 = py3r + (gs_trimov_bot_right_out + gs_tw_bottom_out) * bTrimovbotrightout
					py6 = py3r + gs_trimov_bot_right_out * bTrimovbotrightout
				endif
			endif

			if	bPShapedRightOpening then
				py3r = py3r + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR - gs_reveal_bottom
				py4r = py4r + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR - gs_reveal_bottom
				py5 = py5 + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR - gs_reveal_bottom
				py6 = py6 + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR - gs_reveal_bottom
			endif

			if	bShapeEnablesStraightTopTrim then
				py1 = B + overSizeTop + not(gs_stack_top) * (-widoHeadDepth - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out + gs_trim_offs_out_top + gs_tw_top_out*not(bTrimovtoprightout))
				py2 = B + overSizeTop + not(gs_stack_top) * (-widoHeadDepth - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out + gs_trim_offs_out_top)

				if	isWindow | \
					(bPShapedRightOpening & gs_trim_below_sillRight) then
					s6 = maskBottom*not(bTrimovbotrightout)+(15-2*not(gs_tw_bottom_out))*bTrimovbotrightout
					if gs_stack_bottom = 1 then
						s3 = 8
					else
						if not(bCasingBottomOutside) then
							s3 = 15
						else
							s3 = (maskBottom+5*(not(gs_tw_bottom_out) | gs_trim_atframe_out))*not(bTrimovbotrightout)+bTrimovbotrightout*(15-7*gs_stack_bottom)-5*gs_trim_atframe_out*not(bDrawRightSLSill)*not(gs_stack_bottom)\
							+5*not(bTrimovbotleftout)*(WIDO_SILL>0) * (gs_trim_atframe_out) * not(gs_trimb_atframe_out)
						endif
					endif
				else
					s6 = 15
					s3 = 15
				endif

				s1 = maskTop				! 15 or 10 or 8
				s2 = bitset (mask, 1, not(gs_stack_top)) + 4 * gs_trim_atframe_out * (WIDO_SILL>0)
				s5 = 8
			endif
			if	bShapeEnablesArchedTopTrim then
				ta = rightWidth - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out - not(bHalfCircle) * widoHeadDepth - tolerOffsetUpperOut * not(bHalfCircle)
				tc = arcR - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out - not(bHalfCircle) * widoHeadDepth - tolerOffsetUpperOut * not(bHalfCircle)
				py1 = B - arcR + sqr(max(0, tc * tc - ta * ta))

				ta = ta - gs_tw_right_out
				tc = tc - gs_tw_right_out
				py2 = B - arcR + sqr(max(0, tc * tc - ta * ta))

				if	isWindow | \
					(bPShapedRightOpening & gs_trim_below_sillRight) then
					s6 = maskBottom*not(bTrimovbotrightout)+(15-2*not(gs_tw_bottom_out))*bTrimovbotrightout
					if gs_stack_bottom = 1 then
						s3 = 8
					else
						if not(bCasingBottomOutside) then
							s3 = 15
						else
							s3 = (maskBottom+5*(not(gs_tw_bottom_out) | gs_trim_atframe_out))*not(bTrimovbotrightout)+bTrimovbotrightout*(15-7*gs_stack_bottom)-5*gs_trim_atframe_out*not(bDrawRightSLSill)*not(gs_stack_bottom)\
							+5*not(bTrimovbotleftout)*(WIDO_SILL>0) * gs_trim_atframe_out * not(gs_trimb_atframe_out)
						endif
					endif
				else
					s6 = 15
					s3 = 15
				endif

				s1 = 8
				s2 = mask - 2 + 4 * gs_trim_atframe_out * (WIDO_SILL>0)
				s5 = 8
			endif

			if iWindowShape = SHAPE_ELLIPSEARCH then
				py1 = B + overSizeTopOut - archHeight
				py2 = B + overSizeTopOut - archHeight

				s1 = 8
				s2 = mask - 2
				s5 = 9 + 4 * gs_trim_atframe_out
			endif

			pxWCutTopRightOut	= px1
			pxWCutBotRightOut	= px1
			pxWCutMidRightOut	= px1
			pxWCutMidOHRightOut	= px2
			pyWCutTopRightOut 	= py1
			pyWCutMidRightOut	= py4r

			if bShapeEnablesStraightRightTrim & not(gs_stack_right | bRightCornerFunction) then
				body -1
				if bDrawBottTrimatGangingOut then
					py6 = py6 + tolerOffsStackCasLowerOut + trim_offs_out_modify - gs_trim_offs_out
					py5 = py2
					s5 = 13
				endif
				if bDrawTopTrimatGangingOut then
					py5 = py2 - tolerOffsStackCasUpperOut - trim_offs_out_modify + gs_trim_offs_out
					s2 = 10
					s5 = 13
				endif

				cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					4+2, gs_trim_thk_out,
					px1,	py1,	0, s1, gs_trim_out_mat,
					px2,	py2,	0, s2, gs_trim_out_mat,
					px2,	py5,	0, s5, gs_trim_out_mat,
					px2,	py6,	0, s6, gs_trim_out_mat,
					px2,	py3r,	0, s3, gs_trim_out_mat,
					px1,	py4r,	0, s4, gs_trim_out_mat
				gosub "TextCoord_Vert"
			endif

			! --- Draw Door's Right side Trim ---
			py1 = widoThresDepth
			py2 = widoThresDepth
			py3r = py4r + gs_trimov_bot_right_out
			py4r = py3r + gs_tw_bottom_out

			if	bPShapedRightOpening & gs_trim_below_sillRight then
				px1 = rightRevealPnts[idxSillStartRevealRight][1] - gs_sidelight_WHole_width_right  - gs_trim_width_out + gs_trim_offs_out
				px2 = px1 + gs_tw_right_out

				cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					4, gs_trim_thk_out,
					px1,	py1,	0, 15, gs_trim_out_mat,
					px2,	py2,	0, s4, gs_trim_out_mat,
					px2,	py3r,	0, s5, gs_trim_out_mat,
					px1,	py4r,	0, s2, gs_trim_out_mat
				gosub "TextCoord_Vert"

				pxWCutBotRightOut = px2
			endif

			pyWCutBotRightOut = py1

			if bPShapedLeftOpening & gs_trim_below_sillLeft then
				! --- Draw Left lower Trim in Straight Wall ---
				px = -leftWidth - overSizeLeft + widoLeftJamb + tolerOffsetLeftOut
				px1 = px + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_left_out*not(bTrimovbotleftout))
				px2 = px + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out)
				px3 = leftRevealPnts[idxSillStartRevealLeft][1] + gs_sidelight_WHole_width_left  + gs_trim_width_out - gs_trim_offs_out
				px4 = px3 - gs_tw_left_out * gs_trim_below_sillLeft

				if not(bDrawLeftSLSill) | gs_trim_below_sillLeft then
					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, gs_trim_thk_out,
						px1,	py3l,	0, 10, gs_trim_out_mat,
						px2,	py4l,	0, mask - 2 * gs_stack_left, gs_trim_out_mat,
						px3,	py4l,	0, 10 + 5 * not(gs_trim_below_sillLeft), gs_trim_out_mat,
						px4,	py3l,	0, 15, gs_trim_out_mat
					gosub "TextCoord_Hor"
				endif
			endif

			if bPShapedRightOpening & gs_trim_below_sillRight then
				! --- Draw Right lower Trim in Straight Wall ---
				px = rightWidth - overSizeRight - widoRightJamb - tolerOffsetRightOut
				px1 = px - not(gs_stack_right) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_right_out*not(bTrimovbotrightout))
				px2 = px - not(gs_stack_right) * (gs_trim_width_out - gs_trim_offs_out)
				px3 = rightRevealPnts[idxSillStartRevealRight][1] - gs_sidelight_WHole_width_right  - gs_trim_width_out + gs_trim_offs_out
				px4 = px3 + gs_tw_right_out * gs_trim_below_sillRight

				if not(bDrawRightSLSill) | gs_trim_below_sillRight then
					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, gs_trim_thk_out,
						px1,	py3r,	0, 10, gs_trim_out_mat,
						px2,	py4r,	0, mask - 2 * gs_stack_right, gs_trim_out_mat,
						px3,	py4r,	0, 10 + 5 * not(gs_trim_below_sillRight), gs_trim_out_mat,
						px4,	py3r,	0, 15, gs_trim_out_mat
					gosub "TextCoord_Hor"
				endif
			endif

			if bShapeEnablesStraightBottomTrim & not(gs_stack_bottom | not(bCasingBottomOutside) | not(isWindow)) & abs(gs_tw_bottom_out) > EPS \
			& (not(curvedWall) | (curvedWall & gs_trimb_atframe_out)) then
				! --- Draw lower Trim ---

				px = -leftWidth - overSizeLeft + widoLeftJamb + tolerOffsetLeftOut
				px1 = px + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_left_out*not(bTrimovbotleftout))
				px2 = px + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out)
				px = rightWidth + overSizeRight - widoRightJamb - tolerOffsetRightOut
				px3 = px + not(gs_stack_right) * (-gs_trim_width_out + gs_trim_offs_out)
				px4 = px + not(gs_stack_right) * (-gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out*not(bTrimovbotrightout))

				if not(bParalellInCurvedWalls) then		! not USA type
					py = -overSizeBottom + widoThresDepth + gs_trim_offs_out_bottom !!+ BrickSillTrimOffs

					py1 = py + not(gs_stack_bottom) * (gs_trim_width_out*not(bDrawSill) - gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawSill) - gs_tw_bottom_out)
					py2 = py1 + gs_tw_bottom_out * ((bDrawSill & not(bCasingBottomOutside)) | (gs_trim_atframe_out & not(gs_trimb_atframe_out) & (WIDO_SILL>0)))
					py3 = py + not(gs_stack_bottom) * (gs_trim_width_out*not(bDrawSill) - gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawSill))
				else
					py = -overSizeBottom + widoThresDepth + gs_trim_offs_out_bottom !!+ BrickSillTrimOffs

					if bDrawSill then
						py1 = py + not(gs_stack_bottom) * (-gs_trim_offs_out_bottom * not(gs_trim_atframe_out) - gs_tw_bottom_out)
						py3 = py + not(gs_stack_bottom) * (-gs_trim_offs_out_bottom * not(gs_trim_atframe_out))
					else
						py1 = py + not(gs_stack_bottom) * (gs_trim_width_out - gs_trim_offs_out * not(gs_trim_atframe_out) - gs_tw_bottom_out)
						py3 = py + not(gs_stack_bottom) * (gs_trim_width_out - gs_trim_offs_out * not(gs_trim_atframe_out))
					endif
					py2 = py1 + gs_tw_bottom_out * (bDrawSill | (gs_trim_atframe_out & not(gs_trimb_atframe_out) & (WIDO_SILL>0)))
				endif
				py4 = py3
				py5 = py2
				py6 = py1

				s1 = not(gs_trim_atframe_out) * (maskLeft*not(bDrawSill)+maskLeft2*bDrawSill) + gs_trim_atframe_out * (8 + 7 * not(gs_stack_left))
				s2 = not(gs_trim_atframe_out) * maskLeft + gs_trim_atframe_out * (15 - 5 * not(bDrawSill) * gs_trimb_atframe_out)
				s3 = not(gs_trim_atframe_out) * bitset (mask, 1, not(gs_stack_left)) + gs_trim_atframe_out * 13
				s4 = not(gs_trim_atframe_out) * maskRight + gs_trim_atframe_out * (13 - 5 * not(bDrawSill) * gs_trimb_atframe_out)
				s5 = not(gs_trim_atframe_out) * (maskRight*not(bDrawSill)+maskRight2*bDrawSill) + gs_trim_atframe_out * (8 + 7 * not(gs_stack_right))
				s6 = 13 + 2 * not(gs_stack_right)

				addz -WIDO_SILL * gs_trim_atframe_out * not(gs_trimb_atframe_out)

				if gs_fsill then
					add 0, 0, gs_trim_thk_out
					cutplane 270 - gs_sill_angle
					del 1
				endif

				if bDrawLeftTrimatGangingOut then
					px2 = leftRevealPnts[2][1] + tolerOffsStackCasLeftOut + trim_offs_out_modify - gs_trim_offs_out
					py2 = py3
				endif
				if bDrawRightTrimatGangingOut then
					px3 = rightRevealPnts[2][1] - tolerOffsStackCasRightOut - trim_offs_out_modify + gs_trim_offs_out
					py5 = py4
				endif

				cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					4+2, gs_trim_thk_out,
					px1,	py1,	0, s1, gs_trim_out_mat,
					px1,	py2, 	0, s2, gs_trim_out_mat,
					px2,	py3,	0, s3, gs_trim_out_mat,
					px3,	py4,	0, s4, gs_trim_out_mat,
					px4,	py5, 	0, s5, gs_trim_out_mat,
					px4,	py6, 	0, s6, gs_trim_out_mat
				gosub "TextCoord_Hor"

				if gs_fsill then cutend

				del 1
			endif


			if bShapeEnablesStraightTopTrim & not(gs_stack_top) & abs(gs_tw_top_out) > EPS then
				! --- Draw upper Trim ---

				px = -leftWidth - overSizeLeft + widoLeftJamb + tolerOffsetLeftOut
				px1 = px + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_left_out)
				px2 = px + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out)
				px = rightWidth + overSizeRight - widoRightJamb - tolerOffsetRightOut
				px3 = px + not(gs_stack_right) * (-gs_trim_width_out + gs_trim_offs_out)
				px4 = px + not(gs_stack_right) * (-gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out)

				py2 = B + overSizeTop - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out - widoHeadDepth + gs_trim_offs_out_top
				py1 = py2 + gs_tw_top_out

				pyWCutTopOHOut = py1

				if bDrawLeftTrimatGangingOut then
					px2 = leftRevealPnts[2][1] + tolerOffsStackCasLeftOut + trim_offs_out_modify - gs_trim_offs_out
				endif
				if bDrawRightTrimatGangingOut then
					px3 = rightRevealPnts[2][1] - tolerOffsStackCasRightOut - trim_offs_out_modify + gs_trim_offs_out
				endif

				if not(bTrimovtopleftout | bDrawLeftTrimatGangingOut) & not(bTrimovtoprightout | bDrawRightTrimatGangingOut) then
					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, gs_trim_thk_out,
						px1,	py1,	0, maskLeft, gs_trim_out_mat,
						px2,	py2,	0, 13 + 2 * not(gs_stack_left), gs_trim_out_mat,
						px3,	py2,	0, maskRight, gs_trim_out_mat,
						px4,	py1, 	0, 13 + 2 * not(gs_stack_right), gs_trim_out_mat
				endif
				if (bTrimovtopleftout | bDrawLeftTrimatGangingOut) & not(bTrimovtoprightout | bDrawRightTrimatGangingOut) then
					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						6, gs_trim_thk_out,
						px1-gs_trimov_top_left_out*not(gs_stack_left),	py1,	0, 8 + 7 * not(gs_stack_left), gs_trim_out_mat,
						px1-gs_trimov_top_left_out*not(gs_stack_left),	py2,	0, 15, gs_trim_out_mat,
						px1,	py2,	0, maskLeft, gs_trim_out_mat,
						px2,	py2,	0, 13, gs_trim_out_mat, !bitset (mask, 1, not(gs_stack_left)), gs_trim_out_mat,
						px3,	py2,	0, maskRight, gs_trim_out_mat,
						px4,	py1, 	0, 13 + 2 * not(gs_stack_right), gs_trim_out_mat
				endif
				if not(bTrimovtopleftout | bDrawLeftTrimatGangingOut) & (bTrimovtoprightout | bDrawRightTrimatGangingOut) then
					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						6, gs_trim_thk_out,
						px1,	py1,	0, maskLeft, gs_trim_out_mat,
						px2,	py2,	0, 13, gs_trim_out_mat, !bitset (mask, 1, not(gs_stack_left)), gs_trim_out_mat,
						px3,	py2,	0, maskRight, gs_trim_out_mat,
						px4,	py2, 	0, 15, gs_trim_out_mat,
						px4+gs_trimov_top_right_out*not(gs_stack_right),	py2, 	0, 8 + 7 * not(gs_stack_right), gs_trim_out_mat,
						px4+gs_trimov_top_right_out*not(gs_stack_right),	py1, 	0, 15, gs_trim_out_mat
				endif
				if (bTrimovtopleftout | bDrawLeftTrimatGangingOut) & (bTrimovtoprightout | bDrawRightTrimatGangingOut) then
					if gs_trimtype_out_int = CASING_NORMAL then				! Rectangular casing type
						cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
							8, gs_trim_thk_out,
							px1-gs_trimov_top_left_out*not(gs_stack_left),	py1,	0, 8 + 7 * not(gs_stack_left), gs_trim_out_mat,
							px1-gs_trimov_top_left_out*not(gs_stack_left),	py2,	0, 15, gs_trim_out_mat,
							px1,	py2,	0, maskLeft, gs_trim_out_mat,
							px2,	py2,	0, 13, gs_trim_out_mat, !bitset (mask, 1, not(gs_stack_left)), gs_trim_out_mat,
							px3,	py2,	0, maskRight, gs_trim_out_mat,
							px4,	py2, 	0, 15, gs_trim_out_mat,
							px4+gs_trimov_top_right_out*not(gs_stack_right),	py2, 	0, 8 + 7 * not(gs_stack_right), gs_trim_out_mat,
							px4+gs_trimov_top_right_out*not(gs_stack_right),	py1, 	0, 15, gs_trim_out_mat
					endif
					if gs_trimtype_out_int = CASING_OVERHANG then				! SWE traditional casing type
						cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
							10, gs_trim_thk_out,
							px1-gs_trimov_top_left_out*not(gs_stack_left),	py1,		0, 8 + 7 * not(gs_stack_left), gs_trim_out_mat,
							px1-gs_trimov_top_left_out*not(gs_stack_left),	py1-0.04,	0, 8 + 7 * not(gs_stack_left), gs_trim_out_mat,
							px1-gs_trimov_top_left_out*not(gs_stack_left)/2,py2,		0, 15, gs_trim_out_mat,
							px1,	py2,	0, maskLeft, gs_trim_out_mat,
							px2,	py2,	0, bitset (mask, 1, not(gs_stack_left)), gs_trim_out_mat,
							px3,	py2,	0, maskRight, gs_trim_out_mat,
							px4,	py2, 	0, 15, gs_trim_out_mat,
							px4+gs_trimov_top_right_out*not(gs_stack_right)/2,	py2, 		0, 8 + 7 * not(gs_stack_right), gs_trim_out_mat,
							px4+gs_trimov_top_right_out*not(gs_stack_right),	py1-0.04, 	0, 8 + 7 * not(gs_stack_right), gs_trim_out_mat,
							px4+gs_trimov_top_right_out*not(gs_stack_right),	py1, 		0, 15, gs_trim_out_mat
					endif
				endif
			endif



			if	bShapeEnablesArchedTopTrim then

				resol nArchResolution

				px1 = -leftWidth + tolerOffsetLeftOut + gs_trim_width_out - gs_trim_offs_out + widoRightJamb
				px2 = rightWidth - tolerOffsetRightOut - gs_trim_width_out + gs_trim_offs_out - widoRightJamb



				if bHalfCircle then
					addy B - archHeight - tolerOffsetUpperIn

					cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						11, gs_trim_thk_out,
						px1,					0, 	 0,   8 + 7 * gs_stack_left, gs_trim_out_mat,
						px1 - gs_tw_right_out,	-EPS,0,   8 + 7 * gs_stack_left, gs_trim_out_mat,
						px1 - gs_tw_right_out,	0,	 0,  79, gs_trim_out_mat,
						0,						0,	 0, 900, gs_trim_out_mat,
						0,						archHeight - gs_tw_right_out,	0, 3079, gs_trim_out_mat,
						px2 + gs_tw_right_out,	0,	0, 3079, gs_trim_out_mat,
						px2 + gs_tw_right_out,	-EPS,  0, 8 + 7 * gs_stack_right, gs_trim_out_mat,
						px2,					0,	 0, 64 + mask - 2 + 4 * gs_trim_atframe_out * (WIDO_SILL>0), gs_trim_out_mat,
						0,						archHeight, 	0, 3064 + mask - 2 + 4 * gs_trim_atframe_out * (WIDO_SILL>0), gs_trim_out_mat,
						px1,					0, 	0, 3013 + 2 * gs_stack_left, gs_trim_out_mat,
						px1,					0, 	 0,   -1, gs_trim_out_mat

					! --- Draw missing lines ---
					if gs_stack_left  then lin_ px1 - gs_tw_right_out,0,0, px1 - gs_tw_right_out,0,gs_trim_thk_out
					if gs_stack_right then lin_ px2,0,0, px2,0,gs_trim_thk_out
				else
					addy B - archHeight

					ta = leftWidth - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out - widoHeadDepth - tolerOffsetUpperOut
					tc = arcR - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out - widoHeadDepth - tolerOffsetUpperOut
					py1L = sqr(max(0, tc * tc - ta * ta)) - arcR + archHeight

					ta = ta - gs_tw_right_out
					tc = tc - gs_tw_right_out
					py2L = sqr(max(0, tc * tc - ta * ta)) - arcR + archHeight

					ta = rightWidth - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out - widoHeadDepth - tolerOffsetUpperOut
					tc = arcR - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out - widoHeadDepth - tolerOffsetUpperOut
					py1R = sqr(max(0, tc * tc - ta * ta)) - arcR + archHeight

					ta = ta - gs_tw_right_out
					tc = tc - gs_tw_right_out
					py2R = sqr(max(0, tc * tc - ta * ta)) - arcR + archHeight

					if arcR - (A / 2 / archHeight) * widoHeadDepth < archHeight + EPS then
						cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
							8, gs_trim_thk_out,
							px1,					py2L, 		0,    8 + 7 * gs_stack_left, gs_trim_out_mat,
							px1 - gs_tw_right_out,	py1L,		0,   79, gs_trim_out_mat,
							0,						0,			0,  900, gs_trim_out_mat,
							0,						archHeight - gs_tw_right_out,	 0, 3079, gs_trim_out_mat,
							px2 + gs_tw_right_out,	py1R,		0, 3010 + 5 * gs_stack_right, gs_trim_out_mat,
							px2,					py2R,		0,   62 + mask, gs_trim_out_mat,
							0,						archHeight,	0, 3062 + mask, gs_trim_out_mat,
							px1,					py2L,		0, 3015, gs_trim_out_mat
					else
						cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
							8, gs_trim_thk_out,
							0,						archHeight - arcR, 0, 900, gs_trim_out_mat,
							px1,					py2L,	0,    8 + 7 * gs_stack_left, gs_trim_out_mat,
							px1 - gs_tw_right_out,	py1L,	0,   79, gs_trim_out_mat,
							0,						archHeight - widoHeadDepth - tolerOffsetUpperOut + gs_trim_offs_out - gs_trim_width_out + gs_tw_right_out,	0, 3079, gs_trim_out_mat,
							px2 + gs_tw_right_out,	py1R,	0, 3010 + 5 * gs_stack_right, gs_trim_out_mat,
							px2,					py2R,	0,   62 + mask, gs_trim_out_mat,
							0,						archHeight - widoHeadDepth - tolerOffsetUpperOut + gs_trim_offs_out - gs_trim_width_out, 	0, 3062 + mask, gs_trim_out_mat,
							px1,					py2L, 	0, 3015, gs_trim_out_mat
					endif

					lin_ px2,py2R,0,
						 px2,py2R,gs_trim_thk_out
					lin_ px1 - gs_tw_right_out,py1L,0,
						 px1 - gs_tw_right_out,py1L,gs_trim_thk_out
				endif

				del 1
			endif

			if iWindowShape = SHAPE_ELLIPSEARCH then

				resol nArchResolution

				px1 = -leftWidth + widoRightJamb + tolerOffsetLeftOut - gs_trim_offs_out + gs_trim_width_out
				px2 =  rightWidth - widoRightJamb - tolerOffsetRightOut + gs_trim_offs_out - gs_trim_width_out
				px3 = -leftWidth + widoRightJamb + tolerOffsetLeftOut
				px4 = rightWidth - widoRightJamb - tolerOffsetRightOut

				pxcL = -leftWidth + smallRadiusEllips
				pxcR = rightWidth - smallRadiusEllips

				py1 = B + overSizeTopOut - tolerOffsetUpperOut

				s1 = 9 + 4 * (abs(gs_trim_offs_out) > EPS | not(gs_trim_show_cover_out) | abs(gs_trim_thk_out) < EPS)

				cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					13,gs_trim_thk_out,
					px2,					py1 - archHeight,			0, s1,		gs_trim_out_mat,
					pxcR,					py1 - archHeight,			0, 900+s1,	gs_trim_out_mat,
					0,		 				alphaSide,					0, 4000+s1,	gs_trim_out_mat,
					0,						py1 - middleRadiusEllips, 	0, 900+s1,	gs_trim_out_mat,
					0,		 				alphaMiddle,				0, 4000+s1,	gs_trim_out_mat,
					pxcL,					py1 - archHeight,			0, 900+s1,	gs_trim_out_mat,
					0,		 				alphaSide,					0, 4008,	gs_trim_out_mat,
					px1 - gs_tw_right_out,	py1 - archHeight,			0, 13+64,	gs_trim_out_mat,
					0,		 				-alphaSide,					0, 4015+64,	gs_trim_out_mat,
					0,						py1 - middleRadiusEllips, 	0, 915+64,	gs_trim_out_mat,
					0,		 				-alphaMiddle,				0, 4015+64,	gs_trim_out_mat,
					pxcR,					py1 - archHeight,			0, 908+64,	gs_trim_out_mat,
					0,		 				-alphaSide,					0, 4008+64,	gs_trim_out_mat
			endif
			gosub "TextCoord_Hor"

			del 1


			if bCutWall then
				pen WALL_VIEW_PEN
				material matWallOut

				if	bShapeEnablesArchedTopTrim | \
					iWindowShape = SHAPE_ELLIPSEARCH then

					if iWindowShape = SHAPE_ELLIPSEARCH then
						put	pxWCutTopRightOut, pyWCutTopRightOut, 79,
							pxcR,				pyWCutTopRightOut,			979,
							0,		 			alphaSide,					4079,
							0,					py1 - middleRadiusEllips, 	979,
							0,		 			alphaMiddle,				4079,
							pxcL,				py1 - archHeight,			979,
							0,		 			alphaSide,					4079
					else
						if bHalfCircle then
							put	pxWCutTopRightOut, pyWCutTopRightOut, 79,
								0, B - tolerOffsetUpperIn - archHeight, 900,
								pxWCutTopLeftOut, pyWCutTopLeftOut, 3079
						else
							put pxWCutTopRightOut, pyWCutTopRightOut-EPS, 31,
								pxWCutTopRightOut, pyWCutTopRightOut, 79,
								0, B - tolerOffsetUpperIn - arcR, 900,
								pxWCutTopLeftOut, pyWCutTopLeftOut, 3031,
								pxWCutTopLeftOut, pyWCutTopLeftOut-EPS, 31
						endif
					endif
				else
					put pxWCutTopRightOut, pyWCutTopRightOut, 31
					if gs_trimtype_out_int = CASING_OVERHANG then
						put	pxWCutTopRightOut	+ gs_trimov_top_right_out/2, pyWCutTopRightOut, 31,
							pxWCutTopRightOut	+ gs_trimov_top_right_out,	pyWCutTopOHOut - 0.04, 31,
							pxWCutTopRightOut	+ gs_trimov_top_right_out,	pyWCutTopOHOut, 31,
							pxWCutTopLeftOut	- gs_trimov_top_left_out,	pyWCutTopOHOut, 31,
							pxWCutTopLeftOut	- gs_trimov_top_left_out,	pyWCutTopOHOut - 0.04, 31,
							pxWCutTopLeftOut	- gs_trimov_top_left_out/2, pyWCutTopRightOut, 31
					endif
					put	pxWCutTopLeftOut,	pyWCutTopLeftOut,	31
				endif

				put	pxWCutMidLeftOut, pyWCutMidLeftOut, 31

				if gs_trimtype_out_int = CASING_OVERHANG then
					put	pxWCutMidOHLeftOut, pyWCutMidLeftOut, 31,
						pxWCutMidOHLeftOut, pyWCutMidLeftOut + gs_trimov_bot_left_out, 31
				endif
				if not(isWindow) & bPShapedLeftOpening then
					put	pxWCutBotLeftOut, pyWCutMidLeftOut + gs_trimov_bot_left_out, 31,
						pxWCutBotLeftOut, pyWCutBotLeftOut, 31
				endif
				if not(isWindow) & bPShapedRightOpening then
					put	pxWCutBotRightOut, pyWCutBotRightOut, 31,
						pxWCutBotRightOut, pyWCutMidRightOut + gs_trimov_bot_right_out, 31
				endif
				if gs_trimtype_out_int = CASING_OVERHANG then
					put	pxWCutMidOHRightOut, pyWCutMidRightOut + gs_trimov_bot_right_out, 31,
						pxWCutMidOHRightOut, pyWCutMidRightOut, 31
				endif

				put	pxWCutMidRightOut, pyWCutMidRightOut, 31

!				prism_ nsp/3,-1,
!					use(nsp)

				wallniche nsp/3,1,16,
					0,0,1,0,
					get(nsp)

				pen gs_frame_pen
				material gs_trim_out_mat
			endif
		endif

		del 3
	else
		! ======================================
		! Outside Trim - Curved Walls
		! ======================================

		resol WALL_RESOL

		offsArc = iHolePosSign * AC_Hole_Position_Angle / 180 * PI * rSill

		if gs_IsCurved then
			thk = WIDO_SILL
		else
			thk = WALL_THICKNESS * 2
			rotx -180
			cutplane 180
			del 1
			numCutsFrame = 1
		endif

		if wallIsLeft then
			mask = 11 + 4 * (gs_trim_offs_out > EPS | not(bShowJambExtension) | not(gs_trim_show_cover_out))
		else
			mask = 14 + (gs_trim_offs_out > EPS | not(bShowJambExtension) | not(gs_trim_show_cover_out))
		endif

		if gs_trim_width_out > EPS & thk > EPS & bShowJambExtension then

			matTrim = gs_trim_out_mat

			material gs_trim_out_mat
			sect_fill gs_trim_fill_out, gs_trim_pen_bg_out, gs_trim_pen_fg_out, gs_trim_pen_cont_out

			! ===== Outside Trim - Curved Walls - Jamb Extensions =====

			rotx -180
			addz -WOD
			bCondition = WIDO_REVEAL_SIDE exor SYMB_MIRRORED
			roty (not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) + not(wallIsLeft) * 180
			addz rSill

			if	isWindow then
				py4 = -overSizeBottom + not(gs_stack_bottom) * (widoThresDepth * not(bTShapedOpening) + gs_trim_width_out * bParalellInCurvedWalls)
				py3 = py4 + not(gs_stack_bottom | not(bCasingBottomOutside) | bDrawLeftSLSill) * gs_trim_width_out * not(bParalellInCurvedWalls)
				py3l = py3
				py4l = py4
				py3r = py3
				py4r = py4

				s3 = 8 + 2 * not(gs_stack_bottom)	! 15 or 8
				s4 = 13 + 2 * not(gs_stack_bottom)	! 15 or 13
			else
				if	(bPShapedLeftOpening & gs_trim_below_sillLeft) then
					py4l = -overSizeBottomLeft + gs_trim_width_out * bParalellInCurvedWalls
					py3l = py4l + not(bDrawLeftSLSill) * gs_trim_width_out * not(bParalellInCurvedWalls)
				else
					py3l = -overSizeBottomLeft + bDrawLeftSLSill * widoThresDepth
					py4l = -overSizeBottomLeft + bDrawLeftSLSill * widoThresDepth
				endif
				if	(bPShapedRightOpening & gs_trim_below_sillRight) then
					py4r = -overSizeBottomRight + gs_trim_width_out * bParalellInCurvedWalls
					py3r = py4r + not(bDrawRightSLSill) * gs_trim_width_out * not(bParalellInCurvedWalls)
				else
					py3r = -overSizeBottomRight + bDrawRightSLSill * widoThresDepth
					py4r = -overSizeBottomRight + bDrawRightSLSill * widoThresDepth
				endif

				s3 = 15
				s4 = 15
			endif

			! --- Draw Left side Jamb Extension ---
			if bParalellInCurvedWalls then
				addz -rSill
				roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

				cutpolya 4, 1, 0,
					-leftWidth + widoLeftJamb,  -overSizeBottom + widoThresDepth,  0,
					-leftWidth * 3,  -overSizeBottom + widoThresDepth,  0,
					-leftWidth * 3, B + overSizeTop - widoHeadDepth, 0,
					-leftWidth + widoLeftJamb,  B + overSizeTop - widoHeadDepth,  5

				cutpolya 4, 1, 0,
					-leftWidth + widoLeftJamb + gs_trim_width_out,  -overSizeBottom + widoThresDepth,  7,
					rightWidth,  -overSizeBottom + widoThresDepth,  7,
					rightWidth, B + overSizeTop - widoHeadDepth, 7,
					-leftWidth + widoLeftJamb + gs_trim_width_out,  B + overSizeTop - widoHeadDepth,  1
				del 2
			endif

			px1 = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad + widoLeftJamb) - leftWidth * bParalellInCurvedWalls
			px2 = px1 + signWallIsLeft * gs_trim_width_out + 2 * leftWidth * bParalellInCurvedWalls

			if	bShapeEnablesStraightTopTrim then
				py1 = B + overSizeTop - not(gs_stack_top) * widoHeadDepth
				py2 = py1 - not(gs_stack_top) * gs_trim_width_out

				s1 = 8 + 2 * not(gs_stack_top)		! 15 or 8
				s2 = bitset (mask, 1, not(gs_stack_top))
			endif
			if	bShapeEnablesArchedTopTrim then
				ta = leftWidth - tolerOffsetLeftIn
				tc = arcR
				py1 = B - arcR + sqr(max(0, (tc * tc - ta * ta)))

				ta = ta - gs_trim_width_out
				tc = tc - gs_trim_width_out
				py2 = B - arcR + sqr(max(0, (tc * tc - ta * ta)))

				s1 = 8
				s2 = mask - 2
			endif

			if iWindowShape = SHAPE_ELLIPSEARCH then
				py1 = B - archHeight - tolerOffsetUpper
				py2 = B - archHeight - tolerOffsetUpper

				s1 = 8
				s2 = mask - 2
			endif

			if	bPShapedLeftOpening then
				py3l = py3l + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL
				py4l = py4l + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL
			endif

			if not(gs_stack_left | bLeftCornerFunction) then
				body -1
				bprism_ matTrim, matTrim, matTrim,
					4, -signWallIsLeft * thk, rSill,
					px1,	py1,	s1,
					px2,	py2,	s2,
					px2,	py3l,	s3,
					px1,	py4l,	s4
				gosub "TextCoord_Vert"
			endif

			if bParalellInCurvedWalls then
				cutend
				cutend
			endif

			! --- Draw Right side Jamb Extension ---
			if bParalellInCurvedWalls then
				addz -rSill
				roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

				cutpolya 4, 1, 0,
					rightWidth - widoRightJamb,  -overSizeBottom + widoThresDepth,  0,
					rightWidth * 3,  -overSizeBottom + widoThresDepth,  0,
					rightWidth * 3, B + overSizeTop - widoHeadDepth, 0,
					rightWidth - widoRightJamb,  B + overSizeTop - widoHeadDepth,  5

				cutpolya 4, 1, 0,
					rightWidth - widoRightJamb - gs_trim_width_out,  -overSizeBottom + widoThresDepth,  7,
					-leftWidth,  -overSizeBottom + widoThresDepth,  7,
					-leftWidth, B + overSizeTop - widoHeadDepth, 7,
					rightWidth - widoRightJamb - gs_trim_width_out,  B + overSizeTop - widoHeadDepth,  1
				del 2
			endif

			px1 = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad - widoRightJamb) + rightWidth * bParalellInCurvedWalls
			px2 = px1 - signWallIsLeft * gs_trim_width_out - rightWidth * bParalellInCurvedWalls * 2

			if	bShapeEnablesStraightTopTrim then
				py1 = B + overSizeTop - not(gs_stack_top) * (widoHeadDepth + gs_trim_width_out * bParalellInCurvedWalls)
				py2 = py1 - not(gs_stack_top) * gs_trim_width_out * not(bParalellInCurvedWalls)

				s1 = 8 + 2 * not(gs_stack_top)		! 15 or 8
				s2 = bitset (mask, 1, not(gs_stack_top))
			endif
			if	bShapeEnablesArchedTopTrim then
				ta = rightWidth - tolerOffsetRightIn
				tc = arcR
				py1 = B - arcR + sqr(max(0, (tc * tc - ta * ta)))

				ta = ta - gs_trim_width_out
				tc = tc - gs_trim_width_out
				py2 = B - arcR + sqr(max(0, (tc * tc - ta * ta)))

				s1 = 8
				s2 = mask - 2
			endif
			if iWindowShape = SHAPE_ELLIPSEARCH then
				py1 = B - archHeight - tolerOffsetUpper
				py2 = B - archHeight - tolerOffsetUpper

				s1 = 8
				s2 = mask - 2
			endif

			if	bPShapedRightOpening then
				py3r = py3r + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR
				py4r = py4r + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR
			endif

			if not(gs_stack_right | bRightCornerFunction) then
				body -1
				bprism_ matTrim, matTrim, matTrim,
					4, -signWallIsLeft * thk, rSill,
					 px1,	py1, 	s1,
					 px2,	py2, 	s2,
					 px2,	py3r,	s3,
					 px1,	py4r, 	s4
				gosub "TextCoord_Vert"
			endif

			if bParalellInCurvedWalls then
				cutend
				cutend
			endif

			if bTShapedOpening then

				del 3

				alphaLeft = abs(asn(leftRevealPnts[idxSillEndRevealLeft][1]  / radSill)) + 10
				alphaRight = abs(asn(rightRevealPnts[idxSillEndRevealright][1] / radSill)) + 10


				alfaEnd		= alphaRight + 10
				alfaStart	= -alphaLeft - 10
				arcRadius	= radSill
				bMiddlePoints = 1
				firstStatus	= 31
				midStatus	= 10 + 5 * (gs_trim_offs_out > EPS) + 64 + 16
				lastStatus	= 31
				if abs(alfaStart - alfaEnd) > EPS then
					gosub 110

					rotx 180
					rotx -90
					muly -1


					cutDepth = MAX(py3l, py3r)
					if not(wallIsLeft) then
!						prism_ NSP/3 + 2,-cutDepth,
!							radSill * sin(alphaRight), 2*WOD, 15,
!							-radSill * sin(alphaLeft), 2*WOD, 15,
!							use(nsp)
						cutpolya NSP/3 + 2,1,0,
							radSill * sin(alphaRight), 2*WOD, 15,
							-radSill * sin(alphaLeft), 2*WOD, 15,
							get(nsp)
					else
!							prism_ NSP/3 + 2,-cutDepth,
!								 radSill * sin(alphaLeft) + 2,  -radSill * cos(alphaLeft)  + WOD - 2, 15,
!								-radSill * sin(alphaRight) - 2, -radSill * cos(alphaRight) + WOD - 2, 15,
!								use(nsp)
						cutpolya NSP/3 + 2,1,0,
							 radSill * sin(alphaLeft) + 2,  -radSill * cos(alphaLeft)  + WOD - 2, 31,
							-radSill * sin(alphaRight) - 2, -radSill * cos(alphaRight) + WOD - 2, 31,
							get(nsp)
					endif
					del 3
				endif

				if	bPShapedLeftOpening & gs_trim_below_sillLeft then
					! --- Draw Door's Left side Jamb Extension ---

					px1lP = -leftWidth + gs_reveal_left_sL + gs_sidelight_WHole_width_left ! + tolerOffsetLeftIn
					px2lP = px1lP + gs_trim_width_out
					py1 = widoThresDepth
					py2 = widoThresDepth

					body -1
					sprism_ matTrim, matTrim, matTrim,
						4, 0,0, 0,1, thk - pocketThkLeft, wallIncl,
						 px1lP,	py1,	s1,
						 px2lP,	py2,	s2,
						 px2lP,	py3l,	s3,
						 px1lP,	py4l,	s4
					gosub "TextCoord_Vert"

					if	not(bDrawLeftSLSill) then
						! --- Draw Left Sidelight lower side Jamb Extension ---

						if not(bParalellInCurvedWalls) then

							addz -WOD
							roty -alfaLeftOut * signWallIsLeft  !+ atn((widoLeftJamb)  / WOD) * signWallIsLeft
							addz rBoard * signWallIsLeft
							addy py4l
							roty 90
							rotx 180 + 45 * not(gs_stack_left)

							!rect 1,1
							cutplane

							del 6
						endif

						px1l = -leftWidth - overSizeLeftOut - 1 * not(bParalellInCurvedWalls)
						px2l = px1l + gs_trim_width_out

						sprism_ matTrim, matTrim, matTrim,
							4, 0,0, 0,1, thk - pocketThkLeft, wallIncl,
							px2lP,	py3l,	15,
							px1lP,	py4l,	15,
							px1l,	py4l,	15,
							px2l,	py3l,	mask - 2 * gs_stack_left
						gosub "TextCoord_Hor"

						if not(bParalellInCurvedWalls) then cutend

					endif
				endif

				if	bPShapedRightOpening & gs_trim_below_sillRight then
					! --- Draw Door's Right side Jamb Extension ---

					px1rP = rightWidth - gs_reveal_right_sR - gs_sidelight_WHole_width_right ! + tolerOffsetLeftIn
					px2rP = px1rP - gs_trim_width_out
					py1 = widoThresDepth
					py2 = widoThresDepth

					body -1
					sprism_ matTrim, matTrim, matTrim,
						4, 0,0, 0,1, thk - pocketThkLeft, wallIncl,
						 px1rP,	py1,	s1,
						 px2rP,	py2,	s2,
						 px2rP,	py3r,	s3,
						 px1rP,	py4r,	s4
					gosub "TextCoord_Vert"

					if	not(bDrawRightSLSill) then
						! --- Draw Right Sidelight lower side Jamb Extension ---

						if not(bParalellInCurvedWalls) then
							addz -WOD
							roty alfaRightOut * signWallIsLeft
							addz rBoard * signWallIsLeft
							addy py4r
							roty 90
							rotx 360 - 45 * not(gs_stack_right)

							!rect 1,1
							cutplane

							del 6
						endif

						px1r = rightWidth + overSizeRightOut + 1 * not(bParalellInCurvedWalls)
						px2r = px1r - gs_trim_width_out

						sprism_ matTrim, matTrim, matTrim,
							4, 0,0, 0,1, thk - pocketThkLeft, wallIncl,
							px2rP,	py3r,	15,
							px1rP,	py4r,	15,
							px1r,	py4r,	15,
							px2r,	py3r,	mask - 2 * gs_stack_right
						gosub "TextCoord_Hor"

						if not(bParalellInCurvedWalls) then cutend

					endif
				endif

				if abs(alfaStart - alfaEnd) > EPS then cutend

				addz -WOD
				roty (not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) + not(wallIsLeft) * 180
				addz rSill
			endif


			if not(bParalellInCurvedWalls) then
				px1 = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad + widoLeftJamb)
				px2 = px1 + signWallIsLeft * (not(gs_stack_left) * gs_trim_width_out)
				px4 = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad - widoRightJamb)
				px3 = px4 - signWallIsLeft * (not(gs_stack_right) * gs_trim_width_out)
			else
				px1 = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad - leftWidth * not(gs_stack_left))
				px2 = px1
				px4 = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad + rightWidth * not(gs_stack_right))
				px3 = px4
			endif

			if not(gs_stack_bottom | not(bCasingBottomOutside) | bDrawSill | not(isWindow)) then
				if bParalellInCurvedWalls then
					addz -rSill
					roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

					if not(gs_stack_left) then
						cutpolya 4, 1, 0,
							-leftWidth + widoLeftJamb,  -overSizeBottom + widoThresDepth,  7,
							-leftWidth * 3,  -overSizeBottom + widoThresDepth,  7,
							-leftWidth * 3, B + overSizeTop - widoHeadDepth, 7,
							-leftWidth + widoLeftJamb,  B + overSizeTop - widoHeadDepth,  7
					endif

					if not(gs_stack_right) then
						cutpolya 4, 1, 0,
							rightWidth - widoRightJamb,  -overSizeBottom + widoThresDepth,  7,
							rightWidth * 3,  -overSizeBottom + widoThresDepth,  7,
							rightWidth * 3, B + overSizeTop - widoHeadDepth, 7,
							rightWidth - widoRightJamb,  B + overSizeTop - widoHeadDepth,  4
					endif
					del 2
				endif

				py1 = -overSizeBottom + widoThresDepth
				py2 = py1 + gs_trim_width_out

				bprism_ matTrim, matTrim, matTrim,
					4, -signWallIsLeft * thk, rSill,
					px1,	py1,	8 + 2 * not(gs_stack_left),			! 15 or 8
					px2,	py2,	bitset (mask, 1, not(gs_stack_left)),
					px3,	py2,	8 + 2 * not(gs_stack_right),		! 15 or 8
					px4,	py1,	13 + 2 * not(gs_stack_right)		! 15 or 13
				gosub "TextCoord_Hor"

				if bParalellInCurvedWalls then
					if not(gs_stack_left) then cutend
					if not(gs_stack_right) then cutend
				endif
			endif

			if bShapeEnablesStraightTopTrim & not(gs_stack_top) then
				! --- Draw upper Trim ---

				if bParalellInCurvedWalls then
					addz -rSill
					roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

					if not(gs_stack_left) then
						cutpolya 4, 1, 0,
							-leftWidth + widoLeftJamb,  -overSizeBottom + widoThresDepth,  7,
							-leftWidth * 3,  -overSizeBottom + widoThresDepth,  7,
							-leftWidth * 3, B + overSizeTop - widoHeadDepth, 7,
							-leftWidth + widoLeftJamb,  B + overSizeTop - widoHeadDepth,  7
					endif

					if not(gs_stack_right) then
						cutpolya 4, 1, 0,
							rightWidth - widoRightJamb,  -overSizeBottom + widoThresDepth,  7,
							rightWidth * 3,  -overSizeBottom + widoThresDepth,  7,
							rightWidth * 3, B + overSizeTop - widoHeadDepth, 7,
							rightWidth - widoRightJamb,  B + overSizeTop - widoHeadDepth,  4
					endif
					del 2
				endif

				py1 = B + overSizeTop - widoHeadDepth
				py2 = py1 - gs_trim_width_out

				bprism_ matTrim, matTrim, matTrim,
					4, -signWallIsLeft * thk, rSill,
					px1,	py1,	8 + 2 * not(gs_stack_left),			! 15 or 8
					px2,	py2,	bitset (mask, 1, not(gs_stack_left)),
					px3,	py2,	8 + 2 * not(gs_stack_right),		! 15 or 8
					px4,	py1,	13 + 2 * not(gs_stack_right)		! 15 or 13

				if bParalellInCurvedWalls then
					if not(gs_stack_left) then cutend
					if not(gs_stack_right) then cutend
				endif
			endif

			if	bShapeEnablesArchedTopTrim then

				resol WALL_RESOL

				px1 = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad + widoLeftJamb)
				px2 = px1 + signWallIsLeft * gs_trim_width_out
				px4 = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad - widoRightJamb)
				px3 = px4 - signWallIsLeft * gs_trim_width_out


				mulRatio = (leftWidth + rightWidth - widoLeftJamb - widoRightJamb) / abs(px1 - px4)
				addy B - archHeight
				muly mulRatio

				if bHalfCircle then
					bprism_ matTrim, matTrim, matTrim,
						8, -signWallIsLeft * thk, rSill,
						px1,	0, 	   8 + 7 * gs_stack_left,		! 15 or 8
						px2,	0,	  62 + mask,
						0,		1,	 800,
						px3,	0,	1008 + 7 * gs_stack_right,		! 1015 or 1008
						px4,	-EPS,  8 + 7 * gs_stack_right,		! 15 or 8
						px4,	0,	  79,
						0,		1,	 800,
						px1,	0, 	1015
				else

					ta = leftWidth
					tc = arcR
					py1 = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

					ta = ta - gs_trim_width_out
					tc = tc - gs_trim_width_out
					py2 = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

					bprism_ matTrim, matTrim, matTrim,
						6, -signWallIsLeft * thk, rSill,
						(px2 + px3) / 2,		(archHeight - arcR) / mulRatio, 900,
						px2,	py2, 	   8 + 7 * gs_stack_left,	! 15 or 8
						px1,	py1,	  79,
						px4,	py1,	3010 + 5 * gs_stack_right,	! 15 or 8
						px3,	py2,	  62 + mask,
						px2,	py2, 	3015
				endif

				del 2
			endif

			if iWindowShape = SHAPE_ELLIPSEARCH then

				offs = (leftWidth + overSizeLeftOut - (rSill * alfaLeft * DegRad))
				if wallIsLeft then
					s3 = 9 + 4 * (abs(gs_trim_offs_out) > EPS | not(gs_trim_show_cover_out) | abs(gs_trim_thk_out) < EPS) - 2 * gs_stack_right
				else
					s3 = 12 + 1 * (abs(gs_trim_offs_out) > EPS | not(gs_trim_show_cover_out) | abs(gs_trim_thk_out) < EPS) - 2 * gs_stack_right
				endif
				mulRatio = (archHeight / (archHeight + overSizeLeftOut - offs))

				addy B + ((archHeight * mulRatio) - archHeight)
				muly mulRatio

				bprism_ matTrim, matTrim, matTrim,
					13, -signWallIsLeft * thk, rSill,
					signWallIsLeft * offsArc + leftWidth + overSizeLeftOut - offs - widoLeftJamb,							-archHeight,			13,
					signWallIsLeft * offsArc + leftWidth - smallRadiusEllips,												-archHeight,			913,
					0,		 																								 alphaSide,			4013,
					signWallIsLeft * offsArc - (leftWidth - (rightWidth))/2,												-middleRadiusEllips, 	913,
					0,		 																								 alphaMiddle,			4013,
					signWallIsLeft * offsArc - rightWidth + smallRadiusEllips, 												-archHeight,			913,
					0,		 																								 alphaSide,			4008,
					signWallIsLeft * offsArc - rightWidth - overSizeLeftOut + widoRightJamb + offs + gs_trim_width_out,		-archHeight,			s3,
					0,		 																								-alphaSide,			4000+s3,
					signWallIsLeft * offsArc - (leftWidth - rightWidth)/2,													-middleRadiusEllips, 	900+s3,
					0,		 																								-alphaMiddle,			4000+s3,
					signWallIsLeft * offsArc + leftWidth - smallRadiusEllips,												-archHeight,			900+s3,
					0,		 																								-alphaSide,			4000+s3

				del 2
			endif
			gosub "TextCoord_Hor"

			del 4
		endif


		if numCutsFrame then
			cutend
			numCutsFrame = 0
		endif

		if not(gs_stack_left) then
			alfaLeftParallelOut = abs (asn ( (leftRevealPnts[idxSillStartRevealLeft][1] + tolerOffsetLeftOut + gs_trim_width_out) / rSill))
		else
			alfaLeftParallelOut = alfaLeft
		endif
		if not(gs_stack_right) then
			alfaRightParallelOut = abs (asn ( (rightRevealPnts[idxSillStartRevealRight][1] - tolerOffsetRightOut - gs_trim_width_out) / rSill))
		else
			alfaRightParallelOut = alfaRight
		endif

		if gs_trim_thk_out > EPS & gs_trim_show_cover_out & (gs_trimtype_out_int <> CASING_COMPLEX) then

			if iWindowShape = SHAPE_RECTANGULAR then

				if gs_stack_left then
					pxL = leftRevealPnts[idxSillEndRevealLeft][1]
				else
					pxL = leftRevealPnts[idxSillEndRevealLeft][1] + gs_trim_width_out + not(gs_stack_left) * (-gs_trim_offs_out + tolerOffsetLeftOut)
					alphaLeft = abs(asn(pxL / rSill)) + ArcLengthSillToAngle * gs_tw_left_out
					pxL = -rSill * sin(alphaLeft)
					pyL = -sqr(rSill^2 - pxL^2) - WOD
				endif
				if gs_stack_right then
					pxR = rightRevealPnts[idxSillEndRevealright][1]
				else
					pxR = rightRevealPnts[idxSillEndRevealright][1] - gs_trim_width_out - not(gs_stack_right) * (-gs_trim_offs_out + tolerOffsetRightOut)
					alphaRight = abs(asn(pxR / rSill)) + ArcLengthSillToAngle * gs_tw_right_out
					pxR = rSill * sin(alphaRight)
					pyR = -sqr(rSill^2 - pxR^2) - WOD
				endif
				if not(bParalellInCurvedWalls) then		! not USA type
					if isWindow & (not(bDrawSill) | bCasingBottomOutside) then
						if (bDrawSill) * bCasingBottomOutside & not(gs_stack_bottom) then
							pyB = sillBottomOutside - gs_tw_bottom_out
						else
							pyB = -overSizeBottom + not(gs_stack_bottom | not(bCasingBottomOutside)) * (widoThresDepth - gs_trim_offs_out + gs_trim_width_out - gs_tw_bottom_out)
						endif
					else
						pyB = (isWindow & bDrawSill) * (sillBottom + SillSideHeight)
					endif
				else
					if isWindow then
						if bDrawSill then
							pyB = -overSizeBottom + widoThresDepth + gs_trim_offs_out_bottom + not(gs_stack_bottom | not(bCasingBottomOutside)) * (-gs_trim_offs_out_bottom * not(gs_trim_atframe_out) - gs_tw_bottom_out)
						else
							pyB = -overSizeBottom + widoThresDepth + gs_trim_offs_out_bottom + not(gs_stack_bottom | not(bCasingBottomOutside)) * (gs_trim_width_out - gs_trim_offs_out * not(gs_trim_atframe_out) - gs_tw_bottom_out)
						endif
					else
						pyB = 0
					endif
				endif
				pyT = B + overSizeTop - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out - widoHeadDepth + gs_trim_offs_out_top + gs_tw_top_out

				if bCutWall then
					pen WALL_VIEW_PEN
					material matWallOut

					alfaEnd		= alphaRight
					alfaStart	= -alphaLeft
					arcRadius	= radSill
					bMiddlePoints = 1
					firstStatus	= 31
					midStatus	= 95
					lastStatus	= 31
					if abs(alfaStart - alfaEnd) > EPS then
						gosub 110

						rotx -90
						muly -1
						addz -pyB

						cutDepth = pyT - pyB
						if not(wallIsLeft) then
!							prism_ NSP/3 + 1,-cutDepth,
!								0,WOD,15,
!								use(nsp)
							wallniche NSP/3 + 1,1,0,
								0,0,-cutDepth,cutDepth,
								0,WOD,31,
								get(nsp)
						else
!							prism_ NSP/3 + 2,-cutDepth,
!								 (rSill + WALL_THICKNESS) * sin(alphaLeft),  -(rSill + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 15,
!								-(rSill + WALL_THICKNESS) * sin(alphaRight), -(rSill + WALL_THICKNESS) * cos(alphaRight) + WOD, 15,
!								use(nsp)
							wallniche NSP/3 + 2,1,0,
								0,0,-cutDepth,cutDepth,
								 (rSill + WALL_THICKNESS) * sin(alphaLeft),  -(rSill + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 31,
								-(rSill + WALL_THICKNESS) * sin(alphaRight), -(rSill + WALL_THICKNESS) * cos(alphaRight) + WOD, 31,
								get(nsp)
						endif
						del 3
					endif

					pen gs_frame_pen
					material gs_trim_out_mat
				endif
			endif

			if gs_trimtype_out_int = CASING_NORMAL & not(gs_stack_top) & iWindowShape = SHAPE_RECTANGULAR & (bTrimovtopleftout | bTrimovtoprightout) then

				if gs_stack_left then
					pxL = leftRevealPnts[idxSillEndRevealLeft][1]
				else
					pxL = leftRevealPnts[idxSillEndRevealLeft][1] + gs_trim_width_out + not(gs_stack_left) * (-gs_trim_offs_out + tolerOffsetLeftOut)
					alphaLeft = abs(asn(pxL / rSill)) + ArcLengthSillToAngle * (gs_tw_left_out + gs_trimov_top_left_out)
					pxL = -rSill * sin(alphaLeft)
					pyL = -sqr(rSill^2 - pxL^2) - WOD
				endif
				if gs_stack_right then
					pxR = rightRevealPnts[idxSillEndRevealright][1]
				else
					pxR = rightRevealPnts[idxSillEndRevealright][1] - gs_trim_width_out - not(gs_stack_right) * (-gs_trim_offs_out + tolerOffsetRightOut)
					alphaRight = abs(asn(pxR / rSill)) + ArcLengthSillToAngle * (gs_tw_right_out + gs_trimov_top_right_out)
					pxR = rSill * sin(alphaRight)
					pyR = -sqr(rSill^2 - pxR^2) - WOD
				endif
				pyB = B + overSizeTopOut - gs_trim_width_out + gs_trim_offs_out - tolerOffsetUpperOut
				pyT = pyB + gs_tw_top_out

				if bCutWall then
					pen WALL_VIEW_PEN
					material matWallOut

					alfaEnd		= alphaRight
					alfaStart	= -alphaLeft
					arcRadius	= radSill
					bMiddlePoints = 1
					firstStatus	= 31
					midStatus	= 95
					lastStatus	= 31
					if abs(alfaStart - alfaEnd) > EPS then
						gosub 110

						rotx -90
						muly -1
						addz -pyB

						cutDepth = pyT - pyB
						if not(wallIsLeft) then
!							prism_ NSP/3 + 1,-cutDepth,
!								0,WOD,15,
!								use(nsp)
							wallniche NSP/3 + 1,1,0,
								0,0,-cutDepth,cutDepth,
								0,WOD,31,
								get(nsp)
						else
!							prism_ NSP/3 + 2,-cutDepth,
!								 (rSill + WALL_THICKNESS) * sin(alphaLeft),  -(rSill + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 15,
!								-(rSill + WALL_THICKNESS) * sin(alphaRight), -(rSill + WALL_THICKNESS) * cos(alphaRight) + WOD, 15,
!								use(nsp)
							wallniche NSP/3 + 2,1,0,
								0,0,-cutDepth,cutDepth,
								 (rSill + WALL_THICKNESS) * sin(alphaLeft),  -(rSill + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 31,
								-(rSill + WALL_THICKNESS) * sin(alphaRight), -(rSill + WALL_THICKNESS) * cos(alphaRight) + WOD, 31,
								get(nsp)
						endif
						del 3
					endif

					pen gs_frame_pen
					material gs_trim_out_mat
				endif
			endif

			if isWindow & not(gs_stack_left) & iWindowShape = SHAPE_RECTANGULAR & bTrimovbotleftout then

				pxL = leftRevealPnts[idxSillEndRevealLeft][1] + gs_trim_width_out + not(gs_stack_left) * (-gs_trim_offs_out + tolerOffsetLeftOut)
				alphaLeft = abs(asn(pxL / rSill)) + ArcLengthSillToAngle * gs_tw_left_out
				pxL = -rSill * sin(alphaLeft)
				pyL = -sqr(rSill^2 - pxL^2) - WOD

				pxR = leftRevealPnts[idxSillEndRevealLeft][1] + gs_trim_width_out + not(gs_stack_left) * (-gs_trim_offs_out + tolerOffsetLeftOut)
				alphaRight = abs(asn(pxR / rSill))
				pxR = -rSill * sin(alphaRight)
				pyR = -sqr(rSill^2 - pxR^2) - WOD

				pyB = -overSizeBottom + not(gs_stack_bottom | not(bCasingBottomOutside)) * widoThresDepth + gs_trim_offs_out_bottom \
						+ gs_trim_width_out * not(bDrawSill) \
						- gs_trim_offs_out * not(gs_trim_atframe_out) \
						- gs_tw_bottom_out * bTrimovbotleftout \
			!!!			- 1 * (iSillType > 1 & bDrawBoard) \
						- gs_trimov_bot_left_out
				pyT = B + overSizeTop - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out - widoHeadDepth + gs_trim_offs_out_top + gs_tw_top_out

				if bCutWall then
					pen WALL_VIEW_PEN
					material matWallOut

					alfaEnd		= -alphaRight
					alfaStart	= -alphaLeft
					arcRadius	= radSill
					bMiddlePoints = 1
					firstStatus	= 31
					midStatus	= 95
					lastStatus	= 31
					if abs(alfaStart - alfaEnd) > EPS then
						gosub 110

						rotx -90
						muly -1
						addz -pyB

						cutDepth = pyT - pyB
						if not(wallIsLeft) then
!							prism_ NSP/3 + 1,-cutDepth,
!								0,WOD,15,
!								use(nsp)
							wallniche NSP/3 + 1,1,0,
								0,0,-cutDepth,cutDepth,
								0,WOD,31,
								get(nsp)
						else
!							prism_ NSP/3 + 2,-cutDepth,
!								-(rSill + WALL_THICKNESS) * sin(alphaRight), -(rSill + WALL_THICKNESS) * cos(alphaRight) + WOD, 15,
!								-(rSill + WALL_THICKNESS) * sin(alphaLeft),  -(rSill + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 15,
!								use(nsp)
							wallniche NSP/3 + 2,1,0,
								0,0,-cutDepth,cutDepth,
								-(rSill + WALL_THICKNESS) * sin(alphaRight), -(rSill + WALL_THICKNESS) * cos(alphaRight) + WOD, 31,
								-(rSill + WALL_THICKNESS) * sin(alphaLeft),  -(rSill + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 31,
								get(nsp)
						endif
						del 3
					endif

					pen gs_frame_pen
					material gs_trim_out_mat
				endif
			endif

			if isWindow & not(gs_stack_right) & iWindowShape = SHAPE_RECTANGULAR & bTrimovbotrightout then

				pxL = rightRevealPnts[idxSillEndRevealRight][1] - gs_trim_width_out - not(gs_stack_right) * (-gs_trim_offs_out + tolerOffsetRightOut)
				alphaLeft = abs(asn(pxL / rSill)) + ArcLengthSillToAngle * gs_tw_left_out
				pxL = -rSill * sin(alphaLeft)
				pyL = -sqr(rSill^2 - pxL^2) - WOD

				pxR = rightRevealPnts[idxSillEndRevealRight][1] - gs_trim_width_out - not(gs_stack_right) * (-gs_trim_offs_out + tolerOffsetRightOut)
				alphaRight = abs(asn(pxR / rSill))
				pxR = -rSill * sin(alphaRight)
				pyR = -sqr(rSill^2 - pxR^2) - WOD

				pyB = -overSizeBottom + not(gs_stack_bottom | not(bCasingBottomOutside)) * widoThresDepth + gs_trim_offs_out_bottom \
						+ gs_trim_width_out * not(bDrawSill) \
						- gs_trim_offs_out * not(gs_trim_atframe_out) \
						- gs_tw_bottom_out * bTrimovbotleftout \
			!!!			- 1 * (iSillType > 1 & bDrawBoard) \
						- gs_trimov_bot_left_out
				pyT = B + overSizeTop - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out - widoHeadDepth + gs_trim_offs_out_top + gs_tw_top_out

				if bCutWall then
					pen WALL_VIEW_PEN
					material matWallOut

					alfaEnd		= alphaRight
					alfaStart	= alphaLeft
					arcRadius	= radSill
					bMiddlePoints = 1
					firstStatus	= 31
					midStatus	= 95
					lastStatus	= 31
					if abs(alfaStart - alfaEnd) > EPS then
						gosub 110

						rotx -90
						muly -1
						addz -pyB

						cutDepth = pyT - pyB
						if not(wallIsLeft) then
!							prism_ NSP/3 + 1,-cutDepth,
!								0,WOD,15,
!								use(nsp)
							wallniche NSP/3 + 1,1,0,
								0,0,-cutDepth,cutDepth,
								0,WOD,31,
								get(nsp)
						else
!							prism_ NSP/3 + 2,-cutDepth,
!								(rSill + WALL_THICKNESS) * sin(alphaRight), -(rSill + WALL_THICKNESS) * cos(alphaRight) + WOD, 15,
!								(rSill + WALL_THICKNESS) * sin(alphaLeft),  -(rSill + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 15,
!								use(nsp)
							wallniche NSP/3 + 2,1,0,
								0,0,-cutDepth,cutDepth,
								(rSill + WALL_THICKNESS) * sin(alphaRight), -(rSill + WALL_THICKNESS) * cos(alphaRight) + WOD, 31,
								(rSill + WALL_THICKNESS) * sin(alphaLeft),  -(rSill + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 31,
								get(nsp)
						endif
						del 3
					endif

					pen gs_frame_pen
					material gs_trim_out_mat
				endif
			endif

			material gs_trim_out_mat
			sect_fill gs_trim_fill_out, gs_trim_pen_bg_out, gs_trim_pen_fg_out, gs_trim_pen_cont_out

			! ===== Outside Trim - Curved Walls - Casing =====

			if wallIsLeft then
				mask = 14 + (gs_trim_offs_out > EPS)
			else
				mask = 11 + 4 * (gs_trim_offs_out > EPS)
			endif

			maskTop		= 8 + 2 * not(gs_stack_top)
			maskBottom	= 8 + 2 * not(gs_stack_bottom)
			maskLeft	= 8 + (2 + 5 * bParalellInCurvedWalls) * not(gs_stack_left)
			maskRight	= 8 + 2 * not(gs_stack_right)

			maskLeft2	= bDrawSill*(not(bTrimovbotleftout)*(15-7*gs_stack_left)+bTrimovbotleftout*(10-2*gs_stack_left))
			maskRight2	= bDrawSill*(not(bTrimovbotrightout)*(15-7*gs_stack_right)+bTrimovbotrightout*(10-2*gs_stack_right))

			rotx -180
			addz -WOD
			bCondition = WIDO_REVEAL_SIDE exor SYMB_MIRRORED
			roty (not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) + not(wallIsLeft) * 180
			addz rSill


			if bShapeEnablesStraightTopTrim & not(gs_stack_top) then
				! --- Draw upper Trim ---

				if not(bParalellInCurvedWalls) then
					px1 = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad + widoLeftJamb + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_left_out - gs_trimov_top_left_out * bTrimovtopleftout))
					px2 = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad + widoLeftJamb + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out - (gs_tw_left_out + gs_trimov_top_left_out) * bTrimovtopleftout))
					px3 = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad + widoLeftJamb + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_left_out * bTrimovtopleftout))
					px4 = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad + widoLeftJamb + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out))
					px5 = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad - widoRightJamb + not(gs_stack_right) * (-gs_trim_width_out + gs_trim_offs_out))
					px6 = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad - widoRightJamb + not(gs_stack_right) * (-gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out * bTrimovtoprightout))
					px7 = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad - widoRightJamb + not(gs_stack_right) * (-gs_trim_width_out + gs_trim_offs_out + (gs_tw_right_out + gs_trimov_top_right_out) * bTrimovtoprightout))
					px8 = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad - widoRightJamb + not(gs_stack_right) * (-gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out + gs_trimov_top_right_out * bTrimovtoprightout))

					py2 = B + overSizeTop + not(gs_stack_top) * (-widoHeadDepth - gs_trim_width_out + gs_trim_offs_out)
					py1 = py2 + gs_tw_top_out
					py3 = py2
					py4 = py2
					py5 = py2
					py6 = py2
					py7 = py2
					py8 = py1

					s1 = 8 + 7 * not(gs_stack_left) * bTrimovtopleftout
					s2 = 15
					s3 = maskLeft
					s4 = bitset (mask, 1, not(gs_stack_left))
					s5 = maskRight
					s6 = 15
					s7 = 8 + 7 * not(gs_stack_right) * bTrimovtoprightout
					s8 = 13 + 2 * not(gs_stack_right)
				else
					px1 = signWallIsLeft * (offsArc - rSill * alfaLeftParallelout * DegRad + not(gs_stack_left) * (- gs_trim_offs_out - gs_tw_left_out - gs_trimov_top_left_out * bTrimovtopleftout))
					px2 = signWallIsLeft * (offsArc - rSill * alfaLeftParallelout * DegRad + not(gs_stack_left) * (- gs_trim_offs_out - gs_tw_left_out - gs_trimov_top_left_out * bTrimovtopleftout))
					px3 = signWallIsLeft * (offsArc - rSill * alfaLeftParallelout * DegRad + not(gs_stack_left) * (- gs_trim_offs_out - gs_tw_left_out))
					px4 = signWallIsLeft * (offsArc - rSill * alfaLeftParallelout * DegRad + not(gs_stack_left) * (- gs_trim_offs_out - gs_tw_left_out))

					px5 = signWallIsLeft * (offsArc + rSill * alfaRightParallelout * DegRad + not(gs_stack_right) * (gs_trim_offs_out + gs_tw_right_out))
					px6 = signWallIsLeft * (offsArc + rSill * alfaRightParallelout * DegRad + not(gs_stack_right) * (gs_trim_offs_out + gs_tw_right_out))
					px7 = signWallIsLeft * (offsArc + rSill * alfaRightParallelout * DegRad + not(gs_stack_right) * (gs_trim_offs_out + gs_tw_right_out + gs_trimov_top_right_out * bTrimovtoprightout))
					px8 = signWallIsLeft * (offsArc + rSill * alfaRightParallelout * DegRad + not(gs_stack_right) * (gs_trim_offs_out + gs_tw_right_out + gs_trimov_top_right_out * bTrimovtoprightout))

					py2 = B + overSizeTop + not(gs_stack_top) * (-widoHeadDepth - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out - EPS)
					py1 = py2 + gs_tw_top_out + EPS
					py3 = py2
					py4 = py2
					py5 = py2
					py6 = py2 + EPS
					py7 = py2 + EPS
					py8 = py1

					s1 = 8 + 7 * not(gs_stack_left)
					s2 = 15
					s3 = maskLeft
					s4 = 10	!bitset (mask, 1, not(gs_stack_left))
					s5 = maskRight
					s6 = 15
					s7 = 8 + 7 * not(gs_stack_right)
					s8 = 13 + 2 * not(gs_stack_right)
				endif

				if bParalellInCurvedWalls then
					add 0, 0, -rSill
					roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

!					cutpolya 4, 1, 0,
!						-leftWidth + widoLeftJamb + gs_trim_width_out + gs_trim_offs_out,  py3 - EPS - gs_tw_bottom_out * bTrimovbotleftout,  0,
!						-leftWidth * 3,  py3 - EPS - gs_tw_bottom_out * bTrimovbotleftout, 7,
!						-leftWidth * 3, py2 + EPS, 2,
!						-leftWidth + widoLeftJamb + gs_trim_width_out + gs_trim_offs_out,  py2 + EPS,  4 * not(bTrimovbotleftout)

					cutpolya 4, 1, 0,
						-leftWidth + widoLeftJamb + gs_trim_width_out - gs_trim_offs_out,  0,  6,
						rightWidth - widoRightJamb - gs_trim_width_out - gs_trim_offs_out,  0,  7,
						rightWidth - widoRightJamb - gs_trim_width_out - gs_trim_offs_out, py2 + EPS, 4 + 2 * not(gs_stack_right),
						-leftWidth + widoLeftJamb + gs_trim_width_out - gs_trim_offs_out,  py2 + EPS,  2 * not(gs_stack_left)

					cutpolya 4, 1, 0,
						rightWidth - widoRightJamb - gs_trim_width_out - gs_trim_offs_out,  py3 - EPS - gs_tw_bottom_out * bTrimovbotrightout,  0,
						rightWidth * 3,  py3 - EPS - gs_tw_bottom_out * bTrimovbotrightout,  7,
						rightWidth * 3, py2 + EPS, 2,
						rightWidth - widoRightJamb - gs_trim_width_out - gs_trim_offs_out,  py2 + EPS,  4 * not(bTrimovbotrightout)
					del 2
				endif

				if gs_trimtype_out_int = CASING_NORMAL then				! Rectangular casing type
					bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						8, signWallIsLeft * gs_trim_thk_out, rSill,
							px1, py1, s1,
							px2, py2, s2,
							px3, py3, s3,
							px4, py4, s4,
							px5, py5, s5,
							px6, py6, s6,
							px7, py7, s7,
							px8, py8, s8
				endif

				if gs_trimtype_out_int = CASING_OVERHANG then				! SWE traditional casing type
					bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						10, signWallIsLeft * gs_trim_thk_out, rSill,
							px1, py1, s1,
							px1, py1-0.04, s1,
							px3 + (px1 - px3)/2, py2, s2,
							px3, py3, s3,
							px4, py4, s4,
							px5, py5, s5,
							px6, py6, s6,
							px6 + (px8 - px6)/2, py7, s7,
							px8, py8-0.04, s7,
							px8, py8, s8
				endif

				if bParalellInCurvedWalls then
!					cutend
					cutend
					cutend
				endif
			endif

			if	bShapeEnablesArchedTopTrim then

				resol WALL_RESOL


				if not(bParalellInCurvedWalls) then
					px = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad + widoLeftJamb)
					px1 = px + signWallIsLeft * (gs_trim_width_out - gs_trim_offs_out - gs_tw_left_out)
					px2 = px + signWallIsLeft * (gs_trim_width_out - gs_trim_offs_out)
					px = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad - widoRightJamb)
					px3 = px + signWallIsLeft * (-gs_trim_width_out + gs_trim_offs_out)
					px4 = px + signWallIsLeft * (-gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out)
				else
					px2 = signWallIsLeft * (offsArc - rSill * alfaLeftParallelOut * DegRad + gs_trim_width_out - gs_trim_offs_out)
					px1 = signWallIsLeft * (offsArc - rSill * alfaLeftParallelOut * DegRad - gs_trim_offs_out) - signWallIsLeft * gs_tw_left_out
					px3 = signWallIsLeft * (offsArc + rSill * alfaRightParallelOut * DegRad - gs_trim_width_out + gs_trim_offs_out)
					px4 = signWallIsLeft * (offsArc + rSill * alfaRightParallelOut * DegRad + gs_trim_offs_out) + signWallIsLeft * gs_tw_right_out
				endif


				mulRatio = (leftWidth + rightWidth - tolerOffsetLeftIn - tolerOffsetRightIn) / (2 * abs(signWallIsLeft * rSill * alfaLeft * DegRad))
				addy B - archHeight - tolerOffsetUpperIn
				muly mulRatio

				if bHalfCircle then
					bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						9, signWallIsLeft * gs_trim_thk_out, rSill,
						px1,	-EPS, 	   8 + 7 * gs_stack_left,	! 15 or 8
						px1,	0, 	   8 + 7 * gs_stack_left,		! 15 or 8
						px2,	0,	  62 + mask,
						0,		1,	 800,
						px3,	0,	1008 + 7 * gs_stack_right,		! 1015 or 1008
						px4,	-EPS,  8 + 7 * gs_stack_right,		! 15 or 8
						px4,	0,	  79,
						0,		1,	 800,
						px1,	0, 	1079
				else

					ta = (leftWidth + rightWidth) / 2 - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out
					tc = arcR - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out
					py1 = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

					ta = ta - gs_tw_right_out
					tc = tc - gs_tw_right_out
					py2 = sqr(max(0, (tc * tc - ta * ta))) - arcR + archHeight

					bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						6, signWallIsLeft * gs_trim_thk_out, rSill,
						(px2 + px3) / 2,		(archHeight - arcR) / mulRatio, 900,
						px2,	py2, 	   8 + 7 * gs_stack_left,	! 15 or 8
						px1,	py1,	  79,
						px4,	py1,	3010 + 5 * gs_stack_right,	! 15 or 8
						px3,	py2,	  62 + mask,
						px2,	py2, 	3015
				endif

				del 2
			endif

			if iWindowShape = SHAPE_ELLIPSEARCH then

				offs = (leftWidth + overSizeLeftOut - (rSill * alfaLeft * DegRad))
				if wallIsLeft then
					s3 = 12 + 1 * (abs(gs_trim_offs_out) > EPS | not(gs_trim_show_cover_out) | abs(gs_trim_thk_out) < EPS) - 2 * gs_stack_right
				else
					s3 = 9 + 4 * (abs(gs_trim_offs_out) > EPS | not(gs_trim_show_cover_out) | abs(gs_trim_thk_out) < EPS) - 2 * gs_stack_right
				endif
				mulRatio = (archHeight / (archHeight + overSizeLeftOut - offs))

				addy B - tolerOffsetUpper + ((archHeight * mulRatio) - archHeight)
				muly mulRatio
				offs = (leftWidth + overSizeLeftOut - (rSill * alfaLeft * DegRad + gs_trim_offs_out - gs_trim_width_out))

				bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					13, signWallIsLeft * gs_trim_thk_out, rSill,
					signWallIsLeft * offsArc + leftWidth + overSizeLeftOut - offs - widoLeftJamb,						-archHeight,		s3,
					signWallIsLeft * offsArc + leftWidth - smallRadiusEllips,											-archHeight,		900+s3,
					0,		 																							 alphaSide,		4000+s3,
					signWallIsLeft * offsArc - (leftWidth - rightWidth)/2,												-middleRadiusEllips, 	900+s3,
					0,		 																							 alphaMiddle,		4000+s3,
					signWallIsLeft * offsArc - rightWidth + smallRadiusEllips, 											-archHeight,		900+s3,
					0,		 																							 alphaSide,		4008,
					signWallIsLeft * offsArc - rightWidth - overSizeLeftOut + widoRightJamb + offs - gs_tw_left_out,	-archHeight,		79,
					0,		 																							-alphaSide,		4079,
					signWallIsLeft * offsArc - (leftWidth - rightWidth)/2,												-middleRadiusEllips, 	979,
					0,		 																							-alphaMiddle,		4079,
					signWallIsLeft * offsArc + leftWidth - smallRadiusEllips,											-archHeight,		979,
					0,		 																							-alphaSide,		4008

				del 2
			endif
			gosub "TextCoord_Hor"


			! ===== Outside Trim - Curved Walls - Casing - Sides =====

			if	isWindow | \
				bTShapedOpening then
				py = -overSizeBottomLeft + not(gs_stack_bottom) * widoThresDepth + gs_trim_offs_out_bottom

				s3 = maskBottom						! 15 or 10 or 8
				if not(bParalellInCurvedWalls) then
					s4 = 13 + 2 * (not(gs_stack_bottom)) 	! 15 or 13
				else
					s4 = 13 + 2 * (not(gs_stack_bottom)) * bDrawSill
				endif
			else
				py	= -overSizeBottomLeft + bDrawSill * widoThresDepth
				py3 = -overSizeBottomLeft + bDrawSill * widoThresDepth
				py4 = -overSizeBottomLeft + bDrawSill * widoThresDepth

				s3 = 15
				s4 = 15
			endif
			py3l = py
			py4l = py

			! --- Draw left side Trim ---

			if not(bParalellInCurvedWalls) then
				px2 = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad + gs_trim_width_out - gs_trim_offs_out + widoLeftJamb)
				px1 = px2 - signWallIsLeft * gs_tw_left_out
			else
				px2 = signWallIsLeft * (offsArc - rSill * alfaLeftParallelOut * DegRad + gs_trim_width_out - gs_trim_offs_out)
				px1 = signWallIsLeft * (offsArc - rSill * alfaLeftParallelOut * DegRad - gs_trim_offs_out) - signWallIsLeft * gs_tw_left_out
			endif


!			if	(isWindow | \
!				(bPShapedLeftOpening & gs_trim_below_sillLeft)) & ABS(gs_trimov_bot_left_out) < EPS then
!				py3l = py + not(gs_stack_bottom | not(bCasingBottomOutside) | (bDrawLeftSLSill & not(gs_trim_below_sillLeft))) * (gs_trim_width_out - gs_trim_offs_out)
!				py4l = py + not(gs_stack_bottom | not(bCasingBottomOutside) | (bDrawLeftSLSill & not(gs_trim_below_sillLeft))) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_bottom_out)
!			endif

			if gs_stack_bottom then
				py3l = -overSizeBottom
				py4l = py3l
				py5 = py3l
				py6 = py3l
			else
				if not(bCasingBottomOutside) then
					py3l = py
					py4l = py3l
					py5 = py3l
					py6 = py3l
				else
					if	isWindow | \
						(bPShapedLeftOpening & gs_trim_below_sillLeft) then
						py3l = py \
								+ gs_trim_width_out * not(bDrawLeftSLSill) \
								- gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawLeftSLSill) \
								- gs_tw_bottom_out * bTrimovbotleftout \
								- gs_trimov_bot_left_out

						if not(gs_trim_atframe_out) then
							py4l = py \
									+ gs_trim_width_out * not(bDrawLeftSLSill) \
									- gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawLeftSLSill) \
									- gs_tw_bottom_out * (not(bDrawLeftSLSill) | (bDrawLeftSLSill & (bTrimovbotleftout | gs_trim_below_sillLeft))) \
									- gs_trimov_bot_left_out

						else
							py4l = py3l - (gs_trimov_bot_left_out + gs_tw_bottom_out * (bTrimovbotleftout=0) * gs_trimb_atframe_out * not(bDrawLeftSLSill))
						endif
					endif

					py5 = py3l + (gs_trimov_bot_left_out + gs_tw_bottom_out) * bTrimovbotleftout
					py6 = py3l + gs_trimov_bot_left_out * bTrimovbotleftout
				endif
			endif

			if	bPShapedLeftOpening then
				py3l = py3l + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL - gs_reveal_bottom
				py4l = py4l + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL - gs_reveal_bottom
				py5 = py5 + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL - gs_reveal_bottom
				py6 = py6 + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL - gs_reveal_bottom
			endif

			if	bShapeEnablesStraightTopTrim then
				py2 = B + overSizeTop + not(gs_stack_top) * (-widoHeadDepth - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out)
				if not(bParalellInCurvedWalls) then
					py1 = B + overSizeTop + not(gs_stack_top) * (-widoHeadDepth - gs_trim_width_out + gs_trim_offs_out + gs_tw_top_out*not(bTrimovtoprightout))
				else
					py1 = py2
				endif


				if	isWindow | \
					(bPShapedLeftOpening & gs_trim_below_sillLeft) then
					s6 = maskBottom*not(bTrimovbotleftout)+(15-2*not(gs_tw_bottom_out))*bTrimovbotleftout
					if not(gs_stack_bottom) & not(bCasingBottomOutside) then
						s3 = 15
					else
						s3 = (maskBottom+5*not(gs_tw_bottom_out))*not(bTrimovbotleftout)+bTrimovbotleftout*(15-7*gs_stack_bottom)
					endif
				else
					s6 = 15
					s3 = 15
				endif

				s1 = maskTop				! 15 or 10 or 8
				s2 = bitset (mask, 1, not(gs_stack_top))
				s5 = 8
			endif
			if	bShapeEnablesArchedTopTrim then
				ta = leftWidth - gs_trim_width_out + gs_trim_offs_out
				tc = arcR + tolerOffsetUpperIn - gs_trim_width_out + gs_trim_offs_out
				py2 = B - arcR - tolerOffsetUpperIn + sqr(max(0, (tc * tc - ta * ta)))


				ta = ta + gs_tw_right_out
				tc = tc + gs_tw_right_out
				py1 = B - arcR - tolerOffsetUpperIn + sqr(max(0, (tc * tc - ta * ta)))


				if	isWindow | \
					(bPShapedLeftOpening & gs_trim_below_sillLeft) then
					s6 = maskBottom*not(bTrimovbotleftout)+(15-2*not(gs_tw_bottom_out))*bTrimovbotleftout
					if not(gs_stack_bottom) & not(bCasingBottomOutside) then
						s3 = 15
					else
						s3 = (maskBottom+5*not(gs_tw_bottom_out))*not(bTrimovbotleftout)+bTrimovbotleftout*(15-7*gs_stack_bottom)
					endif
				else
					s6 = 15
					s3 = 15
				endif

				s1 = 8
				s2 = mask - 2
				s5 = 8
			endif

			if iWindowShape = SHAPE_ELLIPSEARCH then
				py1 = B - archHeight - tolerOffsetUpper
				py2 = B - archHeight - tolerOffsetUpper

				s1 = 8
				s2 = mask - 2
			endif

			if gs_stack_left then
				px1LUp = px2 - gs_trim_width_out + gs_trim_offs_out
				px2LUp = px1LUp
			else
				px1LUp = px1 * not(bTrimovbotleftout) + px2 * bTrimovbotleftout
				px2LUp = px2
			endif

			if not(gs_stack_left | bLeftCornerFunction) then
				if bParalellInCurvedWalls then
					add 0, 0, -rSill
					roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

					cutpolya 6, 1, 0,
						leftRevealPnts[idxSillStartRevealLeft][1] + tolerOffsetLeftOut + gs_trim_width_out - gs_trim_offs_out,  py5,  2,
						leftRevealPnts[idxSillStartRevealLeft][1] + tolerOffsetLeftOut + gs_trim_width_out - gs_trim_offs_out,  py6,  7,
						leftRevealPnts[idxSillStartRevealLeft][1] + tolerOffsetLeftOut + gs_trim_width_out - gs_trim_offs_out,  -overSizeBottom - (gs_trimov_bot_left_out + gs_tw_bottom_out),  7,
						rightRevealPnts[idxSillStartRevealRight][1], -overSizeBottom - (gs_trimov_bot_left_out + gs_tw_bottom_out),  7,
						rightRevealPnts[idxSillStartRevealRight][1], B + overSizeTop - widoHeadDepth, 4,
						leftRevealPnts[idxSillStartRevealLeft][1] + tolerOffsetLeftOut + gs_trim_width_out - gs_trim_offs_out,  B + overSizeTop - widoHeadDepth,  1
					del 2
				endif

				body -1
				bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					4+2, signWallIsLeft * gs_trim_thk_out, rSill,
					px1,	py1,	s1,
					px2,	py2,	s2,
					px2,	py5,	s5,
					px2,	py6,	s6,
					px2,	py3l,	s3,
					px1,	py4l,	s4
				gosub "TextCoord_Vert"

				if bParalellInCurvedWalls then
					cutend
				endif
			endif

			! --- Draw right side Trim ---

			if	isWindow | \
				bTShapedOpening then
				py = -overSizeBottomRight + not(gs_stack_bottom) * widoThresDepth + gs_trim_offs_out_bottom
			else
				py	= -overSizeBottomRight + bDrawSill * widoThresDepth
				py3 = -overSizeBottomRight + bDrawSill * widoThresDepth
				py4 = -overSizeBottomRight + bDrawSill * widoThresDepth
			endif
			py3r = py
			py4r = py

			if not(bParalellInCurvedWalls) then
				px2 = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad - gs_trim_width_out + gs_trim_offs_out - widoRightJamb)
				px1 = px2 + signWallIsLeft * gs_tw_right_out
			else
				px2 = signWallIsLeft * (offsArc + rSill * alfaRightParallelOut * DegRad - gs_trim_width_out + gs_trim_offs_out)
				px1 = signWallIsLeft * (offsArc + rSill * alfaRightParallelOut * DegRad + gs_trim_offs_out) + signWallIsLeft * gs_tw_right_out
			endif

!!			if	(isWindow | \
!!				(bPShapedRightOpening & gs_trim_below_sillRight)) & ABS(gs_trimov_bot_right_out) < EPS then
!!				py3r = py + not(gs_stack_bottom | not(bCasingBottomOutside) | (bDrawRightSLSill & not(gs_trim_below_sillRight))) * (gs_trim_width_out - gs_trim_offs_out)
!!				py4r = py + not(gs_stack_bottom | not(bCasingBottomOutside) | (bDrawRightSLSill & not(gs_trim_below_sillRight))) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_bottom_out)
!!			endif

			if gs_stack_bottom then
				py3r = -overSizeBottom
				py4r = py3r
				py5 = py3r
				py6 = py3r
			else
				if not(bCasingBottomOutside) then
					py3r = py
					py4r = py3r
					py5 = py3r
					py6 = py3r
				else
					if	isWindow | \
						(bPShapedRightOpening & gs_trim_below_sillRight) then
						py3r = py \
								+ gs_trim_width_out * not(bDrawRightSLSill) \
								- gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawRightSLSill) \
								- gs_tw_bottom_out * bTrimovbotrightout \
								- gs_trimov_bot_right_out
						if not(gs_trim_atframe_out) then
							py4r = py \
									+ gs_trim_width_out * not(bDrawRightSLSill) \
									- gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawRightSLSill) \
									- gs_tw_bottom_out*(not(bDrawRightSLSill) | (bDrawRightSLSill & (bTrimovbotrightout | gs_trim_below_sillRight))) \
									- gs_trimov_bot_right_out
						else
							py4r = py3r - (gs_trimov_bot_left_out + gs_tw_bottom_out * (bTrimovbotleftout=0) * gs_trimb_atframe_out * not(bDrawRightSLSill))
						endif
					endif

					py5 = py3r + (gs_trimov_bot_right_out + gs_tw_bottom_out) * bTrimovbotrightout
					py6 = py3r + gs_trimov_bot_right_out * bTrimovbotrightout
				endif
			endif

			if	bPShapedRightOpening then
				py3r = py3r + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR - gs_reveal_bottom
				py4r = py4r + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR - gs_reveal_bottom
				py5 = py5 + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR - gs_reveal_bottom
				py6 = py6 + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sR - gs_reveal_bottom
			endif

			if	bShapeEnablesStraightTopTrim then
				py2 = B + overSizeTop + not(gs_stack_top) * (-widoHeadDepth - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out)
				if not(bParalellInCurvedWalls) then
					py1 = B + overSizeTop + not(gs_stack_top) * (-widoHeadDepth - gs_trim_width_out + gs_trim_offs_out + gs_tw_top_out * not(bTrimovtoprightout))
				else
					py1 = py2
				endif

				if	isWindow | \
					(bPShapedRightOpening & gs_trim_below_sillRight) then
					s6 = maskBottom*not(bTrimovbotrightout)+(15-2*not(gs_tw_bottom_out))*bTrimovbotrightout
					if not(gs_stack_bottom) & not(bCasingBottomOutside) then
						s3 = 15
					else
						s3 = (maskBottom+5*not(gs_tw_bottom_out))*not(bTrimovbotrightout)+bTrimovbotrightout*(15-7*gs_stack_bottom)
					endif
				else
					s6 = 15
					s3 = 15
				endif

				s1 = maskTop				! 15 or 10 or 8
				s2 = bitset (mask, 1, not(gs_stack_top))
				s5 = 8
			endif
			if	bShapeEnablesArchedTopTrim then
				ta = rightWidth - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out
				tc = arcR + tolerOffsetUpperIn - gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out
				py1 = B - arcR - tolerOffsetUpperIn + sqr(max(0, (tc * tc - ta * ta)))


				ta = ta - gs_tw_right_out
				tc = tc - gs_tw_right_out
				py2 = B - arcR - tolerOffsetUpperIn + sqr(max(0, (tc * tc - ta * ta)))


				if	isWindow | \
					(bPShapedRightOpening & gs_trim_below_sillRight) then
					s6 = maskBottom*not(bTrimovbotrightout)+(15-2*not(gs_tw_bottom_out))*bTrimovbotrightout
					if not(gs_stack_bottom) & not(bCasingBottomOutside) then
						s3 = 15
					else
						s3 = (maskBottom+5*not(gs_tw_bottom_out))*not(bTrimovbotrightout)+bTrimovbotrightout*(15-7*gs_stack_bottom)
					endif
				else
					s6 = 15
					s3 = 15
				endif

				s1 = 8
				s2 = mask - 2
				s5 = 8
			endif

			if iWindowShape = SHAPE_ELLIPSEARCH then
				py1 = B - archHeight - tolerOffsetUpper
				py2 = B - archHeight - tolerOffsetUpper

				s1 = 8
				s2 = mask - 2
			endif

			if gs_stack_right then
				px1RUp = px2 + gs_trim_width_out - gs_trim_offs_out
				px2RUp = px1RUp
			else
				px1RUp = px1 * not(bTrimovbotrightout) + px2 * bTrimovbotrightout
				px2RUp = px2
			endif

			if not(gs_stack_right | bRightCornerFunction) then
				if bParalellInCurvedWalls then
					add 0, 0, -rSill
					roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

					cutpolya 6, 1, 0,
						rightRevealPnts[idxSillStartRevealRight][1] - tolerOffsetRightOut - gs_trim_width_out + gs_trim_offs_out,  py5,  2,
						rightRevealPnts[idxSillStartRevealRight][1] - tolerOffsetRightOut - gs_trim_width_out + gs_trim_offs_out,  py6,  7,
						rightRevealPnts[idxSillStartRevealRight][1] - tolerOffsetRightOut - gs_trim_width_out + gs_trim_offs_out,  -overSizeBottom - (gs_trimov_bot_right_out + gs_tw_bottom_out),  7,
						leftRevealPnts[idxSillStartRevealLeft][1], -overSizeBottom - (gs_trimov_bot_right_out + gs_tw_bottom_out),  7,
						leftRevealPnts[idxSillStartRevealLeft][1], B + overSizeTop - widoHeadDepth, 4,
						rightRevealPnts[idxSillStartRevealRight][1] - tolerOffsetRightOut - gs_trim_width_out + gs_trim_offs_out,  B + overSizeTop - widoHeadDepth,  1
					del 2
				endif

				body -1
				bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					4+2, signWallIsLeft * gs_trim_thk_out, rSill,
					px1,	py1,	s1,
					px2,	py2,	s2,
					px2,	py5,	s5,
					px2,	py6,	s6,
					px2,	py3r,	s3,
					px1,	py4r,	s4
				gosub "TextCoord_Vert"

				if bParalellInCurvedWalls then
					cutend
				endif
			endif


			if	bTShapedOpening then

				py1 = widoThresDepth
				py2 = widoThresDepth

				px1l = 0
				px2l = 0
				if bPShapedLeftOpening then
					px1l = signWallIsLeft * (offsArc + rSill * alfaLeftLSL * DegRad + gs_trim_thk_out)							!gs_trim_thk_out is a safety
					px2l = px1l - signWallIsLeft * gs_trim_below_sillLeft * gs_tw_left_out - signWallIsLeft * gs_trim_thk_out	!gs_trim_thk_out is a safety

					py3l = py4l + gs_trimov_bot_left_out
					py4l = py3l + gs_tw_bottom_out
				endif
				px1r = 0
				px2r = 0
				if bPShapedRightOpening then
					px1r = signWallIsLeft * (offsArc + rSill * alfaRightRSL * DegRad - gs_trim_thk_out)							!gs_trim_thk_out is a safety
					px2r = px1r + signWallIsLeft * gs_trim_below_sillRight * gs_tw_right_out + signWallIsLeft * gs_trim_thk_out	!gs_trim_thk_out is a safety
					py3r = py4r + gs_trimov_bot_right_out
					py4r = py3r + gs_tw_bottom_out
				endif

				add 0, -gs_tw_bottom_out, -rSill
				roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180


!					prism_ 4,7,
!						-leftWidth + gs_reveal_left_sL + gs_sidelight_WHole_width_left + gs_trim_width_out - gs_trim_offs_out,  py1,  15,
!						rightWidth - gs_reveal_right_sR - gs_sidelight_WHole_width_right - gs_trim_width_out + gs_trim_offs_out,  py1,  (11 + 4 * (gs_trim_offs_out > EPS))*WIDO_REVEAL_SIDE + (14 + (gs_trim_offs_out > EPS))*not(WIDO_REVEAL_SIDE),
!						rightWidth - gs_reveal_right_sR - gs_sidelight_WHole_width_right - gs_trim_width_out + gs_trim_offs_out,  MAX(py4l, py4r) + gs_tw_bottom_out,  15,
!						-leftWidth + gs_reveal_left_sL + gs_sidelight_WHole_width_left + gs_trim_width_out - gs_trim_offs_out, MAX(py4l, py4r) + gs_tw_bottom_out,  (11 + 4 * (gs_trim_offs_out > EPS))*WIDO_REVEAL_SIDE + (14 + (gs_trim_offs_out > EPS))*not(WIDO_REVEAL_SIDE)

				cutpolya 4, 1, 0,
					-leftWidth + gs_reveal_left_sL + gs_sidelight_WHole_width_left + gs_trim_width_out - gs_trim_offs_out,  py1,  15,
					rightWidth - gs_reveal_right_sR - gs_sidelight_WHole_width_right - gs_trim_width_out + gs_trim_offs_out,  py1,  (11 + 4 * (gs_trim_offs_out > EPS))*WIDO_REVEAL_SIDE + (14 + (gs_trim_offs_out > EPS))*not(WIDO_REVEAL_SIDE),
					rightWidth - gs_reveal_right_sR - gs_sidelight_WHole_width_right - gs_trim_width_out + gs_trim_offs_out,  MAX(py4l, py4r) + gs_tw_bottom_out,  15,
					-leftWidth + gs_reveal_left_sL + gs_sidelight_WHole_width_left + gs_trim_width_out - gs_trim_offs_out, MAX(py4l, py4r) + gs_tw_bottom_out,  (11 + 4 * (gs_trim_offs_out > EPS))*WIDO_REVEAL_SIDE + (14 + (gs_trim_offs_out > EPS))*not(WIDO_REVEAL_SIDE)


				del 2

				if bPShapedLeftOpening & gs_trim_below_sillLeft then
					! --- Draw Door's Left side Trim  Curved Wall---
					bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, signWallIsLeft * gs_trim_thk_out, rSill,
						px1l,	py1,	15,
						px2l,	py2,	s4,
						px2l,	py3l,	s5,
						px1l,	py4l,	s2
					gosub "TextCoord_Vert"
				endif
				if bPShapedRightOpening & gs_trim_below_sillRight then
					! --- Draw Door's Right side Trim  Curved Wall---
					bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, signWallIsLeft * gs_trim_thk_out, rSill,
						px1r,	py1,	15,
						px2r,	py2,	s4,
						px2r,	py3r,	s5,
						px1r,	py4r,	s2
					gosub "TextCoord_Vert"
				endif

				if bPShapedLeftOpening & gs_trim_below_sillLeft then
					! --- Draw Left lower Trim  Curved Wall---
					bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, signWallIsLeft * gs_trim_thk_out, rSill,
						px2LUp,	py4l,	10 - 2 * gs_stack_left,
						px1LUp,	py3l,	15,
						px2l,	py3l,	10 + 5 * not(gs_trim_below_sillLeft),
						px1l,	py4l,	mask - 2 * gs_stack_left
					gosub "TextCoord_Hor"
				endif

				if bPShapedRightOpening & gs_trim_below_sillRight then
					! --- Draw Right lower Trim  Curved Wall---
					bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
						4, signWallIsLeft * gs_trim_thk_out, rSill,
						px2RUp,	py4r,	10 - 2 * gs_stack_right,
						px1RUp,	py3r,	15,
						px2r,	py3r,	10 + 5 * not(gs_trim_below_sillRight),
						px1r,	py4r,	mask - 2 * gs_stack_right
					gosub "TextCoord_Hor"
				endif

				cutend
			endif

			del 4
		endif

	endif	! not(curvedWall)

	! ===== Outside Trim - Curved Walls - Casing - Bottom Side =====
	if curvedWall  & (gs_trimtype_out_int <> CASING_COMPLEX) then
		resol WALL_RESOL

		offsArc = iHolePosSign * AC_Hole_Position_Angle / 180 * PI * rSill

		if gs_IsCurved then
			thk = WIDO_SILL + gs_trim_jambext_nosing_out
		else
			thk = WALL_THICKNESS + gs_trim_jambext_nosing_out
			rotx -180
			cutplane 180
			del 1
			numCutsFrame = 1
		endif


		if numCutsFrame then
			cutend
			numCutsFrame = 0
		endif

		if not(gs_stack_left) then
			alfaLeftParallelOut = abs (asn ( (leftRevealPnts[idxSillStartRevealLeft][1] + tolerOffsetLeftOut + gs_trim_width_out) / rSill))
		else
			alfaLeftParallelOut = alfaLeft
		endif
		if not(gs_stack_right) then
			alfaRightParallelOut = abs (asn ( (rightRevealPnts[idxSillStartRevealRight][1] - tolerOffsetRightOut - gs_trim_width_out) / rSill))
		else
			alfaRightParallelOut = alfaRight
		endif

		if gs_trim_thk_out > EPS & gs_trim_show_cover_out then

			material gs_trim_out_mat
			sect_fill gs_trim_fill_out, gs_trim_pen_bg_out, gs_trim_pen_fg_out, gs_trim_pen_cont_out

			! ===== Outside Trim - Curved Walls - Casing =====

			if wallIsLeft then
				mask = 14 + (gs_trim_offs_out > EPS)
			else
				mask = 11 + 4 * (gs_trim_offs_out > EPS)
			endif

			maskTop		= 8 + 2 * not(gs_stack_top)
			maskBottom	= 8 + 2 * not(gs_stack_bottom)
			maskLeft	= 8 + (2 + 5 * bParalellInCurvedWalls) * not(gs_stack_left)
			maskRight	= 8 + 2 * not(gs_stack_right)

			maskLeft2	= bDrawSill*(not(bTrimovbotleftout)*(15-7*gs_stack_left)+bTrimovbotleftout*(10-2*gs_stack_left))
			maskRight2	= bDrawSill*(not(bTrimovbotrightout)*(15-7*gs_stack_right)+bTrimovbotrightout*(10-2*gs_stack_right))

			rotx -180
			addz -WOD
			bCondition = WIDO_REVEAL_SIDE exor SYMB_MIRRORED
			roty (not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) + not(wallIsLeft) * 180
			addz rSill


			! ===== Outside Trim - Curved Walls - Casing - Top and Bottom Sides =====

			if not(gs_stack_bottom | not(bCasingBottomOutside) | not(isWindow)) & abs(gs_tw_bottom_out) > EPS & not(gs_trimb_atframe_out) then
				! --- Draw lower Trim ---

				if not(bParalellInCurvedWalls) then
					px1 = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad + widoLeftJamb + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_left_out*not(bTrimovbotleftout)))
					px2 = px1
					px3 = signWallIsLeft * (offsArc - rSill * alfaLeft * DegRad + widoLeftJamb + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out))
					px4 = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad - widoRightJamb + not(gs_stack_right) * (-gs_trim_width_out + gs_trim_offs_out))
					px5 = signWallIsLeft * (offsArc + rSill * alfaRight * DegRad - widoRightJamb + not(gs_stack_right) * (-gs_trim_width_out + gs_trim_offs_out + gs_tw_right_out*not(bTrimovbotrightout)))
					px6 = px5

					py1 = -overSizeBottom + not(gs_stack_bottom | not(bCasingBottomOutside)) * (widoThresDepth + gs_trim_width_out*not(bDrawSill) - gs_trim_offs_out * not(bDrawSill) - gs_tw_bottom_out)
					py2 = py1 + gs_tw_bottom_out * (bDrawSill & not(bCasingBottomOutside))
					py3 = -overSizeBottom + not(gs_stack_bottom | not(bCasingBottomOutside)) * (widoThresDepth + gs_trim_width_out*not(bDrawSill) - gs_trim_offs_out * not(bDrawSill))
					py4 = py3
					py5 = py2
					py6 = py1

					s1 = maskLeft*not(bDrawSill)+maskLeft2*bDrawSill
					s2 = maskLeft
					s3 = bitset (mask, 1, not(gs_stack_left))
					s4 = maskRight
					s5 = maskRight*not(bDrawSill)+maskRight2*bDrawSill
					s6 = 13 + 2 * not(gs_stack_right)
				else
					px1 = signWallIsLeft * (offsArc - rSill * alfaLeftParallelOut * DegRad + not(gs_stack_left) * (gs_trim_width_out*0 - gs_trim_offs_out - gs_tw_left_out))
					px2 = px1
					px3 = signWallIsLeft * (offsArc - rSill * alfaLeftParallelOut * DegRad + not(gs_stack_left) * (gs_trim_width_out*0 - gs_trim_offs_out - gs_tw_left_out))
					px4 = signWallIsLeft * (offsArc + rSill * alfaRightParallelOut * DegRad + not(gs_stack_right) * (-gs_trim_width_out*0 + gs_trim_offs_out + gs_tw_right_out ))
					px5 = px4
					px6 = px5

					py1 = -overSizeBottom + not(gs_stack_bottom | not(bCasingBottomOutside)) * (widoThresDepth + gs_trim_width_out * (not(bDrawSill) & not(gs_trim_atframe_out)) - gs_tw_bottom_out)
					py2 = py1 + gs_tw_bottom_out * bDrawSill
					py3 = -overSizeBottom + not(gs_stack_bottom | not(bCasingBottomOutside)) * (widoThresDepth + gs_trim_width_out * (not(bDrawSill) & not(gs_trim_atframe_out))) + EPS
					py4 = py3 + EPS
					py5 = py2
					py6 = py1

					s1 = maskLeft * not(bDrawSill) + maskLeft2 * bDrawSill
					s2 = maskLeft
					s3 = bitset (mask, 1, not(gs_stack_left))
					s4 = 13	+ 2 * (bDrawSill | gs_trim_atframe_out) * not(gs_stack_right) - 5 * gs_stack_right
					s5 = maskRight * not(bDrawSill) + maskRight2 * bDrawSill
					s6 = 13 + 2 * not(gs_stack_right)
				endif

				if bParalellInCurvedWalls then
					addz -rSill
					roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

					maskOutCasatFrame = 0
					if gs_trim_atframe_out then maskOutCasatFrame = 15


					cutpolya 4, 1, 0,
						-leftWidth + widoLeftJamb + gs_trim_width_out + gs_trim_offs_out,  py3 - EPS - gs_tw_bottom_out * bTrimovbotleftout,  maskOutCasatFrame,
						-leftWidth * 3,  py3 - EPS - gs_tw_bottom_out * bTrimovbotleftout,  7,
						-leftWidth * 3, B + overSizeTop, 7,
						-leftWidth + widoLeftJamb + gs_trim_width_out + gs_trim_offs_out,  B + overSizeTop,  1 * not(bTrimovbotleftout) + bTrimovbotleftout * maskOutCasatFrame

					cutpolya 4, 1, 0,
						rightWidth - widoRightJamb - gs_trim_width_out - gs_trim_offs_out,  py3 - EPS - gs_tw_bottom_out * bTrimovbotrightout,  4 * gs_stack_right,
						rightWidth * 3,  py3 - EPS - gs_tw_bottom_out * bTrimovbotrightout,  7,
						rightWidth * 3, B + overSizeTop, 7,
						rightWidth - widoRightJamb - gs_trim_width_out - gs_trim_offs_out,  B + overSizeTop,  1 * not(bTrimovbotrightout) + bTrimovbotleftout * maskOutCasatFrame

					del 2
				endif

				if gs_fsill then
					addz -rSill
					roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180
					addz WOD
					cutplane gs_sill_angle - 90
					del 3
				endif

				bprism_ gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					4+2, signWallIsLeft * gs_trim_thk_out, rSill,
						px1,	py1, 	s1,
						px2,	py2, 	s2,
						px3,	py3,	s3,
						px4,	py4,	s4,
						px5,	py5, 	s5,
						px6,	py6, 	s6
				gosub "TextCoord_Hor"

				if gs_fsill then cutend

				if bParalellInCurvedWalls then
					cutend
					cutend
				endif
			endif

			del 4
		endif
	endif


	! ===== Outside Trim on Wall Face at Complex Casing =====

	if (gs_trimtype_out_int = CASING_COMPLEX) & (gs_trim_thk_out > EPS) then

		material gs_trim_out_mat
		pen gs_frame_pen
		sect_fill gs_trim_fill_out, gs_trim_pen_bg_out, gs_trim_pen_fg_out, gs_trim_pen_cont_out

		rotx 180
		addz WIDO_SILL
		mulz -1

		_casingOverhangTopSideOut = gs_trimov_top_right_out

		_casingLeftPosX		= -leftWidth + gs_trim_width_out - gs_trim_offs_out + widoLeftJamb + tolerOffsetLeftOut
		_casingRightPosX 	= rightWidth - gs_trim_width_out + gs_trim_offs_out - widoRightJamb - tolerOffsetRightOut
		_casingTopPosY		= B + overSizeTop + not(gs_stack_top) * (-widoHeadDepth - tolerOffsetUpperOut - gs_trim_width_out + gs_trim_offs_out + gs_trim_offs_out_top)
		_trimThick	= gs_trim_thk_out

		! --- Architrave capital ---

		group "capital"

			if bArchitraveCapital & not(gs_stack_top) then

				if not(gs_stack_left | bLeftCornerFunction) then
					_trimWidth	= gs_tw_left_out

					add  _casingLeftPosX - gs_tw_left_out*not(_bArchitraveCapitalOnSide), _casingTopPosY + gs_tw_top_out - min(gs_trim_thk_out, (gs_tw_top_out)/8), -gs_trim_thk_out
					roty 90
					mulz -1
					gosub "architrave capital type"
					del 3
				endif

				if not(gs_stack_right | bRightCornerFunction) then
					_trimWidth	= gs_tw_right_out

					add  _casingRightPosX + gs_tw_right_out*not(_bArchitraveCapitalOnSide), _casingTopPosY + gs_tw_top_out - min(gs_trim_thk_out, (gs_tw_top_out)/8), -gs_trim_thk_out
					roty 90
					gosub "architrave capital type"
					del 2
				endif

			endif

		endgroup


		group "sidehead"

			! --- Draw upper Trim ---

			if not(gs_stack_top) then

				m1 = not(gs_stack_left)
				m2 = not(gs_stack_right)

				_casingHeadLeftPosX		= -leftWidth - overSizeLeft + widoLeftJamb + tolerOffsetLeftOut + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_left_out - _casingOverhangTopSideOut)
				_casingHeadRightPosX 	= rightWidth + overSizeRight - widoRightJamb - tolerOffsetRightOut - not(gs_stack_right) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_right_out - _casingOverhangTopSideOut)

				_trimWidth	= gs_tw_top_out
				_trimLength	= abs(_casingHeadLeftPosX - _casingHeadRightPosX)

				add  _casingHeadLeftPosX, _casingTopPosY, 0
				rotx -90
				roty 90

				gosub "casing head type"

				del 3
			endif


			addz -gs_trim_thk_out

			! Calculate status codes to left and right casing shape
			s1 = 8 + 7*not(gs_stack_top)
			s2 = 13 + 2*not(gs_stack_top)
			s3 = 8 + 7*not(gs_stack_bottom)
			s4 = 13 + 2*not(gs_stack_bottom)

			! --- Draw left side Trim ---

			if (isWindow | bPShapedLeftOpening) & not(gs_stack_bottom | not(bCasingBottomOutside)) then
				_casingLeftBottomPosY = -overSizeBottomLeft + widoThresDepth + gs_trim_width_out * not(bDrawLeftSLSill) - gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawLeftSLSill)
			else
				_casingLeftBottomPosY = -overSizeBottomLeft
			endif

			if bPShapedLeftOpening then
				_casingLeftBottomPosY = _casingLeftBottomPosY + gs_sidelight_parapet_hgt_left + gs_reveal_bottom_sL - gs_reveal_bottom
			endif

			if not(gs_stack_left | bLeftCornerFunction) then
				body -1

				cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					4, _trimThick,
					_casingLeftPosX,					_casingTopPosY,			0, s1, gs_trim_out_mat,
					_casingLeftPosX - gs_tw_left_out,	_casingTopPosY,			0, s2, gs_trim_out_mat,
					_casingLeftPosX - gs_tw_left_out,	_casingLeftBottomPosY,	0, s3, gs_trim_out_mat,
					_casingLeftPosX,					_casingLeftBottomPosY,	0, s4, gs_trim_out_mat
				gosub "TextCoord_Vert"

			endif


			! --- Draw right side Trim ---

			if (isWindow | bTShapedOpening) & not(gs_stack_bottom | not(bCasingBottomOutside)) then
				_casingRightBottomPosY	= -overSizeBottomRight + widoThresDepth + gs_trim_width_out * not(bDrawRightSLSill) - gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawRightSLSill)
			else
				_casingRightBottomPosY	= -overSizeBottomRight
			endif

			if bPShapedRightOpening then
				_casingRightBottomPosY = _casingRightBottomPosY + gs_sidelight_parapet_hgt_right + gs_reveal_bottom_sL - gs_reveal_bottom
			endif

			if not(gs_stack_right | bRightCornerFunction) then
				body -1

				cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
					4, _trimThick,
					_casingRightPosX,					_casingTopPosY,			0, s1, gs_trim_out_mat,
					_casingRightPosX + gs_tw_right_out,	_casingTopPosY,			0, s2, gs_trim_out_mat,
					_casingRightPosX + gs_tw_right_out,	_casingRightBottomPosY,	0, s3, gs_trim_out_mat,
					_casingRightPosX,					_casingRightBottomPosY,	0, s4, gs_trim_out_mat
				gosub "TextCoord_Vert"

			endif

			del 1

		endgroup

		placegroup "sidehead"
		placegroup subgroup("capital", "sidehead")

		killgroup "sidehead"
		killgroup "capital"


		! --- T and P shape's extra casing pieces ---

		if bPShapedLeftOpening & gs_trim_below_sillLeft then
			_casingDoorLeftPosX 		= leftRevealPnts[idxSillStartRevealLeft][1] + gs_sidelight_WHole_width_left  + gs_trim_width_out - gs_trim_offs_out
			_casingDoorLeftTopPosY		= _casingLeftBottomPosY - gs_tw_bottom_out
			_casingDoorLeftBottomPosY	= _widoThresDepth
			_casingParapetLeftPosX		= -leftWidth - overSizeLeft + widoLeftJamb + tolerOffsetLeftOut + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_left_out - casingOverhangBottomSideOut)

			! --- Draw Door's Left side Trim ---

			addz -gs_trim_thk_out

			body -1

			cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
				4, _trimThick,
				_casingDoorLeftPosX ,					_casingDoorLeftTopPosY,		0, 15, gs_trim_out_mat,
				_casingDoorLeftPosX - gs_tw_left_out,	_casingDoorLeftTopPosY,		0, 15, gs_trim_out_mat,
				_casingDoorLeftPosX - gs_tw_left_out,	_casingDoorLeftBottomPosY,	0, 15, gs_trim_out_mat,
				_casingDoorLeftPosX ,					_casingDoorLeftBottomPosY,	0, 15, gs_trim_out_mat
			gosub "TextCoord_Vert"

			del 1

			! --- Draw Left lower Trim in Straight Wall ---

			_trimWidth	= gs_tw_bottom_out
			_trimLength	= abs(_casingParapetLeftPosX - _casingDoorLeftPosX)

			add  _casingParapetLeftPosX, _casingLeftBottomPosY - _trimWidth, 0
			rotx -90
			roty 90

			m1 = not(gs_stack_left)
			m2 = 1

			gosub "casing head type"

			del 3

		endif


		if	bPShapedRightOpening & gs_trim_below_sillRight then
			_casingDoorRightPosX 		= rightRevealPnts[idxSillStartRevealRight][1] - gs_sidelight_WHole_width_right  - gs_trim_width_out + gs_trim_offs_out
			_casingDoorRightTopPosY		= _casingRightBottomPosY - gs_tw_bottom_out
			_casingDoorRightBottomPosY	= _widoThresDepth
			_casingParapetRightPosX		= rightWidth + overSizeRight - widoRightJamb - tolerOffsetRightOut - not(gs_stack_right) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_right_out - casingOverhangBottomSideOut)

			! --- Draw Door's Right side Trim ---

			addz -gs_trim_thk_out

			body -1

			cprism_{2} gs_trim_out_mat, gs_trim_out_mat, gs_trim_out_mat,
				4, _trimThick,
				_casingDoorRightPosX,					_casingDoorRightTopPosY,	0, 15, gs_trim_out_mat,
				_casingDoorRightPosX + gs_tw_right_out,	_casingDoorRightTopPosY,	0, 15, gs_trim_out_mat,
				_casingDoorRightPosX + gs_tw_right_out,	_casingDoorRightBottomPosY,	0, 15, gs_trim_out_mat,
				_casingDoorRightPosX,					_casingDoorRightBottomPosY,	0, 15, gs_trim_out_mat
			gosub "TextCoord_Vert"

			del 1

			! --- Draw Right lower Trim in Straight Wall ---

			_trimWidth	= gs_tw_bottom_out
			_trimLength	= abs(_casingParapetRightPosX - _casingDoorRightPosX)

			add  _casingDoorRightPosX, _casingRightBottomPosY - _trimWidth, 0
			rotx -90
			roty 90

			m1 = 1
			m2 = not(gs_stack_right)

			gosub "casing head type"

			del 3

		endif


		! --- Draw lower Trim ---

		if not(gs_stack_bottom | not(bCasingBottomOutside) | not(isWindow)) then
			_casingHeadLeftPosX		= -leftWidth - overSizeLeft + widoLeftJamb + tolerOffsetLeftOut + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_left_out - casingOverhangBottomSideOut)
			_casingHeadRightPosX 	= rightWidth + overSizeRight - widoRightJamb - tolerOffsetRightOut - not(gs_stack_right) * (gs_trim_width_out - gs_trim_offs_out - gs_tw_right_out - casingOverhangBottomSideOut)
			_casingBottomPosY		= -overSizeBottom + widoThresDepth + gs_trim_width_out*not(bDrawSill) - gs_trim_offs_out * not(gs_trim_atframe_out) * not(bDrawSill)

			_trimWidth	= gs_tw_bottom_out
			_trimLength	= abs(_casingHeadLeftPosX - _casingHeadRightPosX)

			add  _casingHeadLeftPosX, _casingBottomPosY - _trimWidth, 0
			rotx -90
			roty 90

			m1 = not(gs_stack_left)
			m2 = not(gs_stack_right)

			gosub "casing head type"

			del 3
		endif

		del 3
	endif


	! ===== Outside Trim at Ganging =====

	if bDrawLeftTrimatGangingOut then
		if isWindow then
			py = -overSizeBottom + not(gs_stack_bottom) * widoThresDepth

			s3 = maskBottom						! 15 or 10 or 8
			s4 = 13 + 2 * not(gs_stack_bottom)	! 15 or 13
		else
			py3 = -overSizeBottom
			py4 = -overSizeBottom

			s3 = 15
			s4 = 15
		endif

		! --- Draw left side Trim at Ganging ---

		px2 = leftRevealPnts[2][1] + tolerOffsStackCasLeftOut + trim_offs_out_modify - gs_trim_offs_out
		px1 = leftRevealPnts[2][1]
		px3 = leftRevealPnts[2][1] - gs_trim_thk_out * tan(alfaLeft)

		if iWindowShape = SHAPE_RECTANGULAR then
			py1 = B + overSizeTop + not(gs_stack_top) * (- tolerOffsetUpperOut - widoHeadDepth - gs_trim_width_out + gs_trim_offs_out)
			py2 = py1

			py = -overSizeBottom + not(gs_stack_bottom) * (widoThresDepth + gs_trim_offs_out_bottom)

			if bDrawSill then
				py3 = py + not(gs_stack_bottom) * (-gs_trim_offs_out_bottom * not(gs_trim_atframe_out))
			else
				py3 = py + not(gs_stack_bottom) * (gs_trim_width_out - gs_trim_offs_out * not(gs_trim_atframe_out))
			endif

			py4 = py3
			py5 = py2 - (tolerOffsStackCasUpperOut + trim_offs_out_modify - gs_trim_offs_out) * gs_trim_stack_top * gs_trim_stack_top
			py6 = py3 + (tolerOffsStackCasLowerOut + trim_offs_out_modify - gs_trim_offs_out) * gs_trim_stack_bottom * gs_trim_stack_bottom

			s1 = 8
			s2 = 8
			s5 = 13 + 2 * (gs_trim_stack_top | (not(gs_trim_stack_top) & not(gs_trim_atframe_out)))
			s3 = 8
			s4 = 8
			s6 = 8
		endif

		rotx 180
		mulz -1
		add 0, 0, -gs_trim_thk_out

		add px1, 0, gs_trim_thk_out
		roty - alfaLeft * ySign - 90
		cutplane 1, 1, 0
		del 2

		body -1

		prism_ 	6, gs_trim_thk_out,
			px3,	py1,	s1,
			px2,	py2,	s2,
			px2,	py5,	s5,
			px2,	py6,	s6,
			px2,	py3,	s3,
			px3,	py4,	s4
		gosub "TextCoord_Vert"

		cutend

		del 3
	endif

	if bDrawRightTrimatGangingOut then
		if isWindow then
			py = -overSizeBottom + not(gs_stack_bottom) * widoThresDepth

			s3 = maskBottom						! 15 or 10 or 8
			s4 = 13 + 2 * not(gs_stack_bottom)	! 15 or 13
		else
			py3 = -overSizeBottom
			py4 = -overSizeBottom

			s3 = 15
			s4 = 15
		endif

		! --- Draw right side Trim at Ganging ---

		px2 = rightRevealPnts[2][1] - tolerOffsStackCasRightOut - trim_offs_out_modify + gs_trim_offs_out
		px1 = rightRevealPnts[2][1]
		px3 = rightRevealPnts[2][1] + gs_trim_thk_out * tan(alfaright)

		if iWindowShape = SHAPE_RECTANGULAR then
			py1 = B + overSizeTop + not(gs_stack_top) * (- tolerOffsetUpperOut - widoHeadDepth - gs_trim_width_out + gs_trim_offs_out)
			py2 = py1

			py = -overSizeBottom + not(gs_stack_bottom) * (widoThresDepth + gs_trim_offs_out_bottom)

			if bDrawSill then
				py3 = py + not(gs_stack_bottom) * (-gs_trim_offs_out_bottom * not(gs_trim_atframe_out))
			else
				py3 = py + not(gs_stack_bottom) * (gs_trim_width_out - gs_trim_offs_out * not(gs_trim_atframe_out))
			endif

			py4 = py3
			py5 = py2 - (tolerOffsStackCasUpperOut + trim_offs_out_modify - gs_trim_offs_out) * gs_trim_stack_top * gs_trim_stack_top
			py6 = py3 + (tolerOffsStackCasLowerOut + trim_offs_out_modify - gs_trim_offs_out) * gs_trim_stack_bottom * gs_trim_stack_bottom


			s1 = 8
			s2 = 8
			s5 = 13 + 2 * (gs_trim_stack_top | (not(gs_trim_stack_top) & not(gs_trim_atframe_out)))
			s3 = 8
			s4 = 8
			s6 = 8
		endif

		rotx 180
		mulz -1
		add 0, 0, -gs_trim_thk_out

		add px1, 0, gs_trim_thk_out
		roty alfaright * ySign + 90
		cutplane 1, 1, 0
		del 2

		body -1

		prism_ 	6, gs_trim_thk_out,
			px3,	py1,	s1,
			px2,	py2,	s2,
			px2,	py5,	s5,
			px2,	py6,	s6,
			px2,	py3,	s3,
			px3,	py4,	s4
		gosub "TextCoord_Vert"

		cutend

		del 3
	endif


	if bDrawBottTrimatGangingOut then
		! --- Draw lower Trim at Ganging ---

		if gs_stack_left then
			px1 = -leftWidth + tolerOffsStackCasLeftOut + trim_offs_out_modify - gs_trim_offs_out
		else
			px1 = -leftWidth + gs_trim_width_out - gs_trim_offs_out + widoLeftJamb + tolerOffsetLeftOut
		endif

		if gs_stack_right then
			px2 = rightWidth - tolerOffsStackCasRightOut - trim_offs_out_modify + gs_trim_offs_out
		else
			px2 = rightWidth - gs_trim_width_out + gs_trim_offs_out - widoRightJamb - tolerOffsetRightOut
		endif

		py2 = -overSizeBottom
		py1 = py2 + tolerOffsStackCasLowerOut + trim_offs_out_modify - gs_trim_offs_out

		s1 = 15
		s2 = 10
		s3 = 8
		s4 = 8

		rotx 180
		mulz -1
		add 0, 0, -gs_trim_thk_out

		addz WIDO_SILL * (gs_trim_atframe_out = 0)

		prism_ 4, gs_trim_thk_out,
			px1,	py1, 	s1,
			px2,	py1, 	s2,
			px2,	py2,	s3,
			px1,	py2,	s4
		gosub "TextCoord_Hor"

		del 4
	endif

	if bDrawTopTrimatGangingOut then
		! --- Draw upper Trim at Ganging ---

		if gs_stack_left then
			px1 = -leftWidth + tolerOffsStackCasLeftOut + trim_offs_out_modify - gs_trim_offs_out
		else
			px1 = -leftWidth + gs_trim_width_out - gs_trim_offs_out + widoLeftJamb + tolerOffsetLeftOut
		endif

		if gs_stack_right then
			px2 = rightWidth - tolerOffsStackCasRightOut - trim_offs_out_modify + gs_trim_offs_out
		else
			px2 = rightWidth - gs_trim_width_out + gs_trim_offs_out - widoRightJamb - tolerOffsetRightOut
		endif

		py2 = B + overSizeTop
		py1 = py2 - tolerOffsStackCasUpperOut - trim_offs_out_modify + gs_trim_offs_out

		s1 = 15
		s2 = 10
		s3 = 8
		s4 = 8

		rotx 180
		mulz -1
		add 0, 0, -gs_trim_thk_out

		addz WIDO_SILL * (gs_trim_atframe_out = 0)

		prism_ 4, gs_trim_thk_out,
			px1,	py1, 	s1,
			px2,	py1, 	s2,
			px2,	py2,	s3,
			px1,	py2,	s4
		gosub "TextCoord_Hor"

		del 4
	endif

	for i=1 to numCutsCornerColumn
		cutend
	next i
return


3000:
! ==============================================================================
!	Draw Apron
! ==============================================================================

	pen gs_frame_pen

	rotx 180

	if not(curvedWall) then

		! ======================================
		! Straight Walls
		! ======================================

		addz (-WALL_THICKNESS + WIDO_SILL) * not(gs_trim_atframe_in) - WIDO_FRAME_THICKNESS * gs_trim_atframe_in

		thk = WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS
		wallIncl = iDir * WALL_INCL

		mask = 11 + 4 * (gs_trim_offs_in > EPS | not(bShowJambExtension) | abs(WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS) < EPS)

		if gs_trim_thk_in > EPS then

			material gs_apron_mat
			sect_fill gs_trim_fill_in, gs_trim_pen_bg_in, gs_trim_pen_fg_in, gs_trim_pen_cont_in

			! ===== Inside Trim - Straight Walls - Casing =====

			maskTop		= 8 + 2 * not(gs_stack_top)
			maskBottom	= 8 + 2 * not(gs_stack_bottom)
			maskLeft	= 8 + 2 * not(gs_stack_left) + 5 * (gs_trim_in_mat <> gs_apron_mat)
			maskRight	= 8 + 2 * not(gs_stack_right) + 5 * (gs_trim_in_mat <> gs_apron_mat)

			maskLeft2	= not(bTrimovbotleftin)*(15-7*gs_stack_left)+bTrimovbotleftin*(10-2*gs_stack_left + 5 * (gs_trim_in_mat <> gs_apron_mat) * not(gs_stack_left))
			maskRight2	= not(bTrimovbotrightin)*(15-7*gs_stack_right)+bTrimovbotrightin*(10-2*gs_stack_right + 5 * (gs_trim_in_mat <> gs_apron_mat) * not(gs_stack_right))

			! --- Stacked Window or Window with Board or Corner Window ---

			if bInclinedWall & not(gs_trim_atframe_in) then
				roty wallIncl
				addz -gs_trim_thk_in

				if not(gs_stack_bottom | not(isWindow)) & bShapeEnablesStraightBottomTrim & abs(gs_apron_width) > EPS then
					px2 = (gs_trim_width_in - gs_trim_offs_in) / cos(wallIncl)
					px1 = px2 - gs_tw_left_in * not(bTrimovbotleftin)
					px3 = -px2
					px4 = px3 + gs_tw_right_in * not(bTrimovbotrightin)

					py1 = -overSizeBottomIn + not(gs_stack_bottom) * ((gs_trim_width_in + tolerOffsetLowerIn - gs_trim_offs_in) * not(bDrawBoard) - gs_apron_width)
					py2 = -overSizeBottomIn + not(gs_stack_bottom) * ((gs_trim_width_in + tolerOffsetLowerIn - gs_trim_offs_in) * not(bDrawBoard))
					material gs_apron_mat

					if abs(gs_trim_thk_in - gs_apron_thk) < EPS then
						pxL = -(leftWidth - tolerOffsetLeftIn + overSizeLeft)  / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)
						pxR =  (rightWidth - tolerOffsetRightIn + overSizeRight) / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)

						croof_ gs_apron_mat, gs_apron_mat, gs_apron_mat,
							4+2, 0,0, 1,0, 0, 0, -bBottomtriminthk,
							pxL + not(gs_stack_left)  * px1,	py1, 	-gs_stack_left * wallIncl * not(bTrimovbotleftin),	maskLeft2,
							pxL + not(gs_stack_left)  * px1,	py1 + gs_apron_width, 	-wallIncl*(bTrimovbotleftin), maskLeft,						! 15 or 8
							pxL + not(gs_stack_left)  * px2,	py2,	0,	bitset (mask, 1, not(gs_stack_left)),
							pxR + not(gs_stack_right) * px3,	py2,	wallIncl * bTrimovbotrightin,	maskRight,				! 15 or 8
							pxR + not(gs_stack_right) * px4,	py1 + gs_apron_width, 	wallIncl*bTrimovbotrightin, maskRight2,
							pxR + not(gs_stack_right) * px4,	py1, 	0,	13 + 2 * not(gs_stack_right)	! 15 or 13

						lin_ pxL + not(gs_stack_left)  * px2, py2, 0, pxR + not(gs_stack_right) * px3,	py2, 0

					else
						pxL = -(leftWidth  - tolerOffsetLeftIn + overSizeLeft)  / cos(wallIncl) + (gs_trim_thk_in*not(bTrimovbotleftin)+bBottomtriminthk*bTrimovbotleftin) * tan(wallIncl)
						pxR =  (rightWidth - tolerOffsetRightIn + overSizeRight) / cos(wallIncl) + (gs_trim_thk_in*not(bTrimovbotrightin)+bBottomtriminthk*bTrimovbotrightin) * tan(wallIncl)

						addz (gs_trim_thk_in - gs_apron_thk)
						croof_ gs_apron_mat, gs_apron_mat, gs_apron_mat,
							4, 0,0, 1,0, 0, 0, -bBottomtriminthk,
							pxL + not(gs_stack_left)  * px1,	py1, 	-wallIncl*bTrimovbotleftin,	8 + 7 * not(gs_stack_left),
							pxL + not(gs_stack_left)  * px1,	py2, 	0, 13 + 2 * not(gs_stack_left),
							pxR + not(gs_stack_right) * px4,	py2, 	wallIncl*bTrimovbotrightin, 8 + 7 * not(gs_stack_right),
							pxR + not(gs_stack_right) * px4,	py1, 	0,	13 + 2 * not(gs_stack_right)
						del 1
					endif
					material gs_trim_in_mat
				endif

				del 2
			else		! Straight wall
				addz -gs_trim_thk_in

				if not(gs_stack_bottom | not(isWindow)) & bShapeEnablesStraightBottomTrim & abs(gs_apron_width) > EPS & not(bInclinedWall) then
					! --- Draw lower Trim/Apron in Straight Wall ---

					py1 = -overSizeBottomIn + not(gs_stack_bottom) * ((gs_trim_width_in + tolerOffsetLowerIn - gs_trim_offs_in * not(gs_trim_atframe_in)) * not(bDrawBoard) - gs_apron_width)
					py2 = -overSizeBottomIn + not(gs_stack_bottom) * ((gs_trim_width_in + tolerOffsetLowerIn - gs_trim_offs_in * not(gs_trim_atframe_in)) * not(bDrawBoard))

					px1 = -leftWidth + tolerOffsetLeftIn - overSizeLeft + not(gs_stack_left) * (gs_trim_width_in - gs_trim_offs_in - gs_tw_left_in*not(bTrimovbotleftin))
					px2 = -leftWidth + tolerOffsetLeftIn - overSizeLeft + not(gs_stack_left) * (gs_trim_width_in - gs_trim_offs_in)
					px3 =  rightWidth - tolerOffsetRightIn + overSizeRight + not(gs_stack_right) * (-gs_trim_width_in + gs_trim_offs_in)
					px4 =  rightWidth - tolerOffsetRightIn + overSizeRight + not(gs_stack_right) * (-gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in*not(bTrimovbotrightin))

					if bDrawLeftTrimatGangingIn then
						px2 = leftRevealPnts[2][1] + tolerOffsStackCasLeftIn + trinL - gs_trim_offs_in
					endif
					if bDrawRightTrimatGangingIn then
						px3 = rightRevealPnts[2][1] - tolerOffsStackCasRightIn - trinR + gs_trim_offs_in
					endif

					material gs_apron_mat

					addz (WIDO_FRAME_THICKNESS - WALL_THICKNESS + WIDO_SILL) * gs_trim_atframe_in

					if abs(gs_trim_thk_in - gs_apron_thk) < EPS then
						prism_ 4+2, bBottomtriminthk,
							px1,	py1,					maskLeft2,
							px1,	py1 + gs_apron_width, 	maskLeft,						! 15 or 8
							px2,	py2,					bitset (mask, 1, not(gs_stack_left)),
							px3,	py2,					maskRight,						! 15 or 8
							px4,	py1 + gs_apron_width, 	maskRight2,
							px4,	py1,					13 + 2 * not(gs_stack_right)	! 15 or 13
					else
						addz gs_trim_thk_in - gs_apron_thk
						prism_ 4, bBottomtriminthk,
							px1,	py1, 	8  + 7 * not(gs_stack_left),
							px1,	py2,	13 + 2 * not(gs_stack_left),
							px4,	py2,	8  + 7 * not(gs_stack_right),
							px4,	py1, 	13 + 2 * not(gs_stack_right)
						del 1
					endif

					if bCutWall then
						pen WALL_VIEW_PEN
						material matWallIn
						wallniche 4,1,16,
							0,0,1,bBottomtriminthk + (gs_trim_thk_in - gs_apron_thk),
							px1,	py1, 	31,
							px1,	py2,	31,
							px4,	py2,	31,
							px4,	py1, 	31
						pen gs_frame_pen
						material gs_trim_in_mat
					endif

					del 1
				endif

				if not(gs_stack_bottom | not(isWindow)) & bShapeEnablesStraightBottomTrim & abs(gs_apron_width) > EPS & bInclinedWall then
					! --- Draw Apron in Inclined Wall ---

					px2 = (gs_trim_width_in - gs_trim_offs_in) / cos(wallIncl)
					px1 = px2 - gs_tw_left_in * not(bTrimovbotleftin)
					px3 = -px2
					px4 = px3 + gs_tw_right_in * not(bTrimovbotrightin)
					pxL = -(leftWidth  + overSizeLeft)  / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)
					pxR =  (rightWidth + overSizeRight) / cos(wallIncl) + bBottomtriminthk * tan(wallIncl)

					py1 = -overSizeBottomIn + not(gs_stack_bottom) * (gs_trim_width_in - gs_trim_offs_in * not(gs_trim_atframe_in)) * not(bDrawBoard) - gs_apron_width
					py2 = -overSizeBottomIn + not(gs_stack_bottom) * (gs_trim_width_in - gs_trim_offs_in * not(gs_trim_atframe_in)) * not(bDrawBoard)

					material gs_apron_mat

					addz (WIDO_FRAME_THICKNESS - WALL_THICKNESS + WIDO_SILL) * gs_trim_atframe_in + gs_trim_thk_in
					roty wallIncl
					addz -gs_trim_thk_in

					if abs(gs_trim_thk_in - gs_apron_thk) < EPS then
						croof_ bBottomtriminmat, bBottomtriminmat, bBottomtriminmat,
							4+2, 0,0, 1,0, 0, 0, -bBottomtriminthk,
							pxL + not(gs_stack_left)  * px1,	py1, 	-gs_stack_left * wallIncl*not(bTrimovbotleftin),	maskLeft*not(bDrawBoard)+maskLeft2*bDrawBoard,
							pxL + not(gs_stack_left)  * px1,	py1 + gs_apron_width*bDrawBoard, 	-wallIncl*(bTrimovbotleftin), maskLeft,						! 15 or 8
							pxL + not(gs_stack_left)  * px2,	py2,				0,				bitset (mask, 1, not(gs_stack_left)),
							pxR + not(gs_stack_right) * px3,	py2,				gs_stack_right * wallIncl*not(bTrimovbotrightin),	maskRight,				! 15 or 8
							pxR + not(gs_stack_right) * px4,	py1 + gs_apron_width*bDrawBoard, 	wallIncl*bTrimovbotrightin, maskRight*not(bDrawBoard)+maskRight2*bDrawBoard,
							pxR + not(gs_stack_right) * px4,	py1, 	0,				13 + 2 * not(gs_stack_right)	! 15 or 13
					else
						addz gs_trim_thk_in - gs_apron_thk
						croof_ bBottomtriminmat, bBottomtriminmat, bBottomtriminmat,
							4, 0,0, 1,0, 0, 0, -bBottomtriminthk,
							pxL + not(gs_stack_left)  * px1,	py1, 	-wallIncl*bTrimovbotleftin,	8 + 7 * not(gs_stack_left),
							pxL + not(gs_stack_left)  * px1,	py2, 	0, 9 + 2 * not(gs_stack_left),
							pxR + not(gs_stack_right) * px4,	py2, 	wallIncl*bTrimovbotrightin, 8 + 7 * not(gs_stack_right),
							pxR + not(gs_stack_right) * px4,	py1, 	0,	13 + 2 * not(gs_stack_right)
						del 1
					endif

					del 3
					material gs_trim_in_mat
				endif

				del 1
			endif ! bInclinedWall
		endif

		del 1

	else	! not(curvedWall)

		! ======================================
		! Apron - Curved Walls
		! ======================================

		resol WALL_RESOL

		offsArc = iHolePosSign * AC_Hole_Position_Angle / 180 * PI * rBoard

		matTrim = gs_trim_in_mat

		material gs_apron_mat
		sect_fill gs_trim_fill_in, gs_trim_pen_bg_in, gs_trim_pen_fg_in, gs_trim_pen_cont_in

		if gs_IsCurved then
			thk = WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS
		else
			thk = WALL_THICKNESS

			addz -WIDO_FRAME_THICKNESS

			material matTrim

			cutplane
			del 1
			numCutsFrame = 1
		endif

		if wallIsLeft then
			mask = 14 + (gs_trim_offs_in > EPS | not(bShowJambExtension))
		else
			mask = 11 + 4 * (gs_trim_offs_in > EPS | not(bShowJambExtension))
		endif

		if numCutsFrame then
			cutend
			numCutsFrame = 0
		endif

		if not(gs_stack_left) then
			alfaLeftParallelIn = abs (asn ( (leftRevealPnts[idxBoardEndRevealLeft][1] + gs_trim_width_in) / rBoard))
		else
			alfaLeftParallelIn = alfaLeft
		endif
		if not(gs_stack_right) then
			alfaRightParallelIn = abs (asn ( (rightRevealPnts[idxBoardEndRevealRight][1] - gs_trim_width_in) / rBoard))
		else
			alfaRightParallelIn = alfaRight
		endif

		if gs_trim_thk_in > EPS then

! ------------------------------------------------------------------------------
! Apron hole in curved wall
! ------------------------------------------------------------------------------

			if iWindowShape = SHAPE_RECTANGULAR then

				if gs_stack_left then
					pxL = leftRevealPnts[idxBoardEndRevealLeft][1]
				else
					pxL = leftRevealPnts[idxBoardEndRevealLeft][1] + gs_trim_width_in + not(gs_stack_left) * (-gs_trim_offs_in + tolerOffsetLeftIn)
					alphaLeft = abs(asn(pxL / rBoard)) + ArcLengthBoardToAngle * gs_tw_left_in
					pxL = -rBoard * sin(alphaLeft)
					pyL = -sqr(rBoard^2 - pxL^2) - WOD
				endif
				if gs_stack_right then
					pxR = rightRevealPnts[idxBoardEndRevealright][1]
				else
					pxR = rightRevealPnts[idxBoardEndRevealright][1] - gs_trim_width_in - not(gs_stack_right) * (-gs_trim_offs_in + tolerOffsetRightIn)
					alphaRight = abs(asn(pxR / rBoard)) + ArcLengthBoardToAngle * gs_tw_right_in
					pxR = rBoard * sin(alphaRight)
					pyR = -sqr(rBoard^2 - pxR^2) - WOD
				endif
				if isWindow then
					pyB = -overSizeBottomIn - not(gs_stack_bottom) * (gs_apron_width)
				else
					pyB = 0
				endif
				pyT = pyB + gs_apron_width

				if bCutWall then
					pen WALL_VIEW_PEN
					material matWallIn

					alfaEnd		= alphaRight
					alfaStart	= -alphaLeft
					arcRadius	= radBoard
					bMiddlePoints = 1
					firstStatus	= 31
					midStatus	= 95
					lastStatus	= 31
					if abs(alfaStart - alfaEnd) > EPS then
						gosub 110

						rotx 90
						muly -1
						addz -pyB

						cutDepth = pyT - pyB
						if wallIsLeft then
!							prism_ NSP/3 + 1,-cutDepth,
!								0,WOD,15,
!								use(nsp)
							wallniche NSP/3 + 1,1,0,
								0,0,-cutDepth,cutDepth,
								0,WOD,31,
								get(nsp)
						else
!							prism_ NSP/3 + 2,-cutDepth,
!								 (rBoard + WALL_THICKNESS) * sin(alphaLeft),  (rBoard + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 15,
!								-(rBoard + WALL_THICKNESS) * sin(alphaRight), (rBoard + WALL_THICKNESS) * cos(alphaRight) + WOD, 15,
!								use(nsp)
							wallniche NSP/3 + 2,1,0,
									0,0,-cutDepth,cutDepth,
								 (rBoard + WALL_THICKNESS) * sin(alphaLeft),  (rBoard + WALL_THICKNESS) * cos(alphaLeft)  + WOD, 31,
								-(rBoard + WALL_THICKNESS) * sin(alphaRight), (rBoard + WALL_THICKNESS) * cos(alphaRight) + WOD, 31,
								get(nsp)
						endif
						del 3
					endif

					pen gs_frame_pen
					material gs_trim_in_mat
				endif
			endif

			material gs_apron_mat
			sect_fill gs_trim_fill_in, gs_trim_pen_bg_in, gs_trim_pen_fg_in, gs_trim_pen_cont_in

			! ===== Inside Trim - Curved Walls - Casing =====

			if wallIsLeft then
				mask = 11 + 4 * (gs_trim_offs_in > EPS)
			else
				mask = 14 + (gs_trim_offs_in > EPS)
			endif

			maskTop		= 8 + 2 * not(gs_stack_top) * not(bParalellInCurvedWalls)
			maskBottom	= 8 + 2 * not(gs_stack_bottom)
			maskLeft	= 8 + (2 + 5 * bParalellInCurvedWalls) * not(gs_stack_left)
			maskRight	= 8 + 2 * not(gs_stack_right)

			maskLeft2	= bDrawBoard*(not(bTrimovbotleftin)*(15-7*gs_stack_left)+bTrimovbotleftin*(10-2*gs_stack_left))
			maskRight2	= bDrawBoard*(not(bTrimovbotrightin)*(15-7*gs_stack_right)+bTrimovbotrightin*(10-2*gs_stack_right))

			addz -WOD
			bCondition = WIDO_REVEAL_SIDE exor SYMB_MIRRORED
			roty (not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) + not(wallIsLeft) * 180
			addz rBoard

! ------------------------------------------------------------------------------
! Apron in curved wall
! ------------------------------------------------------------------------------

			if not(gs_stack_bottom | not(isWindow)) & bShapeEnablesStraightBottomTrim & abs(gs_apron_width) > EPS then
				if not(bParalellInCurvedWalls) then
					px1 = signWallIsLeft * (offsArc - rBoard * alfaLeft * DegRad + not(gs_stack_left) * (gs_trim_width_in - gs_trim_offs_in - gs_tw_left_in*not(bTrimovbotleftin)))
					px2 = px1
					px3 = signWallIsLeft * (offsArc - rBoard * alfaLeft * DegRad + not(gs_stack_left) * (gs_trim_width_in - gs_trim_offs_in))
					px4 = signWallIsLeft * (offsArc + rBoard * alfaRight * DegRad + not(gs_stack_right) * (-gs_trim_width_in + gs_trim_offs_in))
					px5 = signWallIsLeft * (offsArc + rBoard * alfaRight * DegRad + not(gs_stack_right) * (-gs_trim_width_in + gs_trim_offs_in + gs_tw_right_in*not(bTrimovbotrightin)))
					px6 = px5

					py1 = -overSizeBottomIn + not(gs_stack_bottom) * (gs_trim_width_in*not(bDrawBoard) - gs_trim_offs_in * not(bDrawBoard) - gs_apron_width)
					py2 = py1 + gs_apron_width * bDrawBoard
					py3 = -overSizeBottomIn + not(gs_stack_bottom) * (gs_trim_width_in*not(bDrawBoard) - gs_trim_offs_in * not(bDrawBoard))
					py4 = py3
					py5 = py2
					py6 = py1

					s1 = maskLeft*not(bDrawBoard)+maskLeft2*bDrawBoard
					s2 = maskLeft
					s3 = bitset (mask, 1, not(gs_stack_left))
					s4 = maskRight
					s5 = maskRight*not(bDrawBoard)+maskRight2*bDrawBoard
					s6 = 13 + 2 * not(gs_stack_right)
				else
					px1 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad + not(gs_stack_left) * (gs_trim_width_in*0 - gs_trim_offs_in - gs_tw_left_in + tolerOffsetLeftIn))
					px2 = px1
					px3 = signWallIsLeft * (offsArc - rBoard * alfaLeftParallelIn * DegRad + not(gs_stack_left) * (gs_trim_width_in*0 - gs_trim_offs_in - gs_tw_left_in + tolerOffsetLeftIn))
					px4 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + not(gs_stack_right) * (-gs_trim_width_in*0 + gs_trim_offs_in + gs_tw_right_in - tolerOffsetRightIn ))
					px5 = signWallIsLeft * (offsArc + rBoard * alfaRightParallelIn * DegRad + not(gs_stack_right) * (-gs_trim_width_in*0 + gs_trim_offs_in + gs_tw_right_in - tolerOffsetRightIn ))
					px6 = px5

					py1 = -overSizeBottomIn + not(gs_stack_bottom) * ( (gs_trim_width_in - gs_trim_offs_in + tolerOffsetLowerIn) * not(bDrawBoard) - gs_apron_width)
					py2 = py1 + gs_apron_width * bDrawBoard
					py3 = -overSizeBottomIn + not(gs_stack_bottom) * ( (gs_trim_width_in - gs_trim_offs_in + tolerOffsetLowerIn) * not(bDrawBoard)) + EPS
					py4 = py3 + EPS
					py5 = py2
					py6 = py1

					s1 = maskLeft * not(bDrawBoard) + maskLeft2 * bDrawBoard
					s2 = maskLeft
					s3 = bitset (mask, 1, not(gs_stack_left))
					s4 = 13	+ 2 * bDrawBoard
					s5 = maskRight * not(bDrawBoard) + maskRight2 * bDrawBoard
					s6 = 13 + 2 * not(gs_stack_right)
				endif

				if bParalellInCurvedWalls then
					addz -rBoard
					roty -(not(bCondition) - bCondition) * abs(AC_Hole_Position_Angle) - not(wallIsLeft) * 180

					maskApronNos = 0
					if abs(gs_apron_thk - gs_trim_thk_in) > EPS then
						maskApronNos = 15
					else
						maskApronNos = 15 * (gs_trim_in_mat <> gs_apron_mat)
					endif

					cutpolya 4, 1, 0,
						-leftWidth + tolerOffsetLeftIn + gs_trim_width_in + gs_trim_offs_in,  py3 - EPS - gs_apron_width * bTrimovbotleftin,  maskApronNos,
						-leftWidth * 3,  py3 - EPS - gs_apron_width * bTrimovbotleftin,  7,
						-leftWidth * 3, B + overSizeTop, 7,
						-leftWidth + tolerOffsetLeftIn + gs_trim_width_in + gs_trim_offs_in,  B + overSizeTop,  1 * not(bTrimovbotleftin) + bTrimovbotleftin * maskApronNos

					cutpolya 4, 1, 0,
						-leftWidth + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in,  py3 - EPS,  3,
						rightWidth - tolerOffsetRightIn - gs_trim_width_in - gs_trim_offs_in,  py3 - EPS,  7,
						rightWidth - tolerOffsetRightIn - gs_trim_width_in - gs_trim_offs_in, B + overSizeTop, 7,
						-leftWidth + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in,  B + overSizeTop,  1

					cutpolya 4, 1, 0,
						rightWidth - tolerOffsetRightIn - gs_trim_width_in - gs_trim_offs_in,  py3 - EPS - gs_apron_width * bTrimovbotrightin,  maskApronNos,
						rightWidth * 3,  py3 - EPS - gs_apron_width * bTrimovbotrightin,  7,
						rightWidth * 3, B + overSizeTop, 7,
						rightWidth - tolerOffsetRightIn - gs_trim_width_in - gs_trim_offs_in,  B + overSizeTop,  1 * not(bTrimovbotrightin) + bTrimovbotrightin * maskApronNos

					del 2
				endif

				bprism_ gs_apron_mat, gs_apron_mat, gs_apron_mat,
					4+2, -signWallIsLeft * bBottomtriminthk, rBoard,
					px1,	py1, 	s1,
					px2,	py2, 	s2,
					px3,	py3,	s3,
					px4,	py4,	s4,
					px5,	py5, 	s5,
					px6,	py6, 	s6

				if bParalellInCurvedWalls then
					cutend
					cutend
					cutend
				endif
			endif

			del 3
		endif
	endif	! not(curvedWall)

	del 1
return


"casing head type":

	toler 0.002
	if iCasingHeadTypeOut = CASING_HEAD_RECT then
		put 0,	0,	0,
			-_trimWidth,	0,			0,
			-_trimWidth,	_trimThick,	0,
			0,				_trimThick,	0,
			0,				0,			0
	endif
	
	if iCasingHeadTypeOut = CASING_HEAD_DECORATIVE_1 then
		_sizeW			= min(_trimThick, _trimWidth/8)
		_sizeT			= min(_trimThick, _thickBracket/2)
		_thickProfile	= _trimThick+_thickBracket+_offsetTop
		put 0,0,0,
			-_trimWidth,			0,					0,
			-_trimWidth+_sizeW,		_thickProfile,		0,
			-_trimWidth+_sizeW*2,	_thickProfile,		0,
			-_trimWidth+_sizeW*2,	_trimThick+_sizeT,	0,
			-_sizeW*2,				_trimThick+_sizeT,	0,
			0,						_trimThick,			0,
			0,						0,					0
	endif
	
	if iCasingHeadTypeOut = CASING_HEAD_DECORATIVE_2 then
		_sizeW			= min(_trimThick, _trimWidth/8)
		_sizeT			= min(_trimThick, _thickBracket/2)
		_thickProfile	= _trimThick+_thickBracket+_offsetTop
		_rr				= min((_thickBracket+_offsetTop)/2, _trimWidth-_sizeW*2-EPS)
	
		put 0,0,0,
			-_trimWidth,				0,				0,
			-_trimWidth+_sizeW,			_thickProfile,	0,
			-_trimWidth+_sizeW*2,		_thickProfile,	0,
			-_trimWidth+_sizeW*2,		_trimThick+rr,	1,
			-_trimWidth+_sizeW*2+_rr,	_trimThick,		1001,
			0,							_trimThick,		0,
			0,							0,				0
	endif
	
	if iCasingHeadTypeOut = CASING_HEAD_DECORATIVE_3 then
		_sizeW			= min(_trimThick, _trimWidth/8)
		_thickProfile	= _trimThick+_thickBracket+_offsetTop
	
		put 0,0,0,
			-_trimWidth,			0,				0,
			-_trimWidth+_sizeW,  	_thickProfile,	0,
			-_trimWidth+_sizeW*2,	_thickProfile,	0,
			-_trimWidth+_sizeW*2,	_trimThick,		0,
			0,     					_trimThick,		0,
			0,     					0,				0
	endif
	
	if nsp then
		extrude nsp/3, 0, 0, _trimLength, 1+2+4+16*m1+32*m2,
			get(nsp)
	endif
	
	roty 90
	base
	vert 0,0,0
	vert 0.1,0,0
	vert 0,0.1,0
	vert 0,0,0.1
	coor 258,-1,-2,-3,-4
	body -1
	del 1

return


"architrave capital type":
	if _bArchitraveCapitalOnSide then
		_capitalLength = _trimWidth
	else
		_capitalLength = architraveCapitalWidth
	endif

	if	(iArchitraveCapitalType = ARCH_CAPITAL_SQUARE_ONSIDE |\
		 iArchitraveCapitalType = ARCH_CAPITAL_SQUARE_NEXTSIDE) then

		put -_trimThick,	-0.001,		1,
			-_trimThick,	-0.2,		1,
			0.01,			-0.2,		1,
			0.06,			0,			1,
			-_trimThick,	-0.001,		-1
	endif

	if	(iArchitraveCapitalType = ARCH_CAPITAL_DECOR_ONSIDE |\
		 iArchitraveCapitalType = ARCH_CAPITAL_DECOR_NEXTSIDE) then

		put	-_trimThick,		-0.001,				1,
		  	-_trimThick,		-0.2105623924385,	1,
		  	0.0002225047733932,	-0.2105623924385,	1,
		  	0.02569480801934,	-0.2147356031753,	900,
		  	0,					-66.87864346571,	4001,
		 	0.01953034376379,	-0.1896706216084,	1,
		  	0.01364444354641,	-0.1731057357603,	900,
		  	0,					71.90421043734,		4001,
		  	0.03121820560956,	-0.1726561231749,	1,
		  	0.03757481483445,	-0.1726166802041,	1,
		  	0.02760021831745,	-0.1627083807783,	1,
		  	0.04641522481362,	-0.1412622935953,	900,
		  	0,					-93.75626129549,	4001,
		 	0.026247820758,		-0.1210827262419,	1,
		 	0.0606554624785,	-0.09478132287652,	1,
		 	0.05486053259315,	-0.0887335580581,	1,
		 	0.04784928296197,	-0.0680955002196,	900,
		  	0,					127.355665002,		4001,
			0.06,				-0.05,				1,
			0.07,				-0.05,				1,
			0.07,				0,					1,
			0,					0,					1,
			_trimThick,			-0.001,				-1
	endif

	if iArchitraveCapitalType = 0 then
		put	-_trimThick,		-0.003,				1,
			-_trimThick,		-0.141,				1,
			0,					-0.141,				1,
			-0.008015410958904,	-0.1133424657534,	900,
			0,					60.4,				4001,
			0.02,				-0.12,				1,
			0.01899107142857,	-0.1045,			900,
			0,					172.5514951168,		4001,
			0.02,				-0.089,				1,
			0.08881341911765,	-0.08749908088235,	900,
			0,					-44.8,				4001,
			0.039,				-0.04,				1,
			0.039,				0,					1,
			0,					0,					1,
			-_trimThick,		-0.003,				-1
	endif

	if nsp then
		extrude nsp/3, 0, 0, _capitalLength, 1+2+4+16+32,
			get(nsp)
	endif

	roty 90
	base
	vert 0,0,0
	vert 0.1,0,0
	vert 0,0.1,0
	vert 0,0,0.1
	coor 258,-1,-2,-3,-4
	body -1
	del 1

return


100:
! ==============================================================================
!	Cutting Corner Column
! ==============================================================================

mulz -1
rotx -90


! Draw Right Column ------------------------------------------------------------

if bRightCornerFunction & idxBoardEndRevealRight >= idxR then
	add rightRevealPnts[idxR][1], rightRevealPnts[idxR][2],0
	if bMirrorRight then muly -1

	px1		= px1R
	px2		= px2R
	px3		= px3R
	pxFrame	= pxFrameR

	cutpolya 4, 1, 0,
		px1,			-gs_cc_pr,				15,
		px2 - pxFrame,	-gs_cc_pr,				15,
		px2 - pxFrame,	-gs_cc_pr + gs_cc_thk,	15,
		px3,			-gs_cc_pr + gs_cc_thk,	15

	numCutsCornerColumn = numCutsCornerColumn + 1

	del bMirrorRight + 1
endif


! Draw Left Column -------------------------------------------------------------

if bLeftCornerFunction & idxBoardEndRevealLeft >= idxL then
	add leftRevealPnts[idxL][1], leftRevealPnts[idxL][2],0
	if bMirrorLeft then muly -1
	add offsLeftX, offsLeftY, 0
	mulx -1

	px1		= px1L
	px2		= px2L
	px3		= px3L
	pxFrame	= pxFrameL

	cutpolya 4, 1, 0,
		px1,			-gs_cc_pr,				15,
		px2 - pxFrame,	-gs_cc_pr,				15,
		px2 - pxFrame,	-gs_cc_pr + gs_cc_thk,	15,
		px3,			-gs_cc_pr + gs_cc_thk,	15

	numCutsCornerColumn = numCutsCornerColumn + 1

	del bMirrorLeft + 3
endif

del 2

return


! ==============================================================================
! Arch Segmentation
! ------------------------------------------------------------------------------
! Input parameters:
!	alfaStart:		Start angle (angle)
!	alfaEnd:		End angle (angle)
!	arcRadius:		Arc radius (length)
!	bMiddlePoints:	Generate middle points (0 / 1)
!	firstStatus:	Status of the first segment (integer)
!	midStatus:		Status of the middle segments (integer)
!	lastStatus:		Status of the last segment (integer)
! ==============================================================================

110:
	if not(wallIsLeft) then
		alfaStart = 180 - alfaStart
		alfaEnd = 180 - alfaEnd
	endif
	segmentAngle = 360 / WALL_RESOL


	! --- Point at Start Angle ---
	if WIDO_REVEAL_SIDE then
		if SYMB_ROTANGLE < EPS then
			difAngle = (AC_Hole_Position_Angle + alfaStart) mod segmentAngle
		else
			difAngle = -(AC_Hole_Position_Angle - 180 - alfaStart) mod segmentAngle
		endif
	else
		if SYMB_ROTANGLE < EPS then
			difAngle = -(AC_Hole_Position_Angle - alfaStart + 180) mod segmentAngle
		else
			difAngle = (AC_Hole_Position_Angle + alfaStart) mod segmentAngle
		endif
	endif

	difAngle2 = difAngle
	if abs(difAngle) > segmentAngle / 2 then difAngle = -segmentAngle / 2 + abs(difAngle mod (segmentAngle / 2))

	segmentR = arcRadius / cos(difAngle)
	put segmentR * sin(alfaStart), -segmentR * cos(alfaStart) + WOD, firstStatus

	if bMiddlePoints then
		! --- Middle Points ---
		segmentR = arcRadius / cos(segmentAngle / 2)

		if alfaStart > alfaEnd then
			alfaActual = alfaStart - difAngle2 + segmentAngle / 2

			if alfaActual > alfaStart then alfaActual = alfaActual - segmentAngle
			if alfaActual > alfaStart then alfaActual = alfaActual - segmentAngle

			if alfaActual < alfaEnd then alfaActual = alfaActual + segmentAngle

			if alfaActual < alfaStart & alfaActual > alfaEnd then
				do
					put segmentR * sin(alfaActual), -segmentR * cos(alfaActual) + WOD, midStatus

					alfaActual = alfaActual - segmentAngle

				while alfaActual > alfaEnd
			endif
		else
			alfaActual = alfaStart - difAngle2 + segmentAngle / 2

			if alfaActual < alfaStart then alfaActual = alfaActual + segmentAngle
			if alfaActual > alfaEnd then alfaActual = alfaActual - segmentAngle

			if alfaActual > alfaStart & alfaActual < alfaEnd then
				do
					put segmentR * sin(alfaActual), -segmentR * cos(alfaActual) + WOD, midStatus

					alfaActual = alfaActual + segmentAngle
				while alfaActual < alfaEnd
			endif
		endif
	endif


	! --- Point at End Angle ---
	if WIDO_REVEAL_SIDE then
		if SYMB_ROTANGLE < EPS then
			difAngle = (AC_Hole_Position_Angle + alfaEnd) mod segmentAngle
		else
			difAngle = -(AC_Hole_Position_Angle + 180 - alfaEnd) mod segmentAngle
		endif
	else
		if SYMB_ROTANGLE < EPS then
			difAngle = -(AC_Hole_Position_Angle - alfaEnd + 180) mod segmentAngle
		else
			difAngle = (AC_Hole_Position_Angle + alfaEnd) mod segmentAngle
		endif
	endif

	if abs(difAngle) > segmentAngle / 2 then difAngle = -segmentAngle / 2 + abs(difAngle mod (segmentAngle / 2))

	segmentR = arcRadius / cos(difAngle)
	put segmentR * sin(alfaEnd), -segmentR * cos(alfaEnd) + WOD, lastStatus

return


"TextCoord_Vert":

!********************** texture coordination, vertical

vert 0, 0, 0
vert 0, 1, 0
vert 1, 0, 0
vert 0, 0, 1
coor 2, -1, -2, -3, -4
body 1

base

return



"TextCoord_Hor":

!********************** texture coordination, horozintal

rotz 90
if not(curvedWall) then
	vert 0, 0, 0
	vert 0, 1, 0
	vert 1, 0, 0
	vert 0, 0, 1
	coor 2, -1, -2, -3, -4
else
	addz -wod
	vert 0, 0, 0
	vert 0, 1, 0
	vert 0, 0, 1
	vert 1, 0, 0
	coor 3, -1, -2, -3, -4
	del 1
endif
body 1
del 1

base

return


