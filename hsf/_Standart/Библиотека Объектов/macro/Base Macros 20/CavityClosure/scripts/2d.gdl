
! Contact person: <NJ>

! ==============================================================================
! This macro draws the cavity closure and turned plasters
! ------------------------------------------------------------------------------
! Input parameters:
!	refWidth:				reference width in curved walls (length)
!	leftWidth:				wallhole's side distance from the origin at the left side (length)
!	rightWidth:				wallhole's side distance from the origin at the right side (length)
!	bWndCurved:				is the window made of curved panels (0 / 1)
!	bParalellInCurvedWalls:	is the wallhole parallel in curved walls (0 / 1)
!	bDrawObjContourIn:
!	bDrawObjContourOut:
!	bDrawFrameContourLeft:	Draw the wall contour border on window frame at the left side (0 / 1)
!	bDrawFrameContourRight:	Draw the wall contour border on window frame at the left side (0 / 1)
!	bWindowSymbolAtMiddle:	Is the window symbol appears always on the middle of the wall (CHI special) (0 / 1)
! Corner Window Parameters -----------------------------------------------------
!	bCornerWindow:			is the hole a corner window? (0 / 1)
!	ac_corner_angle:		angle between connected walls in case of Corner Window (angle)
!	ac_diff_con_wall_thk:	indicates the equality thickness of the two connected walls (0 / 1)
!	ac_con_wall_thk:		thickness of the connected wall in case of Corner Window (length)
! Wallhole Cover Fill Parameter (only for polygon walls ) ----------------------
!	fillWallHole:			wallhole cover fill (only for polygon walls) (fill)
!	penWallHoleFg:			wallhole cover fill pen (only for polygon walls) (pen)
!	penWallHoleBg:			wallhole cover fill background pen (only for polygon walls) (pen)
!	penWallContour:			wallhole contour pen (only for polygon walls) (pen)
!	iWallContourLine		Identifies the wall cotours to be drawn
!								(integer; 1 = none, 2 = inside, 3 = outside, 4 = both)
!	gs_wcont_line_in:		type of the wall contour line inside (line type)
!	gs_wcont_line_out:		type of the wall contour line outside (line type)
! Oversize Parameters ----------------------------------------------------------
!	gs_left_oversize:		Left opening oversize (only for polygon walls) (length)
!	gs_right_oversize:		Right opening oversize (only for polygon walls) (length)
! Reveal Parameters ------------------------------------------------------------
!	iRevealType:			reveal type (integer)
!								0 = no Reveal
!								1 = Positive Reveal
!								2 = Negative Reveal
!								3 = Slanted Reveal
!								4 =
!	gs_reveal_left:			left reveal size (length)
!	gs_reveal_right:		left reveal size (length)
!	gs_reveal_left_angle:	left reveal angle in case of slanted reveal (angle)
!	gs_reveal_right_angle:	right reveal angle in case of slanted reveal (angle)
! Stacked Window Parameters ----------------------------------------------------
!	gs_stack_left:			align to door/window on left side (0 / 1)
!	gs_stack_right:			align to door/window on right side (0 / 1)
! Cavity Closure Parameters ----------------------------------------------------
!	gs_maxPlasterThk:		wall skin classification parameter (length)
!							consider Skin as Plaster if it is thinner this
!	gs_bAutoTurnIn:			automatic plaster return at Outside Face (0 / 1)
!	gs_bAutoTurnOut:		automatic plaster return at Inside Face (0 / 1)
!	gs_bOverIn:				number of turned plaster skins at Outside Face (integer)
!	gs_bOverOut:			number of turned plaster skins at Inside Face (integer)
!	iClosureType:			controls the method being used for internal cavity closure (integer)
!	bCavityCloserLeft:		show cavity closure at left side
!	bCavityCloserRight:		show cavity closure at right side
!	gs_nTurn:				number of turned skins in traditional mode (integer value)
!	gs_bJoint:				is there an insulation strip at the front
!							 side of the turned skins (0 / 1) [MODE1]
!	gs_thkJoint:			strip thickness (length)
!	gs_penJoint:			strip contour pen (pen)
!	gs_ltJoint:				strip contour linetype (line type)
!	gs_fillJoint:			strip fill type (fill)
!	gs_penJointFg:			strip fill pen (pen)
!	gs_penJointBg:			strip fill background pen (pen)
!	gs_widthPlug:			heat insulation profile width (length) [MODE2]
!	gs_penPlug:				profile contour pen (pen)
!	gs_ltPlug:				profile contour linetype (line type)
!	gs_fillPlug:			profile fill type (fill)
!	gs_penPlugFg:			profile fill pen (pen)
!	gs_penPlugBg:			profile fill background pen (pen)
! ==============================================================================


!! ==============================================================================
!! Debug function
!! ==============================================================================
!
!for i = 1 to WALL_SKINS_NUMBER
!	text2 0,	0, i
!	text2 0.15,	0, WALL_SKINS_PARAMS[i][SKIN_CORE_STATUS]
!	text2 0.25,	0, WALL_SKINS_PARAMS[i][SKIN_THICKEN_TRAPEZOID]
!	add2 0, 0.2
!next i
!del top


if GLOB_CONTEXT = 6 | GLOB_CONTEXT = 46 then end	! List
if GLOB_CONTEXT = 5 then	! Object Settings Dialog
	bDrawObjContourIn	= 0
	bDrawObjContourOut	= 0
	bSettingsDialog		= 1
endif


! === save the current parameter buffer
dim savedQueueValues[]
call "SaveQueue" parameters returned_parameters savedQueueValues


! ==============================================================================
! Reveal Points Indexes
! ==============================================================================

idxSillStartRevealLeft		= iRevealPointsIdx[1]
idxSillEndRevealLeft		= iRevealPointsIdx[2]
idxFrameStartRevealLeft		= iRevealPointsIdx[3]
idxFrameEndRevealLeft		= iRevealPointsIdx[4]
idxBoardEndRevealLeft		= iRevealPointsIdx[6]
idxSillStartRevealRight		= iRevealPointsIdx[11]
idxSillEndRevealRight		= iRevealPointsIdx[12]
idxFrameStartRevealRight	= iRevealPointsIdx[13]
idxBoardEndRevealRight		= iRevealPointsIdx[16]
idxFrameEndRevealRight		= iRevealPointsIdx[14]


! ==============================================================================
! Cut Wallhole with WALLHOLE2
! ==============================================================================

if WIDO_REVEAL_SIDE then
	mul2 1,-1
	add2 0,WIDO_FRAME_THICKNESS
endif

! ==============================================================================

if vardim1(leftRevealPnts) > 1 then
	if iRevealType = REVEAL_NEGATIVE then
		sxL = leftRevealPnts[idxSillEndRevealLeft - 1][1]
		syL = leftRevealPnts[idxSillEndRevealLeft - 1][2]
	else
		sxL = leftRevealPnts[idxSillEndRevealLeft][1]
		syL = leftRevealPnts[idxSillEndRevealLeft][2]
	endif

	bxL = leftRevealPnts[idxFrameStartRevealLeft][1]
	byL = leftRevealPnts[idxFrameStartRevealLeft][2]

	if iRevealType = REVEAL_NEGATIVE then
		sxR = rightRevealPnts[idxSillEndRevealRight - 1][1]
		syR = rightRevealPnts[idxSillEndRevealRight - 1][2]
	else
		sxR = rightRevealPnts[idxSillEndRevealRight][1]
		syR = rightRevealPnts[idxSillEndRevealRight][2]
	endif

	bxR = rightRevealPnts[idxFrameStartRevealRight][1]
	byR = rightRevealPnts[idxFrameStartRevealRight][2]

	frameSillXL  = leftRevealPnts[idxFrameStartRevealLeft][1]
	frameSillYL  = leftRevealPnts[idxFrameStartRevealLeft][2]
	frameBoardXL = leftRevealPnts[idxFrameEndRevealLeft][1]
	frameBoardYL = leftRevealPnts[idxFrameEndRevealLeft][2]

	frameSillXR  = rightRevealPnts[idxFrameStartRevealRight][1]
	frameSillYR  = rightRevealPnts[idxFrameStartRevealRight][2]
	frameBoardXR = rightRevealPnts[idxFrameEndRevealRight][1]
	frameBoardYR = rightRevealPnts[idxFrameEndRevealRight][2]

	if curvedWall then
		syL = -syL
		syR = -syR

		byL = -byL
		byR = -byR
	endif
endif


! ==============================================================================
! Cavity Closure
! ==============================================================================

dim skinCummThkRef[]	! Cummulative skin thickness from the Outside Face (8 +1 skins))
dim skinCummThkOpp[]	! Cummulative skin thickness from the Inside Face (8 + 1 skins)

cumRefThk = 0
cumOppThk = 0

if bCompositeWall then
	for i=1 to WALL_SKINS_NUMBER
		idx = i: gosub 10	! Get proper index

		cumRefThk = cumRefThk + WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
		skinCummThkRef[idx] = cumRefThk

		idx = WALL_SKINS_NUMBER + 1 - idx	! reorder
		cumOppThk = cumOppThk + WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
		skinCummThkOpp[idx] = cumOppThk
	next i
endif


! ==============================================================================

del top

if curvedWall then
	if WIDO_REVEAL_SIDE then
		mul2 1,-1
		add2 0,WIDO_FRAME_THICKNESS
	endif
else
	if WIDO_REVEAL_SIDE then add2 0,-WIDO_FRAME_THICKNESS
	if SYMB_ROTANGLE > EPS then mul2 1, -1
	if wallIsLeft then
		add2 0, -WIDO_SILL
	else
		add2 0, -WALL_THICKNESS + WIDO_SILL
	endif
	if reorder then
		mul2 1,-1
		add2 0, -WALL_THICKNESS
	endif
endif

! Stored Contour Line Related Definitions ======================================

dim contourLines[][7]	! Contour line store array
clIdx = 1				! Actual index

! Transformation from CavityClosure coorinate system to Wallhole Coorinate system
if curvedWall then
	if wallIsLeft exor reorder then
		signX = -1
	else
		signX = -1
	endif
	signY	= -1
	offsetY	= 0
else
	signX = 1
	if wallIsLeft exor reorder then
		signY	=  1
		offsetY	= -WIDO_SILL
	else
		signY	= -1
		offsetY	= WALL_THICKNESS - WIDO_SILL
	endif
endif


! ==============================================================================
! Call Leaf- and Right Cavity Closure Subroutines
! ==============================================================================

if WIDO_SILL <= gs_reveal_outer_jamb_depth then
	bSlantedOuterSide = 0
endif

if bCompositeWall then

	dim arrayCustomCC[8][4]

	! Initialize variable to CollectWallSkinSectionLines function
	iSkin = 1
	dim _wallSkinSectionLines[][7]
	for i = 1 to 7
		_wallSkinSectionLines[iSkin][i] = 0
	next i

	iTurnSkin = 1
	dim _turnSkinEndingLines[][7]
	for i = 1 to 7
		_turnSkinEndingLines[iTurnSkin][i] = 0
	next i

! Left Cavity Closure ==========================================================

	if not(bLeftCornerFunction) then

		if curvedWall then
			numTrans = 0
		else
			mul2 -1, 1
			numTrans = 1
		endif

		sideSign		= -1
		distanceX		= leftWidth
		alfaX			= leftAlfa
		alfaJamb		= gs_reveal_left * ArcLengthSillToAngle
		revealWidth		= gs_reveal_left
		revealAngle		= gs_reveal_left_angle
		revealSillAngle	= gs_reveal_outerLeft_angle
		bx = bxL
		by = byL
		sx = sxL
		sy = syL

		if bCavityCloserLeft | iClosureType	= CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then

			bCavityCloser	= bCavityCloserLeft

			if	iClosureType = CLOSURE_TRADITIONAL |\
				iClosureType = CLOSURE_FINISH then
				gosub "TraditionalCavityClosure"
			endif
			if	(iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) &\
				(bCavityCloserLeft | gs_cc_dutch_ShowLeft) & not(gs_stack_left) then

				gs_showJoint = gs_cc_dutch_ShowLeft
				gosub "TraditionalCavityClosure"	! Variable Closure

				if gs_showJoint & not(curvedWall) then
					gosub "CollectWallSkinSectionLines"

					_leftClosureFartherSideMPx = _closureFartherSideMPx * signX * sideSign
					_leftClosureFartherSideMPy = _closureFartherSideMPy * signY + offsetY
				endif
			endif
			if	iClosureType = CLOSURE_PREFABRICATED |\
				iClosureType = CLOSURE_AIR_SPACE then
				gosub "PrefabricatedCavityClosure"
			endif
			if	iClosureType = CLOSURE_CUSTOM |\
				iClosureType = CLOSURE_PLASTER_REVEAL |\
				iClosureType = CLOSURE_INSULATED_REVEAL |\
				iClosureType = CLOSURE_INSULATED_FOR_RENOVATION then

				arrayCustomCC		= gs_custom_cc_array_left
				revealWidthInner	= revealInnerLeft

				sillPx	= leftRevealPnts[idxSillStartRevealLeft][1]
				sillPy	= leftRevealPnts[idxSillStartRevealLeft][2] * signCurvedWall
				boardPx	= leftRevealPnts[idxBoardEndRevealLeft][1]
				boardPy	= leftRevealPnts[idxBoardEndRevealLeft][2] * signCurvedWall

				sillPx2	= leftRevealPnts[idxSillStartRevealLeft + 1][1]
				sillPy2	= leftRevealPnts[idxSillStartRevealLeft + 1][2] * signCurvedWall

				frameSillX	= frameSillXL
				frameSillY	= frameSillYL
				frameBoardX	= frameBoardXL
				frameBoardY	= frameBoardYL

!add2 A/2,0
!yy = 0
!for idx=1 to vardim1(gs_custom_cc_array_left)
!	iBitfield		  = round_int(gs_custom_cc_array_left[idx][CUSTOMCC_BITFIELD])
!	ccThickness		= gs_custom_cc_array_left[idx][CUSTOMCC_THICKNESS]
!	ccOverhang		= gs_custom_cc_array_left[idx][CUSTOMCC_OVERHANG]
!	ccSeparatorPen	= gs_custom_cc_array_left[idx][CUSTOMCC_PEN]
!
!	ccTurnIn		= bittest(iBitfield, 0)
!	ccThicknessType	= bittest(iBitfield, 1)
!	ccOrientation	= bittest(iBitfield, 2)
!	ccSeparator		= bittest(iBitfield, 3)
!	ccPlaster		= bittest(iBitfield, 4)
!
!	if idx=1 | idx=5 then: pen 20: else: pen 1: endif
!	text2 0,yy, \
!		str(ccTurnIn,1,0) +","+			\
!		str(ccThicknessType,1,0) +","+	\
!		str(ccOrientation,1,0) +","+	\
!		str(ccSeparator,1,0) +","+		\
!		str(ccPlaster,1,0) +" - "+		\
!		str(ccThickness * 1000,1,0) +","+	\
!		str(ccOverhang * 1000,1,0) +","+	\
!		str(ccSeparatorPen,1,0)
!
!	yy = yy + 0.1
!next idx
!del 1

				gosub "CustomCavityClosure"
			endif
		endif

		del numTrans

	endif

! Right Cavity Closure =========================================================

	if not(bCornerWindow) then
		if curvedWall then
			mul2 -1,1
			numTrans = 1
		else
			numTrans = 0
		endif

		sideSign		= 1
		distanceX		= rightWidth
		alfaX			= rightAlfa
		alfaJamb		= gs_reveal_right * ArcLengthSillToAngle
		revealWidth		= gs_reveal_right
		revealAngle		= gs_reveal_right_angle
		revealSillAngle	= gs_reveal_outerRight_angle
		bx = bxR
		by = byR
		sx = sxR
		sy = syR

		if bCavityCloserRight | iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then

			bCavityCloser	= bCavityCloserRight

			if	iClosureType = CLOSURE_TRADITIONAL |\
				iClosureType = CLOSURE_FINISH then
				gosub "TraditionalCavityClosure"
			endif
			if	(iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) &\
				(bCavityCloserRight | gs_cc_dutch_ShowRight) & not(gs_stack_right) then

				gs_showJoint = gs_cc_dutch_ShowRight
				gosub "TraditionalCavityClosure"	! Variable Closure

				if gs_showJoint & not(curvedWall) then
					gosub "CollectWallSkinSectionLines"

					_rightClosureFartherSideMPx = _closureFartherSideMPx * signX * sideSign
					_rightClosureFartherSideMPy = _closureFartherSideMPy * signY + offsetY
				endif
			endif
			if	iClosureType = CLOSURE_PREFABRICATED |\
				iClosureType = CLOSURE_AIR_SPACE then
				gosub "PrefabricatedCavityClosure"
			endif
			if	iClosureType = CLOSURE_CUSTOM |\
				iClosureType = CLOSURE_PLASTER_REVEAL |\
				iClosureType = CLOSURE_INSULATED_REVEAL |\
				iClosureType = CLOSURE_INSULATED_FOR_RENOVATION then

				arrayCustomCC		= gs_custom_cc_array_right
				revealWidthInner	= revealInnerRight

				sillPx	= rightRevealPnts[idxSillStartRevealRight][1]
				sillPy	= rightRevealPnts[idxSillStartRevealRight][2] * signCurvedWall
				boardPx	= rightRevealPnts[idxBoardEndRevealRight][1]
				boardPy	= rightRevealPnts[idxBoardEndRevealRight][2] * signCurvedWall

				sillPx2	= rightRevealPnts[idxSillStartRevealRight + 1][1]
				sillPy2	= rightRevealPnts[idxSillStartRevealRight + 1][2] * signCurvedWall

				frameSillX	= frameSillXR
				frameSillY	= frameSillYR
				frameBoardX	= frameBoardXR
				frameBoardY	= frameBoardYR

!add2 A/2,0
!yy = 0
!circle2 0,0,0.02
!for idx=1 to vardim1(gs_custom_cc_array_right)
!	iBitfield		  = round_int(gs_custom_cc_array_right[idx][CUSTOMCC_BITFIELD])
!	ccThickness		= gs_custom_cc_array_right[idx][CUSTOMCC_THICKNESS]
!	ccOverhang		= gs_custom_cc_array_right[idx][CUSTOMCC_OVERHANG]
!	ccSeparatorPen	= gs_custom_cc_array_right[idx][CUSTOMCC_PEN]
!
!	ccTurnIn		= bittest(iBitfield, 0)
!	ccThicknessType	= bittest(iBitfield, 1)
!	ccOrientation	= bittest(iBitfield, 2)
!	ccSeparator		= bittest(iBitfield, 3)
!	ccPlaster		= bittest(iBitfield, 4)
!
!	if idx=1 | idx=5 then: pen 20: else: pen 1: endif
!	text2 0,yy, \
!		str(ccTurnIn,1,0) +","+			\
!		str(ccThicknessType,1,0) +","+	\
!		str(ccOrientation,1,0) +","+	\
!		str(ccSeparator,1,0) +","+		\
!		str(ccPlaster,1,0) +" - "+		\
!		str(ccThickness * 1000,1,0) +","+	\
!		str(ccOverhang * 1000,1,0) +","+	\
!		str(ccSeparatorPen,1,0)
!
!	yy = yy + 0.1
!next idx
!del 1

				gosub "CustomCavityClosure"
			endif
		endif

		del numTrans
	endif

endif	! bCompositeWall


! Draw wall contour lines ======================================================

dim edgeSections[][7]

if vardim1(lineSections) > 0 | vardim1(contourLines) > 0 then
	gosub "DrawWallContourLines"
endif


! Restore the saved parameter buffer ===========================================

call "LoadQueue" parameters savedQueueValues = savedQueueValues


end

! ==============================================================================
! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
! ==============================================================================




! ==============================================================================
! === SUBROUTINES
! ==============================================================================


! ==============================================================================
!		Traditional Cavity Closure
! ------------------------------------------------------------------------------
! Input variables:
!	possibleSkinTurnIn:		number of possible plaster skins at the Outside Face
!	possibleSkinTurnOut:	number of possible plaster skins at the Inside Face
!	distanceX:				horizontal distance from the original origo
!	alfaX:					alfa x in case of curved walls (alfaX > 0)
!	alfaJamb:				jamb alfa (alfaJamb > 0)
!	revealWidth:			width of the reveal
! ==============================================================================

"TraditionalCavityClosure":

	if iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
		thkJoint = gs_cc_dutch_thkJoint
	else
		thkJoint = gs_thkJoint
	endif

	nSkins = WALL_SKINS_NUMBER - possibleSkinTurnOut - possibleSkinTurnIn
	if nSkins < 3 then return

	gs_nTurn = min(gs_nTurn, nSkins - 2)

	if iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
		signTurnDir = (gs_cc_dutch_ClosureToSide = 2) - not(gs_cc_dutch_ClosureToSide = 2)

		if gs_cc_dutch_ClosureToSide = 2 then
			idx = WALL_SKINS_NUMBER - possibleSkinTurnOut - gs_cc_dutch_ClosureToSkin: gosub 10	! Get proper index
			idx = max(idx, 1)
			idx = min(idx, WALL_SKINS_NUMBER + 1)
			baseSkinLevel = skinCummThkRef[idx]

			idx = WALL_SKINS_NUMBER - possibleSkinTurnOut:	gosub 10	! Get proper index
			idx = max(idx, 1)
			idx = min(idx, WALL_SKINS_NUMBER)
			baseSkinIdx = idx
		else
			idx = possibleSkinTurnIn + gs_cc_dutch_ClosureToSkin: gosub 10	! Get proper index
			idx = max(idx, 1)
			idx = min(idx, WALL_SKINS_NUMBER + 1)
			baseSkinIdx = idx
			baseSkinLevel = skinCummThkRef[baseSkinIdx]
		endif
	else
		signTurnDir = (gs_bTurnDir) - not(gs_bTurnDir)

		if gs_bTurnDir then
			idx = WALL_SKINS_NUMBER - possibleSkinTurnOut - 1: gosub 10	! Get proper index
			baseSkinLevel = skinCummThkRef[idx]

			idx = WALL_SKINS_NUMBER - possibleSkinTurnOut:	gosub 10	! Get proper index
			baseSkinIdx = idx
		else
			idx = possibleSkinTurnIn + 1: gosub 10	! Get proper index
			baseSkinIdx = idx
			baseSkinLevel = skinCummThkRef[baseSkinIdx]
		endif
	endif

	offsetFromJoint = ((iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) & not(gs_cc_dutch_TurnToClosure)) * gs_cc_dutch_TurnToClosureOffs
	if	iClosureType = CLOSURE_VARIABLE |\
		iClosureType = CLOSURE_DUTCH_VARIABLE then

		signTurnDir2 = (gs_bTurnDir) - not(gs_bTurnDir)
		if (gs_cc_dutch_ClosureToSide = 2) exor gs_bTurnDir then
			lengthSkinTurnIn = baseSkinLevel - signTurnDir2 * gs_bJoint * (offsetFromJoint)
		else
			lengthSkinTurnIn = baseSkinLevel - signTurnDir2 * gs_bJoint * (thkJoint + offsetFromJoint)
		endif
	else
		lengthSkinTurnIn = baseSkinLevel - signTurnDir * gs_bJoint * (thkJoint + offsetFromJoint)
	endif

!!!	idx = nSkinTurnIn + gs_nTurn: gosub 10	! Get proper index
	if gs_bTurnDir then
		idx = possibleSkinTurnIn + gs_nTurn: gosub 10	! Get proper index
		if idx > 0 then
			level_1 = skinCummThkRef[idx]
		else
			level_1 = 0
		endif
	else
		idx = WALL_SKINS_NUMBER - possibleSkinTurnOut - gs_nTurn: gosub 10	! Get proper index
		level_1 = skinCummThkRef[idx]
	endif

	idx = baseSkinIdx
	baseSkinFillType		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL])
	baseSkinFillFgPen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_PEN])
	baseSkinFillBgPen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_BACK_PEN])
	baseSkinFillOrientation	= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_ORIENTATION])
	baseSkinContLinePen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
	baseSkinContLineType	= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])

!!!	idx = nSkinTurnIn: gosub 10	! Get proper index
	if gs_bTurnDir then
		idx = possibleSkinTurnIn: gosub 10	! Get proper index
		if idx > 0 then
			level_2 = skinCummThkRef[idx]
		else
			level_2 = 0
		endif
	else
		idx = WALL_SKINS_NUMBER - possibleSkinTurnOut: gosub 10	! Get proper index
		level_2 = skinCummThkRef[idx]
	endif

	summThicknessOfTurnedSkins = abs(level_1 - level_2)

	dx = 0
	bCuttedPlug = 0
	bNegativeTurn = 0

	vectS = -sin(revealAngle) * signWallIsLeft
	vectC =  cos(revealAngle)

	if bFirstSkinAtReveal exor not(gs_bTurnDir) then
		if iRevealType = REVEAL_POSITIVE then dx = -revealWidth
		if iRevealType = REVEAL_NEGATIVE then dx = -revealWidth
		if iRevealType = REVEAL_SLANTED  then dx = -revealWidth

		if not(curvedWall) then
			slantX = 0
			vectS = sin(alfaX - alfaJamb)
			vectC = cos(alfaX - alfaJamb)
		endif

		bCuttedPlug		= 0
		plugLeftDx		= 0
		plugOnWindow	= 0		! GER request

		bIncludeReveal	= 0

		if	not(iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) &\
			iRevealType <> REVEAL_NEGATIVE &\
			revealWidth + EPS >= summThicknessOfTurnedSkins &\
			summThicknessOfTurnedSkins + (thkJoint + offsetFromJoint) < WIDO_SILL then

			! note: summThicknessOfTurnedSkins equals the summ width of the turned skins

			if gs_bTurnDir then
				baseSkinLevel = WIDO_SILL
				lengthSkinTurnIn = baseSkinLevel - gs_bJoint * (thkJoint + offsetFromJoint)
			else
				baseSkinLevel = WALL_THICKNESS - WIDO_SILL
				lengthSkinTurnIn = baseSkinLevel + gs_bJoint * (thkJoint + offsetFromJoint)
			endif
			plugOnWindow = 1
		else
			if not(iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) & iRevealType = REVEAL_NEGATIVE then
				plugLeftDx = 0

				if gs_bTurnDir then
					if baseSkinLevel - EPS > WIDO_SILL then
						bCuttedPlug = 1
					endif
				else
					if baseSkinLevel - EPS < WALL_THICKNESS - WIDO_SILL then
						bCuttedPlug = 1
					endif
				endif
			else
				if gs_bTurnDir then

					if iRevealType = REVEAL_NEGATIVE then
						testEPS = -EPS
					else
						testEPS = EPS
					endif

					if lengthSkinTurnIn - testEPS >= WIDO_SILL then
						if lengthSkinTurnIn - testEPS < WIDO_SILL then
							plugLeftDx = revealWidth
						else
							bIncludeReveal = 1
							if bSlantedInnerSide then
								if iRevealType = REVEAL_SLANTED then slantDy = lengthSkinTurnIn - WIDO_SILL
								if iRevealType = REVEAL_SPLAYED then slantDy = lengthSkinTurnIn - WIDO_SILL - WIDO_FRAME_THICKNESS
								dx = slantDy * tan(revealAngle)
							else
								dx = 0
							endif
						endif
					else
						bCuttedPlug = 1
					endif
				else
					if lengthSkinTurnIn + testEPS <= WALL_THICKNESS - WIDO_SILL then
						if lengthSkinTurnIn - testEPS > WALL_THICKNESS - WIDO_SILL then
							plugLeftDx = revealWidth
						else
							bIncludeReveal = 1
							if bSlantedInnerSide then
								if iRevealType = REVEAL_SLANTED then slantDy = WALL_THICKNESS - lengthSkinTurnIn - WIDO_SILL
								if iRevealType = REVEAL_SPLAYED then slantDy = WALL_THICKNESS - lengthSkinTurnIn - WIDO_SILL - WIDO_FRAME_THICKNESS
								dx = slantDy * tan(revealAngle)
							else
								dx = 0
							endif
						endif
					else
						bCuttedPlug = 1
					endif
				endif
			endif
		endif
		if WIDO_SILL < EPS & (iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE) then
			bIncludeReveal = 0
		endif
	else

		if iRevealType = REVEAL_NEGATIVE then
			if iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
				if gs_bTurnDir then
					if lengthSkinTurnIn + EPS >= WALL_THICKNESS - WIDO_SILL & WIDO_SILL < WALL_THICKNESS then
						bIncludeReveal = 1
					endif
				else
					if lengthSkinTurnIn + EPS <= WIDO_SILL & WIDO_SILL < WALL_THICKNESS then
						bIncludeReveal = 1
					endif
				endif
			else
				if gs_bTurnDir then
					if baseSkinLevel + EPS >= WALL_THICKNESS - WIDO_SILL & WIDO_SILL < WALL_THICKNESS then
						bIncludeReveal = 1
					endif
				else
					if baseSkinLevel + EPS <= WIDO_SILL & WIDO_SILL < WALL_THICKNESS then
						bIncludeReveal = 1
					endif
				endif
			endif
		else
			if gs_bTurnDir then
				if curvedWall & not(bWndCurved) then
					if wallIsLeft then
						sLevel = sqr(bx^2 + (by + WOD)^2) - radBoard
					else
						sLevel = WALL_THICKNESS - sqr(bx^2 + (by + WOD)^2) + radSill
					endif

					if baseSkinLevel - EPS >= sLevel then
						bCuttedPlug = 1
						plugLeftDx = -revealWidth
					endif
				else
					if baseSkinLevel + EPS > WALL_THICKNESS - WIDO_SILL then
						bCuttedPlug = 1
						plugLeftDx = -revealWidth
					endif
				endif
			else
				if curvedWall & not(bWndCurved) then
					if wallIsLeft then
						sLevel = radSill - sqr(bx^2 + (by + WOD)^2)
					else
						sLevel = sqr(bx^2 + (by + WOD)^2) - radSill
					endif

					if baseSkinLevel + EPS <= sLevel then
						bCuttedPlug = 1
						plugLeftDx = -revealWidth
					endif
				else
					if baseSkinLevel + EPS < WIDO_SILL then
						bCuttedPlug = 1
						plugLeftDx = -revealWidth
					endif
				endif
			endif
		endif

		if iRevealType = REVEAL_NEGATIVE then
			if gs_bTurnDir then
				if WALL_THICKNESS - WIDO_SILL < baseSkinLevel + EPS then
					dx = -revealWidth
				endif
			else
				if WIDO_SILL > baseSkinLevel + EPS then
					dx = -revealWidth
				endif
			endif
			bNegativeTurn = 1
		endif
		if iRevealType = REVEAL_SLANTED then slantLength = WALL_THICKNESS - WIDO_SILL
		if iRevealType = REVEAL_SPLAYED then slantLength = WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS

		if not(curvedWall) then
			if bSlantedInnerSide then
				slantX = tan(revealAngle)
				vectS = -sin(revealAngle) * signWallIsLeft
				vectC =  cos(revealAngle)
			else
				slantX = 0
				vectS = sin(alfaX)
				vectC = cos(alfaX)
			endif
		endif
	endif

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		bCuttedPlug		= 0
		bIncludeReveal	= 0
	endif

	if iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
		bCuttedPlug	= 0
		plugLeftDx	= 0

		dx = 0
		if bFirstSkinAtReveal then
			if	iRevealType = REVEAL_POSITIVE | \
				iRevealType = REVEAL_SLANTED then
				refLevelForDxTest = baseSkinLevel + (gs_cc_dutch_ClosureToSide = 1) * thkJoint
				if WIDO_SILL > refLevelForDxTest - EPS then
					dx = -revealWidth
				endif
			endif
			if iRevealType = REVEAL_NEGATIVE then
				refLevelForDxTest = baseSkinLevel - (gs_cc_dutch_ClosureToSide = 2) * thkJoint
				if WIDO_SILL > refLevelForDxTest + EPS then
					dx = -revealWidth
				endif
			endif
		else
			if	iRevealType = REVEAL_POSITIVE | \
				iRevealType = REVEAL_SLANTED then
				refLevelForDxTest = baseSkinLevel - (gs_cc_dutch_ClosureToSide = 2) * thkJoint
				if WALL_THICKNESS - WIDO_SILL < refLevelForDxTest + EPS then
					dx = -revealWidth
				endif
			endif
			if iRevealType = REVEAL_NEGATIVE then
				refLevelForDxTest = baseSkinLevel + (gs_cc_dutch_ClosureToSide = 1) * thkJoint
				if WALL_THICKNESS - WIDO_SILL < refLevelForDxTest - EPS then
					dx = -revealWidth
				endif
			endif
		endif
	endif

	if curvedWall then
		signTurnDir2 = (gs_bTurnDir) - not(gs_bTurnDir)

		if reorder then
			if iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
				rBegH = min(radSill, radBoard) + baseSkinLevel
				if (gs_cc_dutch_ClosureToSide = 2) exor gs_bTurnDir then
					rBegH = min(radSill, radBoard) + baseSkinLevel + signTurnDir2 * gs_bJoint * thkJoint
					rEndH = min(radSill, radBoard) + baseSkinLevel
				else
					rBegH = min(radSill, radBoard) + baseSkinLevel
					rEndH = min(radSill, radBoard) + baseSkinLevel - signTurnDir2 * gs_bJoint * thkJoint
				endif
			else
				rBegH = min(radSill, radBoard) + baseSkinLevel
				rEndH = min(radSill, radBoard) + baseSkinLevel - signTurnDir * thkJoint
			endif
		else
			if iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
				if (gs_cc_dutch_ClosureToSide = 2) exor gs_bTurnDir then
					rBegH = max(radSill, radBoard) - baseSkinLevel - signTurnDir2 * gs_bJoint * thkJoint
					rEndH = max(radSill, radBoard) - baseSkinLevel
				else
					rBegH = max(radSill, radBoard) - baseSkinLevel
					rEndH = max(radSill, radBoard) - baseSkinLevel + signTurnDir2 * gs_bJoint * thkJoint
				endif
			else
				rBegH = max(radSill, radBoard) - baseSkinLevel
				rEndH = max(radSill, radBoard) - baseSkinLevel + signTurnDir * thkJoint
			endif
		endif
		baseSkinRadius	= rEndH
		lengthToAngle	= (180 / rBegH / PI)	! Ref circle is on the rBegH
	endif

	dxAngle = dx * ArcLengthSillToAngle

	if iRevealType = REVEAL_SLANTED & not(bIncludeReveal) & wallIsLeft & (reorder exor gs_bTurnDir) then
		! In this special case we have to draw a normal positive reveal
		bSlantedInnerSide = 0
	endif


! Insulation Strip =============================================================

	dutchSpouwlatPx = 0
	dutchSpouwlatPy = 0

	if gs_bJoint then

		if iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
			widthJoint = gs_cc_dutch_widthJoint
		else
			widthJoint = summThicknessOfTurnedSkins
		endif

		if not(bFirstSkinAtReveal exor not(gs_bTurnDir)) & bSlantedInnerSide & not(curvedWall) then widthJoint = widthJoint / cos(revealAngle)

		if gs_bTurnDir then
			slantDx = bSlantedInnerSide * not(bFirstSkinAtReveal exor not(gs_bTurnDir)) * (baseSkinLevel - thkJoint - WALL_THICKNESS + WIDO_SILL) * tan(revealAngle)
		else
			slantDx = bSlantedInnerSide * not(bFirstSkinAtReveal exor not(gs_bTurnDir)) * (WIDO_SILL - baseSkinLevel - thkJoint) * tan(revealAngle)
		endif

		if not(bFirstSkinAtReveal exor not(gs_bTurnDir)) & baseSkinLevel > WIDO_SILL then
			if gs_bTurnDir then
				plugLeftDx = (WALL_THICKNESS - lengthSkinTurnIn - WIDO_SILL) * tan(revealAngle)
			else
				plugLeftDx = (lengthSkinTurnIn - WIDO_SILL) * tan(revealAngle)
			endif
		endif

! Closure is always placed to inside face of the wall at Dutch Closure =========

		offsetToJoint = 0
		if iClosureType = CLOSURE_DUTCH_VARIABLE then

			offsetToJoint = offsetFromJoint * not(gs_cc_dutch_TurnToClosure)

			if curvedWall & reorder then
				offsetToJoint = -offsetToJoint
			endif
		endif

! End of closure moving to inside face of the wall =============================

		if curvedWall then

			if bSlantedInnerSide | bParalellInCurvedWalls then

				xo = 0
				yo = -WOD

				ro = rBegH

				if (gs_bTurnDir exor reorder exor wallIsLeft) & bCuttedPlug then
					x1 = -sx * sideSign
					y1 =  sy
					x2 = x1 - sin(alfaX - alfaJamb)
					y2 = y1 + cos(alfaX - alfaJamb) * signWallIsLeft
				else
					x1 = -bx * sideSign
					y1 =  by
					x2 = x1 - vectS
					y2 = y1 + vectC * signWallIsLeft
				endif

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px1 = cx
				py1 = cy

				ro = baseSkinRadius

				x1 = -bx * sideSign - widthJoint * vectC
				y1 = by - widthJoint * vectS * signWallIsLeft
				x2 = x1 - vectS
				y2 = y1 + vectC * signWallIsLeft

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px3 = cx
				py3 = cy

				alpha =  atn(cx/(cy+WOD))
				px2 = px3 - signTurnDir2 * signReorder * signWallIsLeft * thkJoint * sin(alpha)
				py2 = py3 - signTurnDir2 * signReorder * signWallIsLeft * thkJoint * cos(alpha)

				ro = rEndH

				if (gs_bTurnDir exor reorder exor wallIsLeft) | not(bCuttedPlug) then
					x1 = -bx * sideSign
					y1 =  by
					x2 = x1 - vectS
					y2 = y1 + vectC * signWallIsLeft
				else
					x1 = -sx * sideSign
					y1 =  sy
					x2 = x1 - sin(alfaX - alfaJamb)
					y2 = y1 + cos(alfaX - alfaJamb) * signWallIsLeft
				endif

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px4 = cx
				py4 = cy

			else

				plugAngle = widthJoint * lengthToAngle
				alfaPlug = alfaX + dxAngle

				sin1 = sin(alfaPlug)
				cos1 = cos(alfaPlug) * signWallIsLeft
				sin2 = sin(alfaPlug + plugAngle)
				cos2 = cos(alfaPlug + plugAngle) * signWallIsLeft

				if bCuttedPlug then
					if gs_bTurnDir exor reorder exor wallIsLeft then
						alfaPlug3 = alfaX - alfaJamb
					else
						alfaPlug3 = alfaX
					endif
					sin3 = sin(alfaPlug3)
					cos3 = cos(alfaPlug3) * signWallIsLeft

					sin4 = sin(alfaX + dxAngle)
					cos4 = cos(alfaX + dxAngle) * signWallIsLeft
				endif

				if bCuttedPlug then
					px1 = -(rBegH - offsetToJoint) * sin3
					py1 = -WOD + (rBegH - offsetToJoint) * cos3
				else
					px1 = -(rBegH - offsetToJoint) * sin1
					py1 = -WOD + (rBegH - offsetToJoint) * cos1
				endif

				px2 = -(rBegH - offsetToJoint) * sin2
				py2 = -WOD + (rBegH - offsetToJoint) * cos2

				px3 = -(rEndH - offsetToJoint) * sin2
				py3 = -WOD + (rEndH - offsetToJoint) * cos2

				if bCuttedPlug then
					px4 = -(rEndH - offsetToJoint) * sin4
					py4 = -WOD + (rEndH + offsetToJoint) * cos4
				else
					px4 = -(rEndH - offsetToJoint) * sin1
					py4 = -WOD + (rEndH - offsetToJoint) * cos1
				endif
			endif
		else
			px1 = distanceX + dx + plugLeftDx
			py1 = baseSkinLevel - signTurnDir * offsetToJoint

			px2 = distanceX + dx + plugLeftDx
			py2 = baseSkinLevel - signTurnDir * (thkJoint + offsetToJoint)

			px3 = distanceX + dx - slantDx + widthJoint
			py3 = baseSkinLevel - signTurnDir * (thkJoint + offsetToJoint)

			px4 = distanceX + dx - slantDx + widthJoint
			py4 = baseSkinLevel - signTurnDir * offsetToJoint
		endif

		dutchSpouwlatPx = px3
		dutchSpouwlatPy = py3


! Draw Insulation Strip ========================================================

		if GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY then
			gs_showJoint = 0
		endif

		if gs_showJoint then
			pen gs_penJoint
			line_type gs_ltJoint
			set fill gs_fillJoint
			line_property LINE_PROPERTY_INNER

			penIdx		= gs_penJoint
			lineTypeIdx	= gs_ltJoint

			if bCuttedPlug then

				bDivide		= 0		! is sill line cross the insulation plug?
				divLength	= 0

				if bFirstSkinAtReveal then
					if gs_bTurnDir then
						bDivide = (baseSkinLevel + EPS  > WIDO_SILL & baseSkinLevel - thkJoint - EPS < WIDO_SILL)
						divLength = baseSkinLevel - WIDO_SILL
					else
						bDivide = (baseSkinLevel - EPS < WIDO_SILL & baseSkinLevel + thkJoint + EPS > WIDO_SILL)
						divLength = baseSkinLevel + thkJoint - WIDO_SILL
					endif
				else
					if gs_bTurnDir then
						bDivide = (baseSkinLevel + EPS > WALL_THICKNESS - WIDO_SILL & baseSkinLevel - thkJoint - EPS < WALL_THICKNESS - WIDO_SILL)
						divLength = baseSkinLevel - thkJoint - (WALL_THICKNESS - WIDO_SILL)
					else
						bDivide = (baseSkinLevel - EPS < WALL_THICKNESS - WIDO_SILL & baseSkinLevel + thkJoint + EPS > WALL_THICKNESS - WIDO_SILL)
						divLength = baseSkinLevel - (WALL_THICKNESS - WIDO_SILL)
					endif
				endif

				if iRevealType = REVEAL_SLANTED & not(plugOnWindow) & bDivide then
					px1Slant = abs(divLength * tan(revealAngle))
					px1Slant = max(0,px1Slant)
				else
					px1Slant = 0
				endif

				if bFirstSkinAtReveal then
					pySill = WIDO_SILL
				else
					pySill = WALL_THICKNESS - WIDO_SILL
				endif

				if curvedWall then
					if curvedWall & not(bWndCurved) & not(iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | iRevealType = REVEAL_NEGATIVE) & (py4 - EPS < by) & (py3 + EPS > by) then
						xo = 0
						yo = -WOD
						ro = baseSkinRadius - (reorder exor gs_bTurnDir) * thkJoint

						x1 = 0
						y1 = by
						x2 = 1
						y2 = by

						gosub 101	! Circle - Line intersection
						gosub 102	! Select good intersection point

						if (reorder exor gs_bTurnDir) then
							put	cx,				cy,		1,
								px2,			py2,	3000 * curvedWall + 1,
								px3,			py3,	1,
								px4,			py4,	3000 * curvedWall + 1

							put	-sideSign * bx,	by,		1
						else
							put	 px1,			py1,	1,
								 px2,			py2,	3000 * curvedWall + 1,
								 px3,			py3,	1,
								 cx,			cy,		3000 * curvedWall + 1,
								-bx * sideSign,	by,		1
						endif
					else
						put	px1,			py1,	1,
							px2,			py2,	3000 * curvedWall + 1,
							px3,			py3,	1,
							px4,			py4,	3000 * curvedWall + 1

						if gs_bTurnDir exor reorder exor wallIsLeft then
							put	-sideSign * bx,	by,		1,
								-sideSign * sx,	sy,		1
						else
							put	-sideSign * sx,	sy,		1,
								-sideSign * bx,	by,		1
						endif
					endif
				else
					if gs_bTurnDir exor reorder exor wallIsLeft then
						put	px1,		py1,		1,
							px1,		pySill,		1,
							distanceX,	pySill,		1,
							distanceX + px1Slant,	py3,		1,
							px3,		py3,		1,
							px4,		py4,		1
					else
						put	distanceX + px1Slant, baseSkinLevel,	1,
							distanceX,	pySill,		1,
							px1,		pySill,		1,
							px2,		py2,		1,
							px3,		py3,		1,
							px4,		py4,		1
					endif
				endif

				penFillFg	= gs_penJointFg
				penFillBg	= gs_penJointBg
				bLocalFill	= 0
				bDrawContour	= 1
				bFitToSkinFill	= 0
				bDrawWallBlock	= 1
				bClosureContour	= 0

				gosub 200	! Draw wallblock with contour
			else
				px1Slant = bSlantedInnerSide * bFirstSkinAtReveal * not(plugOnWindow) * thkJoint * tan(revealAngle)	! Slanted Reveal

				if curvedWall then
					px1Slant = 0
				else
					if bFirstSkinAtReveal exor not(gs_bTurnDir) then
						px1Slant =  bSlantedInnerSide * not(plugOnWindow) * thkJoint * tan(revealAngle)	! Slanted Reveal
					else
						if baseSkinLevel > WIDO_SILL then
							px1Slant = -bSlantedInnerSide * not(plugOnWindow) * thkJoint * tan(revealAngle)	! Slanted Reveal
						else
							px1Slant = 0
						endif
					endif
				endif

				put	px1 + px1Slant,	py1,	1,
					px2,			py2,	3000 * curvedWall + 1,
					px3,			py3,	1,
					px4,			py4,	3000 * curvedWall + 1

				penFillFg	= gs_penJointFg
				penFillBg	= gs_penJointBg
				bLocalFill	= 0
				bDrawContour	= 1
				bFitToSkinFill	= 0
				bDrawWallBlock	= not(iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE)
				bClosureContour = (iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE)

				gosub 200	! Draw wallblock with contour

				_closureFartherSidePx = px3
				! middle point of that side of closure which is farther from local origo and perpendicular to wall axis
				_closureFartherSideMPx = (px3 + px4)/2
				_closureFartherSideMPy = (py3 + py4)/2
			endif		! if bCuttedPlug then
		endif		! if gs_showJoint then
	endif		! if gs_bJoint then


! Turn Skins - Traditional Mode ================================================

	if bInclinedWall & not(iCavityClosureTurnDir = CAVITY_TURN_REFERENCE) then
		bStraightInside	 = 0
		bStraightOutside = 0
	else
		bStraightInside	 = 1
		bStraightOutside = 1
	endif
	turnThk = 0
	baseSkinRadius = baseSkinRadius + signReorder * signTurnDir2 * offsetFromJoint

	if gs_bTurnDir then
		startCount	= possibleSkinTurnIn + 1
		endCount	= possibleSkinTurnIn + gs_nTurn
	else
		startCount	= possibleSkinTurnOut + 1
		endCount	= possibleSkinTurnOut + gs_nTurn
	endif

	bHaveShownSkinBefore = (startCount > 1)		! Skin before the first turned skins is shown or not?
	if bHaveShownSkinBefore then
		prevSkinIdx = startCount - 1
		if gs_bTurnDir then
			idx = prevSkinIdx: gosub 10	! Get proper index
		else
			idx = WALL_SKINS_NUMBER - prevSkinIdx + 1: gosub 10	! Get proper index
		endif

		bHaveShownSkinBefore = not((GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY & WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] < EPS) | \
								   (GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) < EPS))
	endif

	if not(bCavityCloser) then
		return
	endif

	for i = startCount to endCount

		if gs_bTurnDir then
			idx = i: gosub 10	! Get proper index
		else
			idx = WALL_SKINS_NUMBER - i + 1: gosub 10	! Get proper index
		endif

		skinThk = WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
		bFirst	= (i = startCount)
		bLast	= (i = endCount)

		if reorder then
			cummThk = skinCummThkRef[idx + 1]
		else
			if idx > 1 then
				cummThk = skinCummThkRef[idx - 1]
			else
				cummThk = 0
			endif
		endif


! Curved Wall ==================================================================

		if curvedWall then

			bSpecCase	= (not(bIncludeReveal) & not(wallIsLeft) & not(reorder exor gs_bTurnDir))

			if gs_bTurnDir then
				py1 = cummThk + skinThk
				slantL = slantLength - py1
			else
				py1 = cummThk
				slantL = slantLength - WALL_THICKNESS + py1
			endif

			slantX = 0

! p1 point ---------------------------------------------------------------------

			xo = 0
			yo = -WOD
			if bFirstSkinAtReveal then
				if gs_bTurnDir then
					ro = radSill - (cummThk + skinThk) * signReorder
				else
					ro = radSill - cummThk * signReorder
				endif
			else
				if gs_bTurnDir then
					ro = radBoard - (cummThk + skinThk) * signReorder
				else
					ro = radBoard - cummThk * signReorder
				endif
			endif

			if bSlantedInnerSide | bParalellInCurvedWalls then
				x1 = -bx * sideSign - (turnThk + skinThk) * vectC
				y1 =  by - (turnThk + skinThk) * vectS * signWallIsLeft
				x2 = x1 - vectS
				y2 = y1 + vectC * signWallIsLeft
			else
				alfa = alfaX + (turnThk + skinThk) * lengthToAngle + dxAngle

				x1 = 0
				y1 = -WOD
				x2 = -signWallIsLeft * sin(alfa)
				y2 =  cos(alfa) - WOD
			endif

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			px1 = cx
			py1 = cy


! Valid Skin Test --------------------------------------------------------------

			if reorder exor gs_bTurnDir then
				bSkipThisSkin = (baseSkinRadius > ro - EPS)
			else
				bSkipThisSkin = (baseSkinRadius < ro + EPS)
			endif


! p4 point ---------------------------------------------------------------------

			if bFirstSkinAtReveal then
				if gs_bTurnDir then
					ro4 = radSill - cummThk * signReorder
				else
					ro4 = radSill - (cummThk + skinThk) * signReorder
				endif
			else
				if gs_bTurnDir then
					ro4 = radBoard - cummThk * signReorder
				else
					ro4 = radBoard - (cummThk + skinThk) * signReorder
				endif
			endif
			ro = ro4

			if (bSlantedInnerSide & not(bSpecCase & bFirst)) | bParalellInCurvedWalls then
				x1 = -bx * sideSign - turnThk * vectC
				y1 =  by - turnThk * vectS* signWallIsLeft
				x2 = x1 - vectS
				y2 = y1 + vectC * signWallIsLeft
			else
				alfa = alfaX + turnThk * lengthToAngle + dxAngle

				x1 = 0
				y1 = -WOD
				x2 = -signWallIsLeft * sin(alfa)
				y2 =  cos(alfa) - WOD
			endif

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			px4 = cx
			py4 = cy


! p2 point ---------------------------------------------------------------------

			ro = baseSkinRadius

			if bSlantedInnerSide | bParalellInCurvedWalls then
				x1 = -bx * sideSign - (turnThk + skinThk) * vectC
				y1 =  by - (turnThk + skinThk) * vectS * signWallIsLeft
				x2 = x1 - vectS
				y2 = y1 + vectC * signWallIsLeft
			else
				alfa = alfaX + (turnThk + skinThk) * lengthToAngle + dxAngle

				x1 = 0
				y1 = -WOD
				x2 = -signWallIsLeft * sin(alfa)
				y2 =  cos(alfa) - WOD
			endif

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			px2 = cx
			py2 = cy


! p3 point ---------------------------------------------------------------------

			if (bSlantedInnerSide & not(bSpecCase & bFirst)) | bParalellInCurvedWalls then
				x1 = -bx * sideSign - turnThk * vectC
				y1 =  by - turnThk * vectS* signWallIsLeft
				x2 = x1 - vectS
				y2 = y1 + vectC * signWallIsLeft
			else
				alfa = alfaX + turnThk * lengthToAngle + dxAngle

				x1 = 0
				y1 = -WOD
				x2 = -signWallIsLeft * sin(alfa)
				y2 =  cos(alfa) - WOD
			endif

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			px3 = cx
			py3 = cy

			if bIncludeReveal & bFirst then
				if bNegativeTurn then
					px6 = -sideSign * bx
					py6 =  by

					px5 = -sideSign * sx
					py5 =  sy
				else
					px5 = -sideSign * bx
					py5 =  by

					px6 = -sideSign * sx
					py6 =  sy
				endif

				ro = ro4	! on the same circle as the p4 point

				alfa = alfaX - not(bNegativeTurn) * alfaJamb

				if bParalellInCurvedWalls then
					x1 = -sx * sideSign
					y1 =  sy
					x2 = x1
					y2 = y1 + 1
				else
					x1 = 0
					y1 = -WOD
					x2 = -signWallIsLeft * sin(alfa)
					y2 =  cos(alfa) - WOD
				endif

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px7 = cx
				py7 = cy

				if px4 > px7 - EPS then		! to avoid generating degenerated polygons
					px4 = px7
					py4 = py7
				endif
			endif

		else

! Straight Wall, Trapezoid Wall ================================================

			if bInclinedWall then
				inclinedWallDiffInside	= skinCummThkOpp[idx] / incH
				if idx > 1 then
					inclinedWallDiffOutside	= skinCummThkOpp[idx - 1] / incH
				else
					inclinedWallDiffOutside = 0
				endif
			endif
			slantDiffUpper = not(bFirstSkinAtReveal exor not(gs_bTurnDir)) * bSlantedInnerSide * ((turnThk + skinThk) - (turnThk + skinThk) / cos(revealAngle))
			slantDiffLower = not(bFirstSkinAtReveal exor not(gs_bTurnDir)) * bSlantedInnerSide * (turnThk - turnThk / cos(revealAngle))

			py2 = lengthSkinTurnIn
			if gs_bTurnDir then
				slantL = slantLength - py2
			else
				slantL = slantLength - WALL_THICKNESS + py2
			endif
			px2 = distanceX + dx + turnThk + skinThk + slantL * slantX - slantDiffUpper

			if not(bStraightInside) then
				bStraightInside = (WALL_SKINS_PARAMS[idx][SKIN_THICKEN_TRAPEZOID])
			endif

			if gs_bTurnDir then
				py1 = cummThk + skinThk
				slantL = slantLength - py1
			else
				py1 = cummThk
				if bInclinedWall & not(bStraightInside) then
					py1 = WALL_THICKNESS - inclinedWallDiffInside
					py1 = py1 + (distanceX + dx + turnThk + skinThk) * incHor * sideSign * iInclDir
				endif
				slantL = slantLength - WALL_THICKNESS + py1
			endif

			if bInclinedWall & not(bStraightInside) & bSlantedInnerSide then
				x11 = 0
				y11 = WALL_THICKNESS - inclinedWallDiffInside
				x12 = x11 + incH * sideSign
				y12 = y11 + incV

				x21 = px2
				y21 = py2
				x22 = x21 + sin(revealAngle)
				y22 = y21 + cos(revealAngle)

				gosub 100	! Line - Line intersection

				px1 = cx
				py1 = cy
			else
				px1 = distanceX + dx + turnThk + skinThk + slantL * slantX - slantDiffUpper
			endif

			if gs_bTurnDir then
				bSkipThisSkin = (lengthSkinTurnIn < py1 + EPS)
			else
				bSkipThisSkin = (lengthSkinTurnIn > py1 - EPS)
			endif

			py3 = lengthSkinTurnIn
			if gs_bTurnDir then
				slantL = slantLength - py3
			else
				slantL = slantLength - WALL_THICKNESS + py3
			endif
			px3 = distanceX + dx + turnThk + slantL * slantX - slantDiffLower

			if bIncludeReveal & bFirst then
				if WIDO_SILL < EPS then
					py5 = cummThk
					px5 = distanceX + (py5 - WIDO_SILL)* tan(revealAngle)
				else
					if gs_bTurnDir exor bNegativeTurn then
						py5 = WIDO_SILL
					else
						py5 = WALL_THICKNESS - WIDO_SILL
					endif
					px5 = distanceX - bNegativeTurn * revealWidth

					if gs_bTurnDir exor bNegativeTurn then
						py6 = WIDO_SILL
					else
						py6 = WALL_THICKNESS - WIDO_SILL
					endif
					px6 = distanceX - not(bNegativeTurn) * revealWidth

					if gs_bTurnDir then
						py7 = cummThk
					else
						py7 = cummThk + skinThk
					endif
					px7 = distanceX - not(bNegativeTurn) * revealWidth
				endif
			endif

			if gs_bTurnDir then
				py4 = cummThk
				slantL = slantLength - py4
			else
				py4 = cummThk + skinThk
				if bInclinedWall & not(bStraightOutside) then
					py4 = WALL_THICKNESS - inclinedWallDiffOutside
					py4 = py4 + (distanceX + dx + turnThk) * incHor * sideSign * iInclDir
				endif
				slantL = slantLength - WALL_THICKNESS + py4
			endif

			if bInclinedWall & not(bStraightOutside) & bSlantedInnerSide then
				x11 = 0
				y11 = WALL_THICKNESS - inclinedWallDiffOutside
				x12 = x11 + incH * sideSign
				y12 = y11 + incV

				x21 = px3
				y21 = py3
				x22 = x21 + sin(revealAngle)
				y22 = y21 + cos(revealAngle)

				gosub 100	! Line - Line intersection

				px4 = cx
				py4 = cy
			else
				px4 = distanceX + dx + turnThk + (slantL)* slantX - slantDiffLower
			endif

			if not(bStraightOutside) then
				bStraightOutside = (WALL_SKINS_PARAMS[idx][SKIN_THICKEN_TRAPEZOID])
	        endif
		endif

! Draw the turned skins ========================================================

		bShowSkin = not( (GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY & WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] < EPS) | \
						 (GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) < EPS) )

		if not(bSkipThisSkin) then

			skinFillType		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL])
			skinFillFgPen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_PEN])
			skinFillBgPen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_BACK_PEN])
			skinFillOrientation	= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_ORIENTATION])
			bFitToSkinFill		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_FIT_TO_SKIN])
			skinTurnThk = skinThk

			fill skinFillType
			bLocalFill	= skinFillOrientation
			penFillFg	= skinFillFgPen
			penFillBg	= skinFillBgPen

			if gs_bTurnDir then
				bCond = (baseSkinLevel - (thkJoint + offsetFromJoint) < WIDO_SILL)
			else
				bCond = (baseSkinLevel + (thkJoint + offsetFromJoint) < WIDO_SILL)
			endif

			if bFirst & abs(slantX) > EPS & bCond then

				if gs_bTurnDir then
					boardY = by + WALL_THICKNESS - WIDO_SILL
				else
					boardY = by + WIDO_SILL
				endif
				put	px1,			py1,	0,
					px2,			py2,	0,
					bx * sideSign,	py3,	0,
					bx * sideSign,	boardY, 0,
					px4,			py4,	0
			else
				if bIncludeReveal & bFirst then
					if WIDO_SILL < EPS then
						put	px1,	py1,	0,
							px2,	py2,	0,
							px3,	py3,	0,
							px5,	py5,	0,
							px4,	py4,	0
					else
						put	px1,	py1,	0,
							px2,	py2,	0,
							px3,	py3,	3000 * curvedWall,
							px5,	py5,	0,
							px6,	py6,	0,
							px7,	py7,	0
						if px4 > px7 then
							put	px4,	py4,	3000 * curvedWall
						endif
						skinTurnThk = skinThk + revealWidth
					endif
				else
					if curvedWall & not(bWndCurved) & bFirst & not(iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | iRevealType = REVEAL_NEGATIVE) & (py3 - EPS < by) & (py4 + EPS > by) then
						xo = 0
						yo = -WOD
						ro = baseSkinRadius

						x1 = 0
						y1 = by
						x2 = 1
						y2 = by

						gosub 101	! Circle - Line intersection
						gosub 102	! Select good intersection point

						put	 px1,			py1,	0,
							 px2,			py2,	0,
							 cx,			cy,		3000,
							-sx * sideSign,	sy,		0,
							 px4,			py4,	0

						px3 = -sx * sideSign
						py3 =  sy
					else
						put	px1,	py1,	0,
							px2,	py2,	0,
							px3,	py3,	3000 * curvedWall,
							px4,	py4,	0
					endif
				endif
			endif

			if bShowSkin then
				bDrawContour = 0
				bDrawWallBlock = 1
				bClosureContour	= 0
				gosub 200	! Draw wallblock
			else
				if nsp >= 9 then
					fill 0
					wallhole2 nsp/3 + 1, 2, 0, -1,
						0, 0, 0,
						0,-WOD,900,
						get(nsp)
				else
					for ii=1 to nsp
						n = get(1)
					next ii
				endif
			endif

			if gs_bTurnDir then
				tempPen		 = round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN])
				tempLineType = round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE])
			else
				tempPen		 = round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
				tempLineType = round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])
			endif
			if tempPen > 0 & bShowSkin then
				pen			tempPen
				line_type	tempLineType
				if GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY then
					line_property LINE_PROPERTY_CONTOUR
				else
					line_property LINE_PROPERTY_INNER
				endif

				wallline2	px1,py1, px2,py2

				if not(gs_bJoint) or gs_bJoint * not(gs_showJoint) then	! Contonouous mode
					if not(bForceContinousMode) & (baseSkinFillType <> skinFillType | baseSkinFillFgPen <> skinFillFgPen | baseSkinFillBgPen <> skinFillBgPen | baseSkinFillOrientation <> skinFillOrientation) then
						if baseSkinContLinePen > EPS then
							if thkJoint < EPS then
								pen baseSkinContLinePen
							endif
							line_type	baseSkinContLineType

							wallline2 px2,py2, px3,py3
						endif
					endif
				endif
			endif

			if (iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) & not(curvedWall) then
				_turnSkinEndingLines[iTurnSkin][LINE_BEG_X]			= px2 * signX * sideSign
				_turnSkinEndingLines[iTurnSkin][LINE_BEG_Y]			= py2 * signY + offsetY
				_turnSkinEndingLines[iTurnSkin][LINE_END_X]			= px3 * signX * sideSign
				_turnSkinEndingLines[iTurnSkin][LINE_END_Y]			= py3 * signY + offsetY
				_turnSkinEndingLines[iTurnSkin][LINE_ATTRIBUTES]	= 0		! unused
				_turnSkinEndingLines[iTurnSkin][LINE_PEN_IDX]		= round_int(WALL_SKINS_PARAMS[idx][SKIN_END_FACE_PEN])
				_turnSkinEndingLines[iTurnSkin][LINE_LTYPE_IDX]		= WALL_SKINS_PARAMS[idx][SKIN_END_LINE_TYPE]
				iTurnSkin = iTurnSkin + 1
			endif

! It is needed in every cases to show the overlapping (wall contour on closure contour) edges
! because the state of "Show Opening Only" MVO function are not queried.
! If it will have a query then this line is removable back to original line.
!!!			if (iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) & (offsetFromJoint > EPS | dutchSpouwlatPx < max(px2,px3)) then
			if (iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) then
				tempPen = round_int(WALL_SKINS_PARAMS[idx][SKIN_END_FACE_PEN])
				if tempPen > 0 & bShowSkin then
					pen			tempPen
					line_type	WALL_SKINS_PARAMS[idx][SKIN_END_LINE_TYPE]
					if GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY then
						line_property LINE_PROPERTY_CONTOUR
					else
						line_property LINE_PROPERTY_INNER
					endif
					if curvedWall then
						R = sqr(px2^2 + (py2 + WOD)^2)

						vx = px2
						vy = py2 + WOD
						gosub 103	! Direction Angle
						alpha = angle

						vx = px3
						vy = py3 + WOD
						gosub 103	! Direction Angle
						beta = angle

						if abs(alpha - beta) > EPS then
							wallarc2 0,-WOD, R, min(alpha,beta), max(alpha,beta)
						endif
					else
! It is needed in every cases to show the overlapping (wall contour on closure contour) edges
! because the state of "Show Opening Only" MVO function are not queried.
! If it will have a query then this four lines are allowed again.
!!!						if offsetFromJoint > EPS | not(gs_showJoint) then
							wallline2	px2,py2, px3,py3
!!!						else
!!!							wallline2	max(dutchSpouwlatPx, px2),py2,
!!!										max(dutchSpouwlatPx, px3),py3
!!!						endif
					endif
				endif
			endif
		endif

		if gs_bTurnDir then
			tempPen		 = round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
			tempLineType = round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])
		else
			tempPen		 = round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN])
			tempLineType = round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE])
		endif

		if bIncludeReveal & bFirst then
			if WIDO_SILL < EPS then
			else
				bpx = px3
				bpy = py3
				epx = px5
				epy = py5
				penIdx		= bShowSkin  * tempPen
				lineTypeIdx	= tempLineType

				if bShowSkin then
					iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, not(bHaveShownSkinBefore))
					gosub 4920	! Put line section into Cavity Closure lines array
				else
					iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
					gosub 4910	! Put line section into wallhole lines array
				endif

				bpx = px5
				bpy = py5
				epx = px6
				epy = py6
				penIdx		= bShowSkin  * tempPen
				lineTypeIdx	= tempLineType

				if bShowSkin then
					iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, not(bHaveShownSkinBefore))
					gosub 4920	! Put line section into Cavity Closure lines array
				else
					iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
					gosub 4910	! Put line section into wallhole lines array
				endif

				bpx = px6
				bpy = py6
				epx = px7
				epy = py7
				penIdx		= bShowSkin  * tempPen
				lineTypeIdx	= tempLineType

				if bShowSkin then
					iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, not(bHaveShownSkinBefore))
					gosub 4920	! Put line section into Cavity Closure lines array
				else
					iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
					gosub 4910	! Put line section into wallhole lines array
				endif
			endif
		else
			if (not(curvedWall) & (py4 > py3 exor gs_bTurnDir)) | (curvedWall & (py4 > py3 exor wallIsLeft exor reorder exor gs_bTurnDir)) then
				bpx = px3
				bpy = py3
				epx = px4
				epy = py4
				penIdx		= bShowSkin  * tempPen
				lineTypeIdx	= tempLineType

				if bShowSkin then
					iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, not(bHaveShownSkinBefore))
					gosub 4920	! Put line section into Cavity Closure lines array
				else
					iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
					gosub 4910	! Put line section into wallhole lines array
				endif
			endif
		endif

		if bFirst & bShowSkin then
			if tempPen > 0 then
				pen			tempPen
				line_type	tempLineType
				if bHaveShownSkinBefore then
					line_property LINE_PROPERTY_INNER
				else
					line_property LINE_PROPERTY_CONTOUR
				endif

				if not(curvedWall) | (py4 < py3 exor wallIsLeft exor reorder) then
					if abs(slantX) < EPS then
						if bIncludeReveal then
							if WIDO_SILL < EPS then
								wallline2	px3,py3, px5,py5
							else
								if ((wallIsLeft exor reorder) & maxSkinTurnIn = 0) | (not(wallIsLeft exor reorder) & maxSkinTurnOut = 0) then
									line_property LINE_PROPERTY_CONTOUR
								endif

								if not(bInclinedWall & not(gs_bTurnDir)) & px4 > px7 then
									! because the top of the "bIncludeReveal" polygon does not fit to the inclined wall's slanted side
									wallline2	px4,py4, px7,py7
								endif
							endif
						else
!!!							wallline2	px3,py3, px4,py4

							bpx = px3
							bpy = py3
							epx = px4
							epy = py4
							penIdx		= tempPen
							lineTypeIdx	= tempLineType

							if bShowSkin then
								iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, not(bHaveShownSkinBefore))
								gosub 4920	! Put line section into Cavity Closure lines array
							else
								iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
								gosub 4910	! Put line section into wallhole lines array
							endif
						endif
					endif
				else
					if curvedWall & bIncludeReveal then
						R = sqr(px4^2 + (py4 + WOD)^2)

						vx = px4
						vy = py4 + WOD
						gosub 103	! Direction Angle
						alpha = angle

						vx = px7
						vy = py7 + WOD
						gosub 103	! Direction Angle
						beta = angle

						if abs(alpha - beta) > EPS then
							wallarc2 0,-WOD, R, min(alpha,beta), max(alpha,beta)
						endif
					endif
				endif

				if iRevealType = REVEAL_NEGATIVE then

					line_property LINE_PROPERTY_INNER

					if curvedWall & bWndCurved then
!						R = sqr(bx^2 + (by + WOD)^2)
!
!						vx = -bx * sideSign
!						vy =  by + WOD
!						gosub 103	! Direction Angle
!						alpha = angle
!
!						vx = -sx * sideSign
!						vy =  sy + WOD
!						gosub 103	! Direction Angle
!						beta = angle
!
!						if abs(alpha - beta) > EPS then
!							wallarc2 0,-WOD, R, min(alpha,beta), max(alpha,beta)
!						endif
						wallline2 -bx * sideSign,by, -sx * sideSign,sy
					else
						if curvedWall then
							revealY = by
							signTemp = -1
						else
							signTemp = 1
							if reorder exor wallIsLeft then
								revealY = by + WIDO_SILL
							else
								revealY = by + WALL_THICKNESS - WIDO_SILL
							endif
						endif

						wallline2	bx * signTemp * sideSign, revealY,
									sx * signTemp * sideSign, revealY
						if bDrawObjContourIn | bDrawObjContourOut then
							line2	bx * signTemp * sideSign, revealY,
									sx * signTemp * sideSign, revealY
						endif
					endif
				endif
			endif
		endif

		turnThk = turnThk + skinThk
		bHaveShownSkinBefore = bShowSkin
	next i
return


! ==============================================================================
!		Prefabricated Cavity Closure
! ------------------------------------------------------------------------------
! Input variables:
!	possibleSkinTurnIn:		number of possible plaster skins at the Outside Face
!	possibleSkinTurnOut:	number of possible plaster skins at the Inside Face
!	distanceX:				horizontal distance from the original origo
!	alfaX:					alfa x in case of curved walls (alfaX > 0)
!	alfaJamb:				jamb alfa (alfaJamb > 0)
!	revealWidth:			width of the reveal
!	skinCummThkRef:			precalculated cummulative skin thickness from the Outside Face
! ==============================================================================

"PrefabricatedCavityClosure":

!!!pen 1
!!!
!!!add2 sideSign * (distanceX + 0.2),0
!!!mul2 sideSign, 1
!!!circle2 0,0, 0.010
!!!text2 0.04,0, "mm"
!!!for i=1 to WALL_SKINS_NUMBER
!!!	idx = i
!!!
!!!	sName = "N"
!!!	if abs(WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] - 1) < EPS then sName = "C"
!!!	if abs(WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] - 3) < EPS then sName = "LC"
!!!	if abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) < EPS then sName = "P"
!!!	thk = WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
!!!
!!!!!!	gosub 10	! Get proper index
!!!	add2 0, skinCummThkRef[idx] - thk/2
!!!	circle2 0,0, 0.005
!!!	text2 0,0, sName
!!!	text2 0.04,0, thk
!!!	del 1
!!!next i
!!!del 2

	if lastCoreSkin = 0 then
		return
	endif

	nSkins = WALL_SKINS_NUMBER - possibleSkinTurnOut - possibleSkinTurnIn
	if nSkins < 3 then return

	bSlantedInnerSide	= (iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED)
	bNegativeReveal		= (iRevealType = REVEAL_NEGATIVE)

	fill gs_fillPlug
	pen gs_penPlug
	line_type gs_ltPlug
	line_property LINE_PROPERTY_INNER

	idx = possibleSkinTurnIn + 1
	gosub 10	! Get proper index
	begH = skinCummThkRef[idx]
	properBegIdx = idx

	idx = min(lastCoreSkin - 1, possibleSkinTurnIn + nSkins - 1)

	if idx < 1 then
		return
	endif

	gosub 10	! Get proper index

	endH = skinCummThkRef[idx]
	properEndIdx = idx

	if abs(endH - begH) < EPS then return

	vectS = 0
	vectC = 1

	if curvedWall then

! Curved Wall ==================================================================

		rWindowEdge = sqr((bx * sideSign)^2 + (by + WOD)^2)
		rRevealEdge = sqr((sx * sideSign)^2 + (sy + WOD)^2)

		if reorder then
			rBegH = min(radSill, radBoard) + begH
			rEndH = min(radSill, radBoard) + endH
		else
			rBegH = max(radSill, radBoard) - begH
			rEndH = max(radSill, radBoard) - endH
		endif
		plugAngle = gs_widthPlug * (180 / max(rBegH, rEndH) / PI)

		if wallIsLeft exor (iRevealType = REVEAL_NEGATIVE) then
			refH = min(rBegH, rEndH)
			oppH = max(rBegH, rEndH)
		else
			refH = max(rBegH, rEndH)
			oppH = min(rBegH, rEndH)
		endif

! Curved walls - Slanted Reveal ================================================

		if bSlantedInnerSide | bParalellInCurvedWalls then

			xo = 0
			yo = -WOD
			ro = refH

			if wallIsLeft then

				bPullBackPlug = 0

				if rWindowEdge < refH + EPS then
					bSlantedPlug = 0
				else
					bSlantedPlug = 1
				endif

				if (rWindowEdge < oppH & rWindowEdge > refH) then
					bCuttedPlug = 1
				else
					bCuttedPlug = 0
				endif
			else
				bPullBackPlug = (rWindowEdge > refH + EPS & rRevealEdge < refH + EPS)

				if rWindowEdge > refH + EPS & rRevealEdge > refH + EPS then
					bSlantedPlug = 0
				else
					bSlantedPlug = 1
				endif

				if (rWindowEdge > oppH & rWindowEdge < refH) | (rRevealEdge > oppH & rRevealEdge < refH) then
					bCuttedPlug = 1
				else
					bCuttedPlug = 0
				endif
			endif

			if bParalellInCurvedWalls then
				bCuttedPlug = 0
				bSlantedPlug =1
			endif

			if bSlantedPlug & not(bPullBackPlug) then
				if bWndCurved then
					x1 = -rSillLine * sin(alfaX)
					y1 = iArchSign * (-abs(WOD) + rSillLine * cos(alfaX))
					x2 = x1 - sin(revealAngle)
					y2 = y1 - cos(revealAngle)
				else
					x1 = -distanceX
					y1 = 0
					!!! wallThkOppSide = wallThkOppSide + max(leftWidth, rightWidth) * tan(abs(WALL_INCL)) !!!
					wallThkOppSide = 0
					x2 = -distanceX - wallThkOppSide * tan(revealAngle)
					y2 = -wallThkOppSide
				endif

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point

				alfaPlug = -signWallIsLeft * atn(cx / (WOD + cy))

				ro = oppH
				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point

				alfaPlugOpp = -signWallIsLeft * atn(cx / (WOD + cy))

				sin1 = sin(alfaPlug)
				cos1 = cos(alfaPlug) * signWallIsLeft
				sin2 = sin(alfaPlug + plugAngle)
				cos2 = cos(alfaPlug + plugAngle) * signWallIsLeft
				sin3 = sin(alfaPlugOpp)
				cos3 = cos(alfaPlugOpp) * signWallIsLeft
				if bCuttedPlug then
					if bWndCurved then
						alpha = atn(bx * sideSign / (by + WOD))
					else
						alpha = atn(distanceX / WOD)
					endif
					sin4 = sin(alpha)
					cos4 = cos(alpha)
				endif

				if wallIsLeft exor reorder then
					if bCuttedPlug then
						x1 = -rBegH * sin4 * signWallIsLeft
						y1 = -WOD + rBegH * cos4 * signWallIsLeft
					else
						x1 = -rBegH * sin3
						y1 = -WOD + rBegH * cos3
					endif
				else
					x1 = -rBegH * sin1
					y1 = -WOD + rBegH * cos1
				endif

				x2 = -rBegH * sin2
				y2 = -WOD + rBegH * cos2

				x3 = -rEndH * sin2
				y3 = -WOD + rEndH * cos2

				if bCuttedPlug then
					if wallIsLeft exor reorder then
						x4 = -rEndH * sin1
						y4 = -WOD + rEndH * cos1

						x5 = -bx * sideSign
						y5 = by
					else
						x4 = -rEndH * sin4 * signWallIsLeft
						y4 = -WOD + rEndH * cos4 * signWallIsLeft

						x5 = -bx * sideSign
						y5 = by
					endif
				else
					if wallIsLeft exor reorder then
						x4 = -rEndH * sin1
						y4 = -WOD + rEndH * cos1
					else
						x4 = -rEndH * sin3
						y4 = -WOD + rEndH * cos3
					endif
				endif

				put x1,	y1,	1,
					x2,	y2,	3001,
					x3,	y3,	1,
					x4,	y4,	3001

				if bCuttedPlug then
					put x5,y5, 1
				endif

			else	! if bSlantedPlug & not(bPullBackPlug) then

				if bPullBackPlug then
					alfaPlug = abs(atn(bx / (by + WOD)))
				else
					alfaPlug = alfaX - alfaJamb
				endif

				sin1 = sin(alfaPlug)
				cos1 = cos(alfaPlug) * signWallIsLeft
				sin2 = sin(alfaPlug + plugAngle)
				cos2 = cos(alfaPlug + plugAngle) * signWallIsLeft

				x1 = -rBegH * sin1
				y1 = -WOD + rBegH * cos1

				x2 = -rBegH * sin2
				y2 = -WOD + rBegH * cos2

				x3 = -rEndH * sin2
				y3 = -WOD + rEndH * cos2

				x4 = -rEndH * sin1
				y4 = -WOD + rEndH * cos1

				put x1,y1, 1,
					x2,y2, 3001,
					x3,y3, 1,
					x4,y4, 3001
			endif	! if bSlantedPlug & not(bPullBackPlug) then ... else

		endif	! if bSlantedInnerSide then

! bPullBackPlug ================================================================

		if bWndCurved then
			if bNegativeReveal then
				if wallIsLeft then
					bPullBackPlug = (max(rBegH, rEndH) <= rSillLine + EPS)
				else
					bPullBackPlug = (min(rBegH, rEndH) >= rSillLine - EPS)
				endif
			else
				if wallIsLeft then
					bPullBackPlug = (min(rBegH, rEndH) <= rSillLine - EPS)
				else
					bPullBackPlug = (max(rBegH, rEndH) >= rSillLine + EPS)
				endif
			endif
		else
			if wallIsLeft then
				rCorner	= max(rWindowEdge, rRevealEdge)
			else
				rCorner	= min(rWindowEdge, rRevealEdge)
			endif

			if bNegativeReveal then
				if wallIsLeft then
					bPullBackPlug = (max(rBegH, rEndH) <= rCorner + EPS)
				else
					bPullBackPlug = (min(rBegH, rEndH) >= rCorner + EPS)
				endif
			else
				rWindowInnerEdge = sqr((distanceX)^2 + (WOD - WIDO_FRAME_THICKNESS)^2)

				if wallIsLeft then
					bPullBackPlug = ((min(rBegH, rEndH) < rCorner + EPS) | (min(rBegH, rEndH) < rWindowInnerEdge + EPS))
				else
					bPullBackPlug = ((max(rBegH, rEndH) > rCorner + EPS) | (max(rBegH, rEndH) > rWindowInnerEdge + EPS))
				endif
			endif
		endif

! Curved walls - not Slanted Reveal ============================================

		if not(bSlantedInnerSide | bParalellInCurvedWalls) then

			if bPullBackPlug then
				if abs(bx) < abs(sx) exor bNegativeReveal then
					alfaPlug = abs(atn(abs(sx) / (WOD + sy)))
				else
					alfaPlug = abs(atn(abs(bx) / (WOD + by)))
				endif
			else
				alfaPlug = alfaX - alfaJamb
			endif

			alfaPlugOpp = alfaPlug

			sin1 = sin(alfaPlug)
			cos1 = cos(alfaPlug) * signWallIsLeft
			sin2 = sin(alfaPlug + plugAngle)
			cos2 = cos(alfaPlug + plugAngle) * signWallIsLeft
			sin3 = sin(alfaPlugOpp)
			cos3 = cos(alfaPlugOpp) * signWallIsLeft

			if wallIsLeft then
				x1 = -rBegH * sin1
				y1 = -WOD + rBegH * cos1
			else
				x1 = -rBegH * sin3
				y1 = -WOD + rBegH * cos3
			endif

			x2 = -rBegH * sin2
			y2 = -WOD + rBegH * cos2

			x3 = -rEndH * sin2
			y3 = -WOD + rEndH * cos2

			if wallIsLeft then
				x4 = -rEndH * sin3
				y4 = -WOD + rEndH * cos3
			else
				x4 = -rEndH * sin1
				y4 = -WOD + rEndH * cos1
			endif

			put x1,y1, 1,
				x2,y2, 3001,
				x3,y3, 1,
				x4,y4, 3001
		endif	! if bSlantedInnerSide then

	else	! if curvedWall then


! Straight and Trapezoid Wall ==================================================

		if wallIsLeft exor bNegativeReveal exor reorder then
			if iRevealType = REVEAL_NEGATIVE then
				revealLevel = WALL_THICKNESS - WIDO_SILL
			else
				revealLevel = WIDO_SILL
			endif
			bPullBackPlug = (endH - EPS > revealLevel)
		else
			if iRevealType = REVEAL_NEGATIVE then
				revealLevel = WIDO_SILL
			else
				revealLevel = WALL_THICKNESS - WIDO_SILL
			endif
			bPullBackPlug = (begH + EPS < revealLevel)
		endif

		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
			posPlug = distanceX
			bPullBackPlug = 0
		endif
		if iRevealType = REVEAL_POSITIVE then
			posPlug = distanceX - not(bPullBackPlug) * revealWidth
		endif
		if iRevealType = REVEAL_NEGATIVE then
			posPlug = distanceX - bPullBackPlug * revealWidth
		endif
		if iRevealType = REVEAL_SLANTED then
			posPlug = distanceX - not(bPullBackPlug) * revealWidth
		endif

		if bSlantedInnerSide & bPullBackPlug then
			if wallIsLeft exor reorder then
				sillLine = WIDO_SILL
			else
				sillLine = WALL_THICKNESS - WIDO_SILL
			endif

			if wallIsLeft exor reorder then
				refH = endH
				oppH = begH
			else
				refH = begH
				oppH = endH
			endif

			x11 = distanceX
			y11 = sillLine
			x12 = x11 + sin(revealAngle)
			y12 = y11 + signWallIsLeft * signReorder * cos(revealAngle)

			x21 = 0
			y21 = refH
			x22 = 1
			y22 = refH

			gosub 100	! Line - Line intersection

			if sillLine < endH & sillLine > begH then
				put posPlug, sillLine, 1,
					posPlug, oppH, 1
			else
				put cx - (endH-begH) * tan(revealAngle), oppH, 1
			endif

			put	cx + gs_widthPlug, oppH, 1,
				cx + gs_widthPlug, refH, 1,
				cx, refH, 1
		else
			put	posPlug, begH, 1,
				posPlug, endH, 1,
				posPlug + gs_widthPlug, endH, 1,
				posPlug + gs_widthPlug, begH, 1
		endif

	endif	! if curvedWall then

! Draw Insulation Plug =========================================================

	if GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY then
		for ii=1 to nsp
			n = get(1)
		next ii
	else
		bLocalFill	= 0
		penFillFg	= gs_penPlugFg
		penFillBg	= gs_penPlugBg
		bDrawContour	= 1
		bFitToSkinFill	= 0
		bDrawWallBlock	= 1
		bClosureContour	= 0

		penIdx		= gs_penPlug
		lineTypeIdx	= gs_ltPlug

		gosub 200	! Draw wallblock with contour
	endif


! Draw wall skin part ==========================================================

	if (wallIsLeft exor bNegativeReveal exor reorder) | bInclinedWall then
		if iRevealType = REVEAL_NEGATIVE & bInclinedWall then
			y1 = revealLevel
			y2 = endH
			if reorder then
				idx = properEndIdx - 1
			else
				idx = properEndIdx + 1
			endif
		else
			y1 = begH
			y2 = revealLevel
			idx = properBegIdx
		endif
	else
		y1 = revealLevel
		y2 = endH
		if reorder then
			idx = properEndIdx - 1
		else
			idx = properEndIdx + 1
		endif
	endif

	skinThickness = WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]

	bShowSkin = not( (GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY & WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] < EPS) | \
					 (GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) < EPS) )

!!!	if bShowSkin then
		if curvedWall then
			if (bPullBackPlug exor bNegativeReveal) & iRevealType > REVEAL_NO then
				aWindowEdge = atn(bx * sideSign / (by + WOD))
				aRevealEdge = atn(sx * sideSign / (sy + WOD))

				px1 = -bx * sideSign
				py1 =  by

				px2 = -sx * sideSign
				py2 =  sy

				if bParalellInCurvedWalls then
					xo = 0
					yo = -WOD
					ro = oppH

					x1 = px2
					y1 = py2
					x2 = x1
					y2 = y1 + 1

					gosub 101	! Circle - Line intersection
					gosub 102	! Select good intersection point
					px3 = cx
					py3 = cy

					px33 = px3
					py33 = sqr((ro + skinThickness)^2 - px33^2) - WOD

					x1 = px1
					y1 = py1
					x2 = x1
					y2 = y1 + 1

					gosub 101	! Circle - Line intersection
					gosub 102	! Select good intersection point
					px4 = cx
					py4 = cy

					px44 = px4
					py44 = sqr((ro - skinThickness)^2 - px44^2) - WOD
				else
					px3 = -signWallIsLeft * oppH * sin(aRevealEdge)
					py3 = -WOD + signWallIsLeft * oppH * cos(aRevealEdge)

					px33 = -signWallIsLeft * (oppH + skinThickness) * sin(aRevealEdge)
					py33 = -WOD + signWallIsLeft * (oppH + skinThickness) * cos(aRevealEdge)

					px4 = -signWallIsLeft * oppH * sin(aWindowEdge)
					py4 = -WOD + signWallIsLeft * oppH * cos(aWindowEdge)

					px44 = -signWallIsLeft * (oppH - skinThickness) * sin(aWindowEdge)
					py44 = -WOD + signWallIsLeft * (oppH - skinThickness) * cos(aWindowEdge)
				endif

				bSkip4 = (abs(px1 - px4) < EPS & abs(py1 - py4) < EPS)		! Avoid generating invalid polygon

				put	px1, py1, 0,
					px2, py2, 3000 * bWndCurved + 1

				if wallIsLeft then
					if bWndCurved then
						if not(bNegativeReveal) & oppH > rWindowEdge + EPS & refH < rWindowEdge - EPS then
							put px3, py3, 0,
								px4, py4, 3000
						endif
						if bNegativeReveal & refH > rWindowEdge + EPS & oppH < rWindowEdge - EPS then
							put px3, py3, 0,
								px4, py4, 3000
						endif
					else
						bOutPoint = 0
						if py3 > py2 exor bNegativeReveal then
							put px3, py3, 0
							bOutPoint = 1
						endif
						if (py4 > py1 exor bNegativeReveal) & not(bSkip4) then
							put px4, py4, 3000 * bOutPoint
						endif
					endif
				else
					if bWndCurved then
						if not(bNegativeReveal) & refH > rWindowEdge + EPS & oppH < rWindowEdge - EPS then
							put px3, py3, 0,
								px4, py4, 3000
						endif
						if bNegativeReveal & oppH > rWindowEdge + EPS & refH < rWindowEdge - EPS then
							put px3, py3, 0,
								px4, py4, 3000
						endif
					else
						bOutPoint = 0
						if py3 > py2 exor bNegativeReveal then
							put px3, py3, 0
							bOutPoint = 1
						endif
						if (py4 > py1 exor bNegativeReveal) & not(bSkip4) then
							put px4, py4, 3000 * bOutPoint
						endif
					endif
				endif

				fill		  round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL])
				bLocalFill	= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_ORIENTATION])
				penFillFg	= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_PEN])
				penFillBg	= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_BACK_PEN])

				if WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN] > EPS then
					pen WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN]
					line_type WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE]
					line_property LINE_PROPERTY_INNER
					bDrawContour = 1

					penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN])
					lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE])
				else
					bDrawContour = 0
				endif
				bFitToSkinFill = 0
				bDrawWallBlock = 1
				bClosureContour	= 0

				if bShowSkin then
					gosub 200	! Draw wallblock with contour
				else
					if nsp >= 9 then
						fill 0
						wallhole2 nsp/3 + 1, 2, 0, -1,
							0, 0, 0,
							0,-WOD,900,
							get(nsp)
					else
						for ii=1 to nsp
							n = get(1)
						next ii
					endif
				endif

				penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_END_FACE_PEN])
				lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_END_LINE_TYPE])
				lineProperty= LINE_PROPERTY_INNER

				if penIdx > 0 then
!!!					pen				penIdx
!!!					line_type		lineTypeIdx
!!!					line_property	lineProperty

!!!					wallline2 px1,py1, px2,py2
					bpx = px1
					bpy = py1
					epx = px2
					epy = py2
					penIdx	= bShowSkin * penIdx

					if bShowSkin then
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, not(bHaveShownSkinBefore))
						gosub 4920	! Put line section into Cavity Closure lines array
					else
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
						gosub 4910	! Put line section into wallhole lines array
					endif
				endif

				if (wallIsLeft exor bNegativeReveal exor reorder) then
					penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
					lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])
				else
					penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN])
					lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE])
				endif
				lineProperty	= LINE_PROPERTY_INNER

				if penIdx > 0 then
!!!					pen				penIdx
!!!					line_type		lineTypeIdx
!!!					line_property	lineProperty

					if bNegativeReveal then
!!!						wallline2 px1,py1, px44,py44
						bpx = px1
						bpy = py1
						epx = px44
						epy = py44
					else
!!!						wallline2 px2,py2, px33,py33
						bpx = px2
						bpy = py2
						epx = px33
						epy = py33
					endif
					penIdx	= bShowSkin * penIdx

					if bShowSkin then
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, not(bHaveShownSkinBefore))
						gosub 4920	! Put line section into Cavity Closure lines array
					else
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
						gosub 4910	! Put line section into wallhole lines array
					endif
				endif
			endif

		else	! if curvedWall then

			if bPullBackPlug then
				x1 = distanceX
				if iRevealType = REVEAL_POSITIVE then x2 = distanceX - revealWidth
				if iRevealType = REVEAL_NEGATIVE then x2 = distanceX - revealWidth
				if iRevealType = REVEAL_SLANTED  then x2 = distanceX - revealWidth

				if y2 > y1 & abs(x1 - x2) > EPS then
					if bShowSkin then
						fill		 WALL_SKINS_PARAMS[idx][SKIN_FILL]
						bLocalFill = round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_ORIENTATION])
						wallblock2 4, 2 + 24 * bLocalFill + 32,
							WALL_SKINS_PARAMS[idx][SKIN_FILL_PEN],
							WALL_SKINS_PARAMS[idx][SKIN_FILL_BACK_PEN],
							0,0,0,
							x1, y1, 0,
							x1, y2, 0,
							x2, y2, 0,
							x2, y1, 0
					else
						fill 0
						wallblock2 4, 2, 0, -1,
							0,0,0,
							x1, y1, 0,
							x1, y2, 0,
							x2, y2, 0,
							x2, y1, 0
					endif
				endif

				penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_END_FACE_PEN])
				lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_END_LINE_TYPE])
				lineProperty= LINE_PROPERTY_INNER

				if penIdx > 0 then
!!!					pen				penIdx
!!!					line_type		lineTypeIdx
!!!					line_property	lineProperty

					if (wallIsLeft exor bNegativeReveal exor reorder) then
!!!						wallline2 x1,y2, x2,y2
						bpx = x1
						bpy = y2
						epx = x2
						epy = y2
					else
!!!						wallline2 x1,y1, x2,y1
						bpx = x1
						bpy = y1
						epx = x2
						epy = y1
					endif
					penIdx	= bShowSkin * penIdx

					if bShowSkin then
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, not(bHaveShownSkinBefore))
						gosub 4920	! Put line section into Cavity Closure lines array
					else
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
						gosub 4910	! Put line section into wallhole lines array
					endif
				endif

				if (wallIsLeft exor bNegativeReveal exor reorder) then
					penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
					lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])
				else
					penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN])
					lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE])
				endif
				lineProperty	= LINE_PROPERTY_INNER

				if penIdx > 0 then
!!!					pen				penIdx
!!!					line_type		lineTypeIdx
!!!					line_property	lineProperty

					if bNegativeReveal then
						if (wallIsLeft exor reorder) then
!!!							wallline2 x1,y1, x1,y2 + skinThickness
							bpx = x1
							bpy = y1
							epx = x1
							epy = y2 + skinThickness
						else
!!!							wallline2 x1,y1 - skinThickness, x1,y2
							bpx = x1
							bpy = y1 - skinThickness
							epx = x1
							epy = y2
						endif
					else
						if (wallIsLeft exor reorder) then
!!!							wallline2 x2,y1 - skinThickness, x2,y2
							bpx = x2
							bpy = y1 - skinThickness
							epx = x2
							epy = y2
						else
!!!							wallline2 x2,y1, x2,y2 + skinThickness
							bpx = x2
							bpy = y1
							epx = x2
							epy = y2 + skinThickness
						endif
					endif
					penIdx	= bShowSkin * penIdx

					if bShowSkin then
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, not(bHaveShownSkinBefore))
						gosub 4920	! Put line section into Cavity Closure lines array
					else
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
						gosub 4910	! Put line section into wallhole lines array
					endif
				endif
			endif

		endif	! if curvedWall then
!!!	endif
return




! ==============================================================================
!		Custom Cavity Closure
! ------------------------------------------------------------------------------
! Input variables:
!	possibleSkinTurnIn:		number of possible plaster skins at the Outside Face
!	possibleSkinTurnOut:	number of possible plaster skins at the Inside Face
!	distanceX:				horizontal distance from the original origo
!	alfaX:					alfa x in case of curved walls (alfaX > 0)
!	alfaJamb:				jamb alfa (alfaJamb > 0)
!	revealWidth:			width of the reveal
!	arrayCustomCC:			custom cavity closure skin data
!	sillPx, sillPy:			sill side wall edge point
!	boardPx, boardPy:		board side wall edge point
!	frameSillX, frameSillY:
!	frameBoardX, frameBoardY:
! ==============================================================================

"CustomCavityClosure":

!###################################
bUseTurnPlaster = 1
!###################################

	if bUseTurnPlaster then
		nSkins = WALL_SKINS_NUMBER - possibleSkinTurnOut - possibleSkinTurnIn
	else
		nSkins = WALL_SKINS_NUMBER
	endif
	if nSkins < 2 then return

	if wallIsLeft exor reorder then
		revealWidthIn	= revealWidthInner
		revealWidthOut	= revealWidth
	else
		revealWidthIn	= revealWidth
		revealWidthOut	= revealWidthInner
	endif

	if bInclinedWall then
		diffWallThk = WALL_THICKNESS - skinCummThkRef[WALL_SKINS_NUMBER]
	else
		diffWallThk = 0
	endif

	revealWidthAct = revealWidthIn
	bTurnSide = 0
	gosub 4001

	revealWidthAct = revealWidthOut
	bTurnSide = 1
	gosub 4001
return


4001:

! Turn Skins - Custom Cavity Closure ===========================================

	turnThk = 0

	signOverhang = not(bTurnSide) - bTurnSide

	if bUseTurnPlaster then
		if bTurnSide then
			startCount	= possibleSkinTurnIn + 1
			endCount	= WALL_SKINS_NUMBER - possibleSkinTurnOut
		else
			startCount	= possibleSkinTurnOut + 1
			endCount	= WALL_SKINS_NUMBER - possibleSkinTurnIn
		endif
	else
		startCount	= 1
		endCount	= WALL_SKINS_NUMBER
	endif

	endCount = min(4, endCount)

	if not(bTurnSide) exor wallIsLeft exor reorder then
		refX = sillPx
		refY = sillPy

		refX2 = sillPx2
		refY2 = sillPy2

		frameX		= frameSillX
		frameY		= frameSillY
		frameXopp	= frameBoardX
		frameYopp	= frameBoardY
	else
		refX = boardPx
		refY = boardPy

		refX2 = boardPx
		refY2 = boardPy

		frameX		= frameBoardX
		frameY		= frameBoardY
		frameXopp	= frameSillX
		frameYopp	= frameSillY
	endif

	if not(not(bTurnSide) exor bFirstSkinAtReveal) & bSlantedInnerSide then
		vectS = -sin(revealAngle) * signWallIsLeft
		vectC =  cos(revealAngle)
		vectT =  tan(revealAngle)

		vectS2 = vectS
		vectC2 = vectC
		vectT2 = vectT
	else
		if curvedWall & not(bParalellInCurvedWalls) then
			alpha = atn(refX / (refY + WOD))
			vectS = sin(alpha) * sideSign * signWallIsLeft
			vectC = cos(alpha)
			vectT = tan(alpha)

			vectS2 = vectS
			vectC2 = vectC
			vectT2 = vectT
		else
			if bSlantedOuterSide then
				vectS = sin(revealSillAngle) * signWallIsLeft
				vectC = cos(revealSillAngle)
				vectT = tan(revealSillAngle)
			else
				vectS = 0
				vectC = 1
				vectT = 0
			endif

			vectS2 = 0
			vectC2 = 1
			vectT2 = 0
		endif
	endif

	jdx = startCount - 1 + (4 * not(bTurnSide))	! First arrayCustomCC index

	if startCount = 1 then
		bShowPrevSkin = 0
	else
		if bTurnSide then
			idx = startCount - 1: gosub 10	! Get proper index
		else
			idx = WALL_SKINS_NUMBER - (startCount - 1) + 1: gosub 10	! Get proper index
		endif
		bShowPrevSkin = not((GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY & WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] < EPS) | \
							(GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) < EPS))
	endif

	for i = startCount to endCount

		if i = WALL_SKINS_NUMBER then
			bShowNextSkin = 0
		else
			if bTurnSide then
				idx = i + 1: gosub 10	! Get proper index
			else
				idx = WALL_SKINS_NUMBER - (i + 1) + 1: gosub 10	! Get proper index
			endif
			bShowNextSkin = not((GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY & WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] < EPS) | \
								(GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) < EPS))
		endif

		jdx = jdx + 1

!###################################
!arrayCustomCC[jdx][CUSTOMCC_OVERHANG] = 0.05 * i !!!*  (i <> startCount + 1)
!arrayCustomCC[jdx][CUSTOMCC_BITFIELD] = 1 + 2 + 4 + 8 !!!- (i = startCount + 1)	! A masodik reteget nem forgatom
!arrayCustomCC[jdx][CUSTOMCC_THICKNESS] = 0.02 * i
!###################################

		iBitfield = round_int(arrayCustomCC[jdx][CUSTOMCC_BITFIELD])
		bTurnSkin				= bittest(iBitfield, 0)
		bCustomThickness		= bittest(iBitfield, 1)
		bTurnedHatchOriantation	= bittest(iBitfield, 2)
		bSeparatingLine			= bittest(iBitfield, 3)

		bFirst	= (i = 1)
		bLast	= (i = endCount)

! Skin Geometry Calculations ===================================================

		if bTurnSkin then
			if bTurnSide then
				idx = i: gosub 10	! Get proper index
			else
				idx = WALL_SKINS_NUMBER - i + 1: gosub 10	! Get proper index
			endif

			skinThk = WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
			if bCustomThickness then
				skinTurnThk = arrayCustomCC[jdx][CUSTOMCC_THICKNESS]
			else
				skinTurnThk = skinThk
			endif
			if skinTurnThk < EPS then bTurnSkin = 0

			if reorder then
				cummThk = skinCummThkRef[idx + 1]
			else
				if idx > 1 then
					cummThk = skinCummThkRef[idx - 1]
				else
					cummThk = 0
				endif
			endif

			if bInclinedWall then
				if reorder then
					if idx > 1 then
						cummThkInc = skinCummThkOpp[idx - 1]
					else
						cummThkInc = 0
					endif
				else
					cummThkInc = skinCummThkOpp[idx + 1]
				endif
			endif

			bSkipThisSkin		= 0

			! Turned skin consist of a slanted and a perpendicular part (REVEAL_DOUBLE_SPLAYED or REVEAL_OUTSIDE_SPLAYED)
			bDoubleSplayedSkin	= (bSlantedOuterSide & (not(bTurnSide) exor bFirstSkinAtReveal))

! Curved Wall ==================================================================

			frameOffset = (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) * gs_mountingFrame * gs_mountingFrame_depth

			lengthSkinTurnOvhg	= arrayCustomCC[jdx][CUSTOMCC_OVERHANG]
			if wallIsLeft exor reorder then
				lengthSkinTurnToFrame	= WIDO_SILL + not(bTurnSide) * WIDO_FRAME_THICKNESS
				lengthSkinTurnIn		= lengthSkinTurnToFrame - signOverhang * lengthSkinTurnOvhg
			else
				lengthSkinTurnToFrame	= WALL_THICKNESS - WIDO_SILL - bTurnSide * WIDO_FRAME_THICKNESS
				lengthSkinTurnIn		= lengthSkinTurnToFrame - signOverhang * lengthSkinTurnOvhg
			endif

			if not(bTurnSide) exor bFirstSkinAtReveal then
				if wallIsLeft exor reorder then
					lengthSkinTurnToFrame = lengthSkinTurnToFrame - frameOffset
					lengthSkinTurnIn = lengthSkinTurnIn - frameOffset
				else
					lengthSkinTurnToFrame = lengthSkinTurnToFrame + frameOffset
					lengthSkinTurnIn = lengthSkinTurnIn + frameOffset
				endif
			endif

			bSplittedSkin = 0

			if curvedWall then

! p1 point ---------------------------------------------------------------------

				xo = 0
				yo = -WOD
				if bFirstSkinAtReveal then
					ro = radSill  - cummThk * signReorder - skinThk * not(bTurnSide) * signReorder
				else
					ro = radBoard - cummThk * signReorder - skinThk * not(bTurnSide) * signReorder
				endif

				if bFirstSkinAtReveal then
					x2 = -refX * sideSign - (turnThk + skinTurnThk) * vectC
					y2 =  refY			  - (turnThk + skinTurnThk) * vectS * signReorder
				else
					x2 = -refX * sideSign - (turnThk + skinTurnThk) * vectC
					y2 =  refY			  + (turnThk + skinTurnThk) * vectS * signReorder
				endif
				x1 = x2 + vectS
				y1 = y2 - vectC * signWallIsLeft

!line2 x1,y1, x2,y2
!circle2 xo,yo, ro
				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px1 = cx
				py1 = cy
!circle2 px1,py1, 0.01

! p11 point --------------------------------------------------------------------

				xo = 0
				yo = -WOD
				if bFirstSkinAtReveal then
					ro = radSill  - (cummThk + skinThk * bTurnSide) * signReorder
				else
					ro = radBoard - (cummThk + skinThk * bTurnSide) * signReorder
				endif

				if bFirstSkinAtReveal then
					x2 = -refX * sideSign - (turnThk + skinTurnThk) * vectC
					y2 =  refY			  - (turnThk + skinTurnThk) * vectS * signReorder
				else
					x2 = -refX * sideSign - (turnThk + skinTurnThk) * vectC
					y2 =  refY			  + (turnThk + skinTurnThk) * vectS * signReorder
				endif
				x1 = x2 + vectS
				y1 = y2 - vectC * signWallIsLeft

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px11 = cx
				py11 = cy
!circle2 px11,py11, 0.01

				! Select a better point if (px1,py1) zero
				if abs(px1) < EPS & abs(py1) < EPS then
					px1 = px11
					py1 = py11
				endif

! p2 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x12 = -refX2 * sideSign - (turnThk + skinTurnThk) * vectC2
					y12 =  refY2			- (turnThk + skinTurnThk) * vectS2 * signReorder
				else
					x12 = -refX2 * sideSign - (turnThk + skinTurnThk) * vectC2
					y12 =  refY2			+ (turnThk + skinTurnThk) * vectS2 * signReorder
				endif
				x11 = x12 + vectS2
				y11 = y12 - vectC2 * signWallIsLeft

				x21 = 0
				y21 = -not(bFirstSkinAtReveal) * WIDO_FRAME_THICKNESS - lengthSkinTurnOvhg * signReorder
				if bFirstSkinAtReveal exor bTurnSide then
					y21 = -WIDO_FRAME_THICKNESS + lengthSkinTurnOvhg
				else
					y21 = -lengthSkinTurnOvhg + frameOffset
				endif
				x22 = 1
				y22 = y21

!line2 x11,y11, x12,y12
!line2 x21,y21, x22,y22

				gosub 100	! Line - Line intersection

				px2 = cx
				py2 = cy
!pen i
!circle2 px2,py2, 0.005

! A befordulas melysege kisebb, mint a befordulo reteg teteje
if bFirstSkinAtReveal exor bTurnSide then
	if py11 > py2 then
		bSkipThisSkin = 1
	endif
else
	if py11 < py2 then
		bSkipThisSkin = 1
	endif
endif

				if px2 > -frameX * sideSign then
					newPy2 = -not(wallIsLeft exor reorder exor not(bTurnSide)) * WIDO_FRAME_THICKNESS
					px2 = px2 - (newPy2 - py2) * vectT * sideSign
					py2 = newPy2
					bPy2AtFrame = 1
				else
					bPy2AtFrame = 0
				endif
!circle2 px2,py2, 0.01
!circle2 -frameX * sideSign,py2, 0.02
!line2 -frameX * sideSign,py2, -frameX * sideSign + 0.1,py2

! p4 point ---------------------------------------------------------------------

				xo = 0
				yo = -WOD
				if bFirstSkinAtReveal then
					ro = radSill  - cummThk * signReorder - skinThk * not(bTurnSide) * signReorder
				else
					ro = radBoard - cummThk * signReorder - skinThk * not(bTurnSide) * signReorder
				endif

				if bFirstSkinAtReveal then
					x2 = -refX * sideSign - (turnThk) * vectC
					y2 =  refY			  - (turnThk) * vectS * signReorder
				else
					x2 = -refX * sideSign - (turnThk) * vectC
					y2 =  refY			  + (turnThk) * vectS * signReorder
				endif
				x1 = x2 + vectS
				y1 = y2 - vectC * signWallIsLeft

!line2 x1,y1, x2,y2
!circle2 xo,yo, ro
				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px4 = cx
				py4 = cy

! p3 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x12 = -refX2 * sideSign - (turnThk) * vectC2
					y12 =  refY2			  - (turnThk) * vectS2 * signReorder
				else
					x12 = -refX2 * sideSign - (turnThk) * vectC2
					y12 =  refY2			  + (turnThk) * vectS2 * signReorder
				endif
				x11 = x12 + vectS2
				y11 = y12 - vectC2 * signWallIsLeft

				x21 = 0
				if bFirstSkinAtReveal exor bTurnSide then
					y21 = -WIDO_FRAME_THICKNESS + lengthSkinTurnOvhg
				else
					y21 = -lengthSkinTurnOvhg + frameOffset
				endif
				x22 = 1
				y22 = y21

!pen i
!line2 x11,y11, x12,y12
!line2 x21,y21, x22,y22
				gosub 100	! Line - Line intersection

				px3 = cx
				py3 = cy
!circle2 px3,py3, 0.01
!circle2 -bx * sideSign,py3, 0.02

				if px3 > -frameX * sideSign then
					newPy3 = -not(wallIsLeft exor reorder exor not(bTurnSide)) * WIDO_FRAME_THICKNESS
					px3 = px3 - (newPy3 - py3) * vectT2 * sideSign
					py3 = newPy3
					bPy3AtFrame = 1
				else
					bPy3AtFrame = 0
				endif
!circle2 px3,py3, 0.01

! p22, p33 points --------------------------------------------------------------

				if not(bSkipThisSkin) & bPy2AtFrame <> bPy3AtFrame then
					bSplittedSkin = 1

					x11 = -frameX * sideSign
					y11 = -frameY
					x12 = -frameXopp * sideSign
					y12 = -frameYopp

					gosub 100	! Line - Line intersection

					px22 = cx
					py22 = cy
!pen 20
!circle2 x11,y11,0.008
!circle2 px22,py22,0.008

					px33 = -frameX * sideSign
					py33 = py3
				endif


				if not(bSkipThisSkin) & bDoubleSplayedSkin then

! p44  point -------------------------------------------------------------------

					if bFirstSkinAtReveal then
						x12 = -refX * sideSign - turnThk * vectC
						y12 =  refY			   - turnThk * vectS * signReorder
					else
						x12 = -refX * sideSign - turnThk * vectC
						y12 =  refY			   + turnThk * vectS * signReorder
					endif
					x11 = x12 + vectS
					y11 = y12 - vectC * signWallIsLeft

					if bFirstSkinAtReveal then
						x22 = -refX2 * sideSign - turnThk * vectC2
						y22 =  refY2			- turnThk * vectS2 * signReorder
					else
						x22 = -refX2 * sideSign - turnThk * vectC2
						y22 =  refY2			+ turnThk * vectS2 * signReorder
					endif
					x21 = x22 + vectS2
					y21 = y22 - vectC2 * signWallIsLeft

					gosub 100	! Line - Line intersection
					px44 = cx
					py44 = cy

! Special case check -----------------------------------------------------------

					if py44 > py4 then
						if bFirstSkinAtReveal then
							x2 = -refX2 * sideSign - turnThk * vectC2
							y2 =  refY2			   - turnThk * vectS2 * signReorder
						else
							x2 = -refX2 * sideSign - turnThk * vectC2
							y2 =  refY2			   + turnThk * vectS2 * signReorder
						endif
						x1 = x2 + vectS2
						y1 = y2 - vectC2 * signWallIsLeft

						xo = 0
						yo = -WOD
						if bFirstSkinAtReveal then
							ro = radSill  - cummThk * signReorder - skinThk * not(bTurnSide) * signReorder
						else
							ro = radBoard - cummThk * signReorder - skinThk * not(bTurnSide) * signReorder
						endif

						gosub 101	! Circle - Line intersection
						gosub 102	! Select good intersection point
						px4 = cx
						py4 = cy

						px44 = cx
						py44 = cy
					endif

! p55  point -------------------------------------------------------------------

					if bFirstSkinAtReveal then
						x12 = -refX * sideSign - (turnThk + skinTurnThk) * vectC
						y12 =  refY			   - (turnThk + skinTurnThk) * vectS * signReorder
					else
						x12 = -refX * sideSign - (turnThk + skinTurnThk) * vectC
						y12 =  refY			   + (turnThk + skinTurnThk) * vectS * signReorder
					endif
					x11 = x12 + vectS
					y11 = y12 - vectC * signWallIsLeft

					if bFirstSkinAtReveal then
						x22 = -refX2 * sideSign - (turnThk + skinTurnThk) * vectC2
						y22 =  refY2			- (turnThk + skinTurnThk) * vectS2 * signReorder
					else
						x22 = -refX2 * sideSign - (turnThk + skinTurnThk) * vectC2
						y22 =  refY2			+ (turnThk + skinTurnThk) * vectS2 * signReorder
					endif
					x21 = x22 + vectS2
					y21 = y22 - vectC2 * signWallIsLeft

					gosub 100	! Line - Line intersection
					px55 = cx
					py55 = cy

! Special case check -----------------------------------------------------------

					if py55 > py11 then
						if bFirstSkinAtReveal then
							x2 = -refX2 * sideSign - (turnThk + skinTurnThk) * vectC2
							y2 =  refY2			   - (turnThk + skinTurnThk) * vectS2 * signReorder
						else
							x2 = -refX2 * sideSign - (turnThk + skinTurnThk) * vectC2
							y2 =  refY2			   + (turnThk + skinTurnThk) * vectS2 * signReorder
						endif
						x1 = x2 + vectS2
						y1 = y2 - vectC2 * signWallIsLeft

						xo = 0
						yo = -WOD
						if bFirstSkinAtReveal then
							ro = radSill  - (cummThk + skinThk * bTurnSide) * signReorder
						else
							ro = radBoard - (cummThk + skinThk * bTurnSide) * signReorder
						endif

						gosub 101	! Circle - Line intersection
						gosub 102	! Select good intersection point
						px11 = cx
						py11 = cy

						px55 = cx
						py55 = cy
					endif

					if py55 < py2 then
						if bFirstSkinAtReveal then
							x12 = -refX * sideSign - (turnThk + skinTurnThk) * vectC
							y12 =  refY			   - (turnThk + skinTurnThk) * vectS * signReorder
						else
							x12 = -refX * sideSign - (turnThk + skinTurnThk) * vectC
							y12 =  refY			   + (turnThk + skinTurnThk) * vectS * signReorder
						endif
						x11 = x12 + vectS
						y11 = y12 - vectC * signWallIsLeft

						x21 = 0
						y21 = -not(bFirstSkinAtReveal) * WIDO_FRAME_THICKNESS - lengthSkinTurnOvhg * signReorder
						if bFirstSkinAtReveal exor bTurnSide then
							y21 = -WIDO_FRAME_THICKNESS + lengthSkinTurnOvhg
						else
							y21 = -lengthSkinTurnOvhg + frameOffset
						endif
						x22 = 1
						y22 = y21

						gosub 100	! Line - Line intersection

						px2 = cx
						py2 = cy

						px55 = cx
						py55 = cy
					endif

				endif

			else

! Straight Wall, Trapezoid Wall ================================================

				if bInclinedWall then
					if reorder then
						bSlantedSkin	 = (trapezoidCoreSkinIdx >= idx)
						bSlantedSkinNext = (trapezoidCoreSkinIdx >  idx)
					else
						bSlantedSkin	 = (trapezoidCoreSkinIdx <= idx)
						bSlantedSkinNext = (trapezoidCoreSkinIdx <  idx)
					endif
				else
					bSlantedSkin = 0
				endif

! p1 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x12 = refX * sideSign + (turnThk + skinTurnThk) * vectC
					y12 = (refY - offsetY) * signWallIsLeft * signReorder + (turnThk + skinTurnThk) * vectS * signWallIsLeft
				else
					x12 = refX * sideSign + (turnThk + skinTurnThk) * vectC
					y12 = (refY - offsetY) * signWallIsLeft * signReorder	- (turnThk + skinTurnThk) * vectS * signWallIsLeft
				endif
				x11 = x12 + vectS * signWallIsLeft
				y11 = y12 - vectC * signWallIsLeft * signReorder

				x21 = 0
				x22 = 1
				if bSlantedSkin then
					! Splanted skin eseten a slanted oldal felol szamoljuk a retegeket
					y21  = skinCummThkRef[WALL_SKINS_NUMBER] + diffWallThk - cummThkInc / incH
					y22 = y21 + incHor * iInclDir * sideSign
				else
					if bTurnSide then
						y21 = cummThk
					else
						y21 = cummThk + skinThk
					endif
					y22 = y21
				endif

				gosub 100	! Line - Line intersection
				px1 = cx
				py1 = cy

! Special case check -----------------------------------------------------------

				if px1 < distanceX & ((py1 < lengthSkinTurnToFrame + EPS) exor bTurnSide) then
					bInvalidRasterSection = 1
				else
					bInvalidRasterSection = 0
				endif

! p11 point --------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x12 = refX * sideSign + (turnThk + skinTurnThk) * vectC
					y12 = (refY - offsetY) * signWallIsLeft * signReorder + (turnThk + skinTurnThk) * vectS * signWallIsLeft
				else
					x12 = refX * sideSign + (turnThk + skinTurnThk) * vectC
					y12 = (refY - offsetY) * signWallIsLeft * signReorder	- (turnThk + skinTurnThk) * vectS * signWallIsLeft
				endif
				x11 = x12 + vectS * signWallIsLeft
				y11 = y12 - vectC * signWallIsLeft * signReorder

				x21 = 0
				x22 = 1
				if bSlantedSkinNext then
					! Splanted skin eseten a slanted oldal felol szamoljuk a retegeket
					y21  = skinCummThkRef[WALL_SKINS_NUMBER] + diffWallThk - (cummThkInc + skinThk) / incH
					y22 = y21 + incHor * iInclDir * sideSign
				else
					if bTurnSide then
						y21 = cummThk + skinThk
					else
						y21 = cummThk
					endif
					y22 = y21
				endif

				gosub 100	! Line - Line intersection
				px11 = cx
				py11 = cy

! Special case check -----------------------------------------------------------

				! A befordulas melysege kisebb, mint a befordulo reteg teteje
				if bTurnSide then
					bSkipThisSkin = (lengthSkinTurnIn < py1 + EPS)
				else
					bSkipThisSkin = (lengthSkinTurnIn > py1 - EPS)
				endif

! p2 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x12 = refX2 * sideSign + (turnThk + skinTurnThk) * vectC2
					y12 = (refY2 - offsetY) * signWallIsLeft * signReorder + (turnThk + skinTurnThk) * vectS2 * signWallIsLeft
				else
					x12 = refX2 * sideSign + (turnThk + skinTurnThk) * vectC2
					y12 = (refY2 - offsetY) * signWallIsLeft * signReorder	- (turnThk + skinTurnThk) * vectS2 * signWallIsLeft
				endif
				x11 = x12 + vectS2 * signWallIsLeft
				y11 = y12 - vectC2 * signWallIsLeft * signReorder

				x21 = 0
				x22 = 1
				if revealWidthAct > turnThk + skinTurnThk - EPS then
					y21 = lengthSkinTurnToFrame
					bPy2AtFrame = 1
				else
					y21 = lengthSkinTurnIn
					bPy2AtFrame = 0
				endif
				y22 = y21

				gosub 100	! Line - Line intersection
				px2 = cx
				py2 = cy

! Special case check -----------------------------------------------------------

!!!if py2 > cummThk + bTurnSide * skinThk - EPS exor bTurnSide then
!if i=startCount  then
!	line2	0,		cummThk + bTurnSide * skinThk,
!			0.40,	cummThk + bTurnSide * skinThk
!	line2	0,		py2,
!			0.35,	py2
!endif
!if bTurnSide then circle2 0,0, 0.1

if (py2 > cummThk + bTurnSide * skinThk - EPS) exor bTurnSide then
	! Befordul, de a beforulas melysege kisebb, mint maga az eredeti reteg vastagsaga
	bSkipThisSkin = 1
endif

! p3 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x12 = refX2 * sideSign + turnThk * vectC2
					y12 = (refY2 - offsetY) * signWallIsLeft * signReorder + turnThk * vectS2 * signWallIsLeft
				else
					x12 = refX2 * sideSign + turnThk * vectC2
					y12 = (refY2 - offsetY) * signWallIsLeft * signReorder - turnThk * vectS2 * signWallIsLeft
				endif
				x11 = x12 + vectS2 * signWallIsLeft
				y11 = y12 - vectC2 * signWallIsLeft * signReorder

				x21 = 0
				x22 = 1
				if revealWidthAct > turnThk + EPS then
					y21 = lengthSkinTurnToFrame
					bPy3AtFrame = 1
				else
					y21 = lengthSkinTurnIn
					bPy3AtFrame = 0
				endif
				y22 = y21

				gosub 100	! Line - Line intersection
				px3 = cx
				py3 = cy

! Special case check -----------------------------------------------------------

				if py1 < py2 exor bTurnSide then
					bSkipThisSkin = 1
				endif

! p22, p33 points --------------------------------------------------------------

				if not(bSkipThisSkin) & bPy2AtFrame <> bPy3AtFrame then
					bSplittedSkin = 1

					px22 = distanceX
					py22 = py2

					px33 = distanceX
					py33 = py3
				endif

! p4 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x12 = refX * sideSign + turnThk * vectC
					y12 = (refY - offsetY) * signWallIsLeft * signReorder + turnThk * vectS * signWallIsLeft
				else
					x12 = refX * sideSign + turnThk * vectC
					y12 = (refY - offsetY) * signWallIsLeft * signReorder - turnThk * vectS * signWallIsLeft
				endif
				x11 = x12 + vectS * signWallIsLeft
				y11 = y12 - vectC * signWallIsLeft * signReorder

				x21 = 0
				x22 = 1
				if bSlantedSkin then
					! Splanted skin eseten a slanted oldal felol szamoljuk a retegeket
					y21 = skinCummThkRef[WALL_SKINS_NUMBER] + diffWallThk - cummThkInc / incH
					y22 = y21 + incHor * iInclDir * sideSign
				else
					if bTurnSide then
						y21 = cummThk
					else
						y21 = cummThk + skinThk
					endif
					y22 = y21
				endif

				gosub 100	! Line - Line intersection
				px4 = cx
				py4 = cy

! Special case check -----------------------------------------------------------

if bSplittedSkin & ((py4 < py3 + EPS) exor bTurnSide) then
	bSplittedSkin = 0
	px4 = distanceX
	px3 = distanceX
	py3 = lengthSkinTurnIn
	bPy3AtFrame = 0
endif

!!!				if bSplittedSkin & (py4 > py3 & py3 > py1) then
!!!					px3 = px22
!!!					py3 = py22
!!!
!!!					px4 = px22
!!!					bSplittedSkin = 0
!!!				endif


				if not(bSkipThisSkin) & bDoubleSplayedSkin then

! p44  point -------------------------------------------------------------------

					if bFirstSkinAtReveal then
						x12 = refX * sideSign + turnThk * vectC
						y12 = (refY - offsetY) * signWallIsLeft * signReorder + turnThk * vectS * signWallIsLeft
					else
						x12 = refX * sideSign + turnThk * vectC
						y12 = (refY - offsetY) * signWallIsLeft * signReorder - turnThk * vectS * signWallIsLeft
					endif
					x11 = x12 + vectS * signWallIsLeft
					y11 = y12 - vectC * signWallIsLeft * signReorder

					if bFirstSkinAtReveal then
						x22 = refX2 * sideSign + turnThk * vectC2
						y22 = (refY2 - offsetY) * signWallIsLeft * signReorder + turnThk * vectS2 * signWallIsLeft
					else
						x22 = refX2 * sideSign + turnThk * vectC2
						y22 = (refY2 - offsetY) * signWallIsLeft * signReorder - turnThk * vectS2 * signWallIsLeft
					endif
					x21 = x22 + vectS2 * signWallIsLeft
					y21 = y22 - vectC2 * signWallIsLeft * signReorder

					gosub 100	! Line - Line intersection
					px44 = cx
					py44 = cy

! Special case check -----------------------------------------------------------

					if py44 > py4 exor bTurnSide then
						if bFirstSkinAtReveal then
							x12 = refX2 * sideSign + turnThk * vectC2
							y12 = (refY2 - offsetY) * signWallIsLeft * signReorder + turnThk * vectS2 * signWallIsLeft
						else
							x12 = refX2 * sideSign + turnThk * vectC2
							y12 = (refY2 - offsetY) * signWallIsLeft * signReorder - turnThk * vectS2 * signWallIsLeft
						endif
						x11 = x12 + vectS2 * signWallIsLeft
						y11 = y12 - vectC2 * signWallIsLeft * signReorder

						x21 = 0
						x22 = 1
						if bSlantedSkin then
							! Splanted skin eseten a slanted oldal felol szamoljuk a retegeket
							y21 = skinCummThkRef[WALL_SKINS_NUMBER] + diffWallThk - cummThkInc / incH
							y22 = y21 + incHor * iInclDir * sideSign
						else
							if bTurnSide then
								y21 = cummThk
							else
								y21 = cummThk + skinThk
							endif
							y22 = y21
						endif

						gosub 100	! Line - Line intersection
						px4 = cx
						py4 = cy

						px44 = cx
						py44 = cy
					endif

! p55  point -------------------------------------------------------------------

					if bFirstSkinAtReveal then
						x12 = refX * sideSign + (turnThk + skinTurnThk) * vectC
						y12 = (refY - offsetY) * signWallIsLeft * signReorder + (turnThk + skinTurnThk) * vectS * signWallIsLeft
					else
						x12 = refX * sideSign + (turnThk + skinTurnThk) * vectC
						y12 = (refY - offsetY) * signWallIsLeft * signReorder	- (turnThk + skinTurnThk) * vectS * signWallIsLeft
					endif
					x11 = x12 + vectS * signWallIsLeft
					y11 = y12 - vectC * signWallIsLeft * signReorder

					if bFirstSkinAtReveal then
						x22 = refX2 * sideSign + (turnThk + skinTurnThk) * vectC2
						y22 = (refY2 - offsetY) * signWallIsLeft * signReorder + (turnThk + skinTurnThk) * vectS2 * signWallIsLeft
					else
						x22 = refX2 * sideSign + (turnThk + skinTurnThk) * vectC2
						y22 = (refY2 - offsetY) * signWallIsLeft * signReorder	- (turnThk + skinTurnThk) * vectS2 * signWallIsLeft
					endif
					x21 = x22 + vectS2 * signWallIsLeft
					y21 = y22 - vectC2 * signWallIsLeft * signReorder

					gosub 100	! Line - Line intersection
					px55 = cx
					py55 = cy

! Special case check -----------------------------------------------------------

					if py55 > py11 exor bTurnSide then
						if bFirstSkinAtReveal then
							x12 = refX2 * sideSign + (turnThk + skinTurnThk) * vectC2
							y12 = (refY2 - offsetY) * signWallIsLeft * signReorder + (turnThk + skinTurnThk) * vectS2 * signWallIsLeft
						else
							x12 = refX2 * sideSign + (turnThk + skinTurnThk) * vectC2
							y12 = (refY2 - offsetY) * signWallIsLeft * signReorder	- (turnThk + skinTurnThk) * vectS2 * signWallIsLeft
						endif
						x11 = x12 + vectS2 * signWallIsLeft
						y11 = y12 - vectC2 * signWallIsLeft * signReorder

						x21 = 0
						x22 = 1
						if bSlantedSkinNext then
							! Splanted skin eseten a slanted oldal felol szamoljuk a retegeket
							y21  = skinCummThkRef[WALL_SKINS_NUMBER] + diffWallThk - (cummThkInc + skinThk) / incH
							y22 = y21 + incHor * iInclDir * sideSign
						else
							if bTurnSide then
								y21 = cummThk + skinThk
							else
								y21 = cummThk
							endif
							y22 = y21
						endif

						gosub 100	! Line - Line intersection
						px11 = cx
						py11 = cy

						px55 = cx
						py55 = cy
					endif

					if py55 < py2 exor bTurnSide then
						if bFirstSkinAtReveal then
							x12 = refX * sideSign + (turnThk + skinTurnThk) * vectC
							y12 = (refY - offsetY) * signWallIsLeft * signReorder + (turnThk + skinTurnThk) * vectS * signWallIsLeft
						else
							x12 = refX * sideSign + (turnThk + skinTurnThk) * vectC
							y12 = (refY - offsetY) * signWallIsLeft * signReorder	- (turnThk + skinTurnThk) * vectS * signWallIsLeft
						endif
						x11 = x12 + vectS * signWallIsLeft
						y11 = y12 - vectC * signWallIsLeft * signReorder

						x21 = 0
						x22 = 1
						if revealWidthAct > turnThk + skinTurnThk - EPS then
							y21 = lengthSkinTurnToFrame
							bPy2AtFrame = 1
						else
							y21 = lengthSkinTurnIn
							bPy2AtFrame = 0
						endif
						y22 = y21

						gosub 100	! Line - Line intersection
						px2 = cx
						py2 = cy

						px55 = cx
						py55 = cy
					endif

				endif

			endif
		endif	! if bTurnSkin then

! Check turned skin geometry ===================================================

!bSkipThisSkin = (lengthSkinTurnIn > py1 - EPS)

!if jdx=1 then text2 0.2,0, py1

!if bTurnSkin & not(bSkipThisSkin) then
!	if bSlantedOuterSide & (not(bTurnSide) exor bFirstSkinAtReveal) then
!		line_type 1
!		pen i
!		sss = 0.002
!		circle2 px1,py1, sss:	sss=sss+0.002
!		circle2 px11,py11,sss
!		circle2 px2,py2, sss:	sss=sss+0.002
!		if bSplittedSkin then
!			circle2 px22,py22, sss:	sss=sss+0.002
!			circle2 px33,py33, sss:	sss=sss+0.002
!		endif
!		if bDoubleSplayedSkin then
!			circle2 px44,py44, sss:	sss=sss+0.002
!			circle2 px55,py55, sss:	sss=sss+0.002
!		endif
!		circle2 px3,py3, sss:	sss=sss+0.002
!		circle2 px4,py4, sss:	sss=sss+0.002
!	endif
!endif

! Draw the turned skins ========================================================

		bShowSkin = not( (GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY & WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] < EPS) | \
						 (GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) < EPS) )
!!		bShowSkin = (GLOB_STRUCTURE_DISPLAY = STRUCTURE_ENTIRE_STRUCTURE | (GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) > EPS))

		if bTurnSkin & not(bSkipThisSkin) then

			skinFillType		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL])
			skinFillFgPen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_PEN])
			skinFillBgPen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_BACK_PEN])
			skinFillOrientation	= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_ORIENTATION])
			bFitToSkinFill		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_FIT_TO_SKIN])

			if bSplittedSkin then
				if bDoubleSplayedSkin then
					put	px1,	py1,	0,
						px55,	py55,	0,
						px2,	py2,	0,
						px22,	py22,	0,
						px33,	py33,	0,
						px3,	py3,	0,
						px44,	py44,	0,
						px4,	py4,	0
				else
					put	px1,	py1,	0,
						px2,	py2,	0,
						px22,	py22,	0,
						px33,	py33,	0,
						px3,	py3,	0,
						px4,	py4,	0
				endif
			else
				if bDoubleSplayedSkin then
					put	px1,	py1,	0,
						px55,	py55,	0,
						px2,	py2,	0,
						px3,	py3,	0,
						px44,	py44,	0,
						px4,	py4,	0
				else
					put	px1,	py1,	0,
						px2,	py2,	0,
						px3,	py3,	0,
						px4,	py4,	0
				endif
			endif
			if curvedWall then
				put	px1, py1, 3000
			endif

			if bShowSkin then
				fill skinFillType
				bLocalFill	= skinFillOrientation

				if bTurnedHatchOriantation & not(bFitToSkinFill) then
					if bLocalFill then
						fillAngle = 90
					else
						fillAngle = sideSign * WALL_DIRECTION + 90
					endif

					wallblock2 nsp/3 + 1, 2 + 8 + 32, skinFillFgPen, skinFillBgPen,
						0,0,fillAngle,
						0,-WOD,900,
						get(nsp)
				else
					dirAngle = -signWallIsLeft * atn(vectS / vectC)

					wallblock2{2} nsp/3 + 1, 2, 2,8 * (bLocalFill | bFitToSkinFill) + 32 * bFitToSkinFill + 128 * (bLocalFill & not(bFitToSkinFill)),
						skinFillFgPen, skinFillBgPen,
						use(2),
						-sin(dirAngle),-cos(dirAngle), -skinTurnThk*cos(dirAngle),skinTurnThk*sin(dirAngle),
						0,
						0,-WOD,900,
						get(nsp)
				endif
			else
				fill 0
				wallhole2 nsp/3 + 1, 2, 0,-1,
					0,0,0,
					0,-WOD,900,
					get(nsp)
			endif

!			bDrawContour = 0
!			bDrawWallBlock = 1
!			bClosureContour	= 0
!			gosub 200	! Draw wallblock
		endif

! Draw contour lines -----------------------------------------------------------


!#####################################################################

! Turned skin outer contour line -----------------------------------------------

		if bTurnSkin then
			if bTurnSide then
				penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
				lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])
			else
				penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN])
				lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE])
			endif
			lineProperty = LINE_PROPERTY_INNER + (not(bShowPrevSkin))		! (INNER / CONTOUR)

			if not(bSkipThisSkin) & not(bInvalidRasterSection) then
				if bDoubleSplayedSkin then
					bpx = px3
					bpy = py3
					epx = px44
					epy = py44
					!penIdx		= penIdx
					!lineTypeIdx= lineTypeIdx

					if bShowSkin then
!!!						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, (lineProperty = LINE_PROPERTY_CONTOUR))
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 0)
						gosub 4920	! Put line section into Cavity Closure lines array
					else
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
						gosub 4910	! Put line section into wallhole lines array
					endif

					bpx = px44
					bpy = py44
					epx = px4
					epy = py4
					!penIdx		= penIdx
					!lineTypeIdx= lineTypeIdx

					if bShowSkin then
!!!						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, (lineProperty = LINE_PROPERTY_CONTOUR))
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 0)
						gosub 4920	! Put line section into Cavity Closure lines array
					else
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
						gosub 4910	! Put line section into wallhole lines array
					endif
				else
					bpx = px3
					bpy = py3
					epx = px4
					epy = py4
					!penIdx		= penIdx
					!lineTypeIdx= lineTypeIdx

					if bShowSkin then
!!!						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, (lineProperty = LINE_PROPERTY_CONTOUR))
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 0)
						gosub 4920	! Put line section into Cavity Closure lines array
					else
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
						gosub 4910	! Put line section into wallhole lines array
					endif
				endif

				if curvedWall then
					if bShowSkin then
						R = sqr(px1^2 + (py1 + WOD)^2)

						vx = px1
						vy = -py1 - WOD
						gosub 103	! Direction Angle
						alpha = -angle

						vx = px4
						vy = -py4 - WOD
						gosub 103	! Direction Angle
						beta = -angle

						if abs(alpha - beta) > EPS then
							pen				penIdx
							line_type		lineTypeIdx
							line_property	lineProperty
							wallarc2 0,-WOD, R, min(alpha,beta), max(alpha,beta)
						endif
					endif
				else
					bpx = px1
					bpy = py1
					epx = px4
					epy = py4
					iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, (lineProperty = LINE_PROPERTY_CONTOUR))
					penIdx		= penIdx * bShowSkin
					!lineTypeIdx= lineTypeIdx
					gosub 4920	! Put line section into Cavity Closure lines array
				endif
			endif
			if not(bShowSkin) & bShowPrevSkin then
!				pen			penIdx
!				line_type	lineTypeIdx
!				line_property LINE_PROPERTY_CONTOUR
!
!!				wallline2 px1,py1, px4,py4

				bpx = px1
				bpy = py1
				epx = px4
				epy = py4
				iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)		! LINE_PROPERTY_CONTOUR
				!penIdx		= penIdx
				!lineTypeIdx= lineTypeIdx
				gosub 4920	! Put line section into Cavity Closure lines array
			endif

! Turned skin inner contour line -----------------------------------------------

			if bTurnSide then
				penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN])
				lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE])
			else
				penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
				lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])
			endif
			lineProperty = LINE_PROPERTY_INNER + (not(bShowNextSkin))		! (INNER / CONTOUR)

!!!			if bShowSkin & not(bSkipThisSkin) & not(bInvalidRasterSection) & penIdx > 0 then
			if not(bSkipThisSkin) & not(bInvalidRasterSection) & penIdx > 0 then
!				pen				penIdx
!				line_type		lineTypeIdx
!				line_property	lineProperty

				if bSeparatingLine then
!!					wallline2 px11,py11, px2,py2

					bpx = px11
					bpy = py11
					epx = px2
					epy = py2
					!penIdx		= penIdx
					!lineTypeIdx= lineTypeIdx
!circle2 bpx, bpy, 0.01
!circle2 epx, epy, 0.01
					if bShowSkin then
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, (lineProperty = LINE_PROPERTY_CONTOUR))
						gosub 4920	! Put line section into Cavity Closure lines array
					else
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
						gosub 4910	! Put line section into wallhole lines array
					endif

					if bShowSkin & arrayCustomCC[jdx][CUSTOMCC_PEN] > 0 then
!						pen arrayCustomCC[jdx][CUSTOMCC_PEN]
!						line_property LINE_PROPERTY_INNER
!
!!						wallline2 px1,py1, px11,py11

						bpx = px1
						bpy = py1
						epx = px11
						epy = py11
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 0)		! LINE_PROPERTY_INNER

						savedPenIdx		 = penIdx
						savedLineTypeIdx = lineTypeIdx

						penIdx		= arrayCustomCC[jdx][CUSTOMCC_PEN]
						lineTypeIdx	= 1
						gosub 4920	! Put line section into Cavity Closure lines array

						penIdx		= savedPenIdx
						lineTypeIdx	= savedLineTypeIdx
					endif
				else
					if bDoubleSplayedSkin then
!!						wallline2 px55,py55, px2,py2
!!						wallline2 px11,py11, px55,py55

						bpx = px55
						bpy = py55
						epx = px2
						epy = py2

						if bShowSkin then
							iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, (lineProperty = LINE_PROPERTY_CONTOUR))
							gosub 4920	! Put line section into Cavity Closure lines array
						else
							iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
							gosub 4910	! Put line section into wallhole lines array
						endif

						bpx = px11
						bpy = py11
						epx = px55
						epy = py55

						if bShowSkin then
							iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, (lineProperty = LINE_PROPERTY_CONTOUR))
							gosub 4920	! Put line section into Cavity Closure lines array
						else
							iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
							gosub 4910	! Put line section into wallhole lines array
						endif
					else
!!						wallline2 px11,py11, px2,py2

						bpx = px11
						bpy = py11
						epx = px2
						epy = py2
						!penIdx		= penIdx
						!lineTypeIdx= lineTypeIdx

						if bShowSkin then
							iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, (lineProperty = LINE_PROPERTY_CONTOUR))
							gosub 4920	! Put line section into Cavity Closure lines array
						else
							iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
							gosub 4910	! Put line section into wallhole lines array
						endif
					endif

				endif
			endif

! Turned skin end contoure line(s) ---------------------------------------------

			penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_END_FACE_PEN])
			lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_END_LINE_TYPE])
			lineProperty= LINE_PROPERTY_INNER + ((bPy2AtFrame & bPy3AtFrame) | (GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY))		! (INNER / CONTOUR)

!!!			if bShowSkin & penIdx > 0 then
!			if penIdx > 0 then
			if penIdx > 0 & not(bSkipThisSkin) then
!				pen				penIdx
!				line_type		lineTypeIdx
!				line_property	lineProperty

				if bSplittedSkin then
!!					wallline2 px2, py2,	 px22,py22

					bpx = px2
					bpy = py2
					epx = px22
					epy = py22
					!penIdx		= penIdx
					!lineTypeIdx= lineTypeIdx

					if bShowSkin then
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, (lineProperty = LINE_PROPERTY_CONTOUR))
						gosub 4920	! Put line section into Cavity Closure lines array
					else
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
						gosub 4910	! Put line section into wallhole lines array
					endif

					if bShowSkin then
!						line_property LINE_PROPERTY_CONTOUR
!!						wallline2 px22,py22, px33,py33
!!						wallline2 px33,py33, px3, py3

						bpx = px22
						bpy = py22
						epx = px33
						epy = py33
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)		! LINE_PROPERTY_CONTOUR
						!penIdx		= penIdx
						!lineTypeIdx= lineTypeIdx
						gosub 4920	! Put line section into Cavity Closure lines array

						bpx = px33
						bpy = py33
						epx = px3
						epy = py3
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)		! LINE_PROPERTY_CONTOUR
						!penIdx		= penIdx
						!lineTypeIdx= lineTypeIdx
						gosub 4920	! Put line section into Cavity Closure lines array
					endif
				else
!!					wallline2 px2,py2, px3,py3

					bpx = px2
					bpy = py2
					epx = px3
					epy = py3
					!penIdx		= penIdx
					!lineTypeIdx= lineTypeIdx

					if bShowSkin then
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, (lineProperty = LINE_PROPERTY_CONTOUR))
						gosub 4920	! Put line section into Cavity Closure lines array
					else
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
						gosub 4910	! Put line section into wallhole lines array
					endif
				endif
			endif

		endif

! Skin loop end ----------------------------------------------------------------

		bShowPrevSkin = bShowSkin

		if bTurnSkin then
			turnThk = turnThk + skinTurnThk
		endif
	next i
return


4910:
! ==============================================================================
! Put line section into wallhole lines array.
! Convert point coordinates from Cavity Closure coordinate system
! to Wallhole coordinate system.
! ------------------------------------------------------------------------------
! Input variables:
!	bpx,bpy:		Start point coordinate
!	epx,epy:		End point coordinate
!	iAttributes:	Attribute bitfield
!!	penIdx:			Pen index (ignored)
!!	lineTypeIdx:	Line type index (ignored)
!	sideSign:		The following three variable
!	signY:				from Cavity Closure coordinate system
!	offsetY:			to Wallhole coordinate system.
! ==============================================================================

	! Conversion from Cavity Closure coordinate system to Wallhole coordinate system
	x11 = bpx * signX * sideSign
	y11 = bpy * signY + offsetY
	x12 = epx * signX * sideSign
	y12 = epy * signY + offsetY

	dim addedNewLineSections[][4]	! Array to collect newly created line sections
	idxNewLineSections = 0

4911:	! Recursive entry point
	bNeedToAdd = 1

	numLines = vardim1(lineSections)
	ii = 1

	do
		x21 = lineSections[ii][LINE_BEG_X]
		y21 = lineSections[ii][LINE_BEG_Y]
		x22 = lineSections[ii][LINE_END_X]
		y22 = lineSections[ii][LINE_END_Y]

		gosub 999	! Segment - Segment sections

		if state > 0 then
			if iStartInside = 0 & iEndInside = 0 then
				! Delete line section
				lineSections[ii][LINE_BEG_X] = 0
				lineSections[ii][LINE_BEG_Y] = 0
				lineSections[ii][LINE_END_X] = 0
				lineSections[ii][LINE_END_Y] = 0

				! Store line section to merge this into lineSections[] array at the end of this subroutine
				idxNewLineSections = idxNewLineSections + 1
				addedNewLineSections[idxNewLineSections][LINE_BEG_X] = x11
				addedNewLineSections[idxNewLineSections][LINE_BEG_Y] = y11
				addedNewLineSections[idxNewLineSections][LINE_END_X] = x21
				addedNewLineSections[idxNewLineSections][LINE_END_Y] = y21

				x11 = x22
				y11 = y22
				!x12 = x12
				!y12 = y12
				bNeedToAdd = 1
			endif
			if iStartInside = 0 & iEndInside = 1 then
				lineSections[ii][LINE_BEG_X] = x12
				lineSections[ii][LINE_BEG_Y] = y12
				lineSections[ii][LINE_END_X] = x22
				lineSections[ii][LINE_END_Y] = y22

				!x11 = x11
				!y11 = y11
				x12 = x21
				y12 = y21
				bNeedToAdd = 1
			endif
			if iStartInside = 0 & iEndInside = 2 then
				lineSections[ii][LINE_BEG_X] = 0
				lineSections[ii][LINE_BEG_Y] = 0
				lineSections[ii][LINE_END_X] = 0
				lineSections[ii][LINE_END_Y] = 0

				!x11 = x11
				!y11 = y11
				x12 = x21
				y12 = y21
				bNeedToAdd = 1
			endif
			if iStartInside = 1 & iEndInside = 0 then
				lineSections[ii][LINE_BEG_X] = x21
				lineSections[ii][LINE_BEG_Y] = y21
				lineSections[ii][LINE_END_X] = x11
				lineSections[ii][LINE_END_Y] = y11

				x11 = x22
				y11 = y22
				!x12 = x12
				!y12 = y12
				bNeedToAdd = 1
			endif
			if iStartInside = 1 & iEndInside = 1 then
				lineSections[ii][LINE_BEG_X] = x21
				lineSections[ii][LINE_BEG_Y] = y21
				lineSections[ii][LINE_END_X] = x11
				lineSections[ii][LINE_END_Y] = y11

				x11 = x12
				y11 = y12
				x12 = x22
				y12 = y22
				iAttributes = lineSections[ii][LINE_ATTRIBUTES]
				bNeedToAdd = 1
			endif
			if iStartInside = 1 & iEndInside = 2 then
				lineSections[ii][LINE_BEG_X] = x21
				lineSections[ii][LINE_BEG_Y] = y21
				lineSections[ii][LINE_END_X] = x11
				lineSections[ii][LINE_END_Y] = y11
				bNeedToAdd = 0
			endif
			if iStartInside = 2 & iEndInside = 0 then
				lineSections[ii][LINE_BEG_X] = 0
				lineSections[ii][LINE_BEG_Y] = 0
				lineSections[ii][LINE_END_X] = 0
				lineSections[ii][LINE_END_Y] = 0

				x11 = x22
				y11 = y22
				!x12 = x12
				!y12 = y12
				bNeedToAdd = 1
			endif
			if iStartInside = 2 & iEndInside = 1 then
				lineSections[ii][LINE_BEG_X] = x12
				lineSections[ii][LINE_BEG_Y] = y12
				lineSections[ii][LINE_END_X] = x22
				lineSections[ii][LINE_END_Y] = y22
				bNeedToAdd = 0
			endif
			if iStartInside = 2 & iEndInside = 2 then
				lineSections[ii][LINE_BEG_X] = 0
				lineSections[ii][LINE_BEG_Y] = 0
				lineSections[ii][LINE_END_X] = 0
				lineSections[ii][LINE_END_Y] = 0
				bNeedToAdd = 0
			endif
		endif

		ii = ii + 1
	while (ii <= numLines & bNeedToAdd)

	if bNeedToAdd then
		! This part of the original line section does dot overlaps with any other line sections in the lineSections[] array.
		! We have to add this part to the lineSections[] array.
		tempIdx = vardim1(lineSections) + 1

		lineSections[tempIdx][LINE_BEG_X]		= x11
		lineSections[tempIdx][LINE_BEG_Y]		= y11
		lineSections[tempIdx][LINE_END_X]		= x12
		lineSections[tempIdx][LINE_END_Y]		= y12
		lineSections[tempIdx][LINE_ATTRIBUTES]	= iAttributes + bitset(0, LINE_ATTRIBUTES_WALLLINE, 1) + bitset(0, LINE_ATTRIBUTES_DRAWCC, 1)
!		lineSections[tempIdx][LINE_PEN_IDX]		= penIdx		! Ignored, becouse it will be filled out when the segments splitted by wall skin separator lines
!		lineSections[tempIdx][LINE_LTYPE_IDX]	= lineTypeIdx	! Ignored
	endif

	if idxNewLineSections > 0 then
		x11 = addedNewLineSections[idxNewLineSections][LINE_BEG_X]
		y11 = addedNewLineSections[idxNewLineSections][LINE_BEG_Y]
		x12 = addedNewLineSections[idxNewLineSections][LINE_END_X]
		y12  = addedNewLineSections[idxNewLineSections][LINE_END_Y]
		idxNewLineSections = idxNewLineSections - 1

		gosub 4911	! Recurse into this algorithm
	endif
return


4920:
! ==============================================================================
! Put line section into Cavity Closure lines array.
! Convert point coordinates from Cavity Closure coordinate system
! to Wallhole coordinate system.
! ------------------------------------------------------------------------------
! Input variables:
!	bpx,bpy:		Start point coordinate
!	epx,epy:		End point coordinate
!	iAttributes:	Attribute bitfield
!	penIdx:			Pen index
!	lineTypeIdx:	Line type index
! Used global variables:
!	sideSign:
!	signY:
!	offsetY:
! ==============================================================================

	tempIdx = vardim1(contourLines) + 1

	contourLines[tempIdx][LINE_BEG_X]		= bpx * signX * sideSign
	contourLines[tempIdx][LINE_BEG_Y]		= bpy * signY + offsetY
	contourLines[tempIdx][LINE_END_X]		= epx * signX * sideSign
	contourLines[tempIdx][LINE_END_Y]		= epy * signY + offsetY
	contourLines[tempIdx][LINE_ATTRIBUTES]	= iAttributes
	contourLines[tempIdx][LINE_PEN_IDX]		= penIdx
	contourLines[tempIdx][LINE_LTYPE_IDX]	= lineTypeIdx
return


"DrawWallContourLines":
! ==============================================================================
! Draw wall contour lines
! ------------------------------------------------------------------------------
! Input variables:
!	lineSections:		Wall hole edge contour line segments, coming from the FramingGeometry macro
!	contourLines:		Cavity Closure contour line segments
! ==============================================================================

del top
if WIDO_REVEAL_SIDE then
	add2 0,-WIDO_FRAME_THICKNESS
else
	mul2 1,-1
endif


!! ==============================================================================
!! Visualize lineSections[] line segments
!! for testing purposes only!
!! ==============================================================================
!
!numLines = vardim1(lineSections)
!for i=1 to numLines
!	px1 = lineSections[i][LINE_BEG_X]
!	py1 = lineSections[i][LINE_BEG_Y]
!	px2 = lineSections[i][LINE_END_X]
!	py2 = lineSections[i][LINE_END_Y]
!	lineProperty= LINE_PROPERTY_INNER + bittest(round_int(lineSections[i][LINE_ATTRIBUTES]), LINE_ATTRIBUTES_CONTOUR)	! INNER / CONTOUR
!	penIdx		= lineSections[i][LINE_PEN_IDX]
!	lineTypeIdx	= lineSections[i][LINE_LTYPE_IDX]
!
!	if penIdx < 1 then penIdx = 20
!
!	pen				penIdx
!	line_type		lineTypeIdx
!	line_property	lineProperty
!
!	add2 0.002,0.002
!	wallline2 px1,py1, px2,py2
!next i
!del numLines
!end


! ==============================================================================
! Normalize incoming wallhole line sections
! Merge overlapping wallhole contour lines
! ==============================================================================

dim normalizedLineSections[][7]
normalizedLineSections[1][LINE_BEG_X]		= 0
normalizedLineSections[1][LINE_BEG_Y]		= 0
normalizedLineSections[1][LINE_END_X]		= 0
normalizedLineSections[1][LINE_END_Y]		= 0
normalizedLineSections[1][LINE_ATTRIBUTES]	= 0
normalizedLineSections[1][LINE_PEN_IDX]		= 0
normalizedLineSections[1][LINE_LTYPE_IDX]	= 0

idx = 1

numLines = vardim1(lineSections)
for i=1 to numLines
	x11 = lineSections[i][LINE_BEG_X]
	y11 = lineSections[i][LINE_BEG_Y]
	x12 = lineSections[i][LINE_END_X]
	y12 = lineSections[i][LINE_END_Y]
	iAttributes	= round_int(lineSections[i][LINE_ATTRIBUTES])
	penIdx		= lineSections[i][LINE_PEN_IDX]
	lineTypeIdx	= lineSections[i][LINE_LTYPE_IDX]

	bStore = 0

	! Skip deleted line sections (line section is deleted when both it's points set to (0,0) in the subroutine 4910)
	bDeletedLineSection = (abs(x11) < EPS & abs(y11) < EPS & abs(x12) < EPS & abs(y12) < EPS)

	if bittest(iAttributes, LINE_ATTRIBUTES_DRAWCC) & not(bDeletedLineSection) then
		j = i + 1
		bStandalone = 1

		if j <= numLines then
			do
				iAttributes2 = round_int(lineSections[j][LINE_ATTRIBUTES])
				if bittest(iAttributes2, LINE_ATTRIBUTES_DRAWCC) then
	
					bGDLLine1	= (bittest(iAttributes, LINE_ATTRIBUTES_GDLLINE))
					bWallLine1	= (bittest(iAttributes, LINE_ATTRIBUTES_WALLLINE))
	
					bGDLLine2	= (bittest(iAttributes2, LINE_ATTRIBUTES_GDLLINE))
					bWallLine2	= (bittest(iAttributes2, LINE_ATTRIBUTES_WALLLINE))
	
					bMerge = (bGDLLine1 = bGDLLine2 & bWallLine1 = bWallLine2)
	
					x21 = lineSections[j][LINE_BEG_X]
					y21 = lineSections[j][LINE_BEG_Y]
					x22 = lineSections[j][LINE_END_X]
					y22 = lineSections[j][LINE_END_Y]
	
					gosub 999	! Segment - Segment sections
	
					if state > 0 then
						bStandalone = 0
					endif
					if state = 1 | state = 2 then
						if iStartInside = 2 & iEndInside = 2 then
							if bGDLLine1 | bGDLLine2 then
								iAttributes = bitset(iAttributes, LINE_ATTRIBUTES_GDLLINE, 1)
							endif
							if bWallLine1 | bWallLine2 then
								iAttributes = bitset(iAttributes, LINE_ATTRIBUTES_WALLLINE, 1)
							endif
							lineSections[j][LINE_ATTRIBUTES] = 0
							bStore = 1
						endif
						if iStartInside = 2 & iEndInside = 0 then
							x11 = x22
							y11 = y22
							bStore = 1
						endif
						if iStartInside = 0 & iEndInside = 2 then
							x12 = x21
							y12 = y21
							bStore = 1
						endif
	! INFO: half overlapped lines not handled yet!
					endif
				endif
	
				j = j + 1
			while j <= numLines & not(bStore)
		endif

		if bStandalone then bStore = 1
	endif

	if bStore then
		normalizedLineSections[idx][LINE_BEG_X]	= x11
		normalizedLineSections[idx][LINE_BEG_Y]	= y11
		normalizedLineSections[idx][LINE_END_X]	= x12
		normalizedLineSections[idx][LINE_END_Y]	= y12
		normalizedLineSections[idx][LINE_ATTRIBUTES]	= iAttributes
		normalizedLineSections[idx][LINE_PEN_IDX]		= penIdx
		normalizedLineSections[idx][LINE_LTYPE_IDX]		= lineTypeIdx
		idx = idx + 1
	endif
next i


!! ==============================================================================
!! Visualize wall hole edge contour line segments
!! for testing purposes only!
!! ==============================================================================
!
!numLines = vardim1(normalizedLineSections)
!pen 1
!text2 0,0, numLines
!for i=1 to numLines
!	add2 i*0.001,i*0.001
!
!	px1 = normalizedLineSections[i][LINE_BEG_X]
!	py1 = normalizedLineSections[i][LINE_BEG_Y]
!	px2 = normalizedLineSections[i][LINE_END_X]
!	py2 = normalizedLineSections[i][LINE_END_Y]
!	penIdx		= normalizedLineSections[i][LINE_PEN_IDX]
!	lineTypeIdx	= normalizedLineSections[i][LINE_LTYPE_IDX]
!	lineProperty= LINE_PROPERTY_CONTOUR
!	iBitField	= round_int(normalizedLineSections[i][LINE_ATTRIBUTES])
!
!	if penIdx > 0 then
!		pen				penIdx
!		line_type		lineTypeIdx
!		line_property	lineProperty
!
!		pen 6		! Blue
!		if bittest(iBitField, LINE_ATTRIBUTES_GDLLINE) & bittest(iBitField, LINE_ATTRIBUTES_WALLLINE) then
!			pen 4	! Green
!		else
!			if bittest(iBitField, LINE_ATTRIBUTES_GDLLINE) then pen 1
!			if bittest(iBitField, LINE_ATTRIBUTES_WALLLINE) then pen 20
!		endif
!
!		line2 px1,py1, px2,py2
!	endif
!
!	del 1
!next i
!end


! ==============================================================================
! Split wallhole line sections with wall skin lines
! ==============================================================================

dim tempLineSections[]

call "WallContourDivider" parameters AC_Wall_Direction_Type = AC_Wall_Direction_Type,
	radSill			= radSill,
	radBoard		= radBoard,
	WOD				= WOD,
	offsetSill		= offsetSill,
	offsetBoard		= offsetBoard,
	lineSections	= normalizedLineSections,
returned_parameters tempLineSections

numLineSections = round_int(vardim1(tempLineSections) / 7)
dim normalizedLineSections[][7]
idx = 0
for i=1 to numLineSections
	for j=1 to 7
		normalizedLineSections[i][j] = tempLineSections[idx + j]
	next j
	idx = idx + 7
next i


!! ==============================================================================
!! Visualize Cavity Closure contour line segments
!! ==============================================================================
!
!numContourLines = vardim1(contourLines)
!pen 1
!text2 0,0, numContourLines
!for i=1 to numContourLines
!	add2 i*0.001,i*0.001
!	px1 = contourLines[i][LINE_BEG_X]
!	py1 = contourLines[i][LINE_BEG_Y]
!	px2 = contourLines[i][LINE_END_X]
!	py2 = contourLines[i][LINE_END_Y]
!	lineProperty= LINE_PROPERTY_INNER + bittest(round_int(contourLines[i][LINE_ATTRIBUTES]), LINE_ATTRIBUTES_CONTOUR)	! INNER / CONTOUR
!	penIdx		= contourLines[i][LINE_PEN_IDX]
!	lineTypeIdx	= contourLines[i][LINE_LTYPE_IDX]
!
!	pen				penIdx
!	line_type		lineTypeIdx
!	line_property	lineProperty
!
!	wallline2 px1,py1, px2,py2
!	del 1
!next i
!
!! ==============================================================================
!! Visualize wall hole edge contour line segments
!! ==============================================================================
!
!numLines = vardim1(normalizedLineSections)
!for i=1 to numLines
!	px1 = normalizedLineSections[i][LINE_BEG_X]
!	py1 = normalizedLineSections[i][LINE_BEG_Y]
!	px2 = normalizedLineSections[i][LINE_END_X]
!	py2 = normalizedLineSections[i][LINE_END_Y]
!	penIdx		= normalizedLineSections[i][LINE_PEN_IDX]
!	lineTypeIdx	= normalizedLineSections[i][LINE_LTYPE_IDX]
!	lineProperty= LINE_PROPERTY_CONTOUR
!	iBitField	= round_int(normalizedLineSections[i][LINE_ATTRIBUTES])
!
!	if penIdx > 0 then
!		pen				penIdx
!		line_type		lineTypeIdx
!		line_property	lineProperty
!
!		if bittest(iBitField, LINE_ATTRIBUTES_GDLLINE) then
!			line2 px1,py1, px2,py2
!		endif
!		if bittest(iBitField, LINE_ATTRIBUTES_WALLLINE) then
!			wallline2 px1,py1, px2,py2
!		endif
!	endif
!next i


! ==============================================================================
! Draw wall edge line segments if no any line coming from Cavity Closure
! ==============================================================================

numLines		= vardim1(normalizedLineSections)
numContourLines	= vardim1(contourLines)

if numContourLines = 0 then

	! No any line segment coming from Cavity Closure,
	! so we have to draw the entire wall edge line segment set only.

	for i=1 to numLines
		px1 = normalizedLineSections[i][LINE_BEG_X]
		py1 = normalizedLineSections[i][LINE_BEG_Y]
		px2 = normalizedLineSections[i][LINE_END_X]
		py2 = normalizedLineSections[i][LINE_END_Y]
		penIdx		= normalizedLineSections[i][LINE_PEN_IDX]
		lineTypeIdx	= normalizedLineSections[i][LINE_LTYPE_IDX]
		lineProperty= LINE_PROPERTY_CONTOUR
		iBitField	= round_int(normalizedLineSections[i][LINE_ATTRIBUTES])

		if penIdx > 0 then
			pen				penIdx
			line_type		lineTypeIdx
			line_property	lineProperty

			if bittest(iBitField, LINE_ATTRIBUTES_GDLLINE) then
				line2 px1,py1, px2,py2
			endif
			if bittest(iBitField, LINE_ATTRIBUTES_WALLLINE) then
				wallline2 px1,py1, px2,py2
			endif
		endif
	next i

! ------------------------------------------------------------------------------
	return
! ------------------------------------------------------------------------------
endif


! ==============================================================================
! Set LINE_ATTRIBUTES_GDLLINE attribute bit in every Cavity Closure line segment,
! because the Cavity Closure drawing subroutines does not set this
! But the contourLines contains turned skin contours too.
! These contours get LINE_ATTRIBUTES_WALLLINE attribute bit.
! ==============================================================================

numContourLines	= vardim1(contourLines)
for i=1 to numContourLines
	iBitField = round_int(contourLines[i][LINE_ATTRIBUTES])
	if bittest(iBitField, LINE_ATTRIBUTES_CONTOUR_CLOSURE) then
		iBitField = bitset(iBitField, LINE_ATTRIBUTES_GDLLINE, 1)
	else
		iBitField = bitset(iBitField, LINE_ATTRIBUTES_WALLLINE, 1)
	endif
	contourLines[i][LINE_ATTRIBUTES] = iBitField
next i

!! ==============================================================================
!! Visualize Cavity Closure contour line segments
!! ==============================================================================
!numContourLines = vardim1(contourLines)
!for i=1 to numContourLines
!!	add2 i*0.001,i*0.001
!	px1 = contourLines[i][LINE_BEG_X]
!	py1 = contourLines[i][LINE_BEG_Y]
!	px2 = contourLines[i][LINE_END_X]
!	py2 = contourLines[i][LINE_END_Y]
!	lineProperty= LINE_PROPERTY_INNER + bittest(round_int(contourLines[i][LINE_ATTRIBUTES]), LINE_ATTRIBUTES_CONTOUR)	! INNER / CONTOUR
!	penIdx		= contourLines[i][LINE_PEN_IDX]
!	lineTypeIdx	= contourLines[i][LINE_LTYPE_IDX]
!	pen				penIdx
!
!	line_type		lineTypeIdx
!	line_property	lineProperty
!
!	iBitField = round_int(contourLines[i][LINE_ATTRIBUTES])
!	text2 0, i, iBitField
!
!	if bittest(iBitField, LINE_ATTRIBUTES_CONTOUR_GDLLINE) then
!		line2 px1,py1, px2,py2
!	else
!!		wallline2 px1,py1, px2,py2
!	endif
!!	del 1
!next i
!end

! ==============================================================================
! Split line segments coming from Cavity Closure
! with line segments coming from wallhole edge.
! ==============================================================================

dim overlappingEdgeSegmentIdx[]	! Indexes of overlapping wall edge line segments for each Cavity Closure line segment
dim standaloneEdgeSegments[]	! Bitfield flags of disjunct wall edge line segments

numContourLines	= vardim1(contourLines)
for j = 1 to numContourLines
	overlappingEdgeSegmentIdx[j] = 0	! Initializing the array with zero values
next j

for i=1 to numLines		! wall edge line segments
	x21 = normalizedLineSections[i][LINE_BEG_X]
	y21 = normalizedLineSections[i][LINE_BEG_Y]
	x22 = normalizedLineSections[i][LINE_END_X]
	y22 = normalizedLineSections[i][LINE_END_Y]
	lineTypeIdx2	= normalizedLineSections[i][LINE_LTYPE_IDX]
	penIdx2			= normalizedLineSections[i][LINE_PEN_IDX]
	bContourLine2	= 1
	iBitField		= round_int(normalizedLineSections[i][LINE_ATTRIBUTES])
	bNeedGDLLine2	= (bittest(iBitField, LINE_ATTRIBUTES_GDLLINE))		! Need GDL line too

	bStandalone = 1

	numContourLines	= vardim1(contourLines)
	for j=1 to numContourLines	! Cavity Closure contour lines
		x11 = contourLines[j][LINE_BEG_X]
		y11 = contourLines[j][LINE_BEG_Y]
		x12 = contourLines[j][LINE_END_X]
		y12 = contourLines[j][LINE_END_Y]
		bContourLine1	= (bittest(round_int(contourLines[i][LINE_ATTRIBUTES]), LINE_ATTRIBUTES_CONTOUR))
		penIdx1			= contourLines[j][LINE_PEN_IDX]
		lineTypeIdx1	= contourLines[j][LINE_LTYPE_IDX]
		bNeedGDLLine1	= 0

		gosub 999	! Segment - Segment sections

		if state > 0 then
			bStandalone = 0
			overlappingEdgeSegmentIdx[j] = i	! Index of the wall edge line segment
		endif

		if state = 1 | state = 3 then	! (S1 contains whole S2) or (S1 and S2 has a section)

			iBitField = contourLines[j][LINE_ATTRIBUTES]

			if iStartInside = 0 then

				contourLines[j][LINE_BEG_X]	= x11
				contourLines[j][LINE_BEG_Y]	= y11
				contourLines[j][LINE_END_X]	= x21
				contourLines[j][LINE_END_Y]	= y21
				overlappingEdgeSegmentIdx[j] = 0	! Overhanging line section

				bx = x21
				by = y21
				if iEndInside = 0 then
					ex = x22
					ey = y22
				else
					ex = x12
					ey = y12
				endif

				numContourLines = numContourLines + 1
				contourLines[numContourLines][LINE_BEG_X]		= bx
				contourLines[numContourLines][LINE_BEG_Y]		= by
				contourLines[numContourLines][LINE_END_X]		= ex
				contourLines[numContourLines][LINE_END_Y]		= ey
				contourLines[numContourLines][LINE_ATTRIBUTES]	= bitset(iBitField, LINE_ATTRIBUTES_CONTOUR, bContourLine1)
				contourLines[numContourLines][LINE_PEN_IDX]		= penIdx1
				contourLines[numContourLines][LINE_LTYPE_IDX]	= lineTypeIdx1
				overlappingEdgeSegmentIdx[numContourLines] = i	! Index of the wall edge line segment

				if iEndInside = 0 then
					bx = x22
					by = y22
					ex = x12
					ey = y12

					numContourLines = numContourLines + 1
					contourLines[numContourLines][LINE_BEG_X]		= bx
					contourLines[numContourLines][LINE_BEG_Y]		= by
					contourLines[numContourLines][LINE_END_X]		= ex
					contourLines[numContourLines][LINE_END_Y]		= ey
					contourLines[numContourLines][LINE_ATTRIBUTES]	= bitset(iBitField, LINE_ATTRIBUTES_CONTOUR, bContourLine1)
					contourLines[numContourLines][LINE_PEN_IDX]		= penIdx1
					contourLines[numContourLines][LINE_LTYPE_IDX]	= lineTypeIdx1
					overlappingEdgeSegmentIdx[numContourLines] = 0	! Overhanging line section
				endif
			else
				if iEndInside = 0 then
					contourLines[j][LINE_BEG_X]	= x11
					contourLines[j][LINE_BEG_Y]	= y11
					contourLines[j][LINE_END_X]	= x22
					contourLines[j][LINE_END_Y]	= y22

					bx = x22
					by = y22
					ex = x12
					ey = y12

					numContourLines = numContourLines + 1
					contourLines[numContourLines][LINE_BEG_X]		= bx
					contourLines[numContourLines][LINE_BEG_Y]		= by
					contourLines[numContourLines][LINE_END_X]		= ex
					contourLines[numContourLines][LINE_END_Y]		= ey
					contourLines[numContourLines][LINE_ATTRIBUTES]	= bitset(iBitField, LINE_ATTRIBUTES_CONTOUR, bContourLine1)
					contourLines[numContourLines][LINE_PEN_IDX]		= penIdx1
					contourLines[numContourLines][LINE_LTYPE_IDX]	= lineTypeIdx1
					overlappingEdgeSegmentIdx[numContourLines] = 0	! Overhanging line section
				endif
			endif
		endif
!		if state = 2 then	! S2 contains whole S1
!			! Nothing to do
!		endif
	next j

	standaloneEdgeSegments[i] = bStandalone
next i


! ==============================================================================
! Split line segments coming from Cavity Closure
! with line segments coming from wall perpendicular section in closure farther px.
! ==============================================================================

if (iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) & not(curvedWall) then
	numLines = vardim1(_wallSkinSectionLines)
	numTurnSkinEndingLines = vardim1(_turnSkinEndingLines)
	for i=1 to numLines + numTurnSkinEndingLines		! wall edge line segments
		if i < numLines + 1 then
			x21 = _wallSkinSectionLines[i][LINE_BEG_X]
			y21 = _wallSkinSectionLines[i][LINE_BEG_Y]
			x22 = _wallSkinSectionLines[i][LINE_END_X]
			y22 = _wallSkinSectionLines[i][LINE_END_Y]
			lineTypeIdx2	= _wallSkinSectionLines[i][LINE_LTYPE_IDX]
			penIdx2			= _wallSkinSectionLines[i][LINE_PEN_IDX]
		else
			x21 = _turnSkinEndingLines[i - numLines][LINE_BEG_X]
			y21 = _turnSkinEndingLines[i - numLines][LINE_BEG_Y]
			x22 = _turnSkinEndingLines[i - numLines][LINE_END_X]
			y22 = _turnSkinEndingLines[i - numLines][LINE_END_Y]
			lineTypeIdx2	= _turnSkinEndingLines[i - numLines][LINE_LTYPE_IDX]
			penIdx2			= _turnSkinEndingLines[i - numLines][LINE_PEN_IDX]
		endif
		bStandalone = 1

		j = 1
		numContourLines	= vardim1(contourLines)
		do
			x11 = contourLines[j][LINE_BEG_X]
			y11 = contourLines[j][LINE_BEG_Y]
			x12 = contourLines[j][LINE_END_X]
			y12 = contourLines[j][LINE_END_Y]
			penIdx1			= contourLines[j][LINE_PEN_IDX]
			lineTypeIdx1	= contourLines[j][LINE_LTYPE_IDX]

			gosub 999	! Segment - Segment sections

			if (state = 0) then		! S1 and S2 segments not on the same line

				if (abs(x11 - x12) > EPS) & (abs(y11 - y12) < EPS) then		! if the contourLines is parallel to wall

					! searching for a fitting point of contour line in wall skin section direction
					! direction vector of the skin section
					dVx = 0
					dVy = 1

					! a point of the skin section
					linePx	= x21
					linePy	= y21

					! searching for first point of the contour line
					pointPx = x11
					pointPy	= y11
					gosub "SearchFitPointToLine"

					if bFitPoint then
						fitContourLinePx = x11
						fitContourLinePy = y11
					endif

					if not(bFitPoint) then
						! searching for second point of the contour line
						pointPx = x12
						pointPy	= y12
						gosub "SearchFitPointToLine"

						if bFitPoint then
							fitContourLinePx = x12
							fitContourLinePy = y12
						endif
					endif

					if bFitPoint then
						thickWallSkin		 = sqr((x21 - x22)^2 + (y21 - y22)^2)
						dist_fitP_WallSkinP1 = sqr((fitContourLinePx - x21)^2 + (fitContourLinePy - y21)^2)
						dist_fitP_WallSkinP2 = sqr((fitContourLinePx - x22)^2 + (fitContourLinePy - y22)^2)

						if sgn(fitContourLinePx) = 1 then
							_closureFartherSideFitMPx  = _rightClosureFartherSideMPx
							_closureFartherSideFitMPy  = _rightClosureFartherSideMPy
						else
							_closureFartherSideFitMPx  = _leftClosureFartherSideMPx
							_closureFartherSideFitMPy  = _leftClosureFartherSideMPy
						endif

						! -----------------------------------------------------------------------------------------------------------
						! if the contour lines is in inside of wall skin segment or fitting to one of endpoints of wall skin segment
						! contour line point:	   o		o			      o
						! wall skin segment:	o-----o		o-----o		o-----o
						! -----------------------------------------------------------------------------------------------------------
						if abs(thickWallSkin - dist_fitP_WallSkinP1 - dist_fitP_WallSkinP2) < EPS then

							if (dist_fitP_WallSkinP1 < EPS) | (dist_fitP_WallSkinP2 < EPS) then				! if the contour lines is fitting to one of contour (parallel to wall) of wall skin

								! distance of projecting closure gravity point and middle point of wall skin segment
								dist_closureMiddleP_skinMiddleP = sqr((_closureFartherSideFitMPx - ((x21 + x22)/2))^2 + (_closureFartherSideFitMPy - ((y21 + y22)/2))^2)

								! distance of projecting closure gravity point and fitting wall skin endpoint
								if (dist_fitP_WallSkinP1 < EPS) then
									dist_closureMiddleP_skinEndP = sqr((_closureFartherSideFitMPx - x21)^2 + (_closureFartherSideFitMPy - y21)^2)
								else
									dist_closureMiddleP_skinEndP = sqr((_closureFartherSideFitMPx - x22)^2 + (_closureFartherSideFitMPy - y22)^2)
								endif

								! if the skin is outside of the closure then change the contour line attributes
								if dist_closureMiddleP_skinMiddleP > dist_closureMiddleP_skinEndP then
									if penIdx2 > 0 then
										contourLines[j][LINE_PEN_IDX]	= penIdx2
										contourLines[j][LINE_LTYPE_IDX]	= lineTypeIdx2
									endif
								endif
							else
								if penIdx2 > 0 then
									contourLines[j][LINE_PEN_IDX]	= penIdx2
									contourLines[j][LINE_LTYPE_IDX]	= lineTypeIdx2
								endif
							endif
						endif
					endif
				endif
			endif

			if state = 2 then	! S2 contains whole S1
				if penIdx2 > 0 then
					contourLines[j][LINE_PEN_IDX]	= penIdx2
					contourLines[j][LINE_LTYPE_IDX]	= lineTypeIdx2
				endif
			endif

			if state = 1 | state = 3 then	! (S1 contains whole S2) or (S1 and S2 has a section)

				if iStartInside = 0 then

					contourLines[j][LINE_BEG_X]	= x11
					contourLines[j][LINE_BEG_Y]	= y11
					contourLines[j][LINE_END_X]	= x21
					contourLines[j][LINE_END_Y]	= y21

					_bInsertRow = j < numContourLines
					if _bInsertRow then
						_numRow = numContourLines
						_insertedRow = j+1
						gosub "insert row to contourLines arrays"
					endif

					bx = x21
					by = y21
					if iEndInside = 0 then
						ex = x22
						ey = y22
					else
						ex = x12
						ey = y12
					endif

					numContourLines = numContourLines + 1
					contourLines[j+1][LINE_BEG_X]		= bx
					contourLines[j+1][LINE_BEG_Y]		= by
					contourLines[j+1][LINE_END_X]		= ex
					contourLines[j+1][LINE_END_Y]		= ey
					contourLines[j+1][LINE_ATTRIBUTES]	= contourLines[j][LINE_ATTRIBUTES]
					if penIdx2 > 0 then
						contourLines[j+1][LINE_PEN_IDX]		= penIdx2
						contourLines[j+1][LINE_LTYPE_IDX]	= lineTypeIdx2
					else
						contourLines[j+1][LINE_PEN_IDX]		= penIdx1
						contourLines[j+1][LINE_LTYPE_IDX]	= lineTypeIdx1
					endif
					overlappingEdgeSegmentIdx[j+1] = overlappingEdgeSegmentIdx[j]	! Index of the wall edge line segment

					if iEndInside = 0 then
						if _bInsertRow then
							_numRow = numContourLines
							_insertedRow = j+2
							gosub "insert row to contourLines arrays"
						endif

						bx = x22
						by = y22
						ex = x12
						ey = y12

						numContourLines = numContourLines + 1
						contourLines[j+2][LINE_BEG_X]		= bx
						contourLines[j+2][LINE_BEG_Y]		= by
						contourLines[j+2][LINE_END_X]		= ex
						contourLines[j+2][LINE_END_Y]		= ey
						contourLines[j+2][LINE_ATTRIBUTES]	= contourLines[j+1][LINE_ATTRIBUTES]
						contourLines[j+2][LINE_PEN_IDX]		= penIdx1
						contourLines[j+2][LINE_LTYPE_IDX]	= lineTypeIdx1
						overlappingEdgeSegmentIdx[j+2] = overlappingEdgeSegmentIdx[j]	! Overhanging line section
					endif
				else
					if iEndInside = 0 then
						contourLines[j][LINE_BEG_X]	= x11
						contourLines[j][LINE_BEG_Y]	= y11
						contourLines[j][LINE_END_X]	= x22
						contourLines[j][LINE_END_Y]	= y22
						if penIdx2 > 0 then
							contourLines[j][LINE_PEN_IDX]	= penIdx2
							contourLines[j][LINE_LTYPE_IDX]	= lineTypeIdx2
						endif

						_bInsertRow = j < numContourLines
						if _bInsertRow then
							_numRow = numContourLines
							_insertedRow = j+1
							gosub "insert row to contourLines arrays"
						endif

						bx = x22
						by = y22
						ex = x12
						ey = y12

						numContourLines = numContourLines + 1
						contourLines[j+1][LINE_BEG_X]		= bx
						contourLines[j+1][LINE_BEG_Y]		= by
						contourLines[j+1][LINE_END_X]		= ex
						contourLines[j+1][LINE_END_Y]		= ey
						contourLines[j+1][LINE_ATTRIBUTES]	= contourLines[j+1][LINE_ATTRIBUTES]
						contourLines[j+1][LINE_PEN_IDX]		= penIdx1
						contourLines[j+1][LINE_LTYPE_IDX]	= lineTypeIdx1
						overlappingEdgeSegmentIdx[j+1] = overlappingEdgeSegmentIdx[j]	! Overhanging line section
					else
						if iStartInside = 2 & iEndInside = 2 then
							if penIdx2 > 0 then
								contourLines[j][LINE_PEN_IDX]	= penIdx2
								contourLines[j][LINE_LTYPE_IDX]	= lineTypeIdx2
							endif
						endif
					endif
				endif
			endif

			j = j + 1

		while j < numContourLines + 1

	next i
endif


! ==============================================================================
! Draw standalone wall edge line sections
! ==============================================================================

numLines = vardim1(normalizedLineSections)
for i=1 to numLines
	if standaloneEdgeSegments[i] then

		px1 = normalizedLineSections[i][LINE_BEG_X]
		py1 = normalizedLineSections[i][LINE_BEG_Y]
		px2 = normalizedLineSections[i][LINE_END_X]
		py2 = normalizedLineSections[i][LINE_END_Y]
		penIdx		= normalizedLineSections[i][LINE_PEN_IDX]
		lineTypeIdx	= normalizedLineSections[i][LINE_LTYPE_IDX]
		iBitField	= round_int(normalizedLineSections[i][LINE_ATTRIBUTES])

		if penIdx > 0 then
			pen				penIdx
			line_type		lineTypeIdx
			line_property	LINE_PROPERTY_CONTOUR

			if bittest(iBitField, LINE_ATTRIBUTES_GDLLINE) then
				line2 px1,py1, px2,py2
			endif
			if bittest(iBitField, LINE_ATTRIBUTES_WALLLINE) then
				if (GLOB_PREVIEW_MODE = 0) then
					line2 px1,py1, px2,py2
				endif
				wallline2 px1,py1, px2,py2
			endif
		endif
	endif
next i


! ==============================================================================
! Draw standalone Cavity Closure line sections
! ==============================================================================

numContourLines = vardim1(contourLines)
for i=1 to min(numContourLines, vardim1(overlappingEdgeSegmentIdx))
	if overlappingEdgeSegmentIdx[i] = 0 then
		! Cavity Closure line segment is standalone if no matching
		! wallhole edge registered in overlappingEdgeSegmentIdx[] for it.

		px1 = contourLines[i][LINE_BEG_X]
		py1 = contourLines[i][LINE_BEG_Y]
		px2 = contourLines[i][LINE_END_X]
		py2 = contourLines[i][LINE_END_Y]
		lineProperty= LINE_PROPERTY_INNER + bittest(round_int(contourLines[i][LINE_ATTRIBUTES]), LINE_ATTRIBUTES_CONTOUR)	! INNER / CONTOUR
		penIdx		= contourLines[i][LINE_PEN_IDX]
		lineTypeIdx	= contourLines[i][LINE_LTYPE_IDX]

		if penIdx > 0 then
			pen				penIdx
			line_type		lineTypeIdx
			line_property	lineProperty

			if bittest(round_int(contourLines[i][LINE_ATTRIBUTES]), LINE_ATTRIBUTES_GDLLINE) then
				line2 px1,py1, px2,py2
			else
				wallline2 px1,py1, px2,py2
			endif
		endif
	endif
next i


! ==============================================================================
! Merge overlapping Cavity Closure and wallhole line segments.
! ------------------------------------------------------------------------------
! Remarks:
!	Set attributes of Cavity Closure line segments (CCLS)
!	based on the matching wallhole line segment (WHLS).
! ------------------------------------------------------------------------------
! Line Property: (Inner or Contour)
!
!	CCLS:	WHLS:	   Result:
!	Inner	Inner	-> Inner
!	Inner	Contour	-> Contour
!	Contour	Inner	-> Contour
!	Contour	Contour	-> Contour
! ------------------------------------------------------------------------------
! Pen and Line Type:
!	Always coming from the Cavity Closure line segments
! ------------------------------------------------------------------------------
! Wallline2 and/or GDL line2:
!	Wallline2 bit is set by default of course
!	GLD line2 bit is set too if matching wallhole line segment have this bit
! ------------------------------------------------------------------------------
! Visibility:
!	It is controlled with the zero pen index
!	Hidden (0) if pen index = 0
!	Shown (1) if pen idx > 0
!
!	CCLS:	WHLS:	   Result:
!	0		0		-> 0
!	0		1		-> 0
!	1		0		-> 1
!	1		0		-> 1
! ==============================================================================

numContourLines = vardim1(contourLines)
for i=1 to min(numContourLines, vardim1(overlappingEdgeSegmentIdx))
	edgeSegmentIdx = overlappingEdgeSegmentIdx[i]	! Index of the matching wallhole line segment
	if edgeSegmentIdx > 0 then

		iBitField		= round_int(contourLines[i][LINE_ATTRIBUTES])				! Own bitfield
		iEdgeBitField	= round_int(normalizedLineSections[edgeSegmentIdx][LINE_ATTRIBUTES])	! Matching line section's bitfield

! Line Property: (Inner or Contour) --------------------------------------------

		if bittest (iEdgeBitField, LINE_ATTRIBUTES_CONTOUR) then
			iBitField = bitset (iBitField, LINE_ATTRIBUTES_CONTOUR, 1)
		endif

! Wallline2 and/or GDL line2: --------------------------------------------------

		if bittest (iEdgeBitField, LINE_ATTRIBUTES_GDLLINE) then
			iBitField = bitset (iBitField, LINE_ATTRIBUTES_GDLLINE, 1)
		endif

! Visibility: ------------------------------------------------------------------

		! Nothing to do

! ------------------------------------------------------------------------------

		contourLines[i][LINE_ATTRIBUTES] = iBitField

	endif
next i


! ==============================================================================
! Cut off Cavity Closure line segments from the matching wallhole line segments
! ==============================================================================

dim standaloneEdgeSegmentFragments[]
for i = 1 to vardim1(normalizedLineSections)
	standaloneEdgeSegmentFragments[i] = 0	! initializing
next i

numContourLines = vardim1(contourLines)
for i=1 to min(numContourLines, vardim1(overlappingEdgeSegmentIdx))
	edgeSegmentIdx = overlappingEdgeSegmentIdx[i]	! Index of the matching wallhole line segment
	if edgeSegmentIdx > 0 then

		! The _bClosureContour is needed in every cases to show the overlapping
		! (wall contour on closure contour) edges because the state of "Show Opening Only"
		! MVO function are not queried.
		! If it will have a query then this parameter are deletable.
		_bClosureContour = bittest(round_int(contourLines[i][LINE_ATTRIBUTES]), LINE_ATTRIBUTES_CONTOUR_CLOSURE)
		x11 = contourLines[i][LINE_BEG_X]
		y11 = contourLines[i][LINE_BEG_Y]
		x12 = contourLines[i][LINE_END_X]
		y12 = contourLines[i][LINE_END_Y]

		x21 = normalizedLineSections[edgeSegmentIdx][LINE_BEG_X]
		y21 = normalizedLineSections[edgeSegmentIdx][LINE_BEG_Y]
		x22 = normalizedLineSections[edgeSegmentIdx][LINE_END_X]
		y22 = normalizedLineSections[edgeSegmentIdx][LINE_END_Y]

		gosub 999	! Segment - Segment sections

		if state = 1 then	! S1 contains whole S2
			if _bClosureContour then
				standaloneEdgeSegmentFragments[edgeSegmentIdx] = 1
			else
				! Do not need to draw this segment
				standaloneEdgeSegmentFragments[edgeSegmentIdx] = 0
			endif
		endif

		if state = 2 then	! S2 contains whole S1

			if iStartInside = 2 then
				if _bClosureContour then
					! Do not need to cut this segment with closure contour
pen 30
					standaloneEdgeSegmentFragments[edgeSegmentIdx] = 1
				else
					if iEndInside = 2 then
						normalizedLineSections[edgeSegmentIdx][LINE_BEG_X] = 0
						normalizedLineSections[edgeSegmentIdx][LINE_BEG_Y] = 0
						normalizedLineSections[edgeSegmentIdx][LINE_END_X] = 0
						normalizedLineSections[edgeSegmentIdx][LINE_END_Y] = 0
pen 5
standaloneEdgeSegmentFragments[edgeSegmentIdx] = 0
					else
						normalizedLineSections[edgeSegmentIdx][LINE_BEG_X] = x12
						normalizedLineSections[edgeSegmentIdx][LINE_BEG_Y] = y12
						normalizedLineSections[edgeSegmentIdx][LINE_END_X] = x22
						normalizedLineSections[edgeSegmentIdx][LINE_END_Y] = y22
pen 20
standaloneEdgeSegmentFragments[edgeSegmentIdx] = 1
					endif
				endif
			else
				if iEndInside = 2 then
					if _bClosureContour then
						! Do not need to cut this segment with closure contour
pen 30
						standaloneEdgeSegmentFragments[edgeSegmentIdx] = 1
					else
						normalizedLineSections[edgeSegmentIdx][LINE_BEG_X] = x21
						normalizedLineSections[edgeSegmentIdx][LINE_BEG_Y] = y21
						normalizedLineSections[edgeSegmentIdx][LINE_END_X] = x11
						normalizedLineSections[edgeSegmentIdx][LINE_END_Y] = y11
pen 1
standaloneEdgeSegmentFragments[edgeSegmentIdx] = 1
					endif
				else
pen 4
				endif
			endif

		x21 = normalizedLineSections[edgeSegmentIdx][LINE_BEG_X]
		y21 = normalizedLineSections[edgeSegmentIdx][LINE_BEG_Y]
		x22 = normalizedLineSections[edgeSegmentIdx][LINE_END_X]
		y22 = normalizedLineSections[edgeSegmentIdx][LINE_END_Y]
!RRR=RRR+0.002
!!			circle2 x11,y11, RRR
!!			circle2 x12,y12, RRR
!			circle2 x21,y21, RRR
!			circle2 x22,y22, RRR
		endif
	endif
next i


! ==============================================================================
! Draw standalon wallhole line section fragments
! ==============================================================================

!!!add2 0.01, 0.01
numLines = vardim1(standaloneEdgeSegmentFragments)
for i=1 to numLines
	if standaloneEdgeSegmentFragments[i] then

		penIdx = round_int(normalizedLineSections[i][LINE_PEN_IDX])

		if penIdx > 0 then
			iBitField	= round_int(normalizedLineSections[i][LINE_ATTRIBUTES])

			pen				penIdx
			line_type		round_int(normalizedLineSections[i][LINE_LTYPE_IDX])
			line_property	LINE_PROPERTY_INNER + (bittest(iBitField, LINE_ATTRIBUTES_CONTOUR))	! INNER / CONTOUR

			px1 = normalizedLineSections[i][LINE_BEG_X]
			py1 = normalizedLineSections[i][LINE_BEG_Y]
			px2 = normalizedLineSections[i][LINE_END_X]
			py2 = normalizedLineSections[i][LINE_END_Y]

			if bittest(iBitField, LINE_ATTRIBUTES_GDLLINE) then
				line2 px1,py1, px2,py2
			endif
			if bittest(iBitField, LINE_ATTRIBUTES_WALLLINE) then
				if (GLOB_PREVIEW_MODE = 0) then
					line2 px1,py1, px2,py2
				endif
				wallline2 px1,py1, px2,py2
			endif
		endif
	endif
next i

!!!del 1

! ==============================================================================
! Draw
! ==============================================================================

numContourLines = vardim1(contourLines)
for i=1 to min(numContourLines, vardim1(overlappingEdgeSegmentIdx))
	if overlappingEdgeSegmentIdx[i] > 0 then

		penIdx = round_int(contourLines[i][LINE_PEN_IDX])

		if penIdx > 0 then
			iBitField	= round_int(contourLines[i][LINE_ATTRIBUTES])

			pen				penIdx
			line_type		round_int(contourLines[i][LINE_LTYPE_IDX])
			line_property	LINE_PROPERTY_INNER + (bittest(iBitField, LINE_ATTRIBUTES_CONTOUR))	! INNER / CONTOUR

			px1 = contourLines[i][LINE_BEG_X]
			py1 = contourLines[i][LINE_BEG_Y]
			px2 = contourLines[i][LINE_END_X]
			py2 = contourLines[i][LINE_END_Y]

!!!RRR=RRR+0.0005
!!!circle2 px1,py1, RRR
!!!circle2 px2,py2, RRR

			if bittest(iBitField, LINE_ATTRIBUTES_GDLLINE) then
				line2 px1,py1, px2,py2
			endif
			if bittest(iBitField, LINE_ATTRIBUTES_WALLLINE) then
				if (GLOB_PREVIEW_MODE = 0) then
					line2 px1,py1, px2,py2
				endif
				wallline2 px1,py1, px2,py2
			endif
		endif
	endif
next i

del 1

return


! ==============================================================================
! Segment - Segment sections
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12:	S1 segment
!	x21,y21, x22,y22:	S2 segment
!
! Returned variables:
!	state:				 0 = S1 and S2 segments not on the same line
!						-1 = disjunct segments
!						 1 = S1 contains whole S2
!						 2 = S2 contains whole S1
!						 3 = S1 and S2 has a section
!	iStartInside:		 0 = S1 line segment starts outside of S2 line segment
!						 1 = S1 line segment starts inside of S2 line segment
!						 2 = S1 line segment starts on the S2 line segment's start point
!	iEndInside:			 The same for the end points
!
!-------------------------------------------------------------------------------
!   iEndInside -----------+
!   iStartInside ----+    |
!   state ------+    |    |
!               |    |    |
!-------------------------------------------------------------------------------
!               1    0    0   Not valid
!
!               1    1    0   Not valid
!
!               1    0    1   Not valid
!
!               1    1    1   Not valid
!
!               1    1    1   (S1)  B1 o--------------------------o E1
!                             (S2)  B2     o------------------o     E2
!
!               1    2    1   (S1)  B1 o--------------------------o E1
!                             (S2)  B2 o----------------------o     E2
!
!               1    1    2   (S1)  B1 o--------------------------o E1
!                             (S2)  B2     o----------------------o E2
!
!               1    2    2   (S1)  B1 o--------------------------o E1
!                             (S2)  B2 o--------------------------o E2
!
!               2    1    1   (S1)  B1     o------------------o     E1
!                             (S2)  B2 o--------------------------o E2
!
!               2    2    1   (S1)  B1 o----------------------o     E1
!                             (S2)  B2 o--------------------------o E2
!
!               2    1    2   (S1)  B1     o----------------------o E1
!                             (S2)  B2 o--------------------------o E2
!
!               2    2    2   (S1)  B1 o--------------------------o E1
!                             (S2)  B2 o--------------------------o E2
!
!               3    0    0   Not valid
!
!               3    0    1   (S1)  B1 o----------------------o     E1
!                             (S2)  B2     o----------------------o E2
!
!               3    1    0   (S1)  B1     o----------------------o E1
!                             (S2)  B2 o----------------------o     E2
!
!               3    0    2   (S1)  B1 o--------------------------o E1
!                             (S2)  B2     o----------------------o E2
!
!               3    2    0   (S1)  B1 o--------------------------o E1
!                             (S2)  B2 o----------------------o     E2
!
!               3    1    1   Not valid
!
!               3    2    2   Not valid
! ==============================================================================

999:
	lineL1 = sqr((x12 - x11)^2 + (y12 - y11)^2)
	if lineL1 < EPS then
		state = 0
	else
		if (abs((y12 - y11)*(x21 - x11) - (x12 - x11) * (y21 - y11)) / lineL1) > EPS then
			state = 0
		else
			state = -1
		endif
	endif

	if state <> 0 then
		lineL2 = sqr((x12 - x11)^2 + (y12 - y11)^2)
		if lineL2 < EPS then
			state = 0
		else
			if (abs((y12 - y11)*(x22 - x11) - (x12 - x11) * (y22 - y11)) / lineL2) > EPS then
				state = 0
			else
				state = -1
			endif
		endif
	endif

	if state <> 0 then
		bHorizontal = (abs(y11 - y12) < EPS)
		if not(bHorizontal) then
			if atn(abs(x11 - x12) / abs(y11 - y12)) > 45 then bHorizontal = 1
		endif

		if bHorizontal then
			! Mostly horizonal segmens

			if x11 > x12 then
				temp = x11
				x11 = x12
				x12 = temp

				temp = y11
				y11 = y12
				y12 = temp
			endif

			if x21 > x22 then
				temp = x21
				x21 = x22
				x22 = temp

				temp = y21
				y21 = y22
				y22 = temp
			endif

			iStartInside = (x21 - EPS < x11 & x22 + EPS > x11)
			if iStartInside > 0 then
				iStartInside = iStartInside + (abs(x21 - x11) < EPS | abs(x22 - x11) < EPS)
			endif
			iEndInside	 = (x21 - EPS < x12 & x22 + EPS > x12)
			if iEndInside > 0 then
				iEndInside = iEndInside + (abs(x21 - x12) < EPS | abs(x22 - x12) < EPS)
			endif

			if (x21 > x12 - EPS) | (x22 < x11 + EPS) then
				state = -1	! Disjunct segments
			else
				if (x21 > x11 - EPS) & (x22 < x12 + EPS) then
					state = 1
				else
					if (x21 < x11 + EPS) & (x22 > x12 - EPS) then
						state = 2
					else
						state = 3
					endif
				endif
			endif
		else
			! Mostly vertical segmens

			if y11 > y12 then
				temp = x11
				x11 = x12
				x12 = temp

				temp = y11
				y11 = y12
				y12 = temp
			endif

			if y21 > y22 then
				temp = x21
				x21 = x22
				x22 = temp

				temp = y21
				y21 = y22
				y22 = temp
			endif

			iStartInside = (y21 - EPS < y11 & y22 + EPS > y11)
			if iStartInside > 0 then
				iStartInside = iStartInside + (abs(y21 - y11) < EPS | abs(y22 - y11) < EPS)
			endif
			iEndInside	 = (y21 - EPS < y12 & y22 + EPS > y12)
			if iEndInside > 0 then
				iEndInside = iEndInside + (abs(y21 - y12) < EPS | abs(y22 - y12) < EPS)
			endif

			if (y21 > y12 - EPS) | (y22 < y11 + EPS) then
				state = -1	! Disjunct segments
			else
				if (y21 > y11 - EPS) & (y22 < y12 + EPS) then
					state = 1
				else
					if (y21 < y11 + EPS) & (y22 > y12 - EPS) then
						state = 2
					else
						state = 3
					endif
				endif
			endif
		endif
	endif
return


! ==============================================================================
! Line - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12	line #1
!	x21,y21, x22,y22	line #2
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = valid intersection point
!	cx, cy:				intersection point
! ==============================================================================

100:
	lliDiv = (x11-x12) * (y21-y22) - (y11-y12) * (x21-x22)

	if abs(lliDiv) > EPS then
		! Intersection

		temp1 = x11 * y12 - y11 * x12
		temp2 = x21 * y22 - y21 * x22

		tempx = temp1 * (x21-x22) - (x11-x12) * temp2
		tempy = temp1 * (y21-y22) - (y11-y12) * temp2

		state = 1
		cx = (tempx / lliDiv)
		cy = (tempy / lliDiv)
	else
		! No Intersection
		state = 0
		cx = 0
		cy = 0
	endif
return


! ==============================================================================
! Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	xo,yo,ro:			circle
!	x1,y1, x2,y2		line
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = one intersection point (tangential line)
!						2 = two intersection points
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
! ==============================================================================

101:
	tempX1 = x1 - xo: tempY1 = y1 - yo
	tempX2 = x2 - xo: tempY2 = y2 - yo

	if abs(tempX2 - tempX1) < EPS then
		if abs(ro - abs(tempX1)) < EPS then
			state = 1
			xa = tempX1
			ya = 0
			xb = tempX1
			yb = 0
		else
			if abs(ro) - abs(tempX1) < 0 then
				state = 0: xa = 0: ya = 0: xb = 0: yb = 0
			else
				state = 2
				xa = tempX1
				ya = sqr(ro^2 - tempX1^2)
				xb = tempX1
				yb = -sqr(ro^2 - tempX1^2)
			endif
		endif
	else
		kf = (tempY2 - tempY1) / (tempX2 - tempX1)
		ad = 1 + kf^2
		bd = 2 * tempY1 * kf - 2 * tempX1 * kf^2
		cd = tempY1^2 - 2 * tempX1 * tempY1 * kf + tempX1^2 * kf^2 - ro^2

		if bd^2 - 4 * ad * cd < 0 then
			state = 0: xa = 0: ya = 0: xb = 0: yb = 0
		else
			xa = (-bd + sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			ya = tempY1 + (xa - tempX1) * kf
			xb = (-bd - sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			yb = tempY1 + (xb - tempX1) * kf

			if abs(xa - xb) < EPS then state = 1 else state = 2
		endif
	endif

	if state = 2 then
		da = sqr((tempX1 - xa)^2 + (tempY1 - ya)^2)
		db = sqr((tempX1 - xb)^2 + (tempY1 - yb)^2)

		if db < da then
			xxo = xa: yyo = ya
			xa = xb:  ya = yb
			xb = xxo: yb = yyo
		endif
	endif

	xa = xa + xo: ya = ya + yo
	xb = xb + xo: yb = yb + yo
return


! ==============================================================================
! Select good intersection point after Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	state:				intersection status
!	wallIsLeft:
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
!
! Returned variables:
!	cx, cy:				selected intersection point
! ==============================================================================

102:
	cx = 0
	cy = 0
	if state = 1 then
		cx = xa
		cy = ya
	endif
	if state = 2 then
		if wallIsLeft then
			if ya > yb then
				cx = xa
				cy = ya
			else
				cx = xb
				cy = yb
			endif
		else
			if ya < yb then
				cx = xa
				cy = ya
			else
				cx = xb
				cy = yb
			endif
		endif
	endif
return


! ==============================================================================
! Direction Angle
! ------------------------------------------------------------------------------
! Input variables:
!	vx, vy:				vector
!
! Returned variables:
!	alpha:				selected intersection point
! ==============================================================================

103:

if abs(vx) < EPS & abs(vy) < EPS then
	angle = 0
	return
endif

if abs(vx) < EPS then
	if vy > 0 then
		angle = 90
	else
		angle = 270
	endif
else
	angle = atn(vy / vx)
	if vx >= 0 then
		if angle < 0 then
			angle = angle + 360
		endif
	else
		angle = 180 + angle
	endif
endif

return


! ==============================================================================
! Draw wallblock with contour
! ------------------------------------------------------------------------------
! Input variables:
!	stack:				wallblock polygon
!	penFillFg:			fill foreground pen (pen index)
!	penFillBg:			fill background pen (pen index)
!	bLocalFill:			fill orientation (0 / 1)
!	bDrawContour:		draw contour lines
!	bFitToSkinFill:		use soft insulation fill (0 / 1)
!	skinTurnThk:		skin thickness in case of bFitToSkinFill
!	penIdx:
!	lineTypeIdx:
! ==============================================================================

200:
	if nsp >= 9 then
		dirAngle = -signWallIsLeft * atn(vectS / vectC)

		if bDrawWallBlock then
			wallblock2{2} nsp/3 + 1, 2, 2,8 * (bLocalFill | bFitToSkinFill) + 32 * bFitToSkinFill + 128 * (bLocalFill & not(bFitToSkinFill)),
				penFillFg, penFillBg,
				use(2),
				-sin(dirAngle),-cos(dirAngle), -skinTurnThk*cos(dirAngle),skinTurnThk*sin(dirAngle),
				0,
				0,-WOD,900,
				use(nsp)
		else
			poly2_b{5} nsp/3 + 1, 2+4, 2,8 * (bLocalFill | bFitToSkinFill) + 32 * bFitToSkinFill,
				penFillFg, penFillBg,
				use(2),
				-sin(dirAngle),-cos(dirAngle), -skinTurnThk*cos(dirAngle),skinTurnThk*sin(dirAngle),
				0,
				0,-WOD,900,
				use(nsp)
		endif
	endif
	if nsp < 9 | not(bDrawContour) then
		for ii=1 to nsp
			n = get(1)
		next ii
		return
	endif

	numPoints = nsp/3
	for ii=1 to numPoints
		if ii = 1 then
			x1 = get(1)
			y1 = get(1)
			s1 = get(1)
			firstX = x1
			firstY = y1
			firstS = s1
		endif
		if ii = numPoints then
			x2 = firstX
			y2 = firstY
			s2 = firstS
		else
			x2 = get(1)
			y2 = get(1)
			s2 = get(1)
		endif

		if bittest(s2, 0) then
			if s2 >= 3000 then
				R = sqr(x2^2 + (y2 + WOD)^2)

				vx = x1
				vy = y1 + WOD
				gosub 103	! Direction Angle
				alpha = angle

				vx = x2
				vy = y2 + WOD
				gosub 103	! Direction Angle
				beta = angle

				if abs(alpha - beta) > EPS then
					if bClosureContour then
						arc2 0,-WOD, R, min(alpha,beta), max(alpha,beta)
					else
						wallarc2 0,-WOD, R, min(alpha,beta), max(alpha,beta)
					endif
				endif
			else
!				wallline2 x1,y1, x2,y2

				bpx = x1
				bpy = y1
				epx = x2
				epy = y2
				!penIdx		= tempPen
				!lineTypeIdx	= tempLineType

				iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 0) + bitset(0, LINE_ATTRIBUTES_CONTOUR_CLOSURE, bClosureContour)
				gosub 4920	! Put line section into Cavity Closure lines array
			endif
		endif

		x1 = x2
		y1 = y2
		s1 = s2
	next ii
return


! ==============================================================================
! Segment - Segment sections
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12:	S1 segment
!	x21,y21, x22,y22:	S2 segment
!
! Returned variables:
!	state:				 0 = S1 and S2 segments not on the same line
!						-1 = disjunct segments
!						 1 = S1 contains whole S2
!						 2 = S2 contains whole S1
!						 3 = S1 and S2 has a section
! ==============================================================================

300:
	lineL1 = sqr((x12 - x11)^2 + (y12 - y11)^2)
	if lineL1 < EPS then
		state = 0
	else
		if (abs((y12 - y11)*(x21 - x11) - (x12 - x11) * (y21 - y11)) / lineL1) > EPS then
			state = 0
		else
			state = -1
		endif
	endif

	if state <> 0 then
		lineL2 = sqr((x12 - x11)^2 + (y12 - y11)^2)
		if lineL2 < EPS then
			state = 0
		else
			if (abs((y12 - y11)*(x22 - x11) - (x12 - x11) * (y22 - y11)) / lineL2) > EPS then
				state = 0
			else
				state = -1
			endif
		endif
	endif

	if state <> 0 then
		bHorizontal = (abs(y11 - y12) < EPS)
		if not(bHorizontal) then
			if atn(abs(x11 - x12) / abs(y11 - y12)) > 45 then bHorizontal = 1
		endif

		if bHorizontal then
			! Mostly horizonal segmens

			if x11 > x12 then
				temp = x11
				x11 = x12
				x12 = temp

				temp = y11
				y11 = y12
				y12 = temp
			endif

			if x21 > x22 then
				temp = x21
				x21 = x22
				x22 = temp

				temp = y21
				y21 = y22
				y22 = temp
			endif

			iStartInside = (x21 - EPS < x11 & x22 + EPS > x11)
			if iStartInside > 0 then
				iStartInside = iStartInside + (abs(x21 - x11) < EPS | abs(x22 - x11) < EPS)
			endif
			iEndInside	 = (x21 - EPS < x12 & x22 + EPS > x12)
			if iEndInside > 0 then
				iEndInside = iEndInside + (abs(x21 - x12) < EPS | abs(x22 - x12) < EPS)
			endif

			if (x21 > x12 - EPS) | (x22 < x11 + EPS) then
				state = -1	! Disjunct segments
			else
				if (x21 > x11 - EPS) & (x22 < x12 + EPS) then
					state = 1
				else
					if (x21 < x11 + EPS) & (x22 > x12 - EPS) then
						state = 2
					else
						state = 3
					endif
				endif
			endif
		else
			! Mostly vertical segmens

			if y11 > y12 then
				temp = x11
				x11 = x12
				x12 = temp

				temp = y11
				y11 = y12
				y12 = temp
			endif

			if y21 > y22 then
				temp = x21
				x21 = x22
				x22 = temp

				temp = y21
				y21 = y22
				y22 = temp
			endif

			iStartInside = (y21 - EPS < y11 & y22 + EPS > y11)
			if iStartInside > 0 then
				iStartInside = iStartInside + (abs(y21 - y11) < EPS | abs(y22 - y11) < EPS)
			endif
			iEndInside	 = (y21 - EPS < y12 & y22 + EPS > y12)
			if iEndInside > 0 then
				iEndInside = iEndInside + (abs(y21 - y12) < EPS | abs(y22 - y12) < EPS)
			endif

			if (y21 > y12 - EPS) | (y22 < y11 + EPS) then
				state = -1	! Disjunct segments
			else
				if (y21 > y11 - EPS) & (y22 < y12 + EPS) then
					state = 1
				else
					if (y21 < y11 + EPS) & (y22 > y12 - EPS) then
						state = 2
					else
						state = 3
					endif
				endif
			endif
		endif
	endif

!!!lineTypeIdx2	= normalizedLineSections[idx + LINE_LTYPE_IDX]
!!!penIdx2			= normalizedLineSections[idx + LINE_PEN_IDX]
!!!bContourLine1	= 1
!!!iBitField		= round_int(normalizedLineSections[idx + LINE_ATTRIBUTES])
!!!bNeedGDLLine2	= (bittest(iBitField, LINE_ATTRIBUTES_GDLLINE))		! Need GDL line too

!	if state = 0 | state = -1 then	! not on the same line or disjunct segments
	if state = -1 then	! disjunct segments
		return

		bx = x11
		by = y11
		ex = x12
		ey = y12
		lineTypeIdx		= lineTypeIdx1
		penIdx			= penIdx1
		bContourLine	= (bContourLine1 | bContourLine2)
		bNeedGDLLine	= bNeedGDLLine1
		gosub 301

		return
	endif

	if state = 1 then	! S1 contains whole S2

		bx = x21
		by = y21
		ex = x22
		ey = y22
		lineTypeIdx		= lineTypeIdx1
		penIdx			= penIdx1
		bContourLine	= (bContourLine1 | bContourLine2)
		bNeedGDLLine	= bNeedGDLLine1
		gosub 301

		return
	endif

	if state = 2 then	! S2 contains whole S1
	endif

	if state = 3 then	! S1 and S2 has a section
	endif

	bx = x11
	by = y11
	ex = x11
	ey = y11
!	gosub 301	! S1 out

	if iStartInside = 0 then
		bx = x12
		by = y12
	else
		bx = x21
		by = y21
	endif

	ex = x11
	ey = y11
!	gosub 301	! S1 out
return


301:
!!	if vardim1(jdxArray) >= actualJdx + 1 then
!!		if jdxArray[actualJdx + 1] then
!!			return
!!		endif
!!	endif
!!	jdxArray[actualJdx + 1] = 1
!
!	mergedSections[mdx + CLINE_BEG_X] = bx
!	mergedSections[mdx + CLINE_BEG_Y] = by
!	mergedSections[mdx + CLINE_END_X] = ex
!	mergedSections[mdx + CLINE_END_Y] = ey
!	mergedSections[mdx + LINE_PEN_IDX]	= penIdx
!	mergedSections[mdx + LINE_LTYPE_IDX]= lineTypeIdx
!	if bContourLine then
!		mergedSections[mdx + CLINE_PROPERTY] = LINE_PROPERTY_CONTOUR
!	else
!		mergedSections[mdx + CLINE_PROPERTY] = LINE_PROPERTY_INNER
!	endif
!	mergedSections[mdx + CLINE_GDL] = (bNeedGDLLine)
!	mdx = mdx + CLINE_STRUCTURE_SIZE
return

302:
return


! ==============================================================================
! Searching for a fitting point to line
! ------------------------------------------------------------------------------
! Input variables:
!	EPS
!	dVx, dVy			direction vector of the line
!	linePx, linePy		coordinates of a point of the line
!	pointPx, pointPy	coordinates of the point
!
! Output variables:
!	bFitPoint		state of fitting - 1: true, 0: false
! ------------------------------------------------------------------------------
"SearchFitPointToLine":
	! Calculate A, B and C parameter
	! paramA, paramB are equal to normal vector of the line
	paramA = -dVy
	paramB = dVx
	paramC = -(paramA*linePx) - (paramB*linePy)

	! Calculate distance
	_distPointLine = (abs((paramA * pointPx) + (paramB * pointPy) + paramC)) / (sqr(paramA^2 + paramB^2))
	if _distPointLine < EPS then
		bFitPoint = 1
	else
		bFitPoint = 0
	endif
return


! ==============================================================================
! Collect composite wall skins sizes and attributes
! ------------------------------------------------------------------------------
! Input variables:
!	WALL_SKINS_PARAMS array
!	WALL_SKINS_NUMBER
!	iSkin
!	
! Output variables:
!	_wallSkinSectionLines array
! ------------------------------------------------------------------------------
"CollectWallSkinSectionLines":

	_bpx = _closureFartherSidePx
	_epx = _closureFartherSidePx
	_bpy = 0

	for idx = 1 to WALL_SKINS_NUMBER
		_epy = _bpy + WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]

		_wallSkinSectionLines[iSkin][LINE_BEG_X]			= _bpx * signX * sideSign
		_wallSkinSectionLines[iSkin][LINE_BEG_Y]			= _bpy * signY + offsetY
		_wallSkinSectionLines[iSkin][LINE_END_X]			= _epx * signX * sideSign
		_wallSkinSectionLines[iSkin][LINE_END_Y]			= _epy * signY + offsetY
		_wallSkinSectionLines[iSkin][LINE_ATTRIBUTES]		= 0		! unused
		_wallSkinSectionLines[iSkin][LINE_PEN_IDX]			= WALL_SKINS_PARAMS[idx][SKIN_END_FACE_PEN]
		_wallSkinSectionLines[iSkin][LINE_LTYPE_IDX]		= WALL_SKINS_PARAMS[idx][SKIN_END_LINE_TYPE]

		_bpy = _epy
		iSkin = iSkin + 1
	next idx
return


! ==============================================================================
! Insert row to contourLines and overlappingEdgeSegmentIdx array
! ------------------------------------------------------------------------------
! Input variables:
!	contourLines
!	overlappingEdgeSegmentIdx
!	_insertedRow
!	_numRow
! ------------------------------------------------------------------------------
"insert row to contourLines arrays":
	for _iRow = _numRow to _insertedRow step -1
		contourLines[_iRow + 1][LINE_BEG_X]			= contourLines[_iRow][LINE_BEG_X]
		contourLines[_iRow + 1][LINE_BEG_Y]			= contourLines[_iRow][LINE_BEG_Y]
		contourLines[_iRow + 1][LINE_END_X]			= contourLines[_iRow][LINE_END_X]
		contourLines[_iRow + 1][LINE_END_Y]			= contourLines[_iRow][LINE_END_Y]
		contourLines[_iRow + 1][LINE_ATTRIBUTES]	= contourLines[_iRow][LINE_ATTRIBUTES]
		contourLines[_iRow + 1][LINE_PEN_IDX]		= contourLines[_iRow][LINE_PEN_IDX]
		contourLines[_iRow + 1][LINE_LTYPE_IDX]		= contourLines[_iRow][LINE_LTYPE_IDX]

		overlappingEdgeSegmentIdx[_iRow + 1] = overlappingEdgeSegmentIdx[_iRow]
	next _iRow
return
