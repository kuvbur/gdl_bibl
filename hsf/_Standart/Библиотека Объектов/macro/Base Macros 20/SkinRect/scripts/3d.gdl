
! Contact person: <TZs>
! =============================================================================
! The macro draws a rectangular (or ring-sector-part) wall block in 3D
! considering the possible distortions caused by trapeze or curved walls.
! -----------------------------------------------------------------------------
! Input Parameters:
!	startX:				diagonal corner 1
!	startY:				(at bottom)	must be lower than yEnd
!	endX:				diagonal corner 2
!	endY:				(at top)	must be greater than yStart
!	trapType:			type of rectangular block	(integer)
!							(0 = rectangle, 1 = trapeze, 2 = parallelogram)
!	bDoCut:				do wallhole or generate wallblock (0 / 1)
!	matVert:			materials
!	innerRadius:		inner radius of the wall (length)
!	incAngle:			inclination angle of trapeze wall sides (angle)
!	mirrorArcs:			wall position (0 / 1)
!	edge1 ... edge4:	edge masks for XWALL (integer)
!
! Remark:
!	The generated shapes are:
!		rectangle (used in straight and trapeze walls)
!		trapeze (in trapeze walls)
!		parallelogram (in trapeze walls)
!		ring-sector (in curved walls)
! -----------------------------------------------------------------------------

if abs(startX - endX) < EPS | (abs (startY - endY) < EPS & (abs(incAngle) < EPS | trapType <> 1)) then	! NJ, #38133
	end
endif

! queuw saving omitted - assuming it is not used outside

resol WALL_RESOL

if bDoCut < EPS then

	material matVert

endif

if innerRadius < EPS then

!*** straight ***!

	if abs(incAngle) < EPS or trapType = 0 then
		!--- rectangle ---

		if bDoCut then
			if abs(ac_wall_slant_angle1 - ac_wall_slant_angle2) < EPS then
				heightModifier = 0
!				if abs(ac_wall_slant_angle1 - 90) > EPS then
!					heightModifier = WALL_THICKNESS * cos (ac_wall_slant_angle1)
!				endif
				addz -heightModifier
				wallniche 4, 1, 1,
					0, 0, 1, height + 2*heightModifier,
					startX, startY,	0,
					startX, endY, 0,
					endX, endY, 0,
					endX, startY, 0
				del 1
			endif
		else
			if abs(90 - ac_wall_slant_angle1) < EPS then
				xwall_ matLeft, matRight, matVert, matHoriz,
						height, startX, endX, endX, startX,
						startY, startY, endY, endY,
						endY - startY, 0, 0, 0,
						edge1, edge2, edge3, edge4, 0, 0, 0
			else
				if abs(ac_wall_slant_angle1 - ac_wall_slant_angle2) < EPS then
					slantAngle = -(ac_wall_slant_angle1 - 90)
					if SYMB_MIRRORED then
						slantAngle = -slantAngle
					endif
					zCoordModif = 0
					if SYMB_MIRRORED and abs(ac_wall_slant_angle1)> EPS then
						zCoordModif = -WALL_THICKNESS / tan(ac_wall_slant_angle1)
					endif
					SPRISM_{2} matHoriz, matHoriz, matVert,
							4,
							0, 0, 1, 0, height + zCoordModif, slantAngle,
							0, 0, 1, 0, 0 + zCoordModif, slantAngle,
							startX, startY,	15, matRight,
							startX, endY,	15, matLeft,
							endX, endY,	15, matLeft,
							endX, startY,	15, matLeft
				else
					roty 90
					addz startX-EPS
					angle1 = -(90-ac_wall_slant_angle1)
					if SYMB_MIRRORED then
						angle1 = 90-ac_wall_slant_angle1
					endif
					angle2 = angle1
					if (trapType = 1) then		! trapeze
						angle1 = -(90-ac_wall_slant_angle1)
						angle2 = -(90-ac_wall_slant_angle2)
						if SYMB_MIRRORED then
							angle1 = 90-ac_wall_slant_angle2
							angle2 = 90-ac_wall_slant_angle1
						endif
					else
						if (trapType = 2) then	! parallelogram
							angle1 = -(90-ac_wall_slant_angle2)
							if SYMB_MIRRORED then
								angle1 = 90-ac_wall_slant_angle2
							endif
							angle2 = angle1
						endif
					endif
					height2 = -height
					endY2 = endY - height2 * tan(angle2)
					startY2 = startY - height2 * tan(angle1)
					if (startY - endY) * (startY2 - endY2) < 0 then
						tmp = height2 / ((startY - endY) + (startY2 - endY2))
						height2 = -tmp * (startY - endY) - EPS
						endY2 = endY - height2 * tan(angle2)
						startY2 = endY2
					endif
					SPRISM_{2} matVert, matVert, matHoriz,
							4,
							0, 0, 1, 0, endX - startX, 0,
							0, 0, 1, 0, 0, 0,
							0, startY,	15, matHoriz,
							0, endY,	15, matLeft,
							height2, endY2,		15, matHoriz,
							height2, startY2,	15, matLeft
					del 2
				endif
			endif

			gosub "wallTextureCoor"	! fix the texture coordite system
		endif

	else
		diff0 = startX * tan(incAngle)
		diff1 = endX * tan(incAngle)
		if trapType = 1 then
			!--- trapeze ---
			if SYMB_MIRRORED then
				if bDoCut then
					wallniche 4, 1, 1,
						0, 0, 1, height,
						startX, startY + diff0, 0,
						startX, endY, 0,
						endX, endY, 0,
						endX, startY + diff1, 0
				else
					xwall_ matLeft, matRight, matVert, matHoriz,
						height, startX, endX, endX, startX,
						startY + diff0, startY + diff1, endY, endY,
						endY - startY, 0, 0, 0,
						edge1, edge2, edge3, edge4, 0, 0, 0

					gosub "wallTextureCoor"	! fix the texture coordite system
				endif

			else
				if bDoCut > EPS then
					wallniche 4, 1, 1,
						0, 0, 1, height,
						startX, startY, 0,
						endX, startY, 0,
						endX, endY + diff1, 0,
						startX, endY + diff0, 0
				else
					xwall_ matLeft, matRight, matVert, matHoriz,
						height, startX, endX, endX, startX,
						startY, startY, endY + diff1, endY + diff0,
						endY - startY, 0, 0, 0,
						edge1, edge2, edge3, edge4, 0, 0, 0

					gosub "wallTextureCoor"	! fix the texture coordite system
				endif

			endif
		else
			!--- parallelogram ---
			if bDoCut then
				wallniche 4, 1, 1,
					0, 0, 1, height,
					startX, startY + diff0, 0,
					startX, endY + diff0, 0,
					endX, endY + diff1, 0,
					endX, startY + diff1, 0
			else
				xwall_ matLeft, matRight, matVert, matHoriz,
					height, startX, endX, endX, startX,
					startY + diff0, startY + diff1, endY + diff1, endY + diff0,
					endY - startY, 0, 0, 0,
					edge1, edge2, edge3, edge4, 0, 0, 0

				gosub "wallTextureCoor"	! fix the texture coordite system
			endif

		endif
	endif

else

!*** curved ***!

	if mirrorArcs < EPS then

		if bDoCut then

			putAngle = abs(WIDO_POSITION) - startAngle
			putY = startY
			flags = 0
			gosub 22
			iStart = int((abs(WIDO_POSITION) - endAngle) / (180 / WALL_RESOL)) + 1
			iEnd = int((abs(WIDO_POSITION) - startAngle) / (180 / WALL_RESOL))
			for i = 1 to iEnd - iStart
				putAngle = (iEnd - i + 1) * (180 / WALL_RESOL)
				putY = startY
				flags = 0
				gosub 22
			next i
			putAngle = abs(WIDO_POSITION) - endAngle
			putY = startY
			flags = 0
			gosub 22
			putAngle = abs(WIDO_POSITION) - endAngle
			putY = endY
			flags = edge3
			gosub 22
			for i = iStart to iEnd
				putAngle = i * (180 / WALL_RESOL)
				putY = endY
				flags = 0
				gosub 22
			next i
			putAngle = abs(WIDO_POSITION) - startAngle
			putY = endY
			flags = 0
			gosub 22

			wallniche NSP/3, 1, 1,
				0, 0, 1, height,
				get(NSP)

		else

			if bittest(edge1, 0) > EPS then
				edge1_ = bitset(edge1_, 2)
			endif
			if bittest(edge1, 1) > EPS then
				edge2_ = bitset(edge2_, 1)
			endif
			if bittest(edge1, 2) > EPS then
				edge1_ = bitset(edge1_, 0)
			endif
			if bittest(edge1, 3) > EPS then
				edge1_ = bitset(edge1_, 3)
			endif
			if bittest(edge2, 0) > EPS then
				edge4_ = bitset(edge4_, 2)
			endif
			if bittest(edge2, 1) > EPS then
				edge1_ = bitset(edge1_, 1)
			endif
			if bittest(edge2, 2) > EPS then
				edge4_ = bitset(edge4_, 0)
			endif
			if bittest(edge2, 3) > EPS then
				edge4_ = bitset(edge4_, 3)
			endif
			if bittest(edge3, 0) > EPS then
				edge3_ = bitset(edge3_, 2)
			endif
			if bittest(edge3, 1) > EPS then
				edge4_ = bitset(edge4_, 1)
			endif
			if bittest(edge3, 2) > EPS then
				edge3_ = bitset(edge3_, 0)
			endif
			if bittest(edge3, 3) > EPS then
				edge3_ = bitset(edge3_, 3)
			endif
			if bittest(edge4, 0) > EPS then
				edge2_ = bitset(edge2_, 2)
			endif
			if bittest(edge4, 1) > EPS then
				edge3_ = bitset(edge3_, 1)
			endif
			if bittest(edge4, 2) > EPS then
				edge2_ = bitset(edge2_, 0)
			endif
			if bittest(edge4, 3) > EPS then
				edge2_ = bitset(edge2_, 3)
			endif

			lengthMul = (innerRadius + endY) / (outerRadius - WALL_THICKNESS/2)
			addy startY

			addy -(innerRadius + startY)
			rotz -endAngle
			roty 90
			mul -1, 1, 1
			if (abs(WIDO_POSITION) - endAngle) < 180 then
				cutformwidth = (innerRadius + startY) * cos(WIDO_POSITION - endAngle)
				cutformwidth2 = (innerRadius + endY) * cos(WIDO_POSITION - endAngle) - WALL_THICKNESS
				if cutformwidth2 < cutformwidth then
					cutformwidth = cutformwidth2
				endif
			else
				cutformwidth = -(innerRadius + endY) * 1.1
				mulz -1
				cutform 4, 1, 3+192,
					0, 0, 1, -(innerRadius + endY) * 1.1 * sin(WIDO_POSITION - endAngle),
					-0.1, (innerRadius + startY) * cos(WIDO_POSITION - endAngle) * 0.9, 1,
					height+0.1, (innerRadius + startY) * cos(WIDO_POSITION - endAngle) * 0.9, 1,
					height+0.1, -(innerRadius + endY) * 1.1, 1,
					-0.1, -(innerRadius + endY) * 1.1, 1
				del 1
			endif
			cutform 4, 1, 3+192,
				0, 0, 1, (innerRadius + endY) * 1.1,
				-0.1, cutformwidth, 1,
				height+0.1, cutformwidth, 1,
				height+0.1, (innerRadius + endY) * 1.1, 1,
				-0.1, (innerRadius + endY) * 1.1, 1
			del 4

			addy -(innerRadius + startY)
			rotz -startAngle
			roty 90
			mul -1, 1, -1
			cutform 4, 1, 3+192,
				0, 0, 1, innerRadius + endY,
				-EPS, 0, 1,
				height+EPS, 0, 1,
				height+EPS, (innerRadius + endY) * 1.2, 1,
				-EPS, (innerRadius + endY) * 1.2, 1
			del 4
			del 1

			segmentSafetyAdd = 3 * (innerRadius + endY) * (2 * PI / WALL_RESOL)
			if abs (endAngle) > EPS then
				add 0, -innerRadius, 0
				rotz -abs(WIDO_POSITION)
				add 0, innerRadius + endY, 0
				wallLength = (innerRadius + endY) * abs(WIDO_POSITION) * PI / 180
			else
				add 0, endY, 0
			endif
			rotz 180
			if abs (startX) > EPS then
				wallLength = wallLength + segmentSafetyAdd - startX * lengthMul
			endif

			xwall_ matRight, matLeft, matVert, matHoriz,
					height, 0, wallLength, wallLength, 0,
					0, 0, endY - startY, endY - startY,
					endY - startY, innerRadius + endY,
					0, 0,
					edge1_, edge2_, edge3_, edge4_, 0, 0, 0

			if abs(endAngle) > EPS then
				del 2
			endif
			del 2

			cutend
			cutend
			if not((abs(WIDO_POSITION) - endAngle) < 180) then
				cutend
			endif

			putAngle = abs(WIDO_POSITION) - endAngle
			putY = startY
			flags = 0
			gosub 22
			xInner = get(1)
			yInner = get(1)
			dummy = get(1)
			putY = endY
			flags = 0
			gosub 22
			xOuter = get(1)
			yOuter = get(1)
			dummy = get(1)
			if bittest(edge2, 0) > EPS then
				lin_ xInner, yInner, 0, xInner, yInner, height
			endif
			if bittest(edge2, 2) > EPS then
				lin_ xOuter, yOuter, 0, xOuter, yOuter, height
			endif
			if bittest(edge2, 1) > EPS then
				lin_ xInner, yInner, 0, xOuter, yOuter, 0
			endif
			if bittest(edge3, 1) > EPS then
				lin_ xInner, yInner, height, xOuter, yOuter, height
			endif

			putAngle = abs(WIDO_POSITION) - startAngle
			putY = startY
			flags = 0
			gosub 22
			xInner = get(1)
			yInner = get(1)
			dummy = get(1)
			putY = endY
			flags = 0
			gosub 22
			xOuter = get(1)
			yOuter = get(1)
			dummy = get(1)
			if bittest(edge4, 0) > EPS then
				lin_ xInner, yInner, 0, xInner, yInner, height
			endif
			if bittest(edge4, 2) > EPS then
				lin_ xOuter, yOuter, 0, xOuter, yOuter, height
			endif
			if bittest(edge1, 1) > EPS then
				lin_ xInner, yInner, 0, xOuter, yOuter, 0
			endif
			if bittest(edge4, 1) > EPS then
				lin_ xInner, yInner, height, xOuter, yOuter, height
			endif

		endif

	else

		if bDoCut then

			putAngle = startAngle
			putY = startY
			flags = 0
			gosub 23
			iStart = int(startAngle / (180 / WALL_RESOL)) + 1
			iEnd = int(endAngle / (180 / WALL_RESOL))
			for i = iStart to iEnd
				putAngle = i * (180 / WALL_RESOL)
				putY = startY
				flags = 0
				gosub 23
			next i
			putAngle = endAngle
			putY = startY
			flags = 0
			gosub 23
			putAngle = endAngle
			putY = endY
			flags = 0
			gosub 23
			for i = iStart to iEnd
				putAngle = (iEnd + iStart - i) * (180 / WALL_RESOL)
				putY = endY
				flags = 0
				gosub 23
			next i
			putAngle = startAngle
			putY = endY
			flags = 0
			gosub 23

			wallniche NSP/3, 1, 1,
				0, 0, 1, height,
				get(NSP)

		else

			lengthMul = (outerRadius - startY) / (outerRadius - WALL_THICKNESS/2)
			segmentSafetyAdd = 3 * (outerRadius - startY) * (2 * PI / WALL_RESOL)
			addy startY

			addy (outerRadius - startY)
			rotz endAngle
			roty 90
			mul -1, -1, 1
			cutform 4, 1, 3+192,
				0, 0, 1, segmentSafetyAdd * lengthMul,
				-EPS, 0, 1,
				height+EPS, 0, 1,
				height+EPS, (outerRadius - startY) * 1.2, 1,
				-EPS, (outerRadius - startY) * 1.2, 1
			del 4

			addy (outerRadius - startY)
			rotz startAngle
			roty -90
			mul 1, -1, 1
			cutform 4, 1, 3+192,
				0, 0, 1, segmentSafetyAdd * lengthMul,
				-EPS, 0, 1,
				height+EPS, 0, 1,
				height+EPS, (outerRadius - startY) * 1.2, 1,
				-EPS, (outerRadius - startY) * 1.2, 1
			del 4

			xStartWall = 0
			if startX < -EPS then
				xStartWall = (startX - segmentSafetyAdd) * lengthMul
			endif
			if abs(endX) < EPS then
				xEndWall = 0
			else
				xEndWall = (endX + segmentSafetyAdd) * lengthMul
			endif
			xwall_ matLeft, matRight, matVert, matHoriz,
					height, xStartWall, xEndWall, xEndWall, xStartWall,
					0, 0, endY - startY, endY - startY,
					endY - startY, outerRadius - startY,
					0, 0,
					edge1, edge2, edge3, edge4, 0, 0, 0
			cutend
			cutend
			del 1

			putAngle = endAngle
			putY = startY
			flags = 0
			gosub 23
			xInner = get(1)
			yInner = get(1)
			dummy = get(1)
			putY = endY
			flags = 0
			gosub 23
			xOuter = get(1)
			yOuter = get(1)
			dummy = get(1)
			if bittest(edge2, 0) > EPS then
				lin_ xInner, yInner, 0, xInner, yInner, height
			endif
			if bittest(edge2, 2) > EPS then
				lin_ xOuter, yOuter, 0, xOuter, yOuter, height
			endif
			if bittest(edge2, 1) > EPS then
				lin_ xInner, yInner, 0, xOuter, yOuter, 0
			endif
			if bittest(edge3, 1) > EPS then
				lin_ xInner, yInner, height, xOuter, yOuter, height
			endif

			putAngle = startAngle
			putY = startY
			flags = 0
			gosub 23
			xInner = get(1)
			yInner = get(1)
			dummy = get(1)
			putY = endY
			flags = 0
			gosub 23
			xOuter = get(1)
			yOuter = get(1)
			dummy = get(1)
			if bittest(edge4, 0) > EPS then
				lin_ xInner, yInner, 0, xInner, yInner, height
			endif
			if bittest(edge4, 2) > EPS then
				lin_ xOuter, yOuter, 0, xOuter, yOuter, height
			endif
			if bittest(edge1, 1) > EPS then
				lin_ xInner, yInner, 0, xOuter, yOuter, 0
			endif
			if bittest(edge4, 1) > EPS then
				lin_ xInner, yInner, height, xOuter, yOuter, height
			endif

		endif

	endif

endif

! queue restoring omitted - assuming it is not used outside

end


!**************************** SUBROUTINES ***********************************!

! ===== set the texture coordinate system to match the wall =====
"wallTextureCoor":
	if gs_useWallMat then
		for iTrafo = numTrafo to 1 step -1
			if abs(trafo_array[iTrafo][1] - TRAFO_ADD_X) < EPS then
				addx -trafo_array[iTrafo][2]
			endif
			if abs(trafo_array[iTrafo][1] - TRAFO_ADD_Y) < EPS then
				addy -trafo_array[iTrafo][2]
			endif
			if abs(trafo_array[iTrafo][1] - TRAFO_ADD_Z) < EPS then
				addz -trafo_array[iTrafo][2]
			endif
			if abs(trafo_array[iTrafo][1] - TRAFO_ROT_X) < EPS then
				rotx -trafo_array[iTrafo][2]
			endif
			if abs(trafo_array[iTrafo][1] - TRAFO_ROT_Y) < EPS then
				roty -trafo_array[iTrafo][2]
			endif
			if abs(trafo_array[iTrafo][1] - TRAFO_ROT_Z) < EPS then
				rotz -trafo_array[iTrafo][2]
			endif
			if abs(trafo_array[iTrafo][1] - TRAFO_MUL_X) < EPS then
				mulx 1/trafo_array[iTrafo][2]
			endif
			if abs(trafo_array[iTrafo][1] - TRAFO_MUL_Y) < EPS then
				muly 1/trafo_array[iTrafo][2]
			endif
			if abs(trafo_array[iTrafo][1] - TRAFO_MUL_Z) < EPS then
				mulz 1/trafo_array[iTrafo][2]
			endif
		next iTrafo

		base
		vert WALL_TEXTURE_WRAP[3], WALL_TEXTURE_WRAP[4], WALL_TEXTURE_WRAP[5]
		vert WALL_TEXTURE_WRAP[6], WALL_TEXTURE_WRAP[7], WALL_TEXTURE_WRAP[8]
		vert WALL_TEXTURE_WRAP[9], WALL_TEXTURE_WRAP[10], WALL_TEXTURE_WRAP[11]
		vert WALL_TEXTURE_WRAP[12], WALL_TEXTURE_WRAP[13], WALL_TEXTURE_WRAP[14]
		coor{2} WALL_TEXTURE_WRAP[1], WALL_TEXTURE_WRAP[2], -1, -2, -3, -4
		body 1

		for iTrafo = 1 to numTrafo
			if (trafo_array[iTrafo][1] > 0) and (trafo_array[iTrafo][1] < 10) then
				del 1
			endif
		next iTrafo
	else
		!	only straight and trapeze walls
		if abs(WIDO_POSITION) > EPS then
			if SYMB_MIRRORED then
				base
				vert WIDO_POSITION, WALL_END_THICKNESS - WALL_START_THICKNESS, 0
				vert 0, 0, 0
				vert WIDO_POSITION, WALL_THICKNESS, 0
				vert WIDO_POSITION, WALL_END_THICKNESS - WALL_START_THICKNESS, 1
				coor 21, -1, -2, -3, -4
				body 1
			else
				base
				vert WIDO_POSITION, WALL_START_THICKNESS, 0
				vert WIDO_POSITION-1, WALL_START_THICKNESS - tan(incAngle), 0
				vert WIDO_POSITION, 0, 0
				vert WIDO_POSITION, WALL_START_THICKNESS, 1
				coor 21, -1, -2, -3, -4
				body 1
			endif
		endif
	endif
return

! ===== calculate the segmentation-correct position of a point =====
22:
	!	innerRadius > EPS and mirrorArcs < EPS assumed

	n = int(putAngle / (180 / WALL_RESOL))
	frag = fra(putAngle / (180 / WALL_RESOL)) * (180 / WALL_RESOL)

	if abs(putAngle - abs(WIDO_POSITION)) > EPS then
		if n % 2 < EPS then
			tanIncl = abs(WIDO_POSITION) - n * (180 / WALL_RESOL)
			put (innerRadius + putY) * (sin(tanIncl) - tan(frag) * cos(tanIncl)), putY - (innerRadius + putY) * (1 - cos(tanIncl) - tan(frag) * sin(tanIncl)), flags
		else
			tanIncl = abs(WIDO_POSITION) - (n + 1) * (180 / WALL_RESOL)
			frag = 180 / WALL_RESOL - frag
			put (innerRadius + putY) * (sin(tanIncl) + tan(frag) * cos(tanIncl)), putY - (innerRadius + putY) * (1 - cos(tanIncl) + tan(frag) * sin(tanIncl)), flags
		endif
	else
		put 0, putY, flags
	endif

return

! ===== calculate the segmentation-correct position of a point =====
23:
	!	innerRadius > EPS and mirrorArcs > EPS assumed

	n = int(putAngle / (180 / WALL_RESOL))
	frag = fra(putAngle / (180 / WALL_RESOL)) * (180 / WALL_RESOL)

	if n % 2 < EPS then
		tanIncl = n * (180 / WALL_RESOL)
		put (outerRadius - putY) * (sin(tanIncl) + tan(frag) * cos(tanIncl)), putY + (outerRadius - putY) * (1 - cos(tanIncl) + tan(frag) * sin(tanIncl)), flags
	else
		tanIncl = (n + 1) * (180 / WALL_RESOL)
		frag = 180 / WALL_RESOL - frag
		put (outerRadius - putY) * (sin(tanIncl) - tan(frag) * cos(tanIncl)), putY + (outerRadius - putY) * (1 - cos(tanIncl) - tan(frag) * sin(tanIncl)), flags
	endif

return
