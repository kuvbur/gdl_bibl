
! Contact person: <JT, TZs>

! ==============================================================================
! The macro returns some basic data about
!	the opening orientation and the wall geometry.
! ------------------------------------------------------------------------------
! Input parameters:
!	WOD:			distance of the wall-origin from the chord of the window panel
!	EPS:			tolerance
!
! Macro Version 9:
! Output: (on the GDL stack in the following order)
!	[1]:	multiplier for X axis to return to default direction (1 / -1)
!	[2]:	multiplier for Y axis to return to default direction (1 / -1)
!	[3]:	wall is curved (0 / 1)
!	[4]:	wall's reference line is on the left (0 / 1)
!	[5]:	rotation angle of the bottom left corner (angle in degrees)
!	[6]:	inner radius of the curved wall (length value)
!	[7]:	X offset of the bottom left corner (length value)
!	[8]:	Y offset of the bottom left corner (length value)
!	[ ... NSP]:	original stack elements
!
! Macro Version 10:
! Returned parameters:
!	mirrorX:		multiplier for X axis to return to default direction (1 / -1)
!	mirrorY:		multiplier for Y axis to return to default direction (1 / -1)
!	curvedWall:		wall is curved (0 / 1)
!	wallIsLeft:		wall's reference line is on the left (0 / 1)
!	angOrig:		rotation angle of the bottom left corner (angle in degrees)
!	innerRadius:	inner radius of the curved wall (length value)
!	ofsX:			X offset of the bottom left corner (length value)
!	ofsY:			Y offset of the bottom left corner (length value)
! ==============================================================================

! ===== basic wall geometry =====

bRotAngle180 = SYMB_ROTANGLE > EPS
wallIsLeft	= bRotAngle180 exor WIDO_REVEAL_SIDE
curvedWall	= WOD > EPS

! ===== compute tranformation for default orientation =====

if not(SYMB_MIRRORED) then
	if not(bRotAngle180) then
		if not(WIDO_REVEAL_SIDE) then
			if not(curvedWall) then
				mirrorX = 1
				mirrorY = -1
			else
				mirrorX = -1
				mirrorY = -1
			endif
		else
			if not(curvedWall) then
				mirrorX = 1
				mirrorY = 1
			else
				mirrorX = -1
				mirrorY = -1
			endif
		endif
	else
		if not(WIDO_REVEAL_SIDE) then
			if not(curvedWall) then
				mirrorX = -1
				mirrorY = -1
			else
				mirrorX = 1
				mirrorY = 1
			endif
		else
			if not(curvedWall) then
				mirrorX = -1
				mirrorY = 1
			else
				mirrorX = 1
				mirrorY = 1
			endif
		endif
	endif
else
	if not(bRotAngle180) then
		if not(WIDO_REVEAL_SIDE) then
			if not(curvedWall) then
				mirrorX = -1
				mirrorY = -1
			else
				mirrorX = 1
				mirrorY = -1
			endif
		else
			if not(curvedWall) then
				mirrorX = -1
				mirrorY = 1
			else
				mirrorX = 1
				mirrorY = -1
			endif
		endif
	else
		if not(WIDO_REVEAL_SIDE) then
			if not(curvedWall) then
				mirrorX = 1
				mirrorY = -1
			else
				mirrorX = -1
				mirrorY = 1
			endif
		else
			if not(curvedWall) then
				mirrorX = 1
				mirrorY = 1
			else
				mirrorX = -1
				mirrorY = 1
			endif
		endif
	endif
endif


! ===== compute origin tranformation =====

if not(curvedWall) then
	angOrig = 0
	innerRadius = 0
	ofsX = -A / 2
	ofsY = -WIDO_SILL - WIDO_REVEAL_SIDE * WIDO_FRAME_THICKNESS
else
	if WIDO_REVEAL_SIDE then
		if SYMB_ROTANGLE > EPS then
			angOrig = atn (A / 2 / (WOD - WIDO_FRAME_THICKNESS))
			innerRadius = sqr((WOD - WIDO_FRAME_THICKNESS) * (WOD - WIDO_FRAME_THICKNESS) + (A / 2) * (A / 2)) - WIDO_SILL
			dy = WIDO_FRAME_THICKNESS
		else
			angOrig = atn (A / 2 / WOD)
			innerRadius = sqr((WOD + WIDO_FRAME_THICKNESS) * (WOD + WIDO_FRAME_THICKNESS) + (A / 2) * (A / 2)) + WIDO_SILL - WALL_THICKNESS
			dy = -WIDO_FRAME_THICKNESS
		endif
	else
		if SYMB_ROTANGLE > EPS then
			angOrig = atn (A / 2 / (WOD - WIDO_FRAME_THICKNESS))
			innerRadius = sqr((WOD) * (WOD) + (A / 2) * (A / 2)) + WIDO_SILL - WALL_THICKNESS
			dy = 0
		else
			angOrig = atn (A / 2 / WOD)
			innerRadius = sqr(WOD * WOD + (A / 2) * (A / 2)) - WIDO_SILL
			dy = 0
		endif
	endif

	ofsX = -sin (angOrig) * innerRadius
	ofsY =  cos (angOrig) * innerRadius - WOD + dy
endif


if gs_macro_version = 9 then
	! === save the current parameter buffer
	dim savedQueueValues[]
	call "SaveQueue" parameters returned_parameters savedQueueValues

	put	mirrorX,
		mirrorY,
		curvedWall,
		wallIsLeft,
		angOrig,
		innerRadius,
		ofsX,
		ofsY

	! === restore the saved parameter buffer
	call "LoadQueue" parameters savedQueueValues = savedQueueValues
endif

if gs_macro_version >= 10 then
	end mirrorX,
		mirrorY,
		curvedWall,
		wallIsLeft,
		angOrig,
		innerRadius,
		ofsX,
		ofsY
endif


