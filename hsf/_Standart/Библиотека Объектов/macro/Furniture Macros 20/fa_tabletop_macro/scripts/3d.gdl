
if gs_detlevel_3D_m = 0 then end
if gs_detlevel_3D_m = 1 then		! Simple
	gs_tabletop_edge_style_m = 1	! Rectangular
endif

pen gs_cont_pen

resEdge		= max(int(gs_resol / 4), 4)
resCorner	= max(int(gs_resol / 1.5), 4)
resTable	= max(gs_resol, 8)

resEdge		= 4 * ceil(resEdge / 4)
resCorner	= 4 * ceil(resCorner / 4)
resTable	= 4 * ceil(resTable / 4)


! =========================================================================
! Middle hotspot
! =========================================================================
hotspot A/2, B/2, 0,	unID : unID = unID + 1


! =========================================================================
! Tabletop edge profile
! =========================================================================

if gs_tabletop_edge_style_m = 1 then	! Rectangular
	put 0,0,0,
		0,gs_table_thickness,0
	numEdgesNodes = 2
endif
if gs_tabletop_edge_style_m = 2 then	! Half-Rounded
	alpha = 0
	da = 360 / resEdge
	for i=1 to resEdge / 4 + 1
		put gs_table_thickness - gs_table_thickness * cos(alpha), gs_table_thickness * sin(alpha), 1
		alpha = alpha + da
	next i
	numEdgesNodes = resEdge / 4 + 1
endif
if gs_tabletop_edge_style_m = 3 then	! Rounded
	da = 360 / resEdge
	alpha = -90
	for i=1 to resEdge / 2 + 1
		put gs_table_thickness/2 - gs_table_thickness/2 * cos(alpha), gs_table_thickness/2 + gs_table_thickness/2 * sin(alpha), 1
		alpha = alpha + da
	next i
	numEdgesNodes = resEdge / 2 + 1
endif


! =========================================================================
! Tabletop contour
! =========================================================================

legOffsetBase = 0.065

if gs_tabletop_style_m = 1 then		! Rectangle
	put 0,0,0,
		A,0,0,
		A,B,0,
		0,B,0

	legOffsetLeftX	= legOffsetBase
	legOffsetRightX	= legOffsetBase
	legOffsetY		= legOffsetBase
endif

bHalfcircleA = (abs(gs_radius_1 - A/2) < EPS)
bHalfcircleB = (abs(gs_radius_1 - B/2) < EPS)

if gs_tabletop_style_m = 2 or gs_tabletop_style_m = 5 then		! Rounded Rectangle, Oval
	da = 360 / resCorner
	alpha = 180
	for i=1 to resCorner / 4 + not(bHalfcircleA)
		put gs_radius_1 + gs_radius_1 * cos(alpha), gs_radius_1 + gs_radius_1 * sin(alpha), 1
		alpha = alpha + da
	next i
	alpha = 270
	for i=1 to resCorner / 4 + not(bHalfcircleB)
		put A - gs_radius_1 + gs_radius_1 * cos(alpha), gs_radius_1 + gs_radius_1 * sin(alpha), 1
		alpha = alpha + da
	next i
	alpha = 0
	for i=1 to resCorner / 4 + not(bHalfcircleA)
		put A - gs_radius_1 + gs_radius_1 * cos(alpha), B - gs_radius_1 + gs_radius_1 * sin(alpha), 1
		alpha = alpha + da
	next i
	alpha = 90
	for i=1 to resCorner / 4 + not(bHalfcircleB)
		put gs_radius_1 + gs_radius_1 * cos(alpha), B - gs_radius_1 + gs_radius_1 * sin(alpha), 1
		alpha = alpha + da
	next i

	if gs_tabletop_style_m = 2 then
		legOffsetLeftX	= legOffsetBase + gs_radius_1/2
		legOffsetRightX	= legOffsetBase + gs_radius_1/2
		legOffsetY		= legOffsetBase + gs_radius_1/2
	else
		if abs(A - B) < EPS then
			legOffsetLeftX	= A/5
			legOffsetRightX	= A/5
			legOffsetY		= A/5
		else
			if A < B then
				legOffsetLeftX	= legOffsetBase
				legOffsetRightX	= legOffsetBase
				legOffsetY		= gs_radius_1
			else
				legOffsetLeftX	= gs_radius_1
				legOffsetRightX	= gs_radius_1
				legOffsetY		= legOffsetBase
			endif
		endif
	endif
endif

if gs_tabletop_style_m = 3 or gs_tabletop_style_m = 6 then		! Rounded Rectangle on One Side, Oval on One Side
	da = 360 / resCorner
	put 0,0,0
	alpha = 270
	for i=1 to resCorner / 4 + not(bHalfcircleB)
		put A - gs_radius_1 + gs_radius_1 * cos(alpha), gs_radius_1 + gs_radius_1 * sin(alpha), 1
		alpha = alpha + da
	next i
	alpha = 0
	for i=1 to resCorner / 4 + 1
		put A - gs_radius_1 + gs_radius_1 * cos(alpha), B - gs_radius_1 + gs_radius_1 * sin(alpha), 1
		alpha = alpha + da
	next i
	put 0,B,0

	if gs_tabletop_style_m = 3 then
		legOffsetLeftX	= legOffsetBase + gs_radius_1/2
		legOffsetRightX	= legOffsetBase + gs_radius_1/2
		legOffsetY		= legOffsetBase + gs_radius_1/2
	else
		legOffsetLeftX	= legOffsetBase
		legOffsetRightX	= gs_radius_1
		legOffsetY		= legOffsetBase
	endif
endif

if gs_tabletop_style_m = 4 or gs_tabletop_style_m = 9 then		! Ellipse, Round
	ratio = B/A
	da = 360 / resTable
	alpha = 0
	for i=1 to resTable
		put A/2 + A/2 * cos(alpha), B/2 + ratio * A/2 * sin(alpha), 1
		alpha = alpha + da
	next i

	legOffsetLeftX	= A/5
	legOffsetRightX	= A/5
	legOffsetY		= B/5
endif

if gs_tabletop_style_m = 7 or gs_tabletop_style_m = 8 then		! Curved Edge, Curved Edge on One Side

	beta = asn(B/2/gs_radius_2)
	da = 4*beta / resCorner

	if gs_tabletop_style_m = 7 then		! Curved Edge

		alpha = -beta
		for i=1 to resCorner / 2 + not(bMinRadius)
			put A - gs_radius_2 + gs_radius_2 * cos(alpha), B/2 + gs_radius_2 * sin(alpha), not(i=1 or i=resCorner / 2 + 1)
			alpha = alpha + da
		next i

		alpha = 180 - beta
		for i=1 to resCorner / 2 + not(bMinRadius)
			put gs_radius_2 + gs_radius_2 * cos(alpha), B/2 + gs_radius_2 * sin(alpha), not(i=1 or i=resCorner / 2 + 1)
			alpha = alpha + da
		next i
	endif

	if gs_tabletop_style_m = 8 then		! Curved Edge on One Side
		put 0,0,0
		alpha = -beta
		for i=1 to resCorner / 2 + 1
			put A - gs_radius_2 + gs_radius_2 * cos(alpha), B/2 + gs_radius_2 * sin(alpha), not(i=1 or i=resCorner / 2 + 1)
			alpha = alpha + da
		next i
		put 0,B,0
	endif

	if gs_tabletop_style_m = 7 then
		legOffsetLeftX	= gs_radius_2 - gs_radius_2 * cos(beta) + legOffsetBase/2
		legOffsetRightX	= gs_radius_2 - gs_radius_2 * cos(beta) + legOffsetBase/2
		legOffsetY		= legOffsetBase
	else
		legOffsetLeftX	= legOffsetBase
		legOffsetRightX	= gs_radius_2 - gs_radius_2 * cos(beta) + legOffsetBase/2
		legOffsetY		= legOffsetBase
	endif
endif

numPathNodes = nsp/3 - numEdgesNodes

! =========================================================================

addz -gs_table_thickness
gosub 100
del 1

! =========================================================================

end legOffsetLeftX, legOffsetRightX, legOffsetY, unID

! =========================================================================

100:

act = 0
actVERT = 0
actEDGE = 0
DIM ContInd[100][4] ! Contour Start Indices:
					!   [i][1] = VERT
					!   [i][2] = EDGE
					!   [i][3] = number of Basenodes
					!   [i][4] = number of Pathnodes

DIM basenode [20][3]  ! Max. Number of Basenodes = 20
DIM pathnode [100][3] ! Max. Number of Pathnodes = 100


BASE

!!!WHILE NSP DO
	act = act+1
	ContInd[act][1] = actVERT
	ContInd[act][2] = actEDGE
	GOSUB 200
!!!ENDWHILE


! Creating Top Surface

MATERIAL gs_top_mat

IF act>1 THEN
	status = 16 + 32 ! concave poligon + poligon with hole(s)
ELSE
	status = 16 ! concave poligon
ENDIF

FOR j=1 TO act
	IF j>1 THEN PUT 0
	FOR i=0 TO ContInd[j][4]-1 ! number of Pathnodes
		PUT (ContInd[j][2] + ContInd[j][3]*(i+1))
	NEXT i
NEXT j

PGON NSP,0,status, GET(NSP)


! Creating Bottom Surface

MATERIAL gs_top_mat

IF act>1 THEN
	status = 16 + 32 ! concave poligon + poligon with hole(s)
ELSE
	status = 16 ! concave poligon
ENDIF

FOR j=1 TO act
	IF j>1 THEN PUT 0
	FOR i=ContInd[j][4]-1 TO 0 STEP -1  ! number of Pathnodes
		PUT -(ContInd[j][2] + ContInd[j][3]*i + 1)
	NEXT i
NEXT j

PGON NSP,0,status, GET(NSP)


BODY -1

RETURN


200:
! Creating Contour

n = numEdgesNodes
m = numPathNodes

ContInd[act][3] = n
ContInd[act][4] = m


FOR i=1 TO n
	basenode [i][1]=GET (1)
	basenode [i][2]=GET (1)
	basenode [i][3]=GET (1)
NEXT i
FOR i=2 TO m+1
	pathnode [i][1]=GET (1)
	pathnode [i][2]=GET (1)
	pathnode [i][3]=GET (1)
NEXT i

IF pathnode [2][1]<>pathnode [m+1][1] OR pathnode [2][2]<>pathnode [m+1][2] THEN
! The polyline is open, so we close it
	m=m+1
	pathnode [m+1][1]=pathnode [2][1]
	pathnode [m+1][2]=pathnode [2][2]
	pathnode [m+1][3]=pathnode [2][3]
ENDIF
! Set the begining and the end normal vectors
pathnode [1][1]=pathnode [m][1]
pathnode [1][2]=pathnode [m][2]
pathnode [1][3]=pathnode [m][3]
pathnode [m+2][1]=pathnode [3][1]
pathnode [m+2][2]=pathnode [3][2]
pathnode [m+2][3]=pathnode [3][3]
m=m+1

! The begining vector [1]->[2]
dx=pathnode [2][1]-pathnode[1][1]
dy=pathnode [2][2]-pathnode[1][2]
GOSUB 10
fok=alfa
alfa_prev=alfa


! Creating Vertices

FOR i=2 TO m-1
	dx=pathnode [i+1][1]-pathnode [i][1]
	dy=pathnode [i+1][2]-pathnode [i][2]
	GOSUB 10

	beta=alfa_prev-alfa-180
	IF beta<0 THEN beta=beta+360
	IF beta>360 THEN beta=beta-360
	fok=alfa+beta/2
	lenghting=1/SIN(beta/2)

	alfa_prev=alfa

	FOR j=1 TO n
		x1=basenode [j][1]
		y1=basenode [j][2]
		VERT lenghting*x1*cos(fok)+pathnode [i][1],
			lenghting*x1*sin(fok)+pathnode [i][2],
			y1
		actVERT = actVERT+1
	NEXT j
NEXT i

! Creating Edges

firstHEdge = actEDGE

! Horizontal lines
FOR i=0 TO m-3
	FOR j=1 TO n

		IF basenode [j][3] THEN
			IF j=1 OR j=n THEN
				status=0    ! Visible Edge
			ELSE
				status=2        ! Edge of a Curved Surface
			ENDIF
		ELSE
			status=0            ! Visible Edge
		ENDIF

		IF i=m-3 THEN
			EDGE ContInd[act][1] + i*n+j, ContInd[act][1] + j, -1,-1,status
		ELSE
			EDGE ContInd[act][1] + i*n+j, ContInd[act][1] + (i+1)*n+j, -1,-1,status
		ENDIF
		actEDGE = actEDGE+1

	NEXT j
NEXT i

firstVEdge = actEDGE

! Vertical lines
FOR i=0 TO m-3
	status=0
	FOR j=1 TO n-1
		IF basenode [j][2] = basenode [j+1][2] THEN
			status=1
		ELSE
			IF pathnode [i+2][3] THEN
				status=2
			ELSE
				status=0
			ENDIF
		ENDIF

		EDGE ContInd[act][1] + i*n+j, ContInd[act][1] + i*n+j+1, -1,-1,status

		actEDGE = actEDGE+1
	NEXt j
NEXT i


! Creating Side Poligons

MATERIAL gs_top_edge_mat
FOR i=0 TO m-3
	FOR j=1 TO n-1
		status=0

		IF basenode [j][3] OR basenode [j+1][3] THEN
			status=2        ! Poligon of a Curved Surface
		ENDIF

		IF ABS (basenode [j][2] - basenode [j+1][2]) > EPS AND (pathnode [i+2][3] OR pathnode [i+3][3]) THEN
			status=2
		ENDIF

		IF i=m-3 THEN
			PGON 4,0,status,
				-(firstVEdge + i*(n-1) + j),
				firstHEdge + i*n + j,
				firstVEdge + j,
				-(firstHEdge + i*n + j+1)
		ELSE
			PGON 4,0,status,
				-(firstVEdge + i*(n-1) + j),
				firstHEdge + i*n + j,
				firstVEdge + (i+1)*(n-1) + j,
				-(firstHEdge + i*n + j+1)
		ENDIF
	NEXT j
NEXT i

RETURN


10:
! Direction Angle

IF ABS (dx) < EPS THEN
	IF dy > 0 THEN
		alfa = 90
		RETURN
	ELSE
		alfa = 270
		RETURN
	ENDIF
ENDIF
IF ABS (dy) < EPS THEN
	IF dx > 0 THEN
		alfa = 0
		RETURN
	ELSE
		alfa = 180
		RETURN
	ENDIF
ENDIF
alfa = ATN (dy / dx)
IF dx > 0 AND dy > 0 THEN RETURN
IF dx > 0 AND dy < 0 THEN
	alfa = 360 + alfa
	RETURN
ENDIF
IF dx < 0 AND dy > 0 THEN
	alfa = 180 + alfa
	RETURN
ENDIF
IF dx < 0 AND dy < 0 THEN
	alfa = 180 + alfa
	RETURN
ENDIF

RETURN
