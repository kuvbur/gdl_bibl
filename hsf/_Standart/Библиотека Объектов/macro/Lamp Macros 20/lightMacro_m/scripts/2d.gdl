
pen gs_cont_pen

unID = 1

if iSymbolRotationType = ROTTYPE_ROTATIONANGLE and not(bWindowLight) then hotspot2 0, 0, unID				: unID = unID + 1

bShowTargetLine 		= 0
bShowCrossHairSymbol	= 0
bShowArrowSymbol		= 0
bShowFalloffSymbol		= 0
if gs_symbtype_2D_m = SYMBOL_REALISTIC then
	if iLightGroupType = LIGHTGROUP_GENERAL_LIGHT then
		bShowTargetLine 		= NOT(bTargetLineIsVertical)
		bShowCrossHairSymbol	= 1
		bShowArrowSymbol		= NOT(bTargetLineIsVertical)
		bShowFalloffSymbol		= _bDetShowFalloff and _bShowIllumination2D and NOT(c4dGenNoIllumination) and NOT(c4dPhoPhotometric)
	else
		bShowFalloffSymbol		= 0
	endif

	if iC4dGenType = GENTYPE_INFINITE then	gosub "infinite light geometry"
	if iC4dGenType = GENTYPE_AREA then		gosub "area light geometry"
	if iC4dGenType = GENTYPE_OMNI then		gosub "omni light geometry"
	if iC4dGenType = GENTYPE_SPOT then		gosub "spot light geometry"
	if iC4dGenType = GENTYPE_IES then		gosub "ies light geometry"
endif


_symbolSizeA = 0
_symbolSizeB = 0
if (iC4dGenType = GENTYPE_AREA and NOT(bWindowLight)) | iC4dGenType = GENTYPE_IES then
	if gs_symbtype_2D_m = SYMBOL_REALISTIC then
		_symbolSizeA = c4dDetAreaX
		_symbolSizeB = c4dDetAreaY
	else
		_symbolSizeA = symbolSizeA
		_symbolSizeB = symbolSizeB
	endif
endif

add2 lightPosX * (iC4dGenType = GENTYPE_INFINITE and bSunObject), lightPosY * (iC4dGenType = GENTYPE_INFINITE and bSunObject)
	call "Lamp_symbol" parameters all	iEnableLampSymbolTypes	= iEnableLampSymbolTypes,
										a						= _symbolSizeA,
										b						= _symbolSizeB,
										gs_symbtype_2D_m		= gs_symbtype_2D_m,
										iSpecSymbolType			= _specialSymbolType,
										rz						= 0,
										Symbol_unID				= 100
del 1

!================================================================================
end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
!================================================================================



"omni light geometry":

	! ======================================================================
	! Omni Light Geometry
	! ======================================================================

	if bShowCrossHairSymbol then	gosub "crossHair symbol"
	if bShowFalloffSymbol then		gosub "falloff distance editing"
	if bShowTargetLine then			gosub "target line"
	if bShowArrowSymbol then		gosub "arrow symbol"

return


"spot light geometry":

	! ======================================================================
	! Spot Light Geometry
	! ======================================================================

	if _bShowIllumination2D and NOT(c4dGenNoIllumination) then project2{3} 2, 270, 2, 15 parameters bShowLightSymbolIn2D = 1

	gosub "light position editing"
	gosub "target position editing"

	add2 lightPosX, lightPosY
		if bShowCrossHairSymbol then	gosub "crossHair symbol"
	del 1

	if bShowTargetLine then				gosub "target line"
	if bShowArrowSymbol then			gosub "arrow symbol"

	if bShowFalloffSymbol and NOT(bTargetLineIsVertical) then
		add2 lightPosX, lightPosY
			rot2 180 + targetAngle2D
				hotspot2 0,						0,	unID, falloffDist2DTempSpot,	1 + 128,	c4dDetRadius	: unID = unID + 1
				hotspot2 -1,					0,	unID, falloffDist2DTempSpot,	3,			c4dDetRadius	: unID = unID + 1
				hotspot2 falloffDist2DTempSpot,	0,	unID, falloffDist2DTempSpot,	2,			c4dDetRadius	: unID = unID + 1
			del 1
		del 1
	endif

	if _bShowIllumination2D and bTargetLineIsVertical then
		add2 lightPosX, lightPosY
			for ii = 1 to 1 + (1 + 2 * (iLightForm = LIGHTFORM_CIRCLE)) * (bFullEditing)
				hotspot2 0,	0,					unID, outerConeRadius,	1 + 128,	c4dDetOuterAngle	: unID = unID + 1
				hotspot2 -1,	0,				unID, outerConeRadius,	3,			c4dDetOuterAngle	: unID = unID + 1
				hotspot2 outerConeRadius,	0,	unID, outerConeRadius,	2,			c4dDetOuterAngle	: unID = unID + 1

				hotspot2 0,	0,					unID, innerConeRadius,	1 + 128,	c4dDetInnerAngle	: unID = unID + 1
				hotspot2 -1,	0,				unID, innerConeRadius,	3,			c4dDetInnerAngle	: unID = unID + 1
				hotspot2 innerConeRadius,	0,	unID, innerConeRadius,	2,			c4dDetInnerAngle	: unID = unID + 1

				rot2 90 + 90 * (iLightForm = LIGHTFORM_ELLIPSE)
			next ii
			del 1 + (1 + 2 * (iLightForm = LIGHTFORM_CIRCLE)) * (bFullEditing)
		del 1
	endif

return


"area light geometry":

	! ======================================================================
	! Area Light Geometry
	! ======================================================================

	if not(bWindowLight) then
		hotspot2	0,	0,	unID		: unID = unID + 1
	else
		hotspot2	c4dDetAreaX / 2,	sizeAreaY2DTemp / 2 * bShapeIsReversedIn2D - sizeAreaY2DTemp / 2 * NOT(bShapeIsReversedIn2D),	unID		: unID = unID + 1
	endif

	project2{3} 2, 270, 2, 15 parameters bShowLightSymbolIn2D = 1

	gosub "light position editing"
	gosub "target position editing"

	if bWindowLight then add2 c4dDetAreaX / 2, sizeAreaY2DTemp / 2 * bShapeIsReversedIn2D - sizeAreaY2DTemp / 2 * NOT(bShapeIsReversedIn2D)

	add2 lightPosX, lightPosY
		if bShowCrossHairSymbol then	gosub "crossHair symbol"
	del 1

	if bShowTargetLine then				gosub "target line"
	if bShowArrowSymbol then			gosub "arrow symbol"

	if bWindowLight then del 1

	! ======================================================================
	! Area shapes hotspot editing
	! ======================================================================

	if bWindowLight then
		hotspot2	0,	0,					unID, c4dDetAreaX,	1 + 256					: unID = unID + 1
		hotspot2	-1,	0,					unID, c4dDetAreaX, 	3						: unID = unID + 1
		hotspot2	c4dDetAreaX,	0,		unID, c4dDetAreaX, 	2						: unID = unID + 1

		hotspot2	0,	sizeAreaY2DTemp * (bShapeIsReversedIn2D) - sizeAreaY2DTemp * NOT(bShapeIsReversedIn2D),
			unID,	c4dDetAreaX,			1 + 256	: unID = unID + 1
		hotspot2	-1,	sizeAreaY2DTemp * (bShapeIsReversedIn2D) - sizeAreaY2DTemp * NOT(bShapeIsReversedIn2D),
			unID,	c4dDetAreaX, 			3		: unID = unID + 1
		hotspot2	c4dDetAreaX,	sizeAreaY2DTemp * (bShapeIsReversedIn2D) - sizeAreaY2DTemp * NOT(bShapeIsReversedIn2D),
			unID,	c4dDetAreaX, 			2		: unID = unID + 1

		if ABS(rotAngleX) > EPS then
			hotspot2	0,	0,
				unID,	sizeAreaY2DTemp,	1 + 256,	c4dDetAreaY		: unID = unID + 1
			hotspot2	0,	NOT(bShapeIsReversedIn2D) - (bShapeIsReversedIn2D),
				unID,	sizeAreaY2DTemp, 	3,			c4dDetAreaY		: unID = unID + 1
			hotspot2	0,	sizeAreaY2DTemp * (bShapeIsReversedIn2D) - sizeAreaY2DTemp * NOT(bShapeIsReversedIn2D),
				unID,	sizeAreaY2DTemp, 	2,			c4dDetAreaY		: unID = unID + 1

			hotspot2	c4dDetAreaX,	0,
				unID,	sizeAreaY2DTemp,	1 + 256,	c4dDetAreaY	: unID = unID + 1
			hotspot2	c4dDetAreaX,	NOT(bShapeIsReversedIn2D) - (bShapeIsReversedIn2D),
				unID,	sizeAreaY2DTemp, 	3,			c4dDetAreaY	: unID = unID + 1
			hotspot2	c4dDetAreaX,	sizeAreaY2DTemp * (bShapeIsReversedIn2D) - sizeAreaY2DTemp * NOT(bShapeIsReversedIn2D),
				unID,	sizeAreaY2DTemp, 	2,			c4dDetAreaY	: unID = unID + 1
		endif
	else
		_sizeX	= sizeAreaXHalf
		_sizeY	= sizeAreaYHalf

		diagLength	= SQR(_sizeX**2 + (_sizeY)**2)
		diagAngle	= ASN(_sizeY / diagLength)

		dim areaShape2DPoints[9][2]
		for i = 1 to 9
			areaShape2DPoints[i][1] = 0
			areaShape2DPoints[i][2] = 0
		next i

		if iC4dDetAreaShape = AREASHAPE_RECT		then
			_sizeZ	= 0
			put 1, 3, 7, 9
			gosub "area2DPoints"
		endif
		if iC4dDetAreaShape = AREASHAPE_DISC		then
			_sizeZ	= 0
			put 2, 4, 6, 8
			gosub "area2DPoints"
		endif
		if iC4dDetAreaShape = AREASHAPE_SPHERE		then
			_sizeZ	= sizeAreaZHalf
			put 5
			gosub "area2DPoints"

			_sizeZ	= 0
			put 2, 4, 6, 8
			gosub "area2DPoints"

			_sizeZ	= -sizeAreaZHalf
			put 5
			gosub "area2DPoints"
		endif
		if iC4dDetAreaShape = AREASHAPE_HEMISPHERE		then
			_sizeZ	= sizeAreaZHalf
			put 5
			gosub "area2DPoints"

			_sizeZ	= 0
			put 4, 6, 8
			gosub "area2DPoints"

			_sizeZ	= -sizeAreaZHalf
			put 5
			gosub "area2DPoints"
		endif
		if iC4dDetAreaShape = AREASHAPE_CUBE		then
			_sizeZ	= sizeAreaZHalf
			put 1, 3, 5, 7, 9
			gosub "area2DPoints"

			_sizeZ	= -sizeAreaZHalf
			put 1, 3, 5, 7, 9
			gosub "area2DPoints"
		endif
		if iC4dDetAreaShape = AREASHAPE_CYLIND		then
			_sizeZ	= sizeAreaZHalf
			put 2, 4, 5, 6, 8
			gosub "area2DPoints"

			_sizeZ	= -sizeAreaZHalf
			put 2, 4, 5, 6, 8
			gosub "area2DPoints"
		endif
		if iC4dDetAreaShape = AREASHAPE_PCYLIND		then
			_sizeZ	= sizeAreaZHalf
			put 4, 5, 6
			gosub "area2DPoints"

			_sizeZ	= 0
			put 1, 3, 4, 6, 7, 9
			gosub "area2DPoints"

			_sizeZ	= -sizeAreaZHalf
			put 4, 5, 6
			gosub "area2DPoints"
		endif
		if iC4dDetAreaShape = AREASHAPE_LINE		then
			_sizeZ	= sizeAreaXHalf
			put 5
			gosub "area2DPoints"

			_sizeZ	= -sizeAreaXHalf
			put 5
			gosub "area2DPoints"
		endif
	endif

return


"area2DPoints":

	if bTargetLineIsVertical then _sizeZ = 0

	areaShape2DPoints[1][1] = -diagLength * COS(diagAngle + rotAngleZ) * COS(coneRotY) + _sizeZ * SIN(coneRotY)
	areaShape2DPoints[1][2] = -diagLength * SIN(diagAngle + rotAngleZ)

	areaShape2DPoints[2][1] = -_sizeY * COS(90 + rotAngleZ) * COS(coneRotY) + _sizeZ * SIN(coneRotY)
	areaShape2DPoints[2][2] = -_sizeY * SIN(90 - rotAngleZ)

	areaShape2DPoints[3][1] = diagLength * COS(diagAngle - rotAngleZ) * COS(coneRotY) + _sizeZ * SIN(coneRotY)
	areaShape2DPoints[3][2] = -diagLength * SIN(diagAngle - rotAngleZ)

	areaShape2DPoints[4][1] = -_sizeX * COS(180 - rotAngleZ) * COS(coneRotY) + _sizeZ * SIN(coneRotY)
	areaShape2DPoints[4][2] = _sizeX * SIN(180 - rotAngleZ)

	areaShape2DPoints[5][1] = _sizeZ * SIN(coneRotY)
	areaShape2DPoints[5][2] = 0

	areaShape2DPoints[6][1] = _sizeX * COS(180 - rotAngleZ) * COS(coneRotY) + _sizeZ * SIN(coneRotY)
	areaShape2DPoints[6][2] = -_sizeX * SIN(180 - rotAngleZ)

	areaShape2DPoints[7][1] = -diagLength * COS(diagAngle - rotAngleZ) * COS(coneRotY) + _sizeZ * SIN(coneRotY)
	areaShape2DPoints[7][2] = diagLength * SIN(diagAngle - rotAngleZ)

	areaShape2DPoints[8][1] = _sizeY * COS(90 + rotAngleZ) * COS(coneRotY) + _sizeZ * SIN(coneRotY)
	areaShape2DPoints[8][2] = _sizeY * SIN(90 - rotAngleZ)

	areaShape2DPoints[9][1] = diagLength * COS(diagAngle + rotAngleZ) * COS(coneRotY) + _sizeZ * SIN(coneRotY)
	areaShape2DPoints[9][2] = diagLength * SIN(diagAngle + rotAngleZ)

	rot2 coneRotZ
	add2 lightPosX, lightPosY
	for i = 1 to nsp
		iAreaPointIdx	= get(1)

		if (bTargetLineIsVertical | bTargetLineIsHorizontal) and ABS(rotAngleZ) < EPS then
			if bTargetLineIsVertical then
				if	iAreaPointIdx = 4 | iAreaPointIdx = 6 |\
					((iAreaPointIdx = 1 | iAreaPointIdx = 3 | iAreaPointIdx = 7 | iAreaPointIdx = 9) and iC4dDetAreaShape <> AREASHAPE_PCYLIND) then
					hotspot2	0,	areaShape2DPoints[iAreaPointIdx][2],
						unID,	sizeAreaXHalf,			1 + 128,	c4dDetAreaX	: unID = unID + 1
					hotspot2	-areaShape2DPoints[iAreaPointIdx][1],	areaShape2DPoints[iAreaPointIdx][2],
						unID,	sizeAreaXHalf, 			3,			c4dDetAreaX	: unID = unID + 1
					hotspot2	areaShape2DPoints[iAreaPointIdx][1],	areaShape2DPoints[iAreaPointIdx][2],
						unID,	sizeAreaXHalf, 			2,			c4dDetAreaX	: unID = unID + 1
				endif
				if	iAreaPointIdx = 1 | iAreaPointIdx = 7 |\
					iAreaPointIdx = 2 | iAreaPointIdx = 8 |\
					iAreaPointIdx = 3 | iAreaPointIdx = 9 then
					if iC4dDetAreaShape = AREASHAPE_HEMISPHERE then
						hotspot2	areaShape2DPoints[iAreaPointIdx][1],	0,
							unID,	sizeAreaYHalf,			1 + 128,	sizeAreaYHalf	: unID = unID + 1
						hotspot2	areaShape2DPoints[iAreaPointIdx][1],	-areaShape2DPoints[iAreaPointIdx][2],
							unID,	sizeAreaYHalf, 			3,			sizeAreaYHalf	: unID = unID + 1
						hotspot2	areaShape2DPoints[iAreaPointIdx][1],	areaShape2DPoints[iAreaPointIdx][2],
							unID,	sizeAreaYHalf, 			2,			sizeAreaYHalf	: unID = unID + 1
					else
						hotspot2	areaShape2DPoints[iAreaPointIdx][1],	0,
							unID,	sizeAreaYHalf,			1 + 128,	c4dDetAreaY	: unID = unID + 1
						hotspot2	areaShape2DPoints[iAreaPointIdx][1],	-areaShape2DPoints[iAreaPointIdx][2],
							unID,	sizeAreaYHalf, 			3,			c4dDetAreaY	: unID = unID + 1
						hotspot2	areaShape2DPoints[iAreaPointIdx][1],	areaShape2DPoints[iAreaPointIdx][2],
							unID,	sizeAreaYHalf, 			2,			c4dDetAreaY	: unID = unID + 1
					endif
				endif
			else
				if	iAreaPointIdx = 1 | iAreaPointIdx = 7 |\
					iAreaPointIdx = 2 | iAreaPointIdx = 8 |\
					iAreaPointIdx = 3 | iAreaPointIdx = 9 then
					if iC4dDetAreaShape = AREASHAPE_HEMISPHERE then
						hotspot2	areaShape2DPoints[iAreaPointIdx][1],	0,
							unID,	sizeAreaYHalf,			1 + 128,	sizeAreaYHalf	: unID = unID + 1
						hotspot2	areaShape2DPoints[iAreaPointIdx][1],	-areaShape2DPoints[iAreaPointIdx][2],
							unID,	sizeAreaYHalf, 			3,			sizeAreaYHalf	: unID = unID + 1
						hotspot2	areaShape2DPoints[iAreaPointIdx][1],	areaShape2DPoints[iAreaPointIdx][2],
							unID,	sizeAreaYHalf, 			2,			sizeAreaYHalf	: unID = unID + 1
					else
						hotspot2	areaShape2DPoints[iAreaPointIdx][1],	0,
							unID,	sizeAreaYHalf,			1 + 128,	c4dDetAreaY	: unID = unID + 1
						hotspot2	areaShape2DPoints[iAreaPointIdx][1],	-areaShape2DPoints[iAreaPointIdx][2],
							unID,	sizeAreaYHalf, 			3,			c4dDetAreaY	: unID = unID + 1
						hotspot2	areaShape2DPoints[iAreaPointIdx][1],	areaShape2DPoints[iAreaPointIdx][2],
							unID,	sizeAreaYHalf, 			2,			c4dDetAreaY	: unID = unID + 1
					endif
				endif
				if	iAreaPointIdx = 5 then
					if iC4dDetAreaShape = AREASHAPE_LINE then
						hotspot2	0,	areaShape2DPoints[iAreaPointIdx][2],
							unID,	sizeAreaXHalf,			1 + 128,	c4dDetAreaX	: unID = unID + 1
						hotspot2	-_sizeZ,	areaShape2DPoints[iAreaPointIdx][2],
							unID,	sizeAreaXHalf, 			3,			c4dDetAreaX	: unID = unID + 1
						hotspot2	_sizeZ,	areaShape2DPoints[iAreaPointIdx][2],
							unID,	sizeAreaXHalf, 			2,			c4dDetAreaX	: unID = unID + 1
					else
						hotspot2	0,	areaShape2DPoints[iAreaPointIdx][2],
							unID,	sizeAreaZHalf,			1 + 128,	c4dDetAreaZ	: unID = unID + 1
						hotspot2	-_sizeZ,	areaShape2DPoints[iAreaPointIdx][2],
							unID,	sizeAreaZHalf, 			3,			c4dDetAreaZ	: unID = unID + 1
						hotspot2	_sizeZ,	areaShape2DPoints[iAreaPointIdx][2],
							unID,	sizeAreaZHalf, 			2,			c4dDetAreaZ	: unID = unID + 1
					endif
				endif
			endif
		else
			hotspot2 areaShape2DPoints[iAreaPointIdx][1], areaShape2DPoints[iAreaPointIdx][2], unID			: unID = unID + 1
		endif

	next i
	del 2

return


"infinite light geometry":

	! ======================================================================
	! Infinite Light Geometry
	! ======================================================================

	if NOT(c4dGenNoIllumination) then
		if bSunObject then
			add2 lightPosX, lightPosY
				circle2 0, 0, sunRadius

				for ii = 1 to 12
					line2	sunRadius + sunBeamOffset, 0,
							sunRadius + sunBeamOffset + sunBeamLength, 0

					rot2 15
						line2	sunRadius + sunBeamOffset, 0,
								sunRadius + sunBeamOffset + sunBeamLength / 2, 0
					del 1

					rot2 30
				next ii
				del 12
			del 1
		else
			project2{3} 2, 270, 2, 15 parameters bShowLightSymbolIn2D = 1
		endif
	endif

	gosub "light position editing"
	gosub "target position editing"

	add2 lightPosX, lightPosY
		if bShowCrossHairSymbol then	gosub "crossHair symbol"
	del 1

	if bShowTargetLine then			gosub "target line"
	if bShowArrowSymbol then		gosub "arrow symbol"

return


"ies light geometry":

	! ======================================================================
	! IES Light Geometry
	! ======================================================================

	if bShowCrossHairSymbol then	gosub "crossHair symbol"
	if bShowFalloffSymbol then		gosub "falloff distance editing"
	if bShowTargetLine then			gosub "target line"
	if bShowArrowSymbol then		gosub "arrow symbol"

return


"light position editing":

	! ======================================================================
	! Light Position Editing
	! ======================================================================

	if bEnableLightHotspotEditing then
		hotspot2	0,			lightPosY,	unID, lightPosX,	1 + 128	: unID = unID + 1
		hotspot2	-1,			lightPosY,	unID, lightPosX, 	3		: unID = unID + 1
		hotspot2	lightPosX,	lightPosY,	unID, lightPosX, 	2		: unID = unID + 1

		hotspot2	lightPosX,	0,			unID, lightPosY,	1 + 128	: unID = unID + 1
		hotspot2	lightPosX,	-1,			unID, lightPosY, 	3		: unID = unID + 1
		hotspot2	lightPosX,	lightPosY,	unID, lightPosY, 	2		: unID = unID + 1
	else
		hotspot2	lightPosX,	lightPosY,	unID						: unID = unID + 1
	endif

return


"target position editing":

	! ======================================================================
	! Target Position Editing
	! ======================================================================

	if bEnableTargetHotspotEditing then
		hotspot2	0,			targetPosY,	unID, targetPosX,	1 + 128	: unID = unID + 1
		hotspot2	-1,			targetPosY,	unID, targetPosX, 	3		: unID = unID + 1
		hotspot2	targetPosX,	targetPosY,	unID, targetPosX, 	2		: unID = unID + 1

		hotspot2	targetPosX,	0,			unID, targetPosY,	1 + 128	: unID = unID + 1
		hotspot2	targetPosX,	-1,			unID, targetPosY, 	3		: unID = unID + 1
		hotspot2	targetPosX,	targetPosY,	unID, targetPosY, 	2		: unID = unID + 1
	else
		hotspot2	targetPosX,	targetPosY,	unID						: unID = unID + 1
	endif

return


"target line":

	! ======================================================================
	! Target Line
	! ======================================================================

	pen penTargetLine

	if iSymbolRotationType = ROTTYPE_TARGETPOSITION then
		line2 lightPosX + targetLineExtensionLength * COS(targetAngle2D), lightPosY + targetLineExtensionLength * SIN(targetAngle2D), targetPosX, targetPosY
	else
		line2 0, 0, 0, targetLineLength2D
		hotspot2	0,	targetLineLength2D,	unID		: unID = unID + 1
	endif

return


"dashed 2D arc":

	! ======================================================================
	! Dashed 2D Arc
	! ======================================================================

	if GLOB_CONTEXT > 20 and GLOB_CONTEXT < 40 then iLineType = LINETYPE_SIMPLE

	if iLineType = LINETYPE_DASHED and (fullArcLength + dashedLineLength * (ABS(fullArcAngle - 360) < eps)) > (dashedLineLength + tempSpaceLength) * 2 then
		dashedLineNum		= INT((fullArcLength + dashedLineLength * (ABS(fullArcAngle - 360) < eps)) / (dashedLineLength + tempSpaceLength))
		spaceLength			= (fullArcLength + dashedLineLength * (ABS(fullArcAngle - 360) < eps) - dashedLineNum * dashedLineLength) / (dashedLineNum - 1)
		dashedLineAngle		= dashedLineLength * fullArcAngle / fullArcLength
		spaceAngle			= spaceLength * fullArcAngle / fullArcLength

		for li = 1 to dashedLineNum
			arc2 0, 0, circleRadius, 0, dashedLineAngle

			rot2 dashedLineAngle + spaceAngle
		next li
		del dashedLineNum
	else
		circle2 0, 0, circleRadius
	endif

return

"crossHair symbol":

	! ======================================================================
	! Crosshair Symbol
	! ======================================================================

	pen penCrossHair

	line2 -crossHairLineLengthHor / 2, 0, crossHairLineLengthHor / 2, 0
	line2 0, -crossHairLineLengthVer / 2, 0, crossHairLineLengthVer / 2

	rot2 45
	for ii = 1 to 2
		line2 -crossHairLineLengthDia / 2, 0, crossHairLineLengthDia / 2, 0

		rot2 90
	next ii
	del 2 + 1

return


"arrow symbol":

	! ======================================================================
	! Arrow Symbol
	! ======================================================================

	if iSymbolRotationType = ROTTYPE_TARGETPOSITION then
		add2 targetPosX, targetPosY
	else
		add2 0, targetLineLength2D
	endif

	rot2 targetAngle2D
		for ii = 1 to 2
			line2 0, 0, arrowLineLength * SIN(arrowAngle), arrowLineLength * COS(arrowAngle)

			mul2 1, -1
		next ii
		del 2
	del 2

return


"falloff distance editing":

	! ======================================================================
	! Falloff Distance Editing
	! ======================================================================

	penSphere		= penIllumination
	pen penSphere

	circleRadius	= c4dDetRadius
	fullArcAngle	= 360
	fullArcLength	= circleRadius * 2 * pi / 360 * fullArcAngle
	iLineType		= LINETYPE_DASHED

	gosub "dashed 2D arc"

	for ii = 1 to 1 + 3 * (bFullEditing)
		hotspot2 0,	0,				unID, c4dDetRadius,		1 + 128		: unID = unID + 1
		hotspot2 -1,	0,			unID, c4dDetRadius, 	3			: unID = unID + 1
		hotspot2 c4dDetRadius,	0,	unID, c4dDetRadius, 	2			: unID = unID + 1

		rot2 90
	next ii
	del 1 + 3 * (bFullEditing)

return

