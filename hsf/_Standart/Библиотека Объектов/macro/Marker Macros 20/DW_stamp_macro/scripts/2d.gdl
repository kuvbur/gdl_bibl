
unID = 1

nTrans = 0
! -------------------------------------------------------------------------------
! Detail level setting
! -------------------------------------------------------------------------------
bDetailed	= 0
if iDetLevel = DETLEV_DETAILED | (iDetLevel = DETLEV_SCALESENS & GLOB_SCALE < 51) then bDetailed = 1

if bDetailed then
	bShowID				= bShowID_detailed
	bShowWallholeDim	= bShowWallholeDim_detailed
	bShowUnitDim		= bShowUnitDim_detailed
	bShowFire			= bShowFire_detailed
	bShowAcoustic		= bShowAcoustic_detailed
	bShowUValue			= bShowUValue_detailed
	bShowMaterial		= bShowMaterial_detailed
	bShowHardware		= bShowHardware_detailed
	bShowAdditionalTags	= bShowAdditionalTags_detailed
	
	if bWindow then
		bShowEgressDim	= 0
		bShowRevealDim	= bShowRevealDim_detailed
		bShowSill		= bShowSill_detailed
		bShowCust1		= bShowCust1_detailed
		bShowCust2		= bShowCust2_detailed
		bShowThreshold	= 0
		bShowHandle		= 0
		bShowCust		= 0
	else
		bShowEgressDim	= bShowEgressDim_detailed
		bShowRevealDim	= 0
		bShowSill		= 0
		bShowCust1		= 0
		bShowCust2		= 0
		bShowThreshold	= bShowThreshold_detailed
		bShowHandle		= bShowHandle_detailed
		bShowCust		= bShowCust_detailed
	endif
else
	bShowID				= bShowID_simple
	bShowWallholeDim	= bShowWallholeDim_simple
	bShowUnitDim		= bShowUnitDim_simple
	bShowFire			= bShowFire_simple
	bShowAcoustic		= bShowAcoustic_simple
	bShowUValue			= bShowUValue_simple
	bShowMaterial		= bShowMaterial_simple
	bShowHardware		= bShowHardware_simple
	bShowAdditionalTags	= bShowAdditionalTags_simple

	if bWindow then
		bShowEgressDim	= 0
		bShowRevealDim	= bShowRevealDim_simple
		bShowSill		= bShowSill_simple
		bShowCust1		= bShowCust1_simple
		bShowCust2		= bShowCust2_simple
		bShowThreshold	= 0
		bShowHandle		= 0
		bShowCust		= 0
	else
		bShowEgressDim	= bShowEgressDim_simple
		bShowRevealDim	= 0
		bShowSill		= 0
		bShowCust1		= 0
		bShowCust2		= 0
		bShowThreshold	= bShowThreshold_simple
		bShowHandle		= bShowHandle_simple
		bShowCust		= bShowCust_simple
	endif
endif


! -------------------------------------------------------------------------------
! Get value strings
! -------------------------------------------------------------------------------

if iWorkUnitLinear = DIMUNIT_PROJECT then
	widthHeightForm = ""
	rrr = request("Window_Door_Dimension", "", whForm)
	if rrr then widthHeightForm = whForm
else
	if iWorkUnitLinear = DIMUNIT_MM 	then widthHeightForm = "%~0." + str(iWorkUnitLinearDecimal,1,0) + "mm"		!mm
	if iWorkUnitLinear = DIMUNIT_CM 	then widthHeightForm = "%~0." + str(iWorkUnitLinearDecimal,1,0) + "cm"		!cm
	if iWorkUnitLinear = DIMUNIT_DM | iWorkUnitLinear = DIMUNIT_METER	then
		widthHeightForm = "%~0." + str(iWorkUnitLinearDecimal,1,0) + "m"		!m
	endif
	if iWorkUnitLinear = DIMUNIT_INCH 	then widthHeightForm = "%0.64fi"
endif

if iWorkUnitSillHgt = DIMUNIT_PROJECT then
	sillHeightForm = ""
	rrr = request("Sill_height_dimension", "", sillForm)
	if rrr then sillHeightForm = sillForm
else
	if iWorkUnitSillHgt = DIMUNIT_MM 	then sillHeightForm = "%~0." + str(iWorkUnitSillHgtDecimal,1,0) + "mm"		!mm
	if iWorkUnitSillHgt = DIMUNIT_CM 	then sillHeightForm = "%~0." + str(iWorkUnitSillHgtDecimal,1,0) + "cm"		!cm
	if iWorkUnitSillHgt = DIMUNIT_DM | iWorkUnitSillHgt = DIMUNIT_METER then
		sillHeightForm = "%~0." + str(iWorkUnitSillHgtDecimal,1,0) + "m"		!m
	endif
	if iWorkUnitSillHgt = DIMUNIT_INCH 	then sillHeightForm = "%0.64fi"
endif


if iIDText <> IDVALUE_CUSTOMTEXT then
	dim _MasterID[]
	result = REQUEST("Full_ID_of_parent", "", _MasterID)
	strIDValue = ""
	if result then
		if iIDText = IDVALUE_IDNUMBER then
			strIDValue = _MasterID[vardim1(_MasterID)]
		else
			for i = 1 to vardim1 (_MasterID)
				strIDValue = strIDValue + _MasterID[i]
			next i
		endif
	endif
endif


if iFireText = VALUE_AUTOMATIC then
	fireRating = ""
	rrr = request ("ASSOCLP_PARVALUE", "gs_list_firerating",
			index_ww, type_ww, flags_ww, dim1_ww, dim2_ww, fRat)
	if rrr then fireRating = fRat

	strFireValue = fireRating
endif

if iAcousticText = VALUE_AUTOMATIC then
	acousticRating = ""
	rrr = request ("ASSOCLP_PARVALUE", "gs_list_acousticrating",
			index_ww, type_ww, flags_ww, dim1_ww, dim2_ww, aRat)
	if rrr then acousticRating = aRat

	strAcousticValue = acousticRating
endif

if iUValueText = VALUE_AUTOMATIC then
	UValue = ""
	rrr = request ("ASSOCLP_PARVALUE", "gs_list_heattransfer",
			index_ww, type_ww, flags_ww, dim1_ww, dim2_ww, uVal)
	if rrr then UValue = uVal

	strUValueValue = UValue
endif

if iHardwareText = VALUE_AUTOMATIC then
	hardwareSet = ""
	rrr = request ("ASSOCLP_PARVALUE", "gs_list_hwsetno",
			index_ww, type_ww, flags_ww, dim1_ww, dim2_ww, hwset)
	if rrr then hardwareSet = hwset

	strHardwareValue = hardwareSet
endif

! --- wallhole sizes ---
if iWHDimText = DIM_MEASURED then
	_bContentSillSizes = 0

	wallholeWidth = 0
	rrr = request ("ASSOCLP_PARVALUE", "ac_wallhole_width",
			index_ww, type_ww, flags_ww, dim1_ww, dim2_ww, width_wh)
	if rrr then wallholeWidth = width_wh

	wallholeHeight = 0
	rrr = request ("ASSOCLP_PARVALUE", "ac_wallhole_height",
			index_ww, type_ww, flags_ww, dim1_ww, dim2_ww, height_wh)
	if rrr then wallholeHeight = height_wh

	wallholeWidth_main = "" : wallholeWidth_frac = "" : wallholeHeight_main = "" : wallholeHeight_frac = ""

	lengthValue = wallholeHeight
	szFormat = widthHeightForm

	gosub "format_length_2_main_n_frac"

	wallholeHeight_main = main
	wallholeHeight_frac = frac

	lengthValue = wallholeWidth
	szFormat = widthHeightForm

	gosub "format_length_2_main_n_frac"

	wallholeWidth_main = main
	wallholeWidth_frac = frac

	strWHDimValue = wallholeWidth_main + wallholeWidth_frac + GS_Separator + wallholeHeight_main + wallholeHeight_frac
endif

! --- unit sizes ---
if iUnitDimText = DIM_MEASURED then
	_bContentSillSizes = 0

	unitWidth = 0
	rrr = request ("ASSOCLP_PARVALUE", "ac_unit_width",
			index_ww, type_ww, flags_ww, dim1_ww, dim2_ww, width_unit)
	if rrr then unitWidth = width_unit

	unitHeight = 0
	rrr = request ("ASSOCLP_PARVALUE", "ac_unit_height",
			index_ww, type_ww, flags_ww, dim1_ww, dim2_ww, height_unit)
	if rrr then unitHeight = height_unit

	unitWidth_main = "" : unitWidth_frac = "" : unitHeight_main = "" : unitHeight_frac = ""

	lengthValue = unitHeight
	szFormat = widthHeightForm

	gosub "format_length_2_main_n_frac"

	unitHeight_main = main
	unitHeight_frac = frac

	lengthValue = unitWidth
	szFormat = widthHeightForm

	gosub "format_length_2_main_n_frac"

	unitWidth_main = main
	unitWidth_frac = frac

	strUnitDimValue = unitWidth_main + unitWidth_frac + GS_Separator + unitHeight_main + unitHeight_frac
endif

! --- egress sizes ---
if iEgressDimText = DIM_MEASURED then
	_bContentSillSizes = 0

	egressWidth = 0
	rrr = request ("ASSOCLP_PARVALUE", "ac_egress_width",
			index_ww, type_ww, flags_ww, dim1_ww, dim2_ww, width_egress)
	if rrr then egressWidth = width_egress

	egressHeight = 0
	rrr = request ("ASSOCLP_PARVALUE", "ac_egress_height",
			index_ww, type_ww, flags_ww, dim1_ww, dim2_ww, height_egress)
	if rrr then egressHeight = height_egress

	egressWidth_main = "" : egressWidth_frac = "" : egressHeight_main = "" : egressHeight_frac = ""

	lengthValue = egressHeight
	szFormat = widthHeightForm

	gosub "format_length_2_main_n_frac"

	egressHeight_main = main
	egressHeight_frac = frac

	lengthValue = egressWidth
	szFormat = widthHeightForm

	gosub "format_length_2_main_n_frac"

	egressWidth_main = main
	egressWidth_frac = frac

	strEgressDimValue = egressWidth_main + egressWidth_frac + GS_Separator + egressHeight_main + egressHeight_frac
endif

! --- reveal sizes ---
if iRevealDimText = DIM_MEASURED then
	_bContentSillSizes = 0

	revealWidth = 0
	rrr = request ("ASSOCLP_PARVALUE", "ac_reveal_width",
			index_ww, type_ww, flags_ww, dim1_ww, dim2_ww, width_reveal)
	if rrr then revealWidth = width_reveal

	revealHeight = 0
	rrr = request ("ASSOCLP_PARVALUE", "ac_reveal_height",
			index_ww, type_ww, flags_ww, dim1_ww, dim2_ww, height_reveal)
	if rrr then revealHeight = height_reveal

	revealWidth_main = "" : revealWidth_frac = "" : revealHeight_main = "" : revealHeight_frac = ""

	lengthValue = revealHeight
	szFormat = widthHeightForm

	gosub "format_length_2_main_n_frac"

	revealHeight_main = main
	revealHeight_frac = frac

	lengthValue = revealWidth
	szFormat = widthHeightForm

	gosub "format_length_2_main_n_frac"

	revealWidth_main = main
	revealWidth_frac = frac

	strRevealDimValue = revealWidth_main + revealWidth_frac + GS_Separator + revealHeight_main + revealHeight_frac
endif

! --- threshold size ---
if iThresholdText =  DIM_MEASURED then
	_bContentSillSizes = 1

	_bThresholdOn = 0
	_bHasThresholdBool = request ("ASSOCLP_PARVALUE", "bThreshold",
			index_ww, type_ww, flags_ww, dim1_ww, dim2_ww, _bThresholdOn)

	thresholdHeight = 0
	thresholdH	= 0
	_bHas3DThresholdHeight = request ("ASSOCLP_PARVALUE", "thresholdHeight3D",
			index_ww, type_ww, flags_ww, dim1_ww, dim2_ww, thresholdH)

	if _bHasThresholdBool and _bThresholdOn then
		if _bHas3DThresholdHeight then
			! DACH
			thresholdHeight = thresholdH
		else
			doorTreshold = 0
			_bHasThresholdType = request ("ASSOCLP_PARVALUE", "iThresholdType",
				index_ww, type_ww, flags_ww, dim1_ww, dim2_ww, doorTreshold)

			if _bHasThresholdType then
				if doorTreshold > 0 then
					_bHasThresholdThk = request ("ASSOCLP_PARVALUE", "gs_treshold_thk",
						index_ww, type_ww, flags_ww, dim1_ww, dim2_ww, thresholdH)

					if _bHasThresholdThk then
						thresholdHeight = thresholdH
					endif
				endif
			endif
		endif
	endif

	thresholdHeight_main = "" : thresholdHeight_frac = ""

	lengthValue = thresholdHeight
	szFormat = sillHeightForm

	gosub "format_length_2_main_n_frac"

	thresholdHeight_main = main
	thresholdHeight_frac = frac

	strThresholdValue = thresholdHeight_main + thresholdHeight_frac
endif

! --- sill size ---
if iSillText = DIM_MEASURED then
	_bContentSillSizes = 1

	sillHeight_main = ""
	sillHeight_frac = ""

	if iShowSillTo = SILL_TO_CURRSTORY then
		sillHeight = AC_SILL_TO_CURR_STORY
	else
		if iShowSillTo = SILL_TO_WALLBASE then
			sillHeight = AC_GLOB_ELEVATION
		else	! anchor - default
			sillHeight = AC_SILL_TO_ANCHOR_LEVEL
		endif
	endif
	if not(bSillNominal) then
		sillHeight = sillHeight - AC_WIDO_OVERSIZE_B - AC_WIDO_SUBFL_THICKNESS
	endif

	lengthValue = sillHeight
	szFormat = sillHeightForm

	gosub "format_length_2_main_n_frac"

	sillHeight_main = main
	sillHeight_frac = frac

	strSillValue = sillHeight_main + sillHeight_frac
endif

! -------------------------------------------------------------------------------
! Define styles
! -------------------------------------------------------------------------------

if iBoxAlignment = BOXALIGN_LEFT then
	leftAlign	= 1
	rightAlign	= 1
else
	if iBoxAlignment = BOXALIGN_CENTER then
		leftAlign	= 3
		rightAlign	= 1
	else
		if iBoxAlignment = BOXALIGN_SIDE then
			leftAlign	= 1
			rightAlign	= 3
		else
			leftAlign	= 3
			rightAlign	= 3
		endif
	endif
endif

define style "headerStyle" AC_TextFont_1, AC_TextSize_1, 6 + iIDAlignment, AC_TextStyle_1
define style "boxStyleLeft" AC_TextFont_2, AC_TextSize_2, leftAlign, AC_TextStyle_2
define style "boxStyleRight" AC_TextFont_2, AC_TextSize_2, rightAlign, AC_TextStyle_2


! ======================================================================
! set dimensions
! ======================================================================


numLinesInBox	=  bShowWallholeDim + bShowUnitDim + bShowFire + bShowAcoustic + \
					bShowUValue + bShowMaterial + bShowHardware
if bWindow then
	numLinesInBox = numLinesInBox + bShowRevealDim + bShowSill + bShowCust1 + bShowCust2
else
	numLinesInBox = numLinesInBox + bShowEgressDim + bShowThreshold + bShowHandle + bShowCust
endif

if bShowAdditionalTags then
	numLinesInBox = numLinesInBox + _numTnCRow
endif

if numLinesInBox > 0 then
	strings2d[numLinesInBox][2] = ""
	lengthValues2d[numLinesInBox][2] = -9999
	dimensionType[numLinesInBox] = 0
endif

style "boxStyleLeft"

PAPER_TO_MODEL = GLOB_SCALE / 1000

boxSpaceWidth = stw(" ") * PAPER_TO_MODEL

actLine = 1
columnWidth_mm_1 = 0
columnWidth_mm_2 = 0
if bShowWallholeDim then
	if iWHDimText = DIM_MEASURED then
		strings2d[actLine][1] = strWHPrefix
		strings2d[actLine][2] = ""
		lengthValues2d[actLine][1] = wallholeWidth
		lengthValues2d[actLine][2] = wallholeHeight
		dimensionType[actLine] = UNITTYPE_WIDO_DIM
	else
		strings2d[actLine][1] = strWHPrefix
		strings2d[actLine][2] = strWHDimValue
		lengthValues2d[actLine][1] = 0
		lengthValues2d[actLine][2] = 0
		dimensionType[actLine] = 0
	endif

	columnWidth_mm_1 = max(columnWidth_mm_1, stw(" " + strWHPrefix + " "))
	columnWidth_mm_2 = max(columnWidth_mm_2, stw(" " + strWHDimValue + " "))
	actLine = actLine + 1
endif

if bShowUnitDim then
	if iUnitDimText = DIM_MEASURED then
		strings2d[actLine][1] = strUnitPrefix
		strings2d[actLine][2] = ""
		lengthValues2d[actLine][1] = unitWidth
		lengthValues2d[actLine][2] = unitHeight
		dimensionType[actLine] = UNITTYPE_WIDO_DIM
	else
		strings2d[actLine][1] = strUnitPrefix
		strings2d[actLine][2] = strUnitDimValue
		lengthValues2d[actLine][1] = 0
		lengthValues2d[actLine][2] = 0
		dimensionType[actLine] = 0
	endif

	columnWidth_mm_1 = max(columnWidth_mm_1, stw(" " + strUnitPrefix + " "))
	columnWidth_mm_2 = max(columnWidth_mm_2, stw(" " + strUnitDimValue + " "))
	actLine = actLine + 1
endif

if bWindow and bShowRevealDim then
	if iRevealDimText = DIM_MEASURED then
		strings2d[actLine][1] = strRevealPrefix
		strings2d[actLine][2] = ""
		lengthValues2d[actLine][1] = revealWidth
		lengthValues2d[actLine][2] = revealHeight
		dimensionType[actLine] = UNITTYPE_WIDO_DIM
	else
		strings2d[actLine][1] = strRevealPrefix
		strings2d[actLine][2] = strRevealDimValue
		lengthValues2d[actLine][1] = 0
		lengthValues2d[actLine][2] = 0
		dimensionType[actLine] = 0
	endif

	columnWidth_mm_1 = max(columnWidth_mm_1, stw(" " + strRevealPrefix + " "))
	columnWidth_mm_2 = max(columnWidth_mm_2, stw(" " + strRevealDimValue + " "))
	actLine = actLine + 1
endif

if not(bWindow) and bShowEgressDim then
	if iEgressDimText = DIM_MEASURED then
		strings2d[actLine][1] = strEgressPrefix
		strings2d[actLine][2] = ""
		lengthValues2d[actLine][1] = egressWidth
		lengthValues2d[actLine][2] = egressHeight
		dimensionType[actLine] = UNITTYPE_WIDO_DIM
	else
		strings2d[actLine][1] = strEgressPrefix
		strings2d[actLine][2] = strEgressDimValue
		lengthValues2d[actLine][1] = 0
		lengthValues2d[actLine][2] = 0
		dimensionType[actLine] = 0
	endif

	columnWidth_mm_1 = max(columnWidth_mm_1, stw(" " + strEgressPrefix + " "))
	columnWidth_mm_2 = max(columnWidth_mm_2, stw(" " + strEgressDimValue + " "))
	actLine = actLine + 1
endif

if bWindow and bShowSill then
	if iSillText = DIM_MEASURED then
		strings2d[actLine][1] = strSillPrefix
		strings2d[actLine][2] = ""
		lengthValues2d[actLine][1] = sillHeight
		lengthValues2d[actLine][2] = 0
		dimensionType[actLine] = UNITTYPE_SILL_DIM
	else
		strings2d[actLine][1] = strSillPrefix
		strings2d[actLine][2] = strSillValue
		lengthValues2d[actLine][1] = 0
		lengthValues2d[actLine][2] = 0
		dimensionType[actLine] = 0
	endif

	columnWidth_mm_1 = max(columnWidth_mm_1, stw(" " + strSillPrefix + " "))
	columnWidth_mm_2 = max(columnWidth_mm_2, stw(" " + strSillValue + " "))
	actLine = actLine + 1
endif

if not(bWindow) and bShowThreshold then
	if iThresholdText = DIM_MEASURED then
		strings2d[actLine][1] = strThresholdPrefix
		strings2d[actLine][2] = ""
		lengthValues2d[actLine][1] = thresholdHeight
		lengthValues2d[actLine][2] = 0
		dimensionType[actLine] = UNITTYPE_SILL_DIM
	else
		strings2d[actLine][1] = strThresholdPrefix
		strings2d[actLine][2] = strThresholdValue
		lengthValues2d[actLine][1] = 0
		lengthValues2d[actLine][2] = 0
		dimensionType[actLine] = 0
	endif

	columnWidth_mm_1 = max(columnWidth_mm_1, stw(" " + strThresholdPrefix + " "))
	columnWidth_mm_2 = max(columnWidth_mm_2, stw(" " + strThresholdValue + " "))
	actLine = actLine + 1
endif

if bShowFire then
	strings2d[actLine][1] = strFirePrefix
	strings2d[actLine][2] = strFireValue
	lengthValues2d[actLine][1] = 0
	lengthValues2d[actLine][2] = 0
	dimensionType[actLine] = 0

	columnWidth_mm_1 = max(columnWidth_mm_1, stw(" " + strFirePrefix + " "))
	columnWidth_mm_2 = max(columnWidth_mm_2, stw(" " + strFireValue + " "))
	actLine = actLine + 1
endif

if bShowAcoustic then
	strings2d[actLine][1] = strAcousticPrefix
	strings2d[actLine][2] = strAcousticValue
	lengthValues2d[actLine][1] = 0
	lengthValues2d[actLine][2] = 0
	dimensionType[actLine] = 0

	columnWidth_mm_1 = max(columnWidth_mm_1, stw(" " + strAcousticPrefix + " "))
	columnWidth_mm_2 = max(columnWidth_mm_2, stw(" " + strAcousticValue + " "))
	actLine = actLine + 1
endif

if bShowUValue then
	strings2d[actLine][1] = strUValuePrefix
	strings2d[actLine][2] = strUValueValue
	lengthValues2d[actLine][1] = 0
	lengthValues2d[actLine][2] = 0
	dimensionType[actLine] = 0

	columnWidth_mm_1 = max(columnWidth_mm_1, stw(" " + strUValuePrefix + " "))
	columnWidth_mm_2 = max(columnWidth_mm_2, stw(" " + strUValueValue + " "))
	actLine = actLine + 1
endif

if bShowMaterial then
	strings2d[actLine][1] = strMaterialPrefix
	strings2d[actLine][2] = strMaterialValue
	lengthValues2d[actLine][1] = 0
	lengthValues2d[actLine][2] = 0
	dimensionType[actLine] = 0

	columnWidth_mm_1 = max(columnWidth_mm_1, stw(" " + strMaterialPrefix + " "))
	columnWidth_mm_2 = max(columnWidth_mm_2, stw(" " + strMaterialValue + " "))
	actLine = actLine + 1
endif

if bShowHardware then
	strings2d[actLine][1] = strHardwarePrefix
	strings2d[actLine][2] = strHardwareValue
	lengthValues2d[actLine][1] = 0
	lengthValues2d[actLine][2] = 0
	dimensionType[actLine] = 0

	columnWidth_mm_1 = max(columnWidth_mm_1, stw(" " + strHardwarePrefix + " "))
	columnWidth_mm_2 = max(columnWidth_mm_2, stw(" " + strHardwareValue + " "))
	actLine = actLine + 1
endif

if bWindow and bShowCust1 then
	strings2d[actLine][1] = strCust1Prefix
	strings2d[actLine][2] = strCust1Value
	lengthValues2d[actLine][1] = 0
	lengthValues2d[actLine][2] = 0
	dimensionType[actLine] = 0

	columnWidth_mm_1 = max(columnWidth_mm_1, stw(" " + strCust1Prefix + " "))
	columnWidth_mm_2 = max(columnWidth_mm_2, stw(" " + strCust1Value + " "))
	actLine = actLine + 1
endif

if bWindow and bShowCust2 then
	strings2d[actLine][1] = strCust2Prefix
	strings2d[actLine][2] = strCust2Value
	lengthValues2d[actLine][1] = 0
	lengthValues2d[actLine][2] = 0
	dimensionType[actLine] = 0

	columnWidth_mm_1 = max(columnWidth_mm_1, stw(" " + strCust2Prefix + " "))
	columnWidth_mm_2 = max(columnWidth_mm_2, stw(" " + strCust2Value + " "))
	actLine = actLine + 1
endif

if not(bWindow) and bShowHandle then
	strings2d[actLine][1] = strHandlePrefix
	strings2d[actLine][2] = strHandleValue
	lengthValues2d[actLine][1] = 0
	lengthValues2d[actLine][2] = 0
	dimensionType[actLine] = 0

	columnWidth_mm_1 = max(columnWidth_mm_1, stw(" " + strHandlePrefix + " "))
	columnWidth_mm_2 = max(columnWidth_mm_2, stw(" " + strHandleValue + " "))
	actLine = actLine + 1
endif

if not(bWindow) and bShowCust then
	strings2d[actLine][1] = strCustPrefix
	strings2d[actLine][2] = strCustValue
	lengthValues2d[actLine][1] = 0
	lengthValues2d[actLine][2] = 0
	dimensionType[actLine] = 0

	columnWidth_mm_1 = max(columnWidth_mm_1, stw(" " + strCustPrefix + " "))		! mm, paper size
	columnWidth_mm_2 = max(columnWidth_mm_2, stw(" " + strCustValue + " "))
	actLine = actLine + 1
endif

if bShowAdditionalTags then
	for i = 1 to _numTnCRow
		strings2d[actLine][1]		= prefixTnC[i]
		strings2d[actLine][2]		= contentTnC[i]
		lengthValues2d[actLine][1]	= 0
		lengthValues2d[actLine][2]	= 0
		dimensionType[actLine]		= 0

		columnWidth_mm_1 = max(columnWidth_mm_1, stw(" " + prefixTnC[i] + " "))		! mm, paper size
		columnWidth_mm_2 = max(columnWidth_mm_2, stw(" " + contentTnC[i] + " "))
		actLine = actLine + 1
	next i	
endif

style "headerStyle"

IDWidth = stw(" " + strIDValue + " ")			! mm, paper size
IDSpaceWidth = stw(" ") * PAPER_TO_MODEL

minStampWidth = max(IDWidth, columnWidth_mm_1 + columnWidth_mm_2)			! mm, paper size

n = request("Height_of_style", "headerStyle", sh)
minIDLineSpacing = sh			! mm, paper size

n = request("Height_of_style", "boxStyleLeft", sh)
minDetailLineSpacing = sh			! mm, paper size


if iStampWidth = VALUE_AUTOMATIC then
	stampWidth = minStampWidth * PAPER_TO_MODEL

	if (columnWidth_mm_1 + columnWidth_mm_2 - IDWidth) > EPS then		! Minimal Stamp Width is the width of Columns
		columnWidth_1 = columnWidth_mm_1 * PAPER_TO_MODEL
		columnWidth_2 = columnWidth_mm_2 * PAPER_TO_MODEL
	else
		columnWidth_1 = (IDWidth + columnWidth_mm_1 - columnWidth_mm_2)/2 * PAPER_TO_MODEL
		columnWidth_2 = (IDWidth - columnWidth_mm_1 + columnWidth_mm_2)/2 * PAPER_TO_MODEL
	endif
else
	stampWidth = stampWidth_mm * PAPER_TO_MODEL

	columnWidth_1 = (stampWidth_mm + columnWidth_mm_1 - columnWidth_mm_2)/2 * PAPER_TO_MODEL
	columnWidth_2 = (stampWidth_mm - columnWidth_mm_1 + columnWidth_mm_2)/2 * PAPER_TO_MODEL
endif

if iIDLineSpacing = VALUE_AUTOMATIC then
	IDLineSpacing_mm = minIDLineSpacing
	IDLineSpacing_pt = IDLineSpacing_mm * DOT_IN_MM
	headerHeight = minIDLineSpacing * PAPER_TO_MODEL
else
	headerHeight = IDLineSpacing_mm * PAPER_TO_MODEL
endif

if iDetailLineSpacing = VALUE_AUTOMATIC then
	detailLineSpacing_mm = minDetailLineSpacing
	detailLineSpacing_pt = detailLineSpacing_mm * DOT_IN_MM
	lineHeight = minDetailLineSpacing * PAPER_TO_MODEL
else
	lineHeight = detailLineSpacing_mm * PAPER_TO_MODEL
endif

stampHeight = headerHeight + numLinesInBox * lineHeight

! ======================================================================
! set position variables
! ======================================================================

bFlip 			= 0
bMirrorX 		= 0
bMirrorY 		= 0
bReverse 		= 0
angleViewRot 	= 0
_bRotateForReadibility = 0
if AC_Readable then
	rrr = REQUEST ("View_Rotangle", "", angleViewRot)
endif

if AC_WIDO_REVEAL_SIDE_2 then bFlip = 1
if abs(AC_WIDO_MIRRORED - 1) < EPS then	bMirrorX = 1
if abs(AC_SYMB_ROTANGLE - 180) < EPS then bMirrorY = 1
if (not(AC_WIDO_REVEAL_SIDE_2) & abs(AC_SYMB_ROTANGLE-180) < EPS) | \
	(AC_WIDO_REVEAL_SIDE_2 & abs(AC_SYMB_ROTANGLE-180) > EPS) then
	bReverse = 1
endif
if bFlip then
	_heightFirstline = lineHeight
else
	_heightFirstline = headerHeight
endif

! for angle hotspot when mirrored
_markerAngle = markerAngle
if bMirrorX then _markerAngle = -markerAngle

totalRotate = (360 + (SYMB_ROTANGLE + angleViewRot + _markerAngle)) MOD 360
if (bMirrorY & (totalRotate < (gs_readable_angle + eps) | totalRotate > (gs_readable_angle + 180 + eps))) |\
	(not(bMirrorY) & (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps))) then
	_bRotateForReadibility = 1
endif


! ======================================================================
! Default position by Design and user request
! ======================================================================

if bMirrorX then
	mul2 -1, 1
	nTrans = nTrans + 1
endif
if bMirrorY then
	mul2 -1,-1
	add2 0,-_heightFirstline
	nTrans = nTrans + 2
else
	add2 0, - _heightFirstline - AC_WALL_THICKNESS
	nTrans = nTrans + 1
endif


! -------------------------------------------------------------------------------
! Hotspot editing
! -------------------------------------------------------------------------------

hotspot2  0,                 markerPositionVert, unID, markerPositionHor, 1+128 : unID = unID + 1
hotspot2  markerPositionHor, markerPositionVert, unID, markerPositionHor, 2     : unID = unID + 1
hotspot2 -1,                 markerPositionVert, unID, markerPositionHor, 3     : unID = unID + 1

hotspot2 markerPositionHor,  0,                  unID, markerPositionVert, 1+128 : unID = unID + 1
hotspot2 markerPositionHor,  markerPositionVert, unID, markerPositionVert, 2     : unID = unID + 1
hotspot2 markerPositionHor, -1,                  unID, markerPositionVert, 3     : unID = unID + 1

add2 markerPositionHor, markerPositionVert

hotspot2 0, 			0, unID, markerAngle, 6+512*bMirrorX : unID = unID + 1
hotspot2 stampWidth/2, 0, unID, markerAngle, 4+128 : unID = unID + 1
hotspot2 (stampWidth/2) * cos(markerAngle), (stampWidth/2) * sin(markerAngle), unID, markerAngle, 5 : unID = unID + 1

rot2 markerAngle


! -------------------------------------------------------------------------------
! Frame and fill
! -------------------------------------------------------------------------------

pen ac_textpen_1
fill AC_MarkerFill
line_type gs_line_type
pen SYMB_VIEW_PEN

bHeaderContour		= 0
bDetBoxContour		= 0
bHeaderSeparator	= 0
bLineSeparator		= 0
bColumnSeparator	= 0


if bMirrorX then
	mul2 -1,1
	nTrans = nTrans + 1
endif
if _bRotateForReadibility then
	mul2 -1,-1
	add2 0, stampHeight - (headerHeight + lineHeight)
	nTrans = nTrans + 2
endif


if iFrameStyle <> FRAME_NONE then
	bHeaderContour = 1

	if iFrameStyle <> FRAME_STYLE3 then bDetBoxContour = 1

	if iFrameStyle <> FRAME_STYLE1 then bHeaderSeparator = 1

	if iFrameStyle = FRAME_STYLE5 | iFrameStyle = FRAME_STYLE6 then bColumnSeparator = 1

	if iFrameStyle = FRAME_STYLE4 | iFrameStyle = FRAME_STYLE6 then bLineSeparator = 1
endif

poly2_b 6, 1+2+4, gs_fill_pen, gs_back_pen,
	-stampWidth/2, 0, bHeaderContour,
	-stampWidth/2, headerHeight, bHeaderContour,
	 stampWidth/2, headerHeight, bHeaderContour,
	 stampWidth/2, 0, bDetBoxContour,
	 stampWidth/2, headerHeight - stampHeight, bDetBoxContour,
	-stampWidth/2, headerHeight - stampHeight, bDetBoxContour

if bHeaderSeparator then line2 -stampWidth/2, 0, stampWidth/2, 0

if bColumnSeparator then line2 -stampWidth/2 + columnWidth_1, 0, stampWidth/2 - columnWidth_2, headerHeight - stampHeight

if bLineSeparator and numLinesInBox > 1 then
	for i = 1 to numLinesInBox - 1
		add2 0, -lineHeight
		line2 -stampWidth/2, 0, stampWidth/2, 0
	next i
	del numLinesInBox - 1
endif


! -------------------------------------------------------------------------------
! Header text
! -------------------------------------------------------------------------------

if bShowID then
	pen AC_TextPen_1
	style "headerStyle"

	if iIDAlignment = IDALIGN_LEFT then add2 -stampWidth/2 + IDSpaceWidth, 0
	if iIDAlignment = IDALIGN_RIGHT then add2 stampWidth/2 - IDSpaceWidth, 0

	text2 0, (IDLineSpacing_mm - minIDLineSpacing)/2 * PAPER_TO_MODEL, strIDValue

	if iIDAlignment = IDALIGN_LEFT then del 1
	if iIDAlignment = IDALIGN_RIGHT then del 1
endif

! -------------------------------------------------------------------------------
! Details
! -------------------------------------------------------------------------------

pen AC_TextPen_2
add2 0, -(detailLineSpacing_mm - minDetailLineSpacing)/2 * PAPER_TO_MODEL		! move to the center of line

for i = 1 to vardim1(strings2d)
	if dimensionType[i] < EPS then
		leftText = strings2d[i][1]
		rightText = strings2d[i][2]

		gosub "Line_text_left"

		gosub "Line_text_right"
	else
		leftText = strings2d[i][1]

		gosub "Line_text_left"

		if dimensionType[i] = UNITTYPE_SILL_DIM then
			_bContentSillSizes = 1
			szPrefix = ""
			actLengthValue = lengthValues2d[i][1]
			horizontalAlignment = rightAlign

			if rightAlign = 3 then
				add2 stampWidth/2 - boxSpaceWidth, 0
			else
				add2 stampWidth/2 - columnWidth_2 + boxSpaceWidth, 0
			endif

			gosub "Format_and_write"

			del 1
		else
			_bContentSillSizes = 0
			horizontalAlignment = rightAlign

			if rightAlign = 1 then		! left first
				add2 stampWidth/2 - columnWidth_2 + boxSpaceWidth, 0

				szPrefix = ""
				actLengthValue = lengthValues2d[i][1]

				gosub "Format_and_write"

				add2 totalLength * PAPER_TO_MODEL, 0

				szPrefix = GS_Separator
				actLengthValue = lengthValues2d[i][2]

				gosub "Format_and_write"

				del 2
			else
				add2 stampWidth/2 - boxSpaceWidth, 0

				szPrefix = GS_Separator
				actLengthValue = lengthValues2d[i][2]

				gosub "Format_and_write"

				add2 -totalLength * PAPER_TO_MODEL, 0

				szPrefix = ""
				actLengthValue = lengthValues2d[i][1]

				gosub "Format_and_write"

				del 2
			endif
		endif
	endif

	add2 0, -lineHeight
next i

del nTrans
end


! -------------------------------------------------------------------------------
! Get texts in line
! -------------------------------------------------------------------------------

"Format_and_write":

	_sContentForFormatter = actLengthValue
	_custom_form = ""
	_iUnitType = dimensionType[i]

	if _bContentSillSizes then
		_custom_form		= sillHeightForm
		_iWorkUnit			= iWorkUnitSillHgt
	else
		_custom_form		= widthHeightForm
		_iWorkUnit			= iWorkUnitLinear
	endif

	if _iWorkUnit <> DIMUNIT_PROJECT then
		_iUnitType = 0		! Custom

		if _iWorkUnit = DIMUNIT_DM then
			_sContentForFormatter = actLengthValue * 10
		endif
	endif

	call "quantity_text_writer" parameters 	lengthValue				= _sContentForFormatter,
											custom_form				= _custom_form,
											iUnitType				= _iUnitType,
											GS_iMarkerDir			= 1,
											horizontalAlignment		= horizontalAlignment,
											AC_TextFont				= AC_TextFont_2,
											AC_TextSize				= AC_TextSize_2,
											AC_TextStyle			= AC_TextStyle_2,
											szPrefix				= szPrefix,
											AC_Readable				= 0,
											gs_readable_angle		= 90,
											useLeadingAndDescent	= 1,
											bShowText				= 1,
											verticalAlignment		= 2,		! top
											bFeedbackMode			= 0,
					returned_parameters		totalLength,
											totalHeight,
											extraPrecision
return

"Line_text_left":
	style "boxStyleLeft"

	if leftAlign = 1 then
		add2 -stampWidth/2 + boxSpaceWidth, 0
	else
		add2 -stampWidth/2 + columnWidth_1 - boxSpaceWidth, 0
	endif

	text2 0, 0, leftText

	del 1
return

"Line_text_right":
	style "boxStyleRight"

	if rightAlign = 3 then
		add2 stampWidth/2 - boxSpaceWidth, 0
	else
		add2 stampWidth/2 - columnWidth_2 + boxSpaceWidth, 0
	endif

	text2 0, 0, rightText

	del 1
return


! ==============================================================================
! Format length value into main and frac strings
! Input:
!	szFormat:    formatted string
!	lengthValue: length value
! Output:
!	main: the main part of the length which should be written in normal type
!	frac: the fractal part which should be written smaller
! ==============================================================================

"format_length_2_main_n_frac":
	szFormattedLength = ""
	szExtraPrecision = ""

	if _bContentSillSizes then
		_iWorkUnit	= iWorkUnitSillHgt
	else
		_iWorkUnit	= iWorkUnitLinear
	endif

	if _iWorkUnit = DIMUNIT_DM then
		lengthValue = lengthValue * 10
	endif

	szFormattedLength = str{2}(szFormat, lengthValue, szExtraPrecision)

	if strstr(szFormat, "*10") <= 0 then
		main = szFormattedLength
		frac = szExtraPrecision
	else
		slash = strstr(szFormattedLength, "/")

		main = ""
		frac = ""

		if not(slash) then	! No Fractions
			main = szFormattedLength
		else				! Fractions
			if slash > 2 then
				slen  = strlen(szFormattedLength)
				main = strsub(szFormattedLength, 1, slash - 3)
				frac = strsub(szFormattedLength, slash - 2, slen)

				if strstr(frac," ") | strstr(frac,"-") then
					temp = frac
					frac = ""
					frac = strsub(temp, 2, strlen(temp))
				endif

				fine = strsub(main, strlen(main), strlen(main))

				if fine = " " | fine = "-" then
					temp = main
					main = ""
					main = strsub(temp, 1, strlen(temp) - 1)
				endif
			else
				frac = szFormattedLength
			endif
		endif
	endif

return








