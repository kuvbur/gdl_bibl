
! ========================================================================================
!	-------------	-------------
!	|	--------|---|--------	|	
!	|	| Header|	|		|	|
!	|	--------|---|--------	|
!	|	--------|---|--------	|	
!	|	|		|	|		|	|
!	|	| Body	|	|		|	|
!	|	--------|---|--------	|
!	|	Prefix	|	|	Content	|
!	-------------	-------------
!
! Header:
!	has own text style
!		fontTypeHeader			- font style
!		sizeFontHeader_mm		- font size
!		_iStyleFontHeader		- font style
!		_sizeLeadingHeader		- leading, line space percent - 100 % is the real size
!		iAlignmentPrefixHeader	- text alignment - 1: left aligned, 2: center aligned, 3: right aligned, 4: full justified
!		iAlignmentContentHeader	- text alignment - 1: left aligned, 2: center aligned, 3: right aligned, 4: full justified
! Body:
!	has own text style
!		sTypeFontBody			- font style
!		sizeFontBody			- font size
!		iStyleFontBody			- font style
!		sizeLeadingBody			- leading, line space percent - 100 % is the real size
!		iAlignmentPrefixBody	- text alignment - 1: left aligned, 2: center aligned, 3: right aligned, 4: full justified
!		iAlignmentContentBody	- text alignment - 1: left aligned, 2: center aligned, 3: right aligned, 4: full justified
! Prefix:
!		input with sPrefixStrings array - one column : 1.prefix
! Content:
!		input with sContentStrings array - 30 column
!			column properties : [1.note1 2.frac 3.unit 4.unitindex 5.suffix] * 6 possibility
!			can be displayed 6 calculated and separated data with unit in one row
! ========================================================================================
_numberofRow			= vardim1(sContentStrings)
_numberMaxContentCells	= 30
_isPreview 				= (GLOB_CONTEXT = 5)

! ========================================================================================
! Fill out arrays to 30 fixed cells number - initialization 
! ========================================================================================

dim _sContentStrings[][]
	_sContentStrings = sContentStrings
for i = 1 to _numberofRow
	for iCell = vardim2(sContentStrings)+1 to _numberMaxContentCells
		_sContentStrings[i][iCell] = ""
	next iCell
next i

! ========================================================================================
! Custom header style - merge first row prefix and content strings
! if there is Prefix and Content too then Prefix is added to Content
! if there is only Prefix or only Content then the function is working like others
! ========================================================================================

if bEnableCustomHeaderStyle and bUsePrefixColumn then
	_sep = ""
	if sPrefixStrings[1] <> "" then _sep = " "
	_sContentStrings[1][1] = sPrefixStrings[1] + _sep + _sContentStrings[1][1]
	sPrefixStrings[1] = ""
endif

! ========================================================================================
! Merge rows of multi-row-content by Parameter Name
! ========================================================================================

dim _isMergeContentRows[]
for i = 1 to _numberofRow
	_isMergeContentRows[i] = 0
	if bUsePrefixColumn and i > 1 then
		if sPrefixStrings[i] = sPrefixStrings[i-1] then
			for iMerge = i to _numberofRow
				if sPrefixStrings[iMerge] = sPrefixStrings[i-1] then
					sPrefixStrings[iMerge] = ""
					_isMergeContentRows[iMerge] = 1
				endif
			next iMerge
		endif
	endif
next i

! ========================================================================================
! Define styles and ratio of line spacing
! ========================================================================================

! normal text:
define style{2} "mainStyleHeader"  fontTypeHeader, sizeFontHeader_mm * GLOB_SCALE/1000, _iStyleFontHeader
n = request("Height_of_style", "mainStyleHeader", _heightFirstRowTextBox, descent, leading)
_ratioLinespaceHeader = _sizeLeadingHeader

define style{2} "mainStyleBody"  sTypeFontBody, sizeFontBody * GLOB_SCALE/1000, iStyleFontBody
n = request("Height_of_style", "mainStyleBody", _heightRowBody, descent, leading)
_ratioLinespaceBody = sizeLeadingBody

! superscript style - upper index text (for extra precision or unit extension) without underline and striketrough style by design
_iStyleFontHeaderExtra = _iStyleFontHeader
if bittest(_iStyleFontHeaderExtra, 2) then	! Underline
	_iStyleFontHeaderExtra = _iStyleFontHeaderExtra - 4
endif
if bittest(_iStyleFontHeaderExtra, 7) then	! Striketrough
	_iStyleFontHeaderExtra = _iStyleFontHeaderExtra - 128
endif
_iStyleFontBodyExtra = iStyleFontBody
if bittest(_iStyleFontBodyExtra, 2) then	! Underline
	_iStyleFontBodyExtra = _iStyleFontBodyExtra - 4
endif
if bittest(_iStyleFontBodyExtra, 7) then	! Striketrough
	_iStyleFontBodyExtra = _iStyleFontBodyExtra - 128
endif
define style{2} "extraStyleHeader"  fontTypeHeader, sizeFontHeader_mm * GLOB_SCALE/1000, _iStyleFontHeaderExtra + 32
define style{2} "extraStyleBody"	sTypeFontBody, sizeFontBody * GLOB_SCALE/1000, _iStyleFontBodyExtra + 32

! ========================================================================================
! Fill style arrays for paragraph
! ========================================================================================

dim _sStylePrefix[]
dim _sStyleBody[][]
for i = 1 to _numberofRow
	if i = 1 then
		_sStylePrefix[i] = "mainStyleHeader"
	else
		_sStylePrefix[i] = "mainStyleBody"
	endif

	for iCell = 1 to vardim2(sContentStrings)
		if abs(((iCell+5) MOD 5) - 2) < EPS  | abs(((iCell+5) MOD 5) - 4) < EPS then
			if i = 1 then
				_sStyleBody[i][iCell] = "extraStyleHeader"
			else
				_sStyleBody[i][iCell] = "extraStyleBody"
			endif
		else
			if i = 1 then
				_sStyleBody[i][iCell] = "mainStyleHeader"
			else
				_sStyleBody[i][iCell] = "mainStyleBody"
			endif
		endif
	next iCell
	for iCell = vardim2(sContentStrings)+1 to _numberMaxContentCells
		_sStyleBody[i][iCell] =  "mainStyleBody" ! dummy - no need
	next iCell
next i

! ==========================================================================
! Calculating textbox`s dimensions
! ==========================================================================
_xPosTB			= 0
_yPosTB			= 0

dim _stringwidthPrefix[]
dim _stringheightPrefix[]
dim _stringwidthContent[]
dim _stringheightContent[]
dim _heightRow[]

_calculatedWidthPrefixTextBox = 0
_calculatedWidthContentTextBox = 0
_calculatedWidthFullTextBox = 0
if bWrapText then
	if bUsePrefixColumn then
		_calculatedWidthPrefixTextBox = widthTextBoxPrefix_mm
	endif
	if bUseContentColumn then
		_calculatedWidthContentTextBox = widthTextBoxContent_mm
	endif
	_calculatedWidthFullTextBox = _calculatedWidthPrefixTextBox + _calculatedWidthContentTextBox +\
								 (widthTextBoxOffset * 2 * (bUsePrefixColumn & bUseContentColumn))
endif

for i = 1 to _numberofRow

	_penindex 			= 1
	_drawRichtext		= 0
	_iAlignment			= 1
	_iReferencePoint	= 1

	if i = 1 then
		_ratioLineSpace = _ratioLinespaceHeader
	else
		_ratioLineSpace = _ratioLinespaceBody
	endif

	if bUsePrefixColumn then
		_usePrefixChapter	= 1
		_widthTextBlock	= _calculatedWidthPrefixTextBox	! -> zero means automatic calculations
		gosub "usePharagraph"	! returned automatic dim or calculated
		if bWrapText then
			! the recalculated text box width is not always matching with the given widths because of paragraph standard
			! and the text box width can be longer then the automatic by design
			_stringwidthPrefix[i] = _widthTextBlock
		else
			_stringwidthPrefix[i] = _widthTB
		endif
		_stringheightPrefix[i] = _heightTB
	else
		_stringwidthPrefix[i] = 0
		_stringheightPrefix[i] = 0
	endif

	if bUseContentColumn then
		_usePrefixChapter	= 0
		if bEnableCustomHeaderStyle and i = 1 then
			_widthTextBlock = _calculatedWidthFullTextBox
			gosub "usePharagraph"	! returned automatic dim or calculated
		else
			_widthTextBlock		= _calculatedWidthContentTextBox	! -> zero means automatic calculations
			gosub "usePharagraph"	! returned automatic dim or calculated
		endif
		if bWrapText then
			! the recalculated text box width is not always matching with the given widths because of paragraph standard
			! and the text box width can be longer then the automatic by design
			_stringwidthContent[i] = _widthTextBlock
		else
			_stringwidthContent[i] = _widthTB
		endif
		_stringheightContent[i] = _heightTB
	else
		_stringwidthContent[i] = 0
		_stringheightContent[i] = 0
	endif

	_heightRow[i] = max(_stringheightPrefix[i], _stringheightContent[i])
next i

_widthPrefixTextBox = 0
for iCalc = (1 + bEnableCustomHeaderStyle) to vardim1(_stringwidthPrefix)
	_widthPrefixTextBox = max(_widthPrefixTextBox, _stringwidthPrefix[iCalc])
next iCalc
_widthContentTextBox = 0
for iCalc = (1 + bEnableCustomHeaderStyle) to vardim1(_stringwidthContent)
	_widthContentTextBox = max(_widthContentTextBox, _stringwidthContent[iCalc])
next iCalc

! by first row at cutom head style (prefix + 2 offset as separator + content)
_widthFirstRowTextBox = _stringwidthContent[1]
_widthFullTextBox = _widthPrefixTextBox + _widthContentTextBox + (widthTextBoxOffset * 2 * (bUsePrefixColumn & bUseContentColumn))
if bEnableCustomHeaderStyle then
	if _widthFullTextBox < _widthFirstRowTextBox then
		_widthPrefixTextBox = _widthPrefixTextBox + (_widthFirstRowTextBox - _widthFullTextBox) /(bUsePrefixColumn + bUseContentColumn)
		_widthContentTextBox = _widthContentTextBox + (_widthFirstRowTextBox - _widthFullTextBox) /(bUsePrefixColumn + bUseContentColumn)
		_widthFullTextBox = _widthPrefixTextBox + _widthContentTextBox + (widthTextBoxOffset * 2 * (bUsePrefixColumn & bUseContentColumn))
	else
		_widthFirstRowTextBox = _widthFullTextBox
	endif
endif

_heightFirstRowTextBox = _heightRow[1]
_heightFullTextBox = 0
for iCalc = 1 to vardim1(_stringheightContent)
	_heightFullTextBox = _heightFullTextBox + _heightRow[iCalc]
next iCalc

_widthPrefixFrame = 0
if bUsePrefixColumn then
	_widthPrefixFrame = _widthPrefixTextBox + widthTextBoxOffset * 2
endif
_widthContentFrame = 0
if bUseContentColumn then
	_widthContentFrame = _widthContentTextBox + widthTextBoxOffset * 2
endif
_widthFullFrame = _widthPrefixFrame + _widthContentFrame
_heightFullFrame = _heightFullTextBox + widthTextBoxOffset * 2

! ==============================================================================
! Install label position
! ==============================================================================
! ------------------------------------------------------------------------------
! Label positioning - global behavior for Marker form Labels
! - origin is where AC gives, the table begins with top left anchor 
! - LABEL_ROTANGLE (anglePosition) rotating is handled by AC, only need for readability calculation
! - bUseBuiltinPointer OFF (without AC Arrow)
! 		- the origin is at the arrow peak
! 		- orientation is rotated from gdl parameter and working as at Word Labels
!			1. Paralell/Horizontal/Vertical - LABEL_ROTANGLE has no effect
!			2. Custom - only LABEL_ROTANGLE lives
! 		- Reference Point is cordinated by user
! - bUseBuiltinPointer ON (with AC Arrow)
!		- the origin is at the boundary
!		- handling of rotation is belongs to AC (AC_CustomReadabilty OFF)
!		- Reference Point is cordinated at Pointer tabpage
! input:
!	iLabelOrientation	- type Orientation
!	anglePosition		- LABEL_ROTANGLE
!	angleParentPosition	- Parent tool direction using at Parallel
!	_isPreview
! ==============================================================================
nTrans = 0

if bUseBuiltinPointer then
	iReferencePoint			= 1
	iLabelOrientation		= 0	! none
endif

if not(_isPreview) and not(bUseBuiltinPointer) then
	angleViewRot = 0
	rrr = REQUEST ("View_Rotangle", "", angleViewRot)
	totalRotate = (angleViewRot) MOD 360

	if iLabelOrientation = ORIENTATION_PARALLEL then
		rot2 angleParentPosition - anglePosition
		nTrans = nTrans + 1
		totalRotate = ( totalRotate + angleParentPosition ) MOD 360
	else
		if iLabelOrientation = ORIENTATION_HORIZONTAL then
			rot2 -totalRotate - anglePosition
			nTrans = nTrans + 1
			totalRotate = 0
		else
			if iLabelOrientation = ORIENTATION_VERTICAL then
				rot2 -totalRotate + 90 - anglePosition
				nTrans = nTrans + 1
				totalRotate = 90
			else
				! at CUSTOM the LABEL_ROTANGLE (anglePosition) is handled by AC
				totalRotate = (anglePosition + totalRotate) MOD 360
			endif
		endif
	endif
endif


unID = 10
if bUseBuiltinPointer then
	hotspot2 0,					0, 						unID : unID = unID + 1
	hotspot2 _widthFullFrame,	0, 						unID : unID = unID + 1
	hotspot2 _widthFullFrame,	-_heightFullFrame, 		unID : unID = unID + 1
	hotspot2 0,					-_heightFullFrame, 		unID : unID = unID + 1
else
	! Only 1 hotspot at Reference Point
	hotspot2 0,	0,	unID : unID = unID + 1
endif

_posX = 0
_posY = 0

if iReferencePoint = 2 | iReferencePoint = 5 | iReferencePoint = 8 then _posX = -_widthFullFrame/2
if iReferencePoint = 3 | iReferencePoint = 6 | iReferencePoint = 9 then _posX = -_widthFullFrame

if iReferencePoint = 4 | iReferencePoint = 5 | iReferencePoint = 6 then _posY = _heightFullFrame/2
if iReferencePoint = 7 | iReferencePoint = 8 | iReferencePoint = 9 then _posY = _heightFullFrame

add2 _posX, _posY

hotline2 0,					0,					_widthFullFrame,	0,					unID : unID = unID + 1
hotline2 _widthFullFrame,	0,					_widthFullFrame,	-_heightFullFrame,	unID : unID = unID + 1
hotline2 _widthFullFrame,	-_heightFullFrame,	0,					-_heightFullFrame,	unID : unID = unID + 1
hotline2 0,					-_heightFullFrame,	0,					0,					unID : unID = unID + 1

! Readabilty - transform the full table ------------------------------------
if not(_isPreview) then
	if bAlwaysReadable and AC_CustomReadability then
		if (totalRotate > 90+EPS & totalRotate < 270-EPS) then
			mul2 -1, -1
			add2 -_widthFullFrame, _heightFullFrame
		endif
	endif
endif

! ==========================================================================
! Draw texts with paragraph row by row
! - the table begins with top left anchor
! ==========================================================================

_yPosTB	= -widthTextBoxOffset

for i = 1 to _numberofRow
	_drawRichtext 	= 1
	if i = 1 then
		_ratioLineSpace = _ratioLinespaceHeader
		_penindex		= penTextHeader
	else
		_ratioLineSpace = _ratioLinespaceBody
		_penindex		= penTextBody
	endif

	! --------------------------------------------------------------------------
	!  displaying content type NAME column 
	! --------------------------------------------------------------------------

	if bUsePrefixColumn then
		_xPosTB 			= widthTextBoxOffset
		_usePrefixChapter 	= 1
		_iReferencePoint	= 1		! for Text Box Orientation
		_widthTextBlock 	= _widthPrefixTextBox
		_iAlignment			= _iAlignmentPrefixBody
		gosub "usePharagraph"
	endif

	! --------------------------------------------------------------------------
	! displaying content Body column 
	! --------------------------------------------------------------------------

	if bUseContentColumn then
		_usePrefixChapter 	= 0
		_iReferencePoint	= 1		! for Text Box Orientation
		if bEnableCustomHeaderStyle and i = 1 then
			_xPosTB 			= widthTextBoxOffset
			_iAlignment			= iAlignmentHeader
			_widthTextBlock 	= _widthFirstRowTextBox
		else
			_xPosTB 			= _widthPrefixFrame + widthTextBoxOffset
			_iAlignment			= _iAlignmentContentBody
			_widthTextBlock 	= _widthContentTextBox
		endif
		gosub "usePharagraph"
	endif

	_yPosTB = _yPosTB - _heightRow[i]
next i

! ==========================================================================
! Frame and fill
! ==========================================================================

pen penFrame
fill filltype
line_type lineTypeFrame

bHeaderContour		= 0
bDetBoxContour		= 0
bHeaderSeparator	= 0
bLineSeparator		= 0
bColumnSeparator	= 0

if bShowFrame then
	bHeaderContour = 1
	if iFrameStyle <> FRAME_STYLE1 then bHeaderSeparator = 1
	if iFrameStyle <> FRAME_STYLE3 then bDetBoxContour = 1
	if iFrameStyle = FRAME_STYLE4 | iFrameStyle = FRAME_STYLE6 then bLineSeparator = 1
	if (iFrameStyle = FRAME_STYLE5 | iFrameStyle = FRAME_STYLE6) &\
		(bUsePrefixColumn & bUseContentColumn) then
		bColumnSeparator = 1
	endif
endif

poly2_b 6, bShowFrame + bShowFill * 2 + 4, penForeground, penBackground,
	0, 					0, 												bHeaderContour,
	_widthFullFrame, 	0,					 							bHeaderContour,
	_widthFullFrame, 	-(_heightFirstRowTextBox + widthTextBoxOffset), 	bDetBoxContour,
	_widthFullFrame,	-_heightFullFrame, 								bDetBoxContour,
	0,  				-_heightFullFrame, 								bDetBoxContour,
	0,  				-(_heightFirstRowTextBox + widthTextBoxOffset),	bHeaderContour

if bHeaderSeparator then line2 0, -_heightFirstRowTextBox - widthTextBoxOffset, _widthFullFrame, -_heightFirstRowTextBox - widthTextBoxOffset
if bColumnSeparator then
	line2 _widthPrefixFrame, -_heightFirstRowTextBox - widthTextBoxOffset, _widthPrefixFrame, - _heightFullFrame
endif
if bLineSeparator and _numberofRow > 1 then
	for i = 1 to _numberofRow - 1
		if i = 1 then
			add2 0, -_heightRow[i] - widthTextBoxOffset
		else
			add2 0, -_heightRow[i]
		endif
		if not(_isMergeContentRows[i+1]) then
			line2 0, 0, _widthFullFrame, 0
		endif
	next i
	del _numberofRow - 1
endif

hotline2  0, 				0,					_widthFullFrame, 	0,					unID : unID = unID + 1
hotline2  _widthFullFrame, 	0, 					_widthFullFrame,	-_heightFullFrame, 	unID : unID = unID + 1
hotline2  _widthFullFrame,	-_heightFullFrame, 	0, 					-_heightFullFrame, 	unID : unID = unID + 1
hotline2  0, 				-_heightFullFrame, 	0, 					0, 					unID : unID = unID + 1


! ==============================================================================
END !END	!END	!END	!END	!END	!END	!END	!END	!END	!END
! ==============================================================================

! ==============================================================================
"usePharagraph" :
! ------------------------------------------------------------------------------
! input for paragraph:
! 		_iAlignment					! 1: left aligned, 2: center aligned, 3: right aligned, 4: full justified
!		_penindex					! text pen
!		_ratioLineSpace				! (character size + distance to the next line) defined by the actual style will be multiplied by this number
!		xFirstIndentParagraph		! meaning millimeters or meters depends on the fixed_height parameter of the TEXTBLOCK definition
!		xLeftIndentParagraph		! meaning millimeters or meters depends on the fixed_height parameter of the TEXTBLOCK definition
!		xRightIndentParagraph		! meaning millimeters or meters depends on the fixed_height parameter of the TEXTBLOCK definition
!		xTabPositionParagraph		! consecutive tabulator positions (each relative to the beginning of the paragraph). Default values (0) are used (12.7 mm). Works only with '\t' special character.
!		sPrefixStrings[]			! prefix column strings
!		sContentStrings[][30]		! content column strings
!		_sStylePrefix[]				! style for prefix
!		_sStyleBody[][30]			! style for content
!
! input for textblock:
!		_widthTextBlock				! textblock width in mm or m in model space, if 0 it is calculated automatically
!		anglePosition				! rotation angle of the textblock in degrees
!		_iReferencePoint				! code of the position point in the text 1-9
!		widthFactorTextBlock		! width_factor: Character widths defined by the actual style will be multiplied by this number		
!		charspaceFactorTextBlock	! charspace_factor: The horizontal distance between two characters will be multiplied by this number! output:
!		iFixedHeightTextBlock		! fixed_height: Possible values: 	1: the placed TEXTBLOCK will be scale-independent and all specified length type parameters will mean millimeters, !
!		 																0: the placed TEXTBLOCK will be scale-dependent and all specified length type parameters will mean meters in model space
!		_drawRichText				! use richtext (1) or just calculate textblock sizes (0)
! output:
!		texbox sizes - _widthTB, _heightTB
! ==============================================================================
	pen _penindex

	doSplit = '\n'

	_stNamePG 			= "nameParaGraph"
	_iAlignPG 			= _iAlignment				! 1: left aligned, 2: center aligned, 3: right aligned, 4: full justified
	_xFirstIndentPG	 	= xFirstIndentParagraph		! meaning millimeters or meters depends on the fixed_height parameter of the TEXTBLOCK definition
	_xLeftIndentPG 		= xLeftIndentParagraph		! meaning millimeters or meters depends on the fixed_height parameter of the TEXTBLOCK definition
	_xRightIndentPG 	= xRightIndentParagraph		! meaning millimeters or meters depends on the fixed_height parameter of the TEXTBLOCK definition
	_ratioLineSpacePG	= _ratioLineSpace			! (character size + distance to the next line) defined by the actual style will be multiplied by this number
	_xTabPosPG	 		= xTabPositionParagraph		! consecutive tabulator positions (each relative to the beginning of the paragraph). Default values (0) are used (12.7 mm). Works only with '\t' special character.
	_penindexPG			= _penindex

	if _usePrefixChapter = 1 then
		paragraph _stNamePG _iAlignPG,
			_xFirstIndentPG, _xLeftIndentPG, _xRightIndentPG,
			_ratioLineSpacePG, _xTabPosPG,
			_penindexPG
			style _sStylePrefix[i]
			sPrefixStrings[i]
		endparagraph
	else
		paragraph _stNamePG _iAlignPG,
			_xFirstIndentPG, _xLeftIndentPG, _xRightIndentPG,
			_ratioLineSpacePG, _xTabPosPG,
			_penindexPG
			style _sStyleBody[i][1]
			_sContentStrings[i][1]
			style _sStyleBody[i][2]
			_sContentStrings[i][2]
			style _sStyleBody[i][3]
			_sContentStrings[i][3]
			style _sStyleBody[i][4]
			_sContentStrings[i][4]
			style _sStyleBody[i][5]
			_sContentStrings[i][5]
			style _sStyleBody[i][6]
			_sContentStrings[i][6]
			style _sStyleBody[i][7]
			_sContentStrings[i][7]
			style _sStyleBody[i][8]
			_sContentStrings[i][8]
			style _sStyleBody[i][9]
			_sContentStrings[i][9]
			style _sStyleBody[i][10]
			_sContentStrings[i][10]
			style _sStyleBody[i][11]
			_sContentStrings[i][11]
			style _sStyleBody[i][12]
			_sContentStrings[i][12]
			style _sStyleBody[i][13]
			_sContentStrings[i][13]
			style _sStyleBody[i][14]
			_sContentStrings[i][14]
			style _sStyleBody[i][15]
			_sContentStrings[i][15]
			style _sStyleBody[i][16]
			_sContentStrings[i][16]
			style _sStyleBody[i][17]
			_sContentStrings[i][17]
			style _sStyleBody[i][18]
			_sContentStrings[i][18]
			style _sStyleBody[i][19]
			_sContentStrings[i][19]
			style _sStyleBody[i][20]
			_sContentStrings[i][20]
			style _sStyleBody[i][21]
			_sContentStrings[i][21]
			style _sStyleBody[i][22]
			_sContentStrings[i][22]
			style _sStyleBody[i][23]
			_sContentStrings[i][23]
			style _sStyleBody[i][24]
			_sContentStrings[i][24]
			style _sStyleBody[i][25]
			_sContentStrings[i][25]
			style _sStyleBody[i][26]
			_sContentStrings[i][26]
			style _sStyleBody[i][27]
			_sContentStrings[i][27]
			style _sStyleBody[i][28]
			_sContentStrings[i][28]
			style _sStyleBody[i][29]
			_sContentStrings[i][29]
			style _sStyleBody[i][30]
			_sContentStrings[i][30]
		endparagraph
	endif

	_stNameTB			= "nameTextBlock"
	_widthTB			= _widthTextBlock
	_angleTB			= 0 			! table elements dont use readable rotation by rows (full table rotating instead)
	if not(bAlwaysReadable) | (bAlwaysReadable and _angleTB < 180-EPS) then
		_iAnchorTB	= _iReferencePoint
	else
		_iAnchorTB  = 5
		if _iReferencePoint	= 1 then _iAnchorTB = 9
		if _iReferencePoint	= 2 then _iAnchorTB = 8
		if _iReferencePoint	= 3 then _iAnchorTB = 7
		if _iReferencePoint	= 4 then _iAnchorTB = 6
		if _iReferencePoint	= 6 then _iAnchorTB = 4
		if _iReferencePoint	= 7 then _iAnchorTB = 3
		if _iReferencePoint	= 8 then _iAnchorTB = 2
		if _iReferencePoint	= 9 then _iAnchorTB = 1
	endif
	_ratioWidthTB		= widthFactorTextBlock			! width_factor: Character widths defined by the actual style will be multiplied by this number
	_ratioCharspaceTB	= charspaceFactorTextBlock		! charspace_factor: The horizontal distance between two characters will be multiplied by this number
	_iScale 			= iFixedHeightTextBlock			! fixed_height: Possible values: 		1: the placed TEXTBLOCK will be scale-independent and all specified length type parameters will mean millimeters, 
														!		 								0: the placed TEXTBLOCK will be scale-dependent and all specified length type parameters will mean meters in model space.

	textblock _stNameTB _widthTB,
		_iAnchorTB, _angleTB, _ratioWidthTB, _ratioCharspaceTB, _iScale,
		_stNamePG

	rrr = REQUEST ("TEXTBLOCK_INFO", _stNameTB, _widthTB, _heightTB)

	if _drawRichText then
		richtext2 _xPosTB, _yPosTB, _stNameTB
	endif
return
