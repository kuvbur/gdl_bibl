
if nRows = 4 & gs_ui_current_page = idTab_AdditionalWork & GLOB_PREVIEW_MODE = 1 then
	gosub "drawAdditionalWork"
	end 
endif 

! ================================================================================
! Lines, hotspots, sizing, attributes
! ================================================================================

! --------------------------------------------------------------------------------
! Enable Frame in Editing Contexts
! --------------------------------------------------------------------------------
_bEditingContext = (GLOB_CONTEXT = 28 | GLOB_CONTEXT = 22 | GLOB_CONTEXT = 28)
_blockWidth = (A-_gapSumWidth)/nBlocks
_bEnableEmptyRowLines = (bShowVertLines | bShowHorizLines)

! --------------------------------------------------------------------------------
! Bounding Box Strech Hotspots
! --------------------------------------------------------------------------------
unID = 1
gosub "boundingBoxHotspots"


! --------------------------------------------------------------------------------
! Display Fill, Frame, block bounding hotlines and feedback lines for editing
! --------------------------------------------------------------------------------
fill fillStamp
pen penFrame
line_type lineTypeFrame
_hotlineID = 1000

gosub "fillFrameLinesAndBlockHotlines"

! --------------------------------------------------------------------------------
! Define Text Style for Data Textblock, Title and Watermark
! --------------------------------------------------------------------------------
gosub "defineTextStyleAttributes"

! --------------------------------------------------------------------------------
! Title hotlines, hotspots and feedback lines in editing mode
! --------------------------------------------------------------------------------
if bDisplayHeader then
	gosub "headerHotlinesHotspotsEditingLines"
endif


! --------------------------------------------------------------------------------
! Display vertical and horizontal feedback lines in editing mode
! --------------------------------------------------------------------------------
gosub "vertHorEditingLines"


! --------------------------------------------------------------------------------
! Watermark
! --------------------------------------------------------------------------------
gosub "watermarkLinesText"


! ================================================================================
! Creating Data Containers if we have existing data
! ================================================================================
_bEmptyDisplayRevisionData = 0

if not(_bEmptyLayoutRevHistory) then
	_nAllRevCol	= vardim2(LayoutRevHistory)
	_nAllRevRow	= vardim1(LayoutRevHistory)
	_nAllChangeCol	= vardim2(LayoutChangeHistory)
	_nAllChangeRow	= vardim1(LayoutChangeHistory)
	_numFullDataCol	= _nAllRevCol+(_nAllChangeCol-1)		! Revision ID is duplicated in both-> -1
	
	dim _stChangeData[][]			! all data from Change Array for operations
	dim _stRevisionData[][]			! all data from Revision Array for operations
	
	
	if iLayoutType = LAYOUT_SIMPLE then
	! --------------------------------------------------------------------------------
	! Collapse Change data: merge column cells belonging to same revision
	! --------------------------------------------------------------------------------
	
		dim _stCollapsedChData[][]
			for h = 1 to _nAllChangeCol
				for kk = 1 to _nAllChangeRow
					_stCollapsedChData[kk][h] = ""
				next kk
			next h
	
		dim _stChangeDataForSub[][]
		
		_stChangeDataForSub = LayoutChangeHistory
		gosub "collapseChangeData"
	
		_stChangeData = _stCollapsedChData
		_stRevisionData = LayoutRevHistory
	else
		_stChangeData = LayoutChangeHistory
		_stRevisionData = LayoutRevHistory
	endif
	
	! --------------------------------------------------------------------------------
	! Gather all revision data in 1 array for further horizontal slicing (filters)
	! --------------------------------------------------------------------------------
	!	_stChangeData: original or collapsed Change data (LAYOUT_CHANGE_HISTORY global)
	!	_stRevisionData: original Revision data (LAYOUT_REVISION_HISTORY global)
	
	dim _fullRevisionData[][]		! merged original Revision data from AC
	
	gosub "getFullRevisionData"

	! force "empty" string into previously non-inicilized cells
	! can not initialize before, no way to calculate full data dimensions in advance
	for i= 1 to vardim1(_fullRevisionData)
		for j = 1 to vardim2(_fullRevisionData)
			if vartype(_fullRevisionData[i][j]) = 1 then
				_fullRevisionData[i][j] = ""
			endif
		next j	
	next i

	! --------------------------------------------------------------------------------
	! Debug function for _fullRevisionData
	! Check if all cells are strings and inicialized after data merge
	! --------------------------------------------------------------------------------
!!!	for iRows = 1 to vardim1(_fullRevisionData)
!!!		for iCols = 1 to vardim2(_fullRevisionData)
!!!			set style "emptyTextStyle"
!!!			text2 0.02*iCols, 0.003*iRows, strlen(_fullRevisionData[iRows][iCols])
!!!		next iCols
!!!	next iRows


	! --------------------------------------------------------------------------------
	! Transfer array for containing actual rows of revision data for input of subroutines,
	! reset and modified with the latest data after every stage, or left with the previous data
	! --------------------------------------------------------------------------------
	dim _actUsedRevisonData[][]
	
	_actUsedRevisonData = _fullRevisionData


	! --------------------------------------------------------------------------------
	! Calculate first active row index (regarding boolean filters condition)
	! --------------------------------------------------------------------------------
	_idxFirstActiveRevision = 0
	
	if bShowLatestRevisonOnly | not(bDisplayFirstRevision) then
		! active boolean filters
		gosub "getFilteredRowStartIndex"
	else
		! no filter, start from the beginning
		_idxFirstActiveRevision = 1
	endif


	! --------------------------------------------------------------------------------
	! Get all filtered data (rows) from selected data array using _idxFirstActiveRevision
	! If no boolean filter is used, the data in filtered arrays is the same as selected arrays
	! --------------------------------------------------------------------------------
	dim _allFilteredRevisionData[][]	! array variable for data rows remaining after using boolean filters
	
	if (vardim1(_actUsedRevisonData) > 0) then
		if bShowLatestRevisonOnly | not(bDisplayFirstRevision) then
			gosub "getFilteredRowsData"
			! use result array for next step by overwriting the transfer array, reset to empty
			dim _actUsedRevisonData[][]
			_actUsedRevisonData = _allFilteredRevisionData
		endif
	else
		_bEmptyDisplayRevisionData = 1
	endif
	
	
	! --------------------------------------------------------------------------------
	! Use custom filters to sort assembled data,
	! only rows matching the criteria will be included in the result data array
	! --------------------------------------------------------------------------------
	dim _allCustFilteredRevisionData[][]	! data rows remaining after executing custom filter options
	
	if (vardim1(_actUsedRevisonData) > 0) then
		if bUseCustomRowFilter then
			_nUsedDataCol = vardim2(_actUsedRevisonData)
		
			! Find index of criteria column by searching all scheme titles----------------------------------
			_idxColCustFilterCriteria = 0
			_idxColumn = 1	
			for _idxColumn = 1 to _nUsedDataCol
				if stCustFilterColumnID = _allSchemeTitleID[_idxColumn] then
					_idxColCustFilterCriteria = _idxColumn
					! exit cycle
					_idxColumn = _nUsedDataCol
				endif
			next _idxColumn
		
			! Match criteria index column data to criteria text (stCustFilterConditionText)------------------------
			_bHasFilterTargetRow = 0
			dim _bRowMatchCustFilterCriteria[]		! array to mark matching row idx, 1: use, 0: leave out
	
			_idxInicialize = 1
			for _idxInicialize = 1 to vardim1(_actUsedRevisonData)
				_bRowMatchCustFilterCriteria[_idxInicialize] = 0
			next _idxInicialize
	
			if _idxColCustFilterCriteria > 0 then
				gosub "matchCustFilterCriteria"
			endif
			
			! only filter _actUsed array if some data row has matching criteria text
			if _bHasFilterTargetRow = 1 then
				gosub "getCustomFilteredRowsData"
				! use result array for next step by overwriting the transfer array, reset to empty
				dim _actUsedRevisonData[][]
				_actUsedRevisonData = _allCustFilteredRevisionData
			else
				! no matching row for filter, nothing to display or work with in the next step, reset working array to empty
				dim _actUsedRevisonData[][]
				_bEmptyDisplayRevisionData = 1
			endif
		endif
	else
		_bEmptyDisplayRevisionData = 1
	endif
	

	
	! --------------------------------------------------------------------------------
	! Sorting order
	! --------------------------------------------------------------------------------
	dim _allSortedRevisionData[][]		! output all filtered rows from selected columns (multiple block included)
	
	if (vardim1(_actUsedRevisonData) > 0) then
		gosub "getSortedRowsData"
		! use result array for next step by overwriting the transfer array, reset to empty
		dim _actUsedRevisonData[][]
		_actUsedRevisonData = _allSortedRevisionData
	else
		_bEmptyDisplayRevisionData = 1
	endif
	

	! --------------------------------------------------------------------------------
	! Collect sorted RevID-s for cell merging info, used in DinamicTableWriter Macro
	! --------------------------------------------------------------------------------
	!		_textMergeClass[][]:	array variable containing Revision IDs in all columns


	dim _textMergeClass[][]

	for _idxInicialize = 1 to nRows
		idxInicializeCol = 1
		for idxInicializeCol = 1 to nColumns
			_textMergeClass[_idxInicialize][idxInicializeCol] = ""
		next idxInicializeCol
	next _idxInicialize

	if (vardim1(_actUsedRevisonData) > 0) then
		for _idxRow = 1 to vardim1(_actUsedRevisonData)
			_idxCol = 1
			for _idxCol = 1 to nColumns
				! fill up all rows with Revision IDs (first column)
				_textMergeClass[_idxRow][_idxCol] = _actUsedRevisonData[_idxRow][1]
			next _idxCol
		next _idxRow
	else
		_bEmptyDisplayRevisionData = 1
	endif

	
	!------------------------------------------------------------------------------------------------
	! Find criteria match and mark RevID column if Show NCS Marker is ON
	!------------------------------------------------------------------------------------------------
	!		_stRevisionData[][]:	original Revision data variable (LAYOUT_REVISION_HISTORY global)
	!		_issueSchemeTitleID[]:	array variable (String), header IDs collected from GlobIssueScheme for NCS marker head UI selection 
	!		_issueSchemeName[]:		array variable (String), header Names collected from GlobIssueScheme for NCS marker head UI selection values
	
	if (vardim1(_actUsedRevisonData) > 0) then
		if bShowNCSRevisionMarker then
			__nUsedDataRows = vardim1(_actUsedRevisonData)
			__nUsedDataCol = vardim2(_actUsedRevisonData)
		
			dim _bRowMatchNCSCriteria[]		! array to mark matching row idx
		
			for _idxInicialize = 1 to __nUsedDataRows
				_bRowMatchNCSCriteria[_idxInicialize] = 0
			next _idxInicialize
		
			! Find index of criteria column -------------------------------------------------------------
			_idxColNCSCriteria = 0
		
			for _idxColumn = 1 to __nUsedDataCol
				if stNCSConditionColumnID = _allSchemeTitleID[_idxColumn] then
					_idxColNCSCriteria = _idxColumn
					! exit cycle
					_idxColumn = __nUsedDataCol
				endif
			next _idxColumn
		
			! Match criteria index column data to criteria text (stNCSConditionText)------------------------
			if _idxColNCSCriteria > 0 then
				gosub "matchNCSCriteria"
			
				! Mark selected and dispalyed Revision ID columns--------------------------------------------
				dim _bDisplayedRevIDColumn[]		! ON: selected and displayed column is Revision ID
			
				for i = 1 to nColumns
					_bDisplayedRevIDColumn[i] = 0
				next i
			
				_idxSelectedCol = 1
				for _idxSelectedCol = 1 to nColumns
					if selectedColumnIDs[_idxSelectedCol] = _allSchemeTitleID[1] then
						! if the actual selected column is a Revision ID column, set value to TRUE
						_bDisplayedRevIDColumn[_idxSelectedCol] = 1
					endif
				next _idxSelectedCol
			endif
		endif
	else
		_bEmptyDisplayRevisionData = 1
	endif
	
	! --------------------------------------------------------------------------------
	! Debug function for _actUsedRevisonData
	! Last point of use
	! --------------------------------------------------------------------------------

!!!	for iRows = 1 to vardim1(_actUsedRevisonData)
!!!		for iCols = 1 to vardim2(_actUsedRevisonData)
!!!			set style "emptyTextStyle"
!!!			text2 0.02*iCols, 0.003*iRows, _actUsedRevisonData[iRows][iCols]
!!!		next iCols
!!!	next iRows



	! --------------------------------------------------------------------------------
	! Collect selected data columns from all data array
	! --------------------------------------------------------------------------------
	dim _selectedRevisionData[][]	! array containing data only from selected columns

	dim _bMergeColumnFlag[]	! indicate revision data origin for merging selected revision cells in column
	for _idxInicialize = 1 to nColumns
		_bMergeColumnFlag[_idxInicialize] = 0
	next _idxInicialize

	if (vardim1(_actUsedRevisonData) > 0) then
		gosub "getSelectedColumnsData"
	else
		_bEmptyDisplayRevisionData = 1
	endif

	! --------------------------------------------------------------------------------
	! Debug function for _selectedRevisionData
	! Using this array from this point
	! --------------------------------------------------------------------------------
!!!	for iRows = 1 to vardim1(_selectedRevisionData)
!!!		for iCols = 1 to vardim2(_selectedRevisionData)
!!!			set style "emptyTextStyle"
!!!			text2 0.02*iCols, 0.003*iRows, _selectedRevisionData[iRows][iCols]
!!!		next iCols
!!!	next iRows

	
	! --------------------------------------------------------------------------------
	! Fill up NCS marker flag column for table drawing macro (using selected columns only)
	! --------------------------------------------------------------------------------
	dim _bMarkerCellFlag[][]			! variable array for tableWriter macro with marker enable flags

	if (vardim1(_selectedRevisionData) > 0) then
		_iRows = 1
		for _iRows = 1 to vardim1(_selectedRevisionData)
			_idxSelectedCol = 1
			for _idxSelectedCol = 1 to nColumns
				if bShowNCSRevisionMarker then
					if _bDisplayedRevIDColumn[_idxSelectedCol] = 1 & _bRowMatchNCSCriteria[_iRows] = 1 then
						_bMarkerCellFlag[_iRows][_idxSelectedCol] = 1
					else
						_bMarkerCellFlag[_iRows][_idxSelectedCol] = 0
					endif
				else
					_bMarkerCellFlag[_iRows][_idxSelectedCol] = 0
				endif
			next _idxSelectedCol
		next _iRows
	else
		_bEmptyDisplayRevisionData= 1
	endif
endif ! of not(_bEmptyLayoutRevHistory)


! ================================================================================
! Display Header
! ================================================================================
! Header Word Wrap and text function arrays
! --------------------------------------------------------------------------------
if bDisplayHeader then
	dim	_paragraphNames[]			! array for paragraph names for 1 row
	dim _textblockNames[]			! array for textblock names for 1 row
	_idxCol = 1
	for _idxCol = 1 to nColumns
		lengthString = 1
		if _idxCol > 9 then lengthString = 2
		_numString = str(_idxCol, lengthString, 0)
		_paragraphNames[_idxCol] = "paragraph_" + _numString
		_textblockNames[_idxCol] = "textblock_" + _numString
	next _idxCol
	
	_idxCol = 1
	_idxRow = 1
	_iBlocks = 1
	_textPosX = 0
	_textPosY = 0
	dim _nHeaderWrappedLines[]		! array for header wrapped line number
	
	! inicialize with 1 line
	_nMaxLinePerHeaderRow = 1

	gosub "headerDisplay"
endif


!==============================================================================
! Display data if any remains after the filters and selections, else just draw empty cells
! ================================================================================
if bDisplayHeader & iHeaderPosition = HEADER_TOP then
	add2 0, -headerRowHeight
endif

if not(_bEmptyDisplayRevisionData) & not(_bEmptyLayoutRevHistory) then
	! --------------------------------------------------------------------------------
	! Run calculation macro of line numbers with selected data array
	! --------------------------------------------------------------------------------
	dim _textDataMacro[][]
	dim _bRevColFlagMacro[]
	dim _bMarkerCellFlagMacro[][]
	dim _textMergeClassMacro[][]
	dim _lineEnds_closed[]
	dim _lineEnds_closedCalc[]

	_lineEnds_closed[1] = 0

	_lineNumDiff = 0

	_bDrawTable		= 0
	_nMaxLines = nRows*nBlocks
	_textDataMacro = _selectedRevisionData
	_bRevColFlagMacro = _bMergeColumnFlag
	_textMergeClassMacro = _textMergeClass
	_bMarkerCellFlagMacro = _bMarkerCellFlag
	if iDataAlign = ALIGN_TO_BOTTOM then
		bStartFromEnd = 1
	else
		bStartFromEnd = 0
	endif
	gosub "callTableWriter"

	! --------------------------------------------------------------------------------
	! Calculate data array slicing to ensure visibility of the last change
	! of the latest revision in all sorting/alignment types
	! --------------------------------------------------------------------------------
	_lineEnds_closedCalc = _lineEnds_closed
	_nAllAvailableRows = nRows * nBlocks
	_nAllDataRows = vardim1(_selectedRevisionData)					! number of all data rows
	_nAllMaxLineRows = _lineEnds_closed[vardim1(_lineEnds_closed)]	! number of all rows nominated for display without breaks (in last cell of returned array)

	_bRevColFlagMacro = _bMergeColumnFlag

	if nBlocks = 1 & (_nAllAvailableRows >= _nAllMaxLineRows) then
		! --------------------------------------------------------------------------------
		! Equal or more free lines than displayed lines without block-break,
		! simply draw data, no need to recalculate used line numbers
		! --------------------------------------------------------------------------------
		_bDrawTable = 1
		_nMaxLines = nRows
		_textDataMacro = _selectedRevisionData
		_bMarkerCellFlagMacro = _bMarkerCellFlag
		_textMergeClassMacro = _textMergeClass

		gosub "callTableWriter"

		! adding empty lines
		_lineNumDiff = max(_nAllAvailableRows - _nAllMaxLineRows)
		_nUsedBlockLineRows = _nAllMaxLineRows
		if (_bEnableEmptyRowLines & bShowLinesEmptyRows) then
			gosub "emptyFillLines"
		endif
	else
		! --------------------------------------------------------------------------------
		! Block-breaks can modify precalculated used line numbers (breaks inside revisions),
		! so section beginning-end index recalculations are needed to ensure
		! the visibility of the latest revision (or last change of latest revision)
		! --------------------------------------------------------------------------------
		_idxStartBlockSliceDataRow = 1		! starting calculations with first index, increment later if necessary
		_bCalculationSuccess = 0

		do
			! start cycle with reset data
			_iBlocks = 1
			dim _idxFirstDataRowBlock[]
			dim _idxLastDataRowBlock[]

			! inicialize
			_idxFirstDataRowBlock[1] = _idxStartBlockSliceDataRow
			_idxLastDataRowBlock[1] = _idxStartBlockSliceDataRow
			_idxBlockSliceDataRow = _idxStartBlockSliceDataRow

			for _iBlocks = 1 to nBlocks
				! try to find the actual block's last data row index
				if _idxBlockSliceDataRow <= _nAllDataRows then
					_idxFirstDataRowBlock[_iBlocks] = _idxBlockSliceDataRow
					while	(_idxBlockSliceDataRow <= vardim1(_lineEnds_closedCalc)) &\
							(_idxBlockSliceDataRow <= _nAllDataRows)  do
								_idxLastDataRowBlock[_iBlocks] = _idxBlockSliceDataRow
								_idxBlockSliceDataRow = _idxBlockSliceDataRow + 1
					endwhile
				else
					_idxFirstDataRowBlock[_iBlocks] = 0
					_idxLastDataRowBlock[_iBlocks] = 0
				endif
	
				_idxSlice = 1
				! new clean array in every block cycle
				dim _sliceData[][]
				dim _sliceTextMergeClass[][]

				if _idxFirstDataRowBlock[_iBlocks] > 0 then
					_iDataRow = _idxFirstDataRowBlock[_iBlocks]
	
					for _iDataRow = _idxFirstDataRowBlock[_iBlocks] to _idxLastDataRowBlock[_iBlocks]
						_iCol = 1
						for _iCol = 1 to nColumns
							_sliceData[_idxSlice][_iCol] = _selectedRevisionData[_iDataRow][_iCol]
							_sliceTextMergeClass[_idxSlice][_iCol] = _textMergeClass[_iDataRow][_iCol]
						next _iCol
						_idxSlice = _idxSlice + 1
					next _iDataRow
				endif

				_linesToWrite = 0
				if vardim1(_sliceData) > 0 then
					_textDataMacro = _sliceData
					_textMergeClassMacro = _sliceTextMergeClass
					_nMaxLines = nRows
					_bDrawTable = 0
					if iDataAlign = ALIGN_TO_BOTTOM then
						bStartFromEnd = 1
					else
						bStartFromEnd = 0
					endif
					gosub "callTableWriter"
	
					! --------------------------------------------------------------------------------
					! Check if precalculated line number fits actual block-break affected line number
					! and if not, correct starting index for the next slice of data adding skipped indexes
					! --------------------------------------------------------------------------------
					
					if _linesToWrite <> (_idxLastDataRowBlock[_iBlocks] - _idxFirstDataRowBlock[_iBlocks]) + 1 then
						! block-break caused more/less used lines than free space
						_lineNumBlockBreakDifference = ((_idxLastDataRowBlock[_iBlocks] - _idxFirstDataRowBlock[_iBlocks]) + 1) - _linesToWrite
						_idxBlockSliceDataRow = _idxBlockSliceDataRow - _lineNumBlockBreakDifference
						_idxLastDataRowBlock[_iBlocks] = _idxBlockSliceDataRow - 1
					endif

					if (iDataSortingOrder = LATEST_TO_FIRST & iDataAlign = ALIGN_TO_TOP) |\
						(iDataSortingOrder = FIRST_TO_LATEST & iDataAlign = ALIGN_TO_BOTTOM) then
						! --------------------------------------------------------------------------------
						! in this mode combinations the latest revision is always automatically displayed first in the table,
						! no need to recalculate starting index, starting slice index does not change
						! --------------------------------------------------------------------------------
						_bCalculationSuccess = 1
					else
						! --------------------------------------------------------------------------------
						! The visibility of the latest revision must be ensured in any case,
						! (which has the last data index in these cases, _nAllDataRows)
						! so the first slicing start index must be incremented accordingly
						! --------------------------------------------------------------------------------
						if _nAllDataRows <= _idxLastDataRowBlock[_iBlocks] then
							! latest revision data's index is included in last block
							_bCalculationSuccess = 1
						else
							! latest revision data's index is still missing from last block, do again starting from the next starting data index
							_bCalculationSuccess = 0
						endif
					endif
				endif
			next _iBlocks
			! increase starter index for next run
			_idxStartBlockSliceDataRow = _idxStartBlockSliceDataRow + 1
		while (_bCalculationSuccess = 0) & (_idxStartBlockSliceDataRow <= _nAllDataRows)

		_iBlocks = 1
		for _iBlocks = 1 to nBlocks
			if _bCalculationSuccess then
				_idxSlice = 1
				! clean array in every block cycle for data and marker flag
				dim _sliceData[][]
				dim _sliceNCSMarkerFlag[][]
				dim _sliceTextMergeClass[][]

				if iDataAlign = ALIGN_TO_BOTTOM then
					add2 A - _blockWidth*_iBlocks - gapBetweenBlocks*(_iBlocks-1), 0
				endif

				_realLinesNum = 0
				if _idxFirstDataRowBlock[_iBlocks] > 0 then
					for _iDataRow = _idxFirstDataRowBlock[_iBlocks] to _idxLastDataRowBlock[_iBlocks]
						for _iCol = 1 to nColumns
							_sliceData[_idxSlice][_iCol] = _selectedRevisionData[_iDataRow][_iCol]
							_sliceTextMergeClass[_idxSlice][_iCol] = _textMergeClass[_iDataRow][_iCol]

							if bShowNCSRevisionMarker then
								_sliceNCSMarkerFlag[_idxSlice][_iCol] = _bMarkerCellFlag[_iDataRow][_iCol]
							else
								_sliceNCSMarkerFlag[_idxSlice][_iCol] = 0
							endif
						next _iCol
						_idxSlice = _idxSlice + 1
					next _iDataRow

					if _idxLastDataRowBlock[_iBlocks] > 0 then
						! data is available for display in current block
						_textDataMacro = _sliceData
						_bMarkerCellFlagMacro = _sliceNCSMarkerFlag
						_textMergeClassMacro = _sliceTextMergeClass
						_nMaxLines = nRows
						_bDrawTable = 1
						if iDataAlign = ALIGN_TO_BOTTOM then
							bStartFromEnd = 1
						else
							bStartFromEnd = 0
						endif
						gosub "callTableWriter"
					else
						! no more data to display, empty block
						_realLinesNum = 0
					endif
				endif

				_nUsedBlockLineRows = _realLinesNum
				_lineNumDiff = max(0, nRows - _nUsedBlockLineRows)
				if (_bEnableEmptyRowLines & bShowLinesEmptyRows) then
					gosub "emptyFillLines"
				endif
				if iDataAlign = ALIGN_TO_BOTTOM then
					del 1
				endif
				if iDataAlign = ALIGN_TO_TOP then
					add2 _blockWidth + gapBetweenBlocks, 0
				endif
			endif
		next _iBlocks
		if iDataAlign = ALIGN_TO_TOP & _bCalculationSuccess then
			del nBlocks
		endif
	endif
else
	! --------------------------------------------------------------------------------
	! Display empty cells (no data, just inner horizontal lines)
	! --------------------------------------------------------------------------------
	pen 1
	for _iBlocks = 1 to nBlocks
		for _countRows = 1 to nRows
			if (_countRows > 1) then
				gosub "drawHorizontalLine"
			endif
			gosub "drawVerticalLines"
			add2 0, -rowHeight
		next _countRows
		del nRows
		add2 _blockWidth + gapBetweenBlocks, 0
	next _iBlocks
	del nBlocks
endif
	
if bDisplayHeader & iHeaderPosition = HEADER_TOP then
	del 1
endif

! --------------------------------------------------------------------------------
end
! --------------------------------------------------------------------------------


! ==============================================================================
"emptyFillLines":
! ==============================================================================
	if iDataAlign = ALIGN_TO_TOP then
		add2 0, _nUsedBlockLineRows * (-rowHeight)
		if (_lineNumDiff < nRows) & (_lineNumDiff > 0) then
			gosub "drawHorizontalLine"
		endif
	else
		add2 0, 0
	endif

	for _iEmptyLines = 1 to _lineNumDiff
		if iDataAlign = ALIGN_TO_TOP & _iEmptyLines > 1 |\
			iDataAlign = ALIGN_TO_BOTTOM & _iEmptyLines > 1 then
			gosub "drawHorizontalLine"
		endif
		gosub "drawVerticalLines"
		add2 0, -rowHeight
	next _iEmptyLines
	if (_iEmptyLines <= nRows) & (iDataAlign = ALIGN_TO_BOTTOM) & (_lineNumDiff > 0) then
		gosub "drawHorizontalLine"
	endif
	del _lineNumDiff
	del 1
return


! ==============================================================================
"drawHorizontalLine":
! ==============================================================================
	pen penFrame
	line_type lineTypeSeparators
	if (bShowHorizLines & bShowLinesEmptyRows) then
		line2 0, 0, _blockWidth, 0
		hotline2 0, 0, _blockWidth, 0, _hotlineID : _hotlineID = _hotlineID + 1
	endif
return

! ==============================================================================
"drawVerticalLines":
! ==============================================================================
	_iCols = 1
	pen penFrame
	line_type lineTypeSeparators
	if (bShowVertLines & bShowLinesEmptyRows) then
		for _iCols = 1 to (nColumns-1)
			add2 columnWidths[_iCols], 0
			line2 0, 0, 0, -rowHeight
			hotline2 0, 0, 0, -rowHeight, _hotlineID : _hotlineID = _hotlineID + 1
		next _iCols
		del (nColumns-1)
	endif
return



! ==============================================================================
"headerDisplay":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		nBlocks:				parameter (Integer) number of Blocks if Multiple Blocks are displayed
!		nColumns:				parameter (Integer) for number of displayed columns set on UI
!		iHeaderPosition:		parameter (Integer) to set the Top/Bottom position of Title
!		headerRowHeight:		parameter (Length) for Title row height
!		iHeaderAlignment:		parameter (Integer) to set Title text alignment
!		_textPosX:				X coor value for text positioning transformation, calculated from actual textblock size and height of text row
!		_textPosY:				Y coor value for text positioning transformation, calculated from actual textblock size and height of text row
!		_textblockNames[]		variable string array to store text block names for cycle
!		__bMaxLineNumCalculation:	variable to enable/disable calculation mode (no actual drawing)
!		columnWidths[]:			parameter (Length) for width of columns
!	Output Parameters:
! ==============================================================================

	for _iBlocks = 1 to nBlocks
		_countRows = 1
		_countCols = 1

		for _countCols = 1 to nColumns
			_bMaxLineNumCalculation = 1
			gosub "headerParagraphAndLineWrap"
		next _countCols

		_countRows = 1
		_countCols = 1
		for _countCols = 1 to nColumns
			_bMaxLineNumCalculation = 0
			gosub "headerParagraphAndLineWrap"

			_nTransHeaderPos = 0
			if iHeaderPosition = HEADER_BOTTOM then
				add2 0, -B + headerRowHeight
				_nTransHeaderPos = _nTransHeaderPos + 1
			endif

			if (bShowVertLines & (_countCols < nColumns)) | _bEditingContext then
				pen penFrame
				line_type lineTypeSeparators
				line2 columnWidths[_countCols], 0, columnWidths[_countCols], -headerRowHeight
				hotline2 columnWidths[_countCols], 0, columnWidths[_countCols], -headerRowHeight, _hotlineID
				_hotlineID = _hotlineID + 1 
			endif

			if iHeaderAlignment = HEAD_ALIGN_CENTER then
				add2 0, -headerRowHeight/2
				_nTransHeaderPos = _nTransHeaderPos + 1
			else
				if iHeaderAlignment = HEAD_ALIGN_BOTTOM then
					add2 0, -headerRowHeight
					_nTransHeaderPos = _nTransHeaderPos + 1
				endif
			endif

			richtext2 _textPosX, _textPosY, _textblockNames[_countCols]
			del _nTransHeaderPos

			add2 columnWidths[_countCols], 0
		next _countCols
		del nColumns

		add2 _blockWidth + gapBetweenBlocks, 0
	next _iBlocks
	del nBlocks
return



! ==============================================================================
"getFullRevisionData":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		_nAllRevRow:			vardim1(LayoutRevHistory), full number of rows in array	
!		_nAllRevCol:			vardim2(LayoutRevHistory), full number of columns in array
!		_nAllChangeRow:			vardim1(LayoutChangeHistory), full number of rows in array
!		_nAllChangeCol:			vardim2(LayoutChangeHistory), full number of columns in array	
!		_numFullDataCol:			_nAllRevCol+_nAllChangeCol-1, Revision ID is duplicated in both, hence the -1
!		_stRevisionData[][]:	original Revision data (LAYOUT_REVISION_HISTORY global/LayoutRevHistory)
!		_stChangeData[][]:		original or collapsed Change data (LAYOUT_CHANGE_HISTORY global/LayoutChangeHistory)
!	Output Parameters:
!		_fullRevisionData[][]:	array containing merged revision and change data from revision manager
! ==============================================================================

	__idxFullDataRow = 0
	__idxChangeRow = 1
	__idxRevRow = 1

	do
		__idxFullDataRow = __idxFullDataRow + 1
		if __idxRevRow <= _nAllRevRow then
			! reading 1 row Revision column data
			for iRevCol = 1 to _nAllRevCol
				_fullRevisionData[__idxFullDataRow][iRevCol] = _stRevisionData[__idxRevRow][iRevCol]
			next iRevCol
		endif
		if (__idxChangeRow <= _nAllChangeRow) & (__idxRevRow <= _nAllRevRow) then
			if _stChangeData[__idxChangeRow][1] = _stRevisionData[__idxRevRow][1] then
				! Change belongs to actual Revision
				for _iChangeCol = 2 to _nAllChangeCol
					! concatenate Change column data to Revision data
					_fullRevisionData[__idxFullDataRow][_nAllRevCol+_iChangeCol-1] = _stChangeData[__idxChangeRow][_iChangeCol]
				next _iChangeCol
				if (__idxChangeRow+1) <= _nAllChangeRow then
					! next Change row Data, unless it was last
					if _stChangeData[__idxChangeRow+1][1] <> _stRevisionData[__idxRevRow][1] then
						! next Change belongs to another Revision
						__idxRevRow = __idxRevRow + 1
					endif
					__idxChangeRow = __idxChangeRow + 1
				else
					! no more remaining Change rows
					__idxRevRow = __idxRevRow + 1
				endif
			else
				! no (more) Change belonging to actual Reveision row, go to next Revision
				__idxRevRow = __idxRevRow + 1
			endif  
		else
			__idxRevRow = __idxRevRow + 1
			__idxChangeRow = __idxChangeRow + 1
		endif
	! do as long as there is a row left in Revision or Change array
	while (__idxRevRow <= _nAllRevRow | __idxChangeRow <= _nAllChangeRow) 
return


! ==============================================================================
"collapseChangeData":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		_nAllChangeRow:				vardim1(LayoutChangeHistory), full number of rows in array
!		_nAllChangeCol:				vardim2(LayoutChangeHistory), full number of columns in array
!		_stChangeDataForSub[][]:	buffer array for sub, this case containing LayoutChangeHistory[][]
!		separatorString:			parameter (String) for separating merged change cell data
!	Output Parameters:
!		_stCollapsedChData[][]:		array containing collapsed Change data for Simple Stamp
! ==============================================================================

	__idxChRow = 1
	__idxChCol = 1
	__idxCollRow = 1

	for __idxChRow = 1 to _nAllChangeRow
		for __idxChCol = 1 to _nAllChangeCol
			if __idxChRow = 1 then
				! first row goes directly into Collapsed array
				_stCollapsedChData[1][__idxChCol] = _stChangeDataForSub[1][__idxChCol]
			else
				if __idxChCol = 1 then
					! dont collapse Revision ID field
					_stCollapsedChData[__idxCollRow][1] = _stChangeDataForSub[__idxChRow][1]
				else
					if _stCollapsedChData[__idxCollRow][__idxChCol] = "" then
						_stCollapsedChData[__idxCollRow][__idxChCol] = _stChangeDataForSub[__idxChRow][__idxChCol]
					else
						! check for redundant data, skip if already listed
						__stSearchIn = separatorString + _stCollapsedChData[__idxCollRow][__idxChCol] + separatorString
						__stSearchWhat = separatorString + _stChangeDataForSub[__idxChRow][__idxChCol] + separatorString
						__bFoundMatch = STRSTR(__stSearchIn, __stSearchWhat)

						if __bFoundMatch = 0 & _stChangeDataForSub[__idxChRow][__idxChCol] <> "" then
							_stCollapsedChData[__idxCollRow][__idxChCol] = _stCollapsedChData[__idxCollRow][__idxChCol] + separatorString + _stChangeDataForSub[__idxChRow][__idxChCol]
						endif
					endif
				endif
			endif
		next __idxChCol
		if __idxChRow < _nAllChangeRow then
			if _stChangeDataForSub[__idxChRow][1] <> _stChangeDataForSub[__idxChRow+1][1] then
			! check Revision key of next row
				__idxCollRow = __idxCollRow + 1
			endif
		endif
	next __idxChRow
return


! ==============================================================================
"getSelectedColumnsData":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		nColumns:						parameter (Integer) for number of displayed columns set on UI
!		iLayoutType:					parameter (Integer) 1-Simple, 2-Detailed
!		_allSchemeTitleID[]:			array variable (String), all header column IDs corresponding _fullRevisionData array
!		_bAllEnableColCellMerge[]:			indicates if Column belongs to Issue(1) or Change(0) originally
!		_actUsedRevisonData[][]:		array containing merged revision and change data from revision manager
!		selectedColumnIDs[]:			array parameter (String), ID-s collected from stColumnData_n UI parameters (column data selected by user)
!	Output Parameters:
!		_selectedRevisionData[][]:		all rows of selected columns extracted from _fullRevisionData[][]
!		_bMergeColumnFlag[]:			indicates if selected Column belongs to Revison(1) or Change(0) originally
! ==============================================================================

	__idxSelectedCol = 1			! Selected column index
	__iCol	= 1
	
	for __idxSelectedCol = 1 to nColumns
		for __iCol = 1 to vardim1(_allSchemeTitleID)
			if selectedColumnIDs[__idxSelectedCol] = _allSchemeTitleID[__iCol] then
				__idxRow = 1
				for __idxRow = 1 to vardim1(_actUsedRevisonData)
					_selectedRevisionData[__idxRow][__idxSelectedCol] = _actUsedRevisonData[__idxRow][__iCol]
				next __idxRow
				if iLayoutType = LAYOUT_DETAILED then
					_bMergeColumnFlag[__idxSelectedCol] = _bAllEnableColCellMerge[__iCol]
				endif
			endif
		next __iCol
	next __idxSelectedCol
return


! ==============================================================================
"getFilteredRowStartIndex":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		_fullRevisionData[][]:			array containing merged revision and change data from revision manager
!		bShowLatestRevisonOnly:			parameter (Boolean) to only display the latest revision changes
!		bDisplayFirstRevision:			parameter (Boolean) to allow displaying the first revision's data
!	Output Parameters:
!		_idxFirstActiveRevision:		index of first active data line after filtering first or last revision's data
! ==============================================================================
	
	if bShowLatestRevisonOnly then
		__idxLatestRevisionID = vardim1(_fullRevisionData)

		! get idx of first data line belonging to the latest revision
		
		for __idxRow = vardim1(_fullRevisionData) to 1 step -1
			! get first data line index of the latest revision
			if _fullRevisionData[__idxRow][1] = _fullRevisionData[__idxLatestRevisionID][1] then
				_idxFirstActiveRevision = __idxRow
			else
				!break cycle, passed first row of latest revision
				__idxRow = 1
			endif
		next __idxRow
	else
		if not(bDisplayFirstRevision) then
			for __idxRow = 1 to vardim1(_fullRevisionData)
				! find first data line index of second revision data, skip the first revision data lines
				if _fullRevisionData[__idxRow][1] = _fullRevisionData[1][1] then
					_idxFirstActiveRevision = __idxRow + 1
				endif
			next __idxRow
		endif
	endif
return


! ==============================================================================
"getFilteredRowsData":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		_idxFirstActiveRevision:		index of first active data line after filtering first or last revision's data
!		_actUsedRevisonData[][]:		input array containing actual data (this case: _fullRevisionData[][])
!	Output Parameters:
! 		_allFilteredRevisionData[][]:	all available data in filtered rows of selected columns
! ==============================================================================
	__nUsedDataRows = vardim1(_actUsedRevisonData)
	__nUsedDataCol = vardim2(_actUsedRevisonData)

	if vardim1(_actUsedRevisonData) >= _idxFirstActiveRevision then
		! index is in valid range
		__idxRemainingRevisionRows = 1
		for _iRows = _idxFirstActiveRevision to __nUsedDataRows
			_iCols = 1
			for _iCols = 1 to __nUsedDataCol
				_allFilteredRevisionData[__idxRemainingRevisionRows][_iCols] = _actUsedRevisonData[_iRows][_iCols]
			next _iCols
			__idxRemainingRevisionRows = __idxRemainingRevisionRows + 1
		next _iRows
	else
		! fill up one line with empty strings for dummy info display function
		for _iCols = 1 to __nUsedDataCol
			_allFilteredRevisionData[1][_iCols] = ""
		next _iCols
	endif
return



! ==============================================================================
"getSortedRowsData":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		iDataSortingOrder: 			parameter (integer)	FIRST_TO_LATEST = 1, LATEST_TO_FIRST = 2
!		iDataAlign:					parameter (integer) ALIGN_TO_TOP = 1, ALIGN_TO_BOTTOM = 2
!		_actUsedRevisonData[][]:	array containing merged revision and change data from revision manager
!	Output Parameters:
! 		_allSortedRevisionData[][]:	all available data in sorted rows of selected columns
! ==============================================================================
	__nUsedDataRows = vardim1(_actUsedRevisonData)
	__nUsedDataCol = vardim2(_actUsedRevisonData)

	if vardim1(_actUsedRevisonData) > 0 then
		if	(iDataSortingOrder = LATEST_TO_FIRST & iDataAlign = ALIGN_TO_TOP) |\
			(iDataSortingOrder = FIRST_TO_LATEST & iDataAlign = ALIGN_TO_BOTTOM) then
			! fill up sorted arrays with reversed filtered arrays for drawing macro

			_iRows = 1
			for _iRows = 1 to __nUsedDataRows
				_iCols = 1
				for _iCols = 1 to __nUsedDataCol
					_allSortedRevisionData[_iRows][_iCols] = _actUsedRevisonData[__nUsedDataRows+1-_iRows][_iCols]
				next _iCols
			next _iRows
		else
			! sorted and filtered are in the same order, just copy
			_allSortedRevisionData = _actUsedRevisonData
		endif
	else
		! fill up one line with empty strings for dummy info display function
		_iCols = 1
		for _iCols = 1 to __nUsedDataCol
			_allSortedRevisionData[1][_iCols] = ""
		next _iCols
	endif
return



! ==============================================================================
"headerParagraphAndLineWrap":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		textIndent:					parameter (Length) for setting text indent
!		columnWidths[]:				parameter (Length) for width of columns
!		selectedColumnNames[]:		array parameter (String), names collected corresponding selectedColumnIDs[]
!		_bMaxLineNumCalculation:	calculation phase, saving data for next running of subroutine
!	Output Parameters:
!		_textPosX:					X coor value for text positioning transformation
!		_textPosY:					Y coor value for text positioning transformation
!		_nHeaderWrappedLines[][]:	number of cellrows needed to display wrapped header text
!		_nMaxLinePerHeaderRow:		number of maximum header rows for alignment calculations
! ==============================================================================

	__styleParagraph	= "headstyle"
	__penParagraph		= penHeaderText
	
	if bUseCustomHeaders[_countCols] = 1 then
		__paragraphString	= selectedCustHeaders[_countCols]
	else
		__paragraphString	= selectedColumnNames[_countCols]
	endif
	__textLineHeight = 0
	__textBlockHeight = 0
	__realTextBlockHeight = 0

	if _countCols <= nColumns then
		gosub "paragraphTextboxSizes"

		if __textLineHeight > 0 then
			_nHeaderWrappedLines[_countCols] = INT(__textBlockHeight / __textLineHeight)
			if _bMaxLineNumCalculation then
				! simulation run: save data on all row items for final drawing calculations
				_nMaxLinePerHeaderRow = max(_nMaxLinePerHeaderRow, _nHeaderWrappedLines[_countCols])
			endif
			__maxTextBlockHeight = _nMaxLinePerHeaderRow * __textLineHeight
			if iHeaderAlignment = HEAD_ALIGN_CENTER then
				_textPosY = __maxTextBlockHeight/2 - __textLineHeight/2*(_nMaxLinePerHeaderRow-_nHeaderWrappedLines[_countCols])
			else
				if iHeaderAlignment = HEAD_ALIGN_TOP then
					_textPosY = 0
				else
					_textPosY = __maxTextBlockHeight - __textLineHeight*(_nMaxLinePerHeaderRow-_nHeaderWrappedLines[_countCols])
				endif
			endif
		endif
	endif
	_textPosX = textIndent
return


! ==============================================================================
"paragraphTextboxSizes":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		iTextAlignments[]:			parameter (Integer array) for setting column alignment
!		textIndent:					parameter (Length) for setting text indent
!		columnWidths[]:				parameter (Length) for width of columns
!	Output Parameters:
!		_textPosX:					X coor value for text positioning transformation
!		_textPosY:					Y coor value for text positioning transformation
!		__realTextBlockHeight:		Height of text with line spacing above
! ==============================================================================

	__cellWidth = columnWidths[_countCols]-2*textIndent

	PARAGRAPH _paragraphNames[_countCols] iTextAlignments[_countCols], 0, 0, 0, 1, 0
		pen __penParagraph
		set style __styleParagraph
		__paragraphString
	ENDPARAGRAPH

	TEXTBLOCK _textblockNames[_countCols] __cellWidth, 1, 0, 1 , 1, 0, _paragraphNames[_countCols]

	nnn = REQUEST ("Height_of_style", __styleParagraph, __textLineHeight)
	__textBlockWidth = 0
	ttt = REQUEST ("TEXTBLOCK_INFO", _textblockNames[_countCols], __textBlockWidth, __textBlockHeight)

	__realTextBlockHeight = __textBlockHeight + (rowHeight/2 - __textLineHeight/2)
return


! ==============================================================================
"boundingBoxHotspots":
! ==============================================================================
	hotspot2 A, 		0, 			unID, B, 1+256		:unID=unID+1
	hotspot2 A, 		0.001,		unID, B, 3+128		:unID=unID+1
	hotspot2 A, 		-B, 		unID, B, 2			:unID=unID+1
	
	hotspot2 0, 		-B, 		unID, A, 1+256		:unID=unID+1
	hotspot2 -0.001,	-B, 		unID, A, 3+128		:unID=unID+1
	hotspot2 A,			-B, 		unID, A, 2			:unID=unID+1
	
	hotspot2 0, 		0, 			unID, A, 1+256		:unID=unID+1
	hotspot2 -0.001, 	0, 			unID, A, 3+128		:unID=unID+1
	hotspot2 A, 		0, 			unID, A, 2			:unID=unID+1
	
	hotspot2 0, 		0, 			unID, B, 1+256		:unID=unID+1
	hotspot2 0, 		0.001,		unID, B, 3+128		:unID=unID+1
	hotspot2 0, 		-B, 		unID, B, 2			:unID=unID+1
return


! ==============================================================================
"watermarkLinesText":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		nBlocks:				parameter (Integer) number of Blocks if Multiple Blocks are displayed
!		bWatermark:				parameter (Boolean) to enable/disable watermark text
!		LAYOUT_CURRENTREVISION_OPEN:	GDL global variable 1/0 last revision open/closed
!		iWMarkOrientation:		parameter (Integer) for watermark text orientation
!		gapBetweenBlocks:		parameter (Length) to set distance between 2 blocks of data
!		_blockWidth:			length variable, block width calculated from columnWidths[] parameters
!	Output Parameters:
! ==============================================================================
	for _iBlocks = 1 to nBlocks
		if bWatermark & LAYOUT_CURRENTREVISION_OPEN then
			__textRotAngle = atn(B/_blockWidth)
			pen penWatermarkText
			set style "waterMarkStyle"
			add2 _blockWidth/2, -B/2
			if iWMarkOrientation = LEFTTOP_RIGHTBOTTOM then
				rot2 -__textRotAngle
			else
				rot2 __textRotAngle
			endif
			text2 0, 0, stWatermark
			del 2
		endif
	
		add2 _blockWidth+gapBetweenBlocks, 0
	next _iBlocks
	del nBlocks
return



! ==============================================================================
"matchNCSCriteria":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		_actUsedRevisonData[][]:		input array containing actual data (this case: _fullRevisionData[][])
!		_idxColNCSCriteria:		criteria column index of _fullRevisionData[][]
!		iNCSConditionType:			integer parameter for condition type
!	Output Parameters:
!		_bRowMatchNCSCriteria[]:	array to mark criteria row match, inicialized to OFF (ON: row criteria matches condition text)
!		_bHasNCSTargetRow:			indicator of at least one row's existence subject to NCS marker
! ==============================================================================
	! reset for "findGeneralCriteriaMatch" subroutine	
	__bHasTargetRow = 0	

	for __idxRow = 1 to vardim1(_actUsedRevisonData)
		if not(_bEmptyLayoutRevHistory) then
			_stNCSUsedCellText = _actUsedRevisonData[__idxRow][_idxColNCSCriteria]
		else
			_stNCSUsedCellText = ""
		endif

		__iConditionType = iNCSConditionType
		__stUsedCellText = _stNCSUsedCellText
		__stConditionText = stNCSConditionText
		__bMatchCase = bNCSCaseSensitive
		__bRowMatchCriteria = 0
		gosub "findGeneralCriteriaMatch"
		_bRowMatchNCSCriteria[__idxRow] = __bRowMatchCriteria
	next __idxRow
	_bHasNCSTargetRow = __bHasTargetRow
return



! ==============================================================================
"matchCustFilterCriteria":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		_actUsedRevisonData[][]:		input array containing actual data (this case: _fullRevisionData[][])
!		_idxColCustFilterCriteria:		criteria column index
!		iCustFilterConditionType:		integer parameter for condition type
!	Output Parameters:
!		_bRowMatchCustFilterCriteria[]:	array to mark criteria row match, ON: row criteria matches condition text
!		_bHasFilterTargetRow:			indicator of at least one row's existence subject to custom filter
! ==============================================================================
	! reset for "findGeneralCriteriaMatch" subroutine	
	__bHasTargetRow = 0

	for __idxRow = 1 to vardim1(_actUsedRevisonData)
		if not(_bEmptyLayoutRevHistory) then
			_stCustCritUsedCellText = _actUsedRevisonData[__idxRow][_idxColCustFilterCriteria]
		else
			_stCustCritUsedCellText = ""
		endif

		__iConditionType = iCustFilterConditionType
		__stUsedCellText = _stCustCritUsedCellText
		__stConditionText = stCustFilterConditionText
		__bMatchCase = bCustFilterCaseSensitive
		__bRowMatchCriteria = 0
		gosub "findGeneralCriteriaMatch"
		_bRowMatchCustFilterCriteria[__idxRow] = __bRowMatchCriteria
	next __idxRow
	_bHasFilterTargetRow = __bHasTargetRow
return



! ==============================================================================
"findGeneralCriteriaMatch":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		__iConditionType:		iNCSConditionType or iCustFilterConditionType
!		__stUsedCellText:		text in actual data cell, subject to pattern matching
!		__stConditionText:		text pattern
!	Output Parameters:
!		__bRowMatchCriteria:	mark criteria row match, ON: row criteria matches condition text
!		__bHasTargetRow:		indicator of at least one row's existence subject to actual filter
! ==============================================================================
	if not(__bMatchCase) then
		__tmpCellText = STRTOLOWER(__stUsedCellText)
		__tmpCondText = STRTOLOWER(__stConditionText)
		__stUsedCellText = __tmpCellText
		__stConditionText = __tmpCondText
	endif

	if __iConditionType = COND_STARTSWITH | __iConditionType = COND_STARTSWITHNOT then
		n = strstr(__stUsedCellText, __stConditionText)
		if n = 1 then
			if __iConditionType = COND_STARTSWITH then
				__bRowMatchCriteria = 1
				__bHasTargetRow = 1
			endif
		else
			if __iConditionType = COND_STARTSWITHNOT then
				__bRowMatchCriteria = 1
				__bHasTargetRow = 1
			endif
		endif
	endif

	if __iConditionType = COND_ENDSWITH | __iConditionType = COND_ENDSWITHNOT then
		__subDataString = ""
		__startPosEndsWith = 1

		__charNumData = strlen(__stUsedCellText)
		__charNumConditionText = strlen(__stConditionText)
		__startPosEndsWith = __charNumData - __charNumConditionText + 1
		__subDataString = strsub(__stUsedCellText, __startPosEndsWith, __charNumConditionText)

		if __subDataString = __stConditionText then
			if __iConditionType = COND_ENDSWITH then
				__bRowMatchCriteria = 1
				__bHasTargetRow = 1
			endif
		else
			if __iConditionType = COND_ENDSWITHNOT then
				__bRowMatchCriteria = 1
				__bHasTargetRow = 1
			endif
		endif
	endif

	if __iConditionType = COND_CONTAINS | __iConditionType = COND_CONTAINSNOT then
		n = strstr(__stUsedCellText, __stConditionText)
		if n = 0 then
			if __iConditionType = COND_CONTAINSNOT then
				__bRowMatchCriteria = 1
				__bHasTargetRow = 1
			endif
		else
			if __iConditionType = COND_CONTAINS then
				__bRowMatchCriteria = 1
				__bHasTargetRow = 1
			endif
		endif
	endif

	if __iConditionType = COND_IS | __iConditionType = COND_ISNOT then
		if __stUsedCellText = __stConditionText then
			if __iConditionType = COND_IS then
				__bRowMatchCriteria = 1
				__bHasTargetRow = 1
			endif
		else
			if __iConditionType = COND_ISNOT then
				__bRowMatchCriteria = 1
				__bHasTargetRow = 1
			endif
		endif
	endif
return



! ==============================================================================
"getCustomFilteredRowsData":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		_actUsedRevisonData[][]:			array containing merged revision and change data from revision manager
!		_bRowMatchCustFilterCriteria[]:		array for marking all matching rows for custom filter criteria
!	Output Parameters:
! 		_allCustFilteredRevisionData[][]:	all available data in filtered rows of selected columns
! ==============================================================================
	__nUsedDataRows = vardim1(_actUsedRevisonData)
	__nUsedDataCol = vardim2(_actUsedRevisonData)
	
	__idxRemainingRevisionRows = 1
	_iRows = 1
	for _iRows = 1 to __nUsedDataRows
		if _bRowMatchCustFilterCriteria[_iRows] = 1 then
			! 1: include row in output
			_iCols = 1
			for _iCols = 1 to __nUsedDataCol
				_allCustFilteredRevisionData[__idxRemainingRevisionRows][_iCols] = _actUsedRevisonData[_iRows][_iCols]
			next _iCols
			__idxRemainingRevisionRows = __idxRemainingRevisionRows + 1
		endif
	next _iRows
return



! ==============================================================================
"fillFrameLinesAndBlockHotlines":
! ==============================================================================
	! --------------------------------------------------------------------------------
	! Background fill and frame polygon
	! --------------------------------------------------------------------------------
	poly2_b 5, (bShowFrame)+bShowFill*2+4, fillFgPenStamp, fillBgPenStamp,
		0, 0, bShowFrame,
		A, 0, bShowFrame,
		A, -B, bShowFrame,
		0, -B, bShowFrame,
		0, 0, -1

	_iBlocks = 1
	for _iBlocks = 1 to nBlocks
		! --------------------------------------------------------------------------------
		! Frame hotlines
		! --------------------------------------------------------------------------------
		hotline2 0, 0, 				_blockWidth, 0,  _hotlineID	: _hotlineID = _hotlineID + 1
		hotline2 0, 0, 				0, 			 -B, _hotlineID	: _hotlineID = _hotlineID + 1
		hotline2 _blockWidth, 0, 	_blockWidth, -B, _hotlineID	: _hotlineID = _hotlineID + 1
		hotline2 0, -B, 			_blockWidth, -B, _hotlineID	: _hotlineID = _hotlineID + 1

		if _bEditingContext then
		! --------------------------------------------------------------------------------
		! Frame editing lines
		! --------------------------------------------------------------------------------
			line_type 1
			line2 0, 0, 			_blockWidth, 0
			line2 0, 0, 			0, 			 -B
			line2 _blockWidth, 0, 	_blockWidth, -B
			line2 0, -B, 			_blockWidth, -B
			line_type lineTypeFrame
		endif

		! --------------------------------------------------------------------------------
		! Additional frame lines between blocks
		! --------------------------------------------------------------------------------
		if (_iBlocks > 1) & bShowFrame then
			line2 0, 0, 		0, 			 -B
		endif
		if (_iBlocks < nBlocks) & bShowFrame then
			line2 _blockWidth, 0, 	_blockWidth, -B
		endif
		add2 _blockWidth + gapBetweenBlocks, 0
	next _iBlocks
	del nBlocks
return



! ==============================================================================
"headerHotlinesHotspotsEditingLines":
! ==============================================================================
	_iBlocks = 1
	for _iBlocks = 1 to nBlocks
		! --------------------------------------------------------------------------------
		! Horizontal header editing lines/hotlines
		! --------------------------------------------------------------------------------
		if _bEditingContext then
			line_type 1
		else
			line_type lineTypeSeparators
		endif
		if iHeaderPosition = HEADER_TOP then
			hotline2 0, -headerRowHeight, _blockWidth, -headerRowHeight, _hotlineID	: _hotlineID = _hotlineID + 1
			if _bEditingContext | bShowHorizLines then
				line2 0, -headerRowHeight, _blockWidth, -headerRowHeight
			endif
		else
			hotline2 0, -B+headerRowHeight, _blockWidth, -B+headerRowHeight, _hotlineID	: _hotlineID = _hotlineID + 1
			if _bEditingContext | bShowHorizLines  then
				line2 0, -B+headerRowHeight, _blockWidth, -B+headerRowHeight
			endif
		endif

		! --------------------------------------------------------------------------------
		!Header hotspots to all columns
		! --------------------------------------------------------------------------------
		_countCols = 1
		__nTransHeader = 0
		if iHeaderPosition = HEADER_BOTTOM then
			add2 0, -B+headerRowHeight
			__nTransHeader = __nTransHeader + 1
		endif

		for _countCols = 1 to nColumns
			gosub "drawHeaderHotspots"
				
			add2 columnWidths[_countCols], 0
		next _countCols
		del nColumns
		del __nTransHeader

		add2 _blockWidth + gapBetweenBlocks, 0
	next _iBlocks
	del nBlocks
return


! ==============================================================================
"drawHeaderHotspots":
! ==============================================================================
	if _iBlocks = 1 then
		hotspot2 columnWidths[_countCols], 	0,	unID, headerRowHeight, 1+128				:	unID = unID + 1
		hotspot2 columnWidths[_countCols], 	1,	unID, headerRowHeight, 3					:	unID = unID + 1
		hotspot2 columnWidths[_countCols], 	-headerRowHeight,	unID, headerRowHeight, 2					:	unID = unID + 1

		hotspot2  0, 						-headerRowHeight,	unID, columnWidths[_countCols], 1+128		:	unID = unID + 1
		hotspot2 -1, 						-headerRowHeight,	unID, columnWidths[_countCols], 3			:	unID = unID + 1
		hotspot2 columnWidths[_countCols], 	-headerRowHeight,	unID, columnWidths[_countCols], 2			:	unID = unID + 1
	endif
return


! ==============================================================================
"vertHorEditingLines":
! ==============================================================================
	if _bEditingContext then
		line_type 1
	else
		line_type lineTypeSeparators
	endif

	_iBlocks = 1
	for _iBlocks = 1 to nBlocks
		if _bEditingContext then
			! --------------------------------------------------------------------------------
			! Horizontal and Vertical Editing Lines
			! --------------------------------------------------------------------------------
			__nTransHeader = 0
			if bDisplayHeader &	iHeaderPosition = HEADER_TOP then
				add2 0, -headerRowHeight
				__nTransHeader = __nTransHeader + 1
			endif
			__numEditingLineRows = nRows
			if bDisplayHeader &	iHeaderPosition = HEADER_BOTTOM then
				! header does it's own top line this case
				__numEditingLineRows = nRows -1
			endif
			for _countRows = 1 to __numEditingLineRows
				_countCols = 1
				line2 0, -rowHeight, _blockWidth, -rowHeight
				for _countCols = 1 to (nColumns-1)
					line2 columnWidths[_countCols], 0, columnWidths[_countCols], -rowHeight
					add2 columnWidths[_countCols], 0
				next _countCols
				del _countCols-1
				add2 0, -rowHeight
			next _countRows
			del __numEditingLineRows
	
			del __nTransHeader
		endif

		! --------------------------------------------------------------------------------
		! Hotspots
		! --------------------------------------------------------------------------------
		_countCols = 1
		for _countCols = 1 to nColumns
			if _iBlocks = 1 then

				if bDisplayHeader &	iHeaderPosition = HEADER_TOP then
					_referenceDistance = -headerRowHeight
				else
					_referenceDistance = 0
				endif
				gosub "drawEditableHotspots"
				gosub "drawGapHotspots"
			endif
			add2 columnWidths[_countCols], 0
		next _countCols
		del nColumns

		add2 _blockWidth + gapBetweenBlocks, 0
	next _iBlocks
	del nBlocks
return


! ==============================================================================
"drawEditableHotspots":
! ==============================================================================
	hotspot2 columnWidths[_countCols], 	_referenceDistance,				unID, rowHeight, 1+128				:	unID = unID + 1
	hotspot2 columnWidths[_countCols], 	1,				unID, 		rowHeight, 	3					:	unID = unID + 1
	hotspot2 columnWidths[_countCols], 	_referenceDistance-rowHeight,		unID, rowHeight, 2					:	unID = unID + 1

	hotspot2  0, 						_referenceDistance-rowHeight,	unID, columnWidths[_countCols], 1+128	:	unID = unID + 1
	hotspot2 -1, 						_referenceDistance-rowHeight,	unID, columnWidths[_countCols], 3		:	unID = unID + 1
	hotspot2 columnWidths[_countCols], 	_referenceDistance-rowHeight,	unID, columnWidths[_countCols], 2		:	unID = unID + 1
return



! ==============================================================================
"drawGapHotspots":
! ==============================================================================
	if (nBlocks > 1) & _countCols = nColumns then
		hotspot2  columnWidths[_countCols], 				0,	unID, gapBetweenBlocks, 1+128	:	unID = unID + 1
		hotspot2 -1, 										0,	unID, gapBetweenBlocks, 3		:	unID = unID + 1
		hotspot2 columnWidths[_countCols]+gapBetweenBlocks, 0,	unID, gapBetweenBlocks, 2		:	unID = unID + 1
	endif
return



! ==============================================================================
"defineTextStyleAttributes":
! ==============================================================================
	__styleHeaderTextBit = bHeaderTextBold + 2 * bHeaderTextItalic \
					 + 4 * bHeaderTextUnderLine + 128 * bHeaderTextStrikeThrough
	
	__styleTextBit = bTextBold + 2 * bTextItalic \
					 + 4 * bTextUnderLine + 128 * bTextStrikeThrough
	
	__styleTextBitWm = bWmTextBold + 2 * bWmTextItalic \
					 + 4 * bWmTextUnderLine + 128 * bWmTextStrikeThrough
	
	
	__fontSizeHeaderModel = fontSizeHeaderMm / 1000
	
	define style "headstyle"  fontTypeHeader, __fontSizeHeaderModel, 5, __styleHeaderTextBit
	
	__fontSizeTextModel = fontSizeTextMm / 1000
	define style "textStyle"  fontTypeText, __fontSizeTextModel, 5, __styleTextBit
	
	__watermarkFontSizeModel = fontSizeWatermarkMm / GLOB_SCALE
	define style "waterMarkStyle"  fontTypeWatermark, __watermarkFontSizeModel, 5, __styleTextBitWm
	
	__fontSizeEmptyModel = fontSizeTextMm / GLOB_SCALE
	define style "emptyTextStyle" fontTypeText, __fontSizeEmptyModel, 5, __styleTextBit
return


! ==============================================================================
"callTableWriter":
! ==============================================================================
	call "DynamicTableWriter" parameters	bDebugMode		= 0,
											bDrawTable		= _bDrawTable,
	
											! table content, column widths, merging info
											textData		= _textDataMacro,
											textMergeClass	= _textMergeClassMacro,
											bMergeColumn	= _bRevColFlagMacro,
											columnAlignments= iTextAlignments,
											
											! text style parameters
											bEnableAllLines		= 0,
											bEnableUnitIndex	= 0,
											bUnitIndex			= 0,
											fontTypeText		= fontTypeText,
											fontSizeTextMm		= fontSizeTextMm,
											styleTextBit		= __styleTextBit,
											penText				= penText,
											leftTextIndentMm 	= textIndent*1000/GLOB_SCALE,
											rightTextIndentMm 	= textIndent*1000/GLOB_SCALE,
	
											! table formatting, ordering
											cellHeightMm		= rowHeight*1000/GLOB_SCALE,
											columnWidths		= columnWidths,
											nMaxLines			= _nMaxLines,
											bStartFromEnd		= bStartFromEnd,
											bFrameOutside		= 0,
											bBottomFrame		= 1,
											bTopFrame			= 1,
											bSideFrame			= 1,
											bFrameInsideVertical = bShowVertLines,
											bFrameInsideHorizontal= bShowHorizLines,
											penFrame			= penFrame,
											bEnableHotlines		= 1,
											hotlineID			= _hotlineID,
											
											! marker parameters
											bShowCellDataMarker	= bShowNCSRevisionMarker,
											bMarkerCellFlag		= _bMarkerCellFlagMacro,
											penMarker			= penNCSMarker,
											sizeMarker			= sizeNCSMarker,
				returned_parameters _hotlineID,
									_linesToWrite,		! number of lines written from the input textdata table
									_realLinesNum,		! number of lines used with the given fixed cell height
									_dummy,
									_lineEnds_closed	! sum height to this line


return


! ==============================================================================
"drawAdditionalWork":
! ==============================================================================
	_modSize = 1
	if (GLOB_VIEW_TYPE = 8) then
		_modSize = 100
	endif
	define style "funStyle"  fontTypeText, _modSize*2*a/3, 5, 0
	set style "funStyle"
	set fill fillStamp

	poly2 4, 1+2+4,
		0,	0,
		a,	0,
		a,	a,
		0,	a
	
	for i2 = 0 to 4
		line2 0,		i2*a/4,		a,			i2*a/4
		line2 i2*a/4,	0,			i2*a/4,		a
	next i2
	
	for _j = 1 to 4
		for _i = 1 to 4
			if dataGame[_i][_j] = 0 then
			else
				pen log(dataGame[_i][_j])/log(2)
				text2 (2*_j-1)*a/8,	(9-2*_i)*a/8, dataGame[_i][_j]
			endif
		next _i
	next _j

	if bGameOver then
		pen penWatermarkText
		line2 0, 0, A, A
		line2 0, A, A, 0
	endif
return



