
! ==============================================================================
! escalator_m
! ==============================================================================


if gs_detlevel_3D_m = 0 then end
if not(gs_shadow) then SHADOW OFF

grooveWidth = 0
grooveDepth = 0
if gs_detlevel_3D_m = 2 then
	grooveWidth = 0.01
	grooveDepth = 0.005
endif
balustradeFooting = 0.3

trussLowerRad = 2.53
if landingHeight > 0 then
if landingLength >= A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread)) - ((riserBegin - 0.02) / tan(inclination)) - 0.02 / sin(inclination) - trussLowerRad * tan(inclination/2) then
	trussLowerRad = (A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread)) - ((riserBegin - 0.02) / tan(inclination)) - 0.02 / sin(inclination) - landingLength) / tan(inclination/2) - 0.01
endif
endif
trussUpperRad = 1.07
if landingHeight - trussLowerRad * (1 - cos(inclination)) - trussUpperRad * (1 - cos(inclination)) < 0.01 & inclination > 0 then
	trussLowerRad = (landingHeight - trussUpperRad * (1 - cos(inclination)) - 0.01) / (1 - cos(inclination))
	if trussLowerRad < trussLowerRadMin then
		trussLowerRad = trussLowerRadMin
		trussUpperRad = (landingHeight - trussLowerRad * (1 - cos(inclination)) - 0.01) / (1 - cos(inclination))
	endif
endif
treadThk = 0.05

beta = asn(treadThk/tread*sin(inclination + 90))
riserAngle = beta + inclination
riserHeight = tread * sin(riserAngle)
if landingHeight > 0 then
	riserBeginAngle = asn(riserBegin/tread)
else
	riserBeginAngle = 0
endif

if landingHeight > 0 then
	if landingHeight < landingHeightMin then
		maskMod = 0
	else
		maskMod = 1000
	endif
	maskMod2 = 0
else
	maskMod = 0
	maskMod2 = -2
	inclination = 0
endif

pen gs_cont_pen
if gs_detlevel_3D_m = 1 then gs_resol = 8
resol gs_resol * 2


! ==============================================================================
! Hotspots
! ==============================================================================

unID = 1
hotspot 0, 0, 0, unID, B, 1 + 256 : unID = unID + 1
hotspot 0, B, 0, unID, B, 2 : unID = unID + 1
hotspot 0, -1, 0, unID, B, 3 : unID = unID + 1

hotspot A, 0, landingHeight, unID, B, 1 + 256 : unID = unID + 1
hotspot A, B, landingHeight, unID, B, 2 : unID = unID + 1
hotspot A, -1, landingHeight, unID, B, 3 : unID = unID + 1

if iObjectType = ESCALATOR then
	hotspot 0, B/2, 0, unID, A, 1 + 256 : unID = unID + 1
	hotspot A, B/2, 0, unID, A, 2 : unID = unID + 1
	hotspot -1, B/2, 0, unID, A, 3 : unID = unID + 1
else
	hotspot 0, B/2, landingHeight, unID, A, 1 + 128 : unID = unID + 1
	hotspot A, B/2, landingHeight, unID, A, 2 : unID = unID + 1
	hotspot -1, B/2, landingHeight, unID, A, 3 : unID = unID + 1
endif

hotspot A, B/2, 0, unID, landingHeight, 1 + 128 : unID = unID + 1
hotspot A, B/2, landingHeight, unID, landingHeight, 2 : unID = unID + 1
hotspot A, B/2, -1, unID, landingHeight, 3 : unID = unID + 1


! ==============================================================================
! Truss
! ==============================================================================

material matTruss

addy B
rotx 90

! Truss Cuting Points
tcx1 = A/2 - totalTreadLength/2
tcx2 = tcx1
if iObjectType = ESCALATOR then
	tcx3 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread)) - ((riserHeight + riserBegin - treadThk) / tan(inclination))
	tcx4 = tcx3
	tcx5 = A/2 + totalTreadLength/2 - (nLowerLandingTread - 1) * tread - tread * cos(asn(riserBegin/tread)) - ((riserHeight - riserBegin - treadThk) / tan(inclination))
	tcx6 = tcx5
else
	tcx3 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + treadThk * tan(riserBeginAngle/2)
	tcx4 = tcx3 + (treadThk * tan(riserBeginAngle/2) + tread + treadThk * tan((inclination - riserBeginAngle)/2)) * cos(riserBeginAngle)
	tcx6 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread + treadThk * tan(riserBeginAngle/2)
	tcx5 = tcx6 - (tread - treadThk * tan(riserBeginAngle/2) - treadThk * tan((inclination - riserBeginAngle)/2)) * cos(riserBeginAngle)
endif
tcx7 = A/2 + totalTreadLength/2
tcx8 = tcx7
tcx9 = A - landingLength
tcx10 = A - landingLength
tcx11 = A - landingLength
tcx12 = landingLength
tcx13 = landingLength

tcy1 = -0.02 + grooveDepth
if iObjectType = ESCALATOR then
	tcy2 = -0.02 - riserHeight
	tcy3 = -0.02 - riserHeight
	tcy4 = -0.02 - riserHeight
	tcy5 = landingHeight -0.02 - riserHeight
	tcy6 = landingHeight -0.02 - riserHeight
else
	tcy2 = -0.02 - treadThk
	tcy3 = -0.02 - treadThk
	tcy4 = tcy3 + (treadThk * tan(riserBeginAngle/2) + tread + treadThk * tan((inclination - riserBeginAngle)/2)) * sin(riserBeginAngle)
	tcy5 = landingHeight -0.02 - treadThk
	tcy6 = landingHeight -0.02 - treadThk
	tcy5 = tcy6 - (tread - treadThk * tan(riserBeginAngle/2) - treadThk * tan((inclination - riserBeginAngle)/2)) * sin(riserBeginAngle)
endif
tcy7 = tcy6
tcy8 = landingHeight - 0.02 + grooveDepth
tcy9 = tcy8
tcy10 = landingHeight - 0.02 + grooveDepth
tcy11 = landingHeight
tcy12 = landingHeight
tcy13 = tcy1

addz balustradeWidth
cutform 14, 1, 1 + 2,
	0, 0, 1, stepWidth,
	tcx1, tcy1, 31,
	tcx2, tcy2, 31,
	tcx3, tcy3, 31,
	tcx4, tcy4, 31,
	tcx5, tcy5, 31,
	tcx6, tcy6, 31,
	tcx7, tcy7, 31,
	tcx8, tcy8, 31,
	tcx9, tcy9, 31,
	tcx10, tcy10, 31,
	tcx11, tcy11, 31,
	tcx12, tcy12, 31,
	tcx13, tcy13, 31,
	tcx1, tcy1, -1
del 1

tbx1 = 0
if landingHeight > 0 then
	if landingHeight < landingHeightMin then
		tbx2 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread)) - ((riserBegin - 0.02) / tan(inclination)) - 0.02 / sin(inclination)
		tbx3 = tbx2
		tbx4 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread)) + ((riserBegin + 0.02) / tan(inclination)) - 0.02 / sin(inclination)
		tbx5 = tbx4
	else
		tbx2 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread)) - ((riserBegin - 0.02) / tan(inclination)) - 0.02 / sin(inclination)- trussLowerRad * tan(inclination/2)
		tbx3 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread)) - ((riserBegin - 0.02) / tan(inclination))  - 0.02 / sin(inclination)+ trussLowerRad * tan(inclination/2) * cos(inclination)
		tbx4 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread)) + ((riserBegin + 0.02) / tan(inclination)) - 0.02 / sin(inclination) - trussUpperRad * tan(inclination/2) * cos(inclination)
		tbx5 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread)) + ((riserBegin + 0.02) / tan(inclination)) - 0.02 / sin(inclination) + trussUpperRad * tan(inclination/2)
	endif
	tbx8 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread)) + ((riserBegin + 0.02) / tan(inclination)) - 0.02 / sin(inclination) + tan(inclination/2)
	tbx9 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread)) - ((riserBegin - 0.02) / tan(inclination)) - 0.02 / sin(inclination) + tan(inclination/2)
else
	tbx2 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread))
	tbx3 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread))
	tbx4 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread))
	tbx5 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread))
	tbx8 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread))
	tbx9 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread))
endif
tbx6 = A
tbx7 = A
tbx10 = 0
tbx11 = tbx1

tby1 = 0
if landingHeight > 0 then
	tby2 = 0
	if landingHeight < landingHeightMin then
		tby3 = 0
		tby4 = landingHeight
	else
		tby3 = trussLowerRad * tan(inclination/2) * sin(inclination)
		tby4 = landingHeight - trussUpperRad * tan(inclination/2) * sin(inclination)
	endif
	tby5 = landingHeight
	tby6 = landingHeight
else
	tby2 = 0
	tby3 = 0
	tby4 = 0
	tby5 = 0
	tby6 = 0
endif
tby7 = landingHeight - 1
tby8 = landingHeight - 1
tby9 = -1
tby10 = -1
tby11 = 0

prism_ 11, B,
	tbx1, tby1, 15,
	tbx2, tby2, 15 + 64,
	tbx3, tby3, 15 + 64 + maskMod,
	tbx4, tby4, 15 + 64,
	tbx5, tby5, 15 + 64 + maskMod,
	tbx6, tby6, 15,
	tbx7, tby7, 15,
	tbx8, tby8, 15 + maskMod2,
	tbx9, tby9, 15 + maskMod2,
	tbx10, tby10, 15,
	tbx11, tby11, -1

cutend

xCombPos = 0
yCombPos = 0
zCombPos = 0
combAngle = 0
gosub "Comb"

xCombPos = A
yCombPos = B
zCombPos = landingHeight
combAngle = 180
gosub "Comb"

del 2


! ==============================================================================
! Balustrade
! ==============================================================================

! Balustrade Footing Points
hfx1 = landingLength
if landingHeight > 0 then
	if landingHeight < landingHeightMin then
		hfx2 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread)) - ((riserBegin - 0.02) / tan(inclination)) - 0.02 / sin(inclination)
		hfx3 = hfx2
		hfx4 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread)) + ((riserBegin + 0.02) / tan(inclination)) - 0.02 / sin(inclination)
		hfx5 = hfx4
	else
		hfx2 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread)) - ((riserBegin - 0.02) / tan(inclination)) - 0.02 / sin(inclination) - trussLowerRad * tan(inclination/2)
		hfx3 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread)) - ((riserBegin - 0.02) / tan(inclination)) - 0.02 / sin(inclination) + trussLowerRad * tan(inclination/2) * cos(inclination)
		hfx4 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread)) + ((riserBegin + 0.02) / tan(inclination)) - 0.02 / sin(inclination) - trussUpperRad * tan(inclination/2) * cos(inclination)
		hfx5 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread)) + ((riserBegin + 0.02) / tan(inclination)) - 0.02 / sin(inclination) + trussUpperRad * tan(inclination/2)
	endif
else
	hfx2 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread))
	hfx3 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread))
	hfx4 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread))
	hfx5 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread))
endif
hfx6 = A - landingLength
hfx7 = hfx6
if landingHeight < landingHeightMin then
	hfx8 = hfx5 - balustradeFooting * tan(inclination/2)
	hfx9 = hfx8
	hfx10 = hfx2 - balustradeFooting * tan(inclination/2)
	hfx11 = hfx10
else
	hfx8 = hfx5
	hfx9 = hfx5 - (trussUpperRad + balustradeFooting) * sin(inclination)
	hfx10 = hfx2 + (trussLowerRad - balustradeFooting) * sin(inclination)
	hfx11 = hfx2
endif
hfx12 = hfx1

hfy1 = 0
hfy2 = 0
if landingHeight < landingHeightMin then
	hfy3 = 0
	hfy4 = landingHeight
else
	hfy3 = trussLowerRad * tan(inclination/2) * sin(inclination)
	hfy4 = landingHeight - trussUpperRad * tan(inclination/2) * sin(inclination)
endif
hfy5 = landingHeight
hfy6 = landingHeight
hfy7 = landingHeight + balustradeFooting
hfy8 = hfy7
if landingHeight < landingHeightMin then
	hfy9 = hfy7
	hfy10 = balustradeFooting
else
	hfy9 = hfy7 - (trussUpperRad + balustradeFooting) + (trussUpperRad + balustradeFooting) * cos(inclination)
	hfy10 = balustradeFooting + (trussLowerRad - balustradeFooting) - (trussLowerRad - balustradeFooting) * cos(inclination)
endif
hfy11 = balustradeFooting
hfy12 = hfy11

! Balustrade Points
hsx1 = hfx6
hsx2 = hsx1
if landingHeight < landingHeightMin then
	hsx3 = hfx5 - balustradeHeight * tan(inclination/2)
	hsx4 = hsx3
	hsx5 = hfx2 - balustradeHeight * tan(inclination/2)
	hsx6 = hsx5
else
	hsx3 = hfx5
	hsx4 = hfx5 - (trussUpperRad + balustradeHeight) * sin(inclination)
	hsx5 = hfx2 + (trussLowerRad - balustradeHeight) * sin(inclination)
	hsx6 = hfx2
endif

hsx7 = hfx1
hsx8 = hsx7

hsy1 = landingHeight + 0.1
hsy2 = landingHeight + balustradeHeight
hsy3 = hsy2
if landingHeight < landingHeightMin then
	hsy4 = hsy2
	hsy5 = balustradeHeight
else
	hsy4 = hsy2 - (trussUpperRad + balustradeHeight) + (trussUpperRad + balustradeHeight) * cos(inclination)
	hsy5 = balustradeHeight + (trussLowerRad - balustradeHeight) - (trussLowerRad - balustradeHeight) * cos(inclination)
endif
hsy6 = balustradeHeight
hsy7 = hsy6
hsy8 = 0.1

! Handrail (Rubber Band) Points
hrx1 = hfx6
hrx2 = hrx1
if landingHeight < landingHeightMin then
	hrx3 = hfx5 - (balustradeHeight + handrailRubberThk) * tan(inclination/2)
	hrx4 = hrx3
	hrx5 = hfx2 - (balustradeHeight + handrailRubberThk) * tan(inclination/2)
	hrx6 = hrx5
else
	hrx3 = hfx5
	hrx4 = hfx5 - (trussUpperRad + balustradeHeight + handrailRubberThk) * sin(inclination)
	hrx5 = hfx2 + (trussLowerRad - balustradeHeight - handrailRubberThk) * sin(inclination)
	hrx6 = hfx2
endif
hrx7 = hfx1
hrx8 = hrx7

hry1 = landingHeight + 0.1 - handrailRubberThk
hry2 = landingHeight + balustradeHeight + handrailRubberThk
hry3 = hry2
if landingHeight < landingHeightMin then
	hry4 = hry2
	hry5 = balustradeHeight + handrailRubberThk
else
	hry4 = hry2 - (trussUpperRad + balustradeHeight + handrailRubberThk) + (trussUpperRad + balustradeHeight + handrailRubberThk) * cos(inclination)
	hry5 = balustradeHeight + handrailRubberThk + (trussLowerRad - balustradeHeight - handrailRubberThk) - (trussLowerRad - balustradeHeight - handrailRubberThk) * cos(inclination)
endif
hry6 = balustradeHeight + handrailRubberThk
hry7 = hry6
hry8 = 0.1 - handrailRubberThk

for nBal = 1 to 2
	if iBalustradeType = BALUSTRADE_SOLID then
		addy balustradeWidth
		rotx 90
		material matBalustrade
		prism_ 16, balustradeWidth,
			hfx1, hfy1, 15,
			hfx2, hfy2, 15 + 64,
			hfx3, hfy3, 15 + 64 + maskMod,
			hfx4, hfy4, 15 + 64,
			hfx5, hfy5, 15 + 64 + maskMod,
			hfx6, hfy6, 15,

			hsx1, hsy1, 15 + 64,
			1, 0, 800,
			hsx2, hsy2, 1015 + 64,
			hsx3, hsy3, 15 + 64,
			hsx4, hsy4, 15 + 64 + maskMod,
			hsx5, hsy5, 15 + 64,
			hsx6, hsy6, 15 + 64 + maskMod,
			hsx7, hsy7, 15 + 64,
			hsx8, hsy8, 1015,

			hfx1, hfy1, -1
		del 2
	else
		addy balustradeWidth
		rotx 90
		material matTruss
		prism_ 13, balustradeWidth,
			hfx1, hfy1, 15,
			hfx2, hfy2, 15 + 64,
			hfx3, hfy3, 15 + 64 + maskMod,
			hfx4, hfy4, 15 + 64,
			hfx5, hfy5, 15 + 64 + maskMod,
			hfx6, hfy6, 15,
			hfx7, hfy7, 15,
			hfx8, hfy8, 15 + 64,
			hfx9, hfy9, 15 + 64 + maskMod,
			hfx10, hfy10, 15 + 64,
			hfx11, hfy11, 15 + 64 + maskMod,
			hfx12, hfy12, 15,
			hfx1, hfy1, -1
		del 2

		addy balustradeWidth/2 + balustradeGlassWidth/2
		rotx 90
		material matGlass
		prism_ 16, balustradeGlassWidth,
			hfx12, hfy12, 15,
			hfx11, hfy11, 15 + 64,
			hfx10, hfy10, 15 + 64 + maskMod,
			hfx9, hfy9, 15 + 64,
			hfx8, hfy8, 15 + 64 + maskMod,
			hfx7, hfy7, 15,

			hsx1, hsy1, 15 + 64,
			1, 0, 800,
			hsx2, hsy2, 1015 + 64,
			hsx3, hsy3, 15 + 64,
			hsx4, hsy4, 15 + 64 + maskMod,
			hsx5, hsy5, 15 + 64,
			hsx6, hsy6, 15 + 64 + maskMod,
			hsx7, hsy7, 15 + 64,
			hsx8, hsy8, 1015,

			hfx12, hfy12, -1
		del 2
	endif

	addy balustradeWidth/2 + handrailRubberWidth/2
	rotx 90
	material matHandrailRubber
	prism_ 19, handrailRubberWidth,
		hsx1, hsy1, 15 + 64,
		1, 0, 800,
		hsx2, hsy2, 1015 + 64,
		hsx3, hsy3, 15 + 64,
		hsx4, hsy4, 15 + 64 + maskMod,
		hsx5, hsy5, 15 + 64,
		hsx6, hsy6, 15 + 64 + maskMod,
		hsx7, hsy7, 15 + 64,
		hsx8, hsy8, 1015,

		hrx8, hry8, 15 + 64,
		-1, 0, 800,
		hrx7, hry7, 1015 + 64,
		hrx6, hry6, 15 + 64,
		hrx5, hry5, 15 + 64 + maskMod,
		hrx4, hry4, 15 + 64,
		hrx3, hry3, 15 + 64 + maskMod,
		hrx2, hry2, 15 + 64,
		hrx1, hry1, 1015,

		hsx1, hsy1, -1
	del 2
addy B - balustradeWidth
next nBal
del 2


! ==============================================================================
! Treads
! ==============================================================================

resol gs_resol
material matTread
add A/2 - totalTreadLength/2, 0, -0.02
for hi = 1 to nTread + (nLowerLandingTread + nUpperLandingTread) * (landingHeight > 0)
	xTread = tread * cos(asn(riser/tread))
	zTread = riser
	treadAngle = 0
	closingAngle = inclination
	if iObjectType = ESCALATOR then
		if hi = 1 | hi = 2 | hi = nTread + 3 | hi = nTread + 4 | hi = nTread + 5 | hi = nTread + 6 then
			xTread = tread
			zTread = 0
			treadAngle = 0
			closingAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
		endif
		if hi = 3 then
			xTread = tread * cos(asn(riserBegin/tread))
			zTread = riserBegin
			treadAngle = 0
			closingAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
		endif
		if hi = 4 then
			if iObjectType = MOVING_WALKWAY then treadAngle = acs(riserBegin/tread)*0	+ acs(tread * cos(asn(riserBegin/tread))/tread)
			closingAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
		endif
		if hi = nTread + 2 then
			xTread = tread * cos(asn(riserBegin/tread))
			zTread = riserBegin
		endif
		if hi = nTread + 3 then
			if iObjectType = MOVING_WALKWAY then treadAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
			closingAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
		endif
	else
		treadAngle = inclination
		if hi < nLowerLandingTread then
			xTread = tread
			zTread = 0
			treadAngle = 0
			closingAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
		endif
		if hi = nLowerLandingTread then
			xTread = tread * cos(asn(riserBegin/tread))
			zTread = riserBegin
			treadAngle = 0
			closingAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
		endif
		if hi = nLowerLandingTread + 1 | hi = nLowerLandingTread + nTread then
			xTread = tread * cos(asn(riser/tread))
			zTread = riser
			treadAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
			closingAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
		endif
		if hi = nLowerLandingTread + nTread - 1 then
			xTread = tread * cos(asn(riserBegin/tread))
			zTread = riserBegin
		endif
		if hi = nLowerLandingTread + nTread then
			xTread = tread
			zTread = 0
			treadAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
			closingAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
		endif
		if hi > nLowerLandingTread + nTread then
			xTread = tread
			zTread = 0
			treadAngle = 0
			closingAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
		endif
	endif
	gosub "tread"
	add xTread, 0, zTread
next hi
del nTread + (nLowerLandingTread + nUpperLandingTread) * (landingHeight > 0) + 1

end


"tread":

add tread, (B - balustradeWidth), 0
rotx 90
rotz treadAngle

if gs_detlevel_3D_m = 2 & GLOB_CONTEXT <> 5 then
!	nGroove = int(stepWidth/grooveWidth/4) + 1
	nGroove = int(int((stepWidth - grooveWidth)/grooveWidth)/2)

	addz stepWidth/2
	roty 90
	for hj = 1 to 2
	for iGroove = 1 to nGroove
		cutform 5, 1, 1 + 2 + 8 + 16,
			0, 0, 1, 1,
			grooveWidth/2, 0, 31,
			3*grooveWidth/2, 0, 31,
			3*grooveWidth/2, grooveDepth, 31,
			grooveWidth/2, grooveDepth, 31,
			grooveWidth/2, 0, -1
		addx 2 * grooveWidth
	next iGroove
	del nGroove
	mulx -1
	next hj
	del 2
	del 2

	roty -90
	cutplane 225
	del 1
	addx -tread
	roty -90
	cutplane 315
	del 2
endif

if iObjectType = ESCALATOR then
	prism_ 8, stepWidth,
		0, grooveDepth, 15,
		0, -treadThk, 15,
		-tread * cos(riserAngle), -tread * sin(riserAngle), 15,
		-tan(riserAngle), 1, 800,
		-tread * cos(closingAngle), -tread * sin(closingAngle), 1015,
		-tread, 0, 1015,
		-tread, grooveDepth, 15,
		0, grooveDepth, 15
endif
if iObjectType = MOVING_WALKWAY then
	prism_ 7, stepWidth,
		-grooveDepth, grooveDepth, 15,
		0, 0, 15,
		-treadThk * tan(15), -treadThk, 15,
		-tread + treadThk * tan(15), -treadThk, 15,
		-tread, 0, 15,
		-tread + grooveDepth, grooveDepth, 15,
		-grooveDepth, grooveDepth, -1
endif

if gs_detlevel_3D_m = 2  & GLOB_CONTEXT <> 5 then
	cutend
	cutend
	for iGroove = 1 to nGroove * 2
		cutend
	next iGroove
endif

del 1

del 2

return


"Comb":

add xCombPos, zCombPos, yCombPos
roty combAngle

if gs_detlevel_3D_m = 2  & GLOB_CONTEXT <> 5 then
	nGroove = int(int((stepWidth - grooveWidth)/grooveWidth)/2)

	add A/2 - totalTreadLength/2, -0.02, 0

	addz stepWidth/2 + balustradeWidth
	roty 90
	for hk = 1 to 2
	for iGroove = 1 to nGroove
		cutform 5, 1, 1 + 2,
			0, 0, 1, landingLength + comblength - (A - totalTreadLength)/2,
			-grooveWidth/2, 0, 31,
			grooveWidth/2, 0, 31,
			grooveWidth/2, grooveDepth, 31,
			-grooveWidth/2, grooveDepth, 31,
			-grooveWidth/2, 0, -1
		addx 2 * grooveWidth
	next iGroove
	del nGroove
	mulx -1
	next hk
	del 2
	del 2
	del 1
endif

addz balustradeWidth
prism_ 4, B - 2 * balustradeWidth,
	landingLength, -0.02, 15,
	landingLength + combLength, -0.02, 15,
	landingLength, 0, 15,
	landingLength, -0.02, -1
del 1

if gs_detlevel_3D_m = 2 then
	for iGroove = 1 to nGroove * 2
		cutend
	next iGroove
endif
del 2

return


