
paperToModel = GLOB_SCALE / 1000

! ======================================================================
! Scale sensitive Floor Plan Display
! ======================================================================

homestory = 1
abovestory = 0
belowstory = 0
if bStorySensitive then
	if GLOB_CH_STORY_DIST > EPS  then
		abovestory = 1
		homestory = 0
	else
		if GLOB_CH_STORY_DIST < -EPS  then
			belowstory = 1
			homestory = 0
		endif
	endif
endif

! ======================================================================
! Scale sensitive  - Symbol and Text
! ======================================================================

iHomeStory = FLOOR
_contentText = symb_text_1_short
if iSymbolType = FLOOR_OPENING then
	iHomeStory = FLOOR
	_contentText = symb_text_1_short
	if belowStory then
		iHomeStory = CEILING
		_contentText = symb_text_2_short
	endif
endif
if iSymbolType = CEILING_OPENING then
	iHomeStory = CEILING
	_contentText = symb_text_1_short
	if aboveStory then
		iHomeStory = FLOOR
		_contentText = symb_text_2_short
	endif
endif
if iSymbolType = FLOOR_RECESS then
	iHomeStory = FLOOR
	_contentText = symb_text_short
endif

! ======================================================================
! TEXT Style
! ======================================================================

if iFontScale = FONTSCALE_MODEL then
	fontSizePaper	= gs_font_size / paperToModel
endif

AC_TextStyle = gs_text_style_bold + 2*gs_text_style_italic + 4*gs_text_style_underline

define style "textStyle"		fontType, fontSizePaper, 8,  AC_TextStyle
define style "textStyleUnder"	fontType, fontSizePaper, 2,  AC_TextStyle
define style{2} "fracStyle"		fontType, fontSizePaper, 32+(AC_TextStyle)	! with Superscript

stringWidth		= 0
stringHeight	= 0
iMirrored		= 1-2*SYMB_MIRRORED

! --- Oriented View ------------------------------
!angleViewRot 	= 0
!readAngle 		= 90
!qqq = request ("View_Rotangle", "", angleViewRot)
!totalRotate = (SYMB_ROTANGLE + angleViewRot + angle) MOD 360
!bTextRotate	= (totalRotate > (readAngle + eps*iMirrored) & totalRotate < (readAngle + 180 + eps*iMirrored))
!textRotate	= 180 * bTextRotate

!----------- Length Calculation --------------------
sConversionText = ""
gosub "displayUnitConversions"

dim sizes[3]
	sizes[1] = A
	sizes[2] = B
	sizes[3] = gs_slab_thickness

dim sizesText[3][2]
for i = 1 to 3
	call "quantity_text_formatter" parameters 	lengthValue				= sizes[i],
												custom_form				= sConversionText,
												iUnitType				= 0,
												horizontalAlignment 	= 1,
												verticalAlignment		= 1,
												AC_TextFont				= fontType,
												AC_TextSize				= fontSizePaper,
												AC_TextStyle			= AC_TextStyle,
												szPrefix				= "",
												bShowText				= 1,
												bShowUnit				= 0,
												bShowSuperScript		= 0,
							returned_parameters dummy_lengthOfNote1,
												dummy_lengthOfNote2,
												dummy_lengthOfNote3,
												dummy_lengthOfNote4,
												dummy_totalLength,
												dummy_totalHeight,
												dummy_lengthOfUnit,
												dummy_lengthOfIntegerPart,
												note1,				!szPrefix + main
												note2,				!frac,
												dummy_note3,		!szUnit,
												dummy_note4,		!szUnitIndex,
												dummy_szExtraPrecision,
												dummy_iAnchorString

	sizesText[i][1]	= note1
	sizesText[i][2]	= note2
next i

!----------- Add Str To Text --------------------
dim stringsNormal[3]
dim stringsSuper[3]
for i = 1 to 3
	stringsNormal[i]	= ""
	stringsSuper[i]		= ""
next i

if bShowPrefix then
	stringsNormal[1]	= stringsNormal[1] + symb_use_short + " "
endif

if gs_displaytext then
	stringsNormal[1]	= stringsNormal[1] + _contentText
endif

if bShowSizes then
	stringsNormal[1]	= stringsNormal[1] + " "

	if iOpeningType = OPTYPE_CIRCULAR then
		stringsNormal[1]	= stringsNormal[1] + "Ã˜"		!FI
		stringsNormal[1]	= stringsNormal[1] + sizesText[2][1]
		stringsSuper[1]		= stringsSuper[1] + sizesText[2][2]
	else
		stringsNormal[1]	= stringsNormal[1] + sizesText[1][1]
		stringsSuper[1]		= stringsSuper[1] + sizesText[1][2]

		stringsNormal[2]	= stringsNormal[2] + " /" + sizesText[2][1]
		stringsSuper[2]		= stringsSuper[2] + sizesText[2][2]
	endif

	if iSymbSizes = SYMBTEXT_XYZ then
		stringsNormal[3]	= stringsNormal[3] + " /" + sizesText[3][1]
		stringsSuper[3]		= stringsSuper[3] + sizesText[3][2]
	endif
endif


!----------- Paragraph --------------------
paragraph "paragraph" 2, 0, 0, 0, 1, 0
	pen gs_font_pen

	set style "textStyle"
	stringsNormal[1]

	set style "fracStyle"
	stringsSuper[1]

	set style "textStyle"
	stringsNormal[2]

	set style "fracStyle"
	stringsSuper[2]

	set style "textStyle"
	stringsNormal[3]

	set style "fracStyle"
	stringsSuper[3]
endparagraph
textblock "textblock" gs_text_wrap*gs_text_width/paperToModel, 8, 0, 1, 1, 10/GLOB_SCALE, "paragraph"

qqq = REQUEST ("TEXTBLOCK_INFO", "textblock", stringWidth, stringHeight)
stringWidth		= stringWidth	* paperToModel 
stringHeight	= stringHeight	* paperToModel 

bUpperSting = ((gs_displaytext | bShowPrefix | bShowSizes) & stringWidth > EPS)

if iSymbolType = FLOOR_RECESS then add2 -a / 2, -b / 2

! ======================================================================
! Hotspots
! ======================================================================
add2 a / 2, b + stringHeight/ 2

unID = 1
if bUpperSting then
	hotspot2 0, 0
	hotspot2 gs_textoffset_x,	0,					unID,	gs_textoffset_y,	1 + 128	: unID = unID + 1
	hotspot2 gs_textoffset_x,	-0.1,				unID,	gs_textoffset_y,	3 + 128	: unID = unID + 1
	hotspot2 gs_textoffset_x,	gs_textoffset_y,	unID,	gs_textoffset_y,	2		: unID = unID + 1
	hotspot2 0,					gs_textoffset_y,	unID,	gs_textoffset_x,	1 + 128	: unID = unID + 1
	hotspot2 -0.1,				gs_textoffset_y,	unID,	gs_textoffset_x,	3 + 128	: unID = unID + 1
	hotspot2 gs_textoffset_x,	gs_textoffset_y,	unID,	gs_textoffset_x,	2		: unID = unID + 1
endif

del 1
unID = 7

! ======================================================================
! Type
! ======================================================================

if iSymbolType = FLOOR_RECESS then
	shadowFillType	= backGroundFillType
	shadowFillPen	= backGroundFillPen
	shadowFillBgPen	= backGroundFillBgPen

	groundFillType	= backGroundFillType
	groundFillPen	= backGroundFillPen
	groundFillBgPen	= backGroundFillBgPen
else
	shadowFillType	= gs_opening_filltype
	shadowFillPen	= gs_opening_fillpen
	shadowFillBgPen	= gs_opening_backgroundpen

	if iHomeStory = CEILING then
		groundFillType	= ceilingFillType
		groundFillPen	= ceilingFillPen
		groundFillBgPen	= ceilingFillBgPen
	else
		groundFillType	= backGroundFillType
		groundFillPen	= backGroundFillPen
		groundFillBgPen	= backGroundFillBgPen
	endif
endif

if iOpeningType = OPTYPE_RECTANGULAR	then gosub "squareOpening"
if iOpeningType = OPTYPE_ROUNDED		then gosub "ovalOpening"
if iOpeningType = OPTYPE_ELLIPTICAL		then gosub "roundedOpening"
if iOpeningType = OPTYPE_CIRCULAR		then
	a = b
	gosub "roundedOpening"
endif


! ======================================================================
! Text
! ======================================================================
if bUpperSting then
	!----------- Draw Text --------------------
	add2 a/2+gs_textoffset_x, b+stringHeight/2+gs_textoffset_y

	hotspot2 0,0
	hotspot2 (stringWidth/2),				0,							unID+1, angle, 4
	hotspot2 (stringWidth/2)*cos(angle),	(stringWidth/2)*sin(angle),	unID+2, angle, 5
	hotspot2 0,								0,							unID+3, angle, 6
	hotspot2 2,								0,							unID+4, angle, 7

	rot2 angle
	add2 0, -stringHeight/2

	mul2 iMirrored, 1

	if GLOB_CONTEXT = 22 then
		rect2 -stringWidth/2, 0, stringWidth/2, stringHeight
	else
		richtext2 0, 0, "textblock"
	endif

	del 4
endif

!----------- Custom Text --------------------
if bShowCustomText & symb_cust_text <> "" then
	paragraph "paragraphUnder" 2, 0, 0, 0, 1, 0
		pen gs_font_pen
		set style "textStyleUnder"
		symb_cust_text
	endparagraph
	textblock "textblockUnder" gs_text_wrap*gs_text_width/paperToModel, 2, 0, 1, 1, 10/GLOB_SCALE, "paragraphUnder"

	add2 a/2, 0
	if GLOB_CONTEXT = 22 then
		qqq = REQUEST ("TEXTBLOCK_INFO", "textblockUnder", stringWidthUnder, stringHeightUnder)
		stringWidthUnder	= stringWidthUnder	* paperToModel 
		stringHeightUnder	= stringHeightUnder	* paperToModel 

		rect2 -stringWidthUnder/2, 0, stringWidthUnder/2, -stringHeightUnder
	else
		richtext2 0, 0, "textblockUnder"
	endif
	del 1
endif

if iSymbolType = FLOOR_RECESS then del 1

!================================================================================
end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
!================================================================================

!--------------------------------------------------------------------------------
"displayUnitConversions":
!--------------------------------------------------------------------------------
	if iWorkingUnit = WORKUNIT_PROJECT then
		n = REQUEST ("Linear_dimension", "",sConversionText)

		! DIN: removing "hide zero wholes" flag
		zeroFlagPos = STRSTR (sConversionText, "#")
		if zeroFlagPos > 0 then
			charNum = STRLEN (sConversionText)
			format1 = STRSUB (sConversionText, 1, zeroFlagPos - 1)
			format2 = STRSUB (sConversionText, zeroFlagPos + 1, charNum - zeroFlagPos)
			sConversionText = format1 + format2
		endif
	endif

	if iWorkingUnit = WORKUNIT_MM then
		if iDecimalOptions = 0 then sConversionText	= "%~0.0mm"
		if iDecimalOptions = 1 then sConversionText	= "%~0.1mm"
	endif
	if iWorkingUnit = WORKUNIT_CM then
		if iDecimalOptions = 0 then sConversionText	= "%~0.0cm"
		if iDecimalOptions = 1 then sConversionText	= "%~0.1cm"
		if iDecimalOptions = 2 then sConversionText	= "%~0.2cm"
	endif
	if iWorkingUnit = WORKUNIT_METER then
		if iDecimalOptions = 0 then sConversionText	= "%~0.0m"
		if iDecimalOptions = 1 then sConversionText	= "%~0.1m"
		if iDecimalOptions = 2 then sConversionText	= "%~0.2m"
		if iDecimalOptions = 3 then sConversionText	= "%~0.3m"
		if iDecimalOptions = 4 then sConversionText	= "%~0.4m"
	endif
	if iWorkingUnit = WORKUNIT_INCH then
		sConversionText		= "%0.64fi"
	endif
return



!--------------------------------------------------------------------------------
"squareOpening":
!--------------------------------------------------------------------------------

	if b > a then
		x = a / 3.5 * ((b / a / 2) ^ (1 / 2))
		y = x
		if y > a-EPS then
			y = a * magicScale
			x = y
		endif
	else
		x = b / 3.5 * ((a / b / 2) ^ (1 / 2))
		y = x
		if y > b-EPS then
			y = b * magicScale
			x = y
		endif
	endif

	if iHomeStory = CEILING then
		pen gs_ceilingCont_pen
		line_type lineTypeCeiling

		fill groundFillType
		poly2_B 4, 1 + 2 + 4, groundFillPen, groundFillBgPen,
			0, 0, 1,
			0, b, 1,
			a, b, 1,
			a, 0, 1
	
		if iOpeningSymbolType = 1 then
			poly2_B 4, 1 + 4, groundFillPen, groundFillBgPen,
				0, 0, 1,
				a, b, 0,
				0, b, 1,
				a, 0, 0
		else
			poly2_B 4, 1 + 4, groundFillPen, groundFillBgPen,
				0, 0, 0,
				a, 0, 0,
				a, b, 1,
				a - x, y, 1
		endif

		hotspot2 a / 2, b / 2
	endif

	if iHomeStory = FLOOR then
		pen penFloor
		line_type lineTypeFloor

		fill groundFillType
		poly2_B 4, 1 + 2 + 4, groundFillPen, groundFillBgPen,
			0, 0, 1,
			0, b, 1,
			a, b, 1,
			a - x, y, 1

		fill shadowFillType
		poly2_B 4, 1 + 2 + 4, shadowFillPen, shadowFillBgPen,
			0, 0, 1,
			a, 0, 1,
			a, b, 1,
			a - x, y, 1

		hotspot2 a - x, y
	endif


	hotspot2 0, 0
	hotspot2 a, 0
	hotspot2 a, b
	hotspot2 0, b

	unID = 10

return

!--------------------------------------------------------------------------------
"roundedOpening":
!--------------------------------------------------------------------------------

	add2 a / 2, b / 2
	mul2 1, b / a

	if iHomeStory = CEILING then
		pen gs_ceilingCont_pen
		line_type lineTypeCeiling

		fill groundFillType
		poly2_B 2, 1 + 2 + 4, groundFillPen, groundFillBgPen,
			0, 0, 901,
			a / 2, 360, 4001

		line2 -(sin(45))*(a/2), -(sin(45))*(a/2), (sin(45))*(a/2), (sin(45))*(a/2)

		if iOpeningSymbolType = 1 then
			line2 (sin(45))*(a/2), -(sin(45))*(a/2), -(sin(45))*(a/2), (sin(45))*(a/2)
		endif
	endif

	if iHomeStory = FLOOR then
		pen penFloor
		line_type lineTypeFloor

		circle2 0, 0, a / 2
		line2 -(sin(45)) * (a / 2), -(sin(45)) * (a / 2), (sin(45)) * (a / 2), (sin(45)) * (a / 2)

		fill groundFillType
		poly2_B 4, 2 + 4, groundFillPen, groundFillBgPen,
			-(sin(45)) * (a / 2), -(sin(45)) * (a / 2), 1,
			0, 0, 900,
			a / 2, -180, 4001,
			(sin(45)) * (a / 2), (sin(45)) * (a / 2), 1

		fill shadowFillType
		poly2_B 4, 2 + 4, shadowFillPen, shadowFillBgPen,
			-(sin(45)) * (a / 2), -(sin(45)) * (a / 2), 1,
			0, 0, 900,
			a / 2, 180, 4001,
			(sin(45)) * (a / 2), (sin(45)) * (a / 2), 1
	endif

	del 2

	hotspot2 a / 2,	b / 2
	hotspot2 0,		b / 2
	hotspot2 a / 2,	0
	hotspot2 a,		b / 2
	hotspot2 a / 2,	b

	unID = 20

return

!--------------------------------------------------------------------------------
"ovalOpening":
!--------------------------------------------------------------------------------

	x = b / 3.5 * ((a / b / 2) ^ (1 / 2))
	y = x
	if y > b-EPS then
		y = b * magicScale
		x = y
	endif

	if iHomeStory = CEILING then
		pen gs_ceilingCont_pen
		line_type lineTypeCeiling

		fill groundFillType
		poly2_B 7, 1 + 2 + 4, groundFillPen, groundFillBgPen,
			a - b / 2, 0, 1,
			b / 2, 0, 1,
			-1, 0, 800,
			b / 2, b, 1001,
			a - b / 2, b, 1,
			1, 0, 800,
			a - b / 2, 0, 1001

		if iOpeningSymbolType = 1 then
			poly2_B 4, 1 + 4, shadowFillPen, shadowFillBgPen,
				b / 2 - (sin(45)) * (b / 2), b / 2 - (sin(45)) * (b / 2), 1,
				a - b / 2 + (sin(45)) * (b / 2), b / 2 + (sin(45)) * (b / 2), 0,
				b / 2 - (sin(45)) * (b / 2), b / 2 + (sin(45)) * (b / 2), 1,
				a - b / 2 + (sin(45)) * (b / 2), b / 2 - (sin(45)) * (b / 2), 0
			else
			poly2_B 5, 1 + 4, shadowFillPen, shadowFillBgPen,
				a - b / 2, y, 1,
				b / 2, 0, 0,
				a - b / 2, 0, 0,
				a - b / 2, b / 2, 900,
				b / 2, 135, 4001
		endif
	endif

	if iHomeStory = FLOOR then
		pen penFloor
		line_type lineTypeFloor

		fill groundFillType
		poly2_B 7, 1 + 2 + 4, groundFillPen, groundFillBgPen,
			a - b / 2, y, 1,
			b / 2, 0, 1,
			-1, 0, 800,
			b / 2, b, 1001,
			a - b / 2, b, 1,
			a - b / 2, b / 2, 900,
			b / 2, -45, 4001

		fill shadowFillType
		poly2_B 5, 1 + 2 + 4, shadowFillPen, shadowFillBgPen,
			a - b / 2, y, 1,
			b / 2, 0, 1,
			a - b / 2, 0, 1,
			a - b / 2, b / 2, 900,
			b / 2, 135, 4001

		hotspot2 a - b / 2, y
	endif

	hotspot2 b / 2, 0
	hotspot2 a - b / 2,	0
	hotspot2 b / 2,	b
	hotspot2 a - b / 2,	b
	hotspot2 a, b / 2
	hotspot2 0, b / 2

	unID = 30

return



