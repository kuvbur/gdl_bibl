
!!-----------------------!!!-----------------------!!!-----------------------!!
!! Create Cutting Bodies !!! Create Cutting Bodies !!! Create Cutting Bodies !!
!!-----------------------!!!-----------------------!!!-----------------------!!

epszilon=0.0001

if ac_refSide then
	dir=-1
else
	dir=1
endif

if ac_wall_radius<eps then	!! For the Curved Wall
	ratio=1
else
	ratio=(ac_wall_radius+oper_thk*dir)/ac_wall_radius
endif

material gs_mat

if gs_gdl_debug then
	print "cutting_thk=",cutting_thk
	print "ref_thickness=",ref_thickness
endif

! Arrays for the polygon offset
dim transfer[][]
dim polygon[][]
dim empty[1][1]
	empty[1][1] = 0

!------------!
! Bottom Cut !
!------------!

offset=bot_ext
transfer=ac_bot_poly
gosub 9501 !! Do the polygon offset

min_bot_y=0

group "lower cut"
	if cut_set[1]=1 then

		put (polygon[1][1]-over_cut_beg)*ratio, min_bot_y-1, 15
		put (polygon[1][1]-over_cut_beg)*ratio, polygon[1][2], 15
		for i=1 to vardim1(polygon)
			put polygon[i][1]*ratio, polygon[i][2], 15
		next i
		put (polygon[vardim1(polygon)][1]+over_cut_end)*ratio, polygon[vardim1(polygon)][2], 15
		put (polygon[vardim1(polygon)][1]+over_cut_end)*ratio, min_bot_y-1, 15
		put (polygon[1][1]-over_cut_beg)*ratio, min_bot_y-1, -1

		rotx 90
		addz oper_thk*dir
		if ac_wall_radius<eps then
			prism_	nsp/3, -cutting_thk*dir,
					get(nsp)
		else
			bprism_	gs_mat, gs_mat, gs_mat,
					nsp/3, -cutting_thk*dir, ac_wall_radius*ratio,
					get(nsp)
		endif
		del 2
	endif
endgroup


!---------!
! Top Cut !
!---------!

offset=-top_ext
transfer=ac_top_poly
gosub 9501 !! Do the polygon offset

min_top_y=0
max_top_y=ac_wall_height

group "upper cut"
	if cut_set[2]=1 then
		put (polygon[1][1]-over_cut_beg)*ratio, max_top_y+1, 15
		put (polygon[1][1]-over_cut_beg)*ratio, polygon[1][2], 15
		for i=1 to vardim1(polygon)
			put polygon[i][1]*ratio, polygon[i][2], 15
		next i
		put (polygon[top_num][1]+over_cut_end)*ratio, polygon[top_num][2], 15
		put (polygon[top_num][1]+over_cut_end)*ratio, max_top_y+1, 15
		put (polygon[1][1]-over_cut_beg)*ratio, max_top_y+1, -1

		rotx 90
		addz oper_thk*dir
		if ac_wall_radius<eps then
			prism_	nsp/3, -cutting_thk*dir,
					get(nsp)
		else
			bprism_	gs_mat, gs_mat, gs_mat,
					nsp/3, -cutting_thk*dir, ac_wall_radius*ratio,
					get(nsp)
		endif
		del 2
	endif
endgroup


!----------!
! End Cuts !
!----------!

group "end cuts"
	if cut_set[3]=1 then
		addz min_bot_y-1

		if ac_wall_radius<eps then
			prism_	7, (max_top_y-min_top_y)+2,	! begin cut
					0, 0, 15,
					(ref_thickness/tan(ac_angles[1][1]))*not(not(ac_angles[1][1]-90)), ref_thickness*dir, 15,
					(ref_thickness/tan(ac_angles[1][1]))*not(not(ac_angles[1][1]-90)), (ref_thickness+oper_thk)*dir, 15,
				   -over_cut_beg, (ref_thickness+oper_thk)*dir, 15,
				   -over_cut_beg, -oper_thk*dir, 15,
					0, -oper_thk*dir, 15,
					0, 0, -1

			addx ac_wall_length
			prism_	7, (max_top_y-min_top_y)+2, ! end cut
					0, 0, 15,
					ref_thickness/tan(ac_angles[vardim1(ac_angles)][2])*not(not(ac_angles[vardim1(ac_angles)][2]-90)), ref_thickness*dir, 15,
					ref_thickness/tan(ac_angles[vardim1(ac_angles)][2])*not(not(ac_angles[vardim1(ac_angles)][2]-90)), (ref_thickness+oper_thk)*dir, 15,
					over_cut_end, (ref_thickness+oper_thk)*dir, 15,
					over_cut_end, -oper_thk*dir, 15,
					0, -oper_thk*dir, 15,
					0, 0, -1
			del 1
		else
			prism_	7, (max_top_y-min_top_y)+2,	! begin cut
					0, 0, 15,
					sec_x_beg, sec_y_beg*dir, 15,
					sec_x_beg, (sec_y_beg+oper_thk)*dir, 15,
				   -over_cut_beg, (sec_y_beg+oper_thk)*dir, 15,
				   -over_cut_beg, -oper_thk*dir, 15,
					0, -oper_thk*dir, 15,
					0, 0, -1

			addy ac_wall_radius
			rotz 180*ac_wall_length/ac_wall_radius/pi
			addy -ac_wall_radius

			prism_	7, (max_top_y-min_top_y)+2, ! end cut
					0, 0, 15,
					sec_x_end, sec_y_end*dir, 15,
					sec_x_end, (sec_y_end+oper_thk)*dir, 15,
					over_cut_end, (sec_y_end+oper_thk)*dir, 15,
					over_cut_end, -oper_thk*dir, 15,
					0, -oper_thk*dir, 15,
					0, 0, -1

			del 3
		endif
		del 1
	endif
endgroup


!---------------------!
! Do the window holes !
!---------------------!

group "window/door"
	if cut_set[4]=1 then
		dim corner_cuts[][]
		if wd_num<>0 then       ! Do the holes
			epszilon=0.001
			corn_num=1

			rotx 90
			for i=1 to wd_num
				ins_point=0
				corner_end=0
				corner_beg=0
				for j=2 to 2*int((ac_wd_poly[i][1]+1/4")/1") step 2
					if ac_wd_poly[i][j]>=ac_wall_length-epszilon and ac_angles[sg_num][2]<90 then
						put ac_wd_poly[i][j]*ratio
						put ac_wd_poly[i][j+1]
						put 79

						if corner_end=0 then
							corner_cuts[1][1]=(ac_wd_poly[i][j]-epszilon)*ratio
							corner_cuts[1][2]=ac_wd_poly[i][j+1]
							corner_cuts[1][3]=(ac_wd_poly[i][j]+ref_thickness/tan(ac_angles[sg_num][2])+oper_thk)*ratio
							corner_cuts[1][4]=ac_wd_poly[i][j+1]
							corner_end=1
						else
							corner_cuts[1][5]=(ac_wd_poly[i][j]+ref_thickness/tan(ac_angles[sg_num][2])+oper_thk)*ratio
							corner_cuts[1][6]=ac_wd_poly[i][j+1]
							corner_cuts[1][7]=(ac_wd_poly[i][j]-epszilon)*ratio
							corner_cuts[1][8]=ac_wd_poly[i][j+1]
							corner_end=0
							corn_num=corn_num+1
						endif

						ins_point=1
					endif

					if ac_wd_poly[i][j]<=0+epszilon and ac_angles[1][1]>90 then
						put ac_wd_poly[i][j]*ratio
						put ac_wd_poly[i][j+1]
						put 79

						if corner_beg=0 then
							corner_cuts[1][1]=(ac_wd_poly[i][j]+epszilon)*ratio
							corner_cuts[1][2]=ac_wd_poly[i][j+1]
							corner_cuts[1][3]=(ac_wd_poly[i][j]+ref_thickness/tan(ac_angles[1][1])-oper_thk)*ratio
							corner_cuts[1][4]=ac_wd_poly[i][j+1]
							corner_beg=1
						else
							corner_cuts[1][5]=(ac_wd_poly[i][j]+ref_thickness/tan(ac_angles[1][1])-oper_thk)*ratio
							corner_cuts[1][6]=ac_wd_poly[i][j+1]
							corner_cuts[1][7]=(ac_wd_poly[i][j]+epszilon)*ratio
							corner_cuts[1][8]=ac_wd_poly[i][j+1]
							corner_beg=0
							corn_num=corn_num+1
						endif

						ins_point=1
					endif

					if ins_point=0 then
						put ac_wd_poly[i][j]*ratio
						put ac_wd_poly[i][j+1]
						put 79
					endif
					ins_point=0

				next j

				addz oper_thk*dir
				if ac_wall_radius<eps then
					! Cuts for the corner windows
					if corn_num-1<>0 then
						prism_  5, -cutting_thk*dir,  ! Just for testing
								corner_cuts[1][1], corner_cuts[1][2], 15,
								corner_cuts[1][3], corner_cuts[1][4], 15,
								corner_cuts[1][5], corner_cuts[1][6], 15,
								corner_cuts[1][7], corner_cuts[1][8], 15,
								corner_cuts[1][1], corner_cuts[1][2], -1
					endif

					! Cuts for the normal windows
					prism_  int((ac_wd_poly[i][1]+1/4")/1"), -cutting_thk*dir,
							get(nsp)
				else
					! Cuts for the corner windows
					if corn_num-1<>0 then
						bprism_ gs_mat, gs_mat, gs_mat,
								5, -cutting_thk*dir, ac_wall_radius, !!!!+oper_thk*dir
								corner_cuts[1][1], corner_cuts[1][2], 15,
								corner_cuts[1][3], corner_cuts[1][4], 15,
								corner_cuts[1][5], corner_cuts[1][6], 15,
								corner_cuts[1][7], corner_cuts[1][8], 15,
								corner_cuts[1][1], corner_cuts[1][2], -1
					endif
					put use(3)

					! Cuts for the normal windows

					bprism_ gs_mat, gs_mat, gs_mat,
							int((ac_wd_poly[i][1]+1/4")/1")+1, -cutting_thk*dir, ac_wall_radius*ratio,
							get(nsp)
				endif
				del 1
			next i
			del 1

			corn_num=corn_num-1
		endif
	endif
endgroup

! Do the conection holes

group "connecting walls"
	if cut_set[5]=1 then
		if sp_num<>0 then       ! Do the holes
			if ac_wall_radius<eps then
				for i=1 to sp_num
					tan_1=ref_thickness/tan(ac_angles[i+1][1])
					tan_2=-ref_thickness/tan(180-ac_angles[i][2])

					addz ac_side_poly[i][2]
					prism_  9, ac_side_poly[i][4]-ac_side_poly[i][2],
							ac_side_poly[i][1], 0, 15,
							ac_side_poly[i][1], -oper_thk*dir, 15,
							ac_side_poly[i][3], -oper_thk*dir, 15,
							ac_side_poly[i][3], 0, 15,
							ac_side_poly[i][3]+tan_1, ref_thickness*dir, 15,
							ac_side_poly[i][3]+tan_1, (ref_thickness+oper_thk)*dir, 15,
							ac_side_poly[i][1]+tan_2, (ref_thickness+oper_thk)*dir, 15,
							ac_side_poly[i][1]+tan_2, ref_thickness*dir, 15,
							ac_side_poly[i][1], 0, -1
					del 1
				next i
			else
				for i=1 to sp_num
					! -----------------------------------------
					! Calculate the oversize for the revolution
					! -----------------------------------------

					! Center point            (u,v)=(0,ac_wall_radius)
					! Radius                  r=ac_wall_radius-ref_thickness
					! Equation of the circle  (sec_x_beg-u)^2+(sec_y_beg-v)^2=r^2
					! Slope of the line       kappa=180-ac_angles[1][1]
					! Equation of the line    sec_y_beg=tan(kappa)*sec_x_beg
					! Equation with two unkn. (1+(tan(kappa))^2)*sec_x_beg^2-2*ac_wall_radius*tan(kappa)*sec_x_beg+2*ac_wall_radius*ref_thickness-ref_thickness^2

					if ac_angles[i][2]<=90 then
					!!!!print "ac_angles[",i,"][2]<90"

						line_y=con_cur_d-con_cur_w*tan(kappa)

						kappa=ac_angles[i][2]

						a_beg=(1+(tan(kappa))^2)
						b_beg=-2*(ac_wall_radius-y)*tan(kappa)
						c_beg=2*ac_wall_radius*ref_thickness-ref_thickness^2

						if b_beg^2-4*a_beg*c_beg>=0 then
							sec_x_beg=(-b_beg-sqr(b_beg^2-4*a_beg*c_beg))/(2*a_beg)
							sec_y_beg=sec_x_beg*tan(kappa)

							print sec_x_beg,sec_y_beg
						else
							sec_x_beg=ac_wall_radius*cos(kappa)*sin(kappa)
							sec_y_beg=ac_wall_radius-ac_wall_radius*cos(kappa)*cos(kappa)
						endif
					else
					!!!!print "ac_angles[",i,"][2]>90"

						kappa=180-ac_angles[i][2]

						a_beg=(1+(tan(kappa))^2)
						b_beg=-2*(ac_wall_radius-y)*tan(kappa)
						c_beg=2*ac_wall_radius*ref_thickness-ref_thickness^2

						if b_beg^2-4*a_beg*c_beg>=0 then
							sec_x_beg=-(-b_beg-sqr(b_beg^2-4*a_beg*c_beg))/(2*a_beg)
							sec_y_beg=-sec_x_beg*tan(kappa)
						else
							sec_x_beg=-ac_wall_radius*cos(kappa)*sin(kappa)
							sec_y_beg=ac_wall_radius-ac_wall_radius*cos(kappa)*cos(kappa)
						endif
					endif

					if ac_angles[i+1][1]>=90 then
						lambda=180-ac_angles[i+1][1]

						a_end=(1+(tan(lambda))^2)
						b_end=-2*ac_wall_radius*tan(lambda)
						c_end=2*ac_wall_radius*ref_thickness-ref_thickness^2

						if b_end^2-4*a_end*c_end>=0 then
							sec_x_end=-(-b_end-sqr(b_end^2-4*a_end*c_end))/(2*a_end)
							sec_y_end=-sec_x_end*tan(lambda)
						else
							sec_x_end=-ac_wall_radius*cos(lambda)*sin(lambda)
							sec_y_end=ac_wall_radius-ac_wall_radius*cos(lambda)*cos(lambda)
						endif
					else
						lambda=ac_angles[i+1][1]

						a_end=(1+(tan(lambda))^2)
						b_end=-2*ac_wall_radius*tan(lambda)
						c_end=2*ac_wall_radius*ref_thickness-ref_thickness^2

						if b_end^2-4*a_end*c_end>=0 then
							sec_x_end=(-b_end-sqr(b_end^2-4*a_end*c_end))/(2*a_end)
							sec_y_end=sec_x_end*tan(lambda)
						else
							sec_x_end=ac_wall_radius*cos(lambda)*sin(lambda)
							sec_y_end=ac_wall_radius-ac_wall_radius*cos(lambda)*cos(lambda)
						endif
					endif

					con_width=(ac_side_poly[i][3]-ac_side_poly[i][1])
					szigma=con_width/2*180/(ac_wall_radius*Pi)
					con_cur_w=ac_wall_radius*sin(szigma)	! Conection Width/2 Stratight Length from the Curved Length
					con_cur_d=ac_wall_radius*(1-cos(szigma)) ! Conection Width/2 Stratight Length from the Curved Length

					beg_x=sec_x_beg*cos(-szigma)-sec_y_beg*sin(-szigma)
					beg_y=sec_x_beg*sin(-szigma)+sec_y_beg*cos(-szigma)

					end_x=sec_x_end*cos(szigma)-sec_y_end*sin(szigma)
					end_y=sec_x_end*sin(szigma)+sec_y_end*cos(szigma)

	!!!!				print "ref_thickness",ref_thickness
	!!!!				print "sec_x_beg=",sec_x_beg,"sec_y_beg=",sec_y_beg,"sec_x_end=",sec_x_end,"sec_y_end=",sec_y_end
	!!!!				print "con_cur_w=",con_cur_w," con_cur_d=",con_cur_d

					addy ac_wall_radius
					rotz 180*(ac_side_poly[i][3]+ac_side_poly[i][1])/2/ac_wall_radius/pi
					add 0,-ac_wall_radius,ac_side_poly[i][2]
					prism_  9, ac_side_poly[i][4]-ac_side_poly[i][2],
						   -con_cur_w, con_cur_d*dir, 15,
						   -con_cur_w, -oper_thk*dir, 15,
							con_cur_w, -oper_thk*dir, 15,
							con_cur_w, con_cur_d*dir, 15,
							con_cur_w+end_x, (con_cur_d+end_y)*dir, 15,
							con_cur_w+end_x, (con_cur_d+end_y+oper_thk)*dir, 15,
						   -con_cur_w+beg_x, (con_cur_d+beg_y+oper_thk)*dir, 15,
						   -con_cur_w+beg_x, (con_cur_d+beg_y)*dir, 15,
						   -con_cur_w, con_cur_d*dir, -1
					del 3
				next i
			endif
		endif
	endif
endgroup

!!!!if gs_gdl_debug then
!!!!	model wire
!!!!	placegroup "connecting walls"
!!!!	model solid
!!!!endif

!!-----------------------!!!-----------------------!!!-----------------------!!
!! End Of Cutting Bodies !!! End Of Cutting Bodies !!! End Of Cutting Bodies !!
!!-----------------------!!!-----------------------!!!-----------------------!!

!!!!placegroup "lower cut"
!!!!placegroup "upper cut"
!!!!placegroup "end cuts"
!!!!placegroup "window/door"

cut_1=addgroup("lower cut","upper cut")
cut_2=addgroup(cut_1,"end cuts")
cut_3=addgroup(cut_2,"window/door")
cutting_body=addgroup(cut_3,"connecting walls")

placegroup cutting_body

killgroup "lower cut"
killgroup "upper cut"
killgroup "end cuts"
killgroup "window/door"
killgroup "connecting walls"

killgroup cut_1
killgroup cut_2
killgroup cut_3
killgroup cutting_body

END

!!----------------!!!----------------!!!----------------!!!----------------!!
!! Polygon Offset !!! Polygon Offset !!! Polygon Offset !!! Polygon Offset !!
!!----------------!!!----------------!!!----------------!!!----------------!!
9501:

dim data[][]

polygon=empty	!! Empty the Polygon Array
data=empty		!! Empty the Data Array

dir_x=-1	!! Mindig ala kerul az offsetelt az eredetinek
dir_y=1

!-------------------------
! Start the polygon offset
!-------------------------

If abs(offset)<epszilon Then
	polygon=transfer
	return
EndIf

i=1
data[i][1]=0
data[i][2]=0
data[i][3]=0       ! Direction vector
data[i][4]=1       ! Direction vector

for i=2 to vardim1(transfer)           ! Precalculate the data
	data[i][3]=transfer[i][1]-transfer[i-1][1]       ! Direction vector
	data[i][4]=transfer[i][2]-transfer[i-1][2]       ! Direction vector

	length=sqr(data[i][3]^2+data[i][4]^2)            ! Make the unit vector
	vect_x=offset*dir_x*data[i][4]/length
	vect_y=offset*dir_y*data[i][3]/length

	data[i][1]=transfer[i-1][1]+vect_x
	data[i][2]=transfer[i-1][2]+vect_y
next i

data[i][1]=transfer[vardim1(transfer)][1]
data[i][2]=0
data[i][3]=0       ! Direction vector
data[i][4]=1       ! Direction vector

g=1
for i=1 to vardim1(transfer)
	x0=data[i][1]
	y0=data[i][2]
	v_1=data[i][3]
	v_2=data[i][4]

	a0=data[i+1][1]
	b0=data[i+1][2]
	u_1=data[i+1][3]
	u_2=data[i+1][4]

	if abs(v_1*u_2-u_1*v_2)>epszilon then   ! If the points are situated in a line
		y=((v_2*(u_2*a0-u_1*b0))-(u_2*(v_2*x0-v_1*y0)))/(v_1*u_2-u_1*v_2)
		if abs(u_2)>eps then
			x=(u_2*a0-u_1*b0+u_1*y)/u_2
		else
			x=(v_2*x0-v_1*y0+v_1*y)/v_2
		endif

		polygon[g][1]=x
		polygon[g][2]=y

		g=g+1
	endif
next i

return



