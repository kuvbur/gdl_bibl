

! =============================================================================
! GS Skylight Functions
! =============================================================================

call "GS Skylight Functions",
	parameters all	bEnableLining			= bEnableLining,
					bEnableEdgeTypesUpper	= bEnableEdgeTypesUpper,
					bEnableEdgeTypesLower	= bEnableEdgeTypesLower,
	returned_parameters	iLoD3D,
						lod3D_Casing,
						bOplines3d, opLineType3dIn, opLineType3dOut, gs_opline_style_m, gs_opLinePen


! Horizontal and low Roof
if abs(ac_roofang) < MIN_ROOF_ANGLE | ac_roofang > 90 + EPS then
	rotx ac_roofang

	B = max(B, 1.0)
	B = min(B, 3.0)

	if SHELLBASE_VIEW_PEN > 0 then
		pen SHELLBASE_VIEW_PEN
	else
		pen 1
	endif

	material ac_side_mat
	wallniche 4, 1, 8+16,
		0, 0, 1,	0,
		 A/2, 0, 31,
		-A/2, 0, 31,
		-A/2, B, 31,
		 A/2, B, 31

	hotspot -A/2,0,0, 100
	hotspot  A/2,0,0, 101
	hotspot -A/2,B,0, 102
	hotspot  A/2,B,0, 103

	del 1

	end
endif


! ==============================================================================
! Hotspots
! ==============================================================================

![#COMPATIBILITY] - START
if gs_a_half < EPS then gs_a_half = A / 2
![#COMPATIBILITY] - END

dGlas = 0.01
dBlende = 0.01  ! Dicke der Ortgang-Blende.


pen gs_cont_pen

summaHoehe = zHoeheSturzAnsicht+zOkFenster+zDickeSchleppdach

unID = 1
hotspot 0, 0, 0, unID :	unID=unID+1
hotspot -A/2-dUeberstandSchleppdach, -dUeberstandSchleppdach, summaHoehe, unID :	unID=unID+1
hotspot  A/2+dUeberstandSchleppdach, -dUeberstandSchleppdach, summaHoehe, unID :	unID=unID+1

rotx ac_roofang

hotspot  0,			0,0,	unID,gs_a_half,1+128,A:		unID=unID+1
hotspot -1,			0,0,	unID,gs_a_half,3,	 A:		unID=unID+1
hotspot  gs_a_half,	0,0,	unID,gs_a_half,2,	 A:		unID=unID+1

hotspot  0,			B,0,	unID,gs_a_half,1+128,A:		unID=unID+1
hotspot -1,			B,0,	unID,gs_a_half,3,	 A:		unID=unID+1
hotspot  gs_a_half,	B,0,	unID,gs_a_half,2,	 A:		unID=unID+1

hotspot  0,			0,0,	unID,gs_a_half,1+128,A:		unID=unID+1
hotspot  1,			0,0,	unID,gs_a_half,3,	 A:		unID=unID+1
hotspot -gs_a_half,	0,0,	unID,gs_a_half,2,	 A:		unID=unID+1

hotspot  0,			B,0,	unID,gs_a_half,1+128,A:		unID=unID+1
hotspot  1,			B,0,	unID,gs_a_half,3,	 A:		unID=unID+1
hotspot -gs_a_half,	B,0,	unID,gs_a_half,2,	 A:		unID=unID+1


! ==============================================================================
! Wallhole
! ==============================================================================

if useroofmat then   !### Dach-Material.
	lower_mat	= ac_lower_mat
	upper_mat	= ac_upper_mat
	side_mat	= ac_side_mat
	wall_inside_mat	 = ac_lower_mat
	wall_inside_mat2 = ac_lower_mat
else
	lower_mat	= matDachunterseite
	upper_mat	= matDachOberseite
	side_mat	= matOrtgangTraufe
	wall_inside_mat	 = matWandInnen
	wall_inside_mat2 = matWandInnen2
endif


! Lower cutting

if B < EPS then
	BB = zOkFenster
	AC_edge_lower_type = 1
else
	BB = B
	AC_edge_lower_type = AC_edge_lower_type
endif

call "SkylightRect_RoofCutting_macro" parameters all A = A - 2*dWandGaube,
		B					= BB,
		AC_edge_lower_type	= AC_edge_lower_type,
		AC_edge_upper_type	= 3,
		AC_edge_upper_angle = ac_roofang - wSchleppdach,
		ac_upper_mat		= upper_mat,
		gs_lower_bott_mat	= wall_inside_mat,
		gs_lower_top_mat	= lower_mat,
		bUpperCut			= 0,
		ShowUpContLines		= 1


! Upper cutting

if SHELLBASE_VIEW_PEN > 0 then
	pen SHELLBASE_VIEW_PEN
else
	pen 1
endif
material upper_mat

ang_diff = ac_roofang-wSchleppdach
head_mod = dUeberstandSchleppdach * tan(wSchleppdach)
tmp_h = (zOkFenster + head_mod) * cos(ac_roofang)
proj_lgh = (zOkFenster + head_mod) * sin(ac_roofang) + tmp_h / tan(ang_diff)


wallniche 8, 1, 2+16,
	0, cos(ang_diff), -sin(ang_diff),	0,
	-A/2 - dUeberstandSchleppdach - dBlende, proj_lgh, 31,
	-A/2 - dUeberstandSchleppdach - dBlende, proj_lgh + ((zDickeSchleppdach + hBlende)*cos(wSchleppdach)) / sin(ang_diff), 31,
	-A/2 - dUeberstandSchleppdach, proj_lgh + ((zDickeSchleppdach + hBlende)*cos(wSchleppdach)) / sin(ang_diff), 31,
	-A/2 - dUeberstandSchleppdach, proj_lgh + (zDickeSchleppdach*cos(wSchleppdach)) / sin(ang_diff) , 31,
	A/2 + dUeberstandSchleppdach, proj_lgh + (zDickeSchleppdach*cos(wSchleppdach)) / sin(ang_diff) , 31,
	A/2 + dUeberstandSchleppdach, proj_lgh + ((zDickeSchleppdach + hBlende)*cos(wSchleppdach)) / sin(ang_diff), 31,
	A/2 + dUeberstandSchleppdach + dBlende, proj_lgh + ((zDickeSchleppdach + hBlende)*cos(wSchleppdach)) / sin(ang_diff), 31,
	A/2 + dUeberstandSchleppdach + dBlende, proj_lgh, 31


if ac_roofang < 90 - EPS then
	addx -A/2
	roty 90
	wallniche 3, 1, 2,
		0, 0, 1, A,
		0, 0, 31,
		0, proj_lgh, 31,
		-tmp_h, (zOkFenster + head_mod) * sin(ac_roofang), 31
	del 2
endif

del 1

pen gs_cont_pen


addx -a/2

xBreite        = A !PARAM X Dimension
yTiefe         = B !PARAM Y Dimension

if dToleranz < 0.001 then
  dToleranz = 0.003
endif

toler dToleranz

matWandAussen = matWandAus

rRinne = xBreiteRinne / 2   ! Halber Durchmesser der Regenrinne.

if matDachOberseite <= 0 then
  matDachOberseite = matWandAus
endif

if matFensterrahmen <= 0 then
  matFensterrahmen = matWandAus
endif

dSprossenHalb = dSprossen / 2
hFenster = zOkFenster - zUkFenster
zOkRahmenUnten = zUkFenster + dRahmen
zUkRahmenOben = zOkFenster - dRahmen
zUkSprosseMin = zUkFenster + dRahmen + 0.01
zUkSprosseMax = zUkRahmenOben - dSprossen - 0.01

xLkVorderwand = dWandGaube
xRkVorderwand = xBreite - dWandGaube
zTraufe = zOkFenster + zHoeheSturzAnsicht

tanDach = tan(ac_roofang)   !### Wir wollen mit dem Tangens rechnen.

if wSchleppdach < 0 then
  !### Es ist keine Schleppdachneigung angegeben.
  !### Benutze die Neigung aus der Tiefe:

  tanSchleppdach = (yTiefe * tanDach - zTraufe) / (dUeberstandSchleppdach + yTiefe)
  cosSchleppdach = 1 / sqr(1 + tanSchleppdach * tanSchleppdach)
  sinSchleppdach = tanSchleppdach * cosSchleppdach
else
  !### Es ist eine Schleppdachneigung angegeben.
  !### Benutze diese Neigung, und berechne die Tiefe daraus:

  cosSchleppdach = cos(wSchleppdach)
  sinSchleppdach = sin(wSchleppdach)
  tanSchleppdach = sinSchleppdach / cosSchleppdach
  yTiefe = (zTraufe + dUeberstandSchleppdach * tanSchleppdach) / (tanDach - tanSchleppdach)
endif



zOkVorderwand = zTraufe + dUeberstandSchleppdach * tanSchleppdach



!### Vorderwand:

!### Viereckiges Prisma mit Null oder mehr viereckigen Lochern,
!### die auch bis an die Unterkante der Wand reichen konnen.

rotx 90   !### Kippe in die Senkrechte.
addz -dWandGaube


if iLoD3D > SYMBS_3D_S_1 then
	mask_draw = 15
	mask_hide = 11
else
	mask_draw = 1
	mask_hide = 0
endif

  ! Aussenumriss (ohne Unterkante):

if iLoD3D > SYMBS_3D_S_1 then
	put xRkVorderwand, 0, 11,
		xRkVorderwand, zOkVorderwand, 0,
		xLkVorderwand, zOkVorderwand, 9,
		xLkVorderwand, 0, 15
else
	put xRkVorderwand + dWandGaube, 0, 1,
		xRkVorderwand + dWandGaube, zOkVorderwand + zDickeSchleppdach, 1,
		xLkVorderwand - dWandGaube, zOkVorderwand + zDickeSchleppdach, 1,
		xLkVorderwand - dWandGaube, 0, 1
endif

if zUkFenster > 0 then
  !### Mit Brustung: Schliesse die Unterkante der Vorderwand.
  put 0, 0, 700
endif


if nFenster >= 1 then

  !### Die Fensteroffnung(en):

  xLkFenster1 = (xBreite - nFenster * xFensterbreite - (nFenster - 1) * xAbstandFenster) / 2


  xLkFenster = xLkFenster1

  for iFenster = 1 to nFenster
	xRkFenster = xLkFenster + xFensterbreite

	put xLkFenster, zUkFenster, mask_draw,
		xLkFenster, zOkFenster, mask_draw,
		xRkFenster, zOkFenster, mask_draw,
		xRkFenster, zUkFenster, mask_draw

	if zUkFenster > 0 then
	  !### Mit Brustung: Schliesse die Unterkante des Fensters.
	  put 0, 0, 700
	endif

	xLkFenster = xRkFenster + xAbstandFenster
  next iFenster

endif


if iLoD3D > SYMBS_3D_S_1 then
	cprism_ matWandAussen, wall_inside_mat2, matWandOeffnung,
	  nsp/3, dWandGaube, get(nsp)
else
	material wall_inside_mat2
	addz dWandGaube
	poly_ nsp/3,
			use(nsp)
	material matWandAussen
	addz 0.0002
	poly_ nsp/3,
			get(nsp)
	del 2
endif



if nFenster >= 1 and dRahmen > 0 then

  !### Die Fenster:

  bDebug_Glas = 1
  addz dWandGaube - dLeibung - dProfil


  xLkFenster = xLkFenster1

  for iFenster = 1 to nFenster
	xRkFenster = xLkFenster + xFensterbreite

	gosub 2222 !### Fenster.

	xLkFenster = xRkFenster + xAbstandFenster
  next iFenster

  del 1

endif




roty 90
addz dWandGaube

if tanSchleppdach > 0 & iLoD3D > SYMBS_3D_S_1 then
  cprism_ matWandOeffnung, matWandOeffnung, wall_inside_mat2,
	3, xBreite - dWandGaube - dWandGaube,   !### Dreikant-Fullstuck uber der Vorderwand.
	-dWandGaube, zOkVorderwand, 0,
	0, zOkVorderwand, 13,
	0, zOkVorderwand + dWandGaube * tanSchleppdach, 15
endif

del 4



!### Linke Seitenwand:

yHinten = yTiefe + zDickeSchleppdach / (tanDach - tanSchleppdach)
zHinten = yHinten * tanDach
zVorne = zHinten - (yHinten + dUeberstandSchleppdach) * tanSchleppdach


material wall_inside_mat   !### (Material des Objekts fur die Wande.)

gosub 1000

!### Rechte Seitenwand:

addx xBreite
mulx -1
gosub 1000
del 2

!### Dach:



hotspot -dUeberstandSchleppdach, yHinten ,tan(ac_roofang)*yHinten, unID :	unID=unID+1
hotspot A+dUeberstandSchleppdach, yHinten ,tan(ac_roofang)*yHinten, unID :	unID=unID+1



material ac_upper_mat

base

!### Gaubendach jetzt als cslab_, damit wir verschiedene Materialien verwenden konnen:
!### (Das Gaubendach ragt jetzt allerdings oben in das Hauptdach hinein.) GRR 98-06-15

if iLoD3D > SYMBS_3D_S_1 then
	addz -zDickeSchleppdach

	cslab_ upper_mat, lower_mat, side_mat,
		4, zDickeSchleppdach,
		-dUeberstandSchleppdach, -dUeberstandSchleppdach, zVorne, 15,
		xBreite + dUeberstandSchleppdach, -dUeberstandSchleppdach, zVorne, 15,
		xBreite + dUeberstandSchleppdach, yHinten, zHinten, 14,
		-dUeberstandSchleppdach, yHinten, zHinten, 15

	del 1
else
	material upper_mat
	plane_	4,
		-dUeberstandSchleppdach, -dUeberstandSchleppdach, zVorne + 0.0003, 1,
		xBreite + dUeberstandSchleppdach, -dUeberstandSchleppdach, zVorne + 0.0003, 1,
		xBreite + dUeberstandSchleppdach, yHinten, zHinten + 0.0003, 1,
		-dUeberstandSchleppdach, yHinten, zHinten + 0.0003, 1
	material lower_mat
	plane_	4,
		-dUeberstandSchleppdach, -dUeberstandSchleppdach, zVorne + 0.0001, 1,
		xBreite + dUeberstandSchleppdach, -dUeberstandSchleppdach, zVorne + 0.0001, 1,
		xBreite + dUeberstandSchleppdach, yHinten, zHinten + 0.0001, 1,
		-dUeberstandSchleppdach, yHinten, zHinten + 0.0001, 1
endif


!	if GLOB_CONTEXT <> 5 then
!		roofthk_atf = ac_roofthk / sin(ac_roofang - wSchleppdach)
!
!		add xBreite/2, dWandGaube, zOkVorderwand + tan(wSchleppdach) * dWandGaube - 0.001
!		rotx wSchleppdach
!		poly_ 4,
!			-xBreite/2 + dWandGaube + 0.001, 0, 1,
!			xBreite/2 - dWandGaube - 0.001, 0, 1,
!			xBreite/2 - dWandGaube - 0.001, (yTiefe-dWandGaube + roofthk_atf * cos(wSchleppdach)) / cos(wSchleppdach) - 0.001/tan(ac_roofang - wSchleppdach), 1,
!			-xBreite/2 + dWandGaube + 0.001, (yTiefe-dWandGaube + roofthk_atf * cos(wSchleppdach)) / cos(wSchleppdach) - 0.001/tan(ac_roofang - wSchleppdach), 1
!
!		vert 0, 0, 0
!		vert 1, 0, 0
!		vert 0, 1, 0
!		vert 0, 0, 1
!		coor 2, -1, -2, -3, -4
!		body 1
!
!		del 2
!	endif

rotz 90
vert 0, 0, 0
vert 0, 1, 0
vert 1, 0, 0
vert 0, 0, 1
coor 1, -1, -2, -3, -4
body 1
del 1


!### Traufbretter:

if iLoD3D > SYMBS_3D_M_1 then
	rotx 90
	roty 90
	addz -dUeberstandSchleppdach - dBlende

	dzBlende = zDickeSchleppdach + hBlende
	zVorne = zTraufe + dzBlende
	zDachVorne = - dUeberstandSchleppdach * tanDach
	yHinten = -dUeberstandSchleppdach + (zVorne - zDachVorne) / (tanDach - tanSchleppdach)
	zHinten = zVorne + (yHinten + dUeberstandSchleppdach) * tanSchleppdach

	cprism_ matOrtgangTraufe, matOrtgangTraufe, matOrtgangTraufe,
	  4, dBlende,
	  -dUeberstandSchleppdach, zVorne - dzBlende, 15,
	  yHinten, zHinten - dzBlende, 15,
	  yHinten, zHinten, 15,
	  -dUeberstandSchleppdach, zVorne, 15

	addz dBlende + dUeberstandSchleppdach + xBreite + dUeberstandSchleppdach

	cprism_ matOrtgangTraufe, matOrtgangTraufe, matOrtgangTraufe,
	  4, dBlende,
	  -dUeberstandSchleppdach, zVorne - dzBlende, 15,
	  yHinten, zHinten - dzBlende, 15,
	  yHinten, zHinten, 15,
	  -dUeberstandSchleppdach, zVorne, 15

	del 4
endif


if bRinne & iLoD3D > SYMBS_3D_M_1 then

  !### Regenrinne:

  material matRinne

  add -dUeberstandSchleppdach, -dUeberstandSchleppdach - rRinne, zVorne - hBlende
  rotx 180

  revolve 2, 180, 1+2+16+32,
	0, rRinne, 0,
	dUeberstandSchleppdach + xBreite + dUeberstandSchleppdach, rRinne, 0

  del 2

endif



!### Ende:

end





1000:
!############## Unterroutine Seitenwand: ##############

!### Die Seitenwand ist ein 4-eckiges Prisma:

rotx 90
roty 90

if ac_roofang < 90 - EPS then


	if iLoD3D > SYMBS_3D_S_1 then
		cprism_ wall_inside_mat, matWandAussen, matWandAussen,
			4, dWandGaube,
			0, 0, 15,
			0, 0, 11,
			yTiefe, yTiefe * tanDach, 15,
			0, zOkVorderwand, 11
	else
		material wall_inside_mat
		plane_ 4,
			0, 0, 0, 1,
			0, 0, 0, 1,
			yHinten, zHinten, 0, 1,
			0, zOkVorderwand + zDickeSchleppdach, 0, 1
		addz -0.0002
		material matWandAussen
		plane_ 4,
			0, 0, 0, 1,
			0, 0, 0, 1,
			yHinten, zHinten, 0, 1,
			0, zOkVorderwand + zDickeSchleppdach, 0, 1
		del 1
	endif

	roofthk_atf = ac_roofthk / sin(ac_roofang - wSchleppdach)

!	if GLOB_CONTEXT <> 5 then
!		addz dWandGaube+0.001
!		poly_ 6,
!			yTiefe + roofthk_atf * cos(wSchleppdach), yTiefe * tanDach + roofthk_atf * sin(wSchleppdach), 1,
!			dWandGaube, zOkVorderwand + tan(wSchleppdach) * dWandGaube, 1,
!			dWandGaube,0, 1,
!			0,0,1,
!			0, 0, 1,
!			0, -ac_roofthk / cos(ac_roofang), 1
!
!		vert 0, 0, 0
!		vert 1, 0, 0
!		vert 0, 1, 0
!		vert 0, 0, 1
!		coor 2, -1, -2, -3, -4
!		body 1
!
!		del 1
!	endif

endif

del 2

return
!############## Ende Unterroutine Seitenwand ##############





!##############################
2222: !### Unterroutine Fenster
!##############################

if iLoD3D >= SYMBS_3D_M_1 then
	mask = 15
else
	mask = 1
endif

bGlas = 0
bDebug_Fensterrahmen = 1

xRkRahmenLinks = xLkFenster + dRahmen
xLkRahmenRechts = xRkFenster - dRahmen

xLkSprosse = xLkFenster + (xFensterbreite - dSprossen) / 2
xRkSprosse = xLkSprosse + dSprossen


	! Aussenumriss Fenster:

put xLkFenster, zUkFenster, mask,
	xLkFenster, zOkFenster, mask,
	xRkFenster, zOkFenster, mask,
	xRkFenster, zUkFenster, mask,
	0, 0, 700

if iLoD3D > SYMBS_3D_S_1 then
	if nSprossenHor = 0 then
		!### Keine waagerechten Sprossen:

		zUkAusschnitt = zOkRahmenUnten
		zOkAusschnitt = zUkRahmenOben
		gosub 2000 !### Ausschnitt (Ggf. mit vert. Sprosse)

	else
		!### Mindestens eine waagerechte Sprosse.

		zSprosseMin = zUkSprosseMin + dSprossenHalb
		zSprosseMax = zUkSprosseMax + dSprossenHalb

		if abs(zSprosse1)>eps and abs(zSprosseN)>eps and zSprosse1>zSprosseN then
			xSwapped = zSprosse1
			zSprosse1 = zSprosseN
			zSprosseN = xSwapped
		endif

		if abs(zSprosse1)>eps and zSprosse1 < zSprosseMin then
			zSprosse1 = zSprosseMin
		endif

		if zSprosseN > zSprosseMax then
			zSprosseN = zSprosseMax
		endif


		if zSprosse1 <= 0 and zSprosseN <= 0 then
			!### Wahle zSprosse1 und zSprosseN automatisch:

			!### Sprossenhohen fur rechteckiges Fenster:

			hAusschnitt = (hFenster - 2 * dRahmen - nSprossenHor * dSprossen) / (nSprossenHor + 1)
			zSprosse1 = zOkRahmenUnten + hAusschnitt + dSprossenHalb
			zSprosseN = zUkRahmenOben - hAusschnitt - dSprossenHalb

		endif

		if zSprosse1 > 0 and zSprosseN <= 0 then
			!### Wahle zSprosseN automatisch:

			!### Sprossenhohen fur rechteckiges Fenster:

			hAusschnitt = (zUkRahmenOben - (zSprosse1 + dSprossenHalb) - (nSprossenHor - 1) * dSprossen) / nSprossenHor
			zSprosseN = zUkRahmenOben - hAusschnitt - dSprossenHalb

		endif

		if zSprosse1 <= 0 and zSprosseN > 0 then
			!### Wahle zSprosse1 automatisch:

			hAusschnitt = (zSprosseN - dSprossenHalb - zOkRahmenUnten - (nSprossenHor - 1) * dSprossen) / nSprossenHor
			zSprosse1 = zOkRahmenUnten + hAusschnitt + dSprossenHalb
		endif

		zUkSprosse1 = zSprosse1 - dSprossenHalb
		zUkSprosseN = zSprosseN - dSprossenHalb


		zUkAusschnitt = zOkRahmenUnten
		zOkAusschnitt = zUkSprosse1
		gosub 2000 !### Erster Ausschnitt (Ggf. mit vert. Sprosse)

		if nSprossenHor >= 2 then

			hAusschnitt = (zSprosseN - zSprosse1 - (nSprossenHor - 1) * dSprossen) / (nSprossenHor - 1)
			dzAusschnitt = hAusschnitt + dSprossen
			zUkAusschnitt = zUkSprosse1 + dSprossen
			zOkAusschnitt = zUkAusschnitt + hAusschnitt

			for iSprosse = 2 to nSprossenHor
				gosub 2000 !### Mittlerer Ausschnitt (Ggf. mit vert. Sprosse)

				zUkAusschnitt = zUkAusschnitt + dzAusschnitt
				zOkAusschnitt = zOkAusschnitt + dzAusschnitt
			next iSprosse

		endif

		zUkAusschnitt = zUkSprosseN + dSprossen
		zOkAusschnitt = zUkRahmenOben
		gosub 2000 !### Oberster Ausschnitt (Ggf. mit vert. Sprosse)
	endif


	material matFensterrahmen	 !### Fensterrahmen-Material.

	if iLoD3D >= SYMBS_3D_M_1 then
		if bDebug_Fensterrahmen then
			if iLoD3D > SYMBS_3D_M_1 then
				prism_ nsp / 3, dProfil, get(nsp)
			else
				addz -dWandGaube/2 + dProfil
					prism_ nsp / 3, dWandGaube, get(nsp)
				del 1
			endif
		else
			x = max(get(nsp))
		endif
	else
		if bDebug_Fensterrahmen then
			addz dProfil
			poly_ nsp / 3, get(nsp)
			del 1
		else
			x = max(get(nsp))
		endif
	endif
	body -1
else
	material matGlas
	if bDebug_Fensterrahmen then
		addz dWandGaube !dProfil
		poly_ nsp / 3, get(nsp)
		del 1
		body -1
	endif
endif

if matGlas <> 0 & iLoD3D > SYMBS_3D_S_1 then

	!### Glasscheibe:

	bGlas = 1

	material matGlas
	addz (dProfil - dGlas) / 2

	if nSprossenHor = 0 then
	!### Keine waagerechten Sprossen:

	zUkAusschnitt = zOkRahmenUnten
		 zOkAusschnitt = zUkRahmenOben
	gosub 2000 !### Oberster Ausschnitt (Ggf. mit vert. Sprosse)

	else
	!### Mindestens eine waagerechte Sprosse.

	zUkAusschnitt = zOkRahmenUnten
	zOkAusschnitt = zUkSprosse1

	gosub 2000 !### Erster Ausschnitt (Ggf. mit vert. Sprosse)

	if nSprossenHor >= 2 then

		hAusschnitt = (zSprosseN - zSprosse1 - (nSprossenHor - 1) * dSprossen) / (nSprossenHor - 1)
		dzAusschnitt = hAusschnitt + dSprossen
		zUkAusschnitt = zUkSprosse1 + dSprossen
		zOkAusschnitt = zUkAusschnitt + hAusschnitt

		for iSprosse = 2 to nSprossenHor
		gosub 2000 !### Mittlerer Ausschnitt (Ggf. mit vert. Sprosse)

		zUkAusschnitt = zUkAusschnitt + dzAusschnitt
		zOkAusschnitt = zOkAusschnitt + dzAusschnitt
		next iSprosse

	endif

	zUkAusschnitt = zUkSprosseN + dSprossen

		 zOkAusschnitt = zUkRahmenOben
	gosub 2000 !### Oberster Ausschnitt (Ggf. mit vert. Sprosse)

	endif

	del 1

endif



return

!############ Ende Unterroutine Fenster ############





!##############################################
2000: ! Ausschnitt (Ggf. mit vert. Sprosse)
	  ! Parameter: zUkAusschnitt, zOkAusschnitt
!##############################################


if not(bGlas or bDebug_Fensterrahmen) then
  return
endif

if bSprosseVert then

	!### Ausschnitt mit vertikaler Sprosse (= zwei Ausschnitte):

	put xRkRahmenLinks, zUkAusschnitt, mask,
		xLkSprosse, zUkAusschnitt, mask,
		xLkSprosse, zOkAusschnitt, mask,
		xRkRahmenLinks, zOkAusschnitt, mask,
		0, 0, 700

	gosub "GlassDrawing"

	put xRkSprosse, zUkAusschnitt, mask,
		xLkRahmenRechts, zUkAusschnitt, mask,
		xLkRahmenRechts, zOkAusschnitt, mask,
		xRkSprosse, zOkAusschnitt, mask,
		0, 0, 700

	gosub "GlassDrawing"

else

	!### Ausschnitt ohne vertikale Sprosse:

	put xRkRahmenLinks, zUkAusschnitt, mask,
		xLkRahmenRechts, zUkAusschnitt, mask,
		xLkRahmenRechts, zOkAusschnitt, mask,
		xRkRahmenLinks, zOkAusschnitt, mask,
		0, 0, 700

	gosub "GlassDrawing"

endif

return

!############ Ende Unterroutine Ausschnitt ############


! ############ Drawing the glass ############
"GlassDrawing":

if bGlas then
	if bDebug_Glas then
		if iLoD3D > SYMBS_3D_M_1 then
			prism_ nsp/3, dGlas, get(nsp)
		else
			if iLoD3D = SYMBS_3D_M_1 then
				addz dProfil/2+dGlas/2-dWandGaube/2
				poly_ nsp / 3, use(nsp)
				addz dWandGaube
				poly_ nsp / 3, get(nsp)
				del 1
			else
				addz dProfil/2+dGlas/2
				poly_ nsp / 3, get(nsp)
			endif
			del 1
		endif
	else
		print "prism_ ", nsp/3, ", ", dGlas, ",\n", get(nsp)
	endif
endif

return

