
! Contact person: <SzL, NJ>

! =============================================================================

lod3D = 0										! Don't draw anything
if (GLOB_VIEW_TYPE = 9 & GLOB_PREVIEW_MODE = 0) then	! in case of Surface IS Calculation
	lod3D = 2	! Detailed
else
	if iDWDet3D = DETLEVEL_DW3D_SIMPLE then lod3D = 1	! Simple
	if iDWDet3D = DETLEVEL_DW3D_DETAILED then lod3D = 2	! Detailed
	if iDWDet3D = DETLEVEL_DW3D_CHI_SIMPLE | iDWDet3D = DETLEVEL_DW3D_CHI_DETAILED then
		if (GLOB_CONTEXT = 4 | GLOB_CONTEXT = 24 | GLOB_CONTEXT = 6) then
			lod3D = 5								! Chinese
		else
			lod3D = 2
		endif
	endif
endif

gs_fillFr		= gs_bFills * gs_fillFr
gs_penFr_fg		= gs_bFills * gs_penFr_fg
gs_penFr_bg		= gs_bFills * gs_penFr_bg

gs_fillSash		= gs_bFills * gs_fillSash
gs_penSash_fg	= gs_bFills * gs_penSash_fg
gs_penSash_bg	= gs_bFills * gs_penSash_bg

if not(gs_shadow) then shadow off

stack_mask_l = 13
if gs_stack_left then stack_mask_l = 8
stack_mask_r = 13
if gs_stack_right then stack_mask_r = 8

stack_mask_b = 15
if gs_stack_bottom then stack_mask_b = 8
stack_mask_t = 15
if gs_stack_top then stack_mask_t = 8


! =============================================================================
! GS Window Functions
! =============================================================================

call "GS Window Functions",
	parameters all	iWindowShape			= iWindowShape,
					gs_IsCurved				= gs_IsCurved,
					bParalellInCurvedWalls	= bParalellInCurvedWalls,
					lod3D					= lod3D,
					bDisabeMirroring		= bDisabeMirroring,
	returned_parameters	ac_unit_width,
						ac_unit_height,
						gs_frame_ovhg_left_out,
						gs_frame_ovhg_right_out,
						gs_frame_ovhg_top_out,
						gs_frame_ovhg_bottom_out,
						gs_frame_ovhg_left_in,
						gs_frame_ovhg_right_in,
						gs_frame_ovhg_top_in,
						gs_frame_ovhg_bottom_in,
						bMirrored,
						xform11, xform12, xform13, xform14,
						xform21, xform22, xform23, xform24,
						xform31, xform32, xform33, xform34,

						bOplines3d, opLineType3dIn, opLineType3dOut, gs_opline_style_m, gs_opLinePen,
						bShowAddHotspots, bShowAddHotspotsForIS, bShowUnitHotspots


! =============================================================================
! Block for operator mode
! =============================================================================

if GLOB_CONTEXT > 40 & GLOB_CONTEXT < 50 then
	addy gs_tolerance_lower
	prism_ 4, WIDO_FRAME_THICKNESS,
		-ac_unit_width/2, 0, 15,
		 ac_unit_width/2, 0, 15,
		 ac_unit_width/2, ac_unit_height, 15,
		-ac_unit_width/2, ac_unit_height, 15
	del 1
	end
endif


if lod3D = 0 then end

xform	xform11, xform12, xform13, xform14,
		xform21, xform22, xform23, xform24,
		xform31, xform32, xform33, xform34


if lod3D = 5 then	! Chinese
	fr_sect_fill_type	= gs_fillShCover
	fr_sect_fill_fg		= gs_penShCov_fg
	fr_sect_fill_bg		= gs_penShCov_bg

	gs_glass_thk = gs_frame_thk

	n=0											! horizontal and vertical grid number
	m=0
else
	fr_sect_fill_type	= gs_fillFr
	fr_sect_fill_fg		= gs_penFr_fg
	fr_sect_fill_bg		= gs_penFr_bg
endif

origA = A
A = ac_unit_width
B = ac_unit_height


! =============================================================================
! Draw window frame and sash
! =============================================================================

rotx 90


! =============================================================================
! Unit Hotspots
! =============================================================================

if bShowUnitHotspots then
	unID=100

	hotspot  a/2, 0, 0, unID				:unID=unID+1
	hotspot -a/2, 0, 0, unID				:unID=unID+1
	hotspot  a/2, 0, gs_frame_thk, unID		:unID=unID+1
	hotspot -a/2, 0, gs_frame_thk, unID		:unID=unID+1

	hotspot  a/2, b, 0, unID				:unID=unID+1
	hotspot -a/2, b, 0, unID				:unID=unID+1
	hotspot  a/2, b, gs_frame_thk, unID		:unID=unID+1
	hotspot -a/2, b, gs_frame_thk, unID
endif

if gs_frame_pen_cont < 1 then gs_frame_pen_cont = SYMB_SECT_PEN

if gs_fillFr	< 1 then gs_fillFr	 = SYMB_FILL
if gs_penFr_bg	< 1 then gs_penFr_bg = SYMB_FBGD_PEN
if gs_penFr_fg	< 1 then gs_penFr_fg = SYMB_FILL_PEN



bRotAngle180 = SYMB_ROTANGLE > EPS
signrotangle = bRotAngle180 - not(bRotAngle180)

dpi1 = (gs_frame_thk - gth) / 2
if (iGrill = MULLION_SOLID_PANEL) then
	dpi2 = (gs_frame_thk - gs_sash_thk) / 2
else
	dpi2 = (gs_frame_thk - gs_glass_thk) / 2
endif

if n<0 then n=0
if m<0 then m=0


! --- Chinese specific ---
if lod3D = 5 then	!!chinese
	gl_chi_thk = gs_frame_thk
else
	gl_chi_thk = gs_glass_thk
endif


! Cuttings --------------------------------------------------------------------

halfA = A / 2

cutLeft = 0
cutRight = 0
cutTop = 0
cutBottom = 0
if abs(WIDO_ORIG_DIST) < EPS | not(gs_IsCurved) then

	! Straight Wall

	if abs(gs_frame_ovhg_left_out - gs_frame_ovhg_left_in) > EPS then
		addx -halfA - gs_frame_ovhg_left_out
		rotz 90
		cutplane -90 + atn((gs_frame_ovhg_left_out - gs_frame_ovhg_left_in) / gs_frame_thk)
		del 2
		cutLeft = 1
	endif

	if abs(gs_frame_ovhg_right_out - gs_frame_ovhg_right_in) > EPS then
		addx halfA + gs_frame_ovhg_right_out
		rotz 90
		cutplane 90 - atn((gs_frame_ovhg_right_out - gs_frame_ovhg_right_in) / gs_frame_thk)
		del 2
		cutRight = 1
	endif

else

	! Curved Window in Curved Wall

	alpha = 2 * atn((ac_wallhole_width / 2) / abs(WIDO_ORIG_DIST))
	rReveal = ((ac_wallhole_width / 2)) / sin(alpha / 2)

	WOD = abs(WIDO_ORIG_DIST)

	call "WallLogic" parameters	EPS = EPS,
		A = ac_wallhole_width,
		gs_macro_version = 10,
		WOD = WOD,
	returned_parameters dummy_Xmul,
						dummy_Ymul,
						curvedWall,
						wallIsLeft,
						angOrig,
						innerRadius,
						ofsX,
						ofsY

	if wallIsLeft then
		mRad = innerRadius + WALL_THICKNESS - WIDO_SILL
	else
		mRad = innerRadius + WIDO_SILL
	endif

	if abs(gs_frame_ovhg_left_out - gs_frame_ovhg_left_in) > EPS then
		if wallIsLeft then
			addx -rReveal*sin(angOrig)
		else
			add -mRad*sin(angOrig), 0, gs_frame_thk
		endif

		rotz 90
		cutplane -90 + atn((gs_frame_ovhg_left_out - gs_frame_ovhg_left_in) / (gs_frame_thk * cos(angOrig)))
		del 2
		cutLeft = 1
	endif

	if abs(gs_frame_ovhg_right_out - gs_frame_ovhg_right_in) > EPS then
		if wallIsLeft then
			addx rReveal*sin(angOrig)
		else
			add mRad*sin(angOrig), 0, gs_frame_thk
		endif
		rotz 90
		cutplane 90 - atn((gs_frame_ovhg_right_out - gs_frame_ovhg_right_in) / (gs_frame_thk * cos(angOrig)))
		del 2
		cutRight = 1
	endif
endif

if abs(gs_frame_ovhg_top_out - gs_frame_ovhg_top_in) > EPS then
	addy B + gs_frame_ovhg_top_out
	rotz 90
	roty -90 - atn((gs_frame_ovhg_top_out - gs_frame_ovhg_top_in) / gs_frame_thk)
	cutplane 180
	del 3
	cutTop = 1
endif

if abs(gs_frame_ovhg_bottom_out - gs_frame_ovhg_bottom_in) > EPS then
	addy -gs_frame_ovhg_bottom_out
	rotz 90
	roty 90 + atn((gs_frame_ovhg_bottom_out - gs_frame_ovhg_bottom_in) / gs_frame_thk)
	cutplane 180
	del 3
	cutBottom = 1
endif


! Handling Inner-outer Frame Materials ----------------------------------------

if gs_frame_mat = gs_frame_mat2 then				! One body, in case of similar materials
	in_out_cikl = 1

	out_thk = 0
	part_thk = gs_frame_thk

else												! two bodies
	in_out_cikl = 2

	out_thk = dpi2
	part_thk = abs(out_thk)
endif


! Handling Inner-outer Grill Materials ----------------------------------------

if gs_grill_mat = gs_grill_mat2 then			! One body, in case of similar materials
	in_out_cikl_gr = 1

	out_thk_grill = 0
	part_thk_grill = gth
else
	if iMullionPosition = MULLION_INSIDE or iMullionPosition = MULLION_OUTSIDE or (iMullionPosition = MULLION_THROUGHOUT and gs_glass_thk >= gth) then		! Inside, Outside position
		in_out_cikl_gr = 1

		out_thk_grill = gth
		part_thk_grill = out_thk_grill
	else									! Throughout position
		in_out_cikl_gr = 2

		out_thk_grill = gth/2 - gs_glass_thk/2
		part_thk_grill = out_thk_grill
	endif
endif


leftOvhg	=	max(gs_frame_ovhg_left_out, gs_frame_ovhg_left_in)
rightOvhg	=	max(gs_frame_ovhg_right_out, gs_frame_ovhg_right_in)
topOvhg		=	max(gs_frame_ovhg_top_out, gs_frame_ovhg_top_in)
bottomOvhg	=	max(gs_frame_ovhg_bottom_out, gs_frame_ovhg_bottom_in)

pen gs_frame_pen_cont
sect_fill fr_sect_fill_type, fr_sect_fill_bg, fr_sect_fill_fg, gs_frame_pen_cont

if not(gs_shadow) then shadow off

u = (A - (2 * gs_frame_width + n * gw)) / (n + 1)
w = (B - (2 * gs_frame_width + m * gw)) / (m + 1)


if abs(WIDO_ORIG_DIST) < EPS | not(gs_IsCurved) then

! =============================================================================
! Straight Wall
! =============================================================================

	addx -A/2

	material gs_frame_mat2
	pen gs_frame_pen

	addx a/2

! Mitered Joint ---------------------------------------------------------------

	if gs_SashText_typ_num = MITERED_JOINT then

		for ijk = 1 to in_out_cikl
			material gs_frame_mat2

			base
			cprism_ gs_frame_mat,gs_frame_mat2,gs_frame_mat2,
				4, part_thk,
				-a/2-leftOvhg, -bottomOvhg,				stack_mask_r,
				-a/2-leftOvhg, b+topOvhg,					8,
				-a/2+gs_frame_width, b-gs_frame_width,	15,
				-a/2+gs_frame_width, gs_frame_width,8
			vert 0, 0, 0
			vert 0, 1, 0
			vert 1, 0, 0
			vert 0, 0, 1
			coor 2, -1, -2, -3, -4
			body 1

			base
			cprism_ gs_frame_mat,gs_frame_mat2,gs_frame_mat2,
				4, part_thk,
				a/2+rightOvhg, -bottomOvhg,			stack_mask_l,
				a/2+rightOvhg, b+topOvhg,				8,
				a/2-gs_frame_width, b-gs_frame_width,	15,
				a/2-gs_frame_width, gs_frame_width,	8

			vert 0, 0, 0
			vert 0, 1, 0
			vert 1, 0, 0
			vert 0, 0, 1
			coor 2, -1, -2, -3, -4
			body 1

			! Bottom
			cprism_ gs_frame_mat,gs_frame_mat2,gs_frame_mat2,
				4, part_thk,
				-a/2-leftOvhg, -bottomOvhg,				8,
				-a/2+gs_frame_width, gs_frame_width,15,
				a/2-gs_frame_width, gs_frame_width,	8,
				a/2+rightOvhg, -bottomOvhg,			stack_mask_b
			body 1

			! Top
			cprism_ gs_frame_mat,gs_frame_mat2,gs_frame_mat2,
				4, part_thk,
				-a/2-leftOvhg, b+topOvhg,					10,
				-a/2+gs_frame_width, b-gs_frame_width,	15,
				a/2-gs_frame_width, b-gs_frame_width,	8,
				a/2+rightOvhg, b+topOvhg,				stack_mask_t
			body 1

			addz part_thk
			part_thk= gs_frame_thk-out_thk

			gs_frame_mat2 = gs_frame_mat
			gs_frame_mat = gs_frame_mat
		next ijk
		del in_out_cikl

	else

! Butt Joint ------------------------------------------------------------------

		for ijk = 1 to in_out_cikl
			material gs_frame_mat2

			base
			cprism_ gs_frame_mat,gs_frame_mat2,gs_frame_mat2,
				4, part_thk,
				-a/2-leftOvhg, gs_frame_width,			stack_mask_r,
				-a/2-leftOvhg, b-gs_frame_width,				8,
				-a/2+gs_frame_width, b-gs_frame_width,	15,
				-a/2+gs_frame_width, gs_frame_width,8
			vert 0, 0, 0
			vert 0, 1, 0
			vert 1, 0, 0
			vert 0, 0, 1
			coor 2, -1, -2, -3, -4
			body 1

			base
			cprism_ gs_frame_mat,gs_frame_mat2,gs_frame_mat2,
				4, part_thk,
				a/2+rightOvhg, gs_frame_width,		stack_mask_l,
				a/2+rightOvhg, b-gs_frame_width,			8,
				a/2-gs_frame_width, b-gs_frame_width, 	15,
				a/2-gs_frame_width, gs_frame_width,	8
			vert 0, 0, 0
			vert 0, 1, 0
			vert 1, 0, 0
			vert 0, 0, 1
			coor 2, -1, -2, -3, -4
			body 1

			! Bottom
			cprism_ gs_frame_mat,gs_frame_mat2,gs_frame_mat2,
				6, part_thk,
				-a/2-leftOvhg, gs_frame_width,			8,
				-a/2+gs_frame_width, gs_frame_width,15,
				 a/2-gs_frame_width, gs_frame_width,	10,
				 a/2+rightOvhg, gs_frame_width,		stack_mask_l,
				 a/2+rightOvhg, -bottomOvhg,			stack_mask_b,
				-a/2-leftOvhg, -bottomOvhg,			stack_mask_r
			body 1
			! Top
			cprism_ gs_frame_mat,gs_frame_mat2,gs_frame_mat2,
				6, part_thk,
				-a/2-leftOvhg, b-gs_frame_width,				8,
				-a/2+gs_frame_width, b-gs_frame_width, 15,
				 a/2-gs_frame_width, b-gs_frame_width,	10,
				 a/2+rightOvhg, b-gs_frame_width,		stack_mask_l,
				 a/2+rightOvhg, b+topOvhg,				stack_mask_t,
				-a/2-leftOvhg, b+topOvhg,				stack_mask_r
			body 1

			addz part_thk
			part_thk= gs_frame_thk-out_thk

			gs_frame_mat2 = gs_frame_mat
			gs_frame_mat = gs_frame_mat
		next ijk

		del in_out_cikl

	endif

	del 1

! Grids -----------------------------------------------------------------------

	if iMullionPosition = MULLION_INSIDE then
		side_mat = gs_grill_mat
	else
		side_mat = gs_grill_mat2
	endif

	if u<=0 | w<=0 then
		u = A - 2 * gs_frame_width
		w = A - 2 * gs_frame_width
		m = 0
		n = 0
	else
		for ijk= 1 to in_out_cikl_gr

! Vertical Grids --------------------------------------------------------------

			if n>0 then
				material gs_grill_mat2
				pen gs_sash_pen

				addz dpi1
				i=gs_frame_width+u
				for o=1 to n step 1
					addx i
					sprism_ gs_grill_mat,gs_grill_mat2,side_mat,
						4,
						0,0, 0,1, part_thk_grill, 0,
						0,		gs_frame_width,15,
						gw,		gs_frame_width,15,
						gw,		b-gs_frame_width,15,
						0,		b-gs_frame_width,15
					del 1
					i=i+u+gw
				next o
				del 1
			endif

! Horizontal Grids ------------------------------------------------------------

			if m>0 then
				i=0
				for o=1 to n+1 step 1
					put gs_frame_width+i,	w+gs_frame_width,15,
						gs_frame_width+u+i,	w+gs_frame_width,15,
						gs_frame_width+u+i,	w+gs_frame_width+gw,15,
						gs_frame_width+i,		w+gs_frame_width+gw,15,
						gs_frame_width+i,		w+gs_frame_width,-1

					j=gw+w
					for e=1 to m-1  step 1
						put gs_frame_width+i,	w+gs_frame_width+j,15,
							gs_frame_width+u+i,	w+gs_frame_width+j,15,
							gs_frame_width+u+i,	w+gs_frame_width+gw+j,15,
							gs_frame_width+i,		w+gs_frame_width+gw+j,15,
							gs_frame_width+i,		w+gs_frame_width+j,-1
						j=j+gw+w
					next e

					i=i+gw+u
				next o

				f=(n+1)*m
				addz   dpi1
				material gs_grill_mat2

				for o=1 to f step 1
					sprism_ gs_grill_mat,gs_grill_mat2,side_mat,
						5,
						0,0, 0,1, part_thk_grill, 0,
						get(15)
				next o

				del 1
			endif

			addz part_thk_grill

			part_thk_grill = gth - out_thk_grill

			gs_grill_mat = gs_grill_mat
			gs_grill_mat = gs_grill_mat
			side_mat = gs_grill_mat

		next ijk
		del in_out_cikl_gr
	endif


! Glazing ---------------------------------------------------------------------

	body 1

	if iGrill = MULLION_SOLID_PANEL then
		pen gs_sash_pen

		addz dpi2

		i = gs_frame_width
		for o=1 to n+1 step 1
			j = gs_frame_width
			for e=1 to m+1 step 1
				cprism_ gs_panel_mat, gs_panel_mat2, gs_panel_mat2,
					4, gs_sash_thk,
					i,		j,		15,
					i + u,	j,		15,
					i + u,	w + j,	15,
					i,		w + j,	15
				j = j + w + gw
			next e
			i = i + u + gw
		next o

		del 1
	else
		material gs_glass_mat
		pen gs_glass_pen

		addz dpi2

		i = gs_frame_width
		for o=1 to n+1 step 1
			j = gs_frame_width
			for e=1 to m+1 step 1
				prism_ 4,gl_chi_thk,
					i,		j,		15,
					i + u,	j,		15,
					i + u,	w + j,	15,
					i,		w + j,	15
				j = j + w + gw
			next e
			i = i + u + gw
		next o

		del 1
	endif
	del 1

	body 1

else

! =============================================================================
! Curved Window in Curved Wall
! =============================================================================

	resol 2 * WALL_RESOL

	if WIDO_ORIG_DIST > 0 exor WIDO_REVEAL_SIDE then
		part_thk		= -part_thk
		part_thk_grill	= -part_thk_grill

		gs_glass_thk	= -gs_glass_thk
		dpi1			= -dpi1
		dpi2			= -dpi2
	endif

	if WIDO_ORIG_DIST > 0 then
		mulz -1
	endif

	alpha = 2 * atn((origA / 2) / abs(WIDO_ORIG_DIST))
	rReveal = ((origA / 2)) / sin(alpha / 2)

	WOD = abs(WIDO_ORIG_DIST)

	call "WallLogic" parameters	EPS = EPS,
		A = origA,
		gs_macro_version = 10,
		WOD = WOD,
	returned_parameters dummy_Xmul,
						dummy_Ymul,
						curvedWall,
						wallIsLeft,
						angOrig,
						innerRadius,
						ofsX,
						ofsY

	if wallIsLeft then
		mRad = innerRadius + WALL_THICKNESS - WIDO_SILL
	else
		mRad = innerRadius + WIDO_SILL
	endif
	signWallIsLeft	= wallIsleft - not(wallIsleft)

	call "WallLogic" parameters	EPS = EPS,
		A = ac_unit_width,
		gs_macro_version = 10,
		WOD = WOD,
	returned_parameters dummy_Xmul,
						dummy_Ymul,
						curvedWall,
						wallIsLeft,
						angUnitWidth,
						innerRadius,
						ofsX,
						ofsY


! Frame -----------------------------------------------------------------------

	for ijk = 1 to in_out_cikl
		material gs_frame_mat2

		if ijk=1 then
			add 0,0,-WOD
			roty -angUnitWidth
			add 0,0,mRad
		endif

		if in_out_cikl = 1 then
			r = mRad
			addz 0
		else
			if ijk = 1 then
				r = mRad - signWallIsLeft * (gs_frame_thk - out_thk)
				addz -signWallIsLeft * (gs_frame_thk - out_thk)
			else
				r = mRad - wallIsLeft * (gs_frame_thk - out_thk)
				addz -wallIsLeft * (gs_frame_thk - out_thk)
			endif
		endif

		curArchLength = 2*(r)*pi*(2*angUnitWidth/360)
		distRatio = curArchLength / ac_unit_width

		if ijk = 1 then
			t1b1	= gw*(1+dpi1/r)	!gw Sprossen
			t1b2	= gw*(1+dpi2/r)	!gw Glas
			ub1		= u*(1+dpi1/r)	!u Sprossen
			ub2		= u*(1+dpi2/r)	!u Glas

			fel_panel = gs_frame_width
		endif

		pen gs_frame_pen
		if wallIsLeft then
			matTop		= gs_frame_mat2
			matBottom	= gs_frame_mat
			matSide		= gs_frame_mat2
		else
			matTop		= gs_frame_mat
			matBottom	= gs_frame_mat2
			matSide		= gs_frame_mat2
		endif

! Mitered Joint ---------------------------------------------------------------

		if gs_SashText_typ_num = MITERED_JOINT then
			base
			bprism_ matTop,matBottom,matSide,
				4, part_thk,r,
				-leftOvhg,					-bottomOvhg,		stack_mask_r,
				-leftOvhg,					B + topOvhg,		8,
				distRatio * gs_frame_width,	B - gs_frame_width,	15,
				distRatio * gs_frame_width,	gs_frame_width,		8
			vert 0, 0, 0
			vert 0, 1, 0
			vert 1, 0, 0
			vert 0, 0, 1
			coor 5, -1, -2, -3, -4
			body 1

			base
			bprism_ matTop,matBottom,matSide,
				4, part_thk,r,
				distRatio * ac_unit_width + rightOvhg,			-bottomOvhg,				stack_mask_l,
				distRatio * ac_unit_width + rightOvhg,			B + overhangTo + topOvhg,	8,
				distRatio * (ac_unit_width - gs_frame_width),	B - gs_frame_width,			15,
				distRatio * (ac_unit_width - gs_frame_width),	gs_frame_width,				8
			vert 0, 0, 0
			vert 0, 1, 0
			vert 1, 0, 0
			vert 0, 0, 1
			coor 5, -1, -2, -3, -4
			body 1

			! Top
			bprism_ matTop,matBottom,matSide,
				4, part_thk,r,
				-leftOvhg,										B + topOvhg,		10,
				distRatio * gs_frame_width,						B - gs_frame_width,	15,
				distRatio * (ac_unit_width - gs_frame_width),	B - gs_frame_width,	10,
				distRatio * ac_unit_width + rightOvhg,			B + topOvhg,		stack_mask_t

			! Bottom
			bprism_ matTop,matBottom,matSide,
				4, part_thk,r,
				-leftOvhg,										-bottomOvhg,		10,
				distRatio * gs_frame_width,						gs_frame_width,		15,
				distRatio * (ac_unit_width - gs_frame_width),	gs_frame_width,		10,
				distRatio * ac_unit_width + rightOvhg,			-bottomOvhg,		stack_mask_b

		else

! Butt Joint ------------------------------------------------------------------

			base
			bprism_ matTop,matBottom,matSide,
				4, part_thk,r,
				-leftOvhg,					gs_frame_width,		stack_mask_r,
				-leftOvhg,					B - gs_frame_width,	8,
				distRatio * gs_frame_width,	B - gs_frame_width,	15,
				distRatio * gs_frame_width,	gs_frame_width,		10
			vert 0, 0, 0
			vert 0, 1, 0
			vert 1, 0, 0
			vert 0, 0, 1
			coor 5, -1, -2, -3, -4
			body 1

			base
			bprism_ matTop,matBottom,matSide,
				4, part_thk,r,
				distRatio * ac_unit_width + rightOvhg,			gs_frame_width,		stack_mask_l,
				distRatio * ac_unit_width + rightOvhg,			B - gs_frame_width,	8,
				distRatio * (ac_unit_width - gs_frame_width),	B - gs_frame_width,	15,
				distRatio * (ac_unit_width - gs_frame_width),	gs_frame_width,		10
			vert 0, 0, 0
			vert 0, 1, 0
			vert 1, 0, 0
			vert 0, 0, 1
			coor 5, -1, -2, -3, -4
			body 1

			! Top
			bprism_ matTop,matBottom,matSide,
				6, part_thk,r,
				-leftOvhg,										B + topOvhg,		stack_mask_r,
				-leftOvhg,										B - gs_frame_width,	8,
				gs_frame_width,									B - gs_frame_width,	15,
				distRatio * (ac_unit_width - gs_frame_width),	B - gs_frame_width,	10,
				distRatio * ac_unit_width + rightOvhg,			B - gs_frame_width,	stack_mask_l,
				distRatio * ac_unit_width + rightOvhg,			B + topOvhg,		stack_mask_t

			! Bottom
			bprism_ matTop,matBottom,matSide,
				6, part_thk,r,
				-leftOvhg,										-bottomOvhg,		stack_mask_r,
				-leftOvhg,										gs_frame_width,		8,
				distRatio * gs_frame_width,						gs_frame_width,		15,
				distRatio * (ac_unit_width - gs_frame_width),	gs_frame_width,		10,
				distRatio * ac_unit_width + rightOvhg,			gs_frame_width,		stack_mask_l,
				distRatio * ac_unit_width + rightOvhg,			-bottomOvhg,		stack_mask_b
		endif

		del 1

		part_thk = gs_frame_thk - out_thk
		gs_frame_mat2 = gs_frame_mat

	next ijk

! Grids -----------------------------------------------------------------------

	if u<=0 | w<=0 then
		u = A - 2 * gs_frame_width
		w = A - 2 * gs_frame_width
		m = 0
		n = 0
	else
		for ijk = 1 to in_out_cikl_gr
			material gs_grill_mat2
			pen gs_frame_pen

			if in_out_cikl_gr = 1 then
				r = mRad + dpi1
				addz dpi1
			else
				if ijk = 1 then
					r = mRad + dpi1 - signWallIsLeft * (gth - out_thk_grill)
					addz dpi1 - signWallIsLeft * (gth - out_thk_grill)
				else
					r = mRad + dpi1 - wallIsLeft * (gth - out_thk_grill)
					addz dpi1 - wallIsLeft * (gth - out_thk_grill)
				endif
			endif

			curArchLength = 2*(r)*pi*(2*angUnitWidth/360)
			distRatio = curArchLength / ac_unit_width

			if wallIsLeft then
				matTop		= gs_grill_mat2
				matBottom	= gs_grill_mat
				matSide		= gs_grill_mat2
			else
				matTop		= gs_grill_mat
				matBottom	= gs_grill_mat2
				matSide		= gs_grill_mat2
			endif

! Vertical Grids --------------------------------------------------------------

			if n>0 then
				i = gs_frame_width + u
				for o=1 to n step 1
					pen gs_frame_pen
					bprism_  matTop,matBottom,matSide,
						4,part_thk_grill,r,
						distRatio * i,			gs_frame_width,		15,
						distRatio * (i + gw),	gs_frame_width,		15,
						distRatio * (i + gw),	B - gs_frame_width,	15,
						distRatio * i,			B - gs_frame_width,	15
					i = i + u + gw
				next o
			endif

! Horizontal Grids ------------------------------------------------------------

			if m>0 then
				i = gs_frame_width
				for o=1 to n+1 step 1
					j = gs_frame_width + w
					for e=1 to m  step 1
						bprism_  matTop,matBottom,matSide,
							4,part_thk_grill,r,
							distRatio * i,			j,		15,
							distRatio * (i + u),	j,		15,
							distRatio * (i + u),	j + gw,	15,
							distRatio * i,			j + gw,	15
						j = j + w + gw
					next e
					i = i + u + gw
				next o
			endif

			del 1

			part_thk_grill = gth - out_thk_grill
			gs_grill_mat2 = gs_grill_mat

		next ijk
	endif

	body -1

! Glazing ---------------------------------------------------------------------

	if (iGrill = MULLION_SOLID_PANEL) then
		_thk = gs_sash_thk * wallIsLeft
	else
		_thk = gl_chi_thk * wallIsLeft
	endif

	r = mRad + dpi2 - _thk
	curArchLength = 2 * r * pi * (2 * angUnitWidth / 360)
	distRatio = curArchLength / ac_unit_width

	addz dpi2 - _thk

	if iGrill = MULLION_SOLID_PANEL then
		pen gs_sash_pen

		i = gs_frame_width
		for o=1 to n+1 step 1
			j = 0
			for e=1 to m+1 step 1
				put	distRatio * i,			gs_frame_width+j,	15,
					distRatio * (i + u),	gs_frame_width+j,	15,
					distRatio * (i + u),	gs_frame_width+w+j,	15,
					distRatio * i,			gs_frame_width+w+j,	15

				if wallIsLeft then
					bprism_  gs_panel_mat2, gs_panel_mat, gs_panel_mat,
						(NSP)/3, gs_sash_thk,r,
							get(NSP)
				else
					bprism_  gs_panel_mat, gs_panel_mat2, gs_panel_mat,
						(NSP)/3, gs_sash_thk,r,
							get(NSP)
				endif
				j=j+gw+w
			next e
			i = i + u + gw
		next o
	else
		pen gs_glass_pen

		i = gs_frame_width
		for o=1 to n+1 step 1
			j = 0
			for e=1 to m+1 step 1
				bprism_  gs_glass_mat,gs_glass_mat,gs_glass_mat,
					4,gl_chi_thk,r,
					distRatio * i,			gs_frame_width+j,	15,
					distRatio * (i + u),	gs_frame_width+j,	15,
					distRatio * (i + u),	gs_frame_width+w+j,	15,
					distRatio * i,			gs_frame_width+w+j,	15
				j=j+gw+w
			next e
			i = i + u + gw
		next o
	endif

	del 1

endif


! =============================================================================

if cutLeft then cutend
if cutRight then cutend
if cutTop then cutend
if cutBottom then cutend



