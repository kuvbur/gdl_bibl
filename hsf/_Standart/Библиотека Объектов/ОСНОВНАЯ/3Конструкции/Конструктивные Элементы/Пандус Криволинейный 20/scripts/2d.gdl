
dxa		= heightSideFlange1 * sin(ascentPercentage)
dxb		= heightSideFlange2 * sin(ascentPercentage)
dlta	= dxa * 360 / ((inRad + outRad) *pi)
dltb	= dxb * 360 / ((inRad + outRad) *pi)
dxa_i	= heightSideFlange1_in * sin(ascentPercentage)
dxb_i	= heightSideFlange2_in * sin(ascentPercentage)
dlta_i	= dxa_i * 360 / ((inRad + outRad) *pi)
dltb_i	= dxb_i * 360 / ((inRad + outRad) *pi)
dxa_o	= heightSideFlange1_out * sin(ascentPercentage)
dxb_o	= heightSideFlange2_out * sin(ascentPercentage)
dlta_o	= dxa_o * 360 / ((inRad + outRad) *pi)
dltb_o	= dxb_o * 360 / ((inRad + outRad) *pi)

breaklineWidth	= 0.05

gadi1	= asn(breaklineWidth / inRad)
gadi2	= asn(breaklineWidth / (inRad + widthSideFlange2))
gadi3	= asn(breaklineWidth / (inRad + widthSideFlange2 + widthSideFlange1))

gadm	= asn(breaklineWidth / rad)
gad0	= asn((arrowSize / 5) / rad)

gada1	= asn(breaklineWidth / outRad)
gada2	= asn(breaklineWidth / (outRad - widthSideFlange2))
gada3	= asn(breaklineWidth / (outRad - widthSideFlange2 - widthSideFlange1))

! --- Text ---------------------------------------------------------------------

! --- Oriented View ------------------------------ [

angleViewRot = 0
rrr = REQUEST ("View_Rotangle", "", angleViewRot)
totalRotate = (SYMB_ROTANGLE + angleViewRot) MOD 360

format = "%~"
rr	= REQUEST ("Linear_dimension", "", format)
if STRSTR(format, "m") then 
	_Unit = " m"
	formatString = "%m"
endif

if STRSTR(format, "cm") then 
	_Unit = " cm"
	formatString = "%~cm"
endif

if STRSTR(format, "mm") then
	_Unit = " mm"
	formatString = "%~mm"
endif

if STRSTR(format, "ffi") then
	_Unit = ""
	formatString = "%~ffi"
endif

if STRSTR(format, "fdi") then
	_Unit = ""
	formatString = "%~fdi"
endif

if STRSTR(format, "df") then
	_Unit = ""
	formatString = "%~df"
endif

if STRSTR(format, "fi") then
	_Unit = ""
	formatString = "%~fi"
endif

if STRSTR(format, "di") then
	_Unit = ""
	formatString = "%~di"
endif


! --- Oriented View ------------------------------ ]

define style text1 fontType, tx_size*100/GLOB_SCALE, 5, 0

if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
	if iTextType1 = TEXT_PERCENTAGE then
		gr1 = str (ascentPercentage, 4, 2)
		gr2 = str (percentage, 4, 2)
		gr_tx1 = TextPrefix1 + gr1 + " %"
		gr_tx2 = TextPrefix1 + gr2 + " %"
	else
		if iTextType1 = TEXT_RATIO then
			formatString = "%~"
			gr1 = str (ratioAscentLength, 4, 0)
			gr2 = str ("%~", ratioAscentHeight)
			gr3 = str (ratioLength, 4, 0)
			gr4 = str ("%~", ratioHeight)
			gr_tx1 = TextPrefix1 + gr1 + " : " + gr2
			gr_tx2 = TextPrefix1 + gr3 + " : " + gr4
		else
			if iTextType1 = TEXT_SEGMENTLENGTH then
				if bAscent then
					gr1 = str (formatString, lengthAscent)
					gr2 = str (formatString, lengthFull-lengthAscent*2)
					gr_tx1 = TextPrefix1 + gr1 + _Unit
					gr_tx2 = TextPrefix1 + gr2 + _Unit	
				else
					gr1 = str (formatString, lengthFull)
					gr_tx1 = TextPrefix1 + gr1 + _Unit
					gr_tx2 = TextPrefix1 + gr1 + _Unit
				endif	
			else
				if iTextType1 = TEXT_FULLLENGTH then
					gr1 = str (formatString, lengthFull)
					gr_tx1 = TextPrefix1 + gr1 + _Unit
					gr_tx2 = TextPrefix1 + gr1 + _Unit
				else
					gr_tx1 = TextPrefix1 + CustomText
					gr_tx2 = TextPrefix1 + CustomText
				endif
			endif
		endif
	endif

	if iTextType2 = TEXT_PERCENTAGE then
		gr1 = str (ascentPercentage, 4, 2)
		gr2 = str (percentage, 4, 2)
		gr_tx3 = TextPrefix2 + gr1 + " %"
		gr_tx4 = TextPrefix2 + gr2 + " %"
	else
		if iTextType2 = TEXT_RATIO then
			formatString = "%~"
			gr1 = str (ratioAscentLength, 4, 0)
			gr2 = str ("%~", ratioAscentHeight)
			gr3 = str (ratioLength, 4, 0)
			gr4 = str ("%~", ratioHeight)
			gr_tx3 = TextPrefix2 + gr1 + " : " + gr2
			gr_tx4 = TextPrefix2 + gr3 + " : " + gr4
		else
			if iTextType2 = TEXT_SEGMENTLENGTH then
				if bAscent then
					gr1 = str (formatString, lengthAscent)
					gr2 = str (formatString, lengthFull-lengthAscent*2)
					gr_tx3 = TextPrefix2 + gr1 + _Unit
					gr_tx4 = TextPrefix2 + gr2 + _Unit
				else
					gr1 = str (formatString, lengthFull)
					gr_tx3 = TextPrefix2 + gr1 + _Unit
					gr_tx4 = TextPrefix2 + gr1 + _Unit
				endif
			else
				if iTextType2 = TEXT_FULLLENGTH then
					gr1 = str (formatString, lengthFull)
					gr_tx3 = TextPrefix2 + gr1 + _Unit
					gr_tx4 = TextPrefix2 + gr1 + _Unit
				else
					gr_tx3 = TextPrefix2 + CustomText
					gr_tx4 = TextPrefix2 + CustomText
				endif
			endif
		endif
	endif
else
	gr1 = str (ascentPercentage, 4, 2)
	gr2 = str (percentage, 4, 2)
	gr_tx1 = gr1 + " %"
	gr_tx2 = gr2 + " %"
endif

style text1
rrr = request("Height_of_style","text1", shight1)
yPos = shight1*GLOB_SCALE/2000+0.1

! --- Hotspots -----------------------------------------------------------------
unID  = 1
hotspot2 0,  0,										unID : unID = unID + 1
hotspot2 inRad,  0,									unID : unID = unID + 1
hotspot2 outRad,  0,								unID : unID = unID + 1
hotspot2 inRad * cos(alph), inRad * sin(alph),		unID : unID = unID + 1
hotspot2 outRad * cos(alph), outRad * sin(alph),	unID : unID = unID + 1

StartSymbUNID = 100
EndSymbUNID = 1000

! ==============================================================================
!     2D symbol
! ==============================================================================

rampTextAngle1	= STW(gr_tx1) / 1000 * A_ * alph / lengthFull
rampTextAngle2	= STW(gr_tx2) / 1000 * A_ * alph / lengthFull

floorplanCutplaneHeight	= GLOB_CSTORY_ELEV - GLOB_HSTORY_ELEV + GLOB_CUTPLANES_INFO[1]
floorplanToprangeHeight	= GLOB_CSTORY_ELEV - GLOB_HSTORY_ELEV + GLOB_CUTPLANES_INFO[2]

if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
	breaklineAngle	= alph / 2
else
	if bAscent then
		rampAngle1		= ATN(zzyzx / (lengthFull - lengthAscent))
		rampAngle2		= rampAngle1 / 2
		if floorplanCutplaneHeight < TAN(rampAngle2) * lengthAscent then
			breaklineDist	= floorplanCutplaneHeight / TAN(rampAngle2)
			breaklineAngle	= breaklineDist * alph1 / lengthAscent
		else
			if floorplanCutplaneHeight < (zzyzx - TAN(rampAngle2) * lengthAscent) then
				breaklineDist	= lengthAscent + (floorplanCutplaneHeight - TAN(rampAngle2) * lengthAscent) / TAN(rampAngle1)
				breaklineAngle	= alph1 + (breaklineDist - lengthAscent) * alph2 / (lengthFull - lengthAscent * 2)
			else
				breaklineDist	= lengthFull - (zzyzx - floorplanCutplaneHeight) / TAN(rampAngle2)
				breaklineAngle	= alph - (lengthFull - breaklineDist) * alph1 / lengthAscent
			endif
		endif
	else
		rampAngle		= ATN(zzyzx / lengthFull)
		breaklineDist	= floorplanCutplaneHeight / TAN(rampAngle)
		breaklineAngle	= breaklineDist * alph / lengthFull
		endif
endif

if iFloorPlanDisplayType = DISPLAY_PROJECTED | iFloorPlanDisplayType = DISPLAY_OVERHEAD_PROJ then
	bShowText							= 1

	if breaklineAngle < eps then
		bShowDetailedSymbol				= 1
		bShowBreakline					= 0

		bSymbolBelowIsOverhead			= 1
		bSymbolAboveIsOverhead			= 1
	else
		bShowDetailedSymbol				= 1

		if breaklineAngle > alph - gadi1 then
			bShowBreakline				= 0
			bShowSymbolBelowBreakline	= 1
			bShowSymbolAboveBreakline	= 1

			bSymbolBelowIsOverhead		= 0
			bSymbolAboveIsOverhead		= 0
		else
			bShowBreakline				= 1
			bShowSymbolBelowBreakline	= 1
			bShowSymbolAboveBreakline	= (iFloorPlanDisplayType = DISPLAY_OVERHEAD_PROJ)

			bSymbolBelowIsOverhead		= 0
			bSymbolAboveIsOverhead		= (iFloorPlanDisplayType = DISPLAY_OVERHEAD_PROJ)
		endif
	endif
endif
if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		bShowText					= 1
		bShowDetailedSymbol			= 1
		if bShowBreakline then
			bSymbolAboveIsOverhead	= 1
		else
			bSymbolAboveIsOverhead	= 0
		endif
		bSymbolBelowIsOverhead 		= 0
		bShowSymbolBelowBreakline 	= 1
		bShowSymbolAboveBreakline 	= 1
endif
if iFloorPlanDisplayType = DISPLAY_OUTLINES then
	bShowBreakline				= 0
	bShowDetailedSymbol			= 0
	bShowText					= 1

	bSymbolBelowIsOverhead		= 0
	bSymbolAboveIsOverhead		= 0

	bShowSymbolBelowBreakline	= 1
	bShowSymbolAboveBreakline	= 1
endif
if iFloorPlanDisplayType = DISPLAY_OVERHEAD_ALL then
	bShowBreakline				= 0
	bShowDetailedSymbol			= 1
	bShowText					= 0

	bSymbolBelowIsOverhead		= 1
	bSymbolAboveIsOverhead		= 1

	bShowSymbolBelowBreakline	= 1
	bShowSymbolAboveBreakline	= 1
endif

if bShowBreakline then
	if bShowSymbolBelowBreakline then
		gosub "symbol below breakline"
	endif
	if bShowSymbolAboveBreakline then
		gosub "symbol above breakline"
	endif
else
	gosub "symbol w/o breakline"
endif

!================================================================================
end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
!================================================================================


"symbol w/o breakline":
	DRAWINDEX 10
	if bSymbolBelowIsOverhead | bSymbolAboveIsOverhead then
		symbolPen		= overheadPen
		symbolLinetype	= lineOverhead
	else
		symbolPen		= gs_cont_pen
		symbolLinetype	= lineCont
	endif

	if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		symbolPen 		= gs_cont_pen
		symbolLinetype 	= lineCont
	endif

	pen symbolPen
	line_type symbolLinetype

	for k = 1 to 2

		gosub "radius calculation"

		arc2 0, 0, rd, 0, alph
		if bShowDetailedSymbol then
			if NOT(bDiffSides) then
				if bSideFlange1+bSideFlange2>0 then arc2 0, 0, rd+neg*widthSideFlange2, 0, alph
				if bSideFlange1*bSideFlange2>0 then arc2 0, 0, rd+neg*(widthSideFlange2+widthSideFlange1), 0, alph
			else
				if kabl+kbrd>0 then arc2 0, 0, rd+neg*kb_brd, 0, alph
				if kabl*kbrd>0 then arc2 0, 0, rd+neg*(kb_brd+kb_abl), 0, alph
			endif
		endif

		if bAscent then
			ascentLinePos	= alph1 * (k = 1) + (alph - alph1) * (k = 2)
			gosub "ascent line"
		endif

		gadi1=gada1
		gadi2=gada2
		gadi3=gada3

	next k

	if alph > 360 then
		line_type lineDashed
	else
		line_type symbolLinetype
	endif

	if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		line2 inRad, 0, outRad, 0
	else
		line2 inRad, 0, rad-arrowSize/5, 0
		line2 outRad, 0, rad+arrowSize/5, 0
	endif

	line_type symbolLinetype
	line2 inRad*cos(alph), inRad*sin(alph), outRad*cos(alph), outRad*sin(alph)

	! --- Arrow --------------------------------------------------------------------
	if (bWalkingLine and iFloorPlanDisplayType = DISPLAY_SYMBOLIC) or iFloorPlanDisplayType <> DISPLAY_SYMBOLIC then
		DRAWINDEX 20
		if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
			symbolPen 		= penWalkingBelow
		else
			symbolPen 		= penArrow
		endif

		pen symbolPen

		if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
			arc2 0, 0, rad, 0, alph
		else
			arc2 0, 0, rad, asn((arrowSize/5)/rad), alph
		endif

		if (bStartSymbol and iFloorPlanDisplayType = DISPLAY_SYMBOLIC and not(bReverse)) or iFloorPlanDisplayType <> DISPLAY_SYMBOLIC then
			DRAWINDEX 30
			penStartSymbol = penStartSymbolBelow
			gosub "StartSymbol"
		endif

		if (bEndSymbol and iFloorPlanDisplayType = DISPLAY_SYMBOLIC) or iFloorPlanDisplayType <> DISPLAY_SYMBOLIC then
			DRAWINDEX 30
			if 	bAscent and iFloorPlanDisplayType = DISPLAY_SYMBOLIC and (lengthAscent > arrowHeight) |\
				bAscent and iFloorPlanDisplayType <> DISPLAY_SYMBOLIC and (lengthAscent > arrowSize) |\
				not(bAscent) and iFloorPlanDisplayType = DISPLAY_SYMBOLIC and (lengthFull > arrowHeight) |\
				not(bAscent) and iFloorPlanDisplayType <> DISPLAY_SYMBOLIC and (lengthFull > arrowSize) then

				arrowPos = alph
				reversePos = alph
				penEndSymbol = penEndSymbolBelow
				gosub "arrow line"
			endif

			if bAscent then
				if 	iFloorPlanDisplayType = DISPLAY_SYMBOLIC and (lengthAscent > arrowHeight) |\
					iFloorPlanDisplayType <> DISPLAY_SYMBOLIC and (lengthAscent > arrowSize)then

					arrowPos = alph1
					reversePos = alph1
					gosub "arrow line"
				endif
			
				if 	iFloorPlanDisplayType = DISPLAY_SYMBOLIC and (lengthFull - lengthAscent*2 > arrowHeight) |\
					iFloorPlanDisplayType <> DISPLAY_SYMBOLIC and (lengthFull - lengthAscent*2 > arrowSize)then

					arrowPos = alph1 + alph2
					reversePos = alph2
					gosub "arrow line"
				endif
			endif
		endif
	endif

	! --- Text ---------------------------------------------------------------------
	pen penText
	if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		if bShowText1  and (iTextType1 <> TEXT_FULLLENGTH and iTextType1 <> TEXT_CUSTOM or not(bAscent)) then
			if 	bAscent and (lengthFull - lengthAscent*2 > STW(gr_tx2) / 1000 * GLOB_SCALE) |\
				not(bAscent) and (lengthFull > STW(gr_tx2) / 1000 * GLOB_SCALE) then
	
					textPos		= alph / 2
					textCont	= gr_tx2
					_actyPos	= yPos
					gosub "text rotation"
			endif
		endif
		if bShowText2  and (iTextType2 <> TEXT_FULLLENGTH and iTextType2 <> TEXT_CUSTOM or not(bAscent)) then
			if 	bAscent and (lengthFull - lengthAscent*2 > STW(gr_tx4) / 1000 * GLOB_SCALE) |\
				not(bAscent) and (lengthFull > STW(gr_tx4) / 1000 * GLOB_SCALE) then
					textPos		= alph / 2
					textCont	= gr_tx4
					_actyPos 	= - yPos
					gosub "text rotation"
			endif
		endif

		if bAscent then
			if bShowText1 then
				if lengthAscent > STW(gr_tx1) / 1000 * GLOB_SCALE then
					textPos		= alph1 / 2
					textCont	= gr_tx1
					_actyPos	= yPos
	
					gosub "text rotation"	
					if iTextType1 <> TEXT_FULLLENGTH and iTextType1 <> TEXT_CUSTOM then
						textPos		= alph - alph1 / 2
						textCont	= gr_tx1
	
						gosub "text rotation"
					endif
				endif
			endif

			if bShowText2 then
				if lengthAscent > STW(gr_tx3) / 1000 * GLOB_SCALE then
					_actyPos	= - yPos
					textPos		= alph1 / 2
					textCont	= gr_tx3
	
					gosub "text rotation"
	
					if iTextType2 <> TEXT_FULLLENGTH and iTextType2 <> TEXT_CUSTOM then
						textPos		= alph - alph1 / 2
						textCont	= gr_tx3
						gosub "text rotation"
					endif
				endif
			endif
		endif
	else
		if bShowText then
			DRAWINDEX 40
			textPos		= alph / 2
			textCont	= gr_tx2
			_actyPos	= yPos
			gosub "text rotation"
	
			if bAscent then
				textPos		= alph1 / 2
				textCont	= gr_tx1
				gosub "text rotation"
	
				textPos		= alph - alph1 / 2
				textCont	= gr_tx1
				gosub "text rotation"
			endif
		endif
	endif

	! --- Fill --------------------------------------------------------------------
	if bFill and NOT(bSymbolAboveIsOverhead) then
		DRAWINDEX 10
		alpha = alph
		beta = alph

		fill gs_fill_type
		if beta < 360 then
			poly2_b 7, 2+4+64, gs_fill_pen, gs_back_pen,
				inRad, 0, 0,
				outRad, 0, 0,
				0, 0, 900,
				0, alpha, 4000,
				inRad * cos(beta), inRad * sin(beta), 0,
				0, 0, 900,
				0, -beta, 4000
		else
			poly2_b 4, 2+4+64, gs_fill_pen, gs_back_pen,
				0, 0, 900,
				outRad, 360, 4000,
				0, 0, 900,
				inRad, 360, 4000
		endif
	endif

return


"symbol below breakline":
	DRAWINDEX 10
	if bSymbolBelowIsOverhead then
		symbolPen		= overheadPen
		symbolLinetype	= lineOverhead
	else
		symbolPen		= gs_cont_pen
		symbolLinetype	= lineCont
	endif

	pen symbolPen
	line_type symbolLinetype

	if NOT(bShowSymbolAboveBreakline) then
		hotspot2 inRad * cos(breaklineAngle - gadi1), inRad * sin(breaklineAngle - gadi1),		unID : unID = unID + 1
		hotspot2 outRad * cos(breaklineAngle - gada1), outRad * sin(breaklineAngle - gada1),	unID : unID = unID + 1
	endif

	for k = 1 to 2
		kk = 1
		gosub "radius calculation"

		arc2 0, 0, rd, (breaklineAngle+gadi1)*(kk-1), (breaklineAngle-gadi1)*(2-kk)+alph*(kk-1)
		if bShowDetailedSymbol then
			if bDiffSides = 0 then
				if bSideFlange1+bSideFlange2>0 then arc2 0, 0, rd+neg*widthSideFlange2, (breaklineAngle+gadi2)*(kk-1), (breaklineAngle-gadi2)*(2-kk)+alph*(kk-1)
				if bSideFlange1*bSideFlange2>0 then arc2 0, 0, rd+neg*widthSideFlange2+neg*widthSideFlange1, (breaklineAngle+gadi3)*(kk-1), (breaklineAngle-gadi3)*(2-kk)+alph*(kk-1)
			else
				if kabl+kbrd>0 then arc2 0, 0, rd+neg*kb_brd, (breaklineAngle+kgadi2)*(kk-1), (breaklineAngle-kgadi2)*(2-kk)+alph*(kk-1)
				if kabl*kbrd>0 then arc2 0, 0, rd+neg*kb_brd+neg*kb_abl, (breaklineAngle+kgadi3)*(kk-1), (breaklineAngle-kgadi3)*(2-kk)+alph*(kk-1)
			endif
		endif

		if bAscent then
			ascentLinePos	= alph1 * (k = 1) + (alph - alph1) * (k = 2)
			if k = 1 then
				bDrawAscentline1	= (breaklineAngle > alph1)
				if bDrawAscentline1 then
					gosub "ascent line"
				endif
			else
				bDrawAscentline2	= (breaklineAngle > alph - alph1)
				if bDrawAscentline2 then
					gosub "ascent line"
				endif
			endif
		endif

		gadi1=gada1
		gadi2=gada2
		gadi3=gada3

	next k

	if alph > 360 and bShowSymbolAboveBreakline then
		line_type lineDashed
	else
		line_type symbolLinetype
	endif

	if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		line2 inRad, 0, outRad, 0
	else
		line2 inRad, 0, rad-arrowSize/5, 0
		line2 outRad, 0, rad+arrowSize/5, 0
	endif

	rot2 breaklineAngle
	add2 rad, 0

	if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		symbolPen 		= penBreakLineBelow
		symbolLinetype 	= ltBreakLineBelow
	endif

	if bShowBreakline then	
		pen symbolPen
		line_type symbolLinetype
		line2 -widthUsable/2, -breaklineWidth, widthUsable/2, -breaklineWidth
	endif
	del 2

	! --- Arrow --------------------------------------------------------------------
	if (bWalkingLine and iFloorPlanDisplayType = DISPLAY_SYMBOLIC) or iFloorPlanDisplayType <> DISPLAY_SYMBOLIC then
		DRAWINDEX 20
		if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
			symbolPen 		= penWalkingBelow
			symbolLinetype 	= ltWalkingBelow
		else
			symbolPen 		= penArrow
		endif
	
		pen symbolPen
		line_type symbolLinetype

		if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
			arc2 0, 0, rad, 0, (breaklineAngle-gadm)*(2-kk)+alph*(kk-1)
		else
			arc2 0, 0, rad, gad0+(breaklineAngle+gadm-gad0)*(kk-1), (breaklineAngle-gadm)*(2-kk)+alph*(kk-1)
		endif

		if (bStartSymbol and iFloorPlanDisplayType = DISPLAY_SYMBOLIC and not(bReverse)) or iFloorPlanDisplayType <> DISPLAY_SYMBOLIC then
			DRAWINDEX 30
			penStartSymbol = penStartSymbolBelow
			gosub "StartSymbol"
		endif
	
		if (bEndSymbol and iFloorPlanDisplayType = DISPLAY_SYMBOLIC) or iFloorPlanDisplayType <> DISPLAY_SYMBOLIC then
			DRAWINDEX 30
			if 	bAscent and iFloorPlanDisplayType = DISPLAY_SYMBOLIC and (lengthFull / 2 - lengthAscent - tan(gadm) * outRad/2 > arrowHeight) |\
				bAscent and iFloorPlanDisplayType <> DISPLAY_SYMBOLIC and (lengthFull / 2 - lengthAscent - tan(gadm) * outRad/2 > arrowSize) |\
				not(bAscent) and iFloorPlanDisplayType = DISPLAY_SYMBOLIC and (lengthFull / 2 - tan(gadm) * outRad/2 > arrowHeight) |\
				not(bAscent) and iFloorPlanDisplayType <> DISPLAY_SYMBOLIC and (lengthFull / 2 - tan(gadm) * outRad/2 > arrowSize) then

				arrowPos = breaklineAngle - gadm
				penEndSymbol = penEndSymbolBelow
				reversePos = breaklineAngle - gadm
				gosub "arrow line"
			endif
		
			if bAscent then
				if breaklineAngle > alph1 then
					if 	bAscent and iFloorPlanDisplayType = DISPLAY_SYMBOLIC and (lengthAscent > arrowHeight) |\
						bAscent and iFloorPlanDisplayType <> DISPLAY_SYMBOLIC and (lengthAscent > arrowSize) then

						arrowPos = alph1
						reversePos = alph1
						gosub "arrow line"
					endif
				endif
		
				if breaklineAngle > alph - alph1 then
					if 	bAscent and iFloorPlanDisplayType = DISPLAY_SYMBOLIC and (lengthAscent > arrowHeight) |\
						bAscent and iFloorPlanDisplayType <> DISPLAY_SYMBOLIC and (lengthAscent > arrowSize) then

						arrowPos = alph1 + alph2
						reversePos = alph1
						gosub "arrow line"
					endif
				endif
			endif
		endif
	endif

	! --- Text ---------------------------------------------------------------------
	pen penText
	if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		if bAscent then
			if bShowText1 then
				_actyPos	= yPos
				textPos		= MIN(alph / 2, alph1 + (breaklineAngle - alph1) / 2)
				textCont	= gr_tx2
				if breaklineAngle - alph1 > rampTextAngle2 then gosub "text rotation"
				if (iTextType1 <> TEXT_FULLLENGTH and iTextType1 <> TEXT_CUSTOM) then
					textPos		= MIN(alph1, breaklineAngle) / 2
					textCont	= gr_tx1
					if textPos * 2 > rampTextAngle1 then gosub "text rotation"
				endif
			endif

			if bShowText2 then
				_actyPos	= - yPos
				textPos		= MIN(alph / 2, alph1 + (breaklineAngle - alph1) / 2)
				textCont	= gr_tx4
				if breaklineAngle - alph1 > rampTextAngle2 then gosub "text rotation"
				if (iTextType2 <> TEXT_FULLLENGTH and iTextType2 <> TEXT_CUSTOM) then
					textPos		= MIN(alph1, breaklineAngle) / 2
					textCont	= gr_tx3
					if textPos * 2 > rampTextAngle1 then gosub "text rotation"
				endif
			endif
		else
			textPos		= breaklineAngle / 2
			textCont	= gr_tx2
			_actyPos	= yPos
			if breaklineAngle > rampTextAngle1 then gosub "text rotation"

			textPos		= breaklineAngle / 2
			textCont	= gr_tx4
			_actyPos	= - yPos
			if breaklineAngle > rampTextAngle1 then gosub "text rotation"
		endif
	else
		if bShowtext then
			DRAWINDEX 40
			_actyPos	= yPos
			if NOT(bSymbolBelowIsOverhead) then
				if bAscent then
					textPos		= MIN(alph1, breaklineAngle) / 2
					textCont	= gr_tx1
					if textPos * 2 > rampTextAngle1 then gosub "text rotation"
		
					textPos		= MIN(alph / 2, alph1 + (breaklineAngle - alph1) / 2)
					textCont	= gr_tx2
					if breaklineAngle - alph1 > rampTextAngle2 then gosub "text rotation"
		
					textPos		= alph - alph1 + (breaklineAngle + alph1 - alph) / 2
					textCont	= gr_tx1
					if breaklineAngle - (alph - alph1) > rampTextAngle1 then gosub "text rotation"
				else
					textPos		= breaklineAngle / 2
					textCont	= gr_tx2
					if breaklineAngle > rampTextAngle1 then gosub "text rotation"
				endif
			endif
		endif
	endif

	! --- Fill --------------------------------------------------------------------
	if bFill then
		DRAWINDEX 10
		alpha = breaklineAngle - gada1 + gada1 * (bShowSymbolAboveBreakline and NOT(bSymbolAboveIsOverhead))
		gadi1 = asn(breaklineWidth / inRad)
		beta = breaklineAngle - gadi1 + gadi1 * (bShowSymbolAboveBreakline and NOT(bSymbolAboveIsOverhead))

		fill gs_fill_type
		if breaklineAngle < 360-EPS then
			poly2_b 7, 2+4+64, gs_fill_pen, gs_back_pen,
				inRad, 0, 0,
				outRad, 0, 0,
				0, 0, 900,
				0, alpha, 4000,
				inRad * cos(beta), inRad * sin(beta), 0,
				0, 0, 900,
				0, -beta, 4000
		else
			poly2_b 4, 2+4+64, gs_fill_pen, gs_back_pen,
				0, 0, 900,
				outRad, 360, 4000,
				0, 0, 900,
				inRad, 360, 4000
		endif
	endif
return


"symbol above breakline":
	DRAWINDEX 10
	if bSymbolAboveIsOverhead then
		symbolPen		= overheadPen
		symbolLinetype	= lineOverhead
	else
		symbolPen		= gs_cont_pen
		symbolLinetype	= lineCont
	endif

	pen symbolPen
	line_type symbolLinetype

	line2 inRad*cos(alph), inRad*sin(alph), outRad*cos(alph), outRad*sin(alph)

	for k = 1 to 2
		kk = 2
		gosub "radius calculation"

		arc2 0, 0, rd, (breaklineAngle+gadi1)*(kk-1), (breaklineAngle-gadi1)*(2-kk)+alph*(kk-1)

		if bShowDetailedSymbol then
			if bDiffSides = 0 then
				if bSideFlange1+bSideFlange2>0 then arc2 0, 0, rd+neg*widthSideFlange2, (breaklineAngle+gadi2)*(kk-1), (breaklineAngle-gadi2)*(2-kk)+alph*(kk-1)
				if bSideFlange1*bSideFlange2>0 then arc2 0, 0, rd+neg*widthSideFlange2+neg*widthSideFlange1, (breaklineAngle+gadi3)*(kk-1), (breaklineAngle-gadi3)*(2-kk)+alph*(kk-1)
			else
				if kabl+kbrd>0 then arc2 0, 0, rd+neg*kb_brd, (breaklineAngle+kgadi2)*(kk-1), (breaklineAngle-kgadi2)*(2-kk)+alph*(kk-1)
				if kabl*kbrd>0 then arc2 0, 0, rd+neg*kb_brd+neg*kb_abl, (breaklineAngle+kgadi3)*(kk-1), (breaklineAngle-kgadi3)*(2-kk)+alph*(kk-1)
			endif
		endif

		if bAscent then
			if k = 1 then
				bDrawAscentline1	= (breaklineAngle < alph1)
				if bDrawAscentline1 then
					gosub "ascent line"
				endif
			else
				bDrawAscentline2	= (breaklineAngle < alph - alph1)
				if bDrawAscentline2 then
					gosub "ascent line"
				endif
			endif
		endif

		gadi1=gada1
		gadi2=gada2
		gadi3=gada3

	next k

	if bShowBreakline then
		rot2 breaklineAngle
		add2 rad, 0
	
		if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
			symbolPen 		= penBreakLineAbove
			symbolLinetype 	= ltBreakLineAbove
		endif
	
		pen symbolPen
		line_type symbolLinetype

		line2 -widthUsable/2, breaklineWidth, widthUsable/2, breaklineWidth
		del 2
	endif


	if (bWalkingLine and not(bStop) and iFloorPlanDisplayType = DISPLAY_SYMBOLIC) or iFloorPlanDisplayType <> DISPLAY_SYMBOLIC then
		DRAWINDEX 20
		if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
			symbolPen 		= penWalkingAbove
			line_type ltWalkingAbove
		else
			symbolPen 		= penArrow
		endif
	
		pen symbolPen
		arc2 0, 0, rad, gad0+(breaklineAngle+gadm-gad0)*(kk-1), (breaklineAngle-gadm)*(2-kk)+alph*(kk-1)

		if bShowAboveBreak then
			DRAWINDEX 30
			rot2 breaklineAngle+gadm
			penStartSymbol = penStartSymbolAbove
				gosub "StartSymbol"
			del 1
		endif
	
		if bEndSymbol or iFloorPlanDisplayType <> DISPLAY_SYMBOLIC then
			DRAWINDEX 30
			if 	bAscent and iFloorPlanDisplayType = DISPLAY_SYMBOLIC and (lengthAscent  > arrowHeight) |\
				bAscent and iFloorPlanDisplayType <> DISPLAY_SYMBOLIC and (lengthAscent  > arrowSize) |\
				not(bAscent) and iFloorPlanDisplayType = DISPLAY_SYMBOLIC and (lengthFull / 2 - tan(gadm) * outRad > arrowHeight) |\
				not(bAscent) and iFloorPlanDisplayType <> DISPLAY_SYMBOLIC and (lengthFull / 2 - tan(gadm) * outRad > arrowSize) then

				arrowPos = alph
				penEndSymbol = penEndSymbolAbove
				reversePos = alph / 2 - gadm
				gosub "arrow line"
			endif
			if bAscent then
				if breaklineAngle < alph1 then
					if 	bAscent and iFloorPlanDisplayType = DISPLAY_SYMBOLIC and (lengthAscent > arrowHeight) |\
						bAscent and iFloorPlanDisplayType <> DISPLAY_SYMBOLIC and (lengthAscent > arrowSize) then

						arrowPos = alph1
						reversePos = alph1
						gosub "arrow line"
					endif
				endif
		
				if breaklineAngle < alph - alph1 then
					if 	bAscent and iFloorPlanDisplayType = DISPLAY_SYMBOLIC and (lengthFull / 2 - lengthAscent - tan(gadm) * outRad > arrowHeight) |\
						bAscent and iFloorPlanDisplayType <> DISPLAY_SYMBOLIC and (lengthFull / 2 - lengthAscent - tan(gadm) * outRad > arrowSize) then

						arrowPos = alph1 + alph2
						reversePos = alph2/2-gadm
						gosub "arrow line"
					endif
				endif
			endif
		endif
	endif

	! --- Text ---------------------------------------------------------------------
	pen penText
	if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		if bAscent then
			if bShowText1 and (iTextType1 <> TEXT_FULLLENGTH and iTextType1 <> TEXT_CUSTOM) then
				_actyPos	= yPos
				textPos		= MAX(alph / 2, breaklineAngle + (alph - alph1 - breaklineAngle) / 2)
				textCont	= gr_tx2
				if alph - alph1 - breaklineAngle > rampTextAngle2 then gosub "text rotation"
	
				textPos		= MAX(alph - alph1 + alph1 / 2, alph - (alph - breaklineAngle) / 2)
				textCont	= gr_tx1
				if alph - breaklineAngle > rampTextAngle1 then gosub "text rotation"
			endif
			if bShowText2 and (iTextType2 <> TEXT_FULLLENGTH and iTextType2 <> TEXT_CUSTOM) then
				_actyPos	= - yPos	
				textPos		= MAX(alph / 2, breaklineAngle + (alph - alph1 - breaklineAngle) / 2)
				textCont	= gr_tx4
				if alph - alph1 - breaklineAngle > rampTextAngle2 then gosub "text rotation"
	
				textPos		= MAX(alph - alph1 + alph1 / 2, alph - (alph - breaklineAngle) / 2)
				textCont	= gr_tx3
				if alph - breaklineAngle > rampTextAngle1 then gosub "text rotation"
			endif
		else
			if bShowText1 then
				_actyPos	= yPos
				textPos		= breaklineAngle + (alph - breaklineAngle) / 2
				textCont	= gr_tx2
				if alph - breaklineAngle > rampTextAngle2 then gosub "text rotation"
			endif
			if bShowText2 then
				_actyPos	= - yPos
				textPos		= breaklineAngle + (alph - breaklineAngle) / 2
				textCont	= gr_tx4
				if alph - breaklineAngle > rampTextAngle2 then gosub "text rotation"
			endif
		endif
	else
		if bShowText then
			DRAWINDEX 40
			_actyPos	= yPos	
			if bAscent then
				textPos		= breaklineAngle + (alph1 - breaklineAngle) / 2
				textCont	= gr_tx1
				if alph1 - breaklineAngle > rampTextAngle1 then gosub "text rotation"
		
				textPos		= MAX(alph / 2, breaklineAngle + (alph - alph1 - breaklineAngle) / 2)
				textCont	= gr_tx2
				if alph - alph1 - breaklineAngle > rampTextAngle2 then gosub "text rotation"
		
				textPos		= MAX(alph - alph1 + alph1 / 2, alph - (alph - breaklineAngle) / 2)
				textCont	= gr_tx1
				if alph - breaklineAngle > rampTextAngle1 then gosub "text rotation"
			else
				textPos		= breaklineAngle + (alph - breaklineAngle) / 2
				textCont	= gr_tx2
				if alph - breaklineAngle > rampTextAngle2 then gosub "text rotation"
			endif
		endif
	endif
	! --- Fill --------------------------------------------------------------------
	if bFill and NOT(bSymbolAboveIsOverhead) then
		DRAWINDEX 10
		alph = min(alph, 360)

		alpha = alph - breaklineAngle - gada1 * NOT(bShowSymbolBelowBreakline)
		gadi1 = asn(breaklineWidth / inRad)
		beta = alph - breaklineAngle - gadi1 * NOT(bShowSymbolBelowBreakline)

		rot2 breaklineAngle

	fill gs_fill_type
		poly2_b 7, 2+4+64, gs_fill_pen, gs_back_pen,
			inRad, 0, 0,
			outRad, 0, 0,
			0, 0, 900,
			0, alpha, 4000,
			inRad * cos(beta), inRad * sin(beta), 0,
			0, 0, 900,
			0, -beta, 4000

		del 1
	endif
return


"ascent line":

	if alph > 360 + ascentLinePos and bShowSymbolAboveBreakline then
		line_type lineDashed
	else
		line_type symbolLinetype
	endif

	ascentLinePos	= alph1 * (k = 1) + (alph - alph1) * (k = 2)

	rot2 ascentLinePos
	add2 inRad + (outRad - inRad) / 2, 0

	if NOT(bDiffSides) then
		line2 -(widthUsable / 2 - (widthSideFlange2  * bSideFlange2 + widthSideFlange1 * bSideFlange1) * (bShowDetailedSymbol)), 0,
				(widthUsable / 2 - (widthSideFlange2 * bSideFlange2 + widthSideFlange1 * bSideFlange1) * (bShowDetailedSymbol)), 0
	else
		line2 -(widthUsable / 2 - (widthSideFlange2_in  * bSideFlange2_in + widthSideFlange1_in  * bSideFlange1_in) * (bShowDetailedSymbol)), 0,
				(widthUsable / 2 - (widthSideFlange2_out * bSideFlange2_out + widthSideFlange1_out * bSideFlange1_out) * (bShowDetailedSymbol)), 0
	endif

	del 2

	if bShowDetailedSymbol then
		rot2 ascentLinePos - dltb
		add2 inRad + (outRad - inRad) / 2, 0

		if NOT(bDiffSides) then
			if bSideFlange2 then
				line2 -widthUsable / 2, 0,
						-widthUsable / 2 + widthSideFlange2, 0

				line2 widthUsable / 2, 0,
						widthUsable / 2 - widthSideFlange2, 0
			endif
		else
			if bSideFlange2_in then
				line2 -widthUsable / 2, 0,
						-widthUsable / 2 + widthSideFlange2_in, 0
			endif
			if bSideFlange2_out then
				line2 widthUsable / 2, 0,
						widthUsable / 2 - widthSideFlange2_out, 0
			endif
		endif

		del 2

		rot2 ascentLinePos - dlta
		add2 inRad + (outRad - inRad) / 2, 0

		if NOT(bDiffSides) then
			if bSideFlange1 then
				line2 -widthUsable / 2 + bSideFlange2 * widthSideFlange2, 0,
						-widthUsable / 2 + bSideFlange2 * widthSideFlange2 + widthSideFlange1, 0

				line2 widthUsable / 2 - bSideFlange2 * widthSideFlange2, 0,
						widthUsable / 2 - bSideFlange2 * widthSideFlange2 - widthSideFlange1, 0
			endif
		else
			if bSideFlange1_in then
				line2 -widthUsable / 2 + bSideFlange2_in * widthSideFlange2_in, 0,
						-widthUsable / 2 + bSideFlange2_in * widthSideFlange2_in + widthSideFlange1_in, 0
			endif
			if bSideFlange1_out then
				line2 widthUsable / 2 - bSideFlange2_out * widthSideFlange2_out, 0,
						widthUsable / 2 - bSideFlange2_out * widthSideFlange2_out - widthSideFlange1_out, 0
			endif
		endif

		del 2
	endif

	line_type symbolLinetype

return


"radius calculation":

	if k = 1 then
		rd = inRad
		kbrd = bSideFlange2_in
		kb_brd = widthSideFlange2_in
		kabl = bSideFlange1_in
		kb_abl = widthSideFlange1_in
		kgadi2 = asn(breaklineWidth / (inRad + widthSideFlange2_in))
		kgadi3 = asn(breaklineWidth / (inRad + widthSideFlange2_in + widthSideFlange1_in))
		alp = alph1
		neg = 1
	else
		rd = outRad
		kbrd = bSideFlange2_out
		kb_brd = widthSideFlange2_out
		kabl = bSideFlange1_out
		kb_abl = widthSideFlange1_out
		kgadi2 = asn(breaklineWidth / (outRad - widthSideFlange2_out))
		kgadi3 = asn(breaklineWidth / (outRad - widthSideFlange2_out - widthSideFlange1_out))
		alp = alph1 + alph2
		neg = -1
	endif

return


"arrow line":
	
	if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		fill fillEndSymbol
		if iEndSymbol = 1 or iEndSymbol = 3 or iEndSymbol = 5 then
			_actSymbolLength = widthUsable / 2
			_actSymbolHeight = arrowHeight
		endif

		if iEndSymbol = 2 or iEndSymbol = 4 or  iEndSymbol = 6 then
			_actSymbolLength = arrowWidth / 2
			_actSymbolHeight = arrowHeight
		endif

		if iEndSymbol = 1 or iEndSymbol = 2 then
			temp_ArrowMask=0
		else
			temp_ArrowMask=1
		endif

		_gamma = atn(_actSymbolHeight / rad)
		_H = 2 * sin(_gamma / 2) * rad
		_Y = 2 * sin(_gamma / 2) * cos(_gamma / 2) * rad
		_X = sqr((_H *_H) - (_Y * _Y))

		rot2 arrowPos - _gamma

		if bReverse then
			mul2 1, -1
			rot2 -_gamma*2 + reversePos
		endif

		add2 rad, 0

		POLY2_ 5, 1,
			0,					0,		temp_ArrowMask,
			_actSymbolLength,	0, 		1,
			-_X, 				_Y, 	1,
			-_actSymbolLength, 	0, 		temp_ArrowMask,
			0,					0,		- 1


		if iEndSymbol = 3 or iEndSymbol = 4 then
			poly2_B 5, 2, gs_fill_pen, penEndSymbol,
				0,					0,		temp_ArrowMask,
				_actSymbolLength,	0, 		1,
				-_X, 				_Y, 	1,
				-_actSymbolLength, 	0, 		temp_ArrowMask,
				0,					0,		- 1

		else
			if iEndSymbol = 5 or iEndSymbol = 6 then
				poly2_B 4, 2, gs_fill_pen, penEndSymbol,
					0,					0,		temp_ArrowMask,
					_actSymbolLength,	0, 		1,
					-_X, 				_Y, 	temp_ArrowMask,
					0,					0,		-1
			endif
		endif

		hotspot2	-_actSymbolLength,	_actSymbolHeight,		EndSymbUNID, arrowHeight, 1+128	: EndSymbUNID = EndSymbUNID + 1
		hotspot2	-_actSymbolLength,	0,						EndSymbUNID, arrowHeight, 2		: EndSymbUNID = EndSymbUNID + 1
		hotspot2	-_actSymbolLength,	_actSymbolHeight + 1,	EndSymbUNID, arrowHeight, 3		: EndSymbUNID = EndSymbUNID + 1

		hotspot2	_actSymbolLength,	_actSymbolHeight,		EndSymbUNID, arrowHeight, 1+128 : EndSymbUNID = EndSymbUNID + 1
		hotspot2	_actSymbolLength, 	0,						EndSymbUNID, arrowHeight, 2		: EndSymbUNID = EndSymbUNID + 1
		hotspot2	_actSymbolLength, 	_actSymbolHeight + 1,	EndSymbUNID, arrowHeight, 3		: EndSymbUNID = EndSymbUNID + 1

		if iEndSymbol = 2 or iEndSymbol = 4 or iEndSymbol = 6 then
			hotspot2	0,					0,	EndSymbUNID, arrowWidthHalf, 1+128,	arrowWidth	: EndSymbUNID = EndSymbUNID+ 1
			hotspot2	-_actSymbolLength,	0,	EndSymbUNID, arrowWidthHalf, 2,		arrowWidth	: EndSymbUNID = EndSymbUNID+ 1
			hotspot2	_actSymbolLength,	0,	EndSymbUNID, arrowWidthHalf, 3,		arrowWidth	: EndSymbUNID = EndSymbUNID+ 1
	
			hotspot2	0,					0,	EndSymbUNID, arrowWidthHalf, 1+128,	arrowWidth	: EndSymbUNID = EndSymbUNID+ 1
			hotspot2	_actSymbolLength,	0,	EndSymbUNID, arrowWidthHalf, 2,		arrowWidth	: EndSymbUNID = EndSymbUNID+ 1
			hotspot2	-_actSymbolLength,	0,	EndSymbUNID, arrowWidthHalf, 3,		arrowWidth	: EndSymbUNID = EndSymbUNID+ 1
		endif

		if bReverse then
			del 2
		endif

	else
		rot2 arrowPos
		add2 inRad + (outRad - inRad) / 2, 0

		for jjj = 1 to 2
			line2 0, 0, -arrowSize, -arrowSize
			mul2 -1, 1
		next jjj
		del 2
	endif

	del 2

return


"text rotation":

	totalAnglePos = totalRotate + textPos + 90

	rot2 textPos

	add2 rad - _actyPos, 0
	rot2 90

	nTrans = 0
	if typeTextRotation_m = 2 then
		if  (totalAnglePos > (gs_readable_angle + eps) & totalAnglePos < (gs_readable_angle + 180 + eps)) then
			rot2 180
			mul2 -1, 1
			nTrans = nTrans + 2
		endif
	endif

	text2 0, 0, textCont

	del nTrans

	del 2

	del 1

return

"StartSymbol":
	if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		add2 rad, 0
		fill fillEndSymbol
		if penStartSymbol <> 0 then
			temp_FillStatus = 2
		else
			temp_FillStatus = 0
		endif

		if iStartSymbol = 1 then	! Style 1
			poly2_b 2, 1+temp_FillStatus, gs_fill_pen, penStartSymbol,
				0,						0, 		901,
				widthStartSymbol / 2,	360, 	4001
		endif

		if iStartSymbol = 2 then	! Style 2
			for k = 1 to 2
				poly2_b 6, 1+temp_FillStatus, gs_fill_pen, penStartSymbol,
					0, 						0, 						1,
					widthStartSymbol / 2, 	0, 						1,
					0,						0,						901,
					0,						90,						4001,
					0,						widthStartSymbol / 2,	0,
					0,						0,						-1
				poly2_b 6, 1, gs_fill_pen, penStartSymbol,
					0,						0,						1,
					0,						widthStartSymbol / 2,	1,
					0,						0,						901,
					0,						90,						4001,
					-widthStartSymbol / 2,	0,						0,
					0,						0,						-1
				rot2 180
			next k
			del 2
		endif

		if iStartSymbol = 3 then	! Style 3
			line2 widthStartSymbol/2, 	- heightStartSymbol/2, 	 widthStartSymbol/2, 	heightStartSymbol/2
			line2 - widthStartSymbol/2, 	- heightStartSymbol/2, 	- widthStartSymbol/2, 	 heightStartSymbol/2
		endif

		if iStartSymbol = 1 or iStartSymbol = 2 then
			for ii=1 to 4
				hotspot2 0, 					0,	StartSymbUNID, widthStartSymbolHalf, 1+128, widthStartSymbol	: StartSymbUNID = StartSymbUNID + 1
				hotspot2 widthStartSymbol / 2, 	0,	StartSymbUNID, widthStartSymbolHalf, 2, 	widthStartSymbol	: StartSymbUNID = StartSymbUNID + 1
				hotspot2 -1, 					0,	StartSymbUNID, widthStartSymbolHalf, 3+128, widthStartSymbol	: StartSymbUNID = StartSymbUNID + 1
				rot2 90
			next ii
			del ii-1
		else
			for ii=1 to 2
				! Symbol Width/2
				hotspot2 0,						- heightStartSymbolHalf, StartSymbUNID, widthStartSymbolHalf, 1+128,	widthStartSymbol	:StartSymbUNID=StartSymbUNID+1
				hotspot2 widthStartSymbolHalf, 	- heightStartSymbolHalf, StartSymbUNID, widthStartSymbolHalf, 2, 		widthStartSymbol	:StartSymbUNID=StartSymbUNID+1
				hotspot2 -1,					- heightStartSymbolHalf, StartSymbUNID, widthStartSymbolHalf, 3, 		widthStartSymbol	:StartSymbUNID=StartSymbUNID+1
	
				hotspot2 0,						heightStartSymbolHalf, StartSymbUNID, widthStartSymbolHalf, 1+128,	widthStartSymbol	:StartSymbUNID=StartSymbUNID+1
				hotspot2 widthStartSymbolHalf, 	heightStartSymbolHalf, StartSymbUNID, widthStartSymbolHalf, 2,		widthStartSymbol	:StartSymbUNID=StartSymbUNID+1
				hotspot2 -1,					heightStartSymbolHalf, StartSymbUNID, widthStartSymbolHalf, 3,		widthStartSymbol	:StartSymbUNID=StartSymbUNID+1
	
				! Symbol Height
				hotspot2 widthStartSymbolHalf, 0,						StartSymbUNID, heightStartSymbolHalf, 1+128, 	heightStartSymbol		:StartSymbUNID=StartSymbUNID+1
				hotspot2 widthStartSymbolHalf, heightStartSymbolHalf, 	StartSymbUNID, heightStartSymbolHalf, 2, 		heightStartSymbol		:StartSymbUNID=StartSymbUNID+1
				hotspot2 widthStartSymbolHalf, -1,						StartSymbUNID, heightStartSymbolHalf, 3, 		heightStartSymbol		:StartSymbUNID=StartSymbUNID+1
	
				hotspot2 widthStartSymbolHalf, 0,						StartSymbUNID, heightStartSymbolHalf, 1+128, 	heightStartSymbol		:StartSymbUNID=StartSymbUNID+1
				hotspot2 widthStartSymbolHalf, - heightStartSymbolHalf,	StartSymbUNID, heightStartSymbolHalf, 2,		heightStartSymbol		:StartSymbUNID=StartSymbUNID+1
				hotspot2 widthStartSymbolHalf, 1,						StartSymbUNID, heightStartSymbolHalf, 3, 		heightStartSymbol		:StartSymbUNID=StartSymbUNID+1
				mul2 -1,1
			next ii
			del ii-1
		endif
		del 1
	else
		circle2 rad, 0, arrowSize / 5
	endif


return
