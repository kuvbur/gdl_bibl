
! --- Text ---------------------------------------------------------------------

! --- Oriented View ------------------------------ [

angleViewRot = 0
rrr = REQUEST ("View_Rotangle", "", angleViewRot)
totalRotate = (SYMB_ROTANGLE + angleViewRot) MOD 360

format = "%~"
rr	= REQUEST ("Linear_dimension", "", format)
if STRSTR(format, "m") then 
	_Unit = " m"
	formatString = "%m"
endif

if STRSTR(format, "cm") then 
	_Unit = " cm"
	formatString = "%~cm"
endif

if STRSTR(format, "mm") then
	_Unit = " mm"
	formatString = "%~mm"
endif

if STRSTR(format, "ffi") then
	_Unit = ""
	formatString = "%~ffi"
endif

if STRSTR(format, "fdi") then
	_Unit = ""
	formatString = "%~fdi"
endif

if STRSTR(format, "df") then
	_Unit = ""
	formatString = "%~df"
endif

if STRSTR(format, "fi") then
	_Unit = ""
	formatString = "%~fi"
endif

if STRSTR(format, "di") then
	_Unit = ""
	formatString = "%~di"
endif

! --- Oriented View ------------------------------ ]

define style text1 fontType, tx_size*100/GLOB_SCALE, 5, 0

if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
	if iTextType1 = TEXT_PERCENTAGE then
		gr1 = str (ascentPercentage, 4, 2)
		gr2 = str (percentage, 4, 2)
		gr_tx1 = TextPrefix1 + gr1 + " %"
		gr_tx2 = TextPrefix1 + gr2 + " %"
	else
		if iTextType1 = TEXT_RATIO then
			gr1 = str (ratioAscentLength, 4, 0)
			gr2 = str ("%~", ratioAscentHeight)
			gr3 = str (ratioLength, 4, 0)
			gr4 = str ("%~", ratioHeight)
			gr_tx1 = TextPrefix1 + gr1 + " : " + gr2
			gr_tx2 = TextPrefix1 + gr3 + " : " + gr4
		else
			if iTextType1 = TEXT_SEGMENTLENGTH then
				if bAscent then
					gr1 = str (formatString, lengthAscent)
					gr2 = str (formatString, a-lengthAscent*2)
					gr_tx1 = TextPrefix1 + gr1 + _Unit
					gr_tx2 = TextPrefix1 + gr2 + _Unit
				else
					gr1 = str (formatString, A)
					gr_tx1 = TextPrefix1 + gr1 + _Unit
					gr_tx2 = TextPrefix1 + gr1 + _Unit
				endif	
			else
				if iTextType1 = TEXT_FULLLENGTH then
					gr1 = str (formatString, A)
					gr_tx1 = TextPrefix1 + gr1 + _Unit
					gr_tx2 = TextPrefix1 + gr1 + _Unit
				else
					gr_tx1 = TextPrefix1 + CustomText
					gr_tx2 = TextPrefix1 + CustomText
				endif
			endif
		endif
	endif

	if iTextType2 = TEXT_PERCENTAGE then
		gr1 = str (ascentPercentage, 4, 2)
		gr2 = str (percentage, 4, 2)
		gr_tx3 = TextPrefix2 + gr1 + " %"
		gr_tx4 = TextPrefix2 + gr2 + " %"
	else
		if iTextType2 = TEXT_RATIO then
			formatString = "%~"
			gr1 = str (ratioAscentLength, 4, 0)
			gr2 = str ("%~", ratioAscentHeight)
			gr3 = str (ratioLength, 4, 0)
			gr4 = str ("%~", ratioHeight)
			gr_tx3 = TextPrefix2 + gr1 + " : " + gr2
			gr_tx4 = TextPrefix2 + gr3 + " : " + gr4
		else
			if iTextType2 = TEXT_SEGMENTLENGTH then
				if bAscent then
					gr1 = str (formatString, lengthAscent)
					gr2 = str (formatString, a-lengthAscent*2)
					gr_tx3 = TextPrefix2 + gr1 + _Unit
					gr_tx4 = TextPrefix2 + gr2 + _Unit
				else
					gr1 = str (formatString, A)
					gr_tx3 = TextPrefix2 + gr1 + _Unit
					gr_tx4 = TextPrefix2 + gr1 + _Unit
				endif
			else
				if iTextType2 = TEXT_FULLLENGTH then
					gr1 = str (formatString, A)
					gr_tx3 = TextPrefix2 + gr1 + _Unit
					gr_tx4 = TextPrefix2 + gr1 + _Unit
				else
					gr_tx3 = TextPrefix2 + CustomText
					gr_tx4 = TextPrefix2 + CustomText
				endif
			endif
		endif
	endif
else
	gr1=str (ascentPercentage, 4, 2)
	gr2=str (percentage, 4, 2)
	gr_tx1=gr1 + " %"
	gr_tx2=gr2 + " %"
endif

style text1
rrr = request("Height_of_style","text1", shight1)

if iFloorPlanDisplayType = DISPLAY_SYMBOLIC and iWalkingLineType = WALKINGLINE_TRIANGLE and (not(bShowText1)or not(bShowText2)) then
	yPos = 0
else
	yPos = (shight1*1.5)*GLOB_SCALE/4000
endif

! --- Hotspots -----------------------------------------------------------------
unID  = 1
hotspot2 0,  0,		unID : unID = unID + 1
hotspot2 a,  0,		unID : unID = unID + 1
hotspot2 0,  b/2,	unID : unID = unID + 1
hotspot2 0, -b/2,	unID : unID = unID + 1
hotspot2 a,  b/2,	unID : unID = unID + 1
hotspot2 a, -b/2,	unID : unID = unID + 1
StartSymbUNID 	= 100
EndSymbUNID 	= 1000

! ==============================================================================
!     2D symbol
! ==============================================================================

floorplanCutplaneHeight	= GLOB_CSTORY_ELEV - GLOB_HSTORY_ELEV + GLOB_CUTPLANES_INFO[1]
floorplanToprangeHeight	= GLOB_CSTORY_ELEV - GLOB_HSTORY_ELEV + GLOB_CUTPLANES_INFO[2]

if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
	breaklineDist	= a / 2
else
	if bAscent then
		rampAngle1		= ATN(zzyzx / (a - lengthAscent))
		rampAngle2		= rampAngle1 / 2
		if floorplanCutplaneHeight < TAN(rampAngle2) * lengthAscent then
			breaklineDist	= floorplanCutplaneHeight / TAN(rampAngle2)
		else
			if floorplanCutplaneHeight < (zzyzx - TAN(rampAngle2) * lengthAscent) then
				breaklineDist	= lengthAscent + (floorplanCutplaneHeight - TAN(rampAngle2) * lengthAscent) / TAN(rampAngle1)
			else
				breaklineDist	= a - (zzyzx - floorplanCutplaneHeight) / TAN(rampAngle2)
			endif
		endif
	else
		rampAngle		= ATN(zzyzx / a)
		breaklineDist	= floorplanCutplaneHeight / TAN(rampAngle)
	endif
endif

if iFloorPlanDisplayType = DISPLAY_PROJECTED | iFloorPlanDisplayType = DISPLAY_OVERHEAD_PROJ then
	bShowText						= 1

	if breaklineDist < (b / 2) * TAN(breaklineAngle) + breaklineWidth then
		bShowDetailedSymbol				= 1
		bShowBreakline					= 0

		bSymbolBelowIsOverhead			= 1
		bSymbolAboveIsOverhead			= 1
	else
		bShowDetailedSymbol				= 1

		if breaklineDist > a - (b / 2) * TAN(breaklineAngle) - breaklineWidth then
			bShowBreakline				= 0
			bShowSymbolBelowBreakline	= 1
			bShowSymbolAboveBreakline	= 1

			bSymbolBelowIsOverhead		= 0
			bSymbolAboveIsOverhead		= 0
		else
			bShowBreakline				= 1
			bShowSymbolBelowBreakline	= 1
			bShowSymbolAboveBreakline	= (iFloorPlanDisplayType = DISPLAY_OVERHEAD_PROJ)

			bSymbolBelowIsOverhead		= 0
			bSymbolAboveIsOverhead		= (iFloorPlanDisplayType = DISPLAY_OVERHEAD_PROJ)
		endif
	endif
endif
if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		bShowDetailedSymbol		= 1
		if bShowBreakline then
			bSymbolAboveIsOverhead	= 1
		else
			bSymbolAboveIsOverhead	= 0
		endif
		bSymbolBelowIsOverhead 	= 0
		bShowSymbolBelowBreakline = 1
		bShowSymbolAboveBreakline = 1
endif

if iFloorPlanDisplayType = DISPLAY_OUTLINES then
	bShowBreakline				= 0
	bShowDetailedSymbol			= 0
	bShowText					= 1

	bSymbolBelowIsOverhead		= 0
	bSymbolAboveIsOverhead		= 0

	bShowSymbolBelowBreakline	= 1
	bShowSymbolAboveBreakline	= 1
endif
if iFloorPlanDisplayType = DISPLAY_OVERHEAD_ALL then
	bShowBreakline				= 0
	bShowDetailedSymbol			= 1
	bShowText					= 0

	bSymbolBelowIsOverhead		= 1
	bSymbolAboveIsOverhead		= 1

	bShowSymbolBelowBreakline	= 1
	bShowSymbolAboveBreakline	= 1
endif

if bShowBreakline then
	if bShowSymbolBelowBreakline or iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		gosub "symbol below breakline"
	endif
	if bShowSymbolAboveBreakline or iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		gosub "symbol above breakline"
	endif
else
	gosub "symbol w/o breakline"
endif

!================================================================================
end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
!================================================================================


"symbol w/o breakline":
	DRAWINDEX 10

	if bSymbolBelowIsOverhead | bSymbolAboveIsOverhead then
		symbolPen		= overheadPen
		symbolLinetype	= lineOverhead
	else
		symbolPen		= gs_cont_pen
		symbolLinetype	= lineCont
	endif

	if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		symbolPen 		= gs_cont_pen
		symbolLinetype 	= lineCont
	endif
	pen symbolPen
	line_type symbolLinetype

	if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		line2 0, -b/2, 0, b/2
	else
		line2 0, -b/2, 0, -arrowSize/5
		line2 0,  b/2, 0,  arrowSize/5
	endif

	line2 a, -b/2, a,  b/2
	line2 0,  b/2, a,  b/2
	line2 0, -b/2, a, -b/2

	if bShowDetailedSymbol then
		if bSideFlange2_right	then line2	0, -b/2 + widthSideFlange2_right,
											a, -b/2 + widthSideFlange2_right
		if bSideFlange2_left	then line2	0,  b/2 - widthSideFlange2_left,
											a,  b/2 - widthSideFlange2_left
		if bSideFlange1_right	then line2	0, -b/2 + widthSideFlange1_right + widthSideFlange2_right * bSideFlange2_right,
											a, -b/2 + widthSideFlange1_right + widthSideFlange2_right * bSideFlange2_right
		if bSideFlange1_left	then line2	0,  b/2 - widthSideFlange1_left - widthSideFlange2_left * bSideFlange2_left,
											a,  b/2 - widthSideFlange1_left - widthSideFlange2_left * bSideFlange2_left
	endif

	if bAscent then

		breakAscentline = 0
		bShowFlangeLinesL	= 1
		bShowFlangeLinesR	= 1
		bDrawPart1 = 1
		bDrawPart2 = 1

		ascentLinePos	= lengthAscent
		bDrawAscentline1	= (breaklineDist > ascentLinePos - (b / 2 - widthSideFlange2_left - widthSideFlange1_left) * TAN(breaklineAngle) + breaklineWidth)
		if bDrawAscentline1 then
			breakAscentline	= 0
			bShowFlangeLinesL	= 1
			bShowFlangeLinesR	= 1!(breaklineDist > ascentLinePos + (b / 2) * TAN(breaklineAngle) + breaklineWidth)
			gosub "ascent line"
		endif

		ascentLinePos	= a - lengthAscent
		bDrawAscentline2	= (breaklineDist < ascentLinePos + (b / 2 - widthSideFlange2_right - widthSideFlange1_right) * TAN(breaklineAngle) - breaklineWidth)
		if bDrawAscentline2 then
			breakAscentline	= 0
			bShowFlangeLinesL	= 1!(breaklineDist < ascentLinePos - (b / 2) * TAN(breaklineAngle) - breaklineWidth)
			bShowFlangeLinesR	= 1
			gosub "ascent line"
		endif

	endif

	! --- Arrow --------------------------------------------------------------------
	if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		symbolPen 		= penWalkingBelow
		line_type ltWalkingBelow
	else
		symbolPen 		= penArrow
	endif
	pen symbolPen

	if (bWalkingLine and bStartSymbol and iFloorPlanDisplayType = DISPLAY_SYMBOLIC) or iFloorPlanDisplayType <> DISPLAY_SYMBOLIC then
		DRAWINDEX 30	
		if bReverse then
			_StartSymbolPos = A
		else
			_StartSymbolPos = 0
		endif
		penStartSymbol = penStartSymbolBelow
		gosub "StartSymbol"
	endif

	if (bWalkingLine and iFloorPlanDisplayType = DISPLAY_SYMBOLIC) or iFloorPlanDisplayType <> DISPLAY_SYMBOLIC then
		DRAWINDEX 20
		if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
			if bReverse then
				mul2 -1,1
				add2 -a, 0
			endif

			if bWalkingLine then
				if iWalkingLineType = WALKINGLINE_SIMPLE then
					line2 0, 0, a, 0
				else
					if not(bDiffSides) then
						if not(bAscent) then
							line2 0, b/2 - (widthSideFlange1 * bSideFlange1) - (widthSideFlange2 * bSideFlange2), a, 0
							line2 0, - b/2 + (widthSideFlange1 * bSideFlange1) + (widthSideFlange2 * bSideFlange2), a, 0
						else
							line2 0, b/2 - (widthSideFlange1 * bSideFlange1) - (widthSideFlange2 * bSideFlange2), lengthAscent, 0
							line2 0, - b/2 + (widthSideFlange1 * bSideFlange1) + (widthSideFlange2 * bSideFlange2), lengthAscent, 0

							line2 lengthAscent, b/2 - (widthSideFlange1 * bSideFlange1) - (widthSideFlange2 * bSideFlange2), A - lengthAscent, 0
							line2 lengthAscent, - b/2 + (widthSideFlange1 * bSideFlange1) + (widthSideFlange2 * bSideFlange2), A - lengthAscent, 0

							line2 A - lengthAscent, b/2 - (widthSideFlange1 * bSideFlange1) - (widthSideFlange2 * bSideFlange2), A, 0
							line2 A - lengthAscent, - b/2 + (widthSideFlange1 * bSideFlange1) + (widthSideFlange2 * bSideFlange2), A, 0
						endif
					else
						if not(bAscent) then
							line2 0, b/2 - (widthSideFlange1_left * bSideFlange1_left) - (widthSideFlange2_left * bSideFlange2_left), a, 0
							line2 0, - b/2 + (widthSideFlange1_right * bSideFlange1_right) + (widthSideFlange2_right * bSideFlange2_right), a, 0
						else
							line2 0, b/2 - (widthSideFlange1_left * bSideFlange1_left) - (widthSideFlange2_left * bSideFlange2_left), lengthAscent, 0
							line2 0, - b/2 + (widthSideFlange1_right * bSideFlange1_right) + (widthSideFlange2_right * bSideFlange2_right), lengthAscent, 0

							line2 lengthAscent, b/2 - (widthSideFlange1_left * bSideFlange1_left) - (widthSideFlange2_left * bSideFlange2_left), A - lengthAscent, 0
							line2 lengthAscent, - b/2 + (widthSideFlange1_right * bSideFlange1_right) + (widthSideFlange2_right * bSideFlange2_right), A - lengthAscent, 0

							line2 A - lengthAscent, b/2 - (widthSideFlange1_left * bSideFlange1_left) - (widthSideFlange2_left * bSideFlange2_left), A, 0
							line2 A - lengthAscent, - b/2 + (widthSideFlange1_right * bSideFlange1_right) + (widthSideFlange2_right * bSideFlange2_right ), A, 0
						endif
					endif
				endif
			endif
			if bReverse then
				del 2
			endif
		else
			line2 0, 0, a, 0
		endif
	endif
	
	if (bWalkingLine and bEndSymbol and iFloorPlanDisplayType = DISPLAY_SYMBOLIC) or iFloorPlanDisplayType <> DISPLAY_SYMBOLIC then
		DRAWINDEX 30
		penEndSymbol = penEndSymbolBelow
		if bAscent then
			arrowPos = lengthAscent
			if lengthAscent > arrowHeight then gosub "arrow line"
	
			arrowPos = a - lengthAscent
			if a - lengthAscent * 2 > arrowHeight then gosub "arrow line"
		endif

		if bReverse then
			arrowPos = 0
		else
			arrowPos = A
		endif
		
		if lengthAscent > arrowHeight then gosub "arrow line"

	endif

	! --- Text ---------------------------------------------------------------------
	DRAWINDEX 40
	pen penText
	if typeTextRotation_m = 2 then gosub "text rotation"

	if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then

		if bAscent then
			if bShowText1 then
				if lengthAscent > 	STW(gr_tx2) / 1000 * GLOB_SCALE 	then text2 A / 2, yPos, gr_tx2
				if iTextType1 <> TEXT_FULLLENGTH and iTextType1 <> TEXT_CUSTOM then
					if lengthAscent 		> STW(gr_tx2) / 1000 * GLOB_SCALE 	then text2 a - lengthAscent / 2, 	yPos, gr_tx1
					if a - lengthAscent * 2 > STW(gr_tx1) / 1000 * GLOB_SCALE 	then text2 lengthAscent / 2, 		yPos, gr_tx1
				endif
			endif
			if bShowText2 then
				if lengthAscent > 	STW(gr_tx4) / 1000 * GLOB_SCALE 	then text2 A/2, -yPos, gr_tx4
				if iTextType2 <> TEXT_FULLLENGTH and iTextType2 <> TEXT_CUSTOM then
					if lengthAscent 			> STW(gr_tx4) / 1000 * GLOB_SCALE 	then text2 A - lengthAscent / 2, 	-yPos, gr_tx3
					if a - lengthAscent * 2 	> STW(gr_tx3) / 1000 * GLOB_SCALE 	then text2 lengthAscent / 2, 		-yPos, gr_tx3
				endif
			endif
		else
			if bShowText1 then
				if a - lengthAscent * 2 > STW(gr_tx1) / 1000 * GLOB_SCALE 	then text2 A / 2, yPos, 	gr_tx2
			endif
			if bShowText2 then
				if a - lengthAscent * 2 > STW(gr_tx3) / 1000 * GLOB_SCALE 	then text2 A / 2, - yPos, 	gr_tx4
			endif
		endif
	else
		if bShowText then	
			text2 a/2, yPos, gr_tx2
			if bAscent then
				text2 lengthAscent / 2, 	yPos, gr_tx1
				text2 a - lengthAscent / 2, yPos, gr_tx1
			endif	
		endif
	endif
	if typeTextRotation_m = 2 then del nTrans

	! --- Fill --------------------------------------------------------------------
	DRAWINDEX 10
	if bFill and NOT(bSymbolAboveIsOverhead) then
		fill gs_fill_type
		poly2_b 4, 2+4+64, gs_fill_pen, gs_back_pen,
			0, -B/2, 	0,
			a, -B/2, 	0,
			a, B/2, 	0,
			0, B/2, 	0
	endif

return


"symbol below breakline":
	DRAWINDEX 10
	if bSymbolBelowIsOverhead then
		symbolPen		= overheadPen
		symbolLinetype	= lineOverhead
	else
		symbolPen		= gs_cont_pen
		symbolLinetype	= lineCont
	endif

	if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		symbolPen 		= gs_cont_pen
		symbolLinetype 	= lineCont
	endif

	pen symbolPen
	line_type symbolLinetype

	if NOT(bShowSymbolAboveBreakline) then
		hotspot2 breaklineDist + b/2 * tan (breaklineAngle) - breaklineWidth, b / 2,	unID : unID = unID + 1
		hotspot2 breaklineDist - b/2 * tan (breaklineAngle) - breaklineWidth, -b / 2,	unID : unID = unID + 1
	endif

	if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		line2 0, -b/2, 0, b/2
	else
		line2 0, -b/2, 0, -arrowSize/5
		line2 0,  b/2, 0,  arrowSize/5
	endif

	line2 0,  b/2, breaklineDist - breaklineWidth + b/2 * tan (breaklineAngle),  b / 2
	line2 0, -b/2, breaklineDist - breaklineWidth - b/2 * tan (breaklineAngle), -b / 2

	if bShowDetailedSymbol then
		if bSideFlange1_left then
			line2 	0,
					b/2 - widthSideFlange2_left * bSideFlange2_left - widthSideFlange1_left,
					breaklineDist - breaklineWidth + (b/2 - widthSideFlange2_left * bSideFlange2_left - widthSideFlange1_left)  * tan (breaklineAngle),
					b/2 - widthSideFlange2_left * bSideFlange2_left - widthSideFlange1_left
		endif
		if bSideFlange1_right then
			line2 	0,
					-b/2 + widthSideFlange2_right * bSideFlange2_right + widthSideFlange1_right,
					breaklineDist - breaklineWidth - (b/2 - widthSideFlange2_right * bSideFlange2_right - widthSideFlange1_right) * tan (breaklineAngle),
					-b/2 + widthSideFlange2_right * bSideFlange2_right + widthSideFlange1_right
		endif
		if bSideFlange2_left then
				line2 0,  b/2 - widthSideFlange2_left,  breaklineDist - breaklineWidth + (b/2 - widthSideFlange2_left)  * tan (breaklineAngle),  b/2 - widthSideFlange2_left
		endif
		if bSideFlange2_right then
			line2 0, -b/2 + widthSideFlange2_right, breaklineDist - breaklineWidth - (b/2 - widthSideFlange2_right) * tan (breaklineAngle), -b/2 + widthSideFlange2_right
		endif
	endif

	if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		symbolPen 		= penBreakLineBelow
		symbolLinetype 	= ltBreakLineBelow
	endif

	if bShowBreakline then
		pen symbolPen
		line_type symbolLinetype

		line2 breaklineDist - breaklineWidth + b/2  * tan (breaklineAngle), b/2, breaklineDist - breaklineWidth - b/2 * tan (breaklineAngle), -b/2
	endif

	if bAscent then
		if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
			symbolPen 		= gs_cont_pen
			symbolLinetype 	= lineCont
		endif
	
		pen symbolPen
		line_type symbolLinetype

		bDrawPart1 = 1
		bDrawPart2 = 0

		ascentLinePos		= lengthAscent
		bDrawAscentline1	= (breaklineDist > ascentLinePos - (b / 2 - widthSideFlange2_left - widthSideFlange1_left) * TAN(breaklineAngle) + breaklineWidth)
		if bDrawAscentline1 then
			breakAscentline		= (breaklineDist < ascentLinePos + (b / 2 - widthSideFlange2_left - widthSideFlange1_left) * TAN(breaklineAngle) + breaklineWidth)
			bShowFlangeLinesL	= 1
			bShowFlangeLinesR	= (breaklineDist > ascentLinePos + (b / 2) * TAN(breaklineAngle) + breaklineWidth)
			gosub "ascent line"
		endif

		ascentLinePos		= a - lengthAscent
		bDrawAscentline2	= (breaklineDist > ascentLinePos - (b / 2 - widthSideFlange2_left - widthSideFlange1_left) * TAN(breaklineAngle) + breaklineWidth)
		if bDrawAscentline2 then
			breakAscentline		= (breaklineDist < ascentLinePos + (b / 2 - widthSideFlange2_left - widthSideFlange1_left) * TAN(breaklineAngle) + breaklineWidth)
			bShowFlangeLinesL	= 1
			bShowFlangeLinesR	= (breaklineDist > ascentLinePos + (b / 2) * TAN(breaklineAngle) + breaklineWidth)
			gosub "ascent line"
		endif
	endif

	! --- Arrow --------------------------------------------------------------------
	if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		symbolPen 		= penWalkingBelow
		symbolLinetype 	= ltWalkingBelow
	else
		symbolPen 		= penArrow
	endif

	pen symbolPen
	line_type symbolLinetype

	if (bStartSymbol and iFloorPlanDisplayType = DISPLAY_SYMBOLIC and not(bReverse)) or iFloorPlanDisplayType <> DISPLAY_SYMBOLIC then
		DRAWINDEX 30
		_StartSymbolPos = 0
		penStartSymbol 	= penStartSymbolBelow
		gosub "StartSymbol"
	endif

	if (bWalkingLine and iFloorPlanDisplayType = DISPLAY_SYMBOLIC) or iFloorPlanDisplayType <> DISPLAY_SYMBOLIC then
		DRAWINDEX 20
		if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
			if bWalkingLine then
				if iWalkingLineType = WALKINGLINE_SIMPLE then
					line2 0, 0, breaklineDist - breaklineWidth, 0
				else
					if not(bReverse) then
						if not(bAscent) then
							line2 	0, _BLeft/2, 	A/2 - breaklineWidth + _XLeft, _YLeft
							line2 	0, -_BRight/2, 	A/2 - breaklineWidth -_XRight, -_YRight
						else
							line2 	0, 	_BLeft/2,  		lengthAscent, 0
							line2 	0, 	-_BRight/2, 	lengthAscent, 0

							line2 	lengthAscent, 	_BLeft/2, 	A/2 - breaklineWidth + _XLeft,  _YLeft
							line2 	lengthAscent, 	-_BRight/2, A/2 - breaklineWidth - _XRight, -_YRight
						endif
					else
						if not(bAscent) then
							line2 	breaklineWidth, 0, A / 2 - breaklineWidth + _XLeft, 	_YLeft
							line2 	breaklineWidth, 0, A / 2 - breaklineWidth - _XRight, 	-_YRight
						else
							line2 	0, 0, lengthAscent, _BLeft/2
							line2 	0, 0, lengthAscent, -_BRight/2

							line2 	lengthAscent, 	0, A / 2 - breaklineWidth + _XLeft, 	_YLeft
							line2 	lengthAscent, 	0, A / 2 - breaklineWidth - _XRight, 	-_YRight
						endif
					endif
				endif
			endif
		else
			line2 0, 0, breaklineDist - breaklineWidth, 0
		endif
	endif

	if (bEndSymbol and iFloorPlanDisplayType = DISPLAY_SYMBOLIC and bWalkingLine) or iFloorPlanDisplayType <> DISPLAY_SYMBOLIC then
		DRAWINDEX 30
		penEndSymbol = penEndSymbolBelow

		if bReverse and iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
			arrowPos = 0
			if lengthAscent > arrowHeight then gosub "arrow line"
		endif		

		if (not(bReverse) and iFloorPlanDisplayType = DISPLAY_SYMBOLIC) or iFloorPlanDisplayType <> DISPLAY_SYMBOLIC then
			arrowPos = breaklineDist - breaklineWidth
			if (a - lengthAscent * 2) / 2 > arrowHeight then gosub "arrow line"
		endif

		if bAscent then
			if breaklineDist > lengthAscent then
				arrowPos = lengthAscent
				if lengthAscent > arrowHeight then gosub "arrow line"
			endif
			if breaklineDist > a - lengthAscent then
				arrowPos = a - lengthAscent
				if a - lengthAscent * 2 > arrowHeight then gosub "arrow line"
			endif
		endif
	endif

	! --- Text ---------------------------------------------------------------------
	pen penText
	if typeTextRotation_m = 2 then gosub "text rotation"
	DRAWINDEX 40
	if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		if bAscent then
			if bShowText1 then
				if breaklineDist-lengthAscent > STW(gr_tx1) / 1000 * GLOB_SCALE then text2 (breaklineDist+lengthAscent)/2 , yPos, gr_tx2
				if iTextType1 <> TEXT_FULLLENGTH and iTextType1 <> TEXT_CUSTOM then
					if lengthAscent > STW(gr_tx2) / 1000 * GLOB_SCALE then text2 lengthAscent/2, yPos, gr_tx1
				endif
			endif

			if bShowText2 then
				if breaklineDist-lengthAscent > STW(gr_tx3) / 1000 * GLOB_SCALE then text2 (breaklineDist+lengthAscent)/2, -yPos, gr_tx4
				if iTextType2 <> TEXT_FULLLENGTH and iTextType2 <> TEXT_CUSTOM then
					if lengthAscent > STW(gr_tx4) / 1000 * GLOB_SCALE then text2 lengthAscent/2, -yPos, gr_tx3
				endif
			endif
		else
			if bShowText1 then
				if breaklineDist > STW(gr_tx1) / 1000 * GLOB_SCALE then text2 breaklineDist / 2 , yPos, gr_tx2
			endif
			if bShowText2 then
				if breaklineDist > STW(gr_tx3) / 1000 * GLOB_SCALE then text2 breaklineDist / 2, - yPos, gr_tx4
			endif
		endif
	else
		if NOT(bSymbolBelowIsOverhead) then	
			if bAscent then
				if MIN(lengthAscent, breaklineDist) > STW(gr_tx1) / 1000 * GLOB_SCALE then text2 MIN(lengthAscent, breaklineDist) / 2, yPos, gr_tx1
				if breaklineDist - lengthAscent > STW(gr_tx2) / 1000 * GLOB_SCALE then text2 MIN(a / 2, lengthAscent + (breaklineDist - lengthAscent) / 2), yPos, gr_tx2
				if breaklineDist - (a - lengthAscent) > STW(gr_tx1) / 1000 * GLOB_SCALE then text2 a - lengthAscent + (breaklineDist + lengthAscent - a) / 2, yPos, gr_tx1
			else
				if breaklineDist > STW(gr_tx2) / 1000 * GLOB_SCALE then text2 breaklineDist / 2, yPos, gr_tx2
			endif
		endif
	endif
	if typeTextRotation_m = 2 then del nTrans

	! --- Fill --------------------------------------------------------------------
	if bFill then
		DRAWINDEX 10
		fill gs_fill_type
		poly2_b 4, 2+4+64, gs_fill_pen, gs_back_pen,
			0, -B/2, 0,
			breaklineDist - breaklineWidth + breaklineWidth * (bShowSymbolAboveBreakline and NOT(bSymbolAboveIsOverhead)) - B/2 * tan (breaklineAngle), -B/2, 0,
			breaklineDist - breaklineWidth + breaklineWidth * (bShowSymbolAboveBreakline and NOT(bSymbolAboveIsOverhead)) + B/2 * tan (breaklineAngle), B/2, 0,
			0, B/2, 0
	endif

return


"symbol above breakline":
	DRAWINDEX 10
	if bSymbolAboveIsOverhead then
		symbolPen		= overheadPen
		symbolLinetype	= lineOverhead
	else
		symbolPen		= gs_cont_pen
		symbolLinetype	= lineCont
	endif

	pen symbolPen
	line_type symbolLinetype

	line2 a, -b/2, a,  b/2
	line2 breaklineDist + breaklineWidth + b/2 * tan (breaklineAngle),  b/2, a,  b/2
	line2 breaklineDist + breaklineWidth - b/2 * tan (breaklineAngle), -b/2, a, -b/2

	if bShowDetailedSymbol then
		if bSideFlange1_left then
			line2 	breaklineDist + breaklineWidth + (b/2 - widthSideFlange2_left * bSideFlange2_left - widthSideFlange1_left)  * tan (breaklineAngle),
					b/2 - widthSideFlange2_left * bSideFlange2_left - widthSideFlange1_left,
					a,
					b/2 - widthSideFlange2_left * bSideFlange2_left - widthSideFlange1_left
		endif
		if bSideFlange1_right then
			line2 	breaklineDist + breaklineWidth - (b/2 - widthSideFlange2_right * bSideFlange2_right - widthSideFlange1_right) * tan (breaklineAngle),
					-b/2 + widthSideFlange2_right * bSideFlange2_right + widthSideFlange1_right,
					a,
					-b/2 + widthSideFlange2_right * bSideFlange2_right + widthSideFlange1_right
		endif
		if bSideFlange2_left then
			line2 breaklineDist + breaklineWidth + (b/2 - widthSideFlange2_left)  * tan (breaklineAngle),  b/2 - widthSideFlange2_left,  a,  b/2 - widthSideFlange2_left
		endif
		if bSideFlange2_right then
			line2 breaklineDist + breaklineWidth - (b/2 - widthSideFlange2_right) * tan (breaklineAngle), -b/2 + widthSideFlange2_right, a, -b/2 + widthSideFlange2_right
		endif
	endif

	if iFloorPlanDisplayType = DISPLAY_SYMBOLIC and bWalkingLine and not(bStop) and bShowAboveBreak then
		DRAWINDEX 30
		pen penWalkingAbove
		penStartSymbol = penStartSymbolAbove
		add2 breaklineDist + breaklineWidth, 0
		gosub "StartSymbol"
		del 1
	endif

	if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		symbolPen 		= penBreakLineAbove
		symbolLinetype 	= ltBreakLineAbove
	endif

	pen symbolPen
	line_type symbolLinetype
	DRAWINDEX 10

	if bShowBreakline then
		line2 breaklineDist + breaklineWidth + b/2 * tan (breaklineAngle), b/2, breaklineDist + breaklineWidth - b/2 * tan (breaklineAngle), -b/2
	endif

	if bAscent then
		if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
			symbolPen		= overheadPen
			symbolLinetype	= lineOverhead
		endif
		
		pen symbolPen
		line_type symbolLinetype
		bDrawPart1 = 0
		bDrawPart2 = 1

		ascentLinePos	= lengthAscent
		bDrawAscentline1	= (breaklineDist < ascentLinePos + (b / 2 - widthSideFlange2_right - widthSideFlange1_right) * TAN(breaklineAngle) - breaklineWidth)
		if bDrawAscentline1 then
			breakAscentline	= (breaklineDist > ascentLinePos - (b / 2 - widthSideFlange2_right - widthSideFlange1_right) * TAN(breaklineAngle) - breaklineWidth)
			bShowFlangeLinesL	= (breaklineDist < ascentLinePos - (b / 2) * TAN(breaklineAngle) - breaklineWidth)
			bShowFlangeLinesR	= 1
			gosub "ascent line"
		endif

		ascentLinePos	= a - lengthAscent
		bDrawAscentline2	= (breaklineDist < ascentLinePos + (b / 2 - widthSideFlange2_right - widthSideFlange1_right) * TAN(breaklineAngle) - breaklineWidth)
		if bDrawAscentline2 then
			breakAscentline	= (breaklineDist > ascentLinePos - (b / 2 - widthSideFlange2_right - widthSideFlange1_right) * TAN(breaklineAngle) - breaklineWidth)
			bShowFlangeLinesL	= (breaklineDist < ascentLinePos - (b / 2) * TAN(breaklineAngle) - breaklineWidth)
			bShowFlangeLinesR	= 1
			gosub "ascent line"
		endif
	endif

	! --- Arrow --------------------------------------------------------------------
	if (bWalkingLine and not(bStop) and iFloorPlanDisplayType = DISPLAY_SYMBOLIC) or iFloorPlanDisplayType <> DISPLAY_SYMBOLIC then
		DRAWINDEX 20

		if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
			symbolPen 		= penWalkingAbove
			line_type ltWalkingAbove
		else
			symbolPen 		= penArrow
		endif
	
		pen symbolPen

		if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
			if bWalkingLine then
				if iWalkingLineType = WALKINGLINE_SIMPLE then
					line2 breaklineDist + breaklineWidth, 0, a, 0
				else
					if not(bReverse) then
						if not(bAscent) then
							line2 	_XLeft + A/2 + breaklineWidth, 		_YLeft, 	A, 0
							line2 	-_XRight + A/2 + breaklineWidth,	-_YRight, 	A, 0
						else
							line2 	A-lengthAscent, _BLeft/2,  	A, 0
							line2 	A-lengthAscent, - _BRight/2,  	A, 0

							line2 	_XLeft + a/2+breaklineWidth,  	_YLeft, 	a-lengthAscent, 0
							line2 	-_XRight + a/2+breaklineWidth,  -_YRight, 	a-lengthAscent, 0
						endif
					else
						if not(bAscent) then
							line2 	a / 2 + breaklineWidth + _XLeft, _YLeft, a, _BLeft/2
							line2 	a / 2 + breaklineWidth -_XRight, -_YRight, A, -_BRight/2
						else
							line2 	A - lengthAscent, 0, A, _BLeft/2
							line2 	A - lengthAscent, 0, A, -_BRight/2

							line2 	a / 2 + breaklineWidth + _XLeft, 	_YLeft, 	A - lengthAscent, 	_BLeft/2
							line2 	a / 2 + breaklineWidth - _XRight, 	-_YRight, 	A - lengthAscent, 	-_BRight/2
						endif
					endif
				endif
			endif
		else
			line2 breaklineDist + breaklineWidth, 0, a, 0
		endif

	endif

	if (not(bStop) and bWalkingLine and bEndSymbol and iFloorPlanDisplayType = DISPLAY_SYMBOLIC) or iFloorPlanDisplayType <> DISPLAY_SYMBOLIC then
		DRAWINDEX 30
		penEndSymbol = penEndSymbolAbove

		if (not(bReverse) and iFloorPlanDisplayType = DISPLAY_SYMBOLIC) or iFloorPlanDisplayType <> DISPLAY_SYMBOLIC then
			arrowPos = A
			if lengthAscent > arrowHeight then gosub "arrow line"
		endif		
	
		if bReverse  and iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
			add2 breaklineWidth * 2, 0
			arrowPos = breaklineDist - breaklineWidth
			if (a - lengthAscent * 2) / 2 > arrowHeight then gosub "arrow line"
			del 1
		endif

		if bAscent then
			if breaklineDist < lengthAscent then
				arrowPos = lengthAscent
				if lengthAscent > arrowHeight then gosub "arrow line"
			endif
			if breaklineDist < a - lengthAscent then
				arrowPos = a - lengthAscent
				if a - lengthAscent * 2 > arrowHeight then gosub "arrow line"
			endif
		endif
	endif

	! --- Text ---------------------------------------------------------------------
	pen penText
	if typeTextRotation_m = 2 then gosub "text rotation"
	DRAWINDEX 40
	if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		if bAscent then
			if bShowText1 and iTextType1 <> TEXT_FULLLENGTH and iTextType1 <> TEXT_CUSTOM then
				if lengthAscent > STW(gr_tx2) / 1000 * GLOB_SCALE then text2 a - lengthAscent / 2, yPos, gr_tx1
				if breaklineDist - lengthAscent > STW(gr_tx1) / 1000 * GLOB_SCALE then text2 a - (breaklineDist+lengthAscent)/2, yPos, gr_tx2
			endif

			if bShowText2 and iTextType2 <> TEXT_FULLLENGTH and iTextType2 <> TEXT_CUSTOM then
				if lengthAscent > STW(gr_tx4) / 1000 * GLOB_SCALE then text2 a - lengthAscent / 2, -yPos, gr_tx3
				if breaklineDist - lengthAscent > STW(gr_tx3) / 1000 * GLOB_SCALE then text2 a - (breaklineDist+lengthAscent)/2, -yPos, gr_tx4
			endif
		else
			if bShowText1 then
				if breaklineDist > STW(gr_tx1) / 1000 * GLOB_SCALE then text2 a - breaklineDist / 2, yPos, gr_tx2
			endif
			if bShowText2 then
				if breaklineDist > STW(gr_tx3) / 1000 * GLOB_SCALE then text2 a - breaklineDist / 2, -yPos, gr_tx4
			endif
		endif
	else
		if bShowText then
			if NOT(bSymbolBelowIsOverhead) then
				if bAscent then
					if lengthAscent - breaklineDist > STW(gr_tx1) / 1000 * GLOB_SCALE then text2 breaklineDist + (lengthAscent - breaklineDist) / 2, yPos, gr_tx1
					if a - lengthAscent - breaklineDist > STW(gr_tx2) / 1000 * GLOB_SCALE then text2 MAX(a / 2, breaklineDist + (a - lengthAscent - breaklineDist) / 2), yPos, gr_tx2
					if (a - breaklineDist) > STW(gr_tx1) / 1000 * GLOB_SCALE then text2 MAX(breaklineDist + (a - breaklineDist) / 2, a - lengthAscent / 2), yPos, gr_tx1
				else
					if (a - breaklineDist) > STW(gr_tx2) / 1000 * GLOB_SCALE then text2 breaklineDist + (a - breaklineDist) / 2, yPos, gr_tx2
				endif		
			endif
		endif
	endif
	if typeTextRotation_m = 2 then del nTrans

	! --- Fill --------------------------------------------------------------------
	if bFill and NOT(bSymbolAboveIsOverhead) then
		DRAWINDEX 10
		fill gs_fill_type
		poly2_b 4, 2+4+64, gs_fill_pen, gs_back_pen,
				breaklineDist + breaklineWidth * NOT(bShowSymbolBelowBreakline) - B/2 * tan (breaklineAngle), -B/2, 0,
				A, -B/2, 0,
				A, B/2, 0,
				breaklineDist + breaklineWidth * NOT(bShowSymbolBelowBreakline) + B/2 * tan (breaklineAngle), B/2, 0
	endif

return

"ascent line":

	add2 ascentLinePos, 0

	ascentBreakHeight	= breaklineWidth * 2 / TAN(breaklineAngle)

	if breakAscentline then
		if bDrawPart1 then
			line2	0,  b/2 - (widthSideFlange2_left  * bSideFlange2_left + widthSideFlange1_left  * bSideFlange1_left) * bShowDetailedSymbol,
					0, b/2 - (widthSideFlange2_left  * bSideFlange2_left + widthSideFlange1_left  * bSideFlange1_left) * bShowDetailedSymbol\
					-(breaklineDist + (b / 2 - widthSideFlange2_left - widthSideFlange1_left) * TAN(breaklineAngle) - ascentLinePos) / TAN(breaklineAngle) + ascentBreakHeight / 2
		endif
		if bDrawPart2 then
			line2	0, b/2 - (widthSideFlange2_left  * bSideFlange2_left + widthSideFlange1_left  * bSideFlange1_left) * bShowDetailedSymbol\
						-(breaklineDist + (b / 2 - widthSideFlange2_left - widthSideFlange1_left) * TAN(breaklineAngle) - ascentLinePos) / TAN(breaklineAngle) - ascentBreakHeight / 2,
					0, -b/2 + (widthSideFlange2_right * bSideFlange2_right + widthSideFlange1_right * bSideFlange1_right) * bShowDetailedSymbol
		endif
	else
		line2	0,  b/2 - (widthSideFlange2_left  * bSideFlange2_left + widthSideFlange1_left  * bSideFlange1_left) * bShowDetailedSymbol,
				0, -b/2 + (widthSideFlange2_right * bSideFlange2_right + widthSideFlange1_right * bSideFlange1_right) * bShowDetailedSymbol
	endif

	if bShowDetailedSymbol then
		if	(NOT(breakAscentline) and bShowFlangeLinesL) | (breakAscentline and bDrawPart1) then
			if bSideFlange1_left then
				line2	- heightSideFlange1_left * ascentPercentage / 100, b/2 - bSideFlange2_left * widthSideFlange2_left,
						- heightSideFlange1_left * ascentPercentage / 100, b/2 - bSideFlange2_left * widthSideFlange2_left - widthSideFlange1_left
			endif
			if bSideFlange2_left then
				line2	- heightSideFlange2_left * ascentPercentage / 100, b/2,
						- heightSideFlange2_left * ascentPercentage / 100, b/2 - widthSideFlange2_left
			endif
		endif

		if	(NOT(breakAscentline) and bShowFlangeLinesR) | (breakAscentline and bDrawPart2) then
			if bSideFlange1_right then
				line2	- heightSideFlange1_right * ascentPercentage / 100, -b/2 + bSideFlange2_right * widthSideFlange2_right,
						- heightSideFlange1_right * ascentPercentage / 100, -b/2 + bSideFlange2_right * widthSideFlange2_right + widthSideFlange1_right
			endif
			if bSideFlange2_right then
				line2	- heightSideFlange2_right * ascentPercentage / 100, -b/2,
						- heightSideFlange2_right * ascentPercentage / 100, -b/2 + widthSideFlange2_right
			endif
		endif
	endif

	del 1

return

"arrow line":
	add2 arrowPos, 0

	if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		fill fillEndSymbol
		if iEndSymbol = 1 or iEndSymbol = 3 or iEndSymbol = 5 then
			_actSymbolLength = b / 2
			_actSymbolHeight = arrowHeight
		endif

		if iEndSymbol = 2 or iEndSymbol = 4 or  iEndSymbol = 6 then
			_actSymbolLength = arrowWidth / 2
			_actSymbolHeight = arrowHeight
		endif

		if iEndSymbol = 1 or iEndSymbol = 2 then
			temp_ArrowMask=0
		else
			temp_ArrowMask=1
		endif

		if bReverse then
			mul2 -1,1
		endif

		POLY2_ 4, 1,
			-_actSymbolHeight,	-_actSymbolLength, 	temp_ArrowMask,
			-_actSymbolHeight,	_actSymbolLength, 	1,
			0,					0, 					1,
			-_actSymbolHeight,	-_actSymbolLength,	-1

		if iEndSymbol = 3 or iEndSymbol = 4 then
			poly2_B 4, 2, gs_fill_pen, penEndSymbol, 
					-_actSymbolHeight,	-_actSymbolLength, 	temp_ArrowMask,
					-_actSymbolHeight,	_actSymbolLength, 	1,
					0,					0, 					1,
					-_actSymbolHeight,	-_actSymbolLength,	-1
		else
			if iEndSymbol = 5 or iEndSymbol = 6 then
				poly2_B 4, 2, gs_fill_pen, penEndSymbol,
						-_actSymbolHeight,	0, 	temp_ArrowMask,
						-_actSymbolHeight,	-_actSymbolLength, 	1,
						0,					0, 					1,
						-_actSymbolHeight,	0,	-1
			endif
		endif

		hotspot2 0,					_actSymbolLength,	EndSymbUNID, arrowHeight, 1+128	: EndSymbUNID = EndSymbUNID+ 1
		hotspot2 -_actSymbolHeight,	_actSymbolLength,	EndSymbUNID, arrowHeight, 2		: EndSymbUNID = EndSymbUNID+ 1
		hotspot2 1,					_actSymbolLength,	EndSymbUNID, arrowHeight, 3		: EndSymbUNID = EndSymbUNID+ 1

		hotspot2 0,					-_actSymbolLength,	EndSymbUNID, arrowHeight, 1+128	: EndSymbUNID = EndSymbUNID+ 1
		hotspot2 -_actSymbolHeight, -_actSymbolLength,	EndSymbUNID, arrowHeight, 2		: EndSymbUNID = EndSymbUNID+ 1
		hotspot2 1, 				-_actSymbolLength,	EndSymbUNID, arrowHeight, 3		: EndSymbUNID = EndSymbUNID+ 1

		if iEndSymbol = 2 or iEndSymbol = 4 or iEndSymbol = 6 then
			hotspot2 -_actSymbolHeight,	0,					EndSymbUNID, arrowWidthHalf, 1+128,	arrowWidth	: EndSymbUNID = EndSymbUNID + 1
			hotspot2 -_actSymbolHeight,	arrowWidth / 2,		EndSymbUNID, arrowWidthHalf, 2,		arrowWidth	: EndSymbUNID = EndSymbUNID + 1
			hotspot2 -_actSymbolHeight,	-1,					EndSymbUNID, arrowWidthHalf, 3,		arrowWidth	: EndSymbUNID = EndSymbUNID + 1
	
			hotspot2 -_actSymbolHeight,	arrowWidth / 2,		EndSymbUNID, arrowWidthHalf, 1+128,	arrowWidth 	: EndSymbUNID = EndSymbUNID + 1
			hotspot2 -_actSymbolHeight,	- arrowWidth / 2,	EndSymbUNID, arrowWidthHalf, 2,		arrowWidth	: EndSymbUNID = EndSymbUNID + 1
			hotspot2 -_actSymbolHeight,	1,					EndSymbUNID, arrowWidthHalf, 3,		arrowWidth	: EndSymbUNID = EndSymbUNID + 1
		endif

		if bReverse then
			del 1
		endif

	else	
		line2 -arrowSize,  arrowSize, 0, 0
		line2 -arrowSize, -arrowSize, 0, 0
	
	endif
	del 1

return


"text rotation":

	nTrans = 0
	if  (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps)) then
		rot2 180
		mul2 -1, 1
		nTrans = nTrans + 2
	endif

return

"StartSymbol":

	add2 _StartSymbolPos, 0
	if iFloorPlanDisplayType = DISPLAY_SYMBOLIC then
		fill fillStartSymbol
		if penStartSymbol <> 0 then
			temp_FillStatus = 2
		else
			temp_FillStatus = 0
		endif

		if iStartSymbol = 1 then	! Style 1
			poly2_b 2, 1+temp_FillStatus, gs_fill_pen, penStartSymbol,
				0,						0, 		901,
				widthStartSymbol / 2,	360, 	4001
		endif

		if iStartSymbol = 2 then	! Style 2
			for k = 1 to 2
				poly2_b 6, 1+temp_FillStatus, gs_fill_pen, penStartSymbol,
					0, 						0, 						1,
					widthStartSymbol / 2, 	0, 						1,
					0,						0,						901,
					0,						90,						4001,
					0,						widthStartSymbol / 2,	0,
					0,						0,						-1
				poly2_b 6, 1, penStartSymbol, gs_fill_pen,
					0,						0,						1,
					0,						widthStartSymbol / 2,	1,
					0,						0,						901,
					0,						90,						4001,
					-widthStartSymbol / 2,	0,						0,
					0,						0,						-1
				rot2 180
			next k
			del 2
		endif

		if iStartSymbol = 3 then	! Style 3
			line2 widthStartSymbol/2, 	heightStartSymbol/2, 	- widthStartSymbol/2, 	heightStartSymbol/2
			line2 widthStartSymbol/2, 	- heightStartSymbol/2, 	- widthStartSymbol/2, 	- heightStartSymbol/2
		endif

		if iStartSymbol = 1 or iStartSymbol = 2 then
			for kk=1 to 4
				hotspot2 0, 					0,	StartSymbUNID, widthStartSymbolHalf, 1+128, widthStartSymbol	: StartSymbUNID = StartSymbUNID + 1
				hotspot2 widthStartSymbol / 2, 	0,	StartSymbUNID, widthStartSymbolHalf, 2, 	widthStartSymbol	: StartSymbUNID = StartSymbUNID + 1
				hotspot2 -1, 					0,	StartSymbUNID, widthStartSymbolHalf, 3+128, widthStartSymbol	: StartSymbUNID = StartSymbUNID + 1
				rot2 90
			next kk
			del 4
		else
			for kk=1 to 2
				! Symbol Width/2
				hotspot2 0,						- heightStartSymbolHalf, StartSymbUNID, widthStartSymbolHalf, 1+128,	widthStartSymbol	:StartSymbUNID=StartSymbUNID+1
				hotspot2 widthStartSymbolHalf, 	- heightStartSymbolHalf, StartSymbUNID, widthStartSymbolHalf, 2, 		widthStartSymbol	:StartSymbUNID=StartSymbUNID+1
				hotspot2 -1,					- heightStartSymbolHalf, StartSymbUNID, widthStartSymbolHalf, 3, 		widthStartSymbol	:StartSymbUNID=StartSymbUNID+1
	
				hotspot2 0,						heightStartSymbolHalf, StartSymbUNID, widthStartSymbolHalf, 1+128,	widthStartSymbol	:StartSymbUNID=StartSymbUNID+1
				hotspot2 widthStartSymbolHalf, 	heightStartSymbolHalf, StartSymbUNID, widthStartSymbolHalf, 2,		widthStartSymbol	:StartSymbUNID=StartSymbUNID+1
				hotspot2 -1,					heightStartSymbolHalf, StartSymbUNID, widthStartSymbolHalf, 3,		widthStartSymbol	:StartSymbUNID=StartSymbUNID+1
	
				! Symbol Height
				hotspot2 widthStartSymbolHalf, 0,						StartSymbUNID, heightStartSymbolHalf, 1+128, 	heightStartSymbol		:StartSymbUNID=StartSymbUNID+1
				hotspot2 widthStartSymbolHalf, heightStartSymbolHalf, 	StartSymbUNID, heightStartSymbolHalf, 2, 		heightStartSymbol		:StartSymbUNID=StartSymbUNID+1
				hotspot2 widthStartSymbolHalf, -1,						StartSymbUNID, heightStartSymbolHalf, 3, 		heightStartSymbol		:StartSymbUNID=StartSymbUNID+1
	
				hotspot2 widthStartSymbolHalf, 0,						StartSymbUNID, heightStartSymbolHalf, 1+128, 	heightStartSymbol		:StartSymbUNID=StartSymbUNID+1
				hotspot2 widthStartSymbolHalf, - heightStartSymbolHalf,	StartSymbUNID, heightStartSymbolHalf, 2,		heightStartSymbol		:StartSymbUNID=StartSymbUNID+1
				hotspot2 widthStartSymbolHalf, 1,						StartSymbUNID, heightStartSymbolHalf, 3, 		heightStartSymbol		:StartSymbUNID=StartSymbUNID+1
				mul2 -1,1
			next kk
			del kk-1
		endif
	else
		circle2 0, 0, arrowSize/5
	endif
	del 1
return
