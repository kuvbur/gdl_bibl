

! --------------------------------------------------------------------------------
! hide All Parameters list
! --------------------------------------------------------------------------------

hideparameter all "A", "B", "ZZYZX"

call "FM_types" parameters all

if GLOB_MODPAR_NAME = "Profile" or siz_mtr[1]="" then
	dim namevekt[]
	dim vekt[]
	vekt[30] = 0
	nTypes = 0
	szelv = open("text", "L_eq(14).txt", "separator='\t', mode = ro, Library")
	iRow = 2
	n = input(szelv, iRow, 2, v1, v2)
	while n > 1 do
		bHaveThisType = 0
		for k = 1 to nTypes
			if vekt[k] 	= v2 then
				bHaveThisType = 1
			endif
		next k
		if not(bHaveThisType) then
			nTypes = nTypes + 1
			vekt[nTypes] = v2
			namevekt[nTypes] = v1
		endif
		iRow = iRow + 1
		n = input(szelv, iRow, 2, v1, v2)
	endwhile
	close szelv

	namevekt[nTypes+1] = `СПЕЦИАЛЬНЫЕ`

	PARAMETERS siz_mtr=namevekt

	siz_mtr = namevekt

	if Profile <> `СПЕЦИАЛЬНЫЕ` then
		for inumType = 1 to nTypes
			if siz_mtr[inumType] = Profile then
				sectDepth = vekt[inumType]
				parameters sectDepth = sectDepth
			endif
		next inumType
	endif
endif

values "Profile" 	siz_mtr

if Profile <> `СПЕЦИАЛЬНЫЕ` & (Profile <> lastProfile or abs(availableThicknesses[1]) < EPS) then

	bFoundExactMatch = 0
	szelv = open("text", "L_eq(14).txt", "separator='\t', mode=ro, Library")
	iRow = 2
	n = input(szelv, iRow, 3, ker1, ker2)
	while n > 0 do
		if sectDepth = ker1 then
			n = input(szelv, iRow, 4, osectThick)
			put osectThick						! collect possible thickness values
			if sectThick = ker2 then			! look up all data fields for the profile
				n = input(szelv, iRow, 5, omassPerMeter, oRad, otoeRad, osectArea, osecondMomentXY, oelastMod, ogyrationRadXY, osecondMomentU, ogyrationRadU, osecondMomentV,  ogyrationRadV)
				bFoundExactMatch = 1
			endif
		endif
		iRow = iRow + 1
		n = input(szelv, iRow, 3, ker1, ker2)
	endwhile
	close szelv

	! store collected thickness values
	if NSP > 0 then
		i = 1
		dim tempAvailableThicknesses[]
		while NSP > 0 do
			tempAvailableThicknesses[i] = get(1)
			i = i + 1
		endwhile
		availableThicknesses = tempAvailableThicknesses
		parameters availableThicknesses = availableThicknesses
	endif

	! set the predefined dimensions
	if bFoundExactMatch then
		lastProfile = Profile
		parameters lastProfile = lastProfile

		sectWidth 		= sectDepth
		B 		= sectWidth / 1000
		ZZYZX	= sectDepth / 1000
		massPerMeter	= omassPerMeter
		Rad		= oRad
		toeRad		= otoeRad
		secondMomentXY	= osecondMomentXY
		secondMomentU	= osecondMomentU
		secondMomentV	= osecondMomentV
		gyrationRadXY	= ogyrationRadXY
		gyrationRadU		= ogyrationRadU
		gyrationRadV		= ogyrationRadV
		elastMod		= oelastMod
		sectArea		= osectArea
		massSum	= massPerMeter * a

		parameters 	sectWidth 		= sectWidth,
					B 		= B,
					ZZYZX	= ZZYZX,
					massPerMeter	= massPerMeter,
					Rad		= Rad,
					toeRad		= toeRad,
					secondMomentXY	= secondMomentXY,
					secondMomentU	= secondMomentU,
					secondMomentV	= secondMomentV,
					gyrationRadXY	= gyrationRadXY,
					gyrationRadU		= gyrationRadU,
					gyrationRadV		= gyrationRadV,
					elastMod		= elastMod,
					sectArea		= sectArea,
					massSum	= massSum
	endif
endif

values "sectThick" availableThicknesses

lock "B"
lock "ZZYZX"

if Profile <> `СПЕЦИАЛЬНЫЕ` then
	lock "sectDepth"
	lock "sectWidth"
	lock "massPerMeter"
	lock "Rad"
	lock "toeRad"
	lock "secondMomentXY"
	lock "secondMomentU"
	lock "secondMomentV"
	lock "gyrationRadXY"
	lock "gyrationRadU"
	lock "gyrationRadV"
	lock "elastMod"
	lock "sectArea"
else
	values "sectWidth" range (sectThick, )
	values "sectDepth" range (sectThick, )
	values "Rad" range [0, min(sectWidth-sectThick-toeRad, sectDepth-sectThick-toeRad)]
	values "toeRad" range [0, sectThick]

	if GLOB_MODPAR_NAME = "sectWidth" | GLOB_MODPAR_NAME = "sectDepth" | GLOB_MODPAR_NAME = "toeRad" then
		if Rad > min(sectWidth-sectThick-toeRad, sectDepth-sectThick-toeRad) then Rad = min(sectWidth-sectThick-toeRad, sectDepth-sectThick-toeRad)
		parameters Rad = Rad
	endif
	B		= sectWidth/1000
	ZZYZX	= sectDepth/1000
	parameters 	B		= B,
				ZZYZX	= ZZYZX
	values "toeRad" range (, sectThick]
endif

massSum = massPerMeter * A
parameters massSum=massSum
lock "massSum"

IF gs_cont_pen <= 0 THEN PARAMETERS gs_cont_pen = 90
IF gs_fill_pen <= 0 THEN PARAMETERS gs_fill_pen = 19

dim stFlangePosValues[2]
	stFlangePosValues[1] = `Вверху`
	stFlangePosValues[2] = `Внизу`

values "stFlangePos" stFlangePosValues
values "iFlangePos" FLANGEPOS_TOP, FLANGEPOS_BOTTOM

if GLOB_MODPAR_NAME = "stFlangePos" then
	iFlangePos = FLANGEPOS_TOP
	if stFlangePos = stFlangePosValues[2] then iFlangePos = FLANGEPOS_BOTTOM
	parameters iFlangePos = iFlangePos
else
	stFlangePos = stFlangePosValues[1]
	if iFlangePos = FLANGEPOS_BOTTOM then stFlangePos = stFlangePosValues[2]
	parameters stFlangePos = stFlangePos
endif
dim stDetLevel3d[3]
	stDetLevel3d[1] = `Простой`
	stDetLevel3d[2] = `Детальный`
	stDetLevel3d[3] = `Откл.`

values "gs_detlevel_3D" stDetLevel3d
values "gs_detlevel_3D_m" 1, 2, 0

if GLOB_MODPAR_NAME = "gs_detlevel_3D" then
	gs_detlevel_3D_m = 1
	if gs_detlevel_3D = stDetLevel3d[2] then gs_detlevel_3D_m = 2
	if gs_detlevel_3D = stDetLevel3d[3] then gs_detlevel_3D_m = 0
	parameters gs_detlevel_3D_m = gs_detlevel_3D_m
else
	gs_detlevel_3D = stDetLevel3d[1]
	if gs_detlevel_3D_m = 2 then gs_detlevel_3D = stDetLevel3d[2]
	if gs_detlevel_3D_m = 0 then gs_detlevel_3D = stDetLevel3d[3]
	parameters gs_detlevel_3D = gs_detlevel_3D
endif
dim stRotAxisValues[2]
	stRotAxisValues[1] = `Вдоль оси`
	stRotAxisValues[2] = `Вдоль поперечного сечения`

values "stRotAxis" stRotAxisValues
values "iRotAxis" ROT_AXIS, ROT_CROSSECT

if GLOB_MODPAR_NAME = "stRotAxis" then
	iRotAxis = ROT_AXIS
	if stRotAxis = stRotAxisValues[2] then iRotAxis = ROT_CROSSECT
	parameters iRotAxis = iRotAxis
else
	stRotAxis = stRotAxisValues[1]
	if iRotAxis = ROT_CROSSECT then stRotAxis = stRotAxisValues[2]
	parameters stRotAxis = stRotAxis
endif
dim stInsertPointValues[3]
	stInsertPointValues[1] = `Вверху`
	stInsertPointValues[2] = `По центру`
	stInsertPointValues[3] = `Внизу`

values "stInsertPoint" stInsertPointValues
values "iInsertPoint" INSERTPOINT_TOP, INSERTPOINT_CENTER, INSERTPOINT_BOTTOM

if GLOB_MODPAR_NAME = "stInsertPoint" then
	iInsertPoint = INSERTPOINT_TOP
	if stInsertPoint = stInsertPointValues[2] then iInsertPoint = INSERTPOINT_CENTER
	if stInsertPoint = stInsertPointValues[3] then iInsertPoint = INSERTPOINT_BOTTOM
	parameters iInsertPoint = iInsertPoint
else
	stInsertPoint = stInsertPointValues[1]
	if iInsertPoint = INSERTPOINT_CENTER then stInsertPoint = stInsertPointValues[2]
	if iInsertPoint = INSERTPOINT_BOTTOM then stInsertPoint = stInsertPointValues[3]
	parameters stInsertPoint = stInsertPoint
endif
values "gs_resol" RANGE [3,)
IF gs_detlevel_3D_m <> 2 then lock "gs_resol"

dim stCutModeValues[3]
	stCutModeValues[1] = `Перпендикулярно оси`
	stCutModeValues[2] = `Вдоль вертикальной оси`
	stCutModeValues[3] = `Вдоль горизонтальной оси`

if iRotAxis = ROT_AXIS or Angle>60 THEN
    values "stCutModeBottom" stCutModeValues[1],
			stCutModeValues[3]
    values "iCutModeBottom" CUTMODE_PERPENDICULAR, CUTMODE_ALONGHORIZONTAL
    values "stCutModeTop" stCutModeValues[1],
			stCutModeValues[3]
    values "iCutModeTop" CUTMODE_PERPENDICULAR, CUTMODE_ALONGHORIZONTAL
else
    values "stCutModeBottom" stCutModeValues
    values "iCutModeBottom" CUTMODE_PERPENDICULAR, CUTMODE_ALONGVERTICAL, CUTMODE_ALONGHORIZONTAL
    values "stCutModeTop" stCutModeValues
    values "iCutModeTop" CUTMODE_PERPENDICULAR, CUTMODE_ALONGVERTICAL, CUTMODE_ALONGHORIZONTAL
endif

if GLOB_MODPAR_NAME = "stCutModeBottom" then
	iCutModeBottom = CUTMODE_PERPENDICULAR
	if stCutModeBottom = stCutModeValues[2] then iCutModeBottom = CUTMODE_ALONGVERTICAL
	if stCutModeBottom = stCutModeValues[3] then iCutModeBottom = CUTMODE_ALONGHORIZONTAL
	parameters iCutModeBottom = iCutModeBottom
else
	stCutModeBottom = stCutModeValues[1]
	if iCutModeBottom = CUTMODE_ALONGVERTICAL then stCutModeBottom = stCutModeValues[2]
	if iCutModeBottom = CUTMODE_ALONGHORIZONTAL then stCutModeBottom = stCutModeValues[3]
	parameters stCutModeBottom = stCutModeBottom
endif

if GLOB_MODPAR_NAME = "stCutModeTop" then
	iCutModeTop = CUTMODE_PERPENDICULAR
	if stCutModeTop = stCutModeValues[2] then iCutModeTop = CUTMODE_ALONGVERTICAL
	if stCutModeTop = stCutModeValues[3] then iCutModeTop = CUTMODE_ALONGHORIZONTAL
	parameters iCutModeTop = iCutModeTop
else
	stCutModeTop = stCutModeValues[1]
	if iCutModeTop = CUTMODE_ALONGVERTICAL then stCutModeTop = stCutModeValues[2]
	if iCutModeTop = CUTMODE_ALONGHORIZONTAL then stCutModeTop = stCutModeValues[3]
	parameters stCutModeTop = stCutModeTop
endif

if not(bCutPlanes) THEN LOCK "stCutModeBottom", "iCutModeBottom",
				"gs_cutang1_bot", "gs_cutang2_bot",
				"stCutModeTop", "iCutModeTop",
				"gs_cutang3_up","gs_cutang4_up"

if not(axis) then
	lock "only_axis", "axis_line_type", "axis_line_pen"
endif
if axis and only_axis then
	lock "gs_ShowMoreHtps2D", "gs_cont_pen", "gs_fill_type", "gs_fill_pen", "gs_back_pen"
endif

IF Angle=0 AND iCutModeBottom <> CUTMODE_ALONGHORIZONTAL AND iCutModeTop <> CUTMODE_ALONGHORIZONTAL OR Angle<>0 THEN
    hideparameter "DashedLineType"
    lock "DashedLineType"
ENDIF


! ---------- Rotation Angle --------------------------------------------------

VALUES "Angle" range[-90,90]

if temp_ang >= 270 and temp_ang <= 360 THEN PARAMETERS temp_ang = 0		!! Bottom
if temp_ang < 270 and temp_ang >= 180 THEN PARAMETERS temp_ang = 180

IF GLOB_MODPAR_NAME = "temp_ang" THEN
	PARAMETERS Angle = temp_ang - 90
ELSE
	PARAMETERS temp_ang = Angle + 90
ENDIF

if GLOB_MODPAR_NAME = "a_temp" then
    if iRotAxis = ROT_CROSSECT then
        A = a_temp/cos(Angle)
    else
        A = a_temp
    endif
    parameters A = A
else
    if iRotAxis = ROT_CROSSECT then
        a_temp = A*cos(Angle)
    else
        a_temp = A
    endif
    parameters a_temp = a_temp
endif


! ---------- Cutting Angles --------------------------------------------------

VALUES "gs_cutang1_bot" range[-60,60]
VALUES "gs_cutang2_bot" range[-60,60]
VALUES "gs_cutang3_up" range[-60,60]
VALUES "gs_cutang4_up" range[-60,60]


if temp_cutang1_bot > 120 and temp_cutang1_bot < (360-120)/2+120 THEN PARAMETERS temp_cutang1_bot = 120
if temp_cutang1_bot < 360 and temp_cutang1_bot >= (360-120)/2+120 THEN PARAMETERS temp_cutang1_bot = 0

if temp_cutang2_bot > 120 and temp_cutang2_bot < (360-120)/2+120 THEN PARAMETERS temp_cutang2_bot = 120
if temp_cutang2_bot < 360 and temp_cutang2_bot >= (360-120)/2+120 THEN PARAMETERS temp_cutang2_bot = 0

if temp_cutang3_up > 120 and temp_cutang3_up < (360-120)/2+120 THEN PARAMETERS temp_cutang3_up = 120
if temp_cutang3_up < 360 and temp_cutang3_up >= (360-120)/2+120 THEN PARAMETERS temp_cutang3_up = 0

if temp_cutang4_up > 120 and temp_cutang4_up < (360-120)/2+120 THEN PARAMETERS temp_cutang4_up = 120
if temp_cutang4_up < 360 and temp_cutang4_up >= (360-120)/2+120 THEN PARAMETERS temp_cutang4_up = 0


IF GLOB_MODPAR_NAME = "temp_cutang1_bot" THEN
	PARAMETERS gs_cutang1_bot = temp_cutang1_bot - 60
ELSE
	PARAMETERS temp_cutang1_bot = gs_cutang1_bot + 60
ENDIF

IF GLOB_MODPAR_NAME = "temp_cutang2_bot" THEN
	PARAMETERS gs_cutang2_bot = temp_cutang2_bot - 60
ELSE
	PARAMETERS temp_cutang2_bot = gs_cutang2_bot + 60
ENDIF

IF GLOB_MODPAR_NAME = "temp_cutang3_up" THEN
	PARAMETERS gs_cutang3_up = temp_cutang3_up - 60
ELSE
	PARAMETERS temp_cutang3_up = gs_cutang3_up + 60
ENDIF

IF GLOB_MODPAR_NAME = "temp_cutang4_up" THEN
	PARAMETERS gs_cutang4_up = temp_cutang4_up - 60
ELSE
	PARAMETERS temp_cutang4_up = gs_cutang4_up + 60
ENDIF
! ================================================================================
! Toplevel, Bottomlevel
! ================================================================================
ac_bottomlevel = 0
ac_toplevel = ZZYZX
tempAng =  abs(atn((ZZYZX-sectThick/1000)/(B-sectThick/1000)) )

if iRotAxis = ROT_AXIS then

	ac_bottomlevel =  - abs(sin (Angle)* B/2)
	if (Angle < 0) then
		ac_toplevel = abs(sin (Angle)* B/2) + cos(Angle)* ZZYZX
	else
		if (abs(Angle) < tempAng) then
			ac_toplevel = abs(sin(90-Angle)* ZZYZX) - abs(sin(Angle)*B/2) + abs(sin(Angle)* sectThick/1000)
		else
			ac_toplevel = abs(sin(Angle) * B/2) + abs(cos(Angle)*sectThick/1000)
		endif
	endif

	if 	iInsertPoint = INSERTPOINT_BOTTOM then
		ac_bottomlevel = ac_bottomlevel 
		ac_toplevel =ac_toplevel
	else
		if iInsertPoint = INSERTPOINT_CENTER then 
			ac_bottomlevel =  ac_bottomlevel - abs( cos(Angle)*ZZYZX/2)
			ac_toplevel = ac_toplevel- abs( cos(Angle)*ZZYZX/2)	
		else				!INSERTPOINT_TOP  	
			ac_toplevel = ac_toplevel- abs( cos(Angle)*ZZYZX)	
			ac_bottomlevel = ac_bottomlevel - abs( cos(Angle)*ZZYZX)
		endif
	endif


else    ! iRotAxis = ROT_CROSSECT 
	if iInsertPoint = INSERTPOINT_BOTTOM then
		if not(Angle<0) then
			ac_bottomlevel =  0
			ac_toplevel = abs(cos(90-Angle) * A) + abs(sin(90-Angle)*ZZYZX)
		else
			ac_toplevel =  abs(sin(90-Angle)*ZZYZX)
			ac_bottomlevel = -abs(cos(90-Angle) * A)
		endif
	else
		if iInsertPoint = INSERTPOINT_CENTER then
			if not(Angle<0) then
				ac_bottomlevel =  -abs(sin (90-Angle)* ZZYZX/2)
				ac_toplevel = abs(cos(90-Angle) * A) + abs(sin(90-Angle)*ZZYZX) -abs(sin (90-Angle)* ZZYZX/2)
			else
				ac_toplevel =  abs(sin (90-Angle)* ZZYZX/2)
				ac_bottomlevel = -abs(cos(90-Angle) * A) - abs(sin(90-Angle)*ZZYZX) +abs(sin (90-Angle)* ZZYZX/2)
			endif
		else				!INSERTPOINT_TOP 
			if not(Angle<0) then 	
				ac_bottomlevel =  -2*abs(sin (90-Angle)* ZZYZX/2)
				ac_toplevel = abs(cos(90-Angle) * A) + abs(sin(90-Angle)*ZZYZX) -2*abs(sin (90-Angle)* ZZYZX/2)
			else
				ac_toplevel = 0
				ac_bottomlevel = -abs(cos(90-Angle) * A) - abs(sin(90-Angle)*ZZYZX)
			endif
		endif
	endif
endif


parameters ac_bottomlevel = ac_bottomlevel
parameters ac_toplevel = ac_toplevel

