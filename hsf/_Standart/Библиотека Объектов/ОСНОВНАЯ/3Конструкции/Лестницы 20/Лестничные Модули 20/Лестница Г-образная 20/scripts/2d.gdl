

! ---------- Hotspots ----------[
	unID = 1
	FlightUNID		= 2
	RailUNID		= 100
	StartSymbUNID	= 200
	ArrowUNID		= 300
	RiseRunUNID		= 400
	UpDownUNID		= 500
	NumUnID			= 600

hotspot2 0,0, unID: unID=unID+1

! ---------- Hotspots ----------]

dim drawPart[3] ! 1 - lower,  2 - upper,  3 - full
dim drawDashed[3] ! 1 - lower,  2 - upper,  3 - full
dim drawSteps[3] ! 1 - lower,  2 - upper,  3 - full
dim drawDetails[3] ! 1 - lower,  2 - upper,  3 - full

drawPart[1] = 0		! Lower
drawPart[2] = 0		! Upper
drawPart[3] = 0		! Full
drawDashed[1] = 0	! Lower
drawDashed[2] = 0	! Upper
drawDashed[3] = 0	! Full
drawSteps[1] = 0	! Lower
drawSteps[2] = 0	! Upper
drawSteps[3] = 0	! Full
drawDetails[1] = 0	! Lower
drawDetails[2] = 0	! Upper
drawDetails[3] = 0	! Full
drawNum = 0


abovestory = 0
belowstory = 0
if bStorySensitive then
	if GLOB_CH_STORY_DIST > EPS  then
		abovestory = 1
	else
		if GLOB_CH_STORY_DIST < -EPS  then
			belowstory = 1
		endif
	endif
endif

bCarriageLineExist		= bShowCarriage and bEnableCarriageLine and (GLOB_SCALE <= iShowCarriageUpTo | iShowCarriageUpTo = 1)

! ---------- Settings of 2D Symbol Type ----------
_iSymbolType = 1
_bShowRailIn2D = 1
if gs_detlevel_2D_m = DET2D_SCALESENSITIVE then
	if GLOB_SCALE <= _iScaleMD then									!! Detailed Scale
		_iSymbolType = iEnabledSymbolTypes[iSymbolGroup][3]
	else
		if GLOB_SCALE > _iScaleMD & GLOB_SCALE <= _iScaleSM then	!! Middle Scale
			_iSymbolType = iEnabledSymbolTypes[iSymbolGroup][2]
		else														!! Simple Scale
			_iSymbolType = iEnabledSymbolTypes[iSymbolGroup][1]
			_bShowRailIn2D = 0
		endif
	endif
else
	_iSymbolType = gs_SymbolType_m
endif

IF _iSymbolType = 1 THEN		! Type 1
	drawPart[3]	= 1		! Full
	drawDashed[3] = 1	! Full
ENDIF

IF _iSymbolType = 2 THEN		! Type 2
	drawPart[3]	= 1		! Full
ENDIF

IF _iSymbolType = 3 THEN		! Type 3
	drawPart[1]	= 1		! Lower
ENDIF

IF _iSymbolType = 4 THEN		! Type 4
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
ENDIF

IF _iSymbolType = 5 THEN		! Type 5
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
ENDIF

IF _iSymbolType = 6 THEN		! Type 6
	drawPart[3]	= 1		! Full
	drawDashed[3] = 1	! Full
	drawSteps[3] = 1	! Full
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 7 THEN		! Type 7
	drawPart[3]	= 1		! Full
	drawSteps[3] = 1	! Full
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 8 THEN		! Type 8
	drawPart[1]	= 1		! Lower
	drawSteps[1] = 1	! Lower
ENDIF

IF _iSymbolType = 9 THEN		! Type 9
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
ENDIF

IF _iSymbolType = 10 THEN		! Type 10
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
ENDIF

IF _iSymbolType = 11 THEN		! Type 11
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 12 THEN		! Type 12
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 13 THEN		! Type 13
	drawPart[3]	= 1		! Full
	drawDashed[3] = 1	! Full
	drawSteps[3] = 1	! Full
	drawDetails[3] = 1	! Full

	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 14 THEN		! Type 14
	drawPart[3]	= 1		! Full
	drawSteps[3] = 1	! Full
	drawDetails[3] = 1	! Full

	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 15 THEN		! Type 15
	drawPart[1]	= 1		! Lower
	drawSteps[1] = 1	! Lower
	drawDetails[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
!	drawDetails[2] = 1	! Upper ! COMP
ENDIF

IF _iSymbolType = 16 THEN		! Type 16
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawDetails[1] = 1	! Lower
ENDIF

IF _iSymbolType = 17 THEN		! Type 17
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
	drawDetails[1] = 1	! Lower
ENDIF

IF _iSymbolType = 18 THEN		! Type 18
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawDetails[1] = 1	! Lower
	drawDetails[2] = 1	! Upper
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 19 THEN		! Type 19
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawDetails[1] = 1	! Lower
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 20 THEN		! Type 20
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawDetails[1] = 1	! Lower
	drawDetails[2] = 1	! Upper
	drawNum = bShowNumbering
ENDIF

! ---------- Stories below the home story ---------- [

bBackgroundFill = 1
if belowstory then
	drawPart[3]		= 1
	drawDashed[3]	= 1

	drawSteps[1] = 0
	drawSteps[2] = 0
	drawSteps[3] = 0

	drawDetails[1] = 0
	drawDetails[2] = 0
	drawDetails[3] = 0

	drawNum = 0
endif

! ---------- Stories below the home story ---------- ]

! ---------- Stories above the home story ---------- [
if abovestory then
	drawPart[1] = 0
	drawPart[2] = 0
	drawPart[3] = 0

	if gs_TreadStUp then
		drawSteps[1] = 1
		drawSteps[2] = 1
		drawSteps[3] = 1

		if drawDetails[1] | drawDetails[3] then
			drawDetails[1] = 1
			drawDetails[2] = 1
			drawDetails[3] = 1
		endif

	else
		drawSteps[1] = 0
		drawSteps[2] = 0
		drawSteps[3] = 0

		drawDetails[1] = 0
		drawDetails[2] = 0
		drawDetails[3] = 0
	endif

	if gs_BreaklineStUp = 0 then
		drawPart[3] = 1
	else
		if gs_LowerPartStUp then
			drawPart[1] = 1
		endif
		if gs_UpperPartStUp then
			drawPart[2] = 1
		endif
	endif

	if gs_numaStUp & gs_TreadStUp & ((drawPart[1] & drawPart[2]) | drawPart[3]) then
		drawNum = 1
	else
		drawNum = 0
	endif
endif

add2 0,gapToFirstTread

hasBreak1st = 0
hasBreak2nd	= 0
	NumStline = INT (gs_BreakHeight/treadHeight)
	NumStline = max(1,NumStline)

FOR iFlight = 1 TO 2
	DRAWINDEX 10
	PEN gs_cont_pen
	FILL gs_fill_type

	if iFlight = 1 then
		RNU_temp = nRisers1stRun-1
		if drawPart[3] then
			bBackgroundFill	= 1
			drawBreakLine = 0
		else
			IF nRisers1stRun > NumStline+1 THEN
				drawBreakLine = 1
				hasBreak1st = 1
				bBackgroundFill	= gs_FillAbove
			else
				drawBreakLine = 0
				bBackgroundFill	= 1
			ENDIF
		endif
	endif
	if iFlight = 2 then
		RNU_temp	= nRisers2ndRun
		if drawPart[3] then
			bBackgroundFill = 1
			drawBreakLine = 0
		else
			if nRisers1stRun <= (NumStline+1) then
				drawBreakLine = 1
				hasBreak2nd = 1
				NumStline = max(1,(NumStline-nRisers1stRun))
				bBackgroundFill	= gs_FillAbove
			else
				drawBreakLine = 0
				bBackgroundFill	= gs_FillAbove
			endif
		endif
	ENDIF
	if belowStory then bBackgroundFill	= 0

	! ==========================================================================
	! CONTOUR LINES
	! ==========================================================================

	IF not(drawBreakLine) THEN
		IF (iFlight = 1 & drawPart[1]) | (iFlight=2 & drawPart[2]) | drawPart[3] THEN
			if aboveStory then
				PEN gs_LinePenStUp
				LINE_TYPE gs_LineTypeStUp
			else
				if drawDashed[iFlight] | drawDashed[3] then
					PEN gs_DashLinePen
					LINE_TYPE dash_line
				else
					PEN gs_cont_pen
					LINE_TYPE solid_line
				endif
			endif

			mask = 1
			if iFlight = 1 then xNosing = nosing * (drawDetails[1]|drawDetails[3])
			if iFlight = 2 then
				xNosing = nosing * (drawDetails[2]|drawDetails[3])
				mask = 0
			endif

			! ---------- Contour of Landing ----------
			if iFlight = 1 then
				POLY2_b 5, 1+2*bBackgroundFill+4+64, gs_fill_pen, gs_back_pen,
					flightWidth,(RNU_temp)*treadDepth-xNosing, 1,
					flightWidth,(RNU_temp)*treadDepth, 0,
					flightWidth,(RNU_temp)*treadDepth+flightWidth, 1,
					0,			(RNU_temp)*treadDepth+flightWidth, 1,
					0,			(RNU_temp)*treadDepth-xNosing, 0

				HOTLINE2 flightWidth, (RNU_temp)*treadDepth-xNosing,		flightWidth,	(RNU_temp)*treadDepth+flightWidth
				HOTLINE2 flightWidth, (RNU_temp)*treadDepth+flightWidth,	0,				(RNU_temp)*treadDepth+flightWidth
				HOTLINE2 0,			(RNU_temp)*treadDepth+flightWidth,	0,				(RNU_temp)*treadDepth-xNosing
				HOTLINE2 0,			(RNU_temp)*treadDepth-xNosing,		flightWidth,	(RNU_temp)*treadDepth-xNosing
			endif

			POLY2_b 4, 1+2*bBackgroundFill+4+64, gs_fill_pen, gs_back_pen,
				0,			-xNosing, 1,
				flightWidth,-xNosing, 1,
				flightWidth,(RNU_temp)*treadDepth-xNosing*mask, 1,
				0,			(RNU_temp)*treadDepth-xNosing*mask, 1

			HOTLINE2 0, -xNosing, flightWidth, -xNosing
			HOTLINE2 flightWidth, -xNosing, flightWidth, (RNU_temp)*treadDepth-xNosing
			HOTLINE2 flightWidth, (RNU_temp)*treadDepth-xNosing,0, (RNU_temp)*treadDepth-xNosing
			HOTLINE2 0, (RNU_temp)*treadDepth-xNosing,0, -xNosing

		endif
	ELSE

! with Break Line
! ---------------------------------------------------------------------------------------------
		if breakline_style_m = 2 then		! Zig Zag
			angle_breakline=ATN(2*treadDepth/flightWidth)
			ZigZag1Y=(2/5*flightWidth)*tan(angle_breakline)
			ZigZag2Y=(7/20*flightWidth)*tan(angle_breakline)
		else
			if breakline_style_m = 3 then		! Zig Zag CHI
				angle_breakline=ATN(2*treadDepth/flightWidth)
				ZigZag1Y=(2/5*flightWidth)*tan(angle_breakline)
				ZigZag2Y=(2/5*flightWidth)*tan(angle_breakline)
			endif
		endif

		IF drawPart[1] THEN
			if aboveStory then
				PEN gs_LinePenStUp
				LINE_TYPE gs_LineTypeStUp
			else
				if drawDashed[1] then
					PEN gs_DashLinePen
					LINE_TYPE dash_line
				else
					PEN gs_cont_pen
					LINE_TYPE solid_line
				endif
			endif

			xNosing = nosing * drawDetails[1]

			if breakline_style_m = 2 then
				! ---------- Zig Zag ----------
				POLY2_b 8, 1+2+4+64, gs_fill_pen, gs_back_pen,
						0, -xNosing, 1,
						flightWidth, -xNosing, 1,
						flightWidth, (NumStline+1)*treadDepth-xNosing, 1,
						6/10*flightWidth,(NumStline+1)*treadDepth-xNosing-ZigZag1Y, 1,
						6/10*flightWidth,(NumStline-1)*treadDepth-xNosing+ZigZag1Y, 1,
						4/10*flightWidth,(NumStline+1)*treadDepth-xNosing-ZigZag1Y, 1,
						4/10*flightWidth,(NumStline-1)*treadDepth-xNosing+ZigZag1Y, 1,
						0, (NumStline-1)*treadDepth-xNosing, 1
			else
				if breakline_style_m = 3 then
					! ---------- Zig Zag CHI ----------
					POLY2_b 9, 1+2+64, gs_fill_pen, gs_back_pen,
							0, -xNosing, 1,
							flightWidth, -xNosing, 1,
							flightWidth, (NumStline+1)*treadDepth-xNosing, 1,
							6/10*flightWidth,(NumStline+1)*treadDepth-xNosing-ZigZag1Y, 1,
							6/10*flightWidth,(NumStline-1)*treadDepth-xNosing+ZigZag1Y, 1,
							4/10*flightWidth,(NumStline+1)*treadDepth-xNosing-ZigZag1Y+breakLineWidth, 1,
							4/10*flightWidth,(NumStline-1)*treadDepth-xNosing+ZigZag1Y, 1,
							0, (NumStline-1)*treadDepth-xNosing, 1,
							0, -xNosing, -1
				else
					! ---------- Straight ----------
					POLY2_b 4, 1+2+4+64, gs_fill_pen, gs_back_pen,
							0, -xNosing, 1,
							flightWidth, -xNosing, 1,
							flightWidth, (NumStline+1)*treadDepth-xNosing, 1,
							0, (NumStline-1)*treadDepth-xNosing, 1
				endif
			endif


			HOTSPOT2 flightWidth/2,(NumStline)*treadDepth-xNosing, FlightUNID: FlightUNID=FlightUNID+1
			HOTSPOT2 0,			(NumStline-1)*treadDepth-xNosing, FlightUNID: FlightUNID=FlightUNID+1
			HOTSPOT2 flightWidth,	(NumStline+1)*treadDepth-xNosing, FlightUNID: FlightUNID=FlightUNID+1

			HOTLINE2 0, -xNosing, flightWidth, -xNosing
			HOTLINE2 flightWidth, -xNosing, flightWidth, (NumStline+1)*treadDepth-xNosing
			HOTLINE2 flightWidth, (NumStline+1)*treadDepth-xNosing,0, (NumStline-1)*treadDepth-xNosing
			HOTLINE2 0, (NumStline-1)*treadDepth-xNosing,0, -xNosing
		ENDIF

		IF drawPart[2] THEN
			if aboveStory then
				PEN gs_LinePenStUp
				LINE_TYPE gs_LineTypeStUp
			else
				if drawDashed[2] then
					PEN gs_DashLinePen
					LINE_TYPE dash_line
				else
					PEN gs_cont_pen
					LINE_TYPE solid_line
				endif
			endif

			if iFlight = 2 then	mask = 0 else mask = 1
			xNosing = nosing * drawDetails[2]


			! ---------- Contour of Landing ----------
			if iFlight = 1 then
				POLY2_b 5, 1+2*bBackgroundFill+4+64, gs_fill_pen, gs_back_pen,
						flightWidth, (RNU_temp)*treadDepth-xNosing, 1,
						flightWidth, (RNU_temp)*treadDepth, 0,
						flightWidth, (RNU_temp)*treadDepth+flightWidth, 1,
						0, (RNU_temp)*treadDepth+flightWidth, 1,
						0, (RNU_temp)*treadDepth-xNosing, 0

				HOTLINE2 flightWidth, (RNU_temp)*treadDepth-xNosing,flightWidth, (RNU_temp)*treadDepth+flightWidth
				HOTLINE2 flightWidth, (RNU_temp)*treadDepth+flightWidth,0, (RNU_temp)*treadDepth+flightWidth
				HOTLINE2 0, (RNU_temp)*treadDepth+flightWidth,0, (RNU_temp)*treadDepth-xNosing
				HOTLINE2 0, (RNU_temp)*treadDepth-xNosing,flightWidth, (RNU_temp)*treadDepth-xNosing
			endif

			if breakline_style_m = 2 then
				! ---------- Zig Zag ----------
				POLY2_b 8, 1+2*bBackgroundFill+4+64, gs_fill_pen, gs_back_pen,
						0, (NumStline-1)*treadDepth-xNosing+ breakLineWidth, 1,
						7/20*flightWidth, (NumStline-1)*treadDepth -xNosing+ breakLineWidth +ZigZag2Y, 1,
						7/20*flightWidth, (NumStline-1)*treadDepth -xNosing+ breakLineWidth +ZigZag2Y+2*(treadDepth-ZigZag1Y), 1,
						11/20*flightWidth, (NumStline-1)*treadDepth -xNosing+ breakLineWidth +ZigZag2Y, 1,
						11/20*flightWidth, (NumStline-1)*treadDepth -xNosing+ breakLineWidth +ZigZag2Y+2*(treadDepth-ZigZag1Y), 1,
						flightWidth, (NumStline+1)*treadDepth-xNosing+ breakLineWidth, 1,
						flightWidth, (RNU_temp)*treadDepth-xNosing*mask, 1,
						0, (RNU_temp)*treadDepth-xNosing*mask, 1
			else
				if breakline_style_m = 3 then
					! ---------- Zig Zag CHI ----------
					POLY2_b 8, 1+2*bBackgroundFill+4+64, gs_fill_pen, gs_back_pen,
							0, (NumStline-1)*treadDepth-xNosing+ breakLineWidth, 1,
							4/10*flightWidth, (NumStline-1)*treadDepth -xNosing+ breakLineWidth +ZigZag2Y, 1,
							4/10*flightWidth, (NumStline+1)*treadDepth-xNosing-ZigZag1Y+breakLineWidth, 1,
							6/10*flightWidth, (NumStline-1)*treadDepth-xNosing+ZigZag1Y, 1,
							6/10*flightWidth, (NumStline-1)*treadDepth -xNosing+ breakLineWidth +ZigZag2Y+2*(treadDepth-ZigZag1Y), 1,
							flightWidth, (NumStline+1)*treadDepth-xNosing+ breakLineWidth, 1,
							flightWidth, (RNU_temp)*treadDepth-xNosing*mask, 1,
							0, (RNU_temp)*treadDepth-xNosing*mask, 1
				else
					! ---------- Straight ----------
					POLY2_b 4, 1+2*bBackgroundFill+4+64, gs_fill_pen, gs_back_pen,
							0, (NumStline-1)*treadDepth-xNosing+breakLineWidth, 1,
							flightWidth, (NumStline+1)*treadDepth-xNosing+breakLineWidth, 1,
							flightWidth, (RNU_temp)*treadDepth-xNosing*mask, 1,
							0, (RNU_temp)*treadDepth-xNosing*mask, 1
				endif
			endif

			HOTLINE2 0, (NumStline-1)*treadDepth-xNosing+breakLineWidth, flightWidth, (NumStline+1)*treadDepth-xNosing+breakLineWidth
			HOTLINE2 flightWidth, (NumStline+1)*treadDepth-xNosing+breakLineWidth,flightWidth, (RNU_temp)*treadDepth-xNosing*mask
			HOTLINE2 flightWidth, (RNU_temp)*treadDepth-xNosing*mask,0, (RNU_temp)*treadDepth-xNosing*mask
			HOTLINE2 0, (RNU_temp)*treadDepth-xNosing*mask,0, (NumStline-1)*treadDepth-xNosing+breakLineWidth

			! BREAK LINE
			HOTSPOT2 flightWidth/2,		(NumStline)*treadDepth-xNosing,					FlightUNID, breakLineWidth, 1+128	: FlightUNID=FlightUNID+1
			HOTSPOT2 flightWidth/2,		(NumStline)*treadDepth-xNosing-1,				FlightUNID, breakLineWidth, 3		: FlightUNID=FlightUNID+1
			HOTSPOT2 flightWidth/2,		(NumStline)*treadDepth-xNosing+breakLineWidth,	FlightUNID, breakLineWidth, 2		: FlightUNID=FlightUNID+1

			HOTSPOT2 0, (NumStline-1)*treadDepth-xNosing+breakLineWidth,				FlightUNID: FlightUNID=FlightUNID+1
			HOTSPOT2 flightWidth, (NumStline+1)*treadDepth-xNosing+breakLineWidth,	FlightUNID: FlightUNID=FlightUNID+1
		endif
	endif

	! ==========================================================================
	! TREADS
	! ==========================================================================
	DRAWINDEX 20

	if not(drawBreakLine) then
		if (iFlight = 1 & drawPart[1] & drawSteps[1]) | \
			(iFlight = 2 & drawPart[2] & drawSteps[2]) | \
			(drawPart[3] & drawSteps[3])  then

			if aboveStory then
				PEN gs_LinePenStUp
				LINE_TYPE gs_LineTypeStUp
			else
				if drawDashed[iFlight] | drawDashed[3] then
					PEN gs_DashLinePen
					LINE_TYPE dash_line
				else
					PEN gs_cont_pen
					LINE_TYPE solid_line
				endif
			endif

			FOR numTread = 1 to RNU_temp
				LINE2 0,-xNosing, flightWidth, -xNosing
				HOTLINE2 0,-xNosing, flightWidth, -xNosing
				ADD2 0,treadDepth
			NEXT numTread
			DEL RNU_temp

			IF drawDetails[iFlight] | drawDetails[3] THEN
				PEN gs_DashLinePen
				LINE_TYPE dash_line

				FOR numTread = 1 to RNU_temp+mask
					LINE2 0, 0, flightWidth, 0
					HOTLINE2 0, 0, flightWidth, 0
					ADD2 0,treadDepth
				NEXT numTread
				DEL numTread -1
			endif
		endif
	else
		if drawPart[1] & drawSteps[1] then

			xNosing = nosing * drawDetails[1]


			FOR numTread = 1 to NumStline+1
				if aboveStory then
					PEN gs_LinePenStUp
					LINE_TYPE gs_LineTypeStUp
				else
					if drawDashed[1] then
						PEN gs_DashLinePen
						LINE_TYPE dash_line
					else
						PEN gs_cont_pen
						LINE_TYPE solid_line
					endif
				endif

				StartSolid = 0
				IF breakline_style_m = 1 THEN
					IF numTread=NumStline THEN StartSolid=flightWidth/2
				ELSE
					IF numTread=NumStline THEN StartSolid=flightWidth*6/10
				ENDIF

				IF numTread<=NumStline THEN
					LINE2 StartSolid,treadDepth-xNosing, flightWidth, treadDepth-xNosing
					HOTLINE2 StartSolid,treadDepth-xNosing, flightWidth, treadDepth-xNosing
				ENDIF

				if drawDetails[1] THEN
					PEN gs_DashLinePen
					LINE_TYPE dash_line

					StartDashed=0
					if breakline_style_m = 1 then	! Straight
						IF ABS(numTread-NumStline-1)<0.001 THEN StartDashed=flightWidth/2+xNosing/tan(bet)
					ELSE
						IF distZigZag >= 4/10*flightWidth THEN
							distZigZag = 4/10*flightWidth
						ELSE
							distZigZag=(flightWidth*(treadDepth-xNosing))/(2*treadDepth)
						ENDIF

						IF numTread=NumStline+1 THEN StartDashed=max(0,leftRailOffset+leftRailFrameThk,flightWidth-distZigZag)
					ENDIF

					IF ABS(numTread-(NumStline))<0.01 THEN StartDashed=max(0,xNosing/tan(bet))

					LINE2 StartDashed,0,flightWidth,0
					HOTLINE2 StartDashed,0,flightWidth,0
				ENDIF
				ADD2 0,treadDepth
			NEXT numTread
			DEL numTread-1
		endif

		IF drawPart[2] & drawSteps[2] THEN

			xNosing = nosing * drawDetails[2]

			ADD2 0,(NumStline)*treadDepth
			FOR numTread = 1 to RNU_temp-NumStline+mask
				if aboveStory then
					PEN gs_LinePenStUp
					LINE_TYPE gs_LineTypeStUp
				else
					if drawDashed[2] then
						PEN gs_DashLinePen
						LINE_TYPE dash_line
					else
						PEN gs_cont_pen
						LINE_TYPE solid_line
					endif
				endif

				EndSolid=flightWidth
				if breakline_style_m = 1 then	! Straight
					IF numTread=1 THEN EndSolid=Min(flightWidth,(treadDepth-breakLineWidth)/tan(bet))
					IF numTread=2 THEN EndSolid=Min(flightWidth,(2*treadDepth-breakLineWidth)/tan(bet))
				else
					if breakline_style_m = 3 then	! Zigzag CHI
						ZigZagCorrection = 4/10
					else
						ZigZagCorrection = 7/20
					endif
					IF numTread=1 THEN EndSolid=Min(ZigZagCorrection*flightWidth,(treadDepth-breakLineWidth)/tan(bet))
					IF numTread=2 THEN
						IF ZigZag2Y+2*(treadDepth-ZigZag1Y)<2*treadDepth-breakLineWidth-xNosing THEN EndSolid=Min(flightWidth,(2*treadDepth-breakLineWidth)/tan(bet))
						IF ZigZag2Y+2*(treadDepth-ZigZag1Y)>=2*treadDepth-breakLineWidth-xNosing THEN EndSolid=Min(flightWidth,ZigZagCorrection*flightWidth)
					ENDIF
				ENDIF

				LINE2 0,-xNosing,EndSolid,-xNosing
				HOTLINE2 0,-xNosing,EndSolid,-xNosing

				IF drawDetails[2] THEN
					PEN gs_DashLinePen
					LINE_TYPE dash_line

					EndDashed=flightWidth
					if breakline_style_m = 1 then	! Straight
						IF numTread=1 THEN EndDashed=Min(flightWidth,(treadDepth-breakLineWidth+xNosing)/tan(bet))
						IF numTread=2 THEN EndDashed=Min(flightWidth,(2*treadDepth-breakLineWidth+xNosing)/tan(bet))
					ELSE
						IF distZigZag <= ZigZagCorrection*flightWidth THEN
							distZigZag = ZigZagCorrection*flightWidth
						ELSE
							distZigZag=(flightWidth*(treadDepth/2+xNosing))/(2*treadDepth)
						ENDIF

						IF numTread=1 THEN EndDashed=Min(ZigZagCorrection*flightWidth,(treadDepth-breakLineWidth+xNosing)/tan(bet))
						IF numTread=2 THEN
							IF ZigZag2Y+2*(treadDepth-ZigZag1Y)<2*treadDepth+xNosing-breakLineWidth THEN EndDashed=Min(flightWidth,(2*treadDepth+xNosing-breakLineWidth)/tan(bet))
							IF ZigZag2Y+2*(treadDepth-ZigZag1Y)>=2*treadDepth+xNosing-breakLineWidth THEN EndDashed=Min(flightWidth,ZigZagCorrection*flightWidth)
						ENDIF
					ENDIF

					LINE2 0,0,EndDashed,0
					HOTLINE2 0,0,EndDashed,0
				ENDIF

				ADD2 0,treadDepth
			NEXT numTread
			DEL numTread-1
			DEL 1
		endif
	endif

	! ==========================================================================
	! WALKING LINE / ARROWHEAD / START END SYMBOL
	! ==========================================================================
	reverseWalkline = 0
	if walkingDirUPDN_m = 3 | walkingDirUPDN_m = 4 | (walkingDirUPDN_m = 6 & abovestory) then
		reverseWalkline = 1
	endif

	if bShowWalkLine & not(belowStory) then

		PEN gs_wLinePen
		FILL gs_ArrowFill

		for i = 1 to 3
			DRAWINDEX 40
			drawWalkLine = 1
			if not(bShowWalkLineAboveBreakline) & i = 2 then drawWalkLine = 0

			if drawPart[i] & drawWalkLine then
				xNosing = nosing * drawDetails[i]
				startLine = -xNosing
				endLine = (RNU_temp)*treadDepth
				penFillArrow = gs_ArrowFillPen
				if i = 1 then
					if drawBreakline then
						endLine = (NumStline)*treadDepth-xNosing
					else
						if iFlight = 1 then
							endLine = (RNU_temp)*treadDepth
						else
							drawWalkLine = 0
						endif
					endif
				endif
				if i = 2 then
					if drawBreakline then
						startLine = startLine + (NumStline)*treadDepth+breakLineWidth
					else
						if iFlight = 1 then
							drawWalkLine = 0
						else
							endLine = (RNU_temp)*treadDepth
						endif
					endif
					penFillArrow = gs_ArrowFillPenAbove
					if walkingDirUPDN_m = 5 then reverseWalkline = 1
				endif

				if aboveStory then
					LINE_TYPE gs_wLineTypeStUp
				else
					if (drawDashed[i]) then
						LINE_TYPE gs_wLineTypeAbove
					else
						LINE_TYPE gs_wLineType1
					endif
				endif

				IF i = 3 & walkingDirUPDN_m = 5 THEN
					if iFlight = 1 then
					! Up Down Both - UP
					endLine = endLine -(MAX(1, INT(RNU_temp/3)))*treadDepth + startLine
					ADD2 flightWidth/2, endLine
					GOSUB "Arrowhead Symbol"
					DEL 1
					endLine = endLine-lengthArrowHead

					line2 flightWidth/2, startLine, flightWidth/2, endLine

					ADD2 flightWidth/2, startLine
					GOSUB "Start End Symbol"
					DEL 1
					endif

					if iFlight = 2 then
					! Up Down Both - Down
					endLine = (RNU_temp)*treadDepth
					startLine = startLine+(MAX(1, INT(RNU_temp/3)))*treadDepth
					ADD2 flightWidth/2, startLine
					MUL2 1, -1
					GOSUB "Arrowhead Symbol"
					DEL 2
					startLine = startLine+lengthArrowHead

					ADD2 flightWidth/2, endLine
					GOSUB "Start End Symbol"
					DEL 1
					endif
				else

					! Arrow Head below Break Line
					if not(reverseWalkline)	& (((i=3|i=2) & iFlight=2) | (i=1 & drawBreakLine)) then
						ADD2 flightWidth/2, endLine
						GOSUB "Arrowhead Symbol"
						DEL 1
						endLine = endLine-lengthArrowHead
					endif

					if not(reverseWalkline) & ((i=3|i=1) & iFlight=1) then
						ADD2 flightWidth/2, startLine
						GOSUB "Start End Symbol"
						DEL 1
					endif

					! Arrow Head on Start
					if reverseWalkline & (((i=3|i=1) & iFlight=1) | (i=2 & drawBreakLine))then
						ADD2 flightWidth/2, startLine
						MUL2 1, -1
						GOSUB "Arrowhead Symbol"
						DEL 2
						startLine = startLine+lengthArrowHead
					endif

					if reverseWalkline & ((i=3|i=2) & iFlight=2) then
						ADD2 flightWidth/2, endLine
						GOSUB "Start End Symbol"
						DEL 1
					endif
				endif

				! Walking Line
				if drawWalkLine then line2 flightWidth/2, startLine, flightWidth/2, endLine
			endif
		next i

		if drawBreakLine then
			HOTSPOT2 flightWidth/2,(NumStline)*treadDepth-xNosing,					FlightUNID,breakLineWidth,1+128		:FlightUNID=FlightUNID+1
			HOTSPOT2 flightWidth/2,(NumStline)*treadDepth-0.1-xNosing,				FlightUNID,breakLineWidth,3			:FlightUNID=FlightUNID+1
			HOTSPOT2 flightWidth/2,(NumStline)*treadDepth+breakLineWidth-xNosing,	FlightUNID,breakLineWidth,2			:FlightUNID=FlightUNID+1
		endif

		if 	(iFlight = 1 & ((not(hasBreak1st) & drawPart[1]) | (hasBreak1st & drawPart[2] & bShowWalkLineAboveBreakline) | (drawPart[3] & (walkingDirUPDN_m <> 5) ))) then
			if aboveStory then
				LINE_TYPE gs_wLineTypeStUp
			else
			if 	(iFlight = 1 & ((not(hasBreak1st) & drawDashed[1]) | (hasBreak1st & drawDashed[2]) | (drawDashed[3] & (walkingDirUPDN_m <> 5) ))) then
					LINE_TYPE gs_wLineTypeAbove
				else
					LINE_TYPE gs_wLineType1
				endif
			endif
			LINE2 flightWidth/2,(RNU_temp)*treadDepth,flightWidth/2,(RNU_temp)*treadDepth+flightWidth/2
			LINE2 flightWidth/2,(RNU_temp)*treadDepth+flightWidth/2,flightWidth,(RNU_temp)*treadDepth+flightWidth/2
		ENDIF
	ENDIF

	DRAWINDEX 10
	ADD2 flightWidth,RNU_temp*treadDepth+flightWidth
	ROT2 -90
NEXT iFlight
DEL 2*2


!===============================================================================
! --- Carriage Line ---
!===============================================================================

if bCarriageLineExist & not(belowStory) then
	fill gs_fill_type

	bShowCarriagePart1	= 0
	bShowCarriagePart2	= 0

	beamNum				= 2
	beamThk				= woodBaseThk
	beamOffsetRight		= woodBaseOffset
	beamOffsetLeft		= woodBaseOffset
	carriageBaseDist	= flightWidth
	carrBreakLineWidth	= breakLineWidth

	if drawPart[3] then
		!!!!!******************************      1st RUN + LANDING 1.
		add2 0, bRiserCover * riserCoverThk
			beamLength			= (nRisers1stRun - 1) * treadDepth + flightWidth - bRiserCover * riserCoverThk
			bCarrAboveBreakLine	= 0
			bBreakCarriageLine	= 0
			gosub "carriage"
		del 1

		!!!!!******************************      2nd RUN
		add2 flightWidth - woodBaseOffset, flightWidth + (nRisers1stRun - 1) * treadDepth
		rot2 -90
			beamLength			= nRisers2ndRun*treadDepth + woodBaseOffset
			bCarrAboveBreakLine	= 0
			bBreakCarriageLine	= 0
			gosub "carriage"
		del 2
	else
		if hasBreak1st then
			if drawPart[1] then
				!!!!!******************************      1st RUN + LANDING 1.
				add2 0, bRiserCover * riserCoverThk
					beamLength			= (nRisers1stRun - 1) * treadDepth + flightWidth - bRiserCover * riserCoverThk
					bCarrAboveBreakLine	= 0
					bBreakCarriageLine	= 1
					bShowCarriagePart1	= 1
					bShowCarriagePart2	= 0
					brLineAngle			= bet
					xNosing				= nosing * drawDetails[1]
					carrBreakLineDist	= NumStline * treadDepth - xNosing + (flightWidth / 2 - woodBaseOffset - woodBaseThk / 2) * tan(brLineAngle) - bRiserCover * riserCoverThk
					gosub "carriage"
				del 1
			endif

			if drawPart[2] then
				!!!!!******************************      1st RUN + LANDING 1.
				add2 0, bRiserCover * riserCoverThk
					beamLength			= (nRisers1stRun - 1) * treadDepth + flightWidth - bRiserCover * riserCoverThk
					bCarrAboveBreakLine	= 1
					bBreakCarriageLine	= 1
					bShowCarriagePart1	= 0
					bShowCarriagePart2	= 1
					brLineAngle			= bet
					xNosing				= nosing * drawDetails[2]
					carrBreakLineDist	= NumStline * treadDepth - xNosing + (flightWidth / 2 - woodBaseOffset - woodBaseThk / 2) * tan(brLineAngle) - bRiserCover * riserCoverThk
					gosub "carriage"
				del 1

				!!!!!******************************      2nd RUN
				add2 flightWidth - woodBaseOffset, flightWidth + (nRisers1stRun - 1) * treadDepth
				rot2 -90
					beamLength			= nRisers2ndRun*treadDepth + woodBaseOffset
					bCarrAboveBreakLine	= 1
					bBreakCarriageLine	= 0
					gosub "carriage"
				del 2
			endif
		else
			if drawPart[1] then
				!!!!!******************************      1st RUN + LANDING 1.
				add2 0, bRiserCover * riserCoverThk
					beamLength			= (nRisers1stRun - 1) * treadDepth + flightWidth - bRiserCover * riserCoverThk
					bCarrAboveBreakLine	= 0
					bBreakCarriageLine	= 0
					gosub "carriage"
				del 1

				!!!!!******************************      2nd RUN
				add2 flightWidth - woodBaseOffset, flightWidth + (nRisers1stRun - 1) * treadDepth
				rot2 -90
					beamLength			= nRisers2ndRun*treadDepth + woodBaseOffset
					bCarrAboveBreakLine	= 0
					bBreakCarriageLine	= 1
					bShowCarriagePart1	= 1
					bShowCarriagePart2	= 0
					brLineAngle			= bet
					xNosing				= nosing * drawDetails[1]
					carrBreakLineDist	= treadDepth + (NumStline - 1) * treadDepth - xNosing + (flightWidth / 2 - beamOffsetRight - beamThk / 2) * tan(brLineAngle) + woodBaseOffset
					gosub "carriage"
				del 2
			endif

			if drawPart[2] then
				!!!!!******************************      2nd RUN
				add2 flightWidth - woodBaseOffset, flightWidth + (nRisers1stRun - 1) * treadDepth
				rot2 -90
					beamLength			= nRisers2ndRun*treadDepth + woodBaseOffset
					bCarrAboveBreakLine	= 1
					bBreakCarriageLine	= 1
					bShowCarriagePart1	= 0
					bShowCarriagePart2	= 1
					brLineAngle			= bet
					xNosing				= nosing * drawDetails[2]
					carrBreakLineDist	= treadDepth + (NumStline - 1) * treadDepth - xNosing + (flightWidth / 2 - beamOffsetRight - beamThk / 2) * tan(brLineAngle) + woodBaseOffset
					gosub "carriage"
				del 2
			endif
		endif
	endif
endif

!===============================================================================
! --- Railings ---
!===============================================================================

if _bShowRailIn2D & not(belowStory) then
	bShowRailPart1			= 0
	bShowRailPart2			= 0
	breakLineW				= breakLineWidth
	breakLineDist			= 0
	brLineAngle				= bet

	bShowRailOn1stRun		= 0
	bShowRailOn1stLanding1	= 0
	bShowRailOn1stLanding2	= 0
	bShowRailOn2ndRun		= 0
	bShowRailOn2ndLanding1	= 0
	bShowRailOn2ndLanding2	= 0
	bShowRailOn3rdRun		= 0

	drawindex 30
	fill gs_fill_type

	! --- Left Rail ----------------------------------------------------------------
	if rail_m = 3 | rail_m = 1 then		! Left, Both
		if bSameRails then
			leftRailType_m = rightRailType_m
			leftWireType_m = rightWireType_m
		endif

		if drawPart[3] then
			if bShowRailOnFloorPlan then
				pen railPen
				if aboveStory then
					LINE_TYPE railLineType
				else
					if (drawDashed[3]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE railLineType
					endif
				endif
				xNosing = 0 ! COMP nosing * drawDetails[3]

				if bSymbolic2D then
					bShowRailOn1stRun		= 1
					bShowRailOn1stLanding1	= 1
					bShowRailOn1stLanding2	= 1
					bShowRailOn2ndRun		= 1
					bBreakRailLine			= 0
					bRailAboveBreakLine		= 0
					gosub "left rail"
				else
					poly2_b 7, 1+2+64, gs_fill_pen, gs_back_pen,
						leftRailOffset+leftRailFrameThk,						-xNosing -leftRailOvhgBottom,										1,
						leftRailOffset,											-xNosing -leftRailOvhgBottom,										1,
						leftRailOffset,											(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset,	1,
						flightWidth+nRisers2ndRun*treadDepth+leftRailOvhgTop,	(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset,	1,
						flightWidth+nRisers2ndRun*treadDepth+leftRailOvhgTop,	(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk,1,
						leftRailOffset+leftRailFrameThk,						(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk,1,
						leftRailOffset+leftRailFrameThk,						-xNosing -leftRailOvhgBottom,-1
				endif
			endif

			if bShowRailAxis then
				line_type railAxisLineType
				pen gs_RailAxisPen
				line2 leftRailOffset+leftRailFrameThk/2, (nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2,leftRailOffset+leftRailFrameThk/2,-leftRailOvhgBottom
				line2 leftRailOffset+leftRailFrameThk/2, (nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2,flightWidth+nRisers2ndRun*treadDepth+leftRailOvhgTop,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2
			endif
		else		! Break Line - Railing
			if hasBreak1st then
				if drawPart[1] & bShowRailOnFloorPlan then
					pen railPen
					if aboveStory then
						SET LINE_TYPE railLineType
					else
						if (drawDashed[1]) then
							SET LINE_TYPE dash_line
						else
							SET LINE_TYPE railLineType
						endif
					endif
					xNosing =  nosing * drawDetails[1]

					if bSymbolic2D then
						bShowRailOn1stRun		= 1
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn2ndRun		= 0
						bBreakRailLine			= 1
						brLineAngle				= bet
						bShowRailPart1			= 1
						breakLineDist			= leftRailOvhgBottom - xNosing + (NumStline - 1) * treadDepth + (leftRailOffset + leftRailFrameThk) * TAN(bet)
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 0
						gosub "left rail"
					else
						poly2_b 5, 1+2+64, gs_fill_pen, gs_back_pen,
							leftRailOffset,						-leftRailOvhgBottom,1,
							leftRailOffset+leftRailFrameThk,	-leftRailOvhgBottom,1,
							leftRailOffset+leftRailFrameThk,	-xNosing+(NumStline-1)*treadDepth+(leftRailOffset+leftRailFrameThk)*tan(bet),1,
							leftRailOffset,						-xNosing+(NumStline-1)*treadDepth+(leftRailOffset)*tan(bet),1,
							leftRailOffset,						-leftRailOvhgBottom,-1
					endif
				endif

				if drawPart[2] & bShowRailOnFloorPlan and bShowRailAboveBreakLine then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[2]) then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif

					if bSymbolic2D then
						xNosing =  nosing * NOT(drawDetails[2])
						bShowRailOn1stRun		= 1
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn2ndRun		= 0
						bBreakRailLine			= 1
						brLineAngle				= bet
						bShowRailPart2			= 1
						breakLineDist			= leftRailOvhgBottom - nosing + (NumStline - 1) * treadDepth + (leftRailOffset + leftRailFrameThk) * TAN(bet)
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 1
						gosub "left rail"

						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 1
						bShowRailOn1stLanding2	= 1
						bShowRailOn2ndRun		= 1
						bBreakRailLine			= 0
						bRailAboveBreakLine		= 1
						gosub "left rail"
					else
						xNosing = nosing * drawDetails[2]
						poly2_b 7, 1 + 2 * gs_FillAbove+64, gs_fill_pen, gs_back_pen,
							leftRailOffset,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset,1,
							flightWidth+nRisers2ndRun*treadDepth+leftRailOvhgTop,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset,1,
							flightWidth+nRisers2ndRun*treadDepth+leftRailOvhgTop,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk,1,
							leftRailOffset+leftRailFrameThk,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk,1,
							leftRailOffset+leftRailFrameThk,(NumStline-1)*treadDepth+breakLineWidth-xNosing+(leftRailOffset+leftRailFrameThk)*tan(bet),1,
							leftRailOffset,(NumStline-1)*treadDepth+breakLineWidth-xNosing+(leftRailOffset)*tan(bet),1,
							leftRailOffset,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset,-1
					endif
				endif

				if bShowRailAxis then
					line_type railAxisLineType
					pen gs_RailAxisPen

					if drawPart[1] then
						xNosing =  nosing * drawDetails[1]
						line2 leftRailOffset+leftRailFrameThk/2, -xNosing+(NumStline-1)*treadDepth+(leftRailOffset+leftRailFrameThk/2)*tan(bet),leftRailOffset+leftRailFrameThk/2,-leftRailOvhgBottom
					endif

					if drawPart[2] then
						xNosing = nosing * drawDetails[2]
						line2 leftRailOffset+leftRailFrameThk/2, (NumStline-1)*treadDepth-xNosing+breakLineWidth+(leftRailOffset+leftRailFrameThk/2)*tan(bet),leftRailOffset+leftRailFrameThk/2,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2
						line2 leftRailOffset+leftRailFrameThk/2, (nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2,flightWidth+nRisers2ndRun*treadDepth+leftRailOvhgTop,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2
					endif
				endif
			else
				if drawPart[1] & bShowRailOnFloorPlan then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[1]) then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif
					xNosing =  nosing * drawDetails[1]

					if bSymbolic2D then
						bShowRailOn1stRun		= 1
						bShowRailOn1stLanding1	= 1
						bShowRailOn1stLanding2	= 1
						bShowRailOn2ndRun		= 0
						bBreakRailLine			= 0
						bRailAboveBreakLine		= 0
						gosub "left rail"

						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn2ndRun		= 1
						bBreakRailLine			= 1
						brLineAngle				= bet
						bShowRailPart1			= 1
						breakLineDist			= treadDepth - xNosing + (NumStline - 1) * treadDepth + (leftRailOffset + leftRailFrameThk) * TAN(bet)
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 0
						gosub "left rail"
					else
						poly2_b  7, 1+2+4+64, gs_fill_pen, gs_back_pen,
							leftRailOffset+leftRailFrameThk,	-leftRailOvhgBottom,1,
							leftRailOffset,						-leftRailOvhgBottom,1,
							leftRailOffset,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset,1,
							flightWidth+(NumStline-1)*treadDepth-xNosing+leftRailOffset*tan(bet),(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset,1,
							flightWidth+(NumStline-1)*treadDepth-xNosing+(leftRailOffset+leftRailFrameThk)*tan(bet),(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk,1,
							leftRailOffset+leftRailFrameThk,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk,1,
							leftRailOffset+leftRailFrameThk,-leftRailOvhgBottom,-1
					endif
				endif

				if drawPart[2] & bShowRailOnFloorPlan and bShowRailAboveBreakLine then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[2]) then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif

					if bSymbolic2D then
						xNosing = nosing * NOT(drawDetails[2])
						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn2ndRun		= 1
						bBreakRailLine			= 1
						brLineAngle				= bet
						bShowRailPart2			= 1
						breakLineDist			= treadDepth - nosing + (NumStline - 1) * treadDepth + (leftRailOffset + leftRailFrameThk) * TAN(bet)
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 1
						gosub "left rail"
					else
						xNosing = nosing * drawDetails[2]
						poly2_b 5, 1 + 2 * gs_FillAbove+64, gs_fill_pen, gs_back_pen,
							flightWidth+(NumStline-1)*treadDepth-xNosing+leftRailOffset*tan(bet)+breakLineWidth,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset,1,
							flightWidth+(NumStline-1)*treadDepth-xNosing+(leftRailOffset+leftRailFrameThk)*tan(bet)+breakLineWidth,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk,1,
							flightWidth+nRisers2ndRun*treadDepth+leftRailOvhgTop,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk,1,
							flightWidth+nRisers2ndRun*treadDepth+leftRailOvhgTop,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset,1,
							flightWidth+(NumStline-1)*treadDepth-xNosing+leftRailOffset*tan(bet)+breakLineWidth,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset,-1
					endif
				endif

				if bShowRailAxis then
					line_type railAxisLineType
					pen gs_RailAxisPen
					if drawPart[1] then
						xNosing = nosing * drawDetails[1]
						line2 leftRailOffset+leftRailFrameThk/2, (nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2,leftRailOffset+leftRailFrameThk/2,-leftRailOvhgBottom
						line2 leftRailOffset+leftRailFrameThk/2, (nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2,\
								flightWidth+(NumStline-1)*treadDepth-xNosing+(leftRailOffset+leftRailFrameThk/2)*tan(bet), (nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2
					endif

					if drawPart[2] then
						xNosing = nosing * drawDetails[2]
						line2 flightWidth+nRisers2ndRun*treadDepth+leftRailOvhgTop, (nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2,\
							flightWidth+(NumStline-1)*treadDepth-xNosing+(leftRailOffset+leftRailFrameThk/2)*tan(bet)+breakLineWidth, (nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2
					endif
				endif
			endif
		endif
	endif

	! --- Right Rail ---------------------------------------------------------------
	pen gs_cont_pen
	if rail_m = 2 | rail_m = 1 then		! Right, Both
		if drawPart[3] then
			if bShowRailOnFloorPlan then
				pen railPen
				if aboveStory then
					LINE_TYPE railLineType
				else
					if (drawDashed[3]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE railLineType
					endif
				endif
				xNosing =  0 ! COMP nosing * drawDetails[3]

				if bSymbolic2D then
					bShowRailOn1stRun		= 1
					bShowRailOn1stLanding1	= 1
					bShowRailOn1stLanding2	= 1
					bShowRailOn2ndRun		= 1
					bBreakRailLine			= 0
					bRailAboveBreakLine		= 0
					gosub "right rail"
				else
					poly2_b 7, 1+2+64, gs_fill_pen, gs_back_pen,
						flightWidth-rightRailOffset,	-xNosing -rightRailOvhgBottom,1,
						flightWidth-rightRailOffset-rightRailFrameThk,-xNosing -rightRailOvhgBottom,1,
						flightWidth-rightRailOffset-rightRailFrameThk,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk,1,
						flightWidth+nRisers2ndRun*treadDepth+rightRailOvhgTop,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk,1,
						flightWidth+nRisers2ndRun*treadDepth+rightRailOvhgTop,(nRisers1stRun-1)*treadDepth+rightRailOffset,1,
						flightWidth-rightRailOffset,(nRisers1stRun-1)*treadDepth+rightRailOffset,1,
						flightWidth-rightRailOffset,-xNosing -rightRailOvhgBottom,-1
				endif
			endif

			if bShowRailAxis then
				line_type railAxisLineType
				pen gs_RailAxisPen
				line2 flightWidth-rightRailOffset-rightRailFrameThk/2, (nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2,flightWidth-rightRailOffset-rightRailFrameThk/2,-rightRailOvhgBottom
				line2 flightWidth+nRisers2ndRun*treadDepth+rightRailOvhgTop, (nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2,flightWidth-rightRailOffset-rightRailFrameThk/2,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2
			endif
		else
			if hasBreak1st then
				if drawPart[1] & bShowRailOnFloorPlan then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[1]) then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif
					xNosing = nosing * drawDetails[1]

					if bSymbolic2D then
						bShowRailOn1stRun		= 1
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn2ndRun		= 0
						bBreakRailLine			= 1
						brLineAngle				= bet
						bShowRailPart1			= 1
						breakLineDist			= rightRailOvhgBottom - xNosing + (NumStline + 1) * treadDepth - rightRailOffset * TAN(bet)
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 0
						gosub "right rail"
					else
						poly2_b 5, 1+2+64, gs_fill_pen, gs_back_pen,
							flightWidth-rightRailOffset,					-rightRailOvhgBottom,1,
							flightWidth-rightRailOffset-rightRailFrameThk,	-rightRailOvhgBottom,1,
							flightWidth-rightRailOffset-rightRailFrameThk,	-xNosing+(NumStline+1)*treadDepth-(rightRailOffset+rightRailFrameThk)*tan(bet),1,
							flightWidth-rightRailOffset,					-xNosing+(NumStline+1)*treadDepth-(rightRailOffset)*tan(bet),1,
							flightWidth-rightRailOffset,					-rightRailOvhgBottom,-1
					endif
				endif

				if drawPart[2] & bShowRailOnFloorPlan and bShowRailAboveBreakLine then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[2]) then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif

					if bSymbolic2D then
						xNosing = nosing * NOT(drawDetails[2])
						bShowRailOn1stRun		= 1
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn2ndRun		= 0
						bBreakRailLine			= 1
						brLineAngle				= bet
						bShowRailPart2			= 1
						breakLineDist			= rightRailOvhgBottom - nosing + (NumStline + 1) * treadDepth - rightRailOffset * TAN(bet)
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 1
						gosub "right rail"

						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 1
						bShowRailOn1stLanding2	= 1
						bShowRailOn2ndRun		= 1
						bBreakRailLine			= 0
						bRailAboveBreakLine		= 1
						gosub "right rail"
					else
						xNosing = nosing * drawDetails[2]
						poly2_b 7, 1 + 2 * gs_FillAbove+64, gs_fill_pen, gs_back_pen,
							flightWidth-rightRailOffset,(nRisers1stRun-1)*treadDepth+rightRailOffset,1,
							flightWidth+nRisers2ndRun*treadDepth+rightRailOvhgTop,(nRisers1stRun-1)*treadDepth+rightRailOffset,1,
							flightWidth+nRisers2ndRun*treadDepth+rightRailOvhgTop,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk,1,
							flightWidth-rightRailOffset-rightRailFrameThk,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk,1,
							flightWidth-rightRailOffset-rightRailFrameThk,(NumStline+1)*treadDepth-xNosing+breakLineWidth-(rightRailOffset+rightRailFrameThk)*tan(bet),1,
							flightWidth-rightRailOffset,(NumStline+1)*treadDepth-xNosing+breakLineWidth-(rightRailOffset)*tan(bet),1,
							flightWidth-rightRailOffset,(nRisers1stRun-1)*treadDepth+rightRailOffset,-1
					endif
				endif

				if bShowRailAxis then
					line_type railAxisLineType
					pen gs_RailAxisPen
					if drawPart[1] then
						xNosing = nosing * drawDetails[1]

						line2 flightWidth-rightRailOffset-rightRailFrameThk/2, -xNosing + (NumStline+1)*treadDepth-(rightRailOffset+rightRailFrameThk/2)*tan(bet),flightWidth-rightRailOffset-rightRailFrameThk/2,-rightRailOvhgBottom
					endif
					if drawPart[2] then
						xNosing = nosing * drawDetails[2]
						line2 flightWidth-rightRailOffset-rightRailFrameThk/2, (NumStline+1)*treadDepth-xNosing+breakLineWidth-(rightRailOffset+rightRailFrameThk/2)*tan(bet),\
							flightWidth-rightRailOffset-rightRailFrameThk/2,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2
						line2 flightWidth+nRisers2ndRun*treadDepth+rightRailOvhgTop, (nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2,flightWidth-rightRailOffset-rightRailFrameThk/2,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2
					endif
				endif
			else
				if drawPart[1] & bShowRailOnFloorPlan then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[1]) then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif
					xNosing = nosing * drawDetails[1]

					if bSymbolic2D then
						bShowRailOn1stRun		= 1
						bShowRailOn1stLanding1	= 1
						bShowRailOn1stLanding2	= 1
						bShowRailOn2ndRun		= 0
						bBreakRailLine			= 0
						bRailAboveBreakLine		= 0
						gosub "right rail"

						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn2ndRun		= 1
						bBreakRailLine			= 1
						brLineAngle				= bet
						bShowRailPart1			= 1
						breakLineDist			= min(rightRailOffset,treadDepth) - xNosing + (NumStline + 1) * treadDepth - (rightRailOffset) * TAN(bet)
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 0
						gosub "right rail"
					else
						poly2_b 7, 1+2+4+64, gs_fill_pen, gs_back_pen,
							flightWidth-rightRailOffset,					-rightRailOvhgBottom,1,
							flightWidth-rightRailOffset-rightRailFrameThk,	-rightRailOvhgBottom,1,
							flightWidth-rightRailOffset-rightRailFrameThk,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk,1,
							flightWidth+(NumStline+1)*treadDepth-xNosing-(rightRailOffset+rightRailFrameThk)*tan(bet),(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk,1,
							flightWidth+(NumStline+1)*treadDepth-xNosing-(rightRailOffset)*tan(bet),(nRisers1stRun-1)*treadDepth+rightRailOffset,1,
							flightWidth-rightRailOffset,(nRisers1stRun-1)*treadDepth+rightRailOffset,1,
							flightWidth-rightRailOffset,-rightRailOvhgBottom,-1
					endif
				endif

				if drawPart[2] & bShowRailOnFloorPlan and bShowRailAboveBreakLine then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[2]) then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif

					if bSymbolic2D then
						xNosing = nosing * NOT(drawDetails[2])
						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn2ndRun		= 1
						bBreakRailLine			= 1
						brLineAngle				= bet
						bShowRailPart2			= 1
						breakLineDist			= min(rightRailOffset,treadDepth) - nosing + (NumStline + 1) * treadDepth - (rightRailOffset) * TAN(bet)
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 1
						gosub "right rail"
					else
						xNosing = nosing * drawDetails[2]
						poly2_b 5, 1+2*gs_FillAbove+64, gs_fill_pen, gs_back_pen,
							flightWidth+(NumStline+1)*treadDepth-xNosing-(rightRailOffset+rightRailFrameThk)*tan(bet)+breakLineWidth,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk,1,
							flightWidth+(NumStline+1)*treadDepth-xNosing-(rightRailOffset)*tan(bet)+breakLineWidth,(nRisers1stRun-1)*treadDepth+rightRailOffset,1,
							flightWidth+nRisers2ndRun*treadDepth+rightRailOvhgTop,(nRisers1stRun-1)*treadDepth+rightRailOffset,1,
							flightWidth+nRisers2ndRun*treadDepth+rightRailOvhgTop,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk,1,
							flightWidth+(NumStline+1)*treadDepth-xNosing-(rightRailOffset+rightRailFrameThk)*tan(bet)+breakLineWidth,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk,-1
					endif
				endif

				if bShowRailAxis then
					line_type railAxisLineType
					pen gs_RailAxisPen
					if drawPart[1] then
						xNosing = nosing * drawDetails[1]
						line2 flightWidth-rightRailOffset-rightRailFrameThk/2, (nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2,flightWidth-rightRailOffset-rightRailFrameThk/2,-rightRailOvhgBottom
						line2 flightWidth-rightRailOffset-rightRailFrameThk/2, (nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2,\
								flightWidth+(NumStline+1)*treadDepth-xNosing-(rightRailOffset+rightRailFrameThk/2)*tan(bet), (nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2
					endif
					if drawPart[2] then
						xNosing = nosing * drawDetails[2]
						line2 flightWidth+(NumStline+1)*treadDepth-xNosing-(rightRailOffset+rightRailFrameThk/2)*tan(bet)+breakLineWidth, \
								(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2,flightWidth+nRisers2ndRun*treadDepth+rightRailOvhgTop, (nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2
					endif
				endif
			endif
		endif
	endif
endif


! ==============================================================================
! Text / Up - Down Text / Numbering
! ==============================================================================

! --- Oriented View ------------------------------------------------------------
angleViewRot = 0
if bShowRiseAndRunText | walkingDirUPDN_m <> 1 | drawNum | gs_description <> "" then
	rrr = REQUEST ("View_Rotangle", "", angleViewRot)
endif
totalRotate = (SYMB_ROTANGLE + angleViewRot) MOD 360


! --- Define Font Style --------------------------------------------------------

define style "UPDN" fontType, UPDNfontsize, 5, 0		  	! UP/DN

define style "stepnum" fontType, gs_NumTextSize, 1, 0		! Numbering

define style "description" fontType, gs_desc_text_size, 4, 0	! Description

! --- Rise & Run Text -------------------------------------------------------

if bShowRiseAndRunText & bShowWalkLine & not(belowStory) then
	call "Stair_RiseRun_Text" PARAMETERS ALL	totalRotate	= totalRotate,
												iRotateType = 1,
												iRiseRunTextPosition = 1,
												RiseRunUNID	= RiseRunUNID
endif


! --- Up & Down Text ---------------------------------------------------------
iReadable = 0
if walkingDirUPDN_m <> 1 & bShowWalkLine & not(belowStory) then		! None
	DRAWINDEX 50
	PEN UPDNfontpen
	xNosing = nosing * (drawDetails[1]|drawDetails[3])

	if (walkingDirUPDN_m = 2 | walkingDirUPDN_m = 5 | (walkingDirUPDN_m = 6 & not(abovestory) & not(belowstory) )) & (drawPart[1]|drawPart[3]) then
		nTransUPDN = 0
		set style "UPDN"
		add2 flightWidth/2+DirUPDN_X,DirUPDN_Y-xNosing
		nTransUPDN = nTransUPDN + 1
		! Text Rotation - Readable / Parallel with Walking Line / Align with Symbol
		! ----------------------------------------------------------------------
		if typeTextRotation_UpDn_m = 2 then									! Readable
			if (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps)) then
				rot2 180
				nTransUPDN = nTransUPDN + 1
			endif
		else
			if typeTextRotation_UpDn_m = 1 then								! Parallel with Walking Line
				if not(SYMB_MIRRORED) then
					iReadable = (totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps))- not(totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps))
				else
					iReadable = (totalRotate < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps))- not(totalRotate < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps))
				endif
				rot2 -90 * iReadable
				nTransUPDN = nTransUPDN + 1
			endif
		endif
		! ----------------------------------------------------------------------
		rot2 AngUPDN
		nTransUPDN = nTransUPDN + 1

		string1	= ``
		text2 0,0, string1

		del nTransUPDN

		width1	= STW (string1)/1000*GLOB_SCALE
		rb		= width1/2
	endif

	if walkingDirUPDN_m = 3 & (drawPart[1]|drawPart[3]) then ! Down at Bottom
		nTransUPDN = 0
		set style "UPDN"
		add2 flightWidth/2+DirUPDN_X,DirUPDN_Y-xNosing
		nTransUPDN = nTransUPDN + 1

		! Text Rotation - Readable / Parallel with Walking Line / Align with Symbol
		! ----------------------------------------------------------------------
		if typeTextRotation_UpDn_m = 2 then									! Readable
			if (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps)) then
				rot2 180
				nTransUPDN = nTransUPDN + 1
			endif
		else
			if typeTextRotation_UpDn_m = 1 then								! Parallel with Walking Line
				if not(SYMB_MIRRORED) then
					iReadable = (totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps))- not(totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps))
				else
					iReadable = (totalRotate < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps))- not(totalRotate < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps))
				endif
				rot2 -90 * iReadable
				nTransUPDN = nTransUPDN + 1
			endif
		endif
		! ----------------------------------------------------------------------
		rot2 AngUPDN
		nTransUPDN = nTransUPDN + 1

		text2 0,0, gs_CustomText_Down

		del nTransUPDN

		string2	= gs_CustomText_Down
		width2	= STW (string2)/1000*GLOB_SCALE
		rb		= width2/2
	endif

	if (walkingDirUPDN_m = 2 | walkingDirUPDN_m = 5 | walkingDirUPDN_m = 3 | (walkingDirUPDN_m = 6 & not(abovestory) & not(belowstory))) & (drawPart[1]|drawPart[3]) then
		nTransHotspot = 0
		add2 flightWidth/2+DirUPDN_X,DirUPDN_Y-xNosing
		nTransHotspot = nTransHotspot  + 1
		if typeTextRotation_UpDn_m = 1 then
			rot2 -90 * iReadable
			nTransHotspot = nTransHotspot  + 1
		endif
		HOTSPOT2 0,					0,				UpDownUNID,	AngUPDN,	6		: UpDownUNID=UpDownUNID+1
		HOTSPOT2 rb,				0,				UpDownUNID,	AngUPDN,	4+128	: UpDownUNID=UpDownUNID+1
		HOTSPOT2 rb*cos(AngUPDN),	rb*sin(AngUPDN),UpDownUNID,	AngUPDN,	5		: UpDownUNID=UpDownUNID+1
		DEL nTransHotspot
	endif

	if (walkingDirUPDN_m = 4 | walkingDirUPDN_m = 5 | (walkingDirUPDN_m = 6 & abovestory)) & (drawPart[2]|drawPart[3]) then
		nTransUPDN = 0
		set style "UPDN"
		add2 A+DirUPDN_X_top,B-flightWidth/2-DirUPDN_Y_top
		nTransUPDN = nTransUPDN + 1

		! Text Rotation - Readable / Parallel with Walking Line / Align with Symbol
		! ----------------------------------------------------------------------
		if typeTextRotation_UpDn_m = 2 then									! Readable
			if ((totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps)) & not(SYMB_MIRRORED)) | \
				((totalRotate < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps)) & SYMB_MIRRORED) then
				rot2 180
				nTransUPDN = nTransUPDN + 1
			endif
		else
			if typeTextRotation_UpDn_m = 1 then								! Parallel with Walking Line
				iReadable = not(totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps))- (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps))
				rot2 -90 * iReadable
				nTransUPDN = nTransUPDN + 1
			endif
		endif
		! ----------------------------------------------------------------------
		rot2 AngUPDN_top + 90
		nTransUPDN = nTransUPDN + 1

		text2 0,0, gs_CustomText_Down

		del nTransUPDN

		string2	= gs_CustomText_Down
		width2	= STW (string2)/1000*GLOB_SCALE
		rb		= width2/2
	endif

	if (walkingDirUPDN_m = 4 | walkingDirUPDN_m = 5 | (walkingDirUPDN_m = 6 & abovestory)) & (drawPart[2]|drawPart[3]) then
		nTransHotspot = 0
		add2 A+DirUPDN_X_top,B-flightWidth/2-DirUPDN_Y_top
		nTransHotspot = nTransHotspot  + 1
		if typeTextRotation_UpDn_m = 1 then
			rot2 -90 * iReadable
			nTransHotspot = nTransHotspot  + 1
		endif
		rot2 90
		nTransHotspot = nTransHotspot  + 1
		HOTSPOT2 0,						0,					UpDownUNID,	AngUPDN_top,	6		: UpDownUNID=UpDownUNID+1
		HOTSPOT2 rb,					0,					UpDownUNID,	AngUPDN_top,	4+128	: UpDownUNID=UpDownUNID+1
		HOTSPOT2 rb*cos(AngUPDN_top),	rb*sin(AngUPDN_top),UpDownUNID,	AngUPDN_top,	5		: UpDownUNID=UpDownUNID+1
		DEL nTransHotspot
	endif
endif

! --- Numbering ----------------------------------------------------------------

if drawNum & not(belowStory) then
	startNumber	= 1
	endNumber	= nRisers1stRun
	xNosing = nosing * (drawDetails[1]|drawDetails[3])

	for iNumFlight = 1 to 2
		DRAWINDEX 50

		set style "stepnum"
		nnn = REQUEST ("Height_of_style", "stepnum", strHeight)
		strHeight = strHeight / 1000 * GLOB_SCALE
		add2 DirNumText_X, DirNumText_Y - treadDepth/2- xNosing

		bReadable = 0
		if iNumFlight = 1 then
			bReadable = (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps))
		else
			if SYMB_MIRRORED then
				bReadable = (totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps))
			else
				bReadable = (totalRotate < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps))
			endif
		endif

		for iNumStep = startNumber to endNumber
			add2 0, treadDepth
			pen gs_NumTextPen
			nTextTransformations = 0
			! Text Rotation - Readable / Align with Symbol
			! ----------------------------------------------------------------------
			if typeTextRotation_Num_m = 2 & bReadable = 1 then								! Readable
				rot2 180
				strWidth = STW(str("%.0", iNumStep + nStartNumbering-1)) / 1000 * GLOB_SCALE
				add2 -strWidth, strHeight
				nTextTransformations = 2
			endif
			! ----------------------------------------------------------------------

			text2 0,0,iNumStep + nStartNumbering-1
			if nTextTransformations > 0 then del nTextTransformations
		next iNumStep
		del (endNumber - startNumber + 1) + 1
			startNumber = nRisers1stRun + 1
		endNumber	= nRisers1stRun + nRisers2ndRun
		add2 flightWidth, (nRisers1stRun-1) * treadDepth + flightWidth
		rot2 -90
	next iNumFlight
	del 4

	HOTSPOT2 0,				DirNumText_Y- xNosing,	NumUnID, DirNumText_X,	1+128	:NumUnID=NumUnID+1
	HOTSPOT2 -1,			DirNumText_Y- xNosing,	NumUnID, DirNumText_X,	3		:NumUnID=NumUnID+1
	HOTSPOT2 DirNumText_X,	DirNumText_Y- xNosing,	NumUnID, DirNumText_X,	2		:NumUnID=NumUnID+1

	HOTSPOT2 DirNumText_X, 0- xNosing,				NumUnID, DirNumText_Y, 1+128	:NumUnID=NumUnID+1
	HOTSPOT2 DirNumText_X, -1- xNosing,				NumUnID, DirNumText_Y, 3		:NumUnID=NumUnID+1
	HOTSPOT2 DirNumText_X, DirNumText_Y- xNosing,	NumUnID, DirNumText_Y,	2		:NumUnID=NumUnID+1

endif

! --- Description ----------------------------------------------------------------

if STRLEN(gs_description) <> 0 & not(belowStory) then
	dim gs_description_bpos[3][3]
	lengthWalkLine = A+B-flightWidth
	if lengthWalkLine/2 < (treadDepth * (nRisers1stRun-1) + flightWidth/2) then
		gs_description_bpos[1][1] = flightWidth/2
		gs_description_bpos[1][2] = lengthWalkLine/2
	else
		gs_description_bpos[1][1] = lengthWalkLine/2 - treadDepth * (nRisers1stRun-1)
		gs_description_bpos[1][2] = (treadDepth * (nRisers1stRun-1) + flightWidth/2)
	endif

	gs_description_bpos[1][3] = 0

	style "description"
	pen gs_desc_text_pen
	add2 (gs_description_bpos[1][1] + gs_description_pos[1][1]), (gs_description_bpos[1][2] + gs_description_pos[1][2])

	textangle = (gs_description_bpos[1][3] + gs_description_pos[1][3])

	reversedText = 0
	angleFull = (totalRotate + textangle) MOD 360

	if angleFull < 0 then
		angleFull = angleFull + 360
	endif
	if angleFull > (gs_readable_angle+eps) & angleFull < (gs_readable_angle + 180 +eps) then
		reversedText = 1
		textangle = textangle + 180
	endif
	rot2 textangle

	if reversedText then
		text2 -STW(gs_description) / 1000 * GLOB_SCALE, 0, gs_description
	else
		text2 0,0, gs_description
	endif

	del 2
	hotspot2 gs_description_bpos[1][1], gs_description_bpos[1][2] + gs_description_pos[1][2], 40000+1, gs_description_pos[1][1], 1 + 128
	posRel = gs_description_pos[1][1]
	if abs(posRel) < 0.00001 then
		posRel = 0.0001
	else
		posRel = 0
	endif
	hotspot2 gs_description_bpos[1][1] - posRel, gs_description_bpos[1][2] + gs_description_pos[1][2], 40000+2, gs_description_pos[1][1], 3 + 128
	hotspot2 gs_description_bpos[1][1] + gs_description_pos[1][1], gs_description_bpos[1][2] + gs_description_pos[1][2], 40000+3, gs_description_pos[1][1], 2

	hotspot2 gs_description_bpos[1][1] + gs_description_pos[1][1], gs_description_bpos[1][2], 40000+4, gs_description_pos[1][2], 1 + 128
	posRel = gs_description_pos[1][2]
	if abs(posRel) < 0.00001 then
		posRel = 0.0001
	else
		posRel = 0
	endif
	hotspot2 gs_description_bpos[1][1] + gs_description_pos[1][1], gs_description_bpos[1][2] - posRel, 40000+5, gs_description_pos[1][2], 3 + 128
	hotspot2 gs_description_bpos[1][1] + gs_description_pos[1][1], gs_description_bpos[1][2] + gs_description_pos[1][2], 40000+6, gs_description_pos[1][2], 2

	!angle edit
	HOTSPOT2 gs_description_bpos[1][1] + gs_description_pos[1][1],
				gs_description_bpos[1][2] + gs_description_pos[1][2],
				40000+7, gs_description_pos[1][3], 6 + 128

	HOTSPOT2 gs_description_bpos[1][1] + gs_description_pos[1][1] + GLOB_SCALE*0.5*COS(gs_description_bpos[1][3])*gs_desc_text_size/1000,
				gs_description_bpos[1][2] + gs_description_pos[1][2] + GLOB_SCALE*0.5*SIN(gs_description_bpos[1][3])*gs_desc_text_size/1000,
				40000+8, gs_description_pos[1][3], 4 + 128

	HOTSPOT2 gs_description_bpos[1][1] + gs_description_pos[1][1] + GLOB_SCALE*0.5*gs_desc_text_size*COS(gs_description_bpos[1][3] + gs_description_pos[1][3])/1000,
				gs_description_bpos[1][2] + gs_description_pos[1][2] + GLOB_SCALE*0.5*gs_desc_text_size*SIN(gs_description_bpos[1][3] + gs_description_pos[1][3])/1000,
				40000+9, gs_description_pos[1][3], 5
endif

!===================================================================
! HOTSPOT EDITING in 2D
!===================================================================
DRAWINDEX 50
!-- FLIGHT WIDTH ---------------------------------------------------
FlightUNID = 50
xNosing = nosing * (drawDetails[1]|drawDetails[3])

HOTSPOT2 0,0,			FlightUNID, flightWidth, 1+128	: FlightUNID=FlightUNID+1
HOTSPOT2 flightWidth,0, FlightUNID, flightWidth, 2		: FlightUNID=FlightUNID+1
HOTSPOT2 -0.1,0,		FlightUNID, flightWidth, 3		: FlightUNID=FlightUNID+1

HOTSPOT2 flightWidth+nRisers2ndRun*treadDepth,(nRisers1stRun-1)*treadDepth+flightWidth,		FlightUNID, flightWidth, 1+128	: FlightUNID=FlightUNID+1
HOTSPOT2 flightWidth+nRisers2ndRun*treadDepth,(nRisers1stRun-1)*treadDepth,					FlightUNID, flightWidth, 2		: FlightUNID=FlightUNID+1
HOTSPOT2 flightWidth+nRisers2ndRun*treadDepth,(nRisers1stRun-1)*treadDepth+flightWidth+0.1,	FlightUNID, flightWidth, 3		: FlightUNID=FlightUNID+1

HOTSPOT2 a,-gapToFirstTread,	FlightUNID, b, 1+128	: FlightUNID=FlightUNID+1
HOTSPOT2 a,b-gapToFirstTread,	FlightUNID, b, 2		: FlightUNID=FlightUNID+1
HOTSPOT2 a,-1,					FlightUNID, b, 3		: FlightUNID=FlightUNID+1

HOTSPOT2 0,-gapToFirstTread,	FlightUNID, b, 1+256	: FlightUNID=FlightUNID+1
HOTSPOT2 0,b-gapToFirstTread,	FlightUNID, b, 2		: FlightUNID=FlightUNID+1
HOTSPOT2 0,-1,					FlightUNID, b, 3		: FlightUNID=FlightUNID+1

HOTSPOT2 0,b-gapToFirstTread,	FlightUNID, a, 1+256	: FlightUNID=FlightUNID+1
HOTSPOT2 a,b-gapToFirstTread,	FlightUNID, a, 2		: FlightUNID=FlightUNID+1
HOTSPOT2 0,-1,					FlightUNID, a, 3		: FlightUNID=FlightUNID+1

!-- UP/DOWN TEXT ---------------------------------------------------
IF bShowWalkLine & not(belowStory) THEN
	IF (walkingDirUPDN_m = 2 | walkingDirUPDN_m = 3 | walkingDirUPDN_m = 5) & bShowWalkLine then
		HOTSPOT2 flightWidth/2,			DirUPDN_Y-xNosing,		UpDownUNID, DirUPDN_X, 1+128	: UpDownUNID=UpDownUNID+1
		HOTSPOT2 flightWidth/2-1,		DirUPDN_Y-xNosing,		UpDownUNID, DirUPDN_X, 3		: UpDownUNID=UpDownUNID+1
		HOTSPOT2 flightWidth/2+DirUPDN_X,	DirUPDN_Y-xNosing,	UpDownUNID, DirUPDN_X, 2		: UpDownUNID=UpDownUNID+1

		HOTSPOT2 flightWidth/2+DirUPDN_X,	0-xNosing,		UpDownUNID, DirUPDN_Y, 1+128		: UpDownUNID=UpDownUNID+1
		HOTSPOT2 flightWidth/2+DirUPDN_X,	-1-xNosing,		UpDownUNID, DirUPDN_Y, 3			: UpDownUNID=UpDownUNID+1
		HOTSPOT2 flightWidth/2+DirUPDN_X,DirUPDN_Y-xNosing, UpDownUNID, DirUPDN_Y, 2			: UpDownUNID=UpDownUNID+1
	ENDIF

	IF (walkingDirUPDN_m = 4 | walkingDirUPDN_m = 5) & bShowWalkLine then
		HOTSPOT2 A,					B - flightWidth/2 - DirUPDN_Y_top, UpDownUNID, DirUPDN_X_top, 1+128 : UpDownUNID=UpDownUNID+1
		HOTSPOT2 A-1,				B - flightWidth/2 - DirUPDN_Y_top, UpDownUNID, DirUPDN_X_top, 3 : UpDownUNID=UpDownUNID+1
		HOTSPOT2 A+DirUPDN_X_top,	B - flightWidth/2 - DirUPDN_Y_top, UpDownUNID, DirUPDN_X_top, 2 : UpDownUNID=UpDownUNID+1

		HOTSPOT2 A+DirUPDN_X_top,	B - flightWidth/2 + 0,				UpDownUNID, DirUPDN_Y_top, 1+128	: UpDownUNID=UpDownUNID+1
		HOTSPOT2 A+DirUPDN_X_top,	B - flightWidth/2 + 1,				UpDownUNID, DirUPDN_Y_top, 3		: UpDownUNID=UpDownUNID+1
		HOTSPOT2 A+DirUPDN_X_top,	B - flightWidth/2 - DirUPDN_Y_top,	UpDownUNID, DirUPDN_Y_top, 2		: UpDownUNID=UpDownUNID+1
	ENDIF
endif

!-- RAILING  ---------------------------------------------------
if _bShowRailIn2D & bShowRailOnFloorPlan & not(belowStory) then
xNosing = 0 ! COMP nosing * (drawDetails[1]|drawDetails[3])

IF rail_m = 2 | rail_m = 1 THEN		! Right, Both
	!!! RAIL OFFSET - right
	HOTSPOT2 flightWidth-rightRailFrameThk/2,					-xNosing-rightRailOvhgBottom, RailUNID, rightRailOffset, 1+128	: RailUNID=RailUNID+1
	HOTSPOT2 flightWidth-rightRailFrameThk/2-rightRailOffset,	-xNosing-rightRailOvhgBottom, RailUNID, rightRailOffset, 2		: RailUNID=RailUNID+1
	HOTSPOT2 flightWidth-rightRailFrameThk/2-0.1,				-xNosing-rightRailOvhgBottom, RailUNID, rightRailOffset, 3		: RailUNID=RailUNID+1

	!!! RAIL TOP OVERHANG
	HOTSPOT2 flightWidth+nRisers2ndRun*treadDepth+rightRailOvhgTop,		(nRisers1stRun-1)*treadDepth+rightRailFrameThk/2, RailUNID, rightRailOffset, 1+128 : RailUNID=RailUNID+1
	HOTSPOT2 flightWidth+nRisers2ndRun*treadDepth+rightRailOvhgTop,		(nRisers1stRun-1)*treadDepth+rightRailFrameThk/2+0.1, RailUNID, rightRailOffset, 3 : RailUNID=RailUNID+1
	HOTSPOT2 flightWidth+nRisers2ndRun*treadDepth+rightRailOvhgTop,		(nRisers1stRun-1)*treadDepth+rightRailFrameThk/2+rightRailOffset, RailUNID, rightRailOffset, 2 : RailUNID=RailUNID+1

	!!! RAIL BOTTOM OVERHANG
	HOTSPOT2 flightWidth-rightRailFrameThk/2-rightRailOffset,		-xNosing,						RailUNID, rightRailOvhgBottom, 1+128 : RailUNID=RailUNID+1
	HOTSPOT2 flightWidth-rightRailFrameThk/2-rightRailOffset,		0+1,					RailUNID, rightRailOvhgBottom, 3 : RailUNID=RailUNID+1
	HOTSPOT2 flightWidth-rightRailFrameThk/2-rightRailOffset,		-xNosing-rightRailOvhgBottom,	RailUNID, rightRailOvhgBottom, 2 : RailUNID=RailUNID+1

	!!! RAIL TOP OVERHANG
	HOTSPOT2 flightWidth+nRisers2ndRun*treadDepth,					(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2, RailUNID, rightRailOvhgTop, 1+128 : RailUNID=RailUNID+1
	HOTSPOT2 flightWidth+nRisers2ndRun*treadDepth-1,				(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2, RailUNID, rightRailOvhgTop, 3		: RailUNID=RailUNID+1
	HOTSPOT2 flightWidth+nRisers2ndRun*treadDepth+rightRailOvhgTop,	(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2, RailUNID, rightRailOvhgTop, 2		: RailUNID=RailUNID+1
ENDIF

IF rail_m = 3 | rail_m = 1 THEN		! Left,	Both
	if bSameRails then
		!!! RAIL OFFSET - right
		HOTSPOT2 rightRailFrameThk/2,		-xNosing-rightRailOvhgBottom,			RailUNID, rightRailOffset, 1+128 : RailUNID=RailUNID+1
		HOTSPOT2 rightRailFrameThk/2+rightRailOffset,	-xNosing-rightRailOvhgBottom,	RailUNID, rightRailOffset, 2		: RailUNID=RailUNID+1
		HOTSPOT2 rightRailFrameThk/2+0.1,	-xNosing-rightRailOvhgBottom,			RailUNID, rightRailOffset, 3		: RailUNID=RailUNID+1

		!!! RAIL TOP OVERHANG
		HOTSPOT2 flightWidth+nRisers2ndRun*treadDepth+rightRailOvhgTop,		(nRisers1stRun-1)*treadDepth+flightWidth-rightRailFrameThk/2,				RailUNID, rightRailOffset, 1+128 : RailUNID=RailUNID+1
		HOTSPOT2 flightWidth+nRisers2ndRun*treadDepth+rightRailOvhgTop,		(nRisers1stRun-1)*treadDepth+flightWidth-rightRailFrameThk/2-0.1,			RailUNID, rightRailOffset, 3		: RailUNID=RailUNID+1
		HOTSPOT2 flightWidth+nRisers2ndRun*treadDepth+rightRailOvhgTop,		(nRisers1stRun-1)*treadDepth+flightWidth-rightRailFrameThk/2-rightRailOffset,	RailUNID, rightRailOffset, 2		: RailUNID=RailUNID+1

		!!! RAIL BOTTOM OVERHANG
		HOTSPOT2 rightRailFrameThk/2+rightRailOffset,		-xNosing,						RailUNID, rightRailOvhgBottom, 1+128 : RailUNID=RailUNID+1
		HOTSPOT2 rightRailFrameThk/2+rightRailOffset,		1,								RailUNID, rightRailOvhgBottom, 3		: RailUNID=RailUNID+1
		HOTSPOT2 rightRailFrameThk/2+rightRailOffset,		-xNosing-rightRailOvhgBottom,	RailUNID, rightRailOvhgBottom, 2		: RailUNID=RailUNID+1

		!!! RAIL TOP OVERHANG
		HOTSPOT2 flightWidth+nRisers2ndRun*treadDepth,					(nRisers1stRun-1)*treadDepth+flightWidth-rightRailOffset-rightRailFrameThk/2, RailUNID, rightRailOvhgTop, 1+128: RailUNID=RailUNID+1
		HOTSPOT2 flightWidth+nRisers2ndRun*treadDepth-1,				(nRisers1stRun-1)*treadDepth+flightWidth-rightRailOffset-rightRailFrameThk/2, RailUNID, rightRailOvhgTop, 3	: RailUNID=RailUNID+1
		HOTSPOT2 flightWidth+nRisers2ndRun*treadDepth+rightRailOvhgTop,	(nRisers1stRun-1)*treadDepth+flightWidth-rightRailOffset-rightRailFrameThk/2, RailUNID, rightRailOvhgTop, 2	: RailUNID=RailUNID+1
	else
		!!! RAIL OFFSET - left
		HOTSPOT2 leftRailFrameThk/2,		-xNosing-leftRailOvhgBottom,			RailUNID, leftRailOffset, 1+128 : RailUNID=RailUNID+1
		HOTSPOT2 leftRailFrameThk/2+leftRailOffset,	-xNosing-leftRailOvhgBottom,	RailUNID, leftRailOffset, 2		: RailUNID=RailUNID+1
		HOTSPOT2 leftRailFrameThk/2+0.1,	-xNosing-leftRailOvhgBottom,			RailUNID, leftRailOffset, 3		: RailUNID=RailUNID+1

		!!! RAIL TOP OVERHANG
		HOTSPOT2 flightWidth+nRisers2ndRun*treadDepth+leftRailOvhgTop,		(nRisers1stRun-1)*treadDepth+flightWidth-leftRailFrameThk/2,				RailUNID, leftRailOffset, 1+128 : RailUNID=RailUNID+1
		HOTSPOT2 flightWidth+nRisers2ndRun*treadDepth+leftRailOvhgTop,		(nRisers1stRun-1)*treadDepth+flightWidth-leftRailFrameThk/2-0.1,			RailUNID, leftRailOffset, 3		: RailUNID=RailUNID+1
		HOTSPOT2 flightWidth+nRisers2ndRun*treadDepth+leftRailOvhgTop,		(nRisers1stRun-1)*treadDepth+flightWidth-leftRailFrameThk/2-leftRailOffset,	RailUNID, leftRailOffset, 2		: RailUNID=RailUNID+1

		!!! RAIL BOTTOM OVERHANG
		HOTSPOT2 leftRailFrameThk/2+leftRailOffset,		-xNosing,						RailUNID, leftRailOvhgBottom, 1+128 : RailUNID=RailUNID+1
		HOTSPOT2 leftRailFrameThk/2+leftRailOffset,		1,								RailUNID, leftRailOvhgBottom, 3		: RailUNID=RailUNID+1
		HOTSPOT2 leftRailFrameThk/2+leftRailOffset,		-xNosing-leftRailOvhgBottom,	RailUNID, leftRailOvhgBottom, 2		: RailUNID=RailUNID+1

		!!! RAIL TOP OVERHANG
		HOTSPOT2 flightWidth+nRisers2ndRun*treadDepth,					(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2, RailUNID, leftRailOvhgTop, 1+128: RailUNID=RailUNID+1
		HOTSPOT2 flightWidth+nRisers2ndRun*treadDepth-1,				(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2, RailUNID, leftRailOvhgTop, 3	: RailUNID=RailUNID+1
		HOTSPOT2 flightWidth+nRisers2ndRun*treadDepth+leftRailOvhgTop,	(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2, RailUNID, leftRailOvhgTop, 2	: RailUNID=RailUNID+1
	endif
ENDIF
endif

END


"Start End Symbol":
	DRAWINDEX 45
	fill gs_StartEndFill

	if gs_StartEndFillPen <> 0 then
		temp_FillStatus = 2
	else
		temp_FillStatus = 0
	endif

	add2 0, +xNosing
	IF gs_StartEndStyle_m = 1 THEN		! Style 1
		POLY2_B 2, 1+temp_FillStatus, gs_StartEndFillPen, gs_fill_pen,
		0,-xNosing,901,
		gs_CircleRadius,360,4001
	ENDIF

	IF gs_StartEndStyle_m = 2 THEN		! Style 2
		FOR kk=1 TO 2
			POLY2_B 6, 1+temp_FillStatus, gs_StartEndFillPen, gs_fill_pen,
				0,-xNosing,1,
				0+gs_CircleRadius,-xNosing,1,
				0,-xNosing,901,
				0,90,4001,
				0,-xNosing+gs_CircleRadius,0,
				0,-xNosing,-1

			POLY2_B 6, 1, gs_StartEndFillPen, gs_fill_pen,
				0,-xNosing,1,
				0,-xNosing+gs_CircleRadius,1,
				0,-xNosing,901,
				0,90,4001,
				0-gs_CircleRadius,-xNosing,0,
				0,-xNosing,-1
		ROT2 180
		ADD2 0, 2*xNosing
		NEXT kk
		DEL 4
	ENDIF

	IF gs_StartEndStyle_m = 3 THEN		! Style 3
		LINE2 0+gs_StartWidth,-xNosing-gs_StartHeight,0+gs_StartWidth,-xNosing+gs_StartHeight
		LINE2 0-gs_StartWidth,-xNosing-gs_StartHeight,0-gs_StartWidth,-xNosing+gs_StartHeight
	ENDIF

	! --- Hotspots of StartEnd Symbol
	IF gs_StartEndStyle_m = 1 | gs_StartEndStyle_m = 2 THEN		! Style 1-2
		ADD2 0,-xNosing
			FOR kk=1 to 4
				HOTSPOT2 0, 0,					StartSymbUNID, gs_CircleRadius, 1+128	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 -1, 0,					StartSymbUNID, gs_CircleRadius, 3+128	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_CircleRadius, 0,	StartSymbUNID, gs_CircleRadius,2		:StartSymbUNID=StartSymbUNID+1

				ROT2 90
			NEXT KK
			DEL 4
		DEL 1
	ENDIF

	IF gs_StartEndStyle_m = 3 THEN		! Style 3
		FOR kk=1 to 2
			ADD2 0, -xNosing
				! Symbol Width/2
				HOTSPOT2 0,				-gs_StartHeight, StartSymbUNID, gs_StartWidth, 1+128:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 -1,			-gs_StartHeight, StartSymbUNID, gs_StartWidth, 3	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, -gs_StartHeight, StartSymbUNID, gs_StartWidth, 2	:StartSymbUNID=StartSymbUNID+1

				HOTSPOT2 0,				gs_StartHeight, StartSymbUNID, gs_StartWidth, 1+128	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 -1,			gs_StartHeight, StartSymbUNID, gs_StartWidth, 3		:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, gs_StartHeight, StartSymbUNID, gs_StartWidth,2		:StartSymbUNID=StartSymbUNID+1
			DEL 1

			ADD2 0, -xNosing
				! Symbol Height
				HOTSPOT2 gs_StartWidth, 0,				StartSymbUNID, gs_StartHeight, 1+128:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, -1,				StartSymbUNID, gs_StartHeight, 3	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, gs_StartHeight, StartSymbUNID, gs_StartHeight, 2	:StartSymbUNID=StartSymbUNID+1

				HOTSPOT2 gs_StartWidth, 0,					StartSymbUNID, gs_StartHeight, 1+128:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, 1,					StartSymbUNID, gs_StartHeight, 3	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, -gs_StartHeight,	StartSymbUNID, gs_StartHeight, 2	:StartSymbUNID=StartSymbUNID+1
			DEL 1

		MUL2 -1,1
		NEXT kk
		DEL 2
	ENDIF
	del 1

	DRAWINDEX 40
RETURN


"Arrowhead Symbol":
	IF arrow_style_m = 1 | arrow_style_m = 4 | arrow_style_m = 7 THEN
		temp_ArrowDist = flightWidth/2
		temp_ArrowHeight = treadDepth
		if not(reverseWalkLine) & (i = 2 | i = 3) & walkingDirUPDN_m <> 5 then temp_ArrowHeight = treadDepth + xNosing
	ENDIF

	IF arrow_style_m = 2 | arrow_style_m = 5 | arrow_style_m = 8 THEN
		temp_ArrowDist = flightWidth/4
		temp_ArrowHeight = treadDepth
		if not(reverseWalkLine) & (i = 2 | i = 3) & walkingDirUPDN_m <> 5 then temp_ArrowHeight = treadDepth + xNosing
	ENDIF

	IF arrow_style_m = 3 | arrow_style_m = 6 | arrow_style_m = 9 THEN
		temp_ArrowDist = gs_ArrowHalfWidth
		temp_ArrowHeight = gs_ArrowHeight
	ENDIF

	if arrow_style_m = 1 | arrow_style_m = 2 | arrow_style_m = 3 then
		temp_ArrowMask=0
	else
		temp_ArrowMask=1
	endif

	POLY2_b 4, 1, penFillArrow, gs_fill_pen,
		-temp_ArrowDist,-temp_ArrowHeight, temp_ArrowMask,
		temp_ArrowDist,-temp_ArrowHeight, 1,
		0,0, 1,
		-temp_ArrowDist,-temp_ArrowHeight, -1

	! --- Arrowhead Fill Contour Points Conditions
	IF arrow_style_m = 4 | arrow_style_m = 5 | arrow_style_m = 6 THEN
		temp_1XFill=temp_ArrowDist
		lengthArrowHead = temp_ArrowHeight
	else
		lengthArrowHead = 0
	ENDIF

	IF arrow_style_m = 7 | arrow_style_m = 8 | arrow_style_m = 9 THEN
		temp_1XFill=0
	ENDIF

	if penFillArrow <> 0 then
		IF arrow_style_m <> 1 & arrow_style_m <> 2 & arrow_style_m <> 3 THEN
			fill gs_ArrowFill ! Always 64 (Foreground)
			POLY2_b 4, 2, penFillArrow, gs_fill_pen,
				-temp_1XFill,-temp_ArrowHeight, temp_ArrowMask,
				temp_ArrowDist,-temp_ArrowHeight, 1,
				0,0, 1,
				-temp_1XFill,-temp_ArrowHeight, -1
		ENDIF
	endif

	HOTSPOT2	0,0,	ArrowUNID: ArrowUNID=ArrowUNID+1

	! --- Hotspot editing of Height & Width of Arrowhead
	IF arrow_style_m = 3 | arrow_style_m = 6 | arrow_style_m = 9 THEN
		HOTSPOT2 gs_ArrowHalfWidth,0,				ArrowUNID, gs_ArrowHeight, 1+128	: ArrowUNID=ArrowUNID+1
		HOTSPOT2 gs_ArrowHalfWidth,-gs_ArrowHeight,	ArrowUNID, gs_ArrowHeight, 2		: ArrowUNID=ArrowUNID+1
		HOTSPOT2 gs_ArrowHalfWidth,1,				ArrowUNID, gs_ArrowHeight, 3		: ArrowUNID=ArrowUNID+1

		HOTSPOT2 -gs_ArrowHalfWidth,0,					ArrowUNID, gs_ArrowHeight, 1+128	: ArrowUNID=ArrowUNID+1
		HOTSPOT2 -gs_ArrowHalfWidth,-gs_ArrowHeight,	ArrowUNID, gs_ArrowHeight, 2		: ArrowUNID=ArrowUNID+1
		HOTSPOT2 -gs_ArrowHalfWidth,1,					ArrowUNID, gs_ArrowHeight, 3		: ArrowUNID=ArrowUNID+1

		HOTSPOT2 0,					-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 1+128	: ArrowUNID=ArrowUNID+1
		HOTSPOT2 gs_ArrowHalfWidth,	-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 2		: ArrowUNID=ArrowUNID+1
		HOTSPOT2 -1,				-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 3		: ArrowUNID=ArrowUNID+1

		HOTSPOT2 0,					-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 1+128 : ArrowUNID=ArrowUNID+1
		HOTSPOT2 -gs_ArrowHalfWidth,-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 2		: ArrowUNID=ArrowUNID+1
		HOTSPOT2 1,					-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 3		: ArrowUNID=ArrowUNID+1
	ENDIF
RETURN


"left rail":

	if bShowRailOn1stRun then
		ADD2 leftRailOffset+leftRailFrameThk/2,-leftRailOvhgBottom
		ROT2 90

		lraSimple=(nRisers1stRun-1)*treadDepth+leftRailOvhgBottom
		lraComplex=(nRisers1stRun-2)*treadDepth
		additionXComplex=leftRailOvhgBottom+treadDepth/2
		additionZComplex=leftRailOvhgBottom*tan(ang)
		hrovL=treadDepth/2+leftRailOvhgBottom
		hrovR=treadDepth/2
		postNumber = int(nRisers1stRun/2+EPS)
		railAngle	= ang
		side = SIDE_LEFT
		gosub "callRailsForStair"

		DEL 2
	endif

	! --- POST & Rail on the landing (left side_1) -----------------------------
	if bShowRailOn1stLanding1 then
		ADD2 leftRailOffset+leftRailFrameThk/2,(nRisers1stRun-1)*treadDepth
		ROT2 90

		lraSimple=flightWidth-leftRailOffset-leftRailFrameThk
		lraComplex=flightWidth-leftRailOffset-leftRailFrameThk
		hrovL=leftRailPostSize/2
		hrovR=-leftRailPostSize/2
		postNumber = (flightWidth-leftRailOffset-leftRailFrameThk)*2 + 1
		railAngle	= ang
		side = SIDE_LEFT
		gosub "callRailsForLanding"

		DEL 2
	endif

	! --- POST & Rail on the landing (left side_2) -----------------------------
	if bShowRailOn1stLanding2 then
	ADD2 leftRailOffset,b-leftRailOffset-leftRailFrameThk/2-gapToFirstTread

		lraSimple=flightWidth-leftRailOffset-treadDepth
		lraComplex=flightWidth-leftRailOffset-treadDepth-leftRailPostSize
		hrovL=leftRailPostSize/2
		hrovR=leftRailPostSize/2
		postNumber = (flightWidth-leftRailOffset-treadDepth)*2 + 1
		railAngle	= ang
		side = SIDE_LEFT
		gosub "callRailsForLanding"

		DEL 1
	endif

	! ---  Rail on 2nd Run -----------------------------------------------------
	if bShowRailOn2ndRun then
		ADD2 flightWidth-treadDepth,b-leftRailOffset-leftRailFrameThk/2-gapToFirstTread

		lraSimple=(nRisers2ndRun+1)*treadDepth+leftRailOvhgTop
		lraComplex=(nRisers2ndRun)*treadDepth
		additionXComplex=treadDepth/2
		additionZComplex=0
		hrovL=treadDepth/2
		hrovR=treadDepth/2+leftRailOvhgTop
		postNumber = int(nRisers2ndRun/2+EPS) + 1
		railAngle	= ang
		side = SIDE_LEFT
		gosub "callRailsForStair"

		DEL 1
	endif

return


"right rail":

	if bShowRailOn1stRun then
		ADD2 flightWidth-rightRailOffset-rightRailFrameThk/2,-rightRailOvhgBottom
		ROT2 90

		lraSimple=(nRisers1stRun-1)*treadDepth+rightRailOvhgBottom+min(0,rightRailOffset)
		lraComplex=(nRisers1stRun-2)*treadDepth+min(0,rightRailOffset)
		additionXComplex=rightRailOvhgBottom+treadDepth/2
		additionZComplex=rightRailOvhgBottom*tan(ang)
		hrovL=treadDepth/2+rightRailOvhgBottom
		hrovR=treadDepth/2
		postNumber = int(nRisers1stRun/2+EPS)
		railAngle	= ang
		side = SIDE_RIGHT
		gosub "callRailsForStair"

		DEL 2
	endif

	! --- POST & Rail on the landing (right side_1) ----------------------------
	if bShowRailOn1stLanding1 then
		IF rightRailOffset<rightRailFrameThk then
			ADD2 flightWidth-rightRailFrameThk-rightRailOffset,(nRisers1stRun-1)*treadDepth+rightRailOffset
			poly2_b 4, 1 + 2 * (NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove) + 4+64, gs_fill_pen, gs_back_pen,
				0, 0, 1,
				rightRailFrameThk, 0, 1,
				rightRailFrameThk, rightRailFrameThk, 1,
				0, rightRailFrameThk, 1
			DEL 1
		ENDIF

		IF rightRailOffset>0.05 THEN
			IF rightRailOffset<0.2 THEN
				ADD2 flightWidth-rightRailOffset,(nRisers1stRun-1)*treadDepth
				ROT2 90
				poly2_b 4, 1 + 2 * (NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove) + 4+64, gs_fill_pen, gs_back_pen,
					0, 0, 1,
					rightRailOffset, 0, 1,
					rightRailOffset, rightRailFrameThk, 1,
					0, rightRailFrameThk, 1
				DEL 2
			ELSE
				ADD2 flightWidth-rightRailOffset-rightRailFrameThk/2,(nRisers1stRun-1)*treadDepth
				ROT2 90
				IF rightRailType_m = 1 & not(rightRailOffset>0.1) THEN
					! nothing !
				ELSE
					IF rightRailType_m = 8 | rightRailType_m = 9 | rightRailType_m = 10 THEN
						ADD2 0,-rightRailFrameThk/2
						IF rightRailOffset>0 then
							poly2_b 4, 1 + 2 * (NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove) + 4+64, gs_fill_pen, gs_back_pen,
								0, 0, 1,
								rightRailOffset, 0, 1,
								rightRailOffset, rightRailFrameThk, 1,
								0, rightRailFrameThk, 1
						endif
						DEL 1
					ELSE
						lraSimple=rightRailOffset
						lraComplex=rightRailOffset
						hrovL=rightRailPostSize/2
						hrovR=-rightRailPostSize/2
						postNumber = rightRailOffset*2
						railAngle	= ang
						side = SIDE_RIGHT
						gosub "callRailsForLanding"
					ENDIF
				ENDIF
				DEL 2
			ENDIF
		ENDIF
	endif

	! --- POST & Rail on the landing (right side_2) ----------------------------
	if bShowRailOn1stLanding2 then
		IF rightRailOffset*tan(ang)>treadHeight THEN
			IF rightRailOffset<0.2 & rightRailOffset>0.05 THEN
				ADD2 flightWidth-rightRailOffset,(nRisers1stRun-1)*treadDepth+rightRailOffset
				ROT2 0
				poly2_b 4, 1 + 2 * (NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove) + 4+64, gs_fill_pen, gs_back_pen,
					0, 0, 1,
					rightRailOffset, 0, 1,
					rightRailOffset, rightRailFrameThk, 1,
					0, rightRailFrameThk, 1
				DEL 2
			ELSE
				ADD2 flightWidth-rightRailOffset,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2
				ROT2 0
				IF rightRailOffset>treadDepth+0.08 & rightRailOffset-treadDepth>2*rightRailFrameThk+0.001 then
					IF rightRailType_m = 8 | rightRailType_m = 9 | rightRailType_m = 10 THEN
						ADD2 0,-rightRailFrameThk/2
						poly2_b 4, 1 + 2 * (NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove) + 4+64, gs_fill_pen, gs_back_pen,
							0, 0, 1,
							rightRailOffset-treadDepth, 0, 1,
							rightRailOffset-treadDepth, rightRailFrameThk, 1,
							0, rightRailFrameThk, 1
						DEL 1
					else
						lraSimple=rightRailOffset	! rightRailOffset-treadDepth ???
						lraComplex=rightRailOffset-treadDepth
						hrovL=-rightRailPostSize/2
						hrovR=rightRailPostSize/2
						postNumber = rightRailOffset*2
						railAngle	= ang
						side = SIDE_RIGHT
						gosub "callRailsForLanding"
					ENDIF
				ENDIF
				DEL 2
			ENDIF
		ENDIF
	endif

	! --- Railing on the 2nd run -----------------------------------------------
	if bShowRailOn2ndRun then
		ADD2 flightWidth-min(rightRailOffset,treadDepth),(nRisers1stRun-1)*treadDepth+rightRailFrameThk/2+rightRailOffset
		ROT2 0

		lraSimple=(nRisers2ndRun)*treadDepth+min(rightRailOffset,treadDepth)+rightRailOvhgTop
		lraComplex=(nRisers2ndRun-1)*treadDepth
		additionXComplex=treadDepth/2+min(rightRailOffset,treadDepth)
		additionZComplex=min(rightRailOffset*tan(ang),treadHeight)
		hrovL=treadDepth/2+min(rightRailOffset,treadDepth)
		hrovR=treadDepth/2+rightRailOvhgTop
		postNumber = int(nRisers2ndRun/2+EPS) + 1
		railAngle	= ang
		side = SIDE_RIGHT
		gosub "callRailsForStair"

		DEL 2
	endif

return


"callRailsForStair":
! ------------------------------------------------------------------------------
!	lraSimple
!	lraComplex
!	additionXComplex
!	additionZComplex
!	hrovL: rail overhang start
!	hrovR: rail overhang end
!	postNumber:   number of posts
!	side: SIDE_LEFT or SIDE_RIGHT
! ==============================================================================
	ani = railAngle
	additionXComplex = additionXComplex
	additionZComplex = additionZComplex
	if side = SIDE_LEFT then
		dsComplex = leftRailDist+treadDepth/2*tan(ang)
	else
		dsComplex = rightRailDist+treadDepth/2*tan(ang)
	endif

	gosub "callRails"
return


! ==============================================================================
"callRailsForLanding":
! ------------------------------------------------------------------------------
!	lraSimple
!	lraComplex
!	hrovL: rail overhang start
!	hrovR: rail overhang end
!	postNumber:   number of posts
!	side: SIDE_LEFT or SIDE_RIGHT
! ==============================================================================
	ani = 0
	additionZComplex = 0
	if side = SIDE_LEFT then
		additionXComplex = leftRailPostSize/2
		dsComplex = leftRailDist
	else
		additionXComplex = rightRailPostSize/2
		dsComplex = rightRailDist
	endif

	gosub "callRails"
return


! ==============================================================================
"callRails":
! ------------------------------------------------------------------------------
!	ani
!	additionXComplex
!	additionZComplex
!	dsComplex
!  ------------------
!	side: SIDE_LEFT or SIDE_RIGHT
!	lraSimple
!	lraComplex
!	hrovL: rail overhang start
!	hrovR: rail overhang end
!	postNumber:   number of posts
! ==============================================================================
	if side = SIDE_LEFT then
		railBarDepth		= leftRailBarDepth
		railBarDiam			= railBarDepth
		railHeight			= leftRailHeight
		railBarThk			= leftRailBarThk
		railFrameThk		= leftRailFrameThk
		railDist			= leftRailDist
		railType_m			= leftRailType_m
		railPostSize		= leftRailPostSize
		nBarsRail			= nBarsLeftRail
		if rightRailType_m = RAIL_WIRED then
			railBarThk		= leftRailWireThk
			railBarDepth	= leftRailWireDepth
			railBarDiam		= leftRailWireDiam
		endif
		bComplexRail		= bComplexRailLeft
	else
		railBarDepth		= rightRailBarDepth
		railBarDiam			= railBarDepth
		railHeight			= rightRailHeight
		railBarThk			= rightRailBarThk
		railFrameThk		= rightRailFrameThk
		railDist			= rightRailDist
		railType_m			= rightRailType_m
		railPostSize		= rightRailPostSize
		nBarsRail			= nBarsRightRail
		if rightRailType_m = RAIL_WIRED then
			railBarThk		= rightRailWireThk
			railBarDepth	= rightRailWireDepth
			railBarDiam		= rightRailWireDiam
		endif
		bComplexRail		= bComplexRailRight
	endif

	add2 additionXComplex * bComplexRail, 0
	call "railSymbol2D_m" parameters all	cfs					= 1,
											bEnable2DPosts		= bComplexRail,
											ptyp_m				= 1,
											ani					= ani,
											rom_m				= 1,
											rmm_m				= 1,
											LengthSize			= 0,
											lra					= lraSimple * NOT(bComplexRail) + lraComplex * (bComplexRail),
											hr					= railHeight,
											hrPerp				= railHeight,
											ab					= 0,
											rb					= 0,
											ds					= railDist,
											gs_AngleL			= 90,
											gs_AngleR			= 90,
											iHandRailStyle		= 1,
											handRailDiameter	= railFrameThk,
											handRailWidth		= railFrameThk,
											hroL				= hrovL,
											hroR				= hrovR,
											np					= postNumber,
											pd					= railPostSize,
											pw					= railPostSize,
											pth					= railFrameThk,
											gs_cont_pen			= railPen,
											sa					= 0,
											bBreakRailLine		= bBreakRailLine,
											breakLineAngle		= brLineAngle,
											breakLineDist		= breakLineDist,
											breakLineWidth		= breakLineW,
											bRailAboveBreakLine	= bRailAboveBreakLine,
											bShowRailBelowBrL	= bShowRailPart1,
											bShowRailAboveBrL	= bShowRailPart2,
											bPostNoCalculation	= (railType_m = 9),
											pit_m				= 2,
											dp					= treadDepth
	del 1

	bShowRailPart1			= 0
	bShowRailPart2			= 0

return

"carriage":

	drawindex 10

	if beamNum = 1 then
		add2 carriageBaseDist / 2 - beamThk / 2 - beamOffsetRight, 0
	else
		add2 carriageBaseDist - beamThk - beamOffsetRight, 0
	endif
	for wb = 1 to beamNum
		if bBreakCarriageLine then
			lengthMod	= -(carriageBaseDist - beamOffsetLeft - beamOffsetRight - beamThk) * tan(brLineAngle) * (wb = 2)
			if bShowCarriagePart1 then
				pen carriagePen
				if aboveStory then
					LINE_TYPE carriageLineType
				else
					if	(drawPart[1] and drawDashed[1]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE carriageLineType
					endif
				endif

				poly2_b 4, 1+2+4+64, gs_fill_pen, gs_back_pen,
					0, 0, 1,
					beamThk, 0, 1,
					beamThk, carrBreakLineDist + beamThk * tan(brLineAngle) / 2 + lengthMod, 1,
					0, carrBreakLineDist - beamThk * tan(brLineAngle) / 2 + lengthMod, 1
			endif

			if bShowCarriagePart2 then
				pen carriagePen
				if aboveStory then
					LINE_TYPE carriageLineType
				else
					if	(drawPart[2] and drawDashed[2]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE carriageLineType
					endif
				endif

				poly2_b 4, 1 + 2 * gs_FillAbove + 4+64, gs_fill_pen, gs_back_pen,
					0, carrBreakLineDist - beamThk * tan(brLineAngle) / 2 + lengthMod + carrBreakLineWidth, 1,
					beamThk, carrBreakLineDist + beamThk * tan(brLineAngle) / 2 + lengthMod + carrBreakLineWidth, 1,
					beamThk, beamLength, 1,
					0, beamLength, 1
			endif
		else
			if aboveStory then
				LINE_TYPE carriageLineType
			else
			pen carriagePen
				if drawPart[3] then
					if (drawDashed[3]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE carriageLineType
					endif
				else
					if	(NOT(bCarrAboveBreakLine) and drawDashed[1]) or\
						((bCarrAboveBreakLine) and drawDashed[2]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE carriageLineType
					endif
				endif
			endif

			poly2_b 4, 1 + 2 * (NOT(bCarrAboveBreakLine) + bCarrAboveBreakLine * gs_FillAbove) + 4+64, gs_fill_pen, gs_back_pen,
				0, 0, 1,
				beamThk, 0, 1,
				beamThk, beamLength, 1,
				0, beamLength, 1
		endif
		add2 -carriageBaseDist + beamThk + beamOffsetLeft + beamOffsetRight, 0
	next wb
	del beamNum + 1

return

