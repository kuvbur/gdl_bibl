

! ---------- Hotspots ----------[
	unID = 1
	FlightUNID		= 50
	RailUNID		= 100
	StartSymbUNID	= 200
	ArrowUNID		= 300
	RiseRunUNID		= 400
	UpDownUNID		= 500
	NumUnID			= 600

hotspot2 0,0, unID: unID=unID+1

! ---------- Hotspots ----------]

dim drawPart[3] ! 1 - lower,  2 - upper,  3 - full
dim drawDashed[3] ! 1 - lower,  2 - upper,  3 - full
dim drawSteps[3] ! 1 - lower,  2 - upper,  3 - full
dim drawDetails[3] ! 1 - lower,  2 - upper,  3 - full


drawPart[1] = 0		! Lower
drawPart[2] = 0		! Upper
drawPart[3] = 0		! Full
drawDashed[1] = 0	! Lower
drawDashed[2] = 0	! Upper
drawDashed[3] = 0	! Full
drawSteps[1] = 0	! Lower
drawSteps[2] = 0	! Upper
drawSteps[3] = 0	! Full
drawDetails[1] = 0	! Lower
drawDetails[2] = 0	! Upper
drawDetails[3] = 0	! Full
drawNum = 0


abovestory = 0
belowstory = 0
if bStorySensitive then
	if GLOB_CH_STORY_DIST > EPS  then
		abovestory = 1
	else
		if GLOB_CH_STORY_DIST < -EPS  then
			belowstory = 1
		endif
	endif
endif

bCarriageLineExist		= bShowCarriage and bEnableCarriageLine and (GLOB_SCALE <= iShowCarriageUpTo | iShowCarriageUpTo = 1)

! ---------- Settings of 2D Symbol Type ----------
_iSymbolType = 1
_bShowRailIn2D = 1
if gs_detlevel_2D_m = DET2D_SCALESENSITIVE then
	if GLOB_SCALE <= _iScaleMD then									!! Detailed Scale
		_iSymbolType = iEnabledSymbolTypes[iSymbolGroup][3]
	else
		if GLOB_SCALE > _iScaleMD & GLOB_SCALE <= _iScaleSM then	!! Middle Scale
			_iSymbolType = iEnabledSymbolTypes[iSymbolGroup][2]
		else														!! Simple Scale
			_iSymbolType = iEnabledSymbolTypes[iSymbolGroup][1]
			_bShowRailIn2D = 0
		endif
	endif
else
	_iSymbolType = gs_SymbolType_m
endif

IF _iSymbolType = 1 THEN		! Type 1
	drawPart[3]	= 1		! Full
	drawDashed[3] = 1	! Full
ENDIF

IF _iSymbolType = 2 THEN		! Type 2
	drawPart[3]	= 1		! Full
ENDIF

IF _iSymbolType = 3 THEN		! Type 3
	drawPart[1]	= 1		! Lower
ENDIF

IF _iSymbolType = 4 THEN		! Type 4
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
ENDIF

IF _iSymbolType = 5 THEN		! Type 5
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
ENDIF

IF _iSymbolType = 6 THEN		! Type 6
	drawPart[3]	= 1		! Full
	drawDashed[3] = 1	! Full
	drawSteps[3] = 1	! Full
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 7 THEN		! Type 7
	drawPart[3]	= 1		! Full
	drawSteps[3] = 1	! Full
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 8 THEN		! Type 8
	drawPart[1]	= 1		! Lower
	drawSteps[1] = 1	! Lower
ENDIF

IF _iSymbolType = 9 THEN		! Type 9
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
ENDIF

IF _iSymbolType = 10 THEN		! Type 10
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
ENDIF

IF _iSymbolType = 11 THEN		! Type 11
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 12 THEN		! Type 12
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 13 THEN		! Type 13
	drawPart[3]	= 1		! Full
	drawDashed[3] = 1	! Full
	drawSteps[3] = 1	! Full
	drawDetails[3] = 1	! Full

	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 14 THEN		! Type 14
	drawPart[3]	= 1		! Full
	drawSteps[3] = 1	! Full
	drawDetails[3] = 1	! Full

	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 15 THEN		! Type 15
	drawPart[1]	= 1		! Lower
	drawSteps[1] = 1	! Lower
	drawDetails[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
!	drawDetails[2] = 1	! Upper ! COMP
ENDIF

IF _iSymbolType = 16 THEN		! Type 16
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawDetails[1] = 1	! Lower
ENDIF

IF _iSymbolType = 17 THEN		! Type 17
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
	drawDetails[1] = 1	! Lower
ENDIF

IF _iSymbolType = 18 THEN		! Type 18
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawDetails[1] = 1	! Lower
	drawDetails[2] = 1	! Upper
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 19 THEN		! Type 19
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawDetails[1] = 1	! Lower
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 20 THEN		! Type 20
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawDetails[1] = 1	! Lower
	drawDetails[2] = 1	! Upper
	drawNum = bShowNumbering
ENDIF

! ---------- Stories below the home story ---------- [

bBackgroundFill = 1
if belowstory then
	drawPart[3]		= 1
	drawDashed[3]	= 1

	drawSteps[1] = 0
	drawSteps[2] = 0
	drawSteps[3] = 0

	drawDetails[1] = 0
	drawDetails[2] = 0
	drawDetails[3] = 0

	drawNum = 0
endif

! ---------- Stories below the home story ---------- ]

! ---------- Stories above the home story ---------- [
if abovestory then
	drawPart[1] = 0
	drawPart[2] = 0
	drawPart[3] = 0

	if gs_TreadStUp then
		drawSteps[1] = 1
		drawSteps[2] = 1
		drawSteps[3] = 1

		if drawDetails[1] | drawDetails[3] then
			drawDetails[1] = 1
			drawDetails[2] = 1
			drawDetails[3] = 1
		endif

	else
		drawSteps[1] = 0
		drawSteps[2] = 0
		drawSteps[3] = 0

		drawDetails[1] = 0
		drawDetails[2] = 0
		drawDetails[3] = 0
	endif

	if gs_BreaklineStUp = 0 then
		drawPart[3] = 1
	else
		if gs_LowerPartStUp then
			drawPart[1] = 1
		endif
		if gs_UpperPartStUp then
			drawPart[2] = 1
		endif
	endif

	if gs_numaStUp & gs_TreadStUp & ((drawPart[1] & drawPart[2]) | drawPart[3]) then
		drawNum = 1
	else
		drawNum = 0
	endif
endif

ROT2 -90
ADD2 -flightWidth,0
ADD2 0,max(nRisers2ndRun-nRisers1stRun,0)*treadDepth

hasBreak1st = 0
hasBreak2nd	= 0
	NumStline = INT (gs_BreakHeight/treadHeight)
	NumStline = max(1,NumStline)

FOR iFlight = 1 TO 2
	DRAWINDEX 10
	PEN gs_cont_pen
	FILL gs_fill_type

	if iFlight = 1 then
		RNU_temp = nRisers1stRun-1
		if drawPart[3] then
			bBackgroundFill	= 1
			drawBreakLine = 0
		else
			IF nRisers1stRun > NumStline+1 THEN
				drawBreakLine = 1
				hasBreak1st = 1
				bBackgroundFill	= gs_FillAbove
			else
				drawBreakLine = 0
				bBackgroundFill	= 1
			ENDIF
		endif
	endif
	if iFlight = 2 then
		RNU_temp	= nRisers2ndRun
		if drawPart[3] then
			bBackgroundFill = 1
			drawBreakLine = 0
		else
			if nRisers1stRun <= (NumStline+1) then
				drawBreakLine = 1
				hasBreak2nd = 1
				NumStline = max(1,(NumStline-nRisers1stRun))
				bBackgroundFill	= gs_FillAbove
			else
				drawBreakLine = 0
				bBackgroundFill	= gs_FillAbove
			endif
		endif
	ENDIF
	if belowStory then bBackgroundFill	= 0

	! ==========================================================================
	! CONTOUR LINES
	! ==========================================================================

	IF not(drawBreakLine) THEN
		IF (iFlight = 1 & drawPart[1]) | (iFlight=2 & drawPart[2]) | drawPart[3] THEN
			if aboveStory then
				PEN gs_LinePenStUp
				LINE_TYPE gs_LineTypeStUp
			else
				if drawDashed[iFlight] | drawDashed[3] then
					PEN gs_DashLinePen
					LINE_TYPE dash_line
				else
					PEN gs_cont_pen
					LINE_TYPE solid_line
				endif
			endif

			mask = 1
			if iFlight = 1 then xNosing = nosing * (drawDetails[1]|drawDetails[3])
			if iFlight = 2 then
				xNosing = nosing * (drawDetails[2]|drawDetails[3])
				mask = 0
			endif

			! ---------- Contour of Landing ----------
			if iFlight = 1 then
				POLY2_b 7, 1+2*bBackgroundFill+4+64, gs_fill_pen, gs_back_pen,
					flightWidth, (RNU_temp)*treadDepth-xNosing, 1,
					flightWidth, (RNU_temp+1)*treadDepth+flightWidth, 1,
					-b+flightWidth, (RNU_temp+1)*treadDepth+flightWidth, 1,
					-b+flightWidth, (RNU_temp+1)*treadDepth, 0,
					-b+2*flightWidth, (RNU_temp+1)*treadDepth, 1,
					0, (RNU_temp+1)*treadDepth, 1,
					0, (RNU_temp)*treadDepth-xNosing, 0

				HOTLINE2 flightWidth, (RNU_temp+1)*treadDepth-xNosing, flightWidth, (RNU_temp+1)*treadDepth+flightWidth
				HOTLINE2 flightWidth, (RNU_temp+1)*treadDepth+flightWidth, -b+flightWidth, (RNU_temp+1)*treadDepth+flightWidth
				HOTLINE2 -b+flightWidth, (RNU_temp+1)*treadDepth+flightWidth,-b+flightWidth, (RNU_temp)*treadDepth
				HOTLINE2 -b+flightWidth, (RNU_temp+1)*treadDepth,flightWidth, (RNU_temp+1)*treadDepth
			endif

			POLY2_b 4, 1+2*bBackgroundFill+4+64, gs_fill_pen, gs_back_pen,
				0,			-xNosing, 1,
				flightWidth,-xNosing, 1,
				flightWidth,(RNU_temp)*treadDepth-xNosing*mask, 1,
				0,			(RNU_temp)*treadDepth-xNosing*mask, 1

			HOTLINE2 0, -xNosing, flightWidth, -xNosing
			HOTLINE2 flightWidth, -xNosing, flightWidth, (RNU_temp)*treadDepth-xNosing
			HOTLINE2 flightWidth, (RNU_temp)*treadDepth-xNosing,0, (RNU_temp)*treadDepth-xNosing
			HOTLINE2 0, (RNU_temp)*treadDepth-xNosing,0, -xNosing

		ENDIF
	ELSE

! with Break Line
! ---------------------------------------------------------------------------------------------
		if breakline_style_m = 2 then		! Zig Zag
			angle_breakline=ATN(2*treadDepth/flightWidth)
			ZigZag1Y=(2/5*flightWidth)*tan(angle_breakline)
			ZigZag2Y=(7/20*flightWidth)*tan(angle_breakline)
		else
			if breakline_style_m = 3 then		! Zig Zag CHI
				angle_breakline=ATN(2*treadDepth/flightWidth)
				ZigZag1Y=(2/5*flightWidth)*tan(angle_breakline)
				ZigZag2Y=(2/5*flightWidth)*tan(angle_breakline)
			endif
		endif

		IF drawPart[1] THEN
			if aboveStory then
				PEN gs_LinePenStUp
				LINE_TYPE gs_LineTypeStUp
			else
				if drawDashed[1] then
					PEN gs_DashLinePen
					LINE_TYPE dash_line
				else
					PEN gs_cont_pen
					LINE_TYPE solid_line
				endif
			endif

			xNosing = nosing * drawDetails[1]

			if breakline_style_m = 2 then
				! ---------- Zig Zag ----------
				POLY2_b 8, 1+2+4+64, gs_fill_pen, gs_back_pen,
						0, -xNosing, 1,
						flightWidth, -xNosing, 1,
						flightWidth, (NumStline+1)*treadDepth-xNosing, 1,
						6/10*flightWidth,(NumStline+1)*treadDepth-xNosing-ZigZag1Y, 1,
						6/10*flightWidth,(NumStline-1)*treadDepth-xNosing+ZigZag1Y, 1,
						4/10*flightWidth,(NumStline+1)*treadDepth-xNosing-ZigZag1Y, 1,
						4/10*flightWidth,(NumStline-1)*treadDepth-xNosing+ZigZag1Y, 1,
						0, (NumStline-1)*treadDepth-xNosing, 1
			else
				if breakline_style_m = 3 then
					! ---------- Zig Zag CHI ----------
					POLY2_b 9, 1+2+64, gs_fill_pen, gs_back_pen,
							0, -xNosing, 1,
							flightWidth, -xNosing, 1,
							flightWidth, (NumStline+1)*treadDepth-xNosing, 1,
							6/10*flightWidth,(NumStline+1)*treadDepth-xNosing-ZigZag1Y, 1,
							6/10*flightWidth,(NumStline-1)*treadDepth-xNosing+ZigZag1Y, 1,
							4/10*flightWidth,(NumStline+1)*treadDepth-xNosing-ZigZag1Y+breakLineWidth, 1,
							4/10*flightWidth,(NumStline-1)*treadDepth-xNosing+ZigZag1Y, 1,
							0, (NumStline-1)*treadDepth-xNosing, 1,
							0, -xNosing, -1
				else
					! ---------- Straight ----------
					POLY2_b 4, 1+2+4+64, gs_fill_pen, gs_back_pen,
							0, -xNosing, 1,
							flightWidth, -xNosing, 1,
							flightWidth, (NumStline+1)*treadDepth-xNosing, 1,
							0, (NumStline-1)*treadDepth-xNosing, 1
				endif
			endif


			HOTSPOT2 flightWidth/2,(NumStline)*treadDepth-xNosing, FlightUNID: FlightUNID=FlightUNID+1
			HOTSPOT2 0,			(NumStline-1)*treadDepth-xNosing, FlightUNID: FlightUNID=FlightUNID+1
			HOTSPOT2 flightWidth,	(NumStline+1)*treadDepth-xNosing, FlightUNID: FlightUNID=FlightUNID+1

			HOTLINE2 0, -xNosing, flightWidth, -xNosing
			HOTLINE2 flightWidth, -xNosing, flightWidth, (NumStline+1)*treadDepth-xNosing
			HOTLINE2 flightWidth, (NumStline+1)*treadDepth-xNosing,0, (NumStline-1)*treadDepth-xNosing
			HOTLINE2 0, (NumStline-1)*treadDepth-xNosing,0, -xNosing
		ENDIF

		IF drawPart[2] THEN
			if aboveStory then
				PEN gs_LinePenStUp
				LINE_TYPE gs_LineTypeStUp
			else
				if drawDashed[2] then
					PEN gs_DashLinePen
					LINE_TYPE dash_line
				else
					PEN gs_cont_pen
					LINE_TYPE solid_line
				endif
			endif

			if iFlight = 2 then	mask = 0 else mask = 1
			xNosing = nosing * drawDetails[2]


			! ---------- Contour of Landing ----------
			if iFlight = 1 then
				POLY2_b 7, 1+2*bBackgroundFill+4+64, gs_fill_pen, gs_back_pen,
					flightWidth, (RNU_temp)*treadDepth-xNosing, 1,
					flightWidth, (RNU_temp+1)*treadDepth+flightWidth, 1,
					-b+flightWidth, (RNU_temp+1)*treadDepth+flightWidth, 1,
					-b+flightWidth, (RNU_temp+1)*treadDepth, 0,
					-b+2*flightWidth, (RNU_temp+1)*treadDepth, 1,
					0, (RNU_temp+1)*treadDepth, 1,
					0, (RNU_temp)*treadDepth-xNosing, 0

				HOTLINE2 flightWidth, (RNU_temp+1)*treadDepth-xNosing, flightWidth, (RNU_temp+1)*treadDepth+flightWidth
				HOTLINE2 flightWidth, (RNU_temp+1)*treadDepth+flightWidth, -b+flightWidth, (RNU_temp+1)*treadDepth+flightWidth
				HOTLINE2 -b+flightWidth, (RNU_temp+1)*treadDepth+flightWidth,-b+flightWidth, (RNU_temp)*treadDepth
				HOTLINE2 -b+flightWidth, (RNU_temp+1)*treadDepth,flightWidth, (RNU_temp+1)*treadDepth
			endif

			if breakline_style_m = 2 then
				! ---------- Zig Zag ----------
				POLY2_b 8, 1+2*bBackgroundFill+4+64, gs_fill_pen, gs_back_pen,
						0, (NumStline-1)*treadDepth-xNosing+ breakLineWidth, 1,
						7/20*flightWidth, (NumStline-1)*treadDepth -xNosing+ breakLineWidth +ZigZag2Y, 1,
						7/20*flightWidth, (NumStline-1)*treadDepth -xNosing+ breakLineWidth +ZigZag2Y+2*(treadDepth-ZigZag1Y), 1,
						11/20*flightWidth, (NumStline-1)*treadDepth -xNosing+ breakLineWidth +ZigZag2Y, 1,
						11/20*flightWidth, (NumStline-1)*treadDepth -xNosing+ breakLineWidth +ZigZag2Y+2*(treadDepth-ZigZag1Y), 1,
						flightWidth, (NumStline+1)*treadDepth-xNosing+ breakLineWidth, 1,
						flightWidth, (RNU_temp)*treadDepth-xNosing*mask, 1,
						0, (RNU_temp)*treadDepth-xNosing*mask, 1
			else
				if breakline_style_m = 3 then
					! ---------- Zig Zag CHI ----------
					POLY2_b 8, 1+2*bBackgroundFill+4+64, gs_fill_pen, gs_back_pen,
							0, (NumStline-1)*treadDepth-xNosing+ breakLineWidth, 1,
							4/10*flightWidth, (NumStline-1)*treadDepth -xNosing+ breakLineWidth +ZigZag2Y, 1,
							4/10*flightWidth, (NumStline+1)*treadDepth-xNosing-ZigZag1Y+breakLineWidth, 1,
							6/10*flightWidth, (NumStline-1)*treadDepth-xNosing+ZigZag1Y, 1,
							6/10*flightWidth, (NumStline-1)*treadDepth -xNosing+ breakLineWidth +ZigZag2Y+2*(treadDepth-ZigZag1Y), 1,
							flightWidth, (NumStline+1)*treadDepth-xNosing+ breakLineWidth, 1,
							flightWidth, (RNU_temp)*treadDepth-xNosing*mask, 1,
							0, (RNU_temp)*treadDepth-xNosing*mask, 1
				else
					! ---------- Straight ----------
					POLY2_b 4, 1+2*bBackgroundFill+4+64, gs_fill_pen, gs_back_pen,
							0, (NumStline-1)*treadDepth-xNosing+breakLineWidth, 1,
							flightWidth, (NumStline+1)*treadDepth-xNosing+breakLineWidth, 1,
							flightWidth, (RNU_temp)*treadDepth-xNosing*mask, 1,
							0, (RNU_temp)*treadDepth-xNosing*mask, 1
				endif
			endif

			HOTLINE2 0, (NumStline-1)*treadDepth-xNosing+breakLineWidth, flightWidth, (NumStline+1)*treadDepth-xNosing+breakLineWidth
			HOTLINE2 flightWidth, (NumStline+1)*treadDepth-xNosing+breakLineWidth,flightWidth, (RNU_temp)*treadDepth-xNosing*mask
			HOTLINE2 flightWidth, (RNU_temp)*treadDepth-xNosing*mask,0, (RNU_temp)*treadDepth-xNosing*mask
			HOTLINE2 0, (RNU_temp)*treadDepth-xNosing*mask,0, (NumStline-1)*treadDepth-xNosing+breakLineWidth

			! BREAK LINE
			HOTSPOT2 flightWidth/2,		(NumStline)*treadDepth-xNosing,					FlightUNID, breakLineWidth, 1+128	: FlightUNID=FlightUNID+1
			HOTSPOT2 flightWidth/2,		(NumStline)*treadDepth-xNosing-1,				FlightUNID, breakLineWidth, 3		: FlightUNID=FlightUNID+1
			HOTSPOT2 flightWidth/2,		(NumStline)*treadDepth-xNosing+breakLineWidth,	FlightUNID, breakLineWidth, 2		: FlightUNID=FlightUNID+1

			HOTSPOT2 0, (NumStline-1)*treadDepth-xNosing+breakLineWidth,				FlightUNID: FlightUNID=FlightUNID+1
			HOTSPOT2 flightWidth, (NumStline+1)*treadDepth-xNosing+breakLineWidth,	FlightUNID: FlightUNID=FlightUNID+1
		endif
	endif

	! ==========================================================================
	! TREADS
	! ==========================================================================
	DRAWINDEX 20

	if not(drawBreakLine) then
		if (iFlight = 1 & drawPart[1] & drawSteps[1]) | \
			(iFlight = 2 & drawPart[2] & drawSteps[2]) | \
			(drawPart[3] & drawSteps[3])  then

			if aboveStory then
				PEN gs_LinePenStUp
				LINE_TYPE gs_LineTypeStUp
			else
				if drawDashed[iFlight] | drawDashed[3] then
					PEN gs_DashLinePen
					LINE_TYPE dash_line
				else
					PEN gs_cont_pen
					LINE_TYPE solid_line
				endif
			endif

			FOR numTread = 1 to RNU_temp
				LINE2 0,-xNosing, flightWidth, -xNosing
				HOTLINE2 0,-xNosing, flightWidth, -xNosing
				ADD2 0,treadDepth
			NEXT numTread
			DEL RNU_temp

			IF drawDetails[iFlight] | drawDetails[3] THEN
				PEN gs_DashLinePen
				LINE_TYPE dash_line

				FOR numTread = 1 to RNU_temp+mask
					LINE2 0, 0, flightWidth, 0
					HOTLINE2 0, 0, flightWidth, 0
					ADD2 0,treadDepth
				NEXT numTread
				DEL numTread -1
			endif
		endif
	else
		if drawPart[1] & drawSteps[1] then

			xNosing = nosing * drawDetails[1]


			FOR numTread = 1 to NumStline+1
				if aboveStory then
					PEN gs_LinePenStUp
					LINE_TYPE gs_LineTypeStUp
				else
					if drawDashed[1] then
						PEN gs_DashLinePen
						LINE_TYPE dash_line
					else
						PEN gs_cont_pen
						LINE_TYPE solid_line
					endif
				endif

				StartSolid = 0
				IF breakline_style_m = 1 THEN
					IF numTread=NumStline THEN StartSolid=flightWidth/2
				ELSE
					IF numTread=NumStline THEN StartSolid=flightWidth*6/10
				ENDIF

				IF numTread<=NumStline THEN
					LINE2 StartSolid,treadDepth-xNosing, flightWidth, treadDepth-xNosing
					HOTLINE2 StartSolid,treadDepth-xNosing, flightWidth, treadDepth-xNosing
				ENDIF

				if drawDetails[1] THEN
					PEN gs_DashLinePen
					LINE_TYPE dash_line

					StartDashed=0
					if breakline_style_m = 1 then	! Straight
						IF ABS(numTread-NumStline-1)<0.001 THEN StartDashed=flightWidth/2+xNosing/tan(bet)
					ELSE
						IF distZigZag >= 4/10*flightWidth THEN
							distZigZag = 4/10*flightWidth
						ELSE
							distZigZag=(flightWidth*(treadDepth-xNosing))/(2*treadDepth)
						ENDIF

						IF numTread=NumStline+1 THEN StartDashed=max(0,leftRailOffset+leftRailFrameThk,flightWidth-distZigZag)
					ENDIF

					IF ABS(numTread-(NumStline))<0.01 THEN StartDashed=max(0,xNosing/tan(bet))

					LINE2 StartDashed,0,flightWidth,0
					HOTLINE2 StartDashed,0,flightWidth,0
				ENDIF
				ADD2 0,treadDepth
			NEXT numTread
			DEL numTread-1
		endif

		IF drawPart[2] & drawSteps[2] THEN

			xNosing = nosing * drawDetails[2]

			ADD2 0,(NumStline)*treadDepth
			FOR numTread = 1 to RNU_temp-NumStline+mask
				if aboveStory then
					PEN gs_LinePenStUp
					LINE_TYPE gs_LineTypeStUp
				else
					if drawDashed[2] then
						PEN gs_DashLinePen
						LINE_TYPE dash_line
					else
						PEN gs_cont_pen
						LINE_TYPE solid_line
					endif
				endif

				EndSolid=flightWidth
				if breakline_style_m = 1 then	! Straight
					IF numTread=1 THEN EndSolid=Max(0,Min(flightWidth,(treadDepth-breakLineWidth)/tan(bet)))
					IF numTread=2 THEN EndSolid=Max(0,Min(flightWidth,flightWidth-(breakLineWidth)/tan(bet)))
					IF numTread=3 THEN EndSolid=Max(0,Min(flightWidth,flightWidth-(breakLineWidth-treadDepth)/tan(bet)))
				else
					if breakline_style_m = 3 then	! Zigzag CHI
						ZigZagCorrection = 4/10
					else
						ZigZagCorrection = 7/20
					endif
					IF numTread=1 THEN EndSolid=min(ZigZagCorrection*flightWidth,(treadDepth-breakLineWidth)/tan(bet))
					IF numTread=2 THEN
						IF ZigZag2Y+2*(treadDepth-ZigZag1Y)<2*treadDepth-breakLineWidth-xNosing THEN EndSolid=Min(flightWidth,(2*treadDepth-breakLineWidth)/tan(bet))
						IF ZigZag2Y+2*(treadDepth-ZigZag1Y)>=2*treadDepth-breakLineWidth-xNosing THEN EndSolid=Min(flightWidth,ZigZagCorrection*flightWidth)
					ENDIF
					IF numTread=3 THEN EndSolid=Min(flightWidth,(3*treadDepth-breakLineWidth-xNosing)/tan(bet))

				ENDIF

				LINE2 0,-xNosing,EndSolid,-xNosing
				HOTLINE2 0,-xNosing,EndSolid,-xNosing

				IF drawDetails[2] THEN
					PEN gs_DashLinePen
					LINE_TYPE dash_line

					EndDashed=flightWidth
					if breakline_style_m = 1 then	! Straight
						IF numTread=1 THEN EndDashed=Min(flightWidth,(treadDepth+xNosing-breakLineWidth)/tan(bet))
						IF numTread=2 THEN EndDashed=Min(flightWidth,flightWidth+(xNosing-breakLineWidth)/tan(bet))
					ELSE
						IF distZigZag <= ZigZagCorrection*flightWidth THEN
							distZigZag = ZigZagCorrection*flightWidth
						ELSE
							distZigZag=(flightWidth*(breakLineWidth+xNosing))/(2*treadDepth)
						ENDIF
						IF numTread=1 THEN EndDashed=Min(ZigZagCorrection*flightWidth,(treadDepth+nosing-breakLineWidth)/tan(bet))
						IF numTread=2 THEN EndDashed=Min(flightWidth,flightWidth-(flightWidth*(breakLineWidth)-nosing)/(2*treadDepth))
					ENDIF

					LINE2 0,0,EndDashed,0
					HOTLINE2 0,0,EndDashed,0
				ENDIF

				ADD2 0,treadDepth
			NEXT numTread
			DEL numTread-1
			DEL 1
		endif
	endif

	! ==========================================================================
	! WALKING LINE / ARROWHEAD / START END SYMBOL
	! ==========================================================================
	reverseWalkline = 0
	if walkingDirUPDN_m = 3 | walkingDirUPDN_m = 4 | (walkingDirUPDN_m = 6 & abovestory) then
		reverseWalkline = 1
	endif

	if bShowWalkLine & not(belowStory) then

		PEN gs_wLinePen
		FILL gs_ArrowFill

		for i = 1 to 3
			DRAWINDEX 40
			drawWalkLine = 1
			if not(bShowWalkLineAboveBreakline) & i = 2 then drawWalkLine = 0

			if drawPart[i] & drawWalkLine then
				xNosing = nosing * drawDetails[i]
				startLine = -xNosing
				endLine = (RNU_temp)*treadDepth
				penFillArrow = gs_ArrowFillPen
				if i = 1 then
					if drawBreakline then
						endLine = (NumStline)*treadDepth-xNosing
					else
						if iFlight = 1 then
							endLine = (RNU_temp)*treadDepth
						else
							drawWalkLine = 0
						endif
					endif
				endif
				if i = 2 then
					if drawBreakline then
						startLine = startLine + (NumStline)*treadDepth+breakLineWidth
					else
						if iFlight = 1 then
							drawWalkLine = 0
						else
							endLine = (RNU_temp)*treadDepth
						endif
					endif
					penFillArrow = gs_ArrowFillPenAbove
					if walkingDirUPDN_m = 5 then reverseWalkline = 1
				endif

				if aboveStory then
					LINE_TYPE gs_wLineTypeStUp
				else
					if (drawDashed[i]) then
						LINE_TYPE gs_wLineTypeAbove
					else
						LINE_TYPE gs_wLineType1
					endif
				endif

				IF i = 3 & walkingDirUPDN_m = 5 THEN
					if iFlight = 1 then
					! Up Down Both - UP
					endLine = endLine -(MAX(1, INT(RNU_temp/3)))*treadDepth + startLine
					ADD2 flightWidth/2, endLine
					GOSUB "Arrowhead Symbol"
					DEL 1
					endLine = endLine-lengthArrowHead

					line2 flightWidth/2, startLine, flightWidth/2, endLine

					ADD2 flightWidth/2, startLine
					GOSUB "Start End Symbol"
					DEL 1
					endif

					if iFlight = 2 then
					! Up Down Both - Down
					endLine = (RNU_temp)*treadDepth
					startLine = startLine+(MAX(1, INT(RNU_temp/3)))*treadDepth
					ADD2 flightWidth/2, startLine
					MUL2 1, -1
					GOSUB "Arrowhead Symbol"
					DEL 2
					startLine = startLine+lengthArrowHead

					ADD2 flightWidth/2, endLine
					GOSUB "Start End Symbol"
					DEL 1
					endif
				else

					! Arrow Head below Break Line
					if not(reverseWalkline)	& (((i=3|i=2) & iFlight=2) | (i=1 & drawBreakLine)) then
						ADD2 flightWidth/2, endLine
						GOSUB "Arrowhead Symbol"
						DEL 1
						endLine = endLine-lengthArrowHead
					endif

					if not(reverseWalkline) & ((i=3|i=1) & iFlight=1) then
						ADD2 flightWidth/2, startLine
						GOSUB "Start End Symbol"
						DEL 1
					endif

					! Arrow Head on Start
					if reverseWalkline & (((i=3|i=1) & iFlight=1) | (i=2 & drawBreakLine))then
						ADD2 flightWidth/2, startLine
						MUL2 1, -1
						GOSUB "Arrowhead Symbol"
						DEL 2
						startLine = startLine+lengthArrowHead
					endif

					if reverseWalkline & ((i=3|i=2) & iFlight=2) then
						ADD2 flightWidth/2, endLine
						GOSUB "Start End Symbol"
						DEL 1
					endif
				endif

				! Walking Line
				if drawWalkLine then line2 flightWidth/2, startLine, flightWidth/2, endLine
			endif
		next i

		if drawBreakLine then
			HOTSPOT2 flightWidth/2,(NumStline)*treadDepth-xNosing,					FlightUNID,breakLineWidth,1+128		:FlightUNID=FlightUNID+1
			HOTSPOT2 flightWidth/2,(NumStline)*treadDepth-0.1-xNosing,				FlightUNID,breakLineWidth,3			:FlightUNID=FlightUNID+1
			HOTSPOT2 flightWidth/2,(NumStline)*treadDepth+breakLineWidth-xNosing,	FlightUNID,breakLineWidth,2			:FlightUNID=FlightUNID+1
		endif

		if 	(iFlight = 1 & ((not(hasBreak1st) & drawPart[1]) | (hasBreak1st & drawPart[2] & bShowWalkLineAboveBreakline) | (drawPart[3] & (walkingDirUPDN_m <> 5) ))) then
			if aboveStory then
				LINE_TYPE gs_wLineTypeStUp
			else
			if 	(iFlight = 1 & ((not(hasBreak1st) & drawDashed[1]) | (hasBreak1st & drawDashed[2]) | (drawDashed[3] & (walkingDirUPDN_m <> 5) ))) then
					LINE_TYPE gs_wLineTypeAbove
				else
					LINE_TYPE gs_wLineType1
				endif
			endif
			LINE2 flightWidth/2,(RNU_temp)*treadDepth,flightWidth/2,(RNU_temp+1)*treadDepth+flightWidth/2
			LINE2 -b+3*flightWidth/2,(RNU_temp+1)*treadDepth,-b+3*flightWidth/2,(RNU_temp+1)*treadDepth+flightWidth/2
			LINE2 flightWidth/2,(RNU_temp+1)*treadDepth+flightWidth/2,-b+3*flightWidth/2,(RNU_temp+1)*treadDepth+flightWidth/2
		ENDIF
	ENDIF

	DRAWINDEX 10
	ADD2 -b+2*flightWidth,(nRisers1stRun)*treadDepth
	ROT2 180
NEXT iFlight
DEL 2*2


!===============================================================================
! --- Carriage Line ---
!===============================================================================

if bCarriageLineExist and not(belowStory) then
	fill gs_fill_type

	bShowCarriagePart1	= 0
	bShowCarriagePart2	= 0

	beamNum				= 2
	beamThk				= woodBaseThk
	beamOffsetRight		= woodBaseOffset
	beamOffsetLeft		= woodBaseOffset
	carriageBaseDist	= flightWidth
	carrBreakLineWidth	= breakLineWidth

	if drawPart[3] then
		!!!!!******************************      1st RUN
		add2 0, bRiserCover * riserCoverThk
			beamLength			= a - flightWidth + 0.1 - woodBaseOffset - bRiserCover * riserCoverThk + woodBaseOffset - max(nRisers2ndRun - nRisers1stRun, 0) * treadDepth
			bCarrAboveBreakLine	= 0
			bBreakCarriageLine	= 0
			gosub "carriage"
		del 1

		!!!!!******************************      LANDING 1.
		add2 flightWidth, a - flightWidth + 0.1 - woodBaseOffset - max(nRisers2ndRun - nRisers1stRun, 0) * treadDepth
		rot2 90
			beamLength			= b
			carriageBaseDist	= flightWidth - 0.1 + woodBaseOffset
			bCarrAboveBreakLine	= 0
			bBreakCarriageLine	= 0
			gosub "carriage"
		del 2

		!!!!!******************************      2nd RUN
		add2 flightWidth * 2 - b, a - flightWidth + 0.1 - max(nRisers2ndRun - nRisers1stRun, 0) * treadDepth
		rot2 -180
			beamLength			= a - flightWidth + 0.1
			carriageBaseDist	= flightWidth
			bCarrAboveBreakLine	= 0
			bBreakCarriageLine	= 0
			gosub "carriage"
		del 2
	else
		if hasBreak1st then
			if drawPart[1] then
				!!!!!******************************      1st RUN
				add2 0, bRiserCover * riserCoverThk
					beamLength			= a - flightWidth + 0.1 - woodBaseOffset - bRiserCover * riserCoverThk + woodBaseOffset
					carriageBaseDist	= flightWidth
					bCarrAboveBreakLine	= 0
					bBreakCarriageLine	= 1
					bShowCarriagePart1	= 1
					brLineAngle			= bet
					xNosing				= nosing * drawDetails[1]
					carrBreakLineDist	= NumStline * treadDepth - xNosing + (flightWidth / 2 - beamOffsetRight - beamThk / 2) * tan(brLineAngle) - bRiserCover * riserCoverThk
					gosub "carriage"
				del 1
			endif

			if drawPart[2] then
				!!!!!******************************      1st RUN
				add2 0, bRiserCover * riserCoverThk
					beamLength			= a - flightWidth + 0.1 - woodBaseOffset - bRiserCover * riserCoverThk + woodBaseOffset - max(nRisers2ndRun - nRisers1stRun, 0) * treadDepth
					carriageBaseDist	= flightWidth
					bCarrAboveBreakLine	= 1
					bBreakCarriageLine	= 1
					bShowCarriagePart2	= 1
					brLineAngle			= bet
					xNosing				= nosing * drawDetails[2]
					carrBreakLineDist	= NumStline * treadDepth - xNosing + (flightWidth / 2 - beamOffsetRight - beamThk / 2) * tan(brLineAngle) - bRiserCover * riserCoverThk
					gosub "carriage"
				del 1

				!!!!!******************************      LANDING 1.
				add2 flightWidth, a - flightWidth + 0.1 - woodBaseOffset - max(nRisers2ndRun - nRisers1stRun, 0) * treadDepth
				rot2 90
					beamLength			= b
					carriageBaseDist	= flightWidth - 0.1 + woodBaseOffset
					bCarrAboveBreakLine	= 1
					bBreakCarriageLine	= 0
					gosub "carriage"
				del 2

				!!!!!******************************      2nd RUN
				add2 flightWidth * 2 - b, a - flightWidth + 0.1 - max(nRisers2ndRun - nRisers1stRun, 0) * treadDepth
				rot2 -180
					beamLength			= a - flightWidth + 0.1
					carriageBaseDist	= flightWidth
					bCarrAboveBreakLine	= 1
					bBreakCarriageLine	= 0
					brLineAngle			= bet
					xNosing				= nosing * drawDetails[2]
					carrBreakLineDist	= a - flightWidth - xNosing - ((nRisers1stRun - 1) - (NumStline - 1)) * treadDepth - (flightWidth / 2 - beamOffsetRight - beamThk / 2) * tan(brLineAngle) + woodBaseOffset + 0.1
					gosub "carriage"
				del 2
			endif
		else
			if drawPart[1] then
				!!!!!******************************      1st RUN
				add2 0, bRiserCover * riserCoverThk
					beamLength			= a - flightWidth + 0.1 - woodBaseOffset - bRiserCover * riserCoverThk + woodBaseOffset - max(nRisers2ndRun - nRisers1stRun, 0) * treadDepth
					carriageBaseDist	= flightWidth
					bCarrAboveBreakLine	= 0
					bBreakCarriageLine	= 0
					gosub "carriage"
				del 1

				!!!!!******************************      LANDING 1.
				add2 flightWidth, a - flightWidth + 0.1 - woodBaseOffset - max(nRisers2ndRun - nRisers1stRun, 0) * treadDepth
				rot2 90
					beamLength			= b
					carriageBaseDist	= flightWidth - 0.1 + woodBaseOffset
					bCarrAboveBreakLine	= 0
					bBreakCarriageLine	= 0
					gosub "carriage"
				del 2

				!!!!!******************************      2nd RUN
				add2 flightWidth * 2 - b, a - flightWidth + 0.1 - max(nRisers2ndRun - nRisers1stRun, 0) * treadDepth
				rot2 -180
					beamLength			= a - flightWidth + 0.1
					carriageBaseDist	= flightWidth
					bCarrAboveBreakLine	= 0
					bBreakCarriageLine	= 1
					bShowCarriagePart1	= 1
					brLineAngle			= bet
					xNosing				= nosing * drawDetails[1]
					carrBreakLineDist	= a - flightWidth - xNosing - ((nRisers1stRun - 1) - (NumStline - 1)) * treadDepth + (flightWidth / 2 - beamOffsetRight - beamThk / 2) * tan(brLineAngle) + 0.1 - max(nRisers2ndRun - nRisers1stRun, 0) * treadDepth
					gosub "carriage"
				del 2
			endif

			if drawPart[2] then
				!!!!!******************************      2nd RUN
				add2 flightWidth * 2 - b, a - flightWidth + 0.1 - max(nRisers2ndRun - nRisers1stRun, 0) * treadDepth
				rot2 -180
					beamLength			= a - flightWidth + 0.1
					carriageBaseDist	= flightWidth
					bCarrAboveBreakLine	= 1
					bBreakCarriageLine	= 1
					bShowCarriagePart2	= 1
					brLineAngle			= bet
					xNosing				= nosing * drawDetails[2]
					carrBreakLineDist	= a - flightWidth - xNosing - ((nRisers1stRun - 1) - (NumStline - 1)) * treadDepth + (flightWidth / 2 - beamOffsetRight - beamThk / 2) * tan(brLineAngle) + 0.1 - max(nRisers2ndRun - nRisers1stRun, 0) * treadDepth
					gosub "carriage"
				del 2
			endif
		endif
	endif
endif


!===============================================================================
! --- Railings ---
!===============================================================================

if _bShowRailIn2D & not(belowStory) then
	bShowRailPart1			= 0
	bShowRailPart2			= 0
	breakLineW				= breakLineWidth
	breakLineDist			= 0
	brLineAngle				= bet

	bShowRailOn1stRun		= 0
	bShowRailOn1stLanding1	= 0
	bShowRailOn1stLanding2	= 0
	bShowRailOn2ndRun		= 0
	bShowRailOn2ndLanding1	= 0
	bShowRailOn2ndLanding2	= 0
	bShowRailOn3rdRun		= 0

	drawindex 30
	fill gs_fill_type

	! --- Left Rail ----------------------------------------------------------------
	if rail_m = 3 | rail_m = 1 then		! Left, Both
		if bSameRails then
			leftRailType_m = rightRailType_m
			leftWireType_m = rightWireType_m
		endif

		if drawPart[3] then
			if bShowRailOnFloorPlan then
				pen railPen
				if aboveStory then
					LINE_TYPE railLineType
				else
					if (drawDashed[3]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE railLineType
					endif
				endif

				if bSymbolic2D then
					bShowRailOn1stRun		= 1
					bShowRailOn1stLanding1	= 1
					bShowRailOn1stLanding2	= 1
					bShowRailOn1stLanding3	= 1
					bShowRailOn2ndRun		= 1
					bBreakRailLine			= 0
					bRailAboveBreakLine		= 0
					gosub "left rail"
				else
					poly2_b 9, 1+2+64, gs_fill_pen, gs_back_pen,
						leftRailOffset+leftRailFrameThk,					-leftRailOvhgBottom,												1,
						leftRailOffset,										-leftRailOvhgBottom,												1,
						leftRailOffset,										 (nRisers1stRun)*treadDepth+leftRailOffset,					1,
						-b+2*flightWidth-leftRailOffset,					 (nRisers1stRun)*treadDepth+leftRailOffset,					1,
						-b+2*flightWidth-leftRailOffset,					 (nRisers1stRun-nRisers2ndRun)*treadDepth-leftRailOvhgTop,			1,
						-b+2*flightWidth-leftRailOffset-leftRailFrameThk,	 (nRisers1stRun-nRisers2ndRun)*treadDepth-leftRailOvhgTop,			1,
						-b+2*flightWidth-leftRailOffset-leftRailFrameThk,	 (nRisers1stRun)*treadDepth+leftRailOffset+leftRailFrameThk,	1,
						leftRailOffset+leftRailFrameThk,					 (nRisers1stRun)*treadDepth+leftRailOffset+leftRailFrameThk,	1,
						leftRailOffset+leftRailFrameThk,					-leftRailOvhgBottom,												-1
				endif
			endif

			if bShowRailAxis then
				line_type railAxisLineType
				pen gs_RailAxisPen
				line2 leftRailOffset+leftRailFrameThk/2, (nRisers1stRun)*treadDepth+leftRailOffset+leftRailFrameThk/2,leftRailOffset+leftRailFrameThk/2,-leftRailOvhgBottom
				line2 -b+2*flightWidth-leftRailOffset-leftRailFrameThk/2, (nRisers1stRun)*treadDepth+leftRailOffset+leftRailFrameThk/2,leftRailOffset+leftRailFrameThk/2,(nRisers1stRun)*treadDepth+leftRailOffset+leftRailFrameThk/2
				line2 -b+2*flightWidth-leftRailOffset-leftRailFrameThk/2, (nRisers1stRun)*treadDepth+leftRailOffset+leftRailFrameThk/2,-b+2*flightWidth-leftRailOffset-leftRailFrameThk/2,(nRisers1stRun-nRisers2ndRun)*treadDepth-leftRailOvhgTop
			endif
		else		! BREAK LINE - Railing
			if hasBreak1st then
				if drawPart[1] & bShowRailOnFloorPlan then
					pen railPen
					if aboveStory then
						SET LINE_TYPE railLineType
					else
						if (drawDashed[1]) then
							SET LINE_TYPE dash_line
						else
							SET LINE_TYPE railLineType
						endif
					endif
					xNosing = nosing * drawDetails[1]

					if bSymbolic2D then
						bShowRailOn1stRun		= 1
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn1stLanding3	= 0
						bShowRailOn2ndRun		= 0
						bBreakRailLine			= 1
						brLineAngle				= -bet
						bShowRailPart1			= 1
						breakLineDist			= leftRailOvhgBottom - xNosing + (NumStline - 1) * treadDepth + (leftRailOffset) * TAN(bet)
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 0
						gosub "left rail"
					else
						poly2_b 5, 1+2+64, gs_fill_pen, gs_back_pen,
							leftRailOffset,					-leftRailOvhgBottom,1,
							leftRailOffset+leftRailFrameThk,-leftRailOvhgBottom,1,
							leftRailOffset+leftRailFrameThk,-xNosing + (NumStline-1)*treadDepth+(leftRailOffset+leftRailFrameThk)*tan(bet),1,
							leftRailOffset,					-xNosing + (NumStline-1)*treadDepth+(leftRailOffset)*tan(bet),1,
							leftRailOffset,					-leftRailOvhgBottom,-1
					endif
				endif

				if drawPart[2] & bShowRailOnFloorPlan and bShowRailAboveBreakLine then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[2]) then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif
					xNosing = nosing * drawDetails[2]

					if bSymbolic2D then
						xNosing =  nosing * NOT(drawDetails[2])
						bShowRailOn1stRun		= 1
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn1stLanding3	= 0
						bShowRailOn2ndRun		= 0
						bBreakRailLine			= 1
						brLineAngle				= -bet
						bShowRailPart2			= 1
						breakLineDist			= leftRailOvhgBottom - nosing + (NumStline - 1) * treadDepth + (leftRailOffset) * TAN(bet)
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 1
						gosub "left rail"

						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 1
						bShowRailOn1stLanding2	= 1
						bShowRailOn1stLanding3	= 1
						bShowRailOn2ndRun		= 1
						bBreakRailLine			= 0
						bRailAboveBreakLine		= 1
						gosub "left rail"
					else
						POLY2_b 9, 1 + 2 * gs_FillAbove+64, gs_fill_pen, gs_back_pen,
							leftRailOffset,(nRisers1stRun)*treadDepth-xNosing+leftRailOffset,1,
							-b+2*flightWidth-leftRailOffset,(nRisers1stRun)*treadDepth-xNosing+leftRailOffset,1,
							-b+2*flightWidth-leftRailOffset,(nRisers1stRun-nRisers2ndRun)*treadDepth-leftRailOvhgTop,1,
							-b+2*flightWidth-leftRailOffset-leftRailFrameThk,(nRisers1stRun-nRisers2ndRun)*treadDepth-leftRailOvhgTop,1,
							-b+2*flightWidth-leftRailOffset-leftRailFrameThk,(nRisers1stRun)*treadDepth-xNosing+leftRailOffset+leftRailFrameThk,1,
							leftRailOffset+leftRailFrameThk,(nRisers1stRun)*treadDepth-xNosing+leftRailOffset+leftRailFrameThk,1,
							leftRailOffset+leftRailFrameThk,				-xNosing + (NumStline-1)*treadDepth+breakLineWidth+(leftRailOffset+leftRailFrameThk)*tan(bet),1,
							leftRailOffset,									-xNosing + (NumStline-1)*treadDepth+breakLineWidth+(leftRailOffset)*tan(bet),1,
							leftRailOffset,(nRisers1stRun)*treadDepth-xNosing+leftRailOffset,-1
					endif
				endif

				if bShowRailAxis then
					line_type railAxisLineType
					pen gs_RailAxisPen

					if drawPart[1] then
						xNosing = nosing * drawDetails[1]
						LINE2 leftRailOffset+leftRailFrameThk/2, -xNosing + (NumStline-1)*treadDepth+(leftRailOffset+leftRailFrameThk/2)*tan(bet),leftRailOffset+leftRailFrameThk/2,-leftRailOvhgBottom
					endif

					if drawPart[2] then
						xNosing = nosing * drawDetails[2]
						LINE2 leftRailOffset+leftRailFrameThk/2, -xNosing + (NumStline-1)*treadDepth+breakLineWidth+(leftRailOffset+leftRailFrameThk/2)*tan(bet),leftRailOffset+leftRailFrameThk/2,(nRisers1stRun)*treadDepth+leftRailOffset+leftRailFrameThk/2
						LINE2 -b+2*flightWidth-leftRailOffset-leftRailFrameThk/2, (nRisers1stRun)*treadDepth+leftRailOffset+leftRailFrameThk/2,leftRailOffset+leftRailFrameThk/2,(nRisers1stRun)*treadDepth+leftRailOffset+leftRailFrameThk/2
						LINE2 -b+2*flightWidth-leftRailOffset-leftRailFrameThk/2, (nRisers1stRun)*treadDepth+leftRailOffset+leftRailFrameThk/2,-b+2*flightWidth-leftRailOffset-leftRailFrameThk/2,(nRisers1stRun-nRisers2ndRun)*treadDepth-leftRailOvhgTop
					endif
				endif
			else
				if drawPart[1] & bShowRailOnFloorPlan then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[1]) then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif
					xNosing = nosing * drawDetails[1]

					if bSymbolic2D then
						bShowRailOn1stRun		= 1
						bShowRailOn1stLanding1	= 1
						bShowRailOn1stLanding2	= 1
						bShowRailOn1stLanding3	= 1
						bShowRailOn2ndRun		= 0
						bBreakRailLine			= 0
						bRailAboveBreakLine		= 0
						gosub "left rail"

						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn1stLanding3	= 0
						bShowRailOn2ndRun		= 1
						bBreakRailLine			= 1
						brLineAngle				= -bet
						bShowRailPart1			= 1
						if bComplexRailLeft then
							breakLineDist		= a-flightWidth-treadDepth/2 - xNosing + (treadDepth/2+leftRailFrameThk+min(leftRailOffset,treadDepth/2-leftRailFrameThk)) - ((nRisers1stRun)*treadDepth-(NumStline-1)*treadDepth-(leftRailFrameThk*0+leftRailOffset)*tan(bet))\
												-max(nRisers2ndRun - nRisers1stRun, 0) * treadDepth
						else
							breakLineDist		= a-flightWidth+leftRailFrameThk+min(leftRailOffset,treadDepth-leftRailFrameThk) - xNosing - ((nRisers1stRun)*treadDepth-(NumStline-1)*treadDepth-(leftRailFrameThk*0+leftRailOffset)*tan(bet))\
												-max(nRisers2ndRun - nRisers1stRun, 0) * treadDepth
						endif
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 0
						gosub "left rail"
					else
						POLY2_b 9, 1+2+4+64, gs_fill_pen, gs_back_pen,
							leftRailOffset,-leftRailOvhgBottom,1,
							leftRailOffset+leftRailFrameThk,-leftRailOvhgBottom,1,
							leftRailOffset+leftRailFrameThk,(nRisers1stRun)*treadDepth-xNosing+leftRailOffset+leftRailFrameThk,1,
							-b+2*flightWidth-leftRailOffset-leftRailFrameThk,(nRisers1stRun)*treadDepth-xNosing+leftRailOffset+leftRailFrameThk,1,
							-b+2*flightWidth-leftRailOffset-leftRailFrameThk,(nRisers1stRun)*treadDepth-(NumStline-1)*treadDepth-(leftRailFrameThk+leftRailOffset)*tan(bet),1,
							-b+2*flightWidth-leftRailOffset,(nRisers1stRun)*treadDepth-(NumStline-1)*treadDepth-(leftRailOffset)*tan(bet),1,
							-b+2*flightWidth-leftRailOffset,(nRisers1stRun)*treadDepth-xNosing+leftRailOffset,1,
							leftRailOffset,(nRisers1stRun)*treadDepth-xNosing+leftRailOffset,1,
							leftRailOffset,-leftRailOvhgBottom,-1
					endif
				endif

				if drawPart[2] & bShowRailOnFloorPlan and bShowRailAboveBreakLine then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[2]) then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif

					if bSymbolic2D then
						xNosing = nosing * NOT(drawDetails[2])
						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn1stLanding3	= 0
						bShowRailOn2ndRun		= 1
						bBreakRailLine			= 1
						brLineAngle				= -bet
						bShowRailPart2			= 1
						if bComplexRailLeft then
							breakLineDist		= a-flightWidth-treadDepth/2 - nosing + (treadDepth/2+leftRailFrameThk+min(leftRailOffset,treadDepth/2-leftRailFrameThk)) - ((nRisers1stRun)*treadDepth-(NumStline-1)*treadDepth-(leftRailFrameThk*0+leftRailOffset)*tan(bet))\
												-max(nRisers2ndRun - nRisers1stRun, 0) * treadDepth
						else
							breakLineDist		= a-flightWidth+leftRailFrameThk+min(leftRailOffset,treadDepth-leftRailFrameThk) - nosing - ((nRisers1stRun)*treadDepth-(NumStline-1)*treadDepth-(leftRailFrameThk*0+leftRailOffset)*tan(bet))\
												-max(nRisers2ndRun - nRisers1stRun, 0) * treadDepth
						endif
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 1
						gosub "left rail"
					else
						xNosing = nosing * drawDetails[2]
						POLY2_b 5, 1+2*gs_FillAbove+4+64, gs_fill_pen, gs_back_pen,
							-b+2*flightWidth-leftRailOffset,					(nRisers1stRun)*treadDepth-(NumStline-1)*treadDepth-(leftRailOffset)*tan(bet)-breakLineWidth,1,
							-b+2*flightWidth-leftRailOffset-leftRailFrameThk,	(nRisers1stRun)*treadDepth-(NumStline-1)*treadDepth-(leftRailFrameThk+leftRailOffset)*tan(bet)-breakLineWidth,1,
							-b+2*flightWidth-leftRailOffset-leftRailFrameThk,	(nRisers1stRun)*treadDepth-nRisers2ndRun*treadDepth-leftRailOvhgTop,1,
							-b+2*flightWidth-leftRailOffset,					(nRisers1stRun)*treadDepth-nRisers2ndRun*treadDepth-leftRailOvhgTop,1,
							-b+2*flightWidth-leftRailOffset,					(nRisers1stRun)*treadDepth-(NumStline-1)*treadDepth-(leftRailOffset)*tan(bet)-breakLineWidth,-1
					endif
				endif

				if bShowRailAxis then
					line_type railAxisLineType
					pen gs_RailAxisPen

					if drawPart[1] then
						xNosing = nosing * drawDetails[1]
						LINE2 leftRailOffset+leftRailFrameThk/2,-leftRailOvhgBottom,
								leftRailOffset+leftRailFrameThk/2,(nRisers1stRun)*treadDepth-xNosing+leftRailOffset+leftRailFrameThk
						LINE2 -b+2*flightWidth-leftRailOffset-leftRailFrameThk/2,(nRisers1stRun)*treadDepth-xNosing+leftRailOffset+leftRailFrameThk,
								leftRailOffset+leftRailFrameThk/2,(nRisers1stRun)*treadDepth-xNosing+leftRailOffset+leftRailFrameThk
						LINE2 -b+2*flightWidth-leftRailOffset-leftRailFrameThk/2, (nRisers1stRun)*treadDepth-(NumStline-1)*treadDepth + nosing -(leftRailFrameThk/2+leftRailOffset)*tan(bet),
								-b+2*flightWidth-leftRailOffset-leftRailFrameThk/2,(nRisers1stRun)*treadDepth-xNosing+leftRailOffset+leftRailFrameThk
					endif
					if drawPart[2] and drawPart[2] and bShowRailAboveBreakLine then
						xNosing = nosing * drawDetails[2]
						LINE2 -b+2*flightWidth-leftRailOffset-leftRailFrameThk/2, (nRisers1stRun)*treadDepth-(NumStline-1)*treadDepth + xNosing -(leftRailFrameThk/2+leftRailOffset)*tan(bet)-breakLineWidth,
								-b+2*flightWidth-leftRailOffset-leftRailFrameThk/2,(nRisers1stRun)*treadDepth-nRisers2ndRun*treadDepth-leftRailOvhgTop
					endif
				endif
			endif
		endif
	endif

	! --- Right Rail ---------------------------------------------------------------
	pen gs_cont_pen
	if rail_m = 2 | rail_m = 1 then		! Right, Both
		if drawPart[3] then
			if bShowRailOnFloorPlan then
				pen railPen
				if aboveStory then
					LINE_TYPE railLineType
				else
					if (drawDashed[3]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE railLineType
					endif
				endif

				if bSymbolic2D then
					bShowRailOn1stRun		= 1
					bShowRailOn1stLanding1	= 1
					bShowRailOn1stLanding2	= 1
					bShowRailOn1stLanding3	= 1
					bShowRailOn2ndRun		= 1
					bBreakRailLine			= 0
					bRailAboveBreakLine		= 0
					gosub "right rail"
				else
					POLY2_b 9, 1+2+64, gs_fill_pen, gs_back_pen,
						flightWidth-rightRailOffset-rightRailFrameThk,-rightRailOvhgBottom,1,
						flightWidth-rightRailOffset,-rightRailOvhgBottom,1,
						flightWidth-rightRailOffset,(nRisers1stRun)*treadDepth+flightWidth-rightRailOffset,1,
						-b+flightWidth+rightRailOffset,(nRisers1stRun)*treadDepth+flightWidth-rightRailOffset,1,
						-b+flightWidth+rightRailOffset,(nRisers1stRun-nRisers2ndRun)*treadDepth-rightRailOvhgTop,1,
						-b+flightWidth+rightRailOffset+rightRailFrameThk,(nRisers1stRun-nRisers2ndRun)*treadDepth-rightRailOvhgTop,1,
						-b+flightWidth+rightRailOffset+rightRailFrameThk,(nRisers1stRun)*treadDepth+flightWidth-rightRailOffset-rightRailFrameThk,1,
						flightWidth-rightRailOffset-rightRailFrameThk,(nRisers1stRun)*treadDepth+flightWidth-rightRailOffset-rightRailFrameThk,1,
						flightWidth-rightRailOffset-rightRailFrameThk,-rightRailOvhgBottom,-1
				endif
			endif

			if bShowRailAxis then
				line_type railAxisLineType
				pen gs_RailAxisPen

				LINE2 flightWidth-rightRailOffset-rightRailFrameThk/2, (nRisers1stRun)*treadDepth+flightWidth-rightRailOffset-rightRailFrameThk/2,flightWidth-rightRailOffset-rightRailFrameThk/2,-rightRailOvhgBottom
				LINE2 -b+flightWidth+rightRailOffset+rightRailFrameThk/2, (nRisers1stRun)*treadDepth+flightWidth-rightRailOffset-rightRailFrameThk/2,\
					flightWidth-rightRailOffset-rightRailFrameThk/2,(nRisers1stRun)*treadDepth+flightWidth-rightRailOffset-rightRailFrameThk/2
				LINE2 -b+flightWidth+rightRailOffset+rightRailFrameThk/2, (nRisers1stRun)*treadDepth+flightWidth-rightRailOffset-rightRailFrameThk/2,-b+flightWidth+rightRailOffset+rightRailFrameThk/2,(nRisers1stRun-nRisers2ndRun)*treadDepth-rightRailOvhgTop
			endif
		else
			if hasBreak1st then
				if drawPart[1] & bShowRailOnFloorPlan then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[1]) then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif
					xNosing = nosing * drawDetails[1]

					if bSymbolic2D then
						bShowRailOn1stRun		= 1
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn1stLanding3	= 0
						bShowRailOn2ndRun		= 0
						bBreakRailLine			= 1
						brLineAngle				= -bet
						bShowRailPart1			= 1
						breakLineDist			= rightRailOvhgBottom - xNosing + (NumStline + 1) * treadDepth - (rightRailOffset + rightRailFrameThk) * TAN(bet)
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 0
						gosub "right rail"
					else
						poly2_b 5, 1+2+64, gs_fill_pen, gs_back_pen,
							flightWidth-rightRailOffset,					-rightRailOvhgBottom,1,
							flightWidth-rightRailOffset-rightRailFrameThk,	-rightRailOvhgBottom,1,
							flightWidth-rightRailOffset-rightRailFrameThk,	-xNosing + (NumStline+1)*treadDepth-(rightRailOffset+rightRailFrameThk)*tan(bet),1,
							flightWidth-rightRailOffset,					-xNosing + (NumStline+1)*treadDepth-(rightRailOffset)*tan(bet),1,
							flightWidth-rightRailOffset,					-rightRailOvhgBottom,-1
					endif
				endif

				if drawPart[2] & bShowRailOnFloorPlan and bShowRailAboveBreakLine then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[2]) then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif
					xNosing = nosing * drawDetails[2]

					if bSymbolic2D then
						xNosing = nosing * NOT(drawDetails[2])
						bShowRailOn1stRun		= 1
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn1stLanding3	= 0
						bShowRailOn2ndRun		= 0
						bBreakRailLine			= 1
						brLineAngle				= -bet
						bShowRailPart2			= 1
						breakLineDist			= rightRailOvhgBottom - nosing + (NumStline + 1) * treadDepth - (rightRailOffset + rightRailFrameThk) * TAN(bet)
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 1
						gosub "right rail"

						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 1
						bShowRailOn1stLanding2	= 1
						bShowRailOn1stLanding3	= 1
						bShowRailOn2ndRun		= 1
						bBreakRailLine			= 0
						bRailAboveBreakLine		= 1
						gosub "right rail"
					else
						POLY2_b 9, 1+2*gs_FillAbove+64, gs_fill_pen, gs_back_pen,
							flightWidth-rightRailOffset,						(nRisers1stRun)*treadDepth+flightWidth-rightRailOffset,1,
							-b+flightWidth+rightRailOffset,						(nRisers1stRun)*treadDepth+flightWidth-rightRailOffset,1,
							-b+flightWidth+rightRailOffset,						(nRisers1stRun-nRisers2ndRun)*treadDepth-rightRailOvhgTop,1,
							-b+flightWidth+rightRailOffset+rightRailFrameThk,	(nRisers1stRun-nRisers2ndRun)*treadDepth-rightRailOvhgTop,1,
							-b+flightWidth+rightRailOffset+rightRailFrameThk,	(nRisers1stRun)*treadDepth+flightWidth-rightRailOffset-rightRailFrameThk,1,
							flightWidth-rightRailOffset-rightRailFrameThk,		(nRisers1stRun)*treadDepth+flightWidth-rightRailOffset-rightRailFrameThk,1,
							flightWidth-rightRailOffset-rightRailFrameThk,		(NumStline+1)*treadDepth-xNosing+breakLineWidth-(rightRailOffset+rightRailFrameThk)*tan(bet),1,
							flightWidth-rightRailOffset,						(NumStline+1)*treadDepth-xNosing+breakLineWidth-(rightRailOffset)*tan(bet),1,
							flightWidth-rightRailOffset,						(nRisers1stRun)*treadDepth+flightWidth-rightRailOffset,-1
					endif
				endif

				if bShowRailAxis then
					line_type railAxisLineType
					pen gs_RailAxisPen

					if drawPart[1] then
						xNosing = nosing * drawDetails[1]

						LINE2 flightWidth-rightRailOffset-rightRailFrameThk/2,-rightRailOvhgBottom,flightWidth-rightRailOffset-rightRailFrameThk/2,-xNosing + (NumStline+1)*treadDepth-(rightRailOffset+rightRailFrameThk/2)*tan(bet)
					endif
					if drawPart[2] then
						xNosing = nosing * drawDetails[2]
						LINE2 flightWidth-rightRailOffset-rightRailFrameThk/2, -xNosing + (NumStline+1)*treadDepth+breakLineWidth-(rightRailOffset+rightRailFrameThk/2)*tan(bet),\
						flightWidth-rightRailOffset-rightRailFrameThk/2,(nRisers1stRun)*treadDepth+flightWidth-rightRailOffset-rightRailFrameThk/2
						LINE2 -b+flightWidth+rightRailOffset+rightRailFrameThk/2, (nRisers1stRun)*treadDepth+flightWidth-rightRailOffset-rightRailFrameThk/2,\
						flightWidth-rightRailOffset-rightRailFrameThk/2,(nRisers1stRun)*treadDepth+flightWidth-rightRailOffset-rightRailFrameThk/2
						LINE2 -b+flightWidth+rightRailOffset+rightRailFrameThk/2, (nRisers1stRun)*treadDepth+flightWidth-rightRailOffset-rightRailFrameThk/2,-b+flightWidth+rightRailOffset+rightRailFrameThk/2,(nRisers1stRun-nRisers2ndRun)*treadDepth-rightRailOvhgTop
					ENDIF
				ENDIF
			else
				if drawPart[1] & bShowRailOnFloorPlan then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[1]) then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif
					xNosing = nosing * drawDetails[1]

					if bSymbolic2D then
						bShowRailOn1stRun		= 1
						bShowRailOn1stLanding1	= 1
						bShowRailOn1stLanding2	= 1
						bShowRailOn1stLanding3	= 1
						bShowRailOn2ndRun		= 0
						bBreakRailLine			= 0
						bRailAboveBreakLine		= 0
						gosub "right rail"

						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn1stLanding3	= 0
						bShowRailOn2ndRun		= 1
						bBreakRailLine			= 1
						brLineAngle				= -bet
						bShowRailPart1			= 1
						if bComplexRailRight then
							breakLineDist		= a-flightWidth+treadDepth/2 - xNosing - ((nRisers1stRun)*treadDepth-(NumStline+1)*treadDepth+(rightRailFrameThk+rightRailOffset)*tan(bet))\
												-max(nRisers2ndRun - nRisers1stRun, 0) * treadDepth
						else
							breakLineDist		= a-flightWidth+treadDepth - xNosing - ((nRisers1stRun)*treadDepth-(NumStline+1)*treadDepth+(rightRailFrameThk+rightRailOffset)*tan(bet))\
												-max(nRisers2ndRun - nRisers1stRun, 0) * treadDepth
						endif
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 0
						gosub "right rail"
					else
						POLY2_b 9, 1+2+4+64, gs_fill_pen, gs_back_pen,
							flightWidth-rightRailOffset,-rightRailOvhgBottom,1,
							flightWidth-rightRailOffset-rightRailFrameThk,-rightRailOvhgBottom,1,
							flightWidth-rightRailOffset-rightRailFrameThk,(nRisers1stRun)*treadDepth+flightWidth-rightRailOffset-rightRailFrameThk,1,
							-b+flightWidth+rightRailOffset+rightRailFrameThk,(nRisers1stRun)*treadDepth+flightWidth-rightRailOffset-rightRailFrameThk,1,
							-b+flightWidth+rightRailOffset+rightRailFrameThk,(nRisers1stRun)*treadDepth-(NumStline+1)*treadDepth+(rightRailFrameThk+rightRailOffset)*tan(bet),1,
							-b+flightWidth+rightRailOffset,(nRisers1stRun)*treadDepth-(NumStline+1)*treadDepth+(rightRailOffset)*tan(bet),1,
							-b+flightWidth+rightRailOffset,(nRisers1stRun)*treadDepth+flightWidth-rightRailOffset,1,
							flightWidth-rightRailOffset,(nRisers1stRun)*treadDepth+flightWidth-rightRailOffset,1,
							flightWidth-rightRailOffset,-rightRailOvhgBottom,-1
					endif
				endif

				if drawPart[2] & bShowRailOnFloorPlan and bShowRailAboveBreakLine then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[2]) then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif

					if bSymbolic2D then
						xNosing = nosing * NOT(drawDetails[2])
						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn1stLanding3	= 0
						bShowRailOn2ndRun		= 1
						bBreakRailLine			= 1
						brLineAngle				= -bet
						bShowRailPart2			= 1
						if bComplexRailRight then
							breakLineDist		= a-flightWidth+treadDepth/2 - nosing - ((nRisers1stRun)*treadDepth-(NumStline+1)*treadDepth+(rightRailFrameThk+rightRailOffset)*tan(bet))\
												-max(nRisers2ndRun - nRisers1stRun, 0) * treadDepth
						else
							breakLineDist		= a-flightWidth+treadDepth - nosing - ((nRisers1stRun)*treadDepth-(NumStline+1)*treadDepth+(rightRailFrameThk+rightRailOffset)*tan(bet))\
												-max(nRisers2ndRun - nRisers1stRun, 0) * treadDepth
						endif
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 1
						gosub "right rail"
					else
						xNosing = nosing * drawDetails[2]
						POLY2_b 5, 1+2*gs_FillAbove+4+64, gs_fill_pen, gs_back_pen,
							-b+flightWidth+rightRailOffset,(nRisers1stRun)*treadDepth-(NumStline+1)*treadDepth+(rightRailOffset)*tan(bet)-breakLineWidth,1,
							-b+flightWidth+rightRailOffset+rightRailFrameThk,(nRisers1stRun)*treadDepth-(NumStline+1)*treadDepth+(rightRailFrameThk+rightRailOffset)*tan(bet)-breakLineWidth,1,
							-b+flightWidth+rightRailOffset+rightRailFrameThk,(nRisers1stRun)*treadDepth-nRisers2ndRun*treadDepth-rightRailOvhgTop,1,
							-b+flightWidth+rightRailOffset,(nRisers1stRun)*treadDepth-nRisers2ndRun*treadDepth-rightRailOvhgTop,1,
							-b+flightWidth+rightRailOffset,(nRisers1stRun)*treadDepth-(NumStline+1)*treadDepth+(rightRailOffset)*tan(bet)-breakLineWidth,-1
					endif
				endif

				if bShowRailAxis then
					line_type railAxisLineType
					pen gs_RailAxisPen

					if drawPart[1] then
						xNosing = nosing * drawDetails[1]
						LINE2 flightWidth-rightRailOffset-rightRailFrameThk/2, (nRisers1stRun)*treadDepth+flightWidth-rightRailOffset-rightRailFrameThk/2,
							flightWidth-rightRailOffset-rightRailFrameThk/2,-rightRailOvhgBottom
						LINE2 -b+flightWidth+rightRailOffset+rightRailFrameThk/2, (nRisers1stRun)*treadDepth+flightWidth-rightRailOffset-rightRailFrameThk/2,\
							flightWidth-rightRailOffset-rightRailFrameThk/2,(nRisers1stRun)*treadDepth+flightWidth-rightRailOffset-rightRailFrameThk/2
						LINE2 -b+flightWidth+rightRailOffset+rightRailFrameThk/2, (nRisers1stRun)*treadDepth+xNosing-(NumStline+1)*treadDepth+(rightRailFrameThk/2+rightRailOffset)*tan(bet),\
							-b+flightWidth+rightRailOffset+rightRailFrameThk/2,(nRisers1stRun)*treadDepth+flightWidth-rightRailOffset-rightRailFrameThk/2
					endif
					if drawPart[2] then
						xNosing = nosing * drawDetails[2]
						LINE2 -b+flightWidth+rightRailOffset+rightRailFrameThk/2, (nRisers1stRun)*treadDepth+xnosing-(NumStline+1)*treadDepth+(rightRailFrameThk/2+rightRailOffset)*tan(bet)-breakLineWidth,\
							-b+flightWidth+rightRailOffset+rightRailFrameThk/2,(nRisers1stRun)*treadDepth-nRisers2ndRun*treadDepth-rightRailOvhgTop
					endif
				endif
			endif
		endif
	endif
endif


! ==============================================================================
! Text / Up - Down Text / Numbering
! ==============================================================================

! --- Oriented View ------------------------------------------------------------
angleViewRot = 0
if bShowRiseAndRunText | walkingDirUPDN_m <> 1 | drawNum | gs_description <> "" then
	rrr = REQUEST ("View_Rotangle", "", angleViewRot)
endif
totalRotate = (SYMB_ROTANGLE + angleViewRot) MOD 360


! --- Define Font Style --------------------------------------------------------

define style "UPDN" fontType, UPDNfontsize, 5, 0		  	! UP/DN

define style "stepnum" fontType, gs_NumTextSize, 1, 0		! Numbering

define style "description" fontType, gs_desc_text_size, 4, 0	! Description

! --- Rise & Run Text -------------------------------------------------------

if bShowRiseAndRunText & bShowWalkLine & not(belowStory) then
	call "Stair_RiseRun_Text" PARAMETERS ALL	totalRotate	= totalRotate,
												iRotateType = 2,
												iRiseRunTextPosition = 1,
												RiseRunUNID	= RiseRunUNID
endif


! --- Up & Down Text ---------------------------------------------------------
iReadable = 0
if walkingDirUPDN_m <> 1 & bShowWalkLine & not(belowStory) then		! None
	DRAWINDEX 50
	PEN UPDNfontpen
	xNosing = nosing * (drawDetails[1]|drawDetails[3])

	if (walkingDirUPDN_m = 2 | walkingDirUPDN_m = 5 | (walkingDirUPDN_m = 6 & not(abovestory) & not(belowstory) )) & (drawPart[1]|drawPart[3]) then
		nTransUPDN = 0
		set style "UPDN"
		add2 flightWidth/2+DirUPDN_X,DirUPDN_Y-xNosing
		nTransUPDN = nTransUPDN + 1
		! Text Rotation - Readable / Parallel with Walking Line / Align with Symbol
		! ----------------------------------------------------------------------
		if typeTextRotation_UpDn_m = 2 then									! Readable
			if ((totalRotate  > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps)) & SYMB_MIRRORED) | \
				((totalRotate  < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps)) & not(SYMB_MIRRORED)) then
				rot2 180
				nTransUPDN = nTransUPDN + 1
			endif
		else
			if typeTextRotation_UpDn_m = 1 then								! Parallel with Walking Line
				iReadable = (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps))- not(totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps))
				rot2 -90 * iReadable
				nTransUPDN = nTransUPDN + 1
			endif
		endif
		! ----------------------------------------------------------------------
		rot2 AngUPDN
		nTransUPDN = nTransUPDN + 1

		string1	= `ВВЕРХ`
		text2 0,0, string1

		del nTransUPDN

		width1	= STW (string1)/1000*GLOB_SCALE
		rb		= width1/2
	endif

	if walkingDirUPDN_m = 3 & (drawPart[1]|drawPart[3]) then ! Down at Bottom
		nTransUPDN = 0
		set style "UPDN"
		add2 flightWidth/2+DirUPDN_X,DirUPDN_Y-xNosing
		nTransUPDN = nTransUPDN + 1

		! Text Rotation - Readable / Parallel with Walking Line / Align with Symbol
		! ----------------------------------------------------------------------
		if typeTextRotation_UpDn_m = 2 then									! Readable
			if ((totalRotate  > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps)) & SYMB_MIRRORED) | \
				((totalRotate  < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps)) & not(SYMB_MIRRORED)) then
				rot2 180
				nTransUPDN = nTransUPDN + 1
			endif
		else
			if typeTextRotation_UpDn_m = 1 then								! Parallel with Walking Line
				iReadable = (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps))- not(totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps))
				rot2 -90 * iReadable
				nTransUPDN = nTransUPDN + 1
			endif
		endif
		! ----------------------------------------------------------------------
		rot2 AngUPDN
		nTransUPDN = nTransUPDN + 1

		text2 0,0, gs_CustomText_Down

		del nTransUPDN

		string2	= gs_CustomText_Down
		width2	= STW (string2)/1000*GLOB_SCALE
		rb		= width2/2
	endif

	if (walkingDirUPDN_m = 2 | walkingDirUPDN_m = 5 | walkingDirUPDN_m = 3 | (walkingDirUPDN_m = 6 & not(abovestory) & not(belowstory))) & (drawPart[1]|drawPart[3]) then
		nTransHotspot = 0
		add2 flightWidth/2+DirUPDN_X,DirUPDN_Y-xNosing
		nTransHotspot = nTransHotspot  + 1
		if typeTextRotation_UpDn_m = 1 then
			rot2 -90 * iReadable
			nTransHotspot = nTransHotspot  + 1
		endif
		HOTSPOT2 0,					0,				UpDownUNID,	AngUPDN,	6		: UpDownUNID=UpDownUNID+1
		HOTSPOT2 rb,				0,				UpDownUNID,	AngUPDN,	4+128	: UpDownUNID=UpDownUNID+1
		HOTSPOT2 rb*cos(AngUPDN),	rb*sin(AngUPDN),UpDownUNID,	AngUPDN,	5		: UpDownUNID=UpDownUNID+1
		DEL nTransHotspot
	endif

	if (walkingDirUPDN_m = 4 | walkingDirUPDN_m = 5 | (walkingDirUPDN_m = 6 & abovestory)) & (drawPart[2]|drawPart[3]) then
		nTransUPDN = 0
		set style "UPDN"
		add2 -B+3*flightWidth/2+DirUPDN_X_top,DirUPDN_Y_top
		nTransUPDN = nTransUPDN + 1

		! Text Rotation - Readable / Parallel with Walking Line / Align with Symbol
		! ----------------------------------------------------------------------
		if typeTextRotation_UpDn_m = 2 then									! Readable
			if ((totalRotate  > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps)) & SYMB_MIRRORED) | \
				((totalRotate  < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps)) & not(SYMB_MIRRORED)) then
				rot2 180
				nTransUPDN = nTransUPDN + 1
			endif
		else
			if typeTextRotation_UpDn_m = 1 then								! Parallel with Walking Line
				iReadable = (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps))- not(totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps))
				rot2 -90 * iReadable
				nTransUPDN = nTransUPDN + 1
			endif
		endif
		! ----------------------------------------------------------------------
		rot2 AngUPDN_top
		nTransUPDN = nTransUPDN + 1

		text2 0,0, gs_CustomText_Down

		del nTransUPDN

		string2	= gs_CustomText_Down
		width2	= STW (string2)/1000*GLOB_SCALE
		rb		= width2/2
	endif

	if (walkingDirUPDN_m = 4 | walkingDirUPDN_m = 5 | (walkingDirUPDN_m = 6 & abovestory)) & (drawPart[2]|drawPart[3]) then
		nTransHotspot = 0
		ADD2 -B+3*flightWidth/2+DirUPDN_X_top,DirUPDN_Y_top
		nTransHotspot = nTransHotspot  + 1
		if typeTextRotation_UpDn_m = 1 then
			rot2 -90 * iReadable
			nTransHotspot = nTransHotspot  + 1
		endif
		HOTSPOT2 0,						0,					UpDownUNID,	AngUPDN_top,	6		: UpDownUNID=UpDownUNID+1
		HOTSPOT2 rb,					0,					UpDownUNID,	AngUPDN_top,	4+128	: UpDownUNID=UpDownUNID+1
		HOTSPOT2 rb*cos(AngUPDN_top),	rb*sin(AngUPDN_top),UpDownUNID,	AngUPDN_top,	5		: UpDownUNID=UpDownUNID+1
		DEL nTransHotspot
	endif
endif

! --- Numbering ----------------------------------------------------------------

if drawNum & not(belowStory) then
	startNumber	= 1
	endNumber	= nRisers1stRun

	xNosing = nosing * (drawDetails[1]|drawDetails[3])

	for iNumFlight = 1 to 2
		DRAWINDEX 50

		set style "stepnum"
		nnn = REQUEST ("Height_of_style", "stepnum", strHeight)
		strHeight = strHeight / 1000 * GLOB_SCALE

		add2 DirNumText_X, DirNumText_Y - treadDepth/2- xNosing

		for iNumStep = startNumber to endNumber
			add2 0, treadDepth
			pen gs_NumTextPen
			nTextTransformations = 0
			! Text Rotation - Readable / Align with Symbol
			! ----------------------------------------------------------------------
			if typeTextRotation_Num_m = 2 then								! Readable

				doRotate = 0
				if (iNumFlight = 1) exor SYMB_MIRRORED then
					if totalRotate < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps) then doRotate = 1
				else
					if totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps) then doRotate = 1
				endif

				if doRotate = 1 then
					rot2 180
					strWidth = STW(str("%.0", iNumStep + nStartNumbering-1)) / 1000 * GLOB_SCALE
					add2 -strWidth, strHeight
					nTextTransformations = 2
				endif
			endif
			! ----------------------------------------------------------------------
			text2 0,0,iNumStep + nStartNumbering-1
			if nTextTransformations > 0 then del nTextTransformations
		next iNumStep
		del (endNumber - startNumber + 1) + 1

		startNumber = nRisers1stRun + 1
		endNumber = nRisers1stRun + nRisers2ndRun
		add2 -b + 2 * flightWidth,(nRisers1stRun) * treadDepth
		rot2 180
	next iNumFlight
	del 4

	hotspot2 0,				DirNumText_Y-xNosing,	unID, DirNumText_X, 1+128	:unID=unID+1
	hotspot2 -1,			DirNumText_Y-xNosing,	unID, DirNumText_X, 3		:unID=unID+1
	hotspot2 DirNumText_X,	DirNumText_Y-xNosing,	unID, DirNumText_X, 2		:unID=unID+1

	hotspot2 DirNumText_X, -xNosing,				unID, DirNumText_Y, 1+128	:unID=unID+1
	hotspot2 DirNumText_X, -1-xNosing,				unID, DirNumText_Y, 3		:unID=unID+1
	hotspot2 DirNumText_X, DirNumText_Y-xNosing,	unID, DirNumText_Y, 2		:unID=unID+1
endif

! --- Description ----------------------------------------------------------------

if STRLEN(gs_description) <> 0 & not(belowStory) then

	dim gs_description_bpos[3][3]
	gs_description_bpos[1][1] = flightWidth - B/2
	gs_description_bpos[1][2] = A-flightWidth/2
	gs_description_bpos[1][3] = 0

	style "description"
	pen gs_desc_text_pen
	add2 (gs_description_bpos[1][1] + gs_description_pos[1][1]), (gs_description_bpos[1][2] + gs_description_pos[1][2])

	textangle = (gs_description_bpos[1][3] + gs_description_pos[1][3])

	reversedText = 0
	angleFull = (totalRotate + textangle) MOD 360

	if angleFull < 0 then
		angleFull = angleFull + 360
	endif
	if angleFull > (gs_readable_angle+eps) & angleFull < (gs_readable_angle + 180 +eps) then
		reversedText = 1
		textangle = textangle + 180
	endif
	rot2 textangle

	if reversedText then
		text2 -STW(gs_description) / 1000 * GLOB_SCALE, 0, gs_description
	else
		text2 0,0, gs_description
	endif

	del 2
	hotspot2 gs_description_bpos[1][1], gs_description_bpos[1][2] + gs_description_pos[1][2], 40000+1, gs_description_pos[1][1], 1 + 128
	posRel = gs_description_pos[1][1]
	if abs(posRel) < 0.00001 then
		posRel = 0.0001
	else
		posRel = 0
	endif
	hotspot2 gs_description_bpos[1][1] - posRel, gs_description_bpos[1][2] + gs_description_pos[1][2], 40000+2, gs_description_pos[1][1], 3 + 128
	hotspot2 gs_description_bpos[1][1] + gs_description_pos[1][1], gs_description_bpos[1][2] + gs_description_pos[1][2], 40000+3, gs_description_pos[1][1], 2

	hotspot2 gs_description_bpos[1][1] + gs_description_pos[1][1], gs_description_bpos[1][2], 40000+4, gs_description_pos[1][2], 1 + 128
	posRel = gs_description_pos[1][2]
	if abs(posRel) < 0.00001 then
		posRel = 0.0001
	else
		posRel = 0
	endif
	hotspot2 gs_description_bpos[1][1] + gs_description_pos[1][1], gs_description_bpos[1][2] - posRel, 40000+5, gs_description_pos[1][2], 3 + 128
	hotspot2 gs_description_bpos[1][1] + gs_description_pos[1][1], gs_description_bpos[1][2] + gs_description_pos[1][2], 40000+6, gs_description_pos[1][2], 2

	!angle edit
	HOTSPOT2 gs_description_bpos[1][1] + gs_description_pos[1][1],
				gs_description_bpos[1][2] + gs_description_pos[1][2],
				40000+7, gs_description_pos[1][3], 6 + 128

	HOTSPOT2 gs_description_bpos[1][1] + gs_description_pos[1][1] + GLOB_SCALE*0.5*COS(gs_description_bpos[1][3])*gs_desc_text_size/1000,
				gs_description_bpos[1][2] + gs_description_pos[1][2] + GLOB_SCALE*0.5*SIN(gs_description_bpos[1][3])*gs_desc_text_size/1000,
				40000+8, gs_description_pos[1][3], 4 + 128

	HOTSPOT2 gs_description_bpos[1][1] + gs_description_pos[1][1] + GLOB_SCALE*0.5*gs_desc_text_size*COS(gs_description_bpos[1][3] + gs_description_pos[1][3])/1000,
				gs_description_bpos[1][2] + gs_description_pos[1][2] + GLOB_SCALE*0.5*gs_desc_text_size*SIN(gs_description_bpos[1][3] + gs_description_pos[1][3])/1000,
				40000+9, gs_description_pos[1][3], 5
endif

!===================================================================
! HOTSPOT EDITING in 2D
!===================================================================
DRAWINDEX 50
!-- FLIGHT WIDTH ---------------------------------------------------
DEL 1
xNosing = nosing * (drawDetails[1]|drawDetails[3])

HOTSPOT2 flightWidth,	a-flightWidth-nRisers1stRun*treadDepth,	FlightUNID, flightWidth, 1+256	: FlightUNID=FlightUNID+1
HOTSPOT2 0,				a-flightWidth-nRisers1stRun*treadDepth, FlightUNID, flightWidth, 2		: FlightUNID=FlightUNID+1
HOTSPOT2 flightWidth+1,	a-flightWidth-nRisers1stRun*treadDepth,	FlightUNID, flightWidth, 3		: FlightUNID=FlightUNID+1

HOTSPOT2 -b+flightWidth,	a-flightWidth-nRisers2ndRun*treadDepth,	FlightUNID, flightWidth, 1+128	: FlightUNID=FlightUNID+1
HOTSPOT2 -b+2*flightWidth,	a-flightWidth-nRisers2ndRun*treadDepth, FlightUNID, flightWidth, 2		: FlightUNID=FlightUNID+1
HOTSPOT2 -b+flightWidth-1,	a-flightWidth-nRisers2ndRun*treadDepth,	FlightUNID, flightWidth, 3		: FlightUNID=FlightUNID+1

HOTSPOT2 flightWidth,		a,	FlightUNID, b, 1+256	: FlightUNID=FlightUNID+1
HOTSPOT2 -b+flightWidth,	a,	FlightUNID, b, 2		: FlightUNID=FlightUNID+1
HOTSPOT2 b+1,				a,	FlightUNID, b, 3		: FlightUNID=FlightUNID+1

HOTSPOT2 flightWidth,		a-flightWidth-nRisers1stRun*treadDepth,	FlightUNID, b, 1+256	: FlightUNID=FlightUNID+1
HOTSPOT2 -b+flightWidth,	a-flightWidth-nRisers1stRun*treadDepth, FlightUNID, b, 2		: FlightUNID=FlightUNID+1
HOTSPOT2 b+1,				a-flightWidth-nRisers1stRun*treadDepth,	FlightUNID, b, 3		: FlightUNID=FlightUNID+1

HOTSPOT2 flightWidth,		a-flightWidth-nRisers1stRun*treadDepth,		FlightUNID, a, 1+256	: FlightUNID=FlightUNID+1
HOTSPOT2 flightWidth,		a,											FlightUNID, a, 2		: FlightUNID=FlightUNID+1
HOTSPOT2 flightWidth,		a-flightWidth-nRisers1stRun*treadDepth-1,	FlightUNID, a, 3		: FlightUNID=FlightUNID+1

HOTSPOT2 -b+flightWidth,	a-flightWidth-nRisers2ndRun*treadDepth,		FlightUNID, a, 1+256	: FlightUNID=FlightUNID+1
HOTSPOT2 -b+flightWidth,	a,											FlightUNID, a, 2		: FlightUNID=FlightUNID+1
HOTSPOT2 -b+flightWidth,	a-flightWidth-nRisers2ndRun*treadDepth-1,	FlightUNID, a, 3		: FlightUNID=FlightUNID+1

!!! UP/DOWN TEXT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
IF bShowWalkLine & not(belowStory) THEN
IF walkingDirUPDN_m = 2 | walkingDirUPDN_m = 3 | walkingDirUPDN_m = 5 then
	HOTSPOT2 flightWidth/2,				DirUPDN_Y-xNosing, UpDownUNID, DirUPDN_X, 1+128 : UpDownUNID=UpDownUNID+1
	HOTSPOT2 flightWidth/2-1,			DirUPDN_Y-xNosing, UpDownUNID, DirUPDN_X, 3		: UpDownUNID=UpDownUNID+1
	HOTSPOT2 flightWidth/2+DirUPDN_X,	DirUPDN_Y-xNosing, UpDownUNID, DirUPDN_X, 2		: UpDownUNID=UpDownUNID+1

	HOTSPOT2 flightWidth/2+DirUPDN_X,	0,			UpDownUNID, DirUPDN_Y, 1+128	: UpDownUNID=UpDownUNID+1
	HOTSPOT2 flightWidth/2+DirUPDN_X,	-1,			UpDownUNID, DirUPDN_Y, 3		: UpDownUNID=UpDownUNID+1
	HOTSPOT2 flightWidth/2+DirUPDN_X,	DirUPDN_Y-xNosing,	UpDownUNID, DirUPDN_Y, 2		: UpDownUNID=UpDownUNID+1
ENDIF
IF walkingDirUPDN_m = 4 | walkingDirUPDN_m = 5 then
	HOTSPOT2 -B+3*flightWidth/2,		DirUPDN_Y_top,			UpDownUNID, DirUPDN_X_top, 1+128	: UpDownUNID=UpDownUNID+1
	HOTSPOT2 -B+3*flightWidth/2-1,		DirUPDN_Y_top,			UpDownUNID, DirUPDN_X_top, 3		: UpDownUNID=UpDownUNID+1
	HOTSPOT2 -B+3*flightWidth/2+DirUPDN_X_top,	DirUPDN_Y_top,	UpDownUNID, DirUPDN_X_top, 2		: UpDownUNID=UpDownUNID+1

	HOTSPOT2 -B+3*flightWidth/2+DirUPDN_X_top,	0,			UpDownUNID, DirUPDN_Y_top, 1+128: UpDownUNID=UpDownUNID+1
	HOTSPOT2 -B+3*flightWidth/2+DirUPDN_X_top,	-1,			UpDownUNID, DirUPDN_Y_top, 3	: UpDownUNID=UpDownUNID+1
	HOTSPOT2 -B+3*flightWidth/2+DirUPDN_X_top,DirUPDN_Y_top,UpDownUNID, DirUPDN_Y_top, 2	: UpDownUNID=UpDownUNID+1
ENDIF
endif

!-- RAILING  ---------------------------------------------------
if _bShowRailIn2D & bShowRailOnFloorPlan & not(belowStory) then
xNosing = 0 ! COMP nosing * (drawDetails[1]|drawDetails[3])

IF rail_m = 2 | rail_m = 1 THEN		! Right, Both

	!!! RAIL OFFSET - right
	HOTSPOT2 -b+flightWidth+rightRailFrameThk/2,				a-flightWidth-nRisers2ndRun*treadDepth-rightRailOvhgTop, RailUNID, rightRailOffset, 1+128 : RailUNID=RailUNID+1
	HOTSPOT2 -b+flightWidth+rightRailFrameThk/2+rightRailOffset,a-flightWidth-nRisers2ndRun*treadDepth-rightRailOvhgTop, RailUNID, rightRailOffset, 2 : RailUNID=RailUNID+1
	HOTSPOT2 -b+flightWidth+rightRailFrameThk/2,				a-flightWidth-nRisers2ndRun*treadDepth-rightRailOvhgTop, RailUNID, rightRailOffset, 3 : RailUNID=RailUNID+1

	HOTSPOT2 flightWidth-rightRailFrameThk/2,					a-flightWidth-nRisers1stRun*treadDepth-rightRailOvhgBottom-xNosing, RailUNID, rightRailOffset, 1+128 : RailUNID=RailUNID+1
	HOTSPOT2 flightWidth-rightRailFrameThk/2-rightRailOffset,	a-flightWidth-nRisers1stRun*treadDepth-rightRailOvhgBottom-xNosing, RailUNID, rightRailOffset, 2 : RailUNID=RailUNID+1
	HOTSPOT2 flightWidth-rightRailFrameThk/2-0.1,				a-flightWidth-nRisers1stRun*treadDepth-rightRailOvhgBottom-xNosing, RailUNID, rightRailOffset, 3 : RailUNID=RailUNID+1

	! RAIL BOTTOM OVERHANG
	HOTSPOT2 flightWidth-rightRailFrameThk/2-rightRailOffset,		a-flightWidth-nRisers1stRun*treadDepth-xNosing,						RailUNID, rightRailOvhgBottom, 1+128 : RailUNID=RailUNID+1
	HOTSPOT2 flightWidth-rightRailFrameThk/2-rightRailOffset,		a-flightWidth-nRisers1stRun*treadDepth+1-xNosing,					RailUNID, rightRailOvhgBottom, 3 : RailUNID=RailUNID+1
	HOTSPOT2 flightWidth-rightRailFrameThk/2-rightRailOffset,		a-flightWidth-nRisers1stRun*treadDepth-rightRailOvhgBottom-xNosing, RailUNID, rightRailOvhgBottom, 2 : RailUNID=RailUNID+1

	!!! RAIL TOP OVERHANG
	HOTSPOT2 -b+flightWidth+rightRailFrameThk/2+rightRailOffset,	a-flightWidth-nRisers2ndRun*treadDepth,					RailUNID, rightRailOvhgTop, 1+128 : RailUNID=RailUNID+1
	HOTSPOT2 -b+flightWidth+rightRailFrameThk/2+rightRailOffset,	a-flightWidth-nRisers2ndRun*treadDepth+1,				RailUNID, rightRailOvhgTop, 3 : RailUNID=RailUNID+1
	HOTSPOT2 -b+flightWidth+rightRailFrameThk/2+rightRailOffset,	a-flightWidth-nRisers2ndRun*treadDepth-rightRailOvhgTop,RailUNID, rightRailOvhgTop, 2 : RailUNID=RailUNID+1
ENDIF

IF rail_m = 3 | rail_m = 1 THEN		! Left, Both

	!!! RAIL OFFSET - left
	HOTSPOT2 -b+2*flightWidth-leftRailFrameThk/2,				a-flightWidth-nRisers2ndRun*treadDepth-leftRailOvhgTop, RailUNID, leftRailOffset, 1+128 : RailUNID=RailUNID+1
	HOTSPOT2 -b+2*flightWidth-leftRailFrameThk/2-leftRailOffset,a-flightWidth-nRisers2ndRun*treadDepth-leftRailOvhgTop, RailUNID, leftRailOffset, 2 : RailUNID=RailUNID+1
	HOTSPOT2 -b+2*flightWidth-leftRailFrameThk/2-0.1,			a-flightWidth-nRisers2ndRun*treadDepth-leftRailOvhgTop, RailUNID, leftRailOffset, 3 : RailUNID=RailUNID+1

	HOTSPOT2 leftRailFrameThk/2,				a-flightWidth-nRisers1stRun*treadDepth-leftRailOvhgBottom-xNosing, RailUNID, leftRailOffset, 1+128 : RailUNID=RailUNID+1
	HOTSPOT2 leftRailFrameThk/2+leftRailOffset,	a-flightWidth-nRisers1stRun*treadDepth-leftRailOvhgBottom-xNosing, RailUNID, leftRailOffset, 2 : RailUNID=RailUNID+1
	HOTSPOT2 leftRailFrameThk/2+0.1,			a-flightWidth-nRisers1stRun*treadDepth-leftRailOvhgBottom-xNosing, RailUNID, leftRailOffset, 3 : RailUNID=RailUNID+1

	! RAIL BOTTOM OVERHANG
	HOTSPOT2 leftRailFrameThk/2+leftRailOffset,	a-flightWidth-nRisers1stRun*treadDepth-xNosing,						RailUNID, leftRailOvhgBottom, 1+128 : RailUNID=RailUNID+1
	HOTSPOT2 leftRailFrameThk/2+leftRailOffset,	a-flightWidth-nRisers1stRun*treadDepth+1-xNosing,					RailUNID, leftRailOvhgBottom, 3		: RailUNID=RailUNID+1
	HOTSPOT2 leftRailFrameThk/2+leftRailOffset,	a-flightWidth-nRisers1stRun*treadDepth-leftRailOvhgBottom-xNosing,	RailUNID, leftRailOvhgBottom, 2		: RailUNID=RailUNID+1


	!!! RAIL TOP OVERHANG
	HOTSPOT2 -b+2*flightWidth-leftRailFrameThk/2-leftRailOffset,		a-flightWidth-nRisers2ndRun*treadDepth,					RailUNID, leftRailOvhgTop, 1+128: RailUNID=RailUNID+1
	HOTSPOT2 -b+2*flightWidth-leftRailFrameThk/2-leftRailOffset,		a-flightWidth-nRisers2ndRun*treadDepth+1,				RailUNID, leftRailOvhgTop, 3	: RailUNID=RailUNID+1
	HOTSPOT2 -b+2*flightWidth-leftRailFrameThk/2-leftRailOffset,		a-flightWidth-nRisers2ndRun*treadDepth-leftRailOvhgTop, RailUNID, leftRailOvhgTop, 2	: RailUNID=RailUNID+1
ENDIF
endif

del 1

END


"Start End Symbol":
	DRAWINDEX 45
	fill gs_StartEndFill

	if gs_StartEndFillPen <> 0 then
		temp_FillStatus = 2
	else
		temp_FillStatus = 0
	endif

	add2 0, +xNosing
	IF gs_StartEndStyle_m = 1 THEN		! Style 1
		POLY2_B 2, 1+temp_FillStatus, gs_StartEndFillPen, gs_fill_pen,
		0,-xNosing,901,
		gs_CircleRadius,360,4001
	ENDIF

	IF gs_StartEndStyle_m = 2 THEN		! Style 2
		FOR kk=1 TO 2
			POLY2_B 6, 1+temp_FillStatus, gs_StartEndFillPen, gs_fill_pen,
				0,-xNosing,1,
				0+gs_CircleRadius,-xNosing,1,
				0,-xNosing,901,
				0,90,4001,
				0,-xNosing+gs_CircleRadius,0,
				0,-xNosing,-1

			POLY2_B 6, 1, gs_StartEndFillPen, gs_fill_pen,
				0,-xNosing,1,
				0,-xNosing+gs_CircleRadius,1,
				0,-xNosing,901,
				0,90,4001,
				0-gs_CircleRadius,-xNosing,0,
				0,-xNosing,-1
		ROT2 180
		ADD2 0, 2*xNosing
		NEXT kk
		DEL 4
	ENDIF

	IF gs_StartEndStyle_m = 3 THEN		! Style 3
		LINE2 0+gs_StartWidth,-xNosing-gs_StartHeight,0+gs_StartWidth,-xNosing+gs_StartHeight
		LINE2 0-gs_StartWidth,-xNosing-gs_StartHeight,0-gs_StartWidth,-xNosing+gs_StartHeight
	ENDIF

	! --- Hotspots of StartEnd Symbol
	IF gs_StartEndStyle_m = 1 | gs_StartEndStyle_m = 2 THEN		! Style 1-2
		ADD2 0,-xNosing
			FOR kk=1 to 4
				HOTSPOT2 0, 0,					StartSymbUNID, gs_CircleRadius, 1+128	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 -1, 0,					StartSymbUNID, gs_CircleRadius, 3+128	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_CircleRadius, 0,	StartSymbUNID, gs_CircleRadius,2		:StartSymbUNID=StartSymbUNID+1

				ROT2 90
			NEXT KK
			DEL 4
		DEL 1
	ENDIF

	IF gs_StartEndStyle_m = 3 THEN		! Style 3
		FOR kk=1 to 2
			ADD2 0, -xNosing
				! Symbol Width/2
				HOTSPOT2 0,				-gs_StartHeight, StartSymbUNID, gs_StartWidth, 1+128:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 -1,			-gs_StartHeight, StartSymbUNID, gs_StartWidth, 3	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, -gs_StartHeight, StartSymbUNID, gs_StartWidth, 2	:StartSymbUNID=StartSymbUNID+1

				HOTSPOT2 0,				gs_StartHeight, StartSymbUNID, gs_StartWidth, 1+128	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 -1,			gs_StartHeight, StartSymbUNID, gs_StartWidth, 3		:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, gs_StartHeight, StartSymbUNID, gs_StartWidth,2		:StartSymbUNID=StartSymbUNID+1
			DEL 1

			ADD2 0, -xNosing
				! Symbol Height
				HOTSPOT2 gs_StartWidth, 0,				StartSymbUNID, gs_StartHeight, 1+128:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, -1,				StartSymbUNID, gs_StartHeight, 3	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, gs_StartHeight, StartSymbUNID, gs_StartHeight, 2	:StartSymbUNID=StartSymbUNID+1

				HOTSPOT2 gs_StartWidth, 0,					StartSymbUNID, gs_StartHeight, 1+128:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, 1,					StartSymbUNID, gs_StartHeight, 3	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, -gs_StartHeight,	StartSymbUNID, gs_StartHeight, 2	:StartSymbUNID=StartSymbUNID+1
			DEL 1

		MUL2 -1,1
		NEXT kk
		DEL 2
	ENDIF
	del 1

	DRAWINDEX 40
RETURN


"Arrowhead Symbol":
	IF arrow_style_m = 1 | arrow_style_m = 4 | arrow_style_m = 7 THEN
		temp_ArrowDist = flightWidth/2
		temp_ArrowHeight = treadDepth
		if not(reverseWalkLine) & (i = 2 | i = 3) & walkingDirUPDN_m <> 5 then temp_ArrowHeight = treadDepth + xNosing
	ENDIF

	IF arrow_style_m = 2 | arrow_style_m = 5 | arrow_style_m = 8 THEN
		temp_ArrowDist = flightWidth/4
		temp_ArrowHeight = treadDepth
		if not(reverseWalkLine) & (i = 2 | i = 3) & walkingDirUPDN_m <> 5 then temp_ArrowHeight = treadDepth + xNosing
	ENDIF

	IF arrow_style_m = 3 | arrow_style_m = 6 | arrow_style_m = 9 THEN
		temp_ArrowDist = gs_ArrowHalfWidth
		temp_ArrowHeight = gs_ArrowHeight
	ENDIF

	if arrow_style_m = 1 | arrow_style_m = 2 | arrow_style_m = 3 then
		temp_ArrowMask=0
	else
		temp_ArrowMask=1
	endif

	POLY2_b 4, 1, penFillArrow, gs_fill_pen,
		-temp_ArrowDist,-temp_ArrowHeight, temp_ArrowMask,
		temp_ArrowDist,-temp_ArrowHeight, 1,
		0,0, 1,
		-temp_ArrowDist,-temp_ArrowHeight, -1

	! --- Arrowhead Fill Contour Points Conditions
	IF arrow_style_m = 4 | arrow_style_m = 5 | arrow_style_m = 6 THEN
		temp_1XFill=temp_ArrowDist
		lengthArrowHead = temp_ArrowHeight
	else
		lengthArrowHead = 0
	ENDIF

	IF arrow_style_m = 7 | arrow_style_m = 8 | arrow_style_m = 9 THEN
		temp_1XFill=0
	ENDIF

	if penFillArrow <> 0 then
		IF arrow_style_m <> 1 & arrow_style_m <> 2 & arrow_style_m <> 3 THEN
			fill gs_ArrowFill ! Always 64 (Foreground)
			POLY2_b 4, 2, penFillArrow, gs_fill_pen,
				-temp_1XFill,-temp_ArrowHeight, temp_ArrowMask,
				temp_ArrowDist,-temp_ArrowHeight, 1,
				0,0, 1,
				-temp_1XFill,-temp_ArrowHeight, -1
		ENDIF
	endif

	HOTSPOT2	0,0,	ArrowUNID: ArrowUNID=ArrowUNID+1

	! --- Hotspot editing of Height & Width of Arrowhead
	IF arrow_style_m = 3 | arrow_style_m = 6 | arrow_style_m = 9 THEN
		HOTSPOT2 gs_ArrowHalfWidth,0,				ArrowUNID, gs_ArrowHeight, 1+128	: ArrowUNID=ArrowUNID+1
		HOTSPOT2 gs_ArrowHalfWidth,-gs_ArrowHeight,	ArrowUNID, gs_ArrowHeight, 2		: ArrowUNID=ArrowUNID+1
		HOTSPOT2 gs_ArrowHalfWidth,1,				ArrowUNID, gs_ArrowHeight, 3		: ArrowUNID=ArrowUNID+1

		HOTSPOT2 -gs_ArrowHalfWidth,0,					ArrowUNID, gs_ArrowHeight, 1+128	: ArrowUNID=ArrowUNID+1
		HOTSPOT2 -gs_ArrowHalfWidth,-gs_ArrowHeight,	ArrowUNID, gs_ArrowHeight, 2		: ArrowUNID=ArrowUNID+1
		HOTSPOT2 -gs_ArrowHalfWidth,1,					ArrowUNID, gs_ArrowHeight, 3		: ArrowUNID=ArrowUNID+1

		HOTSPOT2 0,					-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 1+128	: ArrowUNID=ArrowUNID+1
		HOTSPOT2 gs_ArrowHalfWidth,	-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 2		: ArrowUNID=ArrowUNID+1
		HOTSPOT2 -1,				-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 3		: ArrowUNID=ArrowUNID+1

		HOTSPOT2 0,					-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 1+128 : ArrowUNID=ArrowUNID+1
		HOTSPOT2 -gs_ArrowHalfWidth,-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 2		: ArrowUNID=ArrowUNID+1
		HOTSPOT2 1,					-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 3		: ArrowUNID=ArrowUNID+1
	ENDIF
RETURN


"left rail":

	mul2 -1, 1
	rot2 90
	add2 -max(nRisers2ndRun - nRisers1stRun, 0) * treadDepth, flightWidth

	if bShowRailOn1stRun then
		ADD2 a-flightWidth-nRisers1stRun*treadDepth-leftRailOvhgBottom, -flightWidth+leftRailOffset+leftRailFrameThk/2

		lraSimple=(nRisers1stRun-1)*treadDepth+leftRailOvhgBottom
		lraComplex=(nRisers1stRun-1)*treadDepth
		additionXComplex=leftRailOvhgBottom+treadDepth/2
		additionZComplex=leftRailOvhgBottom*tan(ang)
		hrovL=treadDepth/2+leftRailOvhgBottom
		hrovR=0
		postNumber = ((nRisers-1))/4
		railAngle	= ang
		side = SIDE_LEFT
		gosub "callRailsForStair"

		DEL 1
	endif

	! --- Rails on the landing (left side_1) -------------------------------------
	if bShowRailOn1stLanding1 then
		ADD2 a-flightWidth-treadDepth,-flightWidth+leftRailOffset+leftRailFrameThk/2

		IF leftRailType_m = 7 | leftRailType_m = 8 | leftRailType_m = 9 | leftRailType_m = 10 THEN
			ADD2 treadDepth/2, 0
		endif

		lraSimple=treadDepth+leftRailOffset
		lraComplex=treadDepth/2+leftRailOffset-leftRailPostSize/2+leftRailFrameThk
		hrovL=0
		hrovR=leftRailPostSize/2
		postNumber = (flightWidth+treadDepth/2-leftRailOffset-leftRailPostSize/2)/(3*treadDepth)+1
		side = SIDE_LEFT
		gosub "callRailsForLanding"

		IF leftRailType_m = 7 | leftRailType_m = 8 | leftRailType_m = 9 | leftRailType_m = 10 THEN del 1

		DEL 1
	endif

	! --- Rails on the landing (back) ---
	if bShowRailOn1stLanding2 then
		ADD2 a-flightWidth+leftRailFrameThk/2+leftRailOffset,-flightWidth+leftRailOffset+leftRailFrameThk
		ROT2 -90

		IF b-2*flightWidth+2*leftRailOffset+leftRailFrameThk>=0.05 THEN
			IF leftRailType_m < 7 THEN
				gamma=max(0,ATN(((treadDepth-leftRailFrameThk)*tan(ang)-leftRailOffset*tan(ang))/(b-2*flightWidth+2*leftRailOffset+leftRailFrameThk)))
			else
				gamma=max(0,ATN(((treadDepth/2-leftRailFrameThk)*tan(ang)-leftRailOffset*tan(ang))/(b-2*flightWidth+2*leftRailOffset+leftRailFrameThk)))
			endif

			IF leftRailType_m < 7 or (leftRailType_m > 6 and gamma <= 45) then
				lraSimple=b-2*flightWidth+2*leftRailOffset+leftRailFrameThk
				lraComplex=b-2*flightWidth+2*leftRailOffset + (leftRailFrameThk-leftRailPostSize/2) * (leftRailType_m = 7 or leftRailType_m = 8) - 0.1 * (leftRailType_m = 9)
				additionXComplex=leftRailFrameThk * (leftRailType_m = 9 or leftRailType_m = 10)
				additionZComplex=-leftRailFrameThk*tan(gamma) * (leftRailType_m = 7 or leftRailType_m = 8)
				hrovL=0.05 * (leftRailType_m = 9) - leftRailFrameThk * (leftRailType_m = 7 or leftRailType_m = 8)
				hrovR=0.05 * (leftRailType_m = 9) + leftRailPostSize/2 * (leftRailType_m = 7 or leftRailType_m = 8)
				postNumber = max(2,(b-2*leftRailOffset-2*leftRailFrameThk+leftRailPostSize)/(3*treadDepth))
				railAngle	= gamma
				side = SIDE_LEFT
				gosub "callRailsForStair"
			endif
		ENDIF

		DEL 2
	endif

	! --- Rails on the landing (right side_2) ------------------------------------
	if bShowRailOn1stLanding3 then
		IF leftRailOffset>=treadDepth-leftRailFrameThk THEN
			ADD2 a-flightWidth+treadDepth,-b+flightWidth-leftRailOffset-leftRailFrameThk/2
			IF leftRailOffset-treadDepth+leftRailFrameThk<=0.1 THEN
				ADD2 0, -leftRailFrameThk/2
				IF leftRailType_m = 1 | leftRailType_m = 4 | leftRailType_m = 5 | leftRailType_m = 6 THEN
					poly2_b 4, 1 + 2 * (NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove) + 4+64, gs_fill_pen, gs_back_pen,
						0, 0, 1,
						leftRailOffset-treadDepth+leftRailFrameThk, 0, 1,
						leftRailOffset-treadDepth+leftRailFrameThk, leftRailFrameThk, 1,
						0, leftRailFrameThk, 1
				ENDIF
				DEL 1

				IF leftRailType_m = 2 | leftRailType_m = 3 THEN
					lraSimple=leftRailOffset-treadDepth+leftRailFrameThk
					lraComplex=leftRailOffset-treadDepth+leftRailFrameThk
					hrovL=0
					hrovR=0
					postNumber = 2
					side = SIDE_LEFT
					gosub "callRailsForLanding"
				endif
			ELSE
				IF leftRailType_m > 0 and leftRailType_m < 7 THEN
					lraSimple=leftRailOffset-treadDepth+leftRailFrameThk
					lraComplex=leftRailOffset-treadDepth+leftRailFrameThk
					hrovL=0
					hrovR=0
					postNumber = 2
					side = SIDE_LEFT
					gosub "callRailsForLanding"
				endif
			ENDIF
			DEL 1
		ENDIF

		IF leftRailOffset>=treadDepth/2-leftRailFrameThk THEN
			ADD2 a-flightWidth+leftRailOffset+leftRailFrameThk,-b+flightWidth-leftRailOffset-leftRailFrameThk/2
			IF leftRailOffset+leftRailFrameThk-min(leftRailOffset,treadDepth/2)<=0.2 THEN
				ADD2  0, -leftRailFrameThk/2
				IF leftRailType_m = 7 | leftRailType_m = 8 | leftRailType_m = 9 | leftRailType_m = 10 THEN
					poly2_b 4, 1 + 2 * (NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove) + 4+64, gs_fill_pen, gs_back_pen,
						0, 0, 1,
						-leftRailOffset-leftRailFrameThk+min(leftRailOffset,treadDepth/2), 0, 1,
						-leftRailOffset-leftRailFrameThk+min(leftRailOffset,treadDepth/2), leftRailFrameThk, 1,
						0, leftRailFrameThk, 1
				ENDIF
				DEL 1
			ELSE
				IF leftRailType_m = 7 | leftRailType_m = 8 | leftRailType_m = 9 | leftRailType_m = 10 THEN
					ADD2 -leftRailPostSize/2, 0
					MUL2 -1, 1

					lraSimple=leftRailOffset-min(leftRailOffset,treadDepth/2)
					lraComplex=leftRailOffset-min(leftRailOffset,treadDepth/2)
					hrovL=leftRailPostSize/2
					hrovR=leftRailPostSize/2
					postNumber = (flightWidth+treadDepth/2-leftRailOffset)/(3*treadDepth)+1
					side = SIDE_LEFT
					gosub "callRailsForLanding"

					del 2
				endif
			ENDIF
			DEL 1
		ENDIF
	endif

	! --- Rails on the 2nd Arm ---
	if bShowRailOn2ndRun then
		if bComplexRailLeft then
			ADD2 a-flightWidth-treadDepth/2,-b+flightWidth-leftRailOffset-leftRailFrameThk/2
		else
			ADD2 a-flightWidth+leftRailFrameThk+min(leftRailOffset,treadDepth-leftRailFrameThk), -b+flightWidth-leftRailOffset-leftRailFrameThk/2
		endif
		ROT2 180

		IF leftRailOffset-treadDepth+leftRailFrameThk < eps THEN
			lraSimple=leftRailOffset+(nRisers2ndRun)*treadDepth+leftRailOvhgTop+leftRailFrameThk
		else
			lraSimple=(nRisers2ndRun+1)*treadDepth+leftRailOvhgTop
		endif
		lraComplex=(nRisers2ndRun)*treadDepth-treadDepth
		additionXComplex=0
		additionZComplex=0
		hrovL=treadDepth/2+leftRailFrameThk+min(leftRailOffset,treadDepth/2-leftRailFrameThk)
		hrovR=treadDepth/2+leftRailOvhgTop
		postNumber = ((nRisers2ndRun-1))/2+1
		railAngle	= ang
		side = SIDE_LEFT
		gosub "callRailsForStair"

		del 2
	endif

	del 3
return


"right rail":

	mul2 -1, 1
	rot2 90
	add2 -max(nRisers2ndRun - nRisers1stRun, 0) * treadDepth, flightWidth

	if bShowRailOn1stRun then
		ADD2 a-flightWidth-nRisers1stRun*treadDepth-rightRailOvhgBottom,-rightRailOffset-rightRailFrameThk/2

		lraSimple=(nRisers1stRun-1)*treadDepth+rightRailOvhgBottom
		lraComplex=(nRisers1stRun-1)*treadDepth
		additionXComplex=rightRailOvhgBottom+treadDepth/2
		additionZComplex=rightRailOvhgBottom*tan(ang)
		hrovL=treadDepth/2+rightRailOvhgBottom
		hrovR=0
		postNumber = ((nRisers-1))/4
		railAngle	= ang
		side = SIDE_RIGHT
		gosub "callRailsForStair"

		DEL 1
	endif

	! --- Rails on the landing (right side_1) ------------------------------------
	if bShowRailOn1stLanding1 then
		ADD2 a-flightWidth-treadDepth,-rightRailOffset-rightRailFrameThk/2

		IF rightRailType_m = 7 | rightRailType_m = 8 | rightRailType_m = 9 | rightRailType_m = 10 THEN
			ADD2 treadDepth/2, 0
		endif

		lraSimple=flightWidth+treadDepth-rightRailOffset
		lraComplex=flightWidth+treadDepth/2-rightRailOffset-rightRailPostSize/2
		hrovL=0
		hrovR=rightRailPostSize/2
		postNumber = (flightWidth+treadDepth/2-rightRailOffset-rightRailPostSize/2)/(3*treadDepth)+1
		side = SIDE_RIGHT
		gosub "callRailsForLanding"

		IF rightRailType_m = 7 | rightRailType_m = 8 | rightRailType_m = 9 | rightRailType_m = 10 THEN del 1

		DEL 1
	endif

	! --- Rails on the landing (back) ---
	if bShowRailOn1stLanding2 then
		ADD2 a-rightRailOffset-rightRailFrameThk/2,-rightRailOffset-rightRailFrameThk
		ROT2 -90

		IF rightRailType_m = 7 | rightRailType_m = 8 | rightRailType_m = 9 THEN
			IF rightRailType_m = 7 | rightRailType_m = 8 THEN
				ADD2 -rightRailPostSize/2, 0
			else
				ADD2 treadDepth/2, 0
			endif
		endif

		lraSimple=b-2*rightRailOffset-2*rightRailFrameThk
		lraComplex=b-2*rightRailOffset-2*rightRailFrameThk - treadDepth * (rightRailType_m = 9) + rightRailPostSize * (rightRailType_m = 7 | rightRailType_m = 8)
		hrovL=treadDepth/2 * (rightRailType_m = 9) - rightRailPostSize/2 * (rightRailType_m = 7 | rightRailType_m = 8)
		hrovR=treadDepth/2 * (rightRailType_m = 9) - rightRailPostSize/2 * (rightRailType_m = 7 | rightRailType_m = 8)
		postNumber = (b-2*rightRailOffset-2*rightRailFrameThk+rightRailPostSize)/(3*treadDepth)+1
		side = SIDE_RIGHT
		gosub "callRailsForLanding"

		IF rightRailType_m = 7 | rightRailType_m = 8 | rightRailType_m = 9 THEN del 1

		DEL 2
	endif

	! --- Rails on the landing (right side_2) ------------------------------------
	if bShowRailOn1stLanding3 then
		ADD2 a-flightWidth+treadDepth,-b+rightRailOffset+rightRailFrameThk/2

		IF bComplexRailRight THEN ADD2 -treadDepth/2, 0

		lraSimple=flightWidth-treadDepth-rightRailOffset
		lraComplex=flightWidth-treadDepth/2-rightRailOffset-rightRailPostSize/2 + rightRailPostSize/2 * (rightRailType_m = 9)
		hrovL=0
		hrovR=rightRailPostSize/2
		postNumber = (flightWidth+treadDepth/2-rightRailOffset)/(3*treadDepth)+1
		side = SIDE_RIGHT
		gosub "callRailsForLanding"

		IF bComplexRailRight THEN del 1

		DEL 1
	endif

	! --- Rails on the 2nd Arm ---
	if bShowRailOn2ndRun then
		ADD2 a-flightWidth+treadDepth,-b+rightRailOffset+rightRailFrameThk/2
		ROT2 180

		lraSimple=(nRisers2ndRun+1)*treadDepth+rightRailOvhgTop
		lraComplex=(nRisers2ndRun)*treadDepth
		additionXComplex=treadDepth/2
		additionZComplex=0
		hrovL=0
		hrovR=treadDepth/2+rightRailOvhgTop
		postNumber = ((nRisers2ndRun-1))/2+1
		railAngle	= ang
		side = SIDE_RIGHT
		gosub "callRailsForStair"

		DEL 2
	endif

	del 3

return


! ==============================================================================
"callRailsForStair":
! ------------------------------------------------------------------------------
!	lraSimple
!	lraComplex
!	additionXComplex
!	additionZComplex
!	hrovL: rail overhang start
!	hrovR: rail overhang end
!	postNumber:   number of posts
!	side: SIDE_LEFT or SIDE_RIGHT
! ==============================================================================
	ani = railAngle
	additionXComplex = additionXComplex
	additionZComplex = additionZComplex
	if side = SIDE_LEFT then
		dsComplex = leftRailDist+treadDepth/2*tan(ang)
	else
		dsComplex = rightRailDist+treadDepth/2*tan(ang)
	endif

	gosub "callRails"
return


! ==============================================================================
"callRailsForLanding":
! ------------------------------------------------------------------------------
!	lraSimple
!	lraComplex
!	hrovL: rail overhang start
!	hrovR: rail overhang end
!	postNumber:   number of posts
!	side: SIDE_LEFT or SIDE_RIGHT
! ==============================================================================
	ani = 0
	additionZComplex = 0
	if side = SIDE_LEFT then
		additionXComplex = leftRailPostSize/2*0
		dsComplex = leftRailDist + treadDepth/2*tan(ang)
	else
		additionXComplex = rightRailPostSize/2*0
		dsComplex = rightRailDist + treadDepth/2*tan(ang)
	endif

	gosub "callRails"
return


! ==============================================================================
"callRails":
! ------------------------------------------------------------------------------
!	ani
!	additionXComplex
!	additionZComplex
!	dsComplex
!  ------------------
!	side: SIDE_LEFT or SIDE_RIGHT
!	lraSimple
!	lraComplex
!	hrovL: rail overhang start
!	hrovR: rail overhang end
!	postNumber:   number of posts
! ==============================================================================
	if side = SIDE_LEFT then
		railBarDepth		= leftRailBarDepth
		railBarDiam			= railBarDepth
		railHeight			= leftRailHeight
		railBarThk			= leftRailBarThk
		railFrameThk		= leftRailFrameThk
		railDist			= leftRailDist
		railType_m			= leftRailType_m
		railPostSize		= leftRailPostSize
		nBarsRail			= nBarsLeftRail
		if rightRailType_m = RAIL_WIRED then
			railBarThk		= leftRailWireThk
			railBarDepth	= leftRailWireDepth
			railBarDiam		= leftRailWireDiam
		endif
		bComplexRail		= bComplexRailLeft
	else
		railBarDepth		= rightRailBarDepth
		railBarDiam			= railBarDepth
		railHeight			= rightRailHeight
		railBarThk			= rightRailBarThk
		railFrameThk		= rightRailFrameThk
		railDist			= rightRailDist
		railType_m			= rightRailType_m
		railPostSize		= rightRailPostSize
		nBarsRail			= nBarsRightRail
		if rightRailType_m = RAIL_WIRED then
			railBarThk		= rightRailWireThk
			railBarDepth	= rightRailWireDepth
			railBarDiam		= rightRailWireDiam
		endif
		bComplexRail		= bComplexRailRight
	endif

	add2 additionXComplex * bComplexRail, 0
	call "railSymbol2D_m" parameters all	cfs					= 1,
											bEnable2DPosts		= bComplexRail,
											ptyp_m				= 1,
											ani					= ani,
											rom_m				= 1,
											rmm_m				= 1,
											LengthSize			= 0,
											lra					= lraSimple * NOT(bComplexRail) + lraComplex * (bComplexRail),
											hr					= railHeight,
											hrPerp				= railHeight,
											ab					= 0,
											rb					= 0,
											ds					= railDist,
											gs_AngleL			= 90,
											gs_AngleR			= 90,
											iHandRailStyle		= 1,
											handRailDiameter	= railFrameThk,
											handRailWidth		= railFrameThk,
											hroL				= hrovL,
											hroR				= hrovR,
											np					= postNumber,
											pd					= railPostSize,
											pw					= railPostSize,
											pth					= railFrameThk,
											gs_cont_pen			= railPen,
											sa					= 0,
											bBreakRailLine		= bBreakRailLine,
											breakLineAngle		= brLineAngle,
											breakLineDist		= breakLineDist,
											breakLineWidth		= breakLineW,
											bRailAboveBreakLine	= bRailAboveBreakLine,
											bShowRailBelowBrL	= bShowRailPart1,
											bShowRailAboveBrL	= bShowRailPart2,
											bPostNoCalculation	= (railType_m = 9),
											pit_m				= 2,
											dp					= treadDepth
	del 1

	bShowRailPart1			= 0
	bShowRailPart2			= 0

return

"carriage":

	if beamNum = 1 then
		add2 carriageBaseDist / 2 - beamThk / 2 - beamOffsetRight, 0
	else
		add2 carriageBaseDist - beamThk - beamOffsetRight, 0
	endif
	for wb = 1 to beamNum
		if bBreakCarriageLine then
			lengthMod	= -(carriageBaseDist - beamOffsetLeft - beamOffsetRight - beamThk) * tan(brLineAngle) * (wb = 2)
			if bShowCarriagePart1 then
				pen carriagePen
				if aboveStory then
					LINE_TYPE carriageLineType
				else
					if	(drawPart[1] and drawDashed[1]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE carriageLineType
					endif
				endif

				poly2_b 4, 1+2+4+64, gs_fill_pen, gs_back_pen,
					0, 0, 1,
					beamThk, 0, 1,
					beamThk, carrBreakLineDist + beamThk * tan(brLineAngle) / 2 + lengthMod, 1,
					0, carrBreakLineDist - beamThk * tan(brLineAngle) / 2 + lengthMod, 1
			endif

			if bShowCarriagePart2 then
				pen carriagePen
				if aboveStory then
					LINE_TYPE carriageLineType
				else
					if	(drawPart[2] and drawDashed[2]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE carriageLineType
					endif
				endif


				poly2_b 4, 1 + 2 * gs_FillAbove + 4+64, gs_fill_pen, gs_back_pen,
					0, carrBreakLineDist - beamThk * tan(brLineAngle) / 2 + lengthMod + carrBreakLineWidth, 1,
					beamThk, carrBreakLineDist + beamThk * tan(brLineAngle) / 2 + lengthMod + carrBreakLineWidth, 1,
					beamThk, beamLength, 1,
					0, beamLength, 1
			endif
		else
			if aboveStory then
				LINE_TYPE carriageLineType
			else
			pen carriagePen
				if drawPart[3] then
					if (drawDashed[3]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE carriageLineType
					endif
				else
					if	(NOT(bCarrAboveBreakLine) and drawDashed[1]) or\
						((bCarrAboveBreakLine) and drawDashed[2]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE carriageLineType
					endif
				endif
			endif

			poly2_b 4, 1 + 2 * (NOT(bCarrAboveBreakLine) + bCarrAboveBreakLine * gs_FillAbove) + 4+64, gs_fill_pen, gs_back_pen,
				0, 0, 1,
				beamThk, 0, 1,
				beamThk, beamLength, 1,
				0, beamLength, 1
		endif
		add2 -carriageBaseDist + beamThk + beamOffsetLeft + beamOffsetRight, 0
	next wb
	del beamNum + 1

	bShowCarriagePart1	= 0
	bShowCarriagePart2	= 0

return

