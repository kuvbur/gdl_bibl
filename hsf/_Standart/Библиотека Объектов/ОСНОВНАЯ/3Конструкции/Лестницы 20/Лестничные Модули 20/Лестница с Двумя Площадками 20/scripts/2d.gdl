

! ---------- Hotspots ----------[
	unID = 1
	FlightUNID		= 50
	RailUNID		= 100
	StartSymbUNID	= 200
	ArrowUNID		= 300
	RiseRunUNID		= 400
	UpDownUNID		= 500
	NumUnID			= 600

HOTSPOT2 0,0, unID: unID=unID+1

! ---------- Hotspots ----------]

dim drawPart[3] ! 1 - lower,  2 - upper,  3 - full
dim drawDashed[3] ! 1 - lower,  2 - upper,  3 - full
dim drawSteps[3] ! 1 - lower,  2 - upper,  3 - full
dim drawDetails[3] ! 1 - lower,  2 - upper,  3 - full


drawPart[1] = 0		! Lower
drawPart[2] = 0		! Upper
drawPart[3] = 0		! Full
drawDashed[1] = 0	! Lower
drawDashed[2] = 0	! Upper
drawDashed[3] = 0	! Full
drawSteps[1] = 0	! Lower
drawSteps[2] = 0	! Upper
drawSteps[3] = 0	! Full
drawDetails[1] = 0	! Lower
drawDetails[2] = 0	! Upper
drawDetails[3] = 0	! Full
drawNum = 0


abovestory = 0
belowstory = 0
if bStorySensitive then
	if GLOB_CH_STORY_DIST > EPS  then
		abovestory = 1
	else
		if GLOB_CH_STORY_DIST < -EPS  then
			belowstory = 1
		endif
	endif
endif

bCarriageLineExist		= bShowCarriage and bEnableCarriageLine and (GLOB_SCALE <= iShowCarriageUpTo | iShowCarriageUpTo = 1)

! ---------- Settings of 2D Symbol Type ----------
_iSymbolType = 1
_bShowRailIn2D = 1
if gs_detlevel_2D_m = DET2D_SCALESENSITIVE then
	if GLOB_SCALE <= _iScaleMD then									!! Detailed Scale
		_iSymbolType = iEnabledSymbolTypes[iSymbolGroup][3]
	else
		if GLOB_SCALE > _iScaleMD & GLOB_SCALE <= _iScaleSM then	!! Middle Scale
			_iSymbolType = iEnabledSymbolTypes[iSymbolGroup][2]
		else														!! Simple Scale
			_iSymbolType = iEnabledSymbolTypes[iSymbolGroup][1]
			_bShowRailIn2D = 0
		endif
	endif
else
	_iSymbolType = gs_SymbolType_m
endif

IF _iSymbolType = 1 THEN		! Type 1
	drawPart[3]	= 1		! Full
	drawDashed[3] = 1	! Full
ENDIF

IF _iSymbolType = 2 THEN		! Type 2
	drawPart[3]	= 1		! Full
ENDIF

IF _iSymbolType = 3 THEN		! Type 3
	drawPart[1]	= 1		! Lower
ENDIF

IF _iSymbolType = 4 THEN		! Type 4
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
ENDIF

IF _iSymbolType = 5 THEN		! Type 5
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
ENDIF

IF _iSymbolType = 6 THEN		! Type 6
	drawPart[3]	= 1		! Full
	drawDashed[3] = 1	! Full
	drawSteps[3] = 1	! Full
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 7 THEN		! Type 7
	drawPart[3]	= 1		! Full
	drawSteps[3] = 1	! Full
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 8 THEN		! Type 8
	drawPart[1]	= 1		! Lower
	drawSteps[1] = 1	! Lower
ENDIF

IF _iSymbolType = 9 THEN		! Type 9
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
ENDIF

IF _iSymbolType = 10 THEN		! Type 10
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
ENDIF

IF _iSymbolType = 11 THEN		! Type 11
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 12 THEN		! Type 12
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 13 THEN		! Type 13
	drawPart[3]	= 1		! Full
	drawDashed[3] = 1	! Full
	drawSteps[3] = 1	! Full
	drawDetails[3] = 1	! Full

	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 14 THEN		! Type 14
	drawPart[3]	= 1		! Full
	drawSteps[3] = 1	! Full
	drawDetails[3] = 1	! Full

	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 15 THEN		! Type 15
	drawPart[1]	= 1		! Lower
	drawSteps[1] = 1	! Lower
	drawDetails[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
!	drawDetails[2] = 1	! Upper ! COMP
ENDIF

IF _iSymbolType = 16 THEN		! Type 16
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawDetails[1] = 1	! Lower
ENDIF

IF _iSymbolType = 17 THEN		! Type 17
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
	drawDetails[1] = 1	! Lower
ENDIF

IF _iSymbolType = 18 THEN		! Type 18
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawDetails[1] = 1	! Lower
	drawDetails[2] = 1	! Upper
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 19 THEN		! Type 19
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawDetails[1] = 1	! Lower
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 20 THEN		! Type 20
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawDetails[1] = 1	! Lower
	drawDetails[2] = 1	! Upper
	drawNum = bShowNumbering
ENDIF

! ---------- Stories below the home story ---------- [

bBackgroundFill = 1
if belowstory then
	drawPart[3]		= 1
	drawDashed[3]	= 1

	drawSteps[1] = 0
	drawSteps[2] = 0
	drawSteps[3] = 0

	drawDetails[1] = 0
	drawDetails[2] = 0
	drawDetails[3] = 0

	drawNum = 0
endif

! ---------- Stories below the home story ---------- ]

! ---------- Stories above the home story ---------- [
if abovestory then
	drawPart[1] = 0
	drawPart[2] = 0
	drawPart[3] = 0

	if gs_TreadStUp then
		drawSteps[1] = 1
		drawSteps[2] = 1
		drawSteps[3] = 1

		if drawDetails[1] | drawDetails[3] then
			drawDetails[1] = 1
			drawDetails[2] = 1
			drawDetails[3] = 1
		endif

	else
		drawSteps[1] = 0
		drawSteps[2] = 0
		drawSteps[3] = 0

		drawDetails[1] = 0
		drawDetails[2] = 0
		drawDetails[3] = 0
	endif

	if gs_BreaklineStUp = 0 then
		drawPart[3] = 1
	else
		if gs_LowerPartStUp then
			drawPart[1] = 1
		endif
		if gs_UpperPartStUp then
			drawPart[2] = 1
		endif
	endif

	if gs_numaStUp & gs_TreadStUp & ((drawPart[1] & drawPart[2]) | drawPart[3]) then
		drawNum = 1
	else
		drawNum = 0
	endif
endif


td_t=treadDepth
bet_t=bet

hasBreak1st = 0
hasBreak2nd	= 0
hasBreak3rd	= 0
	NumStline = INT (gs_BreakHeight/treadHeight)
	NumStline = max(1,NumStline)

FOR iFlight = 1 TO 3
	DRAWINDEX 10
	PEN gs_cont_pen
	FILL gs_fill_type

	if iFlight = 1 then
		RNU_temp = nRisers1stRun-1
		if drawPart[3] then
			bBackgroundFill	= 1
			drawBreakLine = 0
		else
			IF nRisers1stRun > NumStline+1 THEN
				drawBreakLine = 1
				hasBreak1st = 1
				bBackgroundFill	= gs_FillAbove
			else
				drawBreakLine = 0
				bBackgroundFill	= 1
			ENDIF
		endif

		treadDepth = td_t
		FILL_above = gs_FillAbove
	endif


	if iFlight = 2 then
		RNU_temp	= nRisers2ndRun-1
		if drawPart[3] then
			bBackgroundFill = 1
			drawBreakLine = 0
		else
			if nRisers1stRun <= (NumStline+1) & (nRisers1stRun+nRisers2ndRun) > (NumStline+1) then
				drawBreakLine = 1
				hasBreak2nd = 1
				NumStline = max(1,(NumStline-nRisers1stRun))
				bBackgroundFill	= gs_FillAbove
			else
				drawBreakLine = 0
				if hasBreak1st then
					bBackgroundFill	= gs_FillAbove
				else
					bBackgroundFill	= 1
				endif
			endif
		endif

		treadDepth=td2
		ang=ang2
		bet=bet2
	endif

	if iFlight = 3 then
		RNU_temp	= nRisers3rdRun
		if drawPart[3] then
			bBackgroundFill = 1
			drawBreakLine = 0
		else
			if (nRisers1stRun+nRisers2ndRun) <= (NumStline+1) then
				drawBreakLine = 1
				hasBreak3rd	= 1
				NumStline = max(1,(NumStline-(nRisers1stRun+nRisers2ndRun)))
				bBackgroundFill	= gs_FillAbove
			else
				drawBreakLine = 0
				if hasBreak1st | hasBreak2nd then
				bBackgroundFill	= gs_FillAbove
				else
					bBackgroundFill	= 1
				endif
			endif
		endif

		treadDepth=td_t
		ang=ATN(treadHeight/treadDepth)
		bet=bet_t
	ENDIF
	if belowStory then bBackgroundFill	= 0

	! ==========================================================================
	! CONTOUR LINES
	! ==========================================================================

	IF not(drawBreakLine) THEN
		IF	((iFlight = 1 | (iFlight = 2 & not(hasBreak1st) & not(hasBreak2nd))) & drawPart[1]) | \
			(iFlight = 2 & hasBreak1st & drawPart[2]) | \
			(iFlight = 3 & drawPart[2]) | \
			(drawPart[3]) then

			if aboveStory then
				PEN gs_LinePenStUp
				LINE_TYPE gs_LineTypeStUp
			else
				IF	((iFlight = 1 | (iFlight = 2 & not(hasBreak1st) & not(hasBreak2nd))) & drawDashed[1]) | \
					(iFlight = 2 & hasBreak1st & drawDashed[2]) | \
					(iFlight = 3 & drawDashed[2]) | \
					(drawDashed[3]) then
					PEN gs_DashLinePen
					LINE_TYPE dash_line
				else
					PEN gs_cont_pen
					LINE_TYPE solid_line
				endif
			endif

			mask = 1
			if iFlight = 1 then xNosing = nosing * (drawDetails[1]|drawDetails[3])
			if iFlight = 2 then xNosing = nosing * ((not(hasBreak1st) & not(hasBreak2nd) & drawDetails[1])| (hasBreak1st & drawDetails[2]) | drawDetails[3])
			if iFlight = 3 then
				xNosing = nosing * (drawDetails[2]|drawDetails[3])
				mask = 0
			endif

			! ---------- Contour of Landing ----------
			if iFlight = 1 | iFlight = 2 then
				POLY2_b 5, 1+2*bBackgroundFill+4+64, gs_fill_pen, gs_back_pen,
					flightWidth,(RNU_temp)*treadDepth-xNosing, 1,
					flightWidth,(RNU_temp)*treadDepth, 0,
					flightWidth,(RNU_temp)*treadDepth+flightWidth, 1,
					0,			(RNU_temp)*treadDepth+flightWidth, 1,
					0,			(RNU_temp)*treadDepth-xNosing, 0

				HOTLINE2 flightWidth, (RNU_temp)*treadDepth-xNosing,		flightWidth,	(RNU_temp)*treadDepth+flightWidth
				HOTLINE2 flightWidth, (RNU_temp)*treadDepth+flightWidth,	0,				(RNU_temp)*treadDepth+flightWidth
				HOTLINE2 0,			(RNU_temp)*treadDepth+flightWidth,	0,				(RNU_temp)*treadDepth-xNosing
				HOTLINE2 0,			(RNU_temp)*treadDepth-xNosing,		flightWidth,	(RNU_temp)*treadDepth-xNosing
			endif

			POLY2_b 4, 1+2*bBackgroundFill+4+64, gs_fill_pen, gs_back_pen,
				0,			-xNosing, 1,
				flightWidth,-xNosing, 1,
				flightWidth,(RNU_temp)*treadDepth-xNosing*mask, 1,
				0,			(RNU_temp)*treadDepth-xNosing*mask, 1

			HOTLINE2 0, -xNosing, flightWidth, -xNosing
			HOTLINE2 flightWidth, -xNosing, flightWidth, (RNU_temp)*treadDepth-xNosing
			HOTLINE2 flightWidth, (RNU_temp)*treadDepth-xNosing,0, (RNU_temp)*treadDepth-xNosing
			HOTLINE2 0, (RNU_temp)*treadDepth-xNosing,0, -xNosing

		ENDIF
	ELSE

! with Break Line
! ---------------------------------------------------------------------------------------------
		if breakline_style_m = 2 then		! Zig Zag
			angle_breakline=ATN(2*treadDepth/flightWidth)
			ZigZag1Y=(2/5*flightWidth)*tan(angle_breakline)
			ZigZag2Y=(7/20*flightWidth)*tan(angle_breakline)
		else
			if breakline_style_m = 3 then		! Zig Zag CHI
				angle_breakline=ATN(2*treadDepth/flightWidth)
				ZigZag1Y=(2/5*flightWidth)*tan(angle_breakline)
				ZigZag2Y=(2/5*flightWidth)*tan(angle_breakline)
			endif
		endif

		IF drawPart[1] THEN
			if aboveStory then
				PEN gs_LinePenStUp
				LINE_TYPE gs_LineTypeStUp
			else
				if drawDashed[1] then
					PEN gs_DashLinePen
					LINE_TYPE dash_line
				else
					PEN gs_cont_pen
					LINE_TYPE solid_line
				endif
			endif

			xNosing = nosing * drawDetails[1]

			if breakline_style_m = 2 then
				! ---------- Zig Zag ----------
				POLY2_b 8, 1+2+4+64, gs_fill_pen, gs_back_pen,
						0, -xNosing, 1,
						flightWidth, -xNosing, 1,
						flightWidth, (NumStline+1)*treadDepth-xNosing, 1,
						6/10*flightWidth,(NumStline+1)*treadDepth-xNosing-ZigZag1Y, 1,
						6/10*flightWidth,(NumStline-1)*treadDepth-xNosing+ZigZag1Y, 1,
						4/10*flightWidth,(NumStline+1)*treadDepth-xNosing-ZigZag1Y, 1,
						4/10*flightWidth,(NumStline-1)*treadDepth-xNosing+ZigZag1Y, 1,
						0, (NumStline-1)*treadDepth-xNosing, 1
			else
				if breakline_style_m = 3 then
					! ---------- Zig Zag CHI ----------
					POLY2_b 9, 1+2+64, gs_fill_pen, gs_back_pen,
							0, -xNosing, 1,
							flightWidth, -xNosing, 1,
							flightWidth, (NumStline+1)*treadDepth-xNosing, 1,
							6/10*flightWidth,(NumStline+1)*treadDepth-xNosing-ZigZag1Y, 1,
							6/10*flightWidth,(NumStline-1)*treadDepth-xNosing+ZigZag1Y, 1,
							4/10*flightWidth,(NumStline+1)*treadDepth-xNosing-ZigZag1Y+breakLineWidth, 1,
							4/10*flightWidth,(NumStline-1)*treadDepth-xNosing+ZigZag1Y, 1,
							0, (NumStline-1)*treadDepth-xNosing, 1,
							0, -xNosing, -1
				else
					! ---------- Straight ----------
					POLY2_b 4, 1+2+4+64, gs_fill_pen, gs_back_pen,
							0, -xNosing, 1,
							flightWidth, -xNosing, 1,
							flightWidth, (NumStline+1)*treadDepth-xNosing, 1,
							0, (NumStline-1)*treadDepth-xNosing, 1
				endif
			endif


			HOTSPOT2 flightWidth/2,(NumStline)*treadDepth-xNosing, FlightUNID: FlightUNID=FlightUNID+1
			HOTSPOT2 0,			(NumStline-1)*treadDepth-xNosing, FlightUNID: FlightUNID=FlightUNID+1
			HOTSPOT2 flightWidth,	(NumStline+1)*treadDepth-xNosing, FlightUNID: FlightUNID=FlightUNID+1

			HOTLINE2 0, -xNosing, flightWidth, -xNosing
			HOTLINE2 flightWidth, -xNosing, flightWidth, (NumStline+1)*treadDepth-xNosing
			HOTLINE2 flightWidth, (NumStline+1)*treadDepth-xNosing,0, (NumStline-1)*treadDepth-xNosing
			HOTLINE2 0, (NumStline-1)*treadDepth-xNosing,0, -xNosing
		ENDIF

		IF drawPart[2] THEN
			if aboveStory then
				PEN gs_LinePenStUp
				LINE_TYPE gs_LineTypeStUp
			else
				if drawDashed[2] then
					PEN gs_DashLinePen
					LINE_TYPE dash_line
				else
					PEN gs_cont_pen
					LINE_TYPE solid_line
				endif
			endif

			if iFlight = 3 then	mask = 0 else mask = 1
			xNosing = nosing * drawDetails[2]


			! ---------- Contour of Landing ----------
			if iFlight = 1 | iFlight = 2 THEN
				POLY2_b 5, 1+2*bBackgroundFill+4+64, gs_fill_pen, gs_back_pen,
						flightWidth, (RNU_temp)*treadDepth-xNosing, 1,
						flightWidth, (RNU_temp)*treadDepth, 0,
						flightWidth, (RNU_temp)*treadDepth+flightWidth, 1,
						0, (RNU_temp)*treadDepth+flightWidth, 1,
						0, (RNU_temp)*treadDepth-xNosing, 0

				HOTLINE2 flightWidth, (RNU_temp)*treadDepth-xNosing,flightWidth, (RNU_temp)*treadDepth+flightWidth
				HOTLINE2 flightWidth, (RNU_temp)*treadDepth+flightWidth,0, (RNU_temp)*treadDepth+flightWidth
				HOTLINE2 0, (RNU_temp)*treadDepth+flightWidth,0, (RNU_temp)*treadDepth-xNosing
				HOTLINE2 0, (RNU_temp)*treadDepth-xNosing,flightWidth, (RNU_temp)*treadDepth-xNosing
			endif

			if breakline_style_m = 2 then
				! ---------- Zig Zag ----------
				POLY2_b 8, 1+2*bBackgroundFill+4+64, gs_fill_pen, gs_back_pen,
						0, (NumStline-1)*treadDepth-xNosing+ breakLineWidth, 1,
						7/20*flightWidth, (NumStline-1)*treadDepth -xNosing+ breakLineWidth +ZigZag2Y, 1,
						7/20*flightWidth, (NumStline-1)*treadDepth -xNosing+ breakLineWidth +ZigZag2Y+2*(treadDepth-ZigZag1Y), 1,
						11/20*flightWidth, (NumStline-1)*treadDepth -xNosing+ breakLineWidth +ZigZag2Y, 1,
						11/20*flightWidth, (NumStline-1)*treadDepth -xNosing+ breakLineWidth +ZigZag2Y+2*(treadDepth-ZigZag1Y), 1,
						flightWidth, (NumStline+1)*treadDepth-xNosing+ breakLineWidth, 1,
						flightWidth, (RNU_temp)*treadDepth-xNosing*mask, 1,
						0, (RNU_temp)*treadDepth-xNosing*mask, 1
			else
				if breakline_style_m = 3 then
					! ---------- Zig Zag CHI ----------
					POLY2_b 8, 1+2*bBackgroundFill+4+64, gs_fill_pen, gs_back_pen,
							0, (NumStline-1)*treadDepth-xNosing+ breakLineWidth, 1,
							4/10*flightWidth, (NumStline-1)*treadDepth -xNosing+ breakLineWidth +ZigZag2Y, 1,
							4/10*flightWidth, (NumStline+1)*treadDepth-xNosing-ZigZag1Y+breakLineWidth, 1,
							6/10*flightWidth, (NumStline-1)*treadDepth-xNosing+ZigZag1Y, 1,
							6/10*flightWidth, (NumStline-1)*treadDepth -xNosing+ breakLineWidth +ZigZag2Y+2*(treadDepth-ZigZag1Y), 1,
							flightWidth, (NumStline+1)*treadDepth-xNosing+ breakLineWidth, 1,
							flightWidth, (RNU_temp)*treadDepth-xNosing*mask, 1,
							0, (RNU_temp)*treadDepth-xNosing*mask, 1
				else
					! ---------- Straight ----------
					POLY2_b 4, 1+2*bBackgroundFill+4+64, gs_fill_pen, gs_back_pen,
							0, (NumStline-1)*treadDepth-xNosing+breakLineWidth, 1,
							flightWidth, (NumStline+1)*treadDepth-xNosing+breakLineWidth, 1,
							flightWidth, (RNU_temp)*treadDepth-xNosing*mask, 1,
							0, (RNU_temp)*treadDepth-xNosing*mask, 1
				endif
			endif

			HOTLINE2 0, (NumStline-1)*treadDepth-xNosing+breakLineWidth, flightWidth, (NumStline+1)*treadDepth-xNosing+breakLineWidth
			HOTLINE2 flightWidth, (NumStline+1)*treadDepth-xNosing+breakLineWidth,flightWidth, (RNU_temp)*treadDepth-xNosing*mask
			HOTLINE2 flightWidth, (RNU_temp)*treadDepth-xNosing*mask,0, (RNU_temp)*treadDepth-xNosing*mask
			HOTLINE2 0, (RNU_temp)*treadDepth-xNosing*mask,0, (NumStline-1)*treadDepth-xNosing+breakLineWidth

			! BREAK LINE
			HOTSPOT2 flightWidth/2,		(NumStline)*treadDepth-xNosing,					FlightUNID, breakLineWidth, 1+128	: FlightUNID=FlightUNID+1
			HOTSPOT2 flightWidth/2,		(NumStline)*treadDepth-xNosing-1,				FlightUNID, breakLineWidth, 3		: FlightUNID=FlightUNID+1
			HOTSPOT2 flightWidth/2,		(NumStline)*treadDepth-xNosing+breakLineWidth,	FlightUNID, breakLineWidth, 2		: FlightUNID=FlightUNID+1

			HOTSPOT2 0, (NumStline-1)*treadDepth-xNosing+breakLineWidth,				FlightUNID: FlightUNID=FlightUNID+1
			HOTSPOT2 flightWidth, (NumStline+1)*treadDepth-xNosing+breakLineWidth,	FlightUNID: FlightUNID=FlightUNID+1
		endif
	endif

	! ==========================================================================
	! TREADS
	! ==========================================================================
	DRAWINDEX 20

	if not(drawBreakLine) then
		IF	((iFlight = 1|(iFlight = 2 & not(hasBreak1st) & not(hasBreak2nd))) & drawPart[1] & drawSteps[1]) | \
			(iFlight = 2 & (hasBreak1st & drawPart[2] & drawSteps[2])) | \
			(iFlight = 3 & drawPart[2] & drawSteps[2]) | \
			(drawPart[3] & drawSteps[3]) then

			if aboveStory then
				PEN gs_LinePenStUp
				LINE_TYPE gs_LineTypeStUp
			else
				IF	((iFlight = 1 | (iFlight = 2 & not(hasBreak1st) & not(hasBreak2nd))) & drawDashed[1]) | \
					(iFlight = 2 & hasBreak1st & drawDashed[2]) | \
					(iFlight = 3 & drawDashed[2]) | \
					(drawDashed[3]) then
					PEN gs_DashLinePen
					LINE_TYPE dash_line
				else
					PEN gs_cont_pen
					LINE_TYPE solid_line
				endif
			endif

			FOR numTread = 1 to RNU_temp
				LINE2 0,-xNosing, flightWidth, -xNosing
				HOTLINE2 0,-xNosing, flightWidth, -xNosing
				ADD2 0,treadDepth
			NEXT numTread
			DEL RNU_temp

			IF	((iFlight = 1 | (iFlight = 2 & not(hasBreak1st) & not(hasBreak2nd))) & drawDetails[1]) | \
				(iFlight = 2 & hasBreak1st & drawDetails[2]) | \
				(iFlight = 3 & drawDetails[2]) | \
				(drawDetails[3]) then

				PEN gs_DashLinePen
				LINE_TYPE dash_line

				FOR numTread = 1 to RNU_temp+mask
					LINE2 0, 0, flightWidth, 0
					HOTLINE2 0, 0, flightWidth, 0
					ADD2 0,treadDepth
				NEXT numTread
				DEL numTread -1
			endif
		endif
	else
		if drawPart[1] & drawSteps[1] then

			xNosing = nosing * drawDetails[1]


			FOR numTread = 1 to NumStline+1
				if aboveStory then
					PEN gs_LinePenStUp
					LINE_TYPE gs_LineTypeStUp
				else
					if drawDashed[1] then
						PEN gs_DashLinePen
						LINE_TYPE dash_line
					else
						PEN gs_cont_pen
						LINE_TYPE solid_line
					endif
				endif

				StartSolid = 0
				IF breakline_style_m = 1 THEN
					IF numTread=NumStline THEN StartSolid=flightWidth/2
				ELSE
					IF numTread=NumStline THEN StartSolid=flightWidth*6/10
				ENDIF

				IF numTread<=NumStline THEN
					LINE2 StartSolid,treadDepth-xNosing, flightWidth, treadDepth-xNosing
					HOTLINE2 StartSolid,treadDepth-xNosing, flightWidth, treadDepth-xNosing
				ENDIF

				if drawDetails[1] THEN
					PEN gs_DashLinePen
					LINE_TYPE dash_line

					StartDashed=0
					if breakline_style_m = 1 then	! Straight
						IF ABS(numTread-NumStline-1)<0.001 THEN StartDashed=flightWidth/2+xNosing/tan(bet)
					ELSE
						IF distZigZag >= 4/10*flightWidth THEN
							distZigZag = 4/10*flightWidth
						ELSE
							distZigZag=(flightWidth*(treadDepth-xNosing))/(2*treadDepth)
						ENDIF

						IF numTread=NumStline+1 THEN StartDashed=max(0,leftRailOffset+leftRailFrameThk,flightWidth-distZigZag)
					ENDIF

					IF ABS(numTread-(NumStline))<0.01 THEN StartDashed=max(0,xNosing/tan(bet))

					LINE2 StartDashed,0,flightWidth,0
					HOTLINE2 StartDashed,0,flightWidth,0
				ENDIF
				ADD2 0,treadDepth
			NEXT numTread
			DEL numTread-1
		endif

		IF drawPart[2] & drawSteps[2] THEN

			xNosing = nosing * drawDetails[2]

			ADD2 0,(NumStline)*treadDepth
			FOR numTread = 1 to RNU_temp-NumStline+mask
				if aboveStory then
					PEN gs_LinePenStUp
					LINE_TYPE gs_LineTypeStUp
				else
					if drawDashed[2] then
						PEN gs_DashLinePen
						LINE_TYPE dash_line
					else
						PEN gs_cont_pen
						LINE_TYPE solid_line
					endif
				endif

				EndSolid=flightWidth
				if breakline_style_m = 1 then	! Straight
					IF numTread=1 THEN EndSolid=Max(0,Min(flightWidth,(treadDepth-breakLineWidth)/tan(bet)))
					IF numTread=2 THEN EndSolid=Max(0,Min(flightWidth,(2*treadDepth-breakLineWidth)/tan(bet)))
					IF numTread=3 THEN EndSolid=Max(0,Min(flightWidth,(3*treadDepth-breakLineWidth)/tan(bet)))
				else
					if breakline_style_m = 3 then	! Zigzag CHI
						ZigZagCorrection = 4/10
					else
						ZigZagCorrection = 7/20
					endif

					IF numTread=1 THEN EndSolid=Max(0,Min(ZigZagCorrection*flightWidth,(treadDepth-breakLineWidth)/tan(bet)))
					IF numTread=2 THEN
						IF ZigZag2Y+2*(treadDepth-ZigZag1Y)<2*treadDepth-breakLineWidth THEN EndSolid=Max(0,Min(flightWidth,(2*treadDepth-breakLineWidth)/tan(bet)))
						IF ZigZag2Y+2*(treadDepth-ZigZag1Y)>=2*treadDepth-breakLineWidth THEN EndSolid=Max(0,Min(flightWidth,ZigZagCorrection*flightWidth))
					ENDIF
					IF numTread=3 THEN EndSolid=Max(0,Min(flightWidth,(3*treadDepth-breakLineWidth)/tan(bet)))
				ENDIF

				LINE2 0,-xNosing,EndSolid,-xNosing
				HOTLINE2 0,-xNosing,EndSolid,-xNosing

				IF drawDetails[2] THEN
					PEN gs_DashLinePen
					LINE_TYPE dash_line

					EndDashed=flightWidth
					if breakline_style_m = 1 then	! Straight
						IF numTread=1 THEN EndDashed=Max(0,Min(flightWidth,(treadDepth-breakLineWidth+xNosing)/tan(bet)))
						IF numTread=2 THEN EndDashed=Max(0,Min(flightWidth,(2*treadDepth-breakLineWidth+xNosing)/tan(bet)))
					ELSE
						IF distZigZag <= ZigZagCorrection*flightWidth THEN
							distZigZag = ZigZagCorrection*flightWidth
						ELSE
							distZigZag=(flightWidth*(treadDepth/2+xNosing))/(2*treadDepth)
						ENDIF

						IF numTread=1 THEN EndDashed=Max(0,Min(ZigZagCorrection*flightWidth,(treadDepth-breakLineWidth+xNosing)/tan(bet)))
						IF numTread=2 THEN
							IF ZigZag2Y+2*(treadDepth-ZigZag1Y)<2*treadDepth+xNosing-breakLineWidth THEN EndDashed=Max(0,Min(flightWidth,(2*treadDepth+xNosing-breakLineWidth)/tan(bet)))
							IF ZigZag2Y+2*(treadDepth-ZigZag1Y)>=2*treadDepth+xNosing-breakLineWidth THEN EndDashed=Max(0,Min(flightWidth,ZigZagCorrection*flightWidth))
						ENDIF
						IF numTread=3 THEN EndDashed=Max(0,Min(flightWidth,(3*treadDepth-breakLineWidth+xNosing)/tan(bet)))
					ENDIF

					LINE2 0,0,EndDashed,0
					HOTLINE2 0,0,EndDashed,0
				ENDIF

				ADD2 0,treadDepth
			NEXT numTread
			DEL numTread-1
			DEL 1
		endif
	endif

	! ==========================================================================
	! WALKING LINE / ARROWHEAD / START END SYMBOL
	! ==========================================================================
	reverseWalkline = 0
	if walkingDirUPDN_m = 3 | walkingDirUPDN_m = 4 | (walkingDirUPDN_m = 6 & abovestory) then
		reverseWalkline = 1
	endif

	if bShowWalkLine & not(belowStory) then

		PEN gs_wLinePen
		FILL gs_ArrowFill

		for i = 1 to 3
			DRAWINDEX 40
			drawWalkLine = 1
			if not(bShowWalkLineAboveBreakline) & i = 2 then drawWalkLine = 0

			if drawPart[i] & drawWalkLine then
				xNosing = nosing * drawDetails[i]
				startLine = -xNosing
				endLine = (RNU_temp)*treadDepth
				penFillArrow = gs_ArrowFillPen
				if i = 1 then
					if drawBreakline then
						endLine = (NumStline)*treadDepth-xNosing
					else
						if (iFlight = 1) | (iFlight = 2 & not(hasBreak1st)) then
							endLine = (RNU_temp)*treadDepth
						else
							drawWalkLine = 0
						endif
					endif
				endif
				if i = 2 then
					if drawBreakline then
						startLine = startLine + (NumStline)*treadDepth+breakLineWidth
					else
						if (iFlight = 1) | (iFlight = 2 & not(hasBreak1st)) then
							drawWalkLine = 0
						else
							endLine = (RNU_temp)*treadDepth
						endif
					endif
					penFillArrow = gs_ArrowFillPenAbove
					if walkingDirUPDN_m = 5 then reverseWalkline = 1
				endif

				if aboveStory then
					LINE_TYPE gs_wLineTypeStUp
				else
					if (drawDashed[i]) then
						LINE_TYPE gs_wLineTypeAbove
					else
						LINE_TYPE gs_wLineType1
					endif
				endif

				IF i = 3 & walkingDirUPDN_m = 5 THEN
					if iFlight = 1 then
					! Up Down Both - UP
						endLine = startLine + (RNU_temp)*treadDepth
						ADD2 flightWidth/2, endLine
						GOSUB "Arrowhead Symbol"
						DEL 1
						endLine = endLine-lengthArrowHead

						line2 flightWidth/2, startLine, flightWidth/2, endLine

						ADD2 flightWidth/2, startLine
						GOSUB "Start End Symbol"
						DEL 1
					endif

					if iFlight = 2 then drawWalkLine = 0

					if iFlight = 3 then
					! Up Down Both - Down
						endLine = (RNU_temp)*treadDepth
						startLine = startLine
						ADD2 flightWidth/2, startLine
						MUL2 1, -1
						GOSUB "Arrowhead Symbol"
						DEL 2
						startLine = startLine+lengthArrowHead

						ADD2 flightWidth/2, endLine
						GOSUB "Start End Symbol"
						DEL 1
					endif
				else

					! Arrow Head below Break Line
					if not(reverseWalkline)	& (((i=3|i=2) & iFlight=3) | (i=1 & drawBreakLine)) then
						ADD2 flightWidth/2, endLine
						GOSUB "Arrowhead Symbol"
						DEL 1
						endLine = endLine-lengthArrowHead
					endif

					if not(reverseWalkline) & ((i=3|i=1) & iFlight=1) then
						ADD2 flightWidth/2, startLine
						GOSUB "Start End Symbol"
						DEL 1
					endif

					! Arrow Head on Start
					if reverseWalkline & (((i=3|i=1) & iFlight=1) | (i=2 & drawBreakLine))then
						ADD2 flightWidth/2, startLine
						MUL2 1, -1
						GOSUB "Arrowhead Symbol"
						DEL 2
						startLine = startLine+lengthArrowHead
					endif

					if reverseWalkline & ((i=3|i=2) & iFlight=3) then
						ADD2 flightWidth/2, endLine
						GOSUB "Start End Symbol"
						DEL 1
					endif
				endif

				! Walking Line
				if drawWalkLine then line2 flightWidth/2, startLine, flightWidth/2, endLine
			endif
		next i

		if drawBreakLine then
			HOTSPOT2 flightWidth/2,(NumStline)*treadDepth-xNosing,					FlightUNID,breakLineWidth,1+128		:FlightUNID=FlightUNID+1
			HOTSPOT2 flightWidth/2,(NumStline)*treadDepth-0.1-xNosing,				FlightUNID,breakLineWidth,3			:FlightUNID=FlightUNID+1
			HOTSPOT2 flightWidth/2,(NumStline)*treadDepth+breakLineWidth-xNosing,	FlightUNID,breakLineWidth,2			:FlightUNID=FlightUNID+1
		endif

		if 	(iFlight = 1 & ((not(hasBreak1st) & drawPart[1]) | (hasBreak1st & drawPart[2] & bShowWalkLineAboveBreakline) | (drawPart[3] & (walkingDirUPDN_m <> 5) ))) | \
			(iFlight = 2 & ((not(hasBreak1st) & not(hasBreak2nd) & drawPart[1]) | ((hasBreak1st|hasBreak2nd) & drawPart[2] & bShowWalkLineAboveBreakline) | (drawPart[3] & (walkingDirUPDN_m <> 5) ))) then
			if aboveStory then
				LINE_TYPE gs_wLineTypeStUp
			else
			if 	(iFlight = 1 & ((not(hasBreak1st) & drawDashed[1]) | (hasBreak1st & drawDashed[2]) | (drawDashed[3] & (walkingDirUPDN_m <> 5) ))) | \
				(iFlight = 2 & ((not(hasBreak1st) & not(hasBreak2nd) & drawDashed[1]) | ((hasBreak1st|hasBreak2nd) & drawDashed[2]) | (drawDashed[3] & (walkingDirUPDN_m <> 5) ))) then
					LINE_TYPE gs_wLineTypeAbove
				else
					LINE_TYPE gs_wLineType1
				endif
			endif
			LINE2 flightWidth/2,(RNU_temp)*treadDepth,flightWidth/2,(RNU_temp)*treadDepth+flightWidth/2
			LINE2 flightWidth/2,(RNU_temp)*treadDepth+flightWidth/2,flightWidth,(RNU_temp)*treadDepth+flightWidth/2
		ENDIF
	ENDIF

	DRAWINDEX 10
	ADD2 flightWidth,RNU_temp*treadDepth+flightWidth
	ROT2 -90
NEXT iFlight
DEL 3*2

treadDepth=td_t
bet=bet_t


!===============================================================================
! --- Carriage Line ---
!===============================================================================

if bCarriageLineExist and not(belowStory) then
	fill gs_fill_type

	bShowCarriagePart1	= 0
	bShowCarriagePart2	= 0

	beamNum				= 2
	beamThk				= woodBaseThk
	beamOffsetRight		= woodBaseOffset
	beamOffsetLeft		= woodBaseOffset
	carriageBaseDist	= flightWidth
	carrBreakLineWidth	= breakLineWidth

	if drawPart[3] then
		!!!!!******************************      1st RUN + LANDING 1.
		add2 0, bRiserCover * riserCoverThk
			beamLength			= (nRisers1stRun - 1) * treadDepth + flightWidth - bRiserCover * riserCoverThk
			bCarrAboveBreakLine	= 0
			bBreakCarriageLine	= 0
			gosub "carriage"
		del 1

		!!!!!******************************      2nd RUN + LANDING 2.
		add2 flightWidth - woodBaseOffset, flightWidth + (nRisers1stRun - 1) * treadDepth
		rot2 -90
			beamLength			= (nRisers2ndRun - 1) * td2 + flightWidth + woodBaseOffset
			bCarrAboveBreakLine	= 0
			bBreakCarriageLine	= 0
			gosub "carriage"
		del 2

		!!!!!******************************      3rd RUN
		add2 a, (nRisers1stRun-1)*treadDepth + woodBaseOffset
		rot2 -180
			beamLength			= nRisers3rdRun * treadDepth + woodBaseOffset
			bCarrAboveBreakLine	= 0
			bBreakCarriageLine	= 0
			gosub "carriage"
		del 2
	else
		if hasBreak1st then
			if drawPart[1] then
				!!!!!******************************      1st RUN + LANDING 1.
				add2 0, bRiserCover * riserCoverThk
					beamLength			= (nRisers1stRun - 1) * treadDepth + flightWidth - bRiserCover * riserCoverThk
					bCarrAboveBreakLine	= 0
					bBreakCarriageLine	= 1
					bShowCarriagePart1	= 1
					bShowCarriagePart2	= 0
					brLineAngle			= bet
					xNosing				= nosing * drawDetails[1]
					carrBreakLineDist	= NumStline * treadDepth - xNosing + (flightWidth / 2 - beamOffsetRight - beamThk / 2) * tan(brLineAngle) - bRiserCover * riserCoverThk
					gosub "carriage"
				del 1
			endif

			if drawPart[2] then
				!!!!!******************************      1st RUN + LANDING 1.
				add2 0, bRiserCover * riserCoverThk
					beamLength			= (nRisers1stRun - 1) * treadDepth + flightWidth - bRiserCover * riserCoverThk
					bCarrAboveBreakLine	= 1
					bBreakCarriageLine	= 1
					bShowCarriagePart1	= 0
					bShowCarriagePart2	= 1
					brLineAngle			= bet
					xNosing				= nosing * drawDetails[2]
					carrBreakLineDist	= NumStline * treadDepth - xNosing + (flightWidth / 2 - beamOffsetRight - beamThk / 2) * tan(brLineAngle) - bRiserCover * riserCoverThk
					gosub "carriage"
				del 1

				!!!!!******************************      2nd RUN + LANDING 2.
				add2 flightWidth - woodBaseOffset, flightWidth + (nRisers1stRun - 1) * treadDepth
				rot2 -90
					beamLength			= (nRisers2ndRun - 1) * td2 + flightWidth + woodBaseOffset
					bCarrAboveBreakLine	= 1
					bBreakCarriageLine	= 0
					gosub "carriage"
				del 2

				!!!!!******************************      3rd RUN
				add2 a, (nRisers1stRun-1)*treadDepth + woodBaseOffset
				rot2 -180
					beamLength			= nRisers3rdRun * treadDepth + woodBaseOffset
					bCarrAboveBreakLine	= 1
					bBreakCarriageLine	= 0
					gosub "carriage"
				del 2
			endif
		endif
		if hasBreak2nd then
			if drawPart[1] then
				!!!!!******************************      1st RUN + LANDING 1.
				add2 0, bRiserCover * riserCoverThk
					beamLength			= (nRisers1stRun - 1) * treadDepth + flightWidth - bRiserCover * riserCoverThk
					bCarrAboveBreakLine	= 0
					bBreakCarriageLine	= 0
					gosub "carriage"
				del 1

				!!!!!******************************      2nd RUN + LANDING 2.
				add2 flightWidth - woodBaseOffset, flightWidth + (nRisers1stRun - 1) * treadDepth
				rot2 -90
					beamLength			= (nRisers2ndRun - 1) * td2 + flightWidth + woodBaseOffset
					bCarrAboveBreakLine	= 0
					bBreakCarriageLine	= 1
					bShowCarriagePart1	= 1
					bShowCarriagePart2	= 0
					brLineAngle			= bet2
					xNosing				= nosing * drawDetails[1]
					carrBreakLineDist	= td2 + (NumStline - 1) * td2 - xNosing + (flightWidth / 2 - beamOffsetRight - beamThk / 2) * tan(brLineAngle) + beamOffsetRight
					gosub "carriage"
				del 2
			endif

			if drawPart[2] then
				!!!!!******************************      2nd RUN + LANDING 2.
				add2 flightWidth - woodBaseOffset, flightWidth + (nRisers1stRun - 1) * treadDepth
				rot2 -90
					beamLength			= (nRisers2ndRun - 1) * td2 + flightWidth + woodBaseOffset
					bCarrAboveBreakLine	= 1
					bBreakCarriageLine	= 1
					bShowCarriagePart1	= 0
					bShowCarriagePart2	= 1
					brLineAngle			= bet2
					xNosing				= nosing * drawDetails[2]
					carrBreakLineDist	= td2 + (NumStline - 1) * td2 - xNosing + (flightWidth / 2 - beamOffsetRight - beamThk / 2) * tan(brLineAngle) + beamOffsetRight
					gosub "carriage"
				del 2

				!!!!!******************************      3rd RUN
				add2 a, (nRisers1stRun-1)*treadDepth + woodBaseOffset
				rot2 -180
					beamLength			= nRisers3rdRun * treadDepth + woodBaseOffset
					bCarrAboveBreakLine	= 1
					bBreakCarriageLine	= 0
					gosub "carriage"
				del 2
			endif
		endif
		if hasBreak3rd then
			if drawPart[1] then
				!!!!!******************************      1st RUN + LANDING 1.
				add2 0, bRiserCover * riserCoverThk
					beamLength			= (nRisers1stRun - 1) * treadDepth + flightWidth - bRiserCover * riserCoverThk
					bCarrAboveBreakLine	= 0
					bBreakCarriageLine	= 0
					gosub "carriage"
				del 1

				!!!!!******************************      2nd RUN + LANDING 2.
				add2 flightWidth - woodBaseOffset, flightWidth + (nRisers1stRun - 1) * treadDepth
				rot2 -90
					beamLength			= (nRisers2ndRun - 1) * td2 + flightWidth + woodBaseOffset
					bCarrAboveBreakLine	= 0
					bBreakCarriageLine	= 0
					gosub "carriage"
				del 2

				!!!!!******************************      3rd RUN
				add2 a, (nRisers1stRun-1)*treadDepth + woodBaseOffset
				rot2 -180
					beamLength			= nRisers3rdRun * treadDepth + woodBaseOffset
					bCarrAboveBreakLine	= 0
					bBreakCarriageLine	= 1
					bShowCarriagePart1	= 1
					bShowCarriagePart2	= 0
					brLineAngle			= bet
					xNosing				= nosing * drawDetails[1]
					carrBreakLineDist	= b - flightWidth + treadDepth - xNosing - ((nRisers1stRun - 1) - (NumStline - 1)) * treadDepth + (flightWidth / 2 - beamOffsetRight - beamThk / 2) * tan(brLineAngle) + woodBaseOffset
					gosub "carriage"
				del 2
			endif

			if drawPart[2] then
				!!!!!******************************      3rd RUN
				add2 a, (nRisers1stRun-1)*treadDepth + woodBaseOffset
				rot2 -180
					beamLength			= nRisers3rdRun * treadDepth + woodBaseOffset
					bCarrAboveBreakLine	= 1
					bBreakCarriageLine	= 1
					bShowCarriagePart1	= 0
					bShowCarriagePart2	= 1
					brLineAngle			= bet
					xNosing				= nosing * drawDetails[2]
					carrBreakLineDist	= b - flightWidth + treadDepth - xNosing - ((nRisers1stRun - 1) - (NumStline - 1)) * treadDepth + (flightWidth / 2 - beamOffsetRight - beamThk / 2) * tan(brLineAngle) + woodBaseOffset
					gosub "carriage"
				del 2
			endif
		endif
	endif
endif

!===============================================================================
! --- Railings ---
!===============================================================================

gapToFirstTread = 0

if _bShowRailIn2D & not(belowStory) then
	bShowRailPart1			= 0
	bShowRailPart2			= 0
	breakLineW				= breakLineWidth
	breakLineDist			= 0
	brLineAngle				= bet

	bShowRailOn1stRun		= 0
	bShowRailOn1stLanding1	= 0
	bShowRailOn1stLanding2	= 0
	bShowRailOn2ndRun		= 0
	bShowRailOn2ndLanding1	= 0
	bShowRailOn2ndLanding2	= 0
	bShowRailOn3rdRun		= 0

	drawindex 30
	fill gs_fill_type

	! --- Left Rail ----------------------------------------------------------------
	if rail_m = 3 | rail_m = 1 then		! Left, Both
		if bSameRails then
			leftRailType_m = rightRailType_m
			leftWireType_m = rightWireType_m
		endif

		if drawPart[3] then
			if bShowRailOnFloorPlan then
				pen railPen
				if aboveStory then
					LINE_TYPE railLineType
				else
					if (drawDashed[3]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE railLineType
					endif
				endif

				if bSymbolic2D then
					bShowRailOn1stRun		= 1
					bShowRailOn1stLanding1	= 1
					bShowRailOn1stLanding2	= 1
					bShowRailOn2ndRun		= 1
					bShowRailOn2ndLanding1	= 1
					bShowRailOn2ndLanding2	= 1
					bShowRailOn3rdRun		= 1
					bBreakRailLine			= 0
					bRailAboveBreakLine		= 0
					gosub "left rail"
				else
					poly2_b 9, 1+2+64, gs_fill_pen, gs_back_pen,
						leftRailOffset+leftRailFrameThk,-leftRailOvhgBottom,1,
						leftRailOffset,-leftRailOvhgBottom,1,
						leftRailOffset,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset,1,
						(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset,1,
						(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset,(nRisers1stRun-1)*treadDepth-nRisers3rdRun*treadDepth-leftRailOvhgTop,1,
						(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset-leftRailFrameThk,(nRisers1stRun-1)*treadDepth-nRisers3rdRun*treadDepth-leftRailOvhgTop,1,
						(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset-leftRailFrameThk,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk,1,
						leftRailOffset+leftRailFrameThk,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk,1,
						leftRailOffset+leftRailFrameThk,-leftRailOvhgBottom,-1
				endif
			endif

			if bShowRailAxis then
				line_type railAxisLineType
				pen gs_RailAxisPen
				line2 leftRailOffset+leftRailFrameThk/2, (nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2,leftRailOffset+leftRailFrameThk/2,-leftRailOvhgBottom
				line2 leftRailOffset+leftRailFrameThk/2, (nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2,a-leftRailOffset-leftRailFrameThk/2,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2
				line2 a-leftRailOffset-leftRailFrameThk/2,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2,a-leftRailOffset-leftRailFrameThk/2,b-flightWidth-nRisers3rdRun*treadDepth-leftRailOvhgTop
			endif
		else		! BREAK LINE - Railing
			if hasBreak1st then
				if drawPart[1] & bShowRailOnFloorPlan then
					pen railPen
					if aboveStory then
						SET LINE_TYPE railLineType
					else
						if (drawDashed[1]) then
							SET LINE_TYPE dash_line
						else
							SET LINE_TYPE railLineType
						endif
					endif
					xNosing = nosing * drawDetails[1]

					if bSymbolic2D then
						bShowRailOn1stRun		= 1
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn2ndRun		= 0
						bShowRailOn2ndLanding1	= 0
						bShowRailOn2ndLanding2	= 0
						bShowRailOn3rdRun		= 0
						bBreakRailLine			= 1
						brLineAngle				= bet
						bShowRailPart1			= 1
						breakLineDist			= leftRailOvhgBottom + (NumStline-1)*treadDepth-xNosing+(leftRailOffset+leftRailFrameThk)*tan(bet)
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 0
						gosub "left rail"
					else
						poly2_b 5, 1+2+64, gs_fill_pen, gs_back_pen,
							leftRailOffset,-leftRailOvhgBottom,1,
							leftRailOffset+leftRailFrameThk,-leftRailOvhgBottom,1,
							leftRailOffset+leftRailFrameThk,(NumStline-1)*treadDepth-xNosing+(leftRailOffset+leftRailFrameThk)*tan(bet),1,
							leftRailOffset,(NumStline-1)*treadDepth-xNosing+(leftRailOffset)*tan(bet),1,
							leftRailOffset,-leftRailOvhgBottom,-1
					endif
				endif

				if drawPart[2] & bShowRailOnFloorPlan and bShowRailAboveBreakLine then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[2]) | drawBreakLine then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif

					xNosing = nosing * drawDetails[2]

					if bSymbolic2D then
						xNosing =  nosing * NOT(drawDetails[2])
						bShowRailOn1stRun		= 1
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn2ndRun		= 0
						bShowRailOn2ndLanding1	= 0
						bShowRailOn2ndLanding2	= 0
						bShowRailOn3rdRun		= 0
						bBreakRailLine			= 1
						brLineAngle				= bet
						bShowRailPart2			= 1
						breakLineDist			= leftRailOvhgBottom + (NumStline-1)*treadDepth-nosing+(leftRailOffset+leftRailFrameThk)*tan(bet)
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 1
						gosub "left rail"

						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 1
						bShowRailOn1stLanding2	= 1
						bShowRailOn2ndRun		= 1
						bShowRailOn2ndLanding1	= 1
						bShowRailOn2ndLanding2	= 1
						bShowRailOn3rdRun		= 1
						bBreakRailLine			= 0
						bRailAboveBreakLine		= 1
						gosub "left rail"
					else
						poly2_b 9, 1+2*gs_FillAbove+64, gs_fill_pen, gs_back_pen,
							leftRailOffset+leftRailFrameThk,(NumStline-1)*treadDepth+breakLineWidth-xNosing+(leftRailOffset+leftRailFrameThk)*tan(bet),1,
							leftRailOffset,(NumStline-1)*treadDepth+breakLineWidth-xNosing+(leftRailOffset)*tan(bet),1,
							leftRailOffset,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset,1,
							(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset,1,
							(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset,(nRisers1stRun-1)*treadDepth-nRisers3rdRun*treadDepth-leftRailOvhgTop,1,
							(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset-leftRailFrameThk,(nRisers1stRun-1)*treadDepth-nRisers3rdRun*treadDepth-leftRailOvhgTop,1,
							(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset-leftRailFrameThk,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk,1,
							leftRailOffset+leftRailFrameThk,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk,1,
							leftRailOffset+leftRailFrameThk,(NumStline-1)*treadDepth+breakLineWidth-xNosing+(leftRailOffset+leftRailFrameThk)*tan(bet),-1
					endif
				endif

				if bShowRailAxis then
					line_type railAxisLineType
					pen gs_RailAxisPen

					if drawPart[1] then
						xNosing = nosing * drawDetails[1]
						line2 leftRailOffset+leftRailFrameThk/2, (NumStline-1)*treadDepth-xNosing+(leftRailOffset+leftRailFrameThk/2)*tan(bet),leftRailOffset+leftRailFrameThk/2,-leftRailOvhgBottom
					endif

					if drawPart[2] then
						xNosing = nosing * drawDetails[2]
						LINE2 leftRailOffset+leftRailFrameThk/2, (NumStline-1)*treadDepth+breakLineWidth-xNosing+(leftRailOffset+leftRailFrameThk/2)*tan(bet),leftRailOffset+leftRailFrameThk/2,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2
						LINE2 leftRailOffset+leftRailFrameThk/2, (nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2,a-leftRailOffset-leftRailFrameThk/2,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2
						LINE2 a-leftRailOffset-leftRailFrameThk/2,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2,a-leftRailOffset-leftRailFrameThk/2,b-flightWidth-nRisers3rdRun*treadDepth-leftRailOvhgTop
					endif
				endif
			endif

			if hasBreak2nd then
				if drawPart[1] & bShowRailOnFloorPlan then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[1]) then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif
					xNosing = nosing * drawDetails[1]

					if bSymbolic2D then
						bShowRailOn1stRun		= 1
						bShowRailOn1stLanding1	= 1
						bShowRailOn1stLanding2	= 1
						bShowRailOn2ndRun		= 0
						bShowRailOn2ndLanding1	= 0
						bShowRailOn2ndLanding2	= 0
						bShowRailOn3rdRun		= 0
						bBreakRailLine			= 0
						bRailAboveBreakLine		= 0
						gosub "left rail"

						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn2ndRun		= 1
						bShowRailOn2ndLanding1	= 0
						bShowRailOn2ndLanding2	= 0
						bShowRailOn3rdRun		= 0
						bBreakRailLine			= 1
						brLineAngle				= bet2
						bShowRailPart1			= 1
						breakLineDist			= td2+(NumStline-1)*td2-xNosing+(leftRailOffset+leftRailFrameThk)*tan(bet2)
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 0
						gosub "left rail"
					else
						poly2_b  7, 1+2+4+64, gs_fill_pen, gs_back_pen,
							leftRailOffset+leftRailFrameThk,	-leftRailOvhgBottom,1,
							leftRailOffset,						-leftRailOvhgBottom,1,
							leftRailOffset,						(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset,1,
							flightWidth+(NumStline-1)*td2-xNosing+leftRailOffset*tan(bet2),	(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset,1,
							flightWidth+(NumStline-1)*td2-xNosing+(leftRailOffset+leftRailFrameThk)*tan(bet2),	(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk,1,
							leftRailOffset+leftRailFrameThk,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk,1,
							leftRailOffset+leftRailFrameThk,-leftRailOvhgBottom,-1
					endif
				endif

				if drawPart[2] & bShowRailOnFloorPlan and bShowRailAboveBreakLine then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[2]) | drawBreakLine then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif

					if bSymbolic2D then
						xNosing = nosing * NOT(drawDetails[2])
						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn2ndRun		= 1
						bShowRailOn2ndLanding1	= 0
						bShowRailOn2ndLanding2	= 0
						bShowRailOn3rdRun		= 0
						bBreakRailLine			= 1
						brLineAngle				= bet2
						bShowRailPart2			= 1
						breakLineDist			= td2+(NumStline-1)*td2-nosing+(leftRailOffset+leftRailFrameThk)*tan(bet2)
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 1
						gosub "left rail"

						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn2ndRun		= 0
						bShowRailOn2ndLanding1	= 1
						bShowRailOn2ndLanding2	= 1
						bShowRailOn3rdRun		= 1
						bBreakRailLine			= 0
						bRailAboveBreakLine		= 1
						gosub "left rail"
					else
						xNosing = nosing * drawDetails[2]
						poly2_b 7, 1+2*gs_FillAbove+64, gs_fill_pen, gs_back_pen,
							flightWidth+(NumStline-1)*td2-xNosing+leftRailOffset*tan(bet2)+breakLineWidth,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset,1,
							flightWidth+(NumStline-1)*td2-xNosing+(leftRailOffset+leftRailFrameThk)*tan(bet2)+breakLineWidth,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk,1,
							(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset-leftRailFrameThk,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk,1,
							(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset-leftRailFrameThk,(nRisers1stRun-1)*treadDepth-nRisers3rdRun*treadDepth-leftRailOvhgTop,1,
							(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset,(nRisers1stRun-1)*treadDepth-nRisers3rdRun*treadDepth-leftRailOvhgTop,1,
							(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset,1,
							flightWidth+(NumStline-1)*td2-xNosing+leftRailOffset*tan(bet2)+breakLineWidth,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset,-1
					endif
				endif

				if bShowRailAxis then
					line_type railAxisLineType
					pen gs_RailAxisPen
					angleBreak = atn((2*td2)/flightWidth)

					if drawPart[1] then
						xNosing = nosing * drawDetails[1]
						line2 leftRailOffset+leftRailFrameThk/2, (nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2,leftRailOffset+leftRailFrameThk/2,-leftRailOvhgBottom
						line2 leftRailOffset+leftRailFrameThk/2, (nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2, \
								flightWidth+(NumStline-1)*td2-xNosing+(leftRailOffset+leftRailFrameThk/2)*tan(angleBreak),(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2
					endif

					if drawPart[2] then
						xNosing = nosing * drawDetails[2]
						line2 a-leftRailOffset-leftRailFrameThk/2, (nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2,\
							flightWidth+(NumStline-1)*td2-xNosing+(leftRailOffset+leftRailFrameThk/2)*tan(angleBreak)+breakLineWidth, (nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2
						line2 a-leftRailOffset-leftRailFrameThk/2, (nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2,a-leftRailOffset-leftRailFrameThk/2,b-flightWidth-nRisers3rdRun*treadDepth-leftRailOvhgTop
					endif
				endif
			endif

			if hasBreak3rd then
				if drawPart[1] & bShowRailOnFloorPlan then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[1]) then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif
					xNosing = nosing * drawDetails[1]

					if bSymbolic2D then
						bShowRailOn1stRun		= 1
						bShowRailOn1stLanding1	= 1
						bShowRailOn1stLanding2	= 1
						bShowRailOn2ndRun		= 1
						bShowRailOn2ndLanding1	= 1
						bShowRailOn2ndLanding2	= 1
						bShowRailOn3rdRun		= 0
						bBreakRailLine			= 0
						bRailAboveBreakLine		= 0
						gosub "left rail"

						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn2ndRun		= 0
						bShowRailOn2ndLanding1	= 0
						bShowRailOn2ndLanding2	= 0
						bShowRailOn3rdRun		= 1
						bBreakRailLine			= 1
						brLineAngle				= bet
						bShowRailPart1			= 1
						breakLineDist			= b-flightWidth+treadDepth - (((nRisers1stRun-1)-(NumStline-1))*treadDepth-(leftRailOffset+leftRailFrameThk)*tan(bet)+xNosing)
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 0
						gosub "left rail"
					else
						poly2_b  9, 1+2+4+64, gs_fill_pen, gs_back_pen,
							leftRailOffset+leftRailFrameThk,					-leftRailOvhgBottom,1,
							leftRailOffset,										-leftRailOvhgBottom,1,
							leftRailOffset,										(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset,1,
							(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset,	(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset,1,
							(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset,	(nRisers1stRun-1)*treadDepth-(NumStline-1)*treadDepth+xNosing-(leftRailOffset)*tan(bet),1,
							(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset-leftRailFrameThk,(nRisers1stRun-1)*treadDepth-(NumStline-1)*treadDepth+xNosing-(leftRailOffset+leftRailFrameThk)*tan(bet),1,
							(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset-leftRailFrameThk,(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk,1,
							leftRailOffset+leftRailFrameThk,					(nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk,1,
							leftRailOffset+leftRailFrameThk,					-leftRailOvhgBottom,-1
					endif
				endif

				if drawPart[2] & bShowRailOnFloorPlan and bShowRailAboveBreakLine then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[2]) | drawBreakLine then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif

					if bSymbolic2D then
						xNosing = nosing * NOT(drawDetails[2])
						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn2ndRun		= 0
						bShowRailOn2ndLanding1	= 0
						bShowRailOn2ndLanding2	= 0
						bShowRailOn3rdRun		= 1
						bBreakRailLine			= 1
						brLineAngle				= bet
						bShowRailPart2			= 1
						breakLineDist			= b-flightWidth+treadDepth - (((nRisers1stRun-1)-(NumStline-1))*treadDepth-(leftRailOffset+leftRailFrameThk)*tan(bet)+nosing)
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 1
						gosub "left rail"
					else
						xNosing = nosing * drawDetails[2]
						poly2_b 5, 1+2*gs_FillAbove+64, gs_fill_pen, gs_back_pen,
							(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset-leftRailFrameThk,(nRisers1stRun-1)*treadDepth-nRisers3rdRun*treadDepth-leftRailOvhgTop,1,
							(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset,(nRisers1stRun-1)*treadDepth-nRisers3rdRun*treadDepth-leftRailOvhgTop,1,
							(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset,(nRisers1stRun-1)*treadDepth-(NumStline-1)*treadDepth+xNosing-(leftRailOffset)*tan(bet)-breakLineWidth,1,
							(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset-leftRailFrameThk,(nRisers1stRun-1)*treadDepth-(NumStline-1)*treadDepth+xNosing-(leftRailOffset+leftRailFrameThk)*tan(bet)-breakLineWidth,1,
							(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset-leftRailFrameThk,(nRisers1stRun-1)*treadDepth-nRisers3rdRun*treadDepth-leftRailOvhgTop,-1
					endif
				endif

				if bShowRailAxis then
					line_type railAxisLineType
					pen gs_RailAxisPen
					if drawPart[1] then
						xNosing = nosing * drawDetails[1]
							line2 leftRailOffset+leftRailFrameThk/2, (nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2,leftRailOffset+leftRailFrameThk/2,-leftRailOvhgBottom
						line2 leftRailOffset+leftRailFrameThk/2, (nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2,\
							(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset-leftRailFrameThk/2, (nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2
						line2 (nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset-leftRailFrameThk/2, (nRisers1stRun-1)*treadDepth+flightWidth-leftRailOffset-leftRailFrameThk/2,\
							(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset-leftRailFrameThk/2, ((nRisers1stRun-1)-(NumStline-1))*treadDepth-(leftRailOffset+leftRailFrameThk/2)*tan(bet)+xNosing
					endif
					if drawPart[2] then
						xNosing = nosing * drawDetails[2]
						line2 (nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset-leftRailFrameThk/2, -leftRailOvhgTop,(nRisers2ndRun-1)*td2+2*flightWidth-leftRailOffset-leftRailFrameThk/2, \
							((nRisers1stRun-1)-(NumStline-1))*treadDepth-(leftRailOffset+leftRailFrameThk/2)*tan(bet)+xNosing-breakLineWidth
					endif
				endif
			endif
		endif
	endif

	! --- Right Rail ---------------------------------------------------------------
	pen gs_cont_pen
	if rail_m = 2 | rail_m = 1 then		! Right, Both
		if drawPart[3] then
			if bShowRailOnFloorPlan then
				pen railPen
				if aboveStory then
					LINE_TYPE railLineType
				else
					if (drawDashed[3]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE railLineType
					endif
				endif

				if bSymbolic2D then
					bShowRailOn1stRun		= 1
					bShowRailOn1stLanding1	= 1
					bShowRailOn1stLanding2	= 1
					bShowRailOn2ndRun		= 1
					bShowRailOn2ndLanding1	= 1
					bShowRailOn2ndLanding2	= 1
					bShowRailOn3rdRun		= 1
					bBreakRailLine			= 0
					bRailAboveBreakLine		= 0
					gosub "right rail"
				else
					poly2_b 9, 1+2+64, gs_fill_pen, gs_back_pen,
						flightwidth-rightrailoffset,-rightrailovhgbottom,1,
						flightwidth-rightrailoffset-rightrailframethk,-rightrailovhgbottom,1,
						flightwidth-rightrailoffset-rightrailframethk,(nrisers1strun-1)*treaddepth+rightrailoffset+rightrailframethk,1,
						flightwidth+(nrisers2ndrun-1)*td2+rightrailoffset+rightrailframethk,(nrisers1strun-1)*treaddepth+rightrailoffset+rightrailframethk,1,
						flightwidth+(nrisers2ndrun-1)*td2+rightrailoffset+rightrailframethk,(nrisers1strun-1-nrisers3rdrun)*treaddepth-rightrailovhgtop,1,
						flightwidth+(nrisers2ndrun-1)*td2+rightrailoffset,(nrisers1strun-1-nrisers3rdrun)*treaddepth-rightrailovhgtop,1,
						flightwidth+(nrisers2ndrun-1)*td2+rightrailoffset,(nrisers1strun-1)*treaddepth+rightrailoffset,1,
						flightwidth-rightrailoffset,(nrisers1strun-1)*treaddepth+rightrailoffset,1,
						flightwidth-rightrailoffset,-rightrailovhgbottom,-1
				endif
			endif

			if bShowRailAxis then
				line_type railAxisLineType
				pen gs_RailAxisPen
				line2 flightWidth-rightRailOffset-rightRailFrameThk/2, (nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2,
						flightWidth-rightRailOffset-rightRailFrameThk/2,-rightRailOvhgBottom
				line2 flightWidth+(nRisers2ndRun-1)*td2+rightRailFrameThk/2+rightRailOffset, (nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2,
						flightWidth-rightRailOffset-rightRailFrameThk/2,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2
				line2 flightWidth+(nRisers2ndRun-1)*td2+rightRailFrameThk/2+rightRailOffset, (nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2,\
						flightWidth+(nRisers2ndRun-1)*td2+rightRailFrameThk/2+rightRailOffset,b-flightWidth-nRisers3rdRun*treadDepth-rightRailOvhgTop
			endif
		else
			if hasBreak1st then
				if drawPart[1] & bShowRailOnFloorPlan then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[1]) then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif
					xNosing = nosing * drawDetails[1]

					if bSymbolic2D then
						bShowRailOn1stRun		= 1
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn2ndRun		= 0
						bShowRailOn2ndLanding1	= 0
						bShowRailOn2ndLanding2	= 0
						bShowRailOn3rdRun		= 0
						bBreakRailLine			= 1
						brLineAngle				= bet
						bShowRailPart1			= 1
						breakLineDist			= rightRailOvhgBottom - xNosing + (NumStline + 1) * treadDepth - rightRailOffset * TAN(bet)
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 0
						gosub "right rail"
					else
						if drawPart[2] and bShowRailAboveBreakLine then
							poly2_b 5, 1+2+64, gs_fill_pen, gs_back_pen,
								flightWidth-rightRailOffset,-rightRailOvhgBottom,1,
								flightWidth-rightRailOffset-rightRailFrameThk,-rightRailOvhgBottom,1,
								flightWidth-rightRailOffset-rightRailFrameThk,(NumStline+1)*treadDepth-xNosing-(rightRailOffset+rightRailFrameThk)*tan(bet),1,
								flightWidth-rightRailOffset,(NumStline+1)*treadDepth-xNosing-(rightRailOffset)*tan(bet),1,
								flightWidth-rightRailOffset,-rightRailOvhgBottom,-1
						endif
					endif
				endif

				if drawPart[2] & bShowRailOnFloorPlan and bShowRailAboveBreakLine then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[2]) | drawBreakLine then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif
					xNosing = nosing * drawDetails[2]

					if bSymbolic2D then
						xNosing = nosing * NOT(drawDetails[2])
						bShowRailOn1stRun		= 1
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn2ndRun		= 0
						bShowRailOn2ndLanding1	= 0
						bShowRailOn2ndLanding2	= 0
						bShowRailOn3rdRun		= 0
						bBreakRailLine			= 1
						brLineAngle				= bet
						bShowRailPart2			= 1
						breakLineDist			= rightRailOvhgBottom - nosing + (NumStline + 1) * treadDepth - rightRailOffset * TAN(bet)
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 1
						gosub "right rail"

						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 1
						bShowRailOn1stLanding2	= 1
						bShowRailOn2ndRun		= 1
						bShowRailOn2ndLanding1	= 1
						bShowRailOn2ndLanding2	= 1
						bShowRailOn3rdRun		= 1
						bBreakRailLine			= 0
						bRailAboveBreakLine		= 1
						gosub "right rail"
					else
						poly2_b 9, 1+2*gs_FillAbove+64, gs_fill_pen, gs_back_pen,
							flightWidth-rightRailOffset,(nRisers1stRun-1)*treadDepth+rightRailOffset,1,
							flightWidth+(nRisers2ndRun-1)*td2+rightRailOffset,(nRisers1stRun-1)*treadDepth+rightRailOffset,1,
							flightWidth+(nRisers2ndRun-1)*td2+rightRailOffset,(nRisers1stRun-1-nRisers3rdRun)*treadDepth-rightRailOvhgTop,1,
							flightWidth+(nRisers2ndRun-1)*td2+rightRailOffset+rightRailFrameThk,(nRisers1stRun-1-nRisers3rdRun)*treadDepth-rightRailOvhgTop,1,
							flightWidth+(nRisers2ndRun-1)*td2+rightRailOffset+rightRailFrameThk,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk,1,
							flightWidth-rightRailOffset-rightRailFrameThk,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk,1,
							flightWidth-rightRailOffset-rightRailFrameThk,(NumStline+1)*treadDepth-xNosing+breakLineWidth-(rightRailOffset+rightRailFrameThk)*tan(bet),1,
							flightWidth-rightRailOffset,(NumStline+1)*treadDepth-xNosing+breakLineWidth-(rightRailOffset)*tan(bet),1,
							flightWidth-rightRailOffset,(nRisers1stRun-1)*treadDepth+rightRailOffset,-1
					endif
				endif

				if bShowRailAxis then
					line_type railAxisLineType
					pen gs_RailAxisPen
					if drawPart[1] then
						xNosing = nosing * drawDetails[1]
						line2 flightWidth-rightRailOffset-rightRailFrameThk/2, (NumStline+1)*treadDepth-xNosing-(rightRailOffset+rightRailFrameThk/2)*tan(bet),flightWidth-rightRailOffset-rightRailFrameThk/2,-rightRailOvhgBottom
					endif

					if drawPart[2] then
						xNosing = nosing * drawDetails[2]
						line2 flightWidth-rightRailOffset-rightRailFrameThk/2, (NumStline+1)*treadDepth-xNosing+breakLineWidth-(rightRailOffset+rightRailFrameThk/2)*tan(bet),\
								flightWidth-rightRailOffset-rightRailFrameThk/2,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2
						line2 flightWidth+(nRisers2ndRun-1)*td2+rightRailFrameThk/2+rightRailOffset, (nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2,\
								flightWidth-rightRailOffset-rightRailFrameThk/2,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2
						line2 flightWidth+(nRisers2ndRun-1)*td2+rightRailFrameThk/2+rightRailOffset, (nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2,\
								flightWidth+(nRisers2ndRun-1)*td2+rightRailFrameThk/2+rightRailOffset,b-flightWidth-nRisers3rdRun*treadDepth-rightRailOvhgTop
					endif
				endif
			endif

			if hasBreak2nd then
				if drawPart[1] & bShowRailOnFloorPlan then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[1]) then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif
					xNosing = nosing * drawDetails[1]

					if bSymbolic2D then
						bShowRailOn1stRun		= 1
						bShowRailOn1stLanding1	= 1
						bShowRailOn1stLanding2	= 1
						bShowRailOn2ndRun		= 0
						bShowRailOn2ndLanding1	= 0
						bShowRailOn2ndLanding2	= 0
						bShowRailOn3rdRun		= 0
						bBreakRailLine			= 0
						bRailAboveBreakLine		= 0
						gosub "right rail"

						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn2ndRun		= 1
						bShowRailOn2ndLanding1	= 0
						bShowRailOn2ndLanding2	= 0
						bShowRailOn3rdRun		= 0
						bBreakRailLine			= 1
						brLineAngle				= bet2
						bShowRailPart1			= 1
						breakLineDist			= min(rightRailOffset,td2)+(NumStline+1)*td2-xNosing-(rightRailOffset)*tan(bet2)
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 0
						gosub "right rail"
					else
						poly2_b 7, 1+2+4+64, gs_fill_pen, gs_back_pen,
							flightWidth-rightRailOffset-rightRailFrameThk,-rightRailOvhgBottom,1,
							flightWidth-rightRailOffset,-rightRailOvhgBottom,1,
							flightWidth-rightRailOffset,(nRisers1stRun-1)*treadDepth+rightRailOffset,1,
							flightWidth+(NumStline+1)*td2-xNosing-(rightRailOffset)*tan(bet2),(nRisers1stRun-1)*treadDepth+rightRailOffset,1,
							flightWidth+(NumStline+1)*td2-xNosing-(rightRailOffset+rightRailFrameThk)*tan(bet2),(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk,1,
							flightWidth-rightRailOffset-rightRailFrameThk,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk,1,
							flightWidth-rightRailOffset-rightRailFrameThk,-rightRailOvhgBottom,-1
					endif
				endif

				if drawPart[2] & bShowRailOnFloorPlan and bShowRailAboveBreakLine then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[2]) | drawBreakLine then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif

					if bSymbolic2D then
						xNosing = nosing * NOT(drawDetails[2])
						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn2ndRun		= 1
						bShowRailOn2ndLanding1	= 0
						bShowRailOn2ndLanding2	= 0
						bShowRailOn3rdRun		= 0
						bBreakRailLine			= 1
						brLineAngle				= bet2
						bShowRailPart2			= 1
						breakLineDist			= min(rightRailOffset,td2)+(NumStline+1)*td2-nosing-(rightRailOffset)*tan(bet2)
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 1
						gosub "right rail"

						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn2ndRun		= 0
						bShowRailOn2ndLanding1	= 1
						bShowRailOn2ndLanding2	= 1
						bShowRailOn3rdRun		= 1
						bBreakRailLine			= 0
						bRailAboveBreakLine		= 1
						gosub "right rail"
					else
						xNosing = nosing * drawDetails[2]
						poly2_b 7, 1+2*gs_FillAbove+64, gs_fill_pen, gs_back_pen,
							flightWidth+(NumStline+1)*td2-xNosing-rightRailOffset*tan(bet2)+breakLineWidth,(nRisers1stRun-1)*treadDepth+rightRailOffset,1,
							flightWidth+(NumStline+1)*td2-xNosing-(rightRailOffset+rightRailFrameThk)*tan(bet2)+breakLineWidth,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk,1,
							(nRisers2ndRun-1)*td2+flightWidth+rightRailOffset+rightRailFrameThk,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk,1,
							(nRisers2ndRun-1)*td2+flightWidth+rightRailOffset+rightRailFrameThk,(nRisers1stRun-1)*treadDepth-nRisers3rdRun*treadDepth-rightRailOvhgTop,1,
							(nRisers2ndRun-1)*td2+flightWidth+rightRailOffset,(nRisers1stRun-1)*treadDepth-nRisers3rdRun*treadDepth-rightRailOvhgTop,1,
							(nRisers2ndRun-1)*td2+flightWidth+rightRailOffset,(nRisers1stRun-1)*treadDepth+rightRailOffset,1,
							flightWidth+(NumStline+1)*td2-xNosing-rightRailOffset*tan(bet2)+breakLineWidth,(nRisers1stRun-1)*treadDepth+rightRailOffset,-1
					endif
				endif

				if bShowRailAxis then
					line_type railAxisLineType
					pen gs_RailAxisPen
					angleBreak = atn((2*td2)/flightWidth)

					if drawPart[1] then
						xNosing = nosing * drawDetails[1]
						line2 flightWidth-rightRailOffset-rightRailFrameThk/2, (nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2,flightWidth-rightRailOffset-rightRailFrameThk/2,-rightRailOvhgBottom
						line2 flightWidth+(NumStline+1)*td2-xNosing-(rightRailOffset+rightRailFrameThk/2)*tan(angleBreak), \
								(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2,flightWidth-rightRailOffset-rightRailFrameThk/2,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2
					endif
					if drawPart[2] then
						xNosing = nosing * drawDetails[2]
						line2 flightWidth+(nRisers2ndRun-1)*td2+rightRailFrameThk/2+rightRailOffset, (nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2,\
								flightWidth+(NumStline+1)*td2-xNosing-(rightRailOffset+rightRailFrameThk/2)*tan(angleBreak)+breakLineWidth,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2
						line2 flightWidth+(nRisers2ndRun-1)*td2+rightRailFrameThk/2+rightRailOffset, (nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2,\
								flightWidth+(nRisers2ndRun-1)*td2+rightRailFrameThk/2+rightRailOffset,b-flightWidth-nRisers3rdRun*treadDepth-rightRailOvhgTop
					endif
				endif
			endif

			if hasBreak3rd then
				if drawPart[1] & bShowRailOnFloorPlan then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[1]) then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif
					xNosing = nosing * drawDetails[1]

					if bSymbolic2D then
						bShowRailOn1stRun		= 1
						bShowRailOn1stLanding1	= 1
						bShowRailOn1stLanding2	= 1
						bShowRailOn2ndRun		= 1
						bShowRailOn2ndLanding1	= 1
						bShowRailOn2ndLanding2	= 1
						bShowRailOn3rdRun		= 0
						bBreakRailLine			= 0
						bRailAboveBreakLine		= 0
						gosub "right rail"

						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn2ndRun		= 0
						bShowRailOn2ndLanding1	= 0
						bShowRailOn2ndLanding2	= 0
						bShowRailOn3rdRun		= 1
						bBreakRailLine			= 1
						brLineAngle				= bet
						bShowRailPart1			= 1
						breakLineDist			= (nRisers1stRun-1)*treadDepth+min(rightRailOffset,treadDepth) - ((nRisers1stRun-1)*treadDepth-(NumStline+1)*treadDepth+xNosing+(rightRailOffset)*tan(bet))
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 0
						gosub "right rail"
					else
						poly2_b 9, 1+2+4+64, gs_fill_pen, gs_back_pen,
							flightWidth-rightRailOffset,-rightRailOvhgBottom,1,
							flightWidth-rightRailOffset-rightRailFrameThk,-rightRailOvhgBottom,1,
							flightWidth-rightRailOffset-rightRailFrameThk,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk,1,
							flightWidth+(nRisers2ndRun-1)*td2+rightRailOffset+rightRailFrameThk,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk,1,
							flightWidth+(nRisers2ndRun-1)*td2+rightRailOffset+rightRailFrameThk,((nRisers1stRun-1)-(NumStline+1))*treadDepth+xNosing+(rightRailOffset+rightRailFrameThk)*tan(bet),1,
							flightWidth+(nRisers2ndRun-1)*td2+rightRailOffset,((nRisers1stRun-1)-(NumStline+1))*treadDepth+xNosing+(rightRailOffset)*tan(bet),1,
							flightWidth+(nRisers2ndRun-1)*td2+rightRailOffset,(nRisers1stRun-1)*treadDepth+rightRailOffset,1,
							flightWidth-rightRailOffset,(nRisers1stRun-1)*treadDepth+rightRailOffset,1,
							flightWidth-rightRailOffset,-rightRailOvhgBottom,-1
					endif
				endif

				if drawPart[2] & bShowRailOnFloorPlan and bShowRailAboveBreakLine then
					pen railPen
					if aboveStory then
						LINE_TYPE railLineType
					else
						if (drawDashed[2]) | drawBreakLine then
							LINE_TYPE dash_line
						else
							LINE_TYPE railLineType
						endif
					endif

					if bSymbolic2D then
						xNosing = nosing * NOT(drawDetails[2])
						bShowRailOn1stRun		= 0
						bShowRailOn1stLanding1	= 0
						bShowRailOn1stLanding2	= 0
						bShowRailOn2ndRun		= 0
						bShowRailOn2ndLanding1	= 0
						bShowRailOn2ndLanding2	= 0
						bShowRailOn3rdRun		= 1
						bBreakRailLine			= 1
						brLineAngle				= bet
						bShowRailPart2			= 1
						breakLineDist			= (nRisers1stRun-1)*treadDepth+min(rightRailOffset,treadDepth) - ((nRisers1stRun-1)*treadDepth-(NumStline+1)*treadDepth+nosing+(rightRailOffset)*tan(bet))
						breakLineW				= breakLineWidth + xNosing
						bRailAboveBreakLine		= 1
						gosub "right rail"
					else
						xNosing = nosing * drawDetails[2]
						poly2_b 5, 1+2*gs_FillAbove+64, gs_fill_pen, gs_back_pen,
							(nRisers2ndRun-1)*td2+flightWidth+rightRailOffset+rightRailFrameThk,(nRisers1stRun-1)*treadDepth-nRisers3rdRun*treadDepth-rightRailOvhgTop,1,
							(nRisers2ndRun-1)*td2+flightWidth+rightRailOffset,(nRisers1stRun-1)*treadDepth-nRisers3rdRun*treadDepth-rightRailOvhgTop,1,
							(nRisers2ndRun-1)*td2+flightWidth+rightRailOffset,(nRisers1stRun-1)*treadDepth-(NumStline+1)*treadDepth+xNosing+(rightRailOffset)*tan(bet)-breakLineWidth,1,
							(nRisers2ndRun-1)*td2+flightWidth+rightRailOffset+rightRailFrameThk,(nRisers1stRun-1)*treadDepth-(NumStline+1)*treadDepth+xNosing+(rightRailOffset+rightRailFrameThk)*tan(bet)-breakLineWidth,1,
							(nRisers2ndRun-1)*td2+flightWidth+rightRailOffset+rightRailFrameThk,(nRisers1stRun-1)*treadDepth-nRisers3rdRun*treadDepth-rightRailOvhgTop,-1
					endif
				endif
				if bShowRailAxis then
					line_type railAxisLineType
					pen gs_RailAxisPen
					if drawPart[1] then
						xNosing = nosing * drawDetails[1]
						line2 flightWidth-rightRailOffset-rightRailFrameThk/2, (nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2,\
								flightWidth-rightRailOffset-rightRailFrameThk/2,-rightRailOvhgBottom
						line2 flightWidth+(nRisers2ndRun-1)*td2+rightRailFrameThk/2+rightRailOffset, (nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2,\
								flightWidth-rightRailOffset-rightRailFrameThk/2,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2
						line2 (nRisers2ndRun-1)*td2+flightWidth+rightRailOffset+rightRailFrameThk/2,(nRisers1stRun-1)*treadDepth-(NumStline+1)*treadDepth+xNosing+(rightRailOffset + rightRailFrameThk/2)*tan(bet),\
								(nRisers2ndRun-1)*td2+flightWidth+rightRailOffset+rightRailFrameThk/2, (nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2
					endif
					if drawPart[2] then
						xNosing = nosing * drawDetails[2]
						line2 (nRisers2ndRun-1)*td2+flightWidth+rightRailOffset+rightRailFrameThk/2,(nRisers1stRun-1)*treadDepth-(NumStline+1)*treadDepth+xNosing+(rightRailOffset + rightRailFrameThk/2)*tan(bet)-breakLineWidth,\
								(nRisers2ndRun-1)*td2+flightWidth+rightRailOffset+rightRailFrameThk/2, -rightRailOvhgTop
					endif
				endif
			endif
		endif
	endif
endif


! ==============================================================================
! Text / Up - Down Text / Numbering
! ==============================================================================

! --- Oriented View ------------------------------------------------------------
angleViewRot = 0
if bShowRiseAndRunText | walkingDirUPDN_m <> 1 | drawNum | gs_description <> "" then
	rrr = REQUEST ("View_Rotangle", "", angleViewRot)
endif
totalRotate = (SYMB_ROTANGLE + angleViewRot) MOD 360


! --- Define Font Style --------------------------------------------------------

define style "UPDN" fontType, UPDNfontsize, 5, 0		  	! UP/DN

define style "stepnum" fontType, gs_NumTextSize, 1, 0		! Numbering

define style "description" fontType, gs_desc_text_size, 4, 0	! Description

! --- Rise & Run Text -------------------------------------------------------

if bShowRiseAndRunText & bShowWalkLine & not(belowStory) then
	call "Stair_RiseRun_Text" PARAMETERS ALL	totalRotate	= totalRotate,
												iRotateType = 1,
												iRiseRunTextPosition = 1,
												RiseRunUNID	= RiseRunUNID
endif


! --- Up & Down Text ---------------------------------------------------------
iReadable = 0
if walkingDirUPDN_m <> 1 & bShowWalkLine & not(belowStory) then		! None
	DRAWINDEX 50
	PEN UPDNfontpen
	xNosing = nosing * (drawDetails[1]|drawDetails[3])

	if (walkingDirUPDN_m = 2 | walkingDirUPDN_m = 5 | (walkingDirUPDN_m = 6 & not(abovestory) & not(belowstory) )) & (drawPart[1]|drawPart[3]) then
		nTransUPDN = 0
		set style "UPDN"
		add2 flightWidth/2+DirUPDN_X,DirUPDN_Y-xNosing
		nTransUPDN = nTransUPDN + 1
		! Text Rotation - Readable / Parallel with Walking Line / Align with Symbol
		! ----------------------------------------------------------------------
		if typeTextRotation_UpDn_m = 2 then									! Readable
			if (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps)) then
				rot2 180
				nTransUPDN = nTransUPDN + 1
			endif
		else
			if typeTextRotation_UpDn_m = 1 then								! Parallel with Walking Line
				if SYMB_MIRRORED then
					iReadable = not(totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps)) - (totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps))
				else
					iReadable = not(totalRotate < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps)) - (totalRotate < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps))
				endif
				rot2 -90 * iReadable
				nTransUPDN = nTransUPDN + 1
			endif
		endif
		! ----------------------------------------------------------------------
		rot2 AngUPDN
		nTransUPDN = nTransUPDN + 1

		string1	= `ВВЕРХ`
		text2 0,0, string1

		del nTransUPDN

		width1	= STW (string1)/1000*GLOB_SCALE
		rb		= width1/2
	endif

	if walkingDirUPDN_m = 3 & (drawPart[1]|drawPart[3]) then ! Down at Bottom
		nTransUPDN = 0
		set style "UPDN"
		add2 flightWidth/2+DirUPDN_X,DirUPDN_Y-xNosing
		nTransUPDN = nTransUPDN + 1

		! Text Rotation - Readable / Parallel with Walking Line / Align with Symbol
		! ----------------------------------------------------------------------
		if typeTextRotation_UpDn_m = 2 then									! Readable
			if (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps)) then
				rot2 180
				nTransUPDN = nTransUPDN + 1
			endif
		else
			if typeTextRotation_UpDn_m = 1 then								! Parallel with Walking Line
				if SYMB_MIRRORED then
					iReadable = not(totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps)) - (totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps))
				else
					iReadable = not(totalRotate < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps)) - (totalRotate < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps))
				endif
				rot2 -90 * iReadable
				nTransUPDN = nTransUPDN + 1
			endif
		endif
		! ----------------------------------------------------------------------
		rot2 AngUPDN
		nTransUPDN = nTransUPDN + 1

		text2 0,0, gs_CustomText_Down

		del nTransUPDN

		string2	= gs_CustomText_Down
		width2	= STW (string2)/1000*GLOB_SCALE
		rb		= width2/2
	endif

	if (walkingDirUPDN_m = 2 | walkingDirUPDN_m = 5 | walkingDirUPDN_m = 3 | (walkingDirUPDN_m = 6 & not(abovestory) & not(belowstory))) & (drawPart[1]|drawPart[3]) then
		nTransHotspot = 0
		add2 flightWidth/2+DirUPDN_X,DirUPDN_Y-xNosing
		nTransHotspot = nTransHotspot  + 1
		if typeTextRotation_UpDn_m = 1 then
			rot2 -90 * iReadable
			nTransHotspot = nTransHotspot  + 1
		endif
		HOTSPOT2 0,					0,				UpDownUNID,	AngUPDN,	6		: UpDownUNID=UpDownUNID+1
		HOTSPOT2 rb,				0,				UpDownUNID,	AngUPDN,	4+128	: UpDownUNID=UpDownUNID+1
		HOTSPOT2 rb*cos(AngUPDN),	rb*sin(AngUPDN),UpDownUNID,	AngUPDN,	5		: UpDownUNID=UpDownUNID+1
		DEL nTransHotspot
	endif

	if (walkingDirUPDN_m = 4 | walkingDirUPDN_m = 5 | (walkingDirUPDN_m = 6 & abovestory)) & (drawPart[2]|drawPart[3]) then
		nTransUPDN = 0
		set style "UPDN"
		add2 A-flightWidth/2+DirUPDN_X_top,DirUPDN_Y_top
		nTransUPDN = nTransUPDN + 1

		! Text Rotation - Readable / Parallel with Walking Line / Align with Symbol
		! ----------------------------------------------------------------------
		if typeTextRotation_UpDn_m = 2 then									! Readable
			if (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps)) then
				rot2 180
				nTransUPDN = nTransUPDN + 1
			endif
		else
			if typeTextRotation_UpDn_m = 1 then								! Parallel with Walking Line
				if SYMB_MIRRORED then
					iReadable = not(totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps)) - (totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps))
				else
					iReadable = not(totalRotate < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps)) - (totalRotate < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps))
				endif
				rot2 -90 * iReadable
				nTransUPDN = nTransUPDN + 1
			endif
		endif
		! ----------------------------------------------------------------------
		ROT2 AngUPDN_top
		nTransUPDN = nTransUPDN + 1

		text2 0,0, gs_CustomText_Down

		del nTransUPDN

		string2	= gs_CustomText_Down
		width2	= STW (string2)/1000*GLOB_SCALE
		rb		= width2/2
	endif

	if (walkingDirUPDN_m = 4 | walkingDirUPDN_m = 5 | (walkingDirUPDN_m = 6 & abovestory)) & (drawPart[2]|drawPart[3]) then
		nTransHotspot = 0
		ADD2 A-flightWidth/2+DirUPDN_X_top,DirUPDN_Y_top
		nTransHotspot = nTransHotspot  + 1
		if typeTextRotation_UpDn_m = 1 then
			rot2 -90 * iReadable
			nTransHotspot = nTransHotspot  + 1
		endif
		HOTSPOT2 0,						0,					UpDownUNID,	AngUPDN_top,	6		: UpDownUNID=UpDownUNID+1
		HOTSPOT2 rb,					0,					UpDownUNID,	AngUPDN_top,	4+128	: UpDownUNID=UpDownUNID+1
		HOTSPOT2 rb*cos(AngUPDN_top),	rb*sin(AngUPDN_top),UpDownUNID,	AngUPDN_top,	5		: UpDownUNID=UpDownUNID+1
		DEL nTransHotspot
	endif
endif

! --- Numbering ----------------------------------------------------------------

if drawNum & not(belowStory) then
	startNumber	= 1
	endNumber	= nRisers1stRun
	td_t = treadDepth

	xNosing = nosing * (drawDetails[1]|drawDetails[3])

	FOR iNumFlight = 1 to 3
		if iNumFlight = 1 | iNumFlight = 3 then treadDepth = treadDepth
		if iNumFlight = 2 then treadDepth = td2
		DRAWINDEX 50

		set style "stepnum"
		nnn = REQUEST ("Height_of_style", "stepnum", strHeight)
		strHeight = strHeight / 1000 * GLOB_SCALE
		add2 DirNumText_X, DirNumText_Y - treadDepth/2- xNosing

		bReadable = 0
		if iNumFlight = 1 then
			bReadable = (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps))
		else
			if iNumFlight = 2 then
				if SYMB_MIRRORED then
					bReadable = (totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps))
				else
					bReadable = (totalRotate < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps))
				endif
			else
				bReadable = (totalRotate < (gs_readable_angle + eps) | totalRotate > (gs_readable_angle + 180 + eps))
			endif
		endif

		for iNumStep = startNumber to endNumber
			add2 0, treadDepth
			pen gs_NumTextPen
			nTextTransformations = 0
			! Text Rotation - Readable / Align with Symbol
			! ----------------------------------------------------------------------
			if typeTextRotation_Num_m = 2 & bReadable = 1 then								! Readable
				rot2 180
				strWidth = STW(str("%.0", iNumStep + nStartNumbering-1)) / 1000 * GLOB_SCALE
				add2 -strWidth, strHeight
				nTextTransformations = 2
			endif
			! ----------------------------------------------------------------------

			text2 0,0,iNumStep + nStartNumbering-1
			if nTextTransformations > 0 then del nTextTransformations
			pen gs_cont_pen
		next iNumStep
		del (endNumber - startNumber + 1) + 1

		treadDepth = td_t

		if iNumFlight = 1 then
			startNumber = nRisers1stRun + 1
			endNumber	= nRisers1stRun + nRisers2ndRun
			add2 flightWidth,(nRisers1stRun-1)*treadDepth+flightWidth
			rot2 -90
		endif
		if iNumFlight = 2 then
			startNumber = nRisers1stRun + nRisers2ndRun + 1
			endNumber = nRisers
			add2 flightWidth,(nRisers2ndRun-1)*td2+flightWidth
			rot2 -90
		endif
	next iNumFlight
	del 4

	hotspot2 0,				DirNumText_Y- xNosing,	NumUnID, DirNumText_X,	1+128	:NumUnID=NumUnID+1
	hotspot2 -1,			DirNumText_Y- xNosing,	NumUnID, DirNumText_X,	3		:NumUnID=NumUnID+1
	hotspot2 DirNumText_X,	DirNumText_Y- xNosing,	NumUnID, DirNumText_X,	2		:NumUnID=NumUnID+1

	hotspot2 DirNumText_X, - xNosing,				NumUnID, DirNumText_Y, 1+128	:NumUnID=NumUnID+1
	hotspot2 DirNumText_X, -1,				NumUnID, DirNumText_Y, 3		:NumUnID=NumUnID+1
	hotspot2 DirNumText_X, DirNumText_Y- xNosing,	NumUnID, DirNumText_Y,	2		:NumUnID=NumUnID+1
endif

! --- Description ----------------------------------------------------------------

if STRLEN(gs_description) <> 0 & not(belowStory) then
	lengthWalkLine = A+2*(B-flightWidth)

	dim gs_description_bpos[3][3]
	gs_description_bpos[1][1] = flightWidth + lengthWalkLine/2 - B
	gs_description_bpos[1][2] = B-flightWidth/2
	gs_description_bpos[1][3] = 0

	style "description"
	pen gs_desc_text_pen
	add2 (gs_description_bpos[1][1] + gs_description_pos[1][1]), (gs_description_bpos[1][2] + gs_description_pos[1][2])

	textangle = (gs_description_bpos[1][3] + gs_description_pos[1][3])

	reversedText = 0
	angleFull = (totalRotate + textangle) MOD 360

	if angleFull < 0 then
		angleFull = angleFull + 360
	endif
	if angleFull > (gs_readable_angle+eps) & angleFull < (gs_readable_angle + 180 +eps) then
		reversedText = 1
		textangle = textangle + 180
	endif
	rot2 textangle

	if reversedText then
		text2 -STW(gs_description) / 1000 * GLOB_SCALE, 0, gs_description
	else
		text2 0,0, gs_description
	endif

	del 2
	hotspot2 gs_description_bpos[1][1], gs_description_bpos[1][2] + gs_description_pos[1][2], 40000+1, gs_description_pos[1][1], 1 + 128
	posRel = gs_description_pos[1][1]
	if abs(posRel) < 0.00001 then
		posRel = 0.0001
	else
		posRel = 0
	endif
	hotspot2 gs_description_bpos[1][1] - posRel, gs_description_bpos[1][2] + gs_description_pos[1][2], 40000+2, gs_description_pos[1][1], 3 + 128
	hotspot2 gs_description_bpos[1][1] + gs_description_pos[1][1], gs_description_bpos[1][2] + gs_description_pos[1][2], 40000+3, gs_description_pos[1][1], 2

	hotspot2 gs_description_bpos[1][1] + gs_description_pos[1][1], gs_description_bpos[1][2], 40000+4, gs_description_pos[1][2], 1 + 128
	posRel = gs_description_pos[1][2]
	if abs(posRel) < 0.00001 then
		posRel = 0.0001
	else
		posRel = 0
	endif
	hotspot2 gs_description_bpos[1][1] + gs_description_pos[1][1], gs_description_bpos[1][2] - posRel, 40000+5, gs_description_pos[1][2], 3 + 128
	hotspot2 gs_description_bpos[1][1] + gs_description_pos[1][1], gs_description_bpos[1][2] + gs_description_pos[1][2], 40000+6, gs_description_pos[1][2], 2

	!angle edit
	HOTSPOT2 gs_description_bpos[1][1] + gs_description_pos[1][1],
				gs_description_bpos[1][2] + gs_description_pos[1][2],
				40000+7, gs_description_pos[1][3], 6 + 128

	HOTSPOT2 gs_description_bpos[1][1] + gs_description_pos[1][1] + GLOB_SCALE*0.5*COS(gs_description_bpos[1][3])*gs_desc_text_size/1000,
				gs_description_bpos[1][2] + gs_description_pos[1][2] + GLOB_SCALE*0.5*SIN(gs_description_bpos[1][3])*gs_desc_text_size/1000,
				40000+8, gs_description_pos[1][3], 4 + 128

	HOTSPOT2 gs_description_bpos[1][1] + gs_description_pos[1][1] + GLOB_SCALE*0.5*gs_desc_text_size*COS(gs_description_bpos[1][3] + gs_description_pos[1][3])/1000,
				gs_description_bpos[1][2] + gs_description_pos[1][2] + GLOB_SCALE*0.5*gs_desc_text_size*SIN(gs_description_bpos[1][3] + gs_description_pos[1][3])/1000,
				40000+9, gs_description_pos[1][3], 5
endif

!===================================================================
! HOTSPOT EDITING in 2D
!===================================================================
DRAWINDEX 50
!-- FLIGHT WIDTH ---------------------------------------------------
xNosing = nosing * (drawDetails[1]|drawDetails[3])

	HOTSPOT2 0,				0,	FlightUNID, flightWidth, 1+128	: FlightUNID=FlightUNID+1
	HOTSPOT2 flightWidth,	0,	FlightUNID, flightWidth, 2		: FlightUNID=FlightUNID+1
	HOTSPOT2 -0.1,			0,	FlightUNID, flightWidth, 3		: FlightUNID=FlightUNID+1

	HOTSPOT2 a,				0,	FlightUNID, flightWidth, 1+128	: FlightUNID=FlightUNID+1
	HOTSPOT2 a-flightWidth,	0,	FlightUNID, flightWidth, 2		: FlightUNID=FlightUNID+1
	HOTSPOT2 a+0.1,			0,	FlightUNID, flightWidth, 3		: FlightUNID=FlightUNID+1

	HOTSPOT2 flightWidth,(nRisers1stRun-1)*treadDepth+flightWidth,		FlightUNID, flightWidth, 1+128	: FlightUNID=FlightUNID+1
	HOTSPOT2 flightWidth,(nRisers1stRun-1)*treadDepth,					FlightUNID, flightWidth, 2		: FlightUNID=FlightUNID+1
	HOTSPOT2 flightWidth,(nRisers1stRun-1)*treadDepth+flightWidth+0.1,	FlightUNID, flightWidth, 3		: FlightUNID=FlightUNID+1

	HOTSPOT2 flightWidth+(nRisers2ndRun-1)*td2,(nRisers1stRun-1)*treadDepth+flightWidth,	FlightUNID, flightWidth, 1+128 : FlightUNID=FlightUNID+1
	HOTSPOT2 flightWidth+(nRisers2ndRun-1)*td2,(nRisers1stRun-1)*treadDepth,				FlightUNID, flightWidth, 2		: FlightUNID=FlightUNID+1
	HOTSPOT2 flightWidth+(nRisers2ndRun-1)*td2,(nRisers1stRun-1)*treadDepth+flightWidth+0.1,FlightUNID, flightWidth, 3		: FlightUNID=FlightUNID+1

	HOTSPOT2 a,	0,	FlightUNID, b, 1+256	: FlightUNID=FlightUNID+1
	HOTSPOT2 a,	b,	FlightUNID, b, 2		: FlightUNID=FlightUNID+1
	HOTSPOT2 a,	-1,	FlightUNID, b, 3		: FlightUNID=FlightUNID+1

	HOTSPOT2 0,0,	FlightUNID, b, 1+256	: FlightUNID=FlightUNID+1
	HOTSPOT2 0,b,	FlightUNID, b, 2		: FlightUNID=FlightUNID+1
	HOTSPOT2 0,-1,	FlightUNID, b, 3		: FlightUNID=FlightUNID+1

	HOTSPOT2 0,b,	FlightUNID, a, 1+256	: FlightUNID=FlightUNID+1
	HOTSPOT2 a,b,	FlightUNID, a, 2		: FlightUNID=FlightUNID+1
	HOTSPOT2 0,-1,	FlightUNID, a, 3		: FlightUNID=FlightUNID+1

!!! UP/DOWN TEXT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
IF bShowWalkLine & not(belowStory) THEN
	IF (walkingDirUPDN_m = 2 | walkingDirUPDN_m = 3 | walkingDirUPDN_m = 5) & bShowWalkLine then
		HOTSPOT2 flightWidth/2,				DirUPDN_Y-xNosing, UpDownUNID, DirUPDN_X, 1+128		: UpDownUNID=UpDownUNID+1
		HOTSPOT2 flightWidth/2-1,			DirUPDN_Y-xNosing, UpDownUNID, DirUPDN_X, 3			: UpDownUNID=UpDownUNID+1
		HOTSPOT2 flightWidth/2+DirUPDN_X,	DirUPDN_Y-xNosing, UpDownUNID, DirUPDN_X, 2			: UpDownUNID=UpDownUNID+1

		HOTSPOT2 flightWidth/2+DirUPDN_X,	0-xNosing,			UpDownUNID, DirUPDN_Y, 1+128	: UpDownUNID=UpDownUNID+1
		HOTSPOT2 flightWidth/2+DirUPDN_X,	-1,			UpDownUNID, DirUPDN_Y, 3		: UpDownUNID=UpDownUNID+1
		HOTSPOT2 flightWidth/2+DirUPDN_X,	DirUPDN_Y-xNosing,	UpDownUNID, DirUPDN_Y, 2		: UpDownUNID=UpDownUNID+1
	ENDIF
	IF (walkingDirUPDN_m = 4 | walkingDirUPDN_m = 5) & bShowWalkLine then
		HOTSPOT2 A-flightWidth/2,				DirUPDN_Y_top, UpDownUNID, DirUPDN_X_top, 1+128		: UpDownUNID=UpDownUNID+1
		HOTSPOT2 A-flightWidth/2-1,				DirUPDN_Y_top, UpDownUNID, DirUPDN_X_top, 3			: UpDownUNID=UpDownUNID+1
		HOTSPOT2 A-flightWidth/2+DirUPDN_X_top,	DirUPDN_Y_top, UpDownUNID, DirUPDN_X_top, 2			: UpDownUNID=UpDownUNID+1

		HOTSPOT2 A-flightWidth/2+DirUPDN_X_top,	0,				UpDownUNID, DirUPDN_Y_top, 1+128	: UpDownUNID=UpDownUNID+1
		HOTSPOT2 A-flightWidth/2+DirUPDN_X_top,	-1,				UpDownUNID, DirUPDN_Y_top, 3		: UpDownUNID=UpDownUNID+1
		HOTSPOT2 A-flightWidth/2+DirUPDN_X_top,DirUPDN_Y_top,	UpDownUNID, DirUPDN_Y_top, 2		: UpDownUNID=UpDownUNID+1
	ENDIF
endif

!-- RAILING  ---------------------------------------------------
if _bShowRailIn2D & bShowRailOnFloorPlan & not(belowStory) then
xNosing = 0 ! COMP nosing * (drawDetails[1]|drawDetails[3])

IF rail_m = 2 | rail_m = 1 THEN		! Right, Both

		!!! RAIL OFFSET - right
		HOTSPOT2 flightWidth-rightRailFrameThk/2,					-rightRailOvhgBottom, RailUNID, rightRailOffset, 1+128 : RailUNID=RailUNID+1
		HOTSPOT2 flightWidth-rightRailFrameThk/2-rightRailOffset,	-rightRailOvhgBottom, RailUNID, rightRailOffset, 2 : RailUNID=RailUNID+1
		HOTSPOT2 flightWidth-rightRailFrameThk/2-0.1,				-rightRailOvhgBottom, RailUNID, rightRailOffset, 3 : RailUNID=RailUNID+1

		HOTSPOT2 flightWidth+(nRisers2ndRun-1)*td2+rightRailFrameThk/2,					(nRisers1stRun-1-nRisers3rdRun)*treadDepth-rightRailOvhgTop, RailUNID, rightRailOffset, 1+128 : RailUNID=RailUNID+1
		HOTSPOT2 flightWidth+(nRisers2ndRun-1)*td2+rightRailFrameThk/2+0.1,				(nRisers1stRun-1-nRisers3rdRun)*treadDepth-rightRailOvhgTop, RailUNID, rightRailOffset, 3 : RailUNID=RailUNID+1
		HOTSPOT2 flightWidth+(nRisers2ndRun-1)*td2+rightRailOffset+rightRailFrameThk/2,	(nRisers1stRun-1-nRisers3rdRun)*treadDepth-rightRailOvhgTop, RailUNID, rightRailOffset, 2 : RailUNID=RailUNID+1

		!!! RAIL BOTTOM OVERHANG
		HOTSPOT2 flightWidth-rightRailFrameThk/2-rightRailOffset,		0,						RailUNID, rightRailOvhgBottom, 1+128	: RailUNID=RailUNID+1
		HOTSPOT2 flightWidth-rightRailFrameThk/2-rightRailOffset,		0+1,					RailUNID, rightRailOvhgBottom, 3		: RailUNID=RailUNID+1
		HOTSPOT2 flightWidth-rightRailFrameThk/2-rightRailOffset,		0-rightRailOvhgBottom,	RailUNID, rightRailOvhgBottom, 2		: RailUNID=RailUNID+1

		!!! RAIL TOP OVERHANG
		HOTSPOT2 flightWidth+(nRisers2ndRun-1)*td2+rightRailOffset+rightRailFrameThk/2,		(nRisers1stRun-1-nRisers3rdRun)*treadDepth,		RailUNID, rightRailOvhgTop, 1+128 : RailUNID=RailUNID+1
		HOTSPOT2 flightWidth+(nRisers2ndRun-1)*td2+rightRailOffset+rightRailFrameThk/2,		(nRisers1stRun-1-nRisers3rdRun)*treadDepth+0.1, RailUNID, rightRailOvhgTop, 3 : RailUNID=RailUNID+1
		HOTSPOT2 flightWidth+(nRisers2ndRun-1)*td2+rightRailOffset+rightRailFrameThk/2,		(nRisers1stRun-1-nRisers3rdRun)*treadDepth-rightRailOvhgTop, RailUNID, rightRailOvhgTop, 2 : RailUNID=RailUNID+1
ENDIF

IF rail_m = 3 | rail_m = 1 THEN		! Left, Both

		!!! RAIL OFFSET - left
		HOTSPOT2 leftRailFrameThk/2,				-leftRailOvhgBottom, RailUNID, leftRailOffset, 1+128 : RailUNID=RailUNID+1
		HOTSPOT2 leftRailFrameThk/2+leftRailOffset,	-leftRailOvhgBottom, RailUNID, leftRailOffset, 2 : RailUNID=RailUNID+1
		HOTSPOT2 leftRailFrameThk/2+0.1,			-leftRailOvhgBottom, RailUNID, leftRailOffset, 3 : RailUNID=RailUNID+1

		HOTSPOT2 2*flightWidth+(nRisers2ndRun-1)*td2-leftRailFrameThk/2,				(nRisers1stRun-1-nRisers3rdRun)*treadDepth-leftRailOvhgTop, RailUNID, leftRailOffset, 1+128 : RailUNID=RailUNID+1
		HOTSPOT2 2*flightWidth+(nRisers2ndRun-1)*td2-leftRailFrameThk/2-0.1,			(nRisers1stRun-1-nRisers3rdRun)*treadDepth-leftRailOvhgTop, RailUNID, leftRailOffset, 3 : RailUNID=RailUNID+1
		HOTSPOT2 2*flightWidth+(nRisers2ndRun-1)*td2-leftRailOffset-leftRailFrameThk/2,	(nRisers1stRun-1-nRisers3rdRun)*treadDepth-leftRailOvhgTop, RailUNID, leftRailOffset, 2 : RailUNID=RailUNID+1

		!!! RAIL BOTTOM OVERHANG
		HOTSPOT2 leftRailFrameThk/2+leftRailOffset,		0,					RailUNID, leftRailOvhgBottom, 1+128 : RailUNID=RailUNID+1
		HOTSPOT2 leftRailFrameThk/2+leftRailOffset,		1,					RailUNID, leftRailOvhgBottom, 3		: RailUNID=RailUNID+1
		HOTSPOT2 leftRailFrameThk/2+leftRailOffset,		-leftRailOvhgBottom,RailUNID, leftRailOvhgBottom, 2		: RailUNID=RailUNID+1

		!!! RAIL TOP OVERHANG
		HOTSPOT2 2*flightWidth+(nRisers2ndRun-1)*td2-leftRailOffset-leftRailFrameThk/2,		(nRisers1stRun-1-nRisers3rdRun)*treadDepth,					RailUNID, leftRailOvhgTop, 1+128 : RailUNID=RailUNID+1
		HOTSPOT2 2*flightWidth+(nRisers2ndRun-1)*td2-leftRailOffset-leftRailFrameThk/2,		(nRisers1stRun-1-nRisers3rdRun)*treadDepth+0.1,				RailUNID, leftRailOvhgTop, 3 : RailUNID=RailUNID+1
		HOTSPOT2 2*flightWidth+(nRisers2ndRun-1)*td2-leftRailOffset-leftRailFrameThk/2,		(nRisers1stRun-1-nRisers3rdRun)*treadDepth-leftRailOvhgTop, RailUNID, leftRailOvhgTop, 2 : RailUNID=RailUNID+1
ENDIF
endif

END


"Start End Symbol":
	DRAWINDEX 45
	fill gs_StartEndFill

	if gs_StartEndFillPen <> 0 then
		temp_FillStatus = 2
	else
		temp_FillStatus = 0
	endif

	add2 0, +xNosing
	IF gs_StartEndStyle_m = 1 THEN		! Style 1
		POLY2_B 2, 1+temp_FillStatus, gs_StartEndFillPen, gs_fill_pen,
		0,-xNosing,901,
		gs_CircleRadius,360,4001
	ENDIF

	IF gs_StartEndStyle_m = 2 THEN		! Style 2
		FOR kk=1 TO 2
			POLY2_B 6, 1+temp_FillStatus, gs_StartEndFillPen, gs_fill_pen,
				0,-xNosing,1,
				0+gs_CircleRadius,-xNosing,1,
				0,-xNosing,901,
				0,90,4001,
				0,-xNosing+gs_CircleRadius,0,
				0,-xNosing,-1

			POLY2_B 6, 1, gs_StartEndFillPen, gs_fill_pen,
				0,-xNosing,1,
				0,-xNosing+gs_CircleRadius,1,
				0,-xNosing,901,
				0,90,4001,
				0-gs_CircleRadius,-xNosing,0,
				0,-xNosing,-1
		ROT2 180
		ADD2 0, 2*xNosing
		NEXT kk
		DEL 4
	ENDIF

	IF gs_StartEndStyle_m = 3 THEN		! Style 3
		LINE2 0+gs_StartWidth,-xNosing-gs_StartHeight,0+gs_StartWidth,-xNosing+gs_StartHeight
		LINE2 0-gs_StartWidth,-xNosing-gs_StartHeight,0-gs_StartWidth,-xNosing+gs_StartHeight
	ENDIF

	! --- Hotspots of StartEnd Symbol
	IF gs_StartEndStyle_m = 1 | gs_StartEndStyle_m = 2 THEN		! Style 1-2
		ADD2 0,-xNosing
			FOR kk=1 to 4
				HOTSPOT2 0, 0,					StartSymbUNID, gs_CircleRadius, 1+128	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 -1, 0,					StartSymbUNID, gs_CircleRadius, 3+128	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_CircleRadius, 0,	StartSymbUNID, gs_CircleRadius,2		:StartSymbUNID=StartSymbUNID+1

				ROT2 90
			NEXT KK
			DEL 4
		DEL 1
	ENDIF

	IF gs_StartEndStyle_m = 3 THEN		! Style 3
		FOR kk=1 to 2
			ADD2 0, -xNosing
				! Symbol Width/2
				HOTSPOT2 0,				-gs_StartHeight, StartSymbUNID, gs_StartWidth, 1+128:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 -1,			-gs_StartHeight, StartSymbUNID, gs_StartWidth, 3	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, -gs_StartHeight, StartSymbUNID, gs_StartWidth, 2	:StartSymbUNID=StartSymbUNID+1

				HOTSPOT2 0,				gs_StartHeight, StartSymbUNID, gs_StartWidth, 1+128	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 -1,			gs_StartHeight, StartSymbUNID, gs_StartWidth, 3		:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, gs_StartHeight, StartSymbUNID, gs_StartWidth,2		:StartSymbUNID=StartSymbUNID+1
			DEL 1

			ADD2 0, -xNosing
				! Symbol Height
				HOTSPOT2 gs_StartWidth, 0,				StartSymbUNID, gs_StartHeight, 1+128:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, -1,				StartSymbUNID, gs_StartHeight, 3	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, gs_StartHeight, StartSymbUNID, gs_StartHeight, 2	:StartSymbUNID=StartSymbUNID+1

				HOTSPOT2 gs_StartWidth, 0,					StartSymbUNID, gs_StartHeight, 1+128:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, 1,					StartSymbUNID, gs_StartHeight, 3	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, -gs_StartHeight,	StartSymbUNID, gs_StartHeight, 2	:StartSymbUNID=StartSymbUNID+1
			DEL 1

		MUL2 -1,1
		NEXT kk
		DEL 2
	ENDIF
	del 1

	DRAWINDEX 40
RETURN


"Arrowhead Symbol":
	IF arrow_style_m = 1 | arrow_style_m = 4 | arrow_style_m = 7 THEN
		temp_ArrowDist = flightWidth/2
		temp_ArrowHeight = treadDepth
		if not(reverseWalkLine) & (i = 2 | i = 3) & walkingDirUPDN_m <> 5 then temp_ArrowHeight = treadDepth + xNosing
	ENDIF

	IF arrow_style_m = 2 | arrow_style_m = 5 | arrow_style_m = 8 THEN
		temp_ArrowDist = flightWidth/4
		temp_ArrowHeight = treadDepth
		if not(reverseWalkLine) & (i = 2 | i = 3) & walkingDirUPDN_m <> 5 then temp_ArrowHeight = treadDepth + xNosing
	ENDIF

	IF arrow_style_m = 3 | arrow_style_m = 6 | arrow_style_m = 9 THEN
		temp_ArrowDist = gs_ArrowHalfWidth
		temp_ArrowHeight = gs_ArrowHeight
	ENDIF

	if arrow_style_m = 1 | arrow_style_m = 2 | arrow_style_m = 3 then
		temp_ArrowMask=0
	else
		temp_ArrowMask=1
	endif

	POLY2_b 4, 1, penFillArrow, gs_fill_pen,
		-temp_ArrowDist,-temp_ArrowHeight, temp_ArrowMask,
		temp_ArrowDist,-temp_ArrowHeight, 1,
		0,0, 1,
		-temp_ArrowDist,-temp_ArrowHeight, -1

	! --- Arrowhead Fill Contour Points Conditions
	IF arrow_style_m = 4 | arrow_style_m = 5 | arrow_style_m = 6 THEN
		temp_1XFill=temp_ArrowDist
		lengthArrowHead = temp_ArrowHeight
	else
		lengthArrowHead = 0
	ENDIF

	IF arrow_style_m = 7 | arrow_style_m = 8 | arrow_style_m = 9 THEN
		temp_1XFill=0
	ENDIF

	if penFillArrow <> 0 then
		IF arrow_style_m <> 1 & arrow_style_m <> 2 & arrow_style_m <> 3 THEN
			fill gs_ArrowFill ! Always 64 (Foreground)
			POLY2_b 4, 2, penFillArrow, gs_fill_pen,
				-temp_1XFill,-temp_ArrowHeight, temp_ArrowMask,
				temp_ArrowDist,-temp_ArrowHeight, 1,
				0,0, 1,
				-temp_1XFill,-temp_ArrowHeight, -1
		ENDIF
	endif

	HOTSPOT2	0,0,	ArrowUNID: ArrowUNID=ArrowUNID+1

	! --- Hotspot editing of Height & Width of Arrowhead
	IF arrow_style_m = 3 | arrow_style_m = 6 | arrow_style_m = 9 THEN
		HOTSPOT2 gs_ArrowHalfWidth,0,				ArrowUNID, gs_ArrowHeight, 1+128	: ArrowUNID=ArrowUNID+1
		HOTSPOT2 gs_ArrowHalfWidth,-gs_ArrowHeight,	ArrowUNID, gs_ArrowHeight, 2		: ArrowUNID=ArrowUNID+1
		HOTSPOT2 gs_ArrowHalfWidth,1,				ArrowUNID, gs_ArrowHeight, 3		: ArrowUNID=ArrowUNID+1

		HOTSPOT2 -gs_ArrowHalfWidth,0,					ArrowUNID, gs_ArrowHeight, 1+128	: ArrowUNID=ArrowUNID+1
		HOTSPOT2 -gs_ArrowHalfWidth,-gs_ArrowHeight,	ArrowUNID, gs_ArrowHeight, 2		: ArrowUNID=ArrowUNID+1
		HOTSPOT2 -gs_ArrowHalfWidth,1,					ArrowUNID, gs_ArrowHeight, 3		: ArrowUNID=ArrowUNID+1

		HOTSPOT2 0,					-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 1+128	: ArrowUNID=ArrowUNID+1
		HOTSPOT2 gs_ArrowHalfWidth,	-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 2		: ArrowUNID=ArrowUNID+1
		HOTSPOT2 -1,				-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 3		: ArrowUNID=ArrowUNID+1

		HOTSPOT2 0,					-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 1+128 : ArrowUNID=ArrowUNID+1
		HOTSPOT2 -gs_ArrowHalfWidth,-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 2		: ArrowUNID=ArrowUNID+1
		HOTSPOT2 1,					-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 3		: ArrowUNID=ArrowUNID+1
	ENDIF
RETURN


"left rail":

	if bShowRailOn1stRun then
		ADD2 leftRailOffset+leftRailFrameThk/2,-leftRailOvhgBottom
		ROT2 90

		lraSimple=(nRisers1stRun-1)*treadDepth+leftRailOvhgBottom
		lraComplex=(nRisers1stRun-2)*treadDepth
		additionXComplex=leftRailOvhgBottom+treadDepth/2
		additionZComplex=leftRailOvhgBottom*tan(ang)
		hrovL=treadDepth/2+leftRailOvhgBottom
		hrovR=treadDepth/2
		postNumber = max(2,(nRisers1stRun)/2+1)
		railAngle	= ang
		side = SIDE_LEFT
		gosub "callRailsForStair"

		DEL 2
	endif

	! ------------ POST & Rail on the landing (left side_1) ------------
	if bShowRailOn1stLanding1 then
		ADD2 leftRailOffset+leftRailFrameThk/2,(nRisers1stRun-1)*treadDepth
		ROT2 90

		lraSimple=flightWidth-leftRailOffset-leftRailFrameThk
		lraComplex=flightWidth-leftRailOffset-leftRailFrameThk
		hrovL=leftRailPostSize/2
		hrovR=-leftRailPostSize/2
		postNumber = max(2,(flightWidth-leftRailOffset-treadDepth)/0.5+1)
		side = SIDE_LEFT
		gosub "callRailsForLanding"

		DEL 2
	endif

	! ------------ POST & Rail on the landing (left side_2) ------------
	if bShowRailOn1stLanding2 then
		ADD2 leftRailOffset,b-leftRailOffset-leftRailFrameThk/2-gapToFirstTread

		IF flightWidth-leftRailOffset-td2>2*leftRailFrameThk then
			IF leftRailType_m > 0 and leftRailType_m < 7 THEN
				lraSimple=flightWidth-leftRailOffset-td2
				lraComplex=flightWidth-leftRailOffset-leftRailFrameThk
				hrovL=leftRailPostSize/2
				hrovR=-leftRailPostSize/2
				postNumber = max(2,(flightWidth-leftRailOffset-treadDepth)/0.5+1)
				side = SIDE_LEFT
				gosub "callRailsForLanding"
			endif
		ENDIF

		IF bComplexRailLeft THEN
			if leftRailType_m = 9 and (flightWidth-leftRailOffset-leftRailPostSize-td2<max(treadDepth/2,0.2)) then
				add2 0,-leftRailFrameThk/2
				poly2_b 4, 1 + 2 * (NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove) + 4 + 64, gs_fill_pen, gs_back_pen,
					0, 0, 1,
					flightWidth-leftRailOffset-td2, 0, 1,
					flightWidth-leftRailOffset-td2, leftRailFrameThk, 1,
					0, leftRailFrameThk, 1
				del 1
			else
				lraSimple=flightWidth-leftRailOffset-leftRailPostSize-td2
				lraComplex=flightWidth-leftRailOffset-leftRailPostSize-td2
				hrovL=leftRailPostSize/2
				hrovR=leftRailPostSize/2
				postNumber = max(2,(flightWidth-leftRailOffset-treadDepth)/0.5+1)
				side = SIDE_LEFT
				gosub "callRailsForLanding"
			endif
		endif

		DEL 1
	endif

	! ------------ Rail on 2nd Run ------------
	if bShowRailOn2ndRun then
		ADD2 flightWidth-td2,b-leftRailOffset-leftRailFrameThk/2-gapToFirstTread

		lraSimple=(nRisers2ndRun)*td2
		lraComplex=(nRisers2ndRun-1)*td2
		additionXComplex=td2/2
		additionZComplex=0
		hrovL=td2/2
		hrovR=td2/2
		postNumber = max(2,(nRisers2ndRun-1)/2+1)
		railAngle	= ang2
		side = SIDE_LEFT
		gosub "callRailsForStair"

		DEL 1
	endif

	! ------------ POST & Rail on the landing (left side_1) ------------
	if bShowRailOn2ndLanding1 then
		ADD2 a-flightWidth,b-leftRailOffset-leftRailFrameThk/2
		ROT2 0

		lraSimple=flightWidth-leftRailOffset-leftRailFrameThk
		lraComplex=flightWidth-leftRailOffset-leftRailFrameThk
		hrovL=leftRailPostSize/2
		hrovR=-leftRailPostSize/2
		postNumber = max(2,(flightWidth-leftRailOffset-leftRailFrameThk)/0.5+1)
		side = SIDE_LEFT
		gosub "callRailsForLanding"

		DEL 2
	endif

	! ------------ POST & Rail on the landing (left side_2) ------------
	if bShowRailOn2ndLanding2 then
		ADD2 a-leftRailOffset-leftRailFrameThk/2,b-leftRailOffset
		ROT2 -90

		IF flightWidth-leftRailOffset-treadDepth>2*leftRailFrameThk THEN
			IF leftRailType_m > 0 and leftRailType_m < 8 THEN
				lraSimple=flightWidth-leftRailOffset-treadDepth
				lraComplex=flightWidth-leftRailOffset-treadDepth-leftRailPostSize
				hrovL=leftRailPostSize/2
				hrovR=leftRailPostSize/2
				postNumber = max(2,(flightWidth-leftRailOffset-treadDepth)/0.5+1)
				side = SIDE_LEFT
				gosub "callRailsForLanding"
			endif
		endif
		IF leftRailType_m = 8 | leftRailType_m = 9 | leftRailType_m = 10 THEN
			if leftRailType_m = 9 and (flightWidth-leftRailOffset-leftRailPostSize-td2<max(treadDepth/2,0.2)) then
				add2 0,-leftRailFrameThk/2
				poly2_b 4, 1 + 2 * (NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove) + 4 + 64, gs_fill_pen, gs_back_pen,
					0, 0, 1,
					flightWidth-leftRailOffset-treadDepth, 0, 1,
					flightWidth-leftRailOffset-treadDepth, leftRailFrameThk, 1,
					0, leftRailFrameThk, 1
				del 1
			else
				lraSimple=flightWidth-leftRailOffset-leftRailPostSize-treadDepth
				lraComplex=flightWidth-leftRailOffset-leftRailPostSize-treadDepth
				hrovL=leftRailPostSize/2
				hrovR=leftRailPostSize/2
				postNumber = max(2,(flightWidth-leftRailOffset-treadDepth)/0.5+1)
				side = SIDE_LEFT
				gosub "callRailsForLanding"
			endif
		endif

		DEL 2
	endif

	! ------------ Rail on 3rd Run ------------
	if bShowRailOn3rdRun then
		ADD2 a-leftRailOffset-leftRailFrameThk/2,b-flightWidth+treadDepth
		ROT2 -90

		lraSimple=(nRisers3rdRun+1)*treadDepth+leftRailOvhgTop
		lraComplex=(nRisers3rdRun)*treadDepth
		additionXComplex=treadDepth/2
		additionZComplex=0
		hrovL=treadDepth/2
		hrovR=treadDepth/2+leftRailOvhgTop
		postNumber = max(2,(nRisers3rdRun)/2+1)
		railAngle	= ang
		side = SIDE_LEFT
		gosub "callRailsForStair"

		DEL 2
	endif

return


"right rail":

	if bShowRailOn1stRun then
		ADD2 flightWidth-rightRailOffset-rightRailFrameThk/2,-rightRailOvhgBottom
		ROT2 90

		lraSimple=(nRisers1stRun-1)*treadDepth+rightRailOvhgBottom+min(0,rightRailOffset)
		lraComplex=(nRisers1stRun-2)*treadDepth+min(0,rightRailOffset)
		additionXComplex=rightRailOvhgBottom+treadDepth/2
		additionZComplex=rightRailOvhgBottom*tan(ang)
		hrovL=treadDepth/2+rightRailOvhgBottom
		hrovR=treadDepth/2+min(0,rightRailOffset)*0
		postNumber = ((nRisers-1))/4
		railAngle	= ang
		side = SIDE_RIGHT
		gosub "callRailsForStair"

		DEL 2
	endif

	! ---------- POST & Rail on the landing (right side_1) ------------
	if bShowRailOn1stLanding1 then
		ADD2 flightWidth-rightRailFrameThk-rightRailOffset,(nRisers1stRun-1)*treadDepth+rightRailOffset
			poly2_b 4, 1 + 2 * (NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove) + 4 + 64, gs_fill_pen, gs_back_pen,
				0, 0, 1,
				rightRailFrameThk, 0, 1,
				rightRailFrameThk, rightRailFrameThk, 1,
				0, rightRailFrameThk, 1
		DEL 1

		IF rightRailOffset>0.05 THEN
			IF rightRailOffset<0.2 THEN
				IF rightRailType_m = 3 | rightRailType_m = 7 | rightRailType_m = 8 | rightRailType_m = 9 | rightRailType_m = 10 THEN
					hight=rightRailFrameThk
					if rightRailType_m = 3 then hight=0.025
					ADD2 flightWidth-rightRailOffset,(nRisers1stRun-1)*treadDepth
					ROT2 90
					poly2_b 4, 1 + 2 * (NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove) + 4 + 64, gs_fill_pen, gs_back_pen,
						0, 0, 1,
						rightRailOffset, 0, 1,
						rightRailOffset, rightRailFrameThk, 1,
						0, rightRailFrameThk, 1
					DEL 2
				ELSE
					ADD2 flightWidth-rightRailOffset,(nRisers1stRun-1)*treadDepth
					ROT2 90
					poly2_b 4, 1 + 2 * (NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove) + 4 + 64, gs_fill_pen, gs_back_pen,
						0, 0, 1,
						rightRailOffset, 0, 1,
						rightRailOffset, rightRailFrameThk, 1,
						0, rightRailFrameThk, 1
					DEL 2
				ENDIF
			ELSE
				ADD2 flightWidth-rightRailOffset-rightRailFrameThk/2,(nRisers1stRun-1)*treadDepth
				ROT2 90

				IF rightRailType_m = 8 | rightRailType_m = 9 | rightRailType_m = 10 THEN
					ADD2 0,-rightRailFrameThk/2
					IF rightRailOffset>0 then
						poly2_b 4, 1 + 2 * (NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove) + 4 + 64, gs_fill_pen, gs_back_pen,
							0, 0, 1,
							rightRailOffset, 0, 1,
							rightRailOffset, rightRailFrameThk, 1,
							0, rightRailFrameThk, 1
					endif
					DEL 1
				else
					lraSimple=rightRailOffset
					lraComplex=rightRailOffset
					hrovL=rightRailPostSize/2
					hrovR=-rightRailPostSize/2
					postNumber = max(2,rightRailOffset/0.5)
					side = SIDE_RIGHT
					gosub "callRailsForLanding"
				ENDIF

				DEL 2
			ENDIF
		ENDIF
	endif

	! ------------ POST & Rail on the landing (right side_2) ------------
	if bShowRailOn1stLanding2 then
		IF rightRailOffset*tan(ang)>treadHeight THEN
			IF rightRailOffset<0.2 & rightRailOffset>0.05 THEN
				IF rightRailType_m = 3 | rightRailType_m = 7 | rightRailType_m = 8 | rightRailType_m = 9 | rightRailType_m = 10 THEN
					hight=rightRailFrameThk
					if rightRailType_m = 3 then hight=0.025
					ADD2 flightWidth-rightRailOffset,(nRisers1stRun-1)*treadDepth+rightRailOffset
					ROT2 0
					poly2_b 4, 1 + 2 * (NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove) + 4 + 64, gs_fill_pen, gs_back_pen,
						0, 0, 1,
						rightRailOffset, 0, 1,
						rightRailOffset, rightRailFrameThk, 1,
						0, rightRailFrameThk, 1
					DEL 2
				ELSE
					ADD2 flightWidth-rightRailOffset,(nRisers1stRun-1)*treadDepth
					ROT2 90
					poly2_b 4, 1 + 2 * (NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove) + 4 + 64, gs_fill_pen, gs_back_pen,
						0, 0, 1,
						rightRailOffset, 0, 1,
						rightRailOffset, rightRailFrameThk, 1,
						0, rightRailFrameThk, 1
					DEL 2
				ENDIF
			ELSE
				ADD2 flightWidth-rightRailOffset,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2
				ROT2 0

				IF rightRailOffset>treadDepth+0.08 & rightRailOffset-treadDepth>2*rightRailFrameThk+0.001 then
					IF rightRailType_m = 8 | rightRailType_m = 9 | rightRailType_m = 10 THEN
						ADD2 0,-rightRailFrameThk/2
						poly2_b 4, 1 + 2 * (NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove) + 4 + 64, gs_fill_pen, gs_back_pen,
							0, 0, 1,
							rightRailOffset-treadDepth, 0, 1,
							rightRailOffset-treadDepth, rightRailFrameThk, 1,
							0, rightRailFrameThk, 1
						DEL 1
					else
						lraSimple=rightRailOffset-treadDepth
						lraComplex=rightRailOffset-treadDepth
						hrovL=-rightRailPostSize/2
						hrovR=rightRailPostSize/2
						postNumber = max(2,rightRailOffset/0.5)
						side = SIDE_RIGHT
						gosub "callRailsForLanding"
					ENDIF
				ENDIF

				DEL 2
			ENDIF
		ENDIF
	endif

	!!!!!!!!!!******** Railing on the 2nd run
	if bShowRailOn2ndRun then
		ADD2 flightWidth-min(rightRailOffset,td2),(nRisers1stRun-1)*treadDepth+rightRailFrameThk/2+rightRailOffset
		ROT2 0

		lraSimple=(nRisers2ndRun-1)*td2+min(rightRailOffset,td2)+min(0,rightRailOffset)
		lraComplex=(nRisers2ndRun-2)*td2+min(0,rightRailOffset)
		additionXComplex=td2/2+min(rightRailOffset,td2)
		additionZComplex=min(rightRailOffset*tan(ang2),treadHeight)
		hrovL=td2/2+min(rightRailOffset,td2)
		hrovR=td2/2
		postNumber=max(2,(nRisers2ndRun-2)/2)
		railAngle	= ang2
		side = SIDE_RIGHT
		gosub "callRailsForStair"

		DEL 2
	endif

	! ------------ POST & Rail on the landing 2. (right side_1) ------------
	if bShowRailOn2ndLanding1 then
		ADD2 a-flightWidth+rightRailOffset,(nRisers1stRun-1)*treadDepth+rightRailOffset
		poly2_b 4, 1 + 2 * (NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove) + 4 + 64, gs_fill_pen, gs_back_pen,
			0, 0, 1,
			rightRailFrameThk, 0, 1,
			rightRailFrameThk, rightRailFrameThk, 1,
			0, rightRailFrameThk, 1
		DEL 1

		IF rightRailOffset>0.05 THEN
			IF rightRailOffset<0.2 THEN
				IF rightRailType_m = 3 | rightRailType_m = 7 | rightRailType_m = 8 | rightRailType_m = 9 | rightRailType_m = 10 THEN
					hight=rightRailFrameThk
					if rightRailType_m = 3 then hight=0.025
					ADD2 a-flightWidth,(nRisers1stRun-1)*treadDepth+rightRailOffset
					ROT2 0
					poly2_b 4, 1 + 2 * (NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove) + 4 + 64, gs_fill_pen, gs_back_pen,
						0, 0, 1,
						rightRailOffset, 0, 1,
						rightRailOffset, rightRailFrameThk, 1,
						0, rightRailFrameThk, 1
					DEL 2
				ELSE
					ADD2 a-flightWidth,(nRisers1stRun-1)*treadDepth+rightRailOffset
					ROT2 0
					poly2_b 4, 1 + 2 * (NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove) + 4 + 64, gs_fill_pen, gs_back_pen,
						0, 0, 1,
						rightRailOffset, 0, 1,
						rightRailOffset, rightRailFrameThk, 1,
						0, rightRailFrameThk, 1
					DEL 2
				ENDIF
			ELSE
				ADD2 a-flightWidth+rightRailOffset,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2
				ROT2 180

				IF rightRailType_m = 8 | rightRailType_m = 9 | rightRailType_m = 10 THEN
					ADD2 0,-rightRailFrameThk/2
					IF rightRailOffset>0 then
						poly2_b 4, 1 + 2 * (NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove) + 4 + 64, gs_fill_pen, gs_back_pen,
							0, 0, 1,
							rightRailOffset, 0, 1,
							rightRailOffset, rightRailFrameThk, 1,
							0, rightRailFrameThk, 1
					endif
					DEL 1
				ELSE
					lraSimple=rightRailOffset
					lraComplex=rightRailOffset
					hrovL=rightRailPostSize/2
					hrovR=-rightRailPostSize/2
					postNumber = max(2,rightRailOffset/0.5)
					side = SIDE_RIGHT
					gosub "callRailsForLanding"
				ENDIF

				DEL 2
			ENDIF
		ENDIF
	endif

	! ------------ POST & Rail on the landing (right side_2) ------------
	if bShowRailOn2ndLanding2 then
		IF rightRailOffset*tan(ang)>treadHeight THEN
			IF rightRailOffset<0.2 & rightRailOffset>0.05 THEN
				IF rightRailType_m = 3 | rightRailType_m = 7 | rightRailType_m = 8 | rightRailType_m = 9 | rightRailType_m = 10 THEN
					hight=rightRailFrameThk
					if rightRailType_m = 3 then hight=0.025
					ADD2 flightWidth-rightRailOffset,(nRisers1stRun-1)*treadDepth+rightRailOffset
					ROT2 0
					poly2_b 4, 1 + 2 * (NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove) + 4 + 64, gs_fill_pen, gs_back_pen,
						0, 0, 1,
						rightRailOffset, 0, 1,
						rightRailOffset, rightRailFrameThk, 1,
						0, rightRailFrameThk, 1
					DEL 2
				ELSE
					ADD2 flightWidth-rightRailOffset,(nRisers1stRun-1)*treadDepth
					ROT2 90
					poly2_b 4, 1 + 2 * (NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove) + 4 + 64, gs_fill_pen, gs_back_pen,
						0, 0, 1,
						rightRailOffset, 0, 1,
						rightRailOffset, rightRailFrameThk, 1,
						0, rightRailFrameThk, 1
					DEL 2
				ENDIF
			ELSE
				ADD2 flightWidth-rightRailOffset,(nRisers1stRun-1)*treadDepth+rightRailOffset+rightRailFrameThk/2
				ROT2 0

				IF rightRailOffset>treadDepth+0.08 & rightRailOffset-treadDepth>2*rightRailFrameThk+0.001 then
					IF rightRailType_m = 8 | rightRailType_m = 9 | rightRailType_m = 10 THEN
						ADD2 0,-rightRailFrameThk/2
						poly2_b 4, 1 + 2 * (NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove) + 4 + 64, gs_fill_pen, gs_back_pen,
							0, 0, 1,
							rightRailOffset-treadDepth, 0, 1,
							rightRailOffset-treadDepth, rightRailFrameThk, 1,
							0, rightRailFrameThk, 1
						DEL 1
					else
						lraSimple=rightRailOffset-treadDepth
						lraComplex=rightRailOffset-treadDepth
						hrovL=-rightRailPostSize/2
						hrovR=rightRailPostSize/2
						postNumber = max(2,rightRailOffset/0.5)
						side = SIDE_RIGHT
						gosub "callRailsForLanding"
					ENDIF
				ENDIF

				DEL 2
			ENDIF
		ENDIF
	endif

	!!!!!!!!!!******** Railing on the 3rd run
	if bShowRailOn3rdRun then
		ADD2 a-flightWidth+rightRailOffset+rightRailFrameThk/2,(nRisers1stRun-1)*treadDepth+min(rightRailOffset,treadDepth)
		ROT2 -90

		lraSimple=(nRisers3rdRun)*treadDepth+min(rightRailOffset,treadDepth)+rightRailOvhgTop
		lraComplex=(nRisers3rdRun-1)*treadDepth
		additionXComplex=treadDepth/2+min(rightRailOffset,treadDepth)
		additionZComplex=min(rightRailOffset*tan(ang),treadHeight)
		hrovL=treadDepth/2+min(rightRailOffset,treadDepth)
		hrovR=treadDepth/2+rightRailOvhgTop
		postNumber = max(2,(nRisers3rdRun-1)/(3*treadDepth))
		railAngle	= ang
		side = SIDE_RIGHT
		gosub "callRailsForStair"

		DEL 2
	endif

return


"callRailsForStair":
! ------------------------------------------------------------------------------
!	lraSimple
!	lraComplex
!	additionXComplex
!	additionZComplex
!	hrovL: rail overhang start
!	hrovR: rail overhang end
!	postNumber:   number of posts
!	side: SIDE_LEFT or SIDE_RIGHT
! ==============================================================================
	ani = railAngle
	additionXComplex = additionXComplex
	additionZComplex = additionZComplex
	if side = SIDE_LEFT then
		dsComplex = leftRailDist+treadDepth/2*tan(ang)
	else
		dsComplex = rightRailDist+treadDepth/2*tan(ang)
	endif

	gosub "callRails"
return


! ==============================================================================
"callRailsForLanding":
! ------------------------------------------------------------------------------
!	lraSimple
!	lraComplex
!	hrovL: rail overhang start
!	hrovR: rail overhang end
!	postNumber:   number of posts
!	side: SIDE_LEFT or SIDE_RIGHT
! ==============================================================================
	ani = 0
	additionZComplex = 0
	if side = SIDE_LEFT then
		additionXComplex = leftRailPostSize/2
		dsComplex = leftRailDist
	else
		additionXComplex = rightRailPostSize/2
		dsComplex = rightRailDist
	endif

	gosub "callRails"
return


! ==============================================================================
"callRails":
! ------------------------------------------------------------------------------
!	ani
!	additionXComplex
!	additionZComplex
!	dsComplex
!  ------------------
!	side: SIDE_LEFT or SIDE_RIGHT
!	lraSimple
!	lraComplex
!	hrovL: rail overhang start
!	hrovR: rail overhang end
!	postNumber:   number of posts
! ==============================================================================
	if side = SIDE_LEFT then
		railBarDepth		= leftRailBarDepth
		railBarDiam			= railBarDepth
		railHeight			= leftRailHeight
		railBarThk			= leftRailBarThk
		railFrameThk		= leftRailFrameThk
		railDist			= leftRailDist
		railType_m			= leftRailType_m
		railPostSize		= leftRailPostSize
		nBarsRail			= nBarsLeftRail
		if rightRailType_m = RAIL_WIRED then
			railBarThk		= leftRailWireThk
			railBarDepth	= leftRailWireDepth
			railBarDiam		= leftRailWireDiam
		endif
		bComplexRail		= bComplexRailLeft
	else
		railBarDepth		= rightRailBarDepth
		railBarDiam			= railBarDepth
		railHeight			= rightRailHeight
		railBarThk			= rightRailBarThk
		railFrameThk		= rightRailFrameThk
		railDist			= rightRailDist
		railType_m			= rightRailType_m
		railPostSize		= rightRailPostSize
		nBarsRail			= nBarsRightRail
		if rightRailType_m = RAIL_WIRED then
			railBarThk		= rightRailWireThk
			railBarDepth	= rightRailWireDepth
			railBarDiam		= rightRailWireDiam
		endif
		bComplexRail		= bComplexRailRight
	endif

	add2 additionXComplex * bComplexRail, 0
	call "railSymbol2D_m" parameters all	cfs					= 1,
											bEnable2DPosts		= bComplexRail,
											ptyp_m				= 1,
											ani					= ani,
											rom_m				= 1,
											rmm_m				= 1,
											LengthSize			= 0,
											lra					= lraSimple * NOT(bComplexRail) + lraComplex * (bComplexRail),
											hr					= railHeight,
											hrPerp				= railHeight,
											ab					= 0,
											rb					= 0,
											ds					= railDist,
											gs_AngleL			= 90,
											gs_AngleR			= 90,
											iHandRailStyle		= 1,
											handRailDiameter	= railFrameThk,
											handRailWidth		= railFrameThk,
											hroL				= hrovL,
											hroR				= hrovR,
											np					= postNumber,
											pd					= railPostSize,
											pw					= railPostSize,
											pth					= railFrameThk,
											gs_cont_pen			= railPen,
											al					= railLineType,
											sa					= 0,
											bBreakRailLine		= bBreakRailLine,
											breakLineAngle		= brLineAngle,
											breakLineDist		= breakLineDist,
											breakLineWidth		= breakLineW,
											bRailAboveBreakLine	= bRailAboveBreakLine,
											bShowRailBelowBrL	= bShowRailPart1,
											bShowRailAboveBrL	= bShowRailPart2,
											bPostNoCalculation	= (railType_m = 9),
											pit_m				= 2,
											dp					= treadDepth
	del 1

	bShowRailPart1			= 0
	bShowRailPart2			= 0

return

"carriage":

	if beamNum = 1 then
		add2 carriageBaseDist / 2 - beamThk / 2 - beamOffsetRight, 0
	else
		add2 carriageBaseDist - beamThk - beamOffsetRight, 0
	endif
	for wb = 1 to beamNum
		if bBreakCarriageLine then
			lengthMod	= -(carriageBaseDist - beamOffsetLeft - beamOffsetRight - beamThk) * tan(brLineAngle) * (wb = 2)
			if bShowCarriagePart1 then
				pen carriagePen
				if aboveStory then
					LINE_TYPE carriageLineType
				else
					if	(drawPart[1] and drawDashed[1]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE carriageLineType
					endif
				endif

				poly2_b 4, 1+2+4+64, gs_fill_pen, gs_back_pen,
					0, 0, 1,
					beamThk, 0, 1,
					beamThk, carrBreakLineDist + beamThk * tan(brLineAngle) / 2 + lengthMod, 1,
					0, carrBreakLineDist - beamThk * tan(brLineAngle) / 2 + lengthMod, 1
			endif

			if bShowCarriagePart2 then
				pen carriagePen
				if aboveStory then
					LINE_TYPE carriageLineType
				else
					if	(drawPart[2] and drawDashed[2]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE carriageLineType
					endif
				endif


				poly2_b 4, 1 + 2 * gs_FillAbove + 4 + 64, gs_fill_pen, gs_back_pen,
					0, carrBreakLineDist - beamThk * tan(brLineAngle) / 2 + lengthMod + carrBreakLineWidth, 1,
					beamThk, carrBreakLineDist + beamThk * tan(brLineAngle) / 2 + lengthMod + carrBreakLineWidth, 1,
					beamThk, beamLength, 1,
					0, beamLength, 1
			endif
		else
			if aboveStory then
				LINE_TYPE carriageLineType
			else
			pen carriagePen
				if drawPart[3] then
					if (drawDashed[3]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE carriageLineType
					endif
				else
					if	(NOT(bCarrAboveBreakLine) and drawDashed[1]) or\
						((bCarrAboveBreakLine) and drawDashed[2]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE carriageLineType
					endif
				endif
			endif

			poly2_b 4, 1 + 2 * (NOT(bCarrAboveBreakLine) + bCarrAboveBreakLine * gs_FillAbove) + 4 + 64, gs_fill_pen, gs_back_pen,
				0, 0, 1,
				beamThk, 0, 1,
				beamThk, beamLength, 1,
				0, beamLength, 1
		endif
		add2 -carriageBaseDist + beamThk + beamOffsetLeft + beamOffsetRight, 0
	next wb
	del beamNum + 1

return

