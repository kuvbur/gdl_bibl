

! ---------- Hotspots ----------[
	unID = 1
	FlightUNID		= 2
	RailUNID		= 100
	StartSymbUNID	= 200
	ArrowUNID		= 300
	RiseRunUNID		= 400
	UpDownUNID		= 500
	NumUnID			= 600

hotspot2 0,0, unID: unID=unID+1

! ---------- Hotspots ----------]

dim drawPart[3] ! 1 - lower,  2 - upper,  3 - full
dim drawDashed[3] ! 1 - lower,  2 - upper,  3 - full
dim drawSteps[3] ! 1 - lower,  2 - upper,  3 - full
dim drawDetails[3] ! 1 - lower,  2 - upper,  3 - full


drawPart[1] = 0		! Lower
drawPart[2] = 0		! Upper
drawPart[3] = 0		! Full
drawDashed[1] = 0	! Lower
drawDashed[2] = 0	! Upper
drawDashed[3] = 0	! Full
drawSteps[1] = 0	! Lower
drawSteps[2] = 0	! Upper
drawSteps[3] = 0	! Full
drawDetails[1] = 0	! Lower
drawDetails[2] = 0	! Upper
drawDetails[3] = 0	! Full
drawNum = 0


abovestory = 0
belowstory = 0
if bStorySensitive then
	if GLOB_CH_STORY_DIST > EPS  then
		abovestory = 1
	else
		if GLOB_CH_STORY_DIST < -EPS  then
			belowstory = 1
		endif
	endif
endif

bCarriageLineExist		= bShowCarriage and bEnableCarriageLine and (GLOB_SCALE <= iShowCarriageUpTo | iShowCarriageUpTo = 1)

! ---------- Settings of 2D Symbol Type ----------
_iSymbolType = 1
_bShowRailIn2D = 1
if gs_detlevel_2D_m = DET2D_SCALESENSITIVE then
	if GLOB_SCALE <= _iScaleMD then									!! Detailed Scale
		_iSymbolType = iEnabledSymbolTypes[iSymbolGroup][3]
	else
		if GLOB_SCALE > _iScaleMD & GLOB_SCALE <= _iScaleSM then	!! Middle Scale
			_iSymbolType = iEnabledSymbolTypes[iSymbolGroup][2]
		else														!! Simple Scale
			_iSymbolType = iEnabledSymbolTypes[iSymbolGroup][1]
			_bShowRailIn2D = 0
		endif
	endif
else
	_iSymbolType = gs_SymbolType_m
endif

IF _iSymbolType = 1 THEN		! Type 1
	drawPart[3]	= 1		! Full
	drawDashed[3] = 1	! Full
ENDIF

IF _iSymbolType = 2 THEN		! Type 2
	drawPart[3]	= 1		! Full
ENDIF

IF _iSymbolType = 3 THEN		! Type 3
	drawPart[1]	= 1		! Lower
ENDIF

IF _iSymbolType = 4 THEN		! Type 4
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
ENDIF

IF _iSymbolType = 5 THEN		! Type 5
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
ENDIF

IF _iSymbolType = 6 THEN		! Type 6
	drawPart[3]	= 1		! Full
	drawDashed[3] = 1	! Full
	drawSteps[3] = 1	! Full
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 7 THEN		! Type 7
	drawPart[3]	= 1		! Full
	drawSteps[3] = 1	! Full
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 8 THEN		! Type 8
	drawPart[1]	= 1		! Lower
	drawSteps[1] = 1	! Lower
ENDIF

IF _iSymbolType = 9 THEN		! Type 9
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
ENDIF

IF _iSymbolType = 10 THEN		! Type 10
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
ENDIF

IF _iSymbolType = 11 THEN		! Type 11
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 12 THEN		! Type 12
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 13 THEN		! Type 13
	drawPart[3]	= 1		! Full
	drawDashed[3] = 1	! Full
	drawSteps[3] = 1	! Full
	drawDetails[3] = 1	! Full

	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 14 THEN		! Type 14
	drawPart[3]	= 1		! Full
	drawSteps[3] = 1	! Full
	drawDetails[3] = 1	! Full

	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 15 THEN		! Type 15
	drawPart[1]	= 1		! Lower
	drawSteps[1] = 1	! Lower
	drawDetails[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
!	drawDetails[2] = 1	! Upper ! COMP
ENDIF

IF _iSymbolType = 16 THEN		! Type 16
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawDetails[1] = 1	! Lower
ENDIF

IF _iSymbolType = 17 THEN		! Type 17
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
	drawDetails[1] = 1	! Lower
ENDIF

IF _iSymbolType = 18 THEN		! Type 18
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawDetails[1] = 1	! Lower
	drawDetails[2] = 1	! Upper
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 19 THEN		! Type 19
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawDetails[1] = 1	! Lower
	drawNum = bShowNumbering
ENDIF

IF _iSymbolType = 20 THEN		! Type 20
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawDetails[1] = 1	! Lower
	drawDetails[2] = 1	! Upper
	drawNum = bShowNumbering
ENDIF

! ---------- Stories below the home story ---------- [

bBackgroundFill = 1
if belowstory then
	drawPart[3]		= 1
	drawDashed[3]	= 1

	drawSteps[1] = 0
	drawSteps[2] = 0
	drawSteps[3] = 0

	drawDetails[1] = 0
	drawDetails[2] = 0
	drawDetails[3] = 0

	drawNum = 0
endif

! ---------- Stories below the home story ---------- ]

! ---------- Stories above the home story ---------- [
if abovestory then
	drawPart[1] = 0
	drawPart[2] = 0
	drawPart[3] = 0

	if gs_TreadStUp then
		drawSteps[1] = 1
		drawSteps[2] = 1
		drawSteps[3] = 1

		if drawDetails[1] | drawDetails[3] then
			drawDetails[1] = 1
			drawDetails[2] = 1
			drawDetails[3] = 1
		endif

	else
		drawSteps[1] = 0
		drawSteps[2] = 0
		drawSteps[3] = 0

		drawDetails[1] = 0
		drawDetails[2] = 0
		drawDetails[3] = 0
	endif

	if gs_BreaklineStUp = 0 then
		drawPart[3] = 1
	else
		if gs_LowerPartStUp then
			drawPart[1] = 1
		endif
		if gs_UpperPartStUp then
			drawPart[2] = 1
		endif
	endif

	if gs_numaStUp & gs_TreadStUp & ((drawPart[1] & drawPart[2]) | drawPart[3]) then
		drawNum = 1
	else
		drawNum = 0
	endif
endif

if bShowCarriage then
	if typeStringer_m = 7 then					! Channel Inside Open - Stringer
		widthTotalTread	= b - thickStringer * 2
	else
		widthTotalTread	= widthFreeFlight
	endif
else
	widthTotalTread		=  flightWidth
endif
bet	= atn((2*treadDepth)/widthTotalTread)

ROT2 -90
ADD2 -b + (b - widthTotalTread) / 2, 0

NumStline = INT (gs_BreakHeight/treadHeight)
NumStline = max(1,NumStline)

DRAWINDEX 10
PEN gs_cont_pen
FILL gs_fill_type

if belowStory then bBackgroundFill	= 0
! ==========================================================================
! CONTOUR LINES
! ==========================================================================


if not(drawPart[3]) then
	drawBreakLine = 1
else
	drawBreakLine = 0
endif

IF not(drawBreakLine) THEN
	if aboveStory then
		PEN gs_LinePenStUp
		LINE_TYPE gs_LineTypeStUp
	else
		if drawDashed[3] then
			PEN gs_DashLinePen
			LINE_TYPE dash_line
		else
			PEN gs_cont_pen
			LINE_TYPE solid_line
		endif
	endif

	xNosing = nosing * (drawDetails[3])

	POLY2_b 4,1+2*bBackgroundFill+4+64, gs_fill_pen, gs_back_pen,
		0, -xNosing, 1,
		widthTotalTread, -xNosing, 1,
		widthTotalTread, (nRisers)*treadDepth, 1,
		0, (nRisers)*treadDepth, 1

	HOTLINE2 0, -xNosing, widthTotalTread, -xNosing
	HOTLINE2 widthTotalTread, -xNosing,widthTotalTread, (nRisers)*treadDepth
	HOTLINE2 widthTotalTread, (nRisers)*treadDepth,0, (nRisers)*treadDepth
	HOTLINE2 0, (nRisers)*treadDepth,0, -xNosing

ELSE

! with Break Line
! ---------------------------------------------------------------------------------------------
	if breakline_style_m = 2 then		! Zig Zag
		angle_breakline=ATN(2*treadDepth/widthTotalTread)
		ZigZag1Y=(2/5*widthTotalTread)*tan(angle_breakline)
		ZigZag2Y=(7/20*widthTotalTread)*tan(angle_breakline)
	else
		if breakline_style_m = 3 then		! Zig Zag CHI
			angle_breakline=ATN(2*treadDepth/widthTotalTread)
			ZigZag1Y=(2/5*widthTotalTread)*tan(angle_breakline)
			ZigZag2Y=(2/5*widthTotalTread)*tan(angle_breakline)
		endif
	endif

	IF drawPart[1] THEN
		if aboveStory then
			PEN gs_LinePenStUp
			LINE_TYPE gs_LineTypeStUp
		else
			if drawDashed[1] then
				PEN gs_DashLinePen
				LINE_TYPE dash_line
			else
				PEN gs_cont_pen
				LINE_TYPE solid_line
			endif
		endif

		xNosing = nosing * drawDetails[1]

		if breakline_style_m = 2 then
			! ---------- Zig Zag ----------
				POLY2_b 8, 1+2+4+64, gs_fill_pen, gs_back_pen,
				0, -xNosing, 1,
				widthTotalTread, -xNosing, 1,
				widthTotalTread, (NumStline+1)*treadDepth-xNosing, 1,
				6/10*widthTotalTread,(NumStline+1)*treadDepth-xNosing-ZigZag1Y, 1,
				6/10*widthTotalTread,(NumStline-1)*treadDepth-xNosing+ZigZag1Y, 1,
				4/10*widthTotalTread,(NumStline+1)*treadDepth-xNosing-ZigZag1Y, 1,
				4/10*widthTotalTread,(NumStline-1)*treadDepth-xNosing+ZigZag1Y, 1,
						0, (NumStline-1)*treadDepth-xNosing, 1
		else
			if breakline_style_m = 3 then
				! ---------- Zig Zag CHI ----------
				POLY2_b 9, 1+2+64, gs_fill_pen, gs_back_pen,
							0, -xNosing, 1,
							widthTotalTread, -xNosing, 1,
							widthTotalTread, (NumStline+1)*treadDepth-xNosing, 1,
							6/10*widthTotalTread,(NumStline+1)*treadDepth-xNosing-ZigZag1Y, 1,
							6/10*widthTotalTread,(NumStline-1)*treadDepth-xNosing+ZigZag1Y, 1,
							4/10*widthTotalTread,(NumStline+1)*treadDepth-xNosing-ZigZag1Y+breakLineWidth, 1,
							4/10*widthTotalTread,(NumStline-1)*treadDepth-xNosing+ZigZag1Y, 1,
							0, (NumStline-1)*treadDepth-xNosing, 1,
							0, -xNosing, -1
			else
				! ---------- Straight ----------
					POLY2_b 4, 1+2+4+64, gs_fill_pen, gs_back_pen,
							0, -xNosing, 1,
							widthTotalTread, -xNosing, 1,
							widthTotalTread, (NumStline+1)*treadDepth-xNosing, 1,
							0, (NumStline-1)*treadDepth-xNosing, 1
			endif
		endif


			HOTSPOT2 widthTotalTread/2,(NumStline)*treadDepth-xNosing, FlightUNID: FlightUNID=FlightUNID+1
			HOTSPOT2 0,			(NumStline-1)*treadDepth-xNosing, FlightUNID: FlightUNID=FlightUNID+1
			HOTSPOT2 widthTotalTread,	(NumStline+1)*treadDepth-xNosing, FlightUNID: FlightUNID=FlightUNID+1

			HOTLINE2 0, -xNosing, widthTotalTread, -xNosing
			HOTLINE2 widthTotalTread, -xNosing, widthTotalTread, (NumStline+1)*treadDepth-xNosing
			HOTLINE2 widthTotalTread, (NumStline+1)*treadDepth-xNosing,0, (NumStline-1)*treadDepth-xNosing
			HOTLINE2 0, (NumStline-1)*treadDepth-xNosing,0, -xNosing
	ENDIF

	IF drawPart[2] THEN
		if aboveStory then
			PEN gs_LinePenStUp
			LINE_TYPE gs_LineTypeStUp
		else
			if drawDashed[2] then
				PEN gs_DashLinePen
				LINE_TYPE dash_line
			else
				PEN gs_cont_pen
				LINE_TYPE solid_line
			endif
		endif

		xNosing = nosing * drawDetails[2]

		if breakline_style_m = 2  then
			! ---------- Zig Zag ----------
			POLY2_b 8, 1+2*gs_FillAbove+4+64, gs_fill_pen, gs_back_pen,
					0, (NumStline-1)*treadDepth-xNosing+breakLineWidth , 1,
					7/20*widthTotalTread, (NumStline-1)*treadDepth -xNosing + breakLineWidth +ZigZag2Y, 1,
					7/20*widthTotalTread, (NumStline-1)*treadDepth -xNosing + breakLineWidth +ZigZag2Y+2*(treadDepth-ZigZag1Y), 1,
					11/20*widthTotalTread, (NumStline-1)*treadDepth -xNosing+ breakLineWidth +ZigZag2Y, 1,
					11/20*widthTotalTread, (NumStline-1)*treadDepth -xNosing+ breakLineWidth +ZigZag2Y+2*(treadDepth-ZigZag1Y), 1,
					widthTotalTread, (NumStline+1)*treadDepth-xNosing+breakLineWidth , 1,
					widthTotalTread, (nRisers)*treadDepth, 1,
					0, (nRisers)*treadDepth, 1
		else
			if breakline_style_m = 3 then
				POLY2_b 8, 1+2*gs_FillAbove+4+64, gs_fill_pen, gs_back_pen,
					0, (NumStline-1)*treadDepth-xNosing+breakLineWidth , 1,
					4/10*widthTotalTread, (NumStline-1)*treadDepth -xNosing + breakLineWidth +ZigZag2Y, 1,
					4/10*widthTotalTread, (NumStline+1)*treadDepth-xNosing-ZigZag1Y+breakLineWidth, 1,
					6/10*widthTotalTread, (NumStline-1)*treadDepth-xNosing+ZigZag1Y, 1,
					6/10*widthTotalTread, (NumStline-1)*treadDepth -xNosing+ breakLineWidth +ZigZag2Y+2*(treadDepth-ZigZag1Y), 1,
					widthTotalTread, (NumStline+1)*treadDepth-xNosing+breakLineWidth , 1,
					widthTotalTread, (nRisers)*treadDepth, 1,
					0, (nRisers)*treadDepth, 1
			else
				POLY2_b 4, 1+2*gs_FillAbove+4+64, gs_fill_pen, gs_back_pen,
					0, (NumStline-1)*treadDepth-xNosing+breakLineWidth, 1,
					widthTotalTread, (NumStline+1)*treadDepth-xNosing+breakLineWidth, 1,
					widthTotalTread, (nRisers)*treadDepth, 1,
					0, (nRisers)*treadDepth, 1
			endif
		endif

		HOTLINE2 0, (NumStline-1)*treadDepth-xNosing+breakLineWidth,widthTotalTread, (NumStline+1)*treadDepth-xNosing+breakLineWidth
		HOTLINE2 widthTotalTread, (NumStline+1)*treadDepth-xNosing+breakLineWidth,widthTotalTread, (nRisers)*treadDepth
		HOTLINE2 widthTotalTread, (nRisers)*treadDepth,0, (nRisers)*treadDepth
		HOTLINE2 0, (nRisers)*treadDepth,0, (NumStline-1)*treadDepth-xNosing+breakLineWidth

		! BREAK LINE
			HOTSPOT2 widthTotalTread/2,		(NumStline)*treadDepth-xNosing,					FlightUNID, breakLineWidth, 1+128	: FlightUNID=FlightUNID+1
			HOTSPOT2 widthTotalTread/2,		(NumStline)*treadDepth-xNosing-1,				FlightUNID, breakLineWidth, 3		: FlightUNID=FlightUNID+1
			HOTSPOT2 widthTotalTread/2,		(NumStline)*treadDepth-xNosing+breakLineWidth,	FlightUNID, breakLineWidth, 2		: FlightUNID=FlightUNID+1

			HOTSPOT2 0, (NumStline-1)*treadDepth-xNosing+breakLineWidth,				FlightUNID: FlightUNID=FlightUNID+1
			HOTSPOT2 widthTotalTread, (NumStline+1)*treadDepth-xNosing+breakLineWidth,	FlightUNID: FlightUNID=FlightUNID+1
		endif
	endif

! ==============================================================================
! TREADS
! ==============================================================================
DRAWINDEX 20

IF not(drawBreakline) THEN
	if drawPart[3] & drawSteps[3] then
		if aboveStory then
			PEN gs_LinePenStUp
			LINE_TYPE gs_LineTypeStUp
		else
			if drawDashed[3] then
				PEN gs_DashLinePen
				LINE_TYPE dash_line
			else
				PEN gs_cont_pen
				LINE_TYPE solid_line
			endif
		endif

		FOR numTread=1 to nRisers
			LINE2 0,-xNosing, widthTotalTread, -xNosing
			HOTLINE2 0,-xNosing, widthTotalTread, -xNosing
			ADD2 0,treadDepth
		NEXT numTread
		DEL numTread-1

		IF drawDetails[3] THEN
			PEN gs_DashLinePen
			LINE_TYPE dash_line

			FOR numTread=1 to nRisers
				LINE2 0, 0, widthTotalTread, 0
				HOTLINE2 0, 0, widthTotalTread, 0
				ADD2 0,treadDepth
			NEXT numTread
			DEL numTread-1
		endif
	endif
else
	if drawPart[1] & drawSteps[1] then

		xNosing = nosing * drawDetails[1]


		FOR numTread=1 to NumStline+1
			if aboveStory then
				PEN gs_LinePenStUp
				LINE_TYPE gs_LineTypeStUp
			else
				if drawDashed[1] then
					PEN gs_DashLinePen
					LINE_TYPE dash_line
				else
					PEN gs_cont_pen
					LINE_TYPE solid_line
				endif
			endif

			StartSolid=0
			if breakline_style_m = 1 then	! Straight
				IF numTread=NumStline+1 THEN StartSolid=StartSolid+widthTotalTread/2
			ELSE
				IF numTread=NumStline+1 THEN StartSolid=StartSolid+widthTotalTread*6/10
			ENDIF

			LINE2 StartSolid,-xNosing,widthTotalTread,-xNosing
			HOTLINE2 StartSolid,-xNosing,widthTotalTread,-xNosing

			if drawDetails[1] THEN
				PEN gs_DashLinePen
				LINE_TYPE dash_line

				StartDashed=0
				if breakline_style_m = 1 then	! Straight
					IF ABS(numTread-NumStline-1)<0.001 THEN StartDashed=widthTotalTread/2+xNosing/tan(bet)
				ELSE
					IF distZigZag >= 4/10*widthTotalTread THEN
						distZigZag = 4/10*widthTotalTread
					ELSE
						distZigZag=(widthTotalTread*(treadDepth-xNosing))/(2*treadDepth)
					ENDIF
					IF numTread=NumStline+1 THEN StartDashed=max(0,leftRailOffset+leftRailFrameThk,widthTotalTread-distZigZag)
				ENDIF

				IF ABS(numTread-(NumStline))<0.01 THEN StartDashed=xNosing/tan(bet)

				LINE2 StartDashed,0,widthTotalTread,0
				HOTLINE2 StartDashed,0,widthTotalTread,0
			ENDIF
			ADD2 0,treadDepth
		NEXT numTread
		DEL numTread-1
	endif

	IF drawPart[2] & drawSteps[2] THEN

		xNosing = nosing * drawDetails[2]

		ADD2 0,(NumStline)*treadDepth
		FOR numTread=1 to nRisers-NumStline
			if aboveStory then
				PEN gs_LinePenStUp
				LINE_TYPE gs_LineTypeStUp
			else
				if drawDashed[2] then
					PEN gs_DashLinePen
					LINE_TYPE dash_line
				else
					PEN gs_cont_pen
					LINE_TYPE solid_line
				endif
			endif

			EndSolid=widthTotalTread
			IF breakline_style_m = 1 THEN
				IF numTread=1 THEN EndSolid=(treadDepth-breakLineWidth)/tan(bet)
				IF numTread=2 THEN EndSolid=(2*treadDepth-breakLineWidth)/tan(bet)
			ELSE
				if breakline_style_m = 3 then
					ZigZagCorrection = 4/10
				else
					ZigZagCorrection = 7/20
				endif
				IF numTread=1 THEN EndSolid=Min(ZigZagCorrection *widthTotalTread,(treadDepth-breakLineWidth)/tan(bet))
				IF numTread=2 THEN
					IF ZigZag2Y+2*(treadDepth-ZigZag1Y)<2*treadDepth-breakLineWidth THEN EndSolid=(2*treadDepth-breakLineWidth)/tan(bet)
					IF ZigZag2Y+2*(treadDepth-ZigZag1Y)>=2*treadDepth-breakLineWidth THEN EndSolid=ZigZagCorrection *widthTotalTread
				ENDIF
			ENDIF

			LINE2 0,-xNosing,EndSolid,-xNosing
			HOTLINE2 0,-xNosing,EndSolid,-xNosing

			IF drawDetails[2] THEN
				PEN gs_DashLinePen
				LINE_TYPE dash_line

				EndDashed=widthTotalTread
				if breakline_style_m = 1 then	! Straight
					IF numTread=1 THEN EndDashed=Min(widthTotalTread,(treadDepth-breakLineWidth+xNosing)/tan(bet))
					IF numTread=2 THEN EndDashed=Min(widthTotalTread,(2*treadDepth-breakLineWidth+xNosing)/tan(bet))
				ELSE
					IF distZigZag <= ZigZagCorrection *widthTotalTread THEN
						distZigZag = ZigZagCorrection *widthTotalTread
					ELSE
						distZigZag=(widthTotalTread*(treadDepth/2+xNosing))/(2*treadDepth)
					ENDIF

						IF numTread=1 THEN EndDashed=Min(ZigZagCorrection*widthTotalTread,(treadDepth-breakLineWidth+xNosing)/tan(bet))
					IF numTread=2 THEN
							IF ZigZag2Y+2*(treadDepth-ZigZag1Y)<2*treadDepth+xNosing-breakLineWidth THEN EndDashed=Min(widthTotalTread,(2*treadDepth+xNosing-breakLineWidth)/tan(bet))
							IF ZigZag2Y+2*(treadDepth-ZigZag1Y)>=2*treadDepth+xNosing-breakLineWidth THEN EndDashed=Min(widthTotalTread,ZigZagCorrection*widthTotalTread)
					ENDIF
				ENDIF

				LINE2 0,0,EndDashed,0
				HOTLINE2 0,0,EndDashed,0
			ENDIF

			ADD2 0,treadDepth
		NEXT numTread
		DEL numTread-1
		DEL 1
		endif
	endif

! ==============================================================================
! WALKING LINE / ARROWHEAD / START END SYMBOL
! ==========================================================================
reverseWalkline = 0
if walkingDirUPDN_m = 3 | walkingDirUPDN_m = 4 | (walkingDirUPDN_m = 6 & abovestory) then
	reverseWalkline = 1
endif

if bShowWalkLine & not(belowStory) then

	PEN gs_wLinePen
	FILL gs_ArrowFill

	for i = 1 to 3
		DRAWINDEX 40
		drawWalkLine = 1
		if not(bShowWalkLineAboveBreakline) & i = 2 then drawWalkLine = 0

		if drawPart[i] & drawWalkLine then
			xNosing = nosing * drawDetails[i]

			startLine = -xNosing
			endLine = (nRisers)*treadDepth
			penFillArrow = gs_ArrowFillPen
			if i = 1 then endLine = (NumStline)*treadDepth-xNosing
			if i = 2 then
				startLine = startLine + (NumStline)*treadDepth+breakLineWidth
				penFillArrow = gs_ArrowFillPenAbove
				if walkingDirUPDN_m = 5 then reverseWalkline = 1
			endif

			if aboveStory then
				LINE_TYPE gs_wLineTypeStUp
			else
				if (drawDashed[i]) then
					LINE_TYPE gs_wLineTypeAbove
				else
					LINE_TYPE gs_wLineType1
				endif
			endif

			IF i = 3 & walkingDirUPDN_m = 5 THEN
				! Up Down Both - UP
				endLine = startLine + (INT(nRisers/3))*treadDepth
				ADD2 widthTotalTread/2, endLine
				GOSUB "Arrowhead Symbol"
				DEL 1
				endLine = endLine-lengthArrowHead

				line2 widthTotalTread/2, startLine, widthTotalTread/2, endLine

				ADD2 widthTotalTread/2, startLine
				GOSUB "Start End Symbol"
				DEL 1

				! Up Down Both - Down
				endLine = (nRisers)*treadDepth
				startLine = startLine + endLine - (MAX(1, INT(nRisers/3)))*treadDepth
				ADD2 widthTotalTread/2, startLine
				MUL2 1, -1
				GOSUB "Arrowhead Symbol"
				DEL 2
				startLine = startLine+lengthArrowHead

				ADD2 widthTotalTread/2, endLine
				GOSUB "Start End Symbol"
				DEL 1
			else
				! Arrow Head below Break Line
				if not(reverseWalkline)	then
					ADD2 widthTotalTread/2, endLine
					GOSUB "Arrowhead Symbol"
					DEL 1
					endLine = endLine-lengthArrowHead

					if i <> 2 then
						ADD2 widthTotalTread/2, startLine
						GOSUB "Start End Symbol"
						DEL 1
					endif
				endif

				! Arrow Head on Start
				if reverseWalkline then
					ADD2 widthTotalTread/2, startLine
					MUL2 1, -1
					GOSUB "Arrowhead Symbol"
					DEL 2
					startLine = startLine+lengthArrowHead

					if i <> 1 then
						ADD2 widthTotalTread/2, endLine
						GOSUB "Start End Symbol"
						DEL 1
					endif
				endif
			endif

			! Walking Line
			if drawWalkLine then line2 widthTotalTread/2, startLine, widthTotalTread/2, endLine
		endif
	next i
ENDIF

! ==============================================================================
! Text / Up - Down Text / Numbering
! ==============================================================================

! --- Oriented View ------------------------------------------------------------
angleViewRot = 0
if bShowRiseAndRunText | walkingDirUPDN_m <> 1 | drawNum | gs_description <> "" then
	rrr = REQUEST ("View_Rotangle", "", angleViewRot)
endif
totalRotate = (SYMB_ROTANGLE + angleViewRot) MOD 360


! --- Define Font Style --------------------------------------------------------

define style "UPDN" fontType, UPDNfontsize, 5, 0		  	! UP/DN

define style "stepnum" fontType, gs_NumTextSize, 1, 0		! Numbering

define style "description" fontType, gs_desc_text_size, 4, 0	! Description

! --- Rise & Run Text -------------------------------------------------------

if bShowRiseAndRunText & bShowWalkLine & not(belowStory) then
	call "Stair_RiseRun_Text" PARAMETERS ALL	totalRotate	= totalRotate,
												iRotateType = 2,
												iRiseRunTextPosition = 1,
												RiseRunUNID	= RiseRunUNID
endif


! --- Up & Down Text ---------------------------------------------------------
iReadable = 0
if walkingDirUPDN_m <> 1 & bShowWalkLine & not(belowStory) then		! None
	DRAWINDEX 50
	PEN UPDNfontpen
	xNosing = nosing * (drawDetails[1]|drawDetails[3])

	if (walkingDirUPDN_m = 2 | walkingDirUPDN_m = 5 | (walkingDirUPDN_m = 6 & not(abovestory) & not(belowstory) )) & (drawPart[1]|drawPart[3]) then
		nTransUPDN = 0
		set style "UPDN"
		add2 widthTotalTread/2+DirUPDN_X,DirUPDN_Y-xNosing
		nTransUPDN = nTransUPDN + 1
		! Text Rotation - Readable / Parallel with Walking Line / Align with Symbol
		! ----------------------------------------------------------------------
		if typeTextRotation_UpDn_m = 2 then									! Readable
			if ((totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps)) & SYMB_MIRRORED) | \
				((totalRotate < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps)) & not(SYMB_MIRRORED)) then
				rot2 180
				nTransUPDN = nTransUPDN + 1
			endif
		else
			if typeTextRotation_UpDn_m = 1 then								! Parallel with Walking Line
				iReadable = (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps))- not(totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps))
				rot2 -90 * iReadable
				nTransUPDN = nTransUPDN + 1
			endif
		endif
		! ----------------------------------------------------------------------
		rot2 AngUPDN
		nTransUPDN = nTransUPDN + 1

		string1=`ВВЕРХ`
		text2 0,0, string1

		del nTransUPDN

		width1	= STW (string1)/1000*GLOB_SCALE
		rb		= width1/2
	endif

	if walkingDirUPDN_m = 3 & (drawPart[1]|drawPart[3]) then ! Down at Bottom
		nTransUPDN = 0
		set style "UPDN"
		add2 widthTotalTread/2+DirUPDN_X,DirUPDN_Y-xNosing
		nTransUPDN = nTransUPDN + 1

		! Text Rotation - Readable / Parallel with Walking Line / Align with Symbol
		! ----------------------------------------------------------------------
		if typeTextRotation_UpDn_m = 2 then									! Readable
			if ((totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps)) & SYMB_MIRRORED) | \
				((totalRotate < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps)) & not(SYMB_MIRRORED)) then
				rot2 180
				nTransUPDN = nTransUPDN + 1
			endif
		else
			if typeTextRotation_UpDn_m = 1 then								! Parallel with Walking Line
				iReadable = (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps))- not(totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps))
				rot2 -90 * iReadable
				nTransUPDN = nTransUPDN + 1
			endif
		endif
		! ----------------------------------------------------------------------
		rot2 AngUPDN
		nTransUPDN = nTransUPDN + 1

		text2 0,0, gs_CustomText_Down

		del nTransUPDN

		string2	= gs_CustomText_Down
		width2	= STW (string2)/1000*GLOB_SCALE
		rb		= width2/2
	endif

	if (walkingDirUPDN_m = 2 | walkingDirUPDN_m = 5 | walkingDirUPDN_m = 3 | (walkingDirUPDN_m = 6 & not(abovestory) & not(belowstory))) & (drawPart[1]|drawPart[3]) then
		nTransHotspot = 0
		add2 widthTotalTread/2+DirUPDN_X,DirUPDN_Y-xNosing
		nTransHotspot = nTransHotspot  + 1
		if typeTextRotation_UpDn_m = 1 then
			rot2 -90 * iReadable
			nTransHotspot = nTransHotspot  + 1
		endif
		HOTSPOT2 0,					0,				UpDownUNID,	AngUPDN,	6		: UpDownUNID=UpDownUNID+1
		HOTSPOT2 rb,				0,				UpDownUNID,	AngUPDN,	4+128	: UpDownUNID=UpDownUNID+1
		HOTSPOT2 rb*cos(AngUPDN),	rb*sin(AngUPDN),UpDownUNID,	AngUPDN,	5		: UpDownUNID=UpDownUNID+1
		DEL nTransHotspot
	endif

	if (walkingDirUPDN_m = 4 | walkingDirUPDN_m = 5 | (walkingDirUPDN_m = 6 & abovestory)) & (drawPart[2]|drawPart[3]) then
		nTransUPDN = 0
		set style "UPDN"
		add2 widthTotalTread/2+DirUPDN_X_top, DirUPDN_Y_top + A
		nTransUPDN = nTransUPDN + 1

		! Text Rotation - Readable / Parallel with Walking Line / Align with Symbol
		! ----------------------------------------------------------------------
		if typeTextRotation_UpDn_m = 2 then									! Readable
			if ((totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps)) & SYMB_MIRRORED) | \
				((totalRotate < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps)) & not(SYMB_MIRRORED)) then
				rot2 180
				nTransUPDN = nTransUPDN + 1
			endif
		else
			if typeTextRotation_UpDn_m = 1 then								! Parallel with Walking Line
				iReadable = (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps))- not(totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps))
				rot2 -90 * iReadable
				nTransUPDN = nTransUPDN + 1
			endif
		endif
		! ----------------------------------------------------------------------
		rot2 AngUPDN_top
		nTransUPDN = nTransUPDN + 1

		text2 0,0, gs_CustomText_Down

		del nTransUPDN

		string2	= gs_CustomText_Down
		width2	= STW (string2)/1000*GLOB_SCALE
		rb		= width2/2
	endif

	if (walkingDirUPDN_m = 4 | walkingDirUPDN_m = 5 | (walkingDirUPDN_m = 6 & abovestory)) & (drawPart[2]|drawPart[3]) then
		nTransHotspot = 0
		add2 widthTotalTread/2+DirUPDN_X_top, DirUPDN_Y_top+A
		nTransHotspot = nTransHotspot  + 1
		if typeTextRotation_UpDn_m = 1 then
			rot2 -90 * iReadable
			nTransHotspot = nTransHotspot  + 1
		endif
		HOTSPOT2 0,						0,					UpDownUNID,	AngUPDN_top,	6		: UpDownUNID=UpDownUNID+1
		HOTSPOT2 rb,					0,					UpDownUNID,	AngUPDN_top,	4+128	: UpDownUNID=UpDownUNID+1
		HOTSPOT2 rb*cos(AngUPDN_top),	rb*sin(AngUPDN_top),UpDownUNID,	AngUPDN_top,	5		: UpDownUNID=UpDownUNID+1
		DEL nTransHotspot
	endif
endif

! --- Numbering ----------------------------------------------------------------

if drawNum & not(belowStory) then
	DRAWINDEX 50
	set style "stepnum"
	nnn = REQUEST ("Height_of_style", "stepnum", strHeight)
	strHeight = strHeight / 1000 * GLOB_SCALE

	xNosing = nosing * (drawDetails[1]|drawDetails[3])
	add2 DirNumText_X, DirNumText_Y - treadDepth/2 - xNosing

	for iNumStep = 1 to nRisers
		add2 0,treadDepth
		pen gs_NumTextPen
		nTextTransformations = 0
		! Text Rotation - Readable / Align with Symbol
		! ----------------------------------------------------------------------
		if typeTextRotation_Num_m = 2 then								! Readable
			if ((totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps)) & SYMB_MIRRORED) | \
				((totalRotate < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps)) & not(SYMB_MIRRORED)) then
				rot2 180
				strWidth = stw(str("%.0", iNumStep + nStartNumbering-1)) / 1000 * GLOB_SCALE
				add2 -strWidth, strHeight
				nTextTransformations = 2
			endif
		endif
		! ----------------------------------------------------------------------

		text2 0,0, iNumStep + nStartNumbering - 1
		if nTextTransformations > 0 then del nTextTransformations
		pen gs_cont_pen
	next iNumStep
	del nRisers +1

	hotspot2 0,				DirNumText_Y- xNosing,	NumUnID, DirNumText_X, 1+128	:NumUnID=NumUnID+1
	hotspot2 -1,			DirNumText_Y- xNosing,	NumUnID, DirNumText_X, 3		:NumUnID=NumUnID+1
	hotspot2 DirNumText_X,	DirNumText_Y- xNosing,	NumUnID, DirNumText_X,	2		:NumUnID=NumUnID+1

	hotspot2 DirNumText_X, 0- xNosing,				NumUnID, DirNumText_Y, 1+128	:NumUnID=NumUnID+1
	hotspot2 DirNumText_X, -1- xNosing,				NumUnID, DirNumText_Y, 3		:NumUnID=NumUnID+1
	hotspot2 DirNumText_X, DirNumText_Y- xNosing,	NumUnID, DirNumText_Y, 2		:NumUnID=NumUnID+1
endif

! --- Description ----------------------------------------------------------------

if STRLEN(gs_description) <> 0 & not(belowStory) then
	lengthWalkLine = A

	! --- positioning ---
	rot2	90
	nTransDes = 1

	dim gs_description_bpos[3][3]
	gs_description_bpos[1][1] = lengthWalkLine/2
	gs_description_bpos[1][2] = -widthTotalTread/2
	gs_description_bpos[1][3] = 0

	style "description"
	pen gs_desc_text_pen
	add2 (gs_description_bpos[1][1] + gs_description_pos[1][1]), (gs_description_bpos[1][2] + gs_description_pos[1][2])

	textangle = (gs_description_bpos[1][3] + gs_description_pos[1][3])

	reversedText = 0
	angleFull = (totalRotate + textangle) MOD 360

	if angleFull < 0 then
		angleFull = angleFull + 360
	endif
	if angleFull > (gs_readable_angle+eps) & angleFull < (gs_readable_angle + 180 +eps) then
		reversedText = 1
		textangle = textangle + 180
	endif
	rot2 textangle

	if reversedText then
		text2 -STW(gs_description) / 1000 * GLOB_SCALE, 0, gs_description
	else
		text2 0,0, gs_description
	endif

	del 2
	hotspot2 gs_description_bpos[1][1], gs_description_bpos[1][2] + gs_description_pos[1][2], 40000+1, gs_description_pos[1][1], 1 + 128
	posRel = gs_description_pos[1][1]
	if abs(posRel) < 0.00001 then
		posRel = 0.0001
	else
		posRel = 0
	endif
	hotspot2 gs_description_bpos[1][1] - posRel, gs_description_bpos[1][2] + gs_description_pos[1][2], 40000+2, gs_description_pos[1][1], 3 + 128
	hotspot2 gs_description_bpos[1][1] + gs_description_pos[1][1], gs_description_bpos[1][2] + gs_description_pos[1][2], 40000+3, gs_description_pos[1][1], 2

	hotspot2 gs_description_bpos[1][1] + gs_description_pos[1][1], gs_description_bpos[1][2], 40000+4, gs_description_pos[1][2], 1 + 128
	posRel = gs_description_pos[1][2]
	if abs(posRel) < 0.00001 then
		posRel = 0.0001
	else
		posRel = 0
	endif
	hotspot2 gs_description_bpos[1][1] + gs_description_pos[1][1], gs_description_bpos[1][2] - posRel, 40000+5, gs_description_pos[1][2], 3 + 128
	hotspot2 gs_description_bpos[1][1] + gs_description_pos[1][1], gs_description_bpos[1][2] + gs_description_pos[1][2], 40000+6, gs_description_pos[1][2], 2

	!angle edit
	HOTSPOT2 gs_description_bpos[1][1] + gs_description_pos[1][1],
				gs_description_bpos[1][2] + gs_description_pos[1][2],
				40000+7, gs_description_pos[1][3], 6 + 128

	HOTSPOT2 gs_description_bpos[1][1] + gs_description_pos[1][1] + GLOB_SCALE*0.5*COS(gs_description_bpos[1][3])*gs_desc_text_size/1000,
				gs_description_bpos[1][2] + gs_description_pos[1][2] + GLOB_SCALE*0.5*SIN(gs_description_bpos[1][3])*gs_desc_text_size/1000,
				40000+8, gs_description_pos[1][3], 4 + 128

	HOTSPOT2 gs_description_bpos[1][1] + gs_description_pos[1][1] + GLOB_SCALE*0.5*gs_desc_text_size*COS(gs_description_bpos[1][3] + gs_description_pos[1][3])/1000,
				gs_description_bpos[1][2] + gs_description_pos[1][2] + GLOB_SCALE*0.5*gs_desc_text_size*SIN(gs_description_bpos[1][3] + gs_description_pos[1][3])/1000,
				40000+9, gs_description_pos[1][3], 5
	del nTransDes

endif

!===============================================================================
! --- Carriage Line ---
!===============================================================================

if bCarriageLineExist and not(belowStory) then
	drawindex 10
	fill gs_fill_type

	bShowCarriagePart1	= 0
	bShowCarriagePart2	= 0

	beamNum				= 2
	beamThk				= widthStringer
	beamOffsetRight		= 0
	beamOffsetLeft		= 0
	carriageBaseDist	= flightWidth
	carrBreakLineWidth	= breakLineWidth

	if drawPart[3] then
		!!!!!******************************      1st RUN
		add2 -(b - widthTotalTread) / 2, (widthOverlapTread - cutDistLowerEnd)
			beamLength			= a - (widthOverlapTread - cutDistLowerEnd)
			bCarrAboveBreakLine	= 0
			bBreakCarriageLine	= 0
			gosub "carriage"
		del 1
	else
		if drawPart[1] then
			!!!!!******************************      1st RUN
			add2 -(b - widthTotalTread) / 2, (widthOverlapTread - cutDistLowerEnd)
				beamLength			= a - (widthOverlapTread - cutDistLowerEnd)
				bCarrAboveBreakLine	= 0
				bBreakCarriageLine	= 1
				bShowCarriagePart1	= 1
				bShowCarriagePart2	= 0
				brLineAngle			= bet
				xNosing				= nosing * drawDetails[1]
				carrBreakLineDist	= NumStline * treadDepth - xNosing + (flightWidth / 2 - beamOffsetRight - beamThk / 2) * tan(brLineAngle) - (widthOverlapTread - cutDistLowerEnd)
				gosub "carriage"
			del 1
		endif

		if drawPart[2] then
			!!!!!******************************      1st RUN
			add2 -(b - widthTotalTread) / 2, (widthOverlapTread - cutDistLowerEnd)
				beamLength			= a - (widthOverlapTread - cutDistLowerEnd)
				bCarrAboveBreakLine	= 1
				bBreakCarriageLine	= 1
				bShowCarriagePart1	= 0
				bShowCarriagePart2	= 1
				brLineAngle			= bet
				xNosing				= nosing * drawDetails[2]
				carrBreakLineDist	= NumStline * treadDepth - xNosing + (flightWidth / 2 - beamOffsetRight - beamThk / 2) * tan(brLineAngle) - (widthOverlapTread - cutDistLowerEnd)
				gosub "carriage"
			del 1
		endif
	endif
endif

!===============================================================================
! --- Railings ---
!===============================================================================
if _bShowRailIn2D & not(belowStory) then
	bShowRailPart1	= 0
	bShowRailPart2	= 0
	breakLineW		= breakLineWidth
	breakLineDist	= 0
	brLineAngle		= bet

	drawindex 30
	fill gs_fill_type


	! --- Left Rail ----------------------------------------------------------------
	if rail_m = 3 | rail_m = 1 then	! Left, Both
		if bSameRails then
			leftRailType_m = rightRailType_m
			leftWireType_m = rightWireType_m
		endif

		add2 -(b - widthTotalTread) / 2, 0

		if drawBreakline then
			if drawPart[1] & bShowRailOnFloorPlan then
				pen railPen
				if aboveStory then
					SET LINE_TYPE railLineType
				else
					if (drawDashed[1]) then
						SET LINE_TYPE dash_line
					else
						SET LINE_TYPE railLineType
					endif
				endif
				xNosing = nosing * drawDetails[1]

				if bSymbolic2D then
					bShowRailOn1stRun		= 1
					bBreakRailLine			= 1
					brLineAngle				= bet
					bShowRailPart1			= 1
					breakLineDist			= leftRailOvhgBottom - xNosing + (NumStline - 1) * treadDepth + (leftRailOffset+leftRailFrameThk - (b - widthTotalTread) / 2) * TAN(bet)
					breakLineW				= breakLineWidth + xNosing
					bRailAboveBreakLine		= 0
					gosub "left rail"
				else
					poly2_b 5, 1+2+64, gs_fill_pen, gs_back_pen,
						leftRailOffset,					-leftRailOvhgBottom,1,
						leftRailOffset+leftRailFrameThk,-leftRailOvhgBottom,1,
						leftRailOffset+leftRailFrameThk,-xNosing+(NumStline-1)*treadDepth+(leftRailOffset+leftRailFrameThk - (b - widthTotalTread) / 2)*tan(bet),1,
						leftRailOffset,					-xNosing+(NumStline-1)*treadDepth+(leftRailOffset - (b - widthTotalTread) / 2)*tan(bet),1,
						leftRailOffset,					-leftRailOvhgBottom,1
				endif
			endif

			if drawPart[2] & bShowRailOnFloorPlan and bShowRailAboveBreakLine then
				pen railPen
				if aboveStory then
					SET LINE_TYPE railLineType
				else
					if (drawDashed[2]) then
						SET LINE_TYPE dash_line
					else
						SET LINE_TYPE railLineType
					endif
				endif
				xNosing = nosing * drawDetails[2]

				if bSymbolic2D then
					xNosing =  nosing * NOT(drawDetails[2])
					bShowRailOn1stRun		= 1
					bBreakRailLine			= 1
					brLineAngle				= bet
					bShowRailPart2			= 1
					breakLineDist			= leftRailOvhgBottom - nosing + (NumStline - 1) * treadDepth + (leftRailOffset+leftRailFrameThk-(b - widthTotalTread) / 2) * TAN(bet)
					breakLineW				= breakLineWidth + xNosing
					bRailAboveBreakLine		= 1
					gosub "left rail"
				else
					poly2_b 5, 1+2*gs_FillAbove+64, gs_fill_pen, gs_back_pen,
						leftRailOffset,					(nRisers)*treadDepth+leftRailOvhgTop,1,
						leftRailOffset+leftRailFrameThk,(nRisers)*treadDepth+leftRailOvhgTop,1,
						leftRailOffset+leftRailFrameThk,-xNosing+(NumStline-1)*treadDepth+breakLineWidth+(leftRailOffset+leftRailFrameThk - (b - widthTotalTread) / 2)*tan(bet),1,
						leftRailOffset,					-xNosing+(NumStline-1)*treadDepth+breakLineWidth+(leftRailOffset - (b - widthTotalTread) / 2)*tan(bet),1,
						leftRailOffset,					(nRisers)*treadDepth+leftRailOvhgTop,1
				endif
			endif

			if bShowRailAxis then
				line_type railAxisLineType
				pen gs_RailAxisPen
				if drawPart[1] then
					xNosing = nosing * drawDetails[1]
					line2 leftRailOffset+leftRailFrameThk/2, -xNosing+(NumStline-1)*treadDepth+(leftRailOffset+leftRailFrameThk/2 - (b - widthTotalTread) / 2)*tan(bet),leftRailOffset+leftRailFrameThk/2,-leftRailOvhgBottom
				endif
				if drawPart[2] then
					xNosing = nosing * drawDetails[2]
					line2 leftRailOffset+leftRailFrameThk/2, -xNosing+(NumStline-1)*treadDepth+breakLineWidth+(leftRailOffset+leftRailFrameThk/2 - (b - widthTotalTread) / 2)*tan(bet),leftRailOffset+leftRailFrameThk/2,(nRisers)*treadDepth+leftRailOvhgTop
				endif
			endif
		else
			if drawPart[3] & bShowRailOnFloorPlan then
				pen railPen
				if aboveStory then
					LINE_TYPE railLineType
				else
					if (drawDashed[3]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE railLineType
					endif
				endif
				xNosing =  0 ! COMP nosing * drawDetails[3]

				if bSymbolic2D then
					bShowRailOn1stRun		= 1
					bBreakRailLine			= 0
					bRailAboveBreakLine		= 0
					gosub "left rail"
				else
					poly2_b 5, 1+2+64, gs_fill_pen, gs_back_pen,
						leftRailOffset,					-xNosing-leftRailOvhgBottom,1,
						leftRailOffset+leftRailFrameThk,-xNosing-leftRailOvhgBottom,1,
						leftRailOffset+leftRailFrameThk,(nRisers)*treadDepth+leftRailOvhgTop,1,
						leftRailOffset,					(nRisers)*treadDepth+leftRailOvhgTop,1,
						leftRailOffset,					-xNosing-leftRailOvhgBottom,1
				endif
			endif

			if bShowRailAxis then
				line_type railAxisLineType
				pen gs_RailAxisPen
				xNosing =  0 ! COMP nosing * drawDetails[3]
				line2 leftRailOffset+leftRailFrameThk/2, (nRisers)*treadDepth+leftRailOvhgTop,leftRailOffset+leftRailFrameThk/2,-xNosing-leftRailOvhgBottom
			endif
		endif

		del 1
	endif

	! --- Right Rail ---------------------------------------------------------------
	if rail_m = 2 | rail_m = 1 then		! Right, Both
		add2 -(b - widthTotalTread) / 2, 0

		if drawBreakline then
			if drawPart[1] & bShowRailOnFloorPlan then
				pen railPen
				if aboveStory then
					LINE_TYPE railLineType
				else
					if (drawDashed[1]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE railLineType
					endif
				endif
				xNosing = nosing * drawDetails[1]

				if bSymbolic2D then
					bShowRailOn1stRun		= 1
					bBreakRailLine			= 1
					brLineAngle				= bet
					bShowRailPart1			= 1
					breakLineDist			= rightRailOvhgBottom - xNosing + (NumStline + 1) * treadDepth - (rightRailOffset - (b - widthTotalTread) / 2) * TAN(bet)
					breakLineW				= breakLineWidth + xNosing
					bRailAboveBreakLine		= 0
					gosub "right rail"
				else
					poly2_b 5, 1+2+64, gs_fill_pen, gs_back_pen,
						flightWidth-rightRailOffset-rightRailFrameThk,	-rightRailOvhgBottom,1,
						flightWidth-rightRailOffset,					-rightRailOvhgBottom,1,
						flightWidth-rightRailOffset,					-xNosing+(NumStline+1)*treadDepth-(rightRailOffset - (b - widthTotalTread) / 2)*tan(bet),1,
						flightWidth-rightRailOffset-rightRailFrameThk,	-xNosing+(NumStline+1)*treadDepth-(rightRailOffset+rightRailFrameThk - (b - widthTotalTread) / 2)*tan(bet),1,
						flightWidth-rightRailOffset-rightRailFrameThk,	-rightRailOvhgBottom,1
				endif
			endif

			if drawPart[2] & bShowRailOnFloorPlan and bShowRailAboveBreakLine then
				pen railPen
				if aboveStory then
					LINE_TYPE railLineType
				else
					if (drawDashed[2]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE railLineType
					endif
				endif
				xNosing = nosing * drawDetails[2]

				if bSymbolic2D then
					xNosing =  nosing * NOT(drawDetails[2])
					bShowRailOn1stRun		= 1
					bBreakRailLine			= 1
					brLineAngle				= bet
					bShowRailPart2			= 1
					breakLineDist			= rightRailOvhgBottom - nosing + (NumStline + 1) * treadDepth - (rightRailOffset - (b - widthTotalTread) / 2) * TAN(bet)
					breakLineW				= breakLineWidth + xNosing
					bRailAboveBreakLine		= 1
					gosub "right rail"
				else
					poly2_b 5, 1 + 2 * gs_FillAbove+64, gs_fill_pen, gs_back_pen,
						flightWidth-rightRailOffset-rightRailFrameThk,	(nRisers)*treadDepth+rightRailOvhgTop,1,
						flightWidth-rightRailOffset,					(nRisers)*treadDepth+rightRailOvhgTop,1,
						flightWidth-rightRailOffset,					-xNosing+(NumStline+1)*treadDepth+breakLineWidth-(rightRailOffset - (b - widthTotalTread) / 2)*tan(bet),1,
						flightWidth-rightRailOffset-rightRailFrameThk,	-xNosing+(NumStline+1)*treadDepth+breakLineWidth-(rightRailOffset+rightRailFrameThk - (b - widthTotalTread) / 2)*tan(bet),1,
						flightWidth-rightRailOffset-rightRailFrameThk,	(nRisers)*treadDepth+rightRailOvhgTop,1
				endif
			endif

			if bShowRailAxis then
				line_type railAxisLineType
				pen gs_RailAxisPen
				if drawPart[1]then
					xNosing = nosing * drawDetails[1]
					line2 flightWidth-rightRailOffset-rightRailFrameThk/2, -xNosing+(NumStline+1)*treadDepth-(rightRailOffset+rightRailFrameThk/2 - (b - widthTotalTread) / 2)*tan(bet),
						flightWidth-rightRailOffset-rightRailFrameThk/2,-rightRailOvhgBottom
				endif
				if drawPart[2] then
					xNosing = nosing * drawDetails[2]
					line2 flightWidth-rightRailOffset-rightRailFrameThk/2, -xNosing+(NumStline+1)*treadDepth+breakLineWidth-(rightRailOffset+rightRailFrameThk/2 - (b - widthTotalTread) / 2)*tan(bet),
						flightWidth-rightRailOffset-rightRailFrameThk/2,(nRisers)*treadDepth+rightRailOvhgTop
				endif
			endif
		else
			if drawPart[3] & bShowRailOnFloorPlan then
				pen railPen
				if aboveStory then
					LINE_TYPE railLineType
				else
					if (drawDashed[3]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE railLineType
					endif
				endif
				xNosing =  0 ! COMP nosing * drawDetails[3]

				if bSymbolic2D then
					bShowRailOn1stRun		= 1
					bBreakRailLine			= 0
					bRailAboveBreakLine		= 0
					gosub "right rail"
				else
					poly2_b 5, 1+2+64, gs_fill_pen, gs_back_pen,
						flightWidth-rightRailOffset,					-xNosing-rightRailOvhgBottom,1,
						flightWidth-rightRailOffset-rightRailFrameThk,	-xNosing-rightRailOvhgBottom,1,
						flightWidth-rightRailOffset-rightRailFrameThk,	(nRisers)*treadDepth+rightRailOvhgTop,1,
						flightWidth-rightRailOffset,					(nRisers)*treadDepth+rightRailOvhgTop,1,
						flightWidth-rightRailOffset,					-xNosing-rightRailOvhgBottom,1
				endif
			endif

			if bShowRailAxis then
				line_type railAxisLineType
				pen gs_RailAxisPen
				xNosing =  0 ! COMP nosing * drawDetails[3]
				line2 flightWidth-rightRailOffset-rightRailFrameThk/2, (nRisers)*treadDepth+rightRailOvhgTop,flightWidth-rightRailOffset-rightRailFrameThk/2,-xNosing-rightRailOvhgBottom
			endif
		endif

		del 1
	endif
endif

!===============================================================================
! --- Hotspot Editing 2D ---
!===============================================================================

drawindex 50
pen gs_cont_pen
! --- Flight Width -------------------------------------------------------------
xNosing = 0!nosing * (drawDetails[1] | drawDetails[3])

add2 -(b - widthTotalTread) / 2, 0
	HOTSPOT2 flightWidth,	xNosing,	FlightUNID, b, 1+256 : FlightUNID=FlightUNID+1
	HOTSPOT2 0,				xNosing,	FlightUNID, b, 2	: FlightUNID=FlightUNID+1
	HOTSPOT2 flightWidth+1,	0,			FlightUNID, b, 3	: FlightUNID=FlightUNID+1

	HOTSPOT2 flightWidth,	(nRisers)*treadDepth+xNosing,	FlightUNID, b, 1+256: FlightUNID=FlightUNID+1
	HOTSPOT2 0,				(nRisers)*treadDepth+xNosing,	FlightUNID, b, 2	: FlightUNID=FlightUNID+1
	HOTSPOT2 flightWidth+1,	(nRisers)*treadDepth+xNosing,	FlightUNID, b, 3	: FlightUNID=FlightUNID+1

	HOTSPOT2 0,	xNosing,	FlightUNID, a, 1+256: FlightUNID=FlightUNID+1
	HOTSPOT2 0,	a+xNosing,	FlightUNID, a, 2	: FlightUNID=FlightUNID+1
	HOTSPOT2 0,	-1,			FlightUNID, a, 3	: FlightUNID=FlightUNID+1

	HOTSPOT2 flightWidth,	xNosing,	FlightUNID, a, 1+256 : FlightUNID=FlightUNID+1
	HOTSPOT2 flightWidth,	a+xNosing,	FlightUNID, a, 2	: FlightUNID=FlightUNID+1
	HOTSPOT2 flightWidth,	-1,			FlightUNID, a, 3	: FlightUNID=FlightUNID+1
del 1

! --- UP/DOWN TEXT -------------------------------------------------------------
if bShowWalkLine & not(belowstory) then
	IF walkingDirUPDN_m = 2 | walkingDirUPDN_m = 3 | walkingDirUPDN_m = 5 then
		HOTSPOT2 widthTotalTread/2,			DirUPDN_Y-xNosing ,		UpDownUNID, DirUPDN_X, 1+128 : UpDownUNID = UpDownUNID+1
		HOTSPOT2 widthTotalTread/2-1,		DirUPDN_Y-xNosing ,		UpDownUNID, DirUPDN_X, 3	: UpDownUNID = UpDownUNID+1
		HOTSPOT2 widthTotalTread/2+DirUPDN_X,	DirUPDN_Y-xNosing ,	UpDownUNID, DirUPDN_X, 2	: UpDownUNID = UpDownUNID+1

		HOTSPOT2 widthTotalTread/2+DirUPDN_X,	0,			UpDownUNID, DirUPDN_Y, 1+128 : UpDownUNID = UpDownUNID+1
		HOTSPOT2 widthTotalTread/2+DirUPDN_X,	-1,			UpDownUNID, DirUPDN_Y, 3	: UpDownUNID = UpDownUNID+1
		HOTSPOT2 widthTotalTread/2+DirUPDN_X,DirUPDN_Y-xNosing ,		UpDownUNID, DirUPDN_Y, 2	: UpDownUNID = UpDownUNID+1
	ENDIF

	IF walkingDirUPDN_m = 4  | walkingDirUPDN_m = 5 then
		HOTSPOT2 widthTotalTread/2,			DirUPDN_Y_top+A,		UpDownUNID, DirUPDN_X_top, 1+128 : UpDownUNID = UpDownUNID+1
		HOTSPOT2 widthTotalTread/2-1,		DirUPDN_Y_top+A,		UpDownUNID, DirUPDN_X_top, 3	: UpDownUNID = UpDownUNID+1
		HOTSPOT2 widthTotalTread/2+DirUPDN_X_top,	DirUPDN_Y_top+A,UpDownUNID, DirUPDN_X_top, 2	: UpDownUNID = UpDownUNID+1

		HOTSPOT2 widthTotalTread/2+DirUPDN_X_top,	0+A,			UpDownUNID, DirUPDN_Y_top, 1+128 : UpDownUNID = UpDownUNID+1
		HOTSPOT2 widthTotalTread/2+DirUPDN_X_top,	-1+A,			UpDownUNID, DirUPDN_Y_top, 3	: UpDownUNID = UpDownUNID+1
		HOTSPOT2 widthTotalTread/2+DirUPDN_X_top,DirUPDN_Y_top+A,	UpDownUNID, DirUPDN_Y_top, 2	: UpDownUNID = UpDownUNID+1
	ENDIF
endif

!-- RAILING  ---------------------------------------------------
if _bShowRailIn2D & bShowRailOnFloorPlan & not(belowStory) then
	xNosing = 0 ! COMP nosing * (drawDetails[1] | drawDetails[3])

	IF rail_m = 2 | rail_m = 1 THEN		! Right, Both
		adx = flightWidth
		gosub "right_rail_hotspots"
	ENDIF

	IF rail_m = 1 & bSameRails THEN			! --- SAME RAILING ON BOTH SIDES ---
		MUL2 -1, 1
		adx = 0
		gosub "right_rail_hotspots"
		DEL 1
	ENDIF

	IF rail_m = 3 | rail_m = 1 & NOT(bSameRails) THEN		! Left, Both
		add2 -(b - widthTotalTread) / 2, 0
			! RAIL OFFSET - left
			HOTSPOT2 leftRailFrameThk/2,				(nRisers)*treadDepth+leftRailOvhgTop, RailUnID, leftRailOffset, 1+128 : RailUnID=RailUnID+1
			HOTSPOT2 leftRailFrameThk/2+leftRailOffset,	(nRisers)*treadDepth+leftRailOvhgTop, RailUnID, leftRailOffset, 2 : RailUnID=RailUnID+1
			HOTSPOT2 leftRailFrameThk/2+0.1,			(nRisers)*treadDepth+leftRailOvhgTop, RailUnID, leftRailOffset, 3 : RailUnID=RailUnID+1

			HOTSPOT2 leftRailFrameThk/2,				-xNosing-leftRailOvhgBottom, RailUnID, leftRailOffset, 1+128 : RailUnID=RailUnID+1
			HOTSPOT2 leftRailFrameThk/2+leftRailOffset,	-xNosing-leftRailOvhgBottom, RailUnID, leftRailOffset, 2 : RailUnID=RailUnID+1
			HOTSPOT2 leftRailFrameThk/2+0.1,			-xNosing-leftRailOvhgBottom, RailUnID, leftRailOffset, 3 : RailUnID=RailUnID+1

			! RAIL BOTTOM OVERHANG
			HOTSPOT2 leftRailFrameThk/2+leftRailOffset,		-xNosing,						RailUnID, leftRailOvhgBottom, 1+128 : RailUnID=RailUnID+1
			HOTSPOT2 leftRailFrameThk/2+leftRailOffset,		-xNosing+1,					RailUnID, leftRailOvhgBottom, 3 : RailUnID=RailUnID+1
			HOTSPOT2 leftRailFrameThk/2+leftRailOffset,		-xNosing-leftRailOvhgBottom,	RailUnID, leftRailOvhgBottom, 2 : RailUnID=RailUnID+1

			! RAIL TOP OVERHANG
			HOTSPOT2 leftRailFrameThk/2+leftRailOffset,		treadDepth*(nRisers),				RailUnID, leftRailOvhgTop, 1+128 : RailUnID=RailUnID+1
			HOTSPOT2 leftRailFrameThk/2+leftRailOffset,		treadDepth*(nRisers)-1,						RailUnID, leftRailOvhgTop, 3 : RailUnID=RailUnID+1
			HOTSPOT2 leftRailFrameThk/2+leftRailOffset,		treadDepth*(nRisers)+leftRailOvhgTop,RailUnID, leftRailOvhgTop, 2 : RailUnID=RailUnID+1
		del 1
	ENDIF
endif

del 2

end

"right_rail_hotspots":
	add2 -(b - widthTotalTread) / 2, 0
		! RAIL OFFSET - right
		HOTSPOT2 adx-rightRailFrameThk/2,					(nRisers)*treadDepth+rightRailOvhgTop, RailUnID, rightRailOffset, 1+128 : RailUnID=RailUnID+1
		HOTSPOT2 adx-rightRailFrameThk/2-rightRailOffset,	(nRisers)*treadDepth+rightRailOvhgTop, RailUnID, rightRailOffset, 2 : RailUnID=RailUnID+1
		HOTSPOT2 adx-rightRailFrameThk/2-0.1,				(nRisers)*treadDepth+rightRailOvhgTop, RailUnID, rightRailOffset, 3 : RailUnID=RailUnID+1

		HOTSPOT2 adx-rightRailFrameThk/2,					-xNosing-rightRailOvhgBottom, RailUnID, rightRailOffset, 1+128 : RailUnID=RailUnID+1
		HOTSPOT2 adx-rightRailFrameThk/2-rightRailOffset,	-xNosing-rightRailOvhgBottom, RailUnID, rightRailOffset, 2 : RailUnID=RailUnID+1
		HOTSPOT2 adx-rightRailFrameThk/2-0.1,				-xNosing-rightRailOvhgBottom, RailUnID, rightRailOffset, 3 : RailUnID=RailUnID+1

		! RAIL BOTTOM OVERHANG
		HOTSPOT2 adx-rightRailFrameThk/2-rightRailOffset,-xNosing,					RailUnID, rightRailOvhgBottom, 1+128 : RailUnID=RailUnID+1
		HOTSPOT2 adx-rightRailFrameThk/2-rightRailOffset,-xNosing+1,					RailUnID, rightRailOvhgBottom, 3 : RailUnID=RailUnID+1
		HOTSPOT2 adx-rightRailFrameThk/2-rightRailOffset,-xNosing-rightRailOvhgBottom,RailUnID, rightRailOvhgBottom, 2 : RailUnID=RailUnID+1

		! RAIL TOP OVERHANG
		HOTSPOT2 adx-rightRailFrameThk/2-rightRailOffset,treadDepth*(nRisers),					RailUnID, rightRailOvhgTop, 1+128 : RailUnID=RailUnID+1
		HOTSPOT2 adx-rightRailFrameThk/2-rightRailOffset,treadDepth*(nRisers)-1,						RailUnID, rightRailOvhgTop, 3 : RailUnID=RailUnID+1
		HOTSPOT2 adx-rightRailFrameThk/2-rightRailOffset,treadDepth*(nRisers)+rightRailOvhgTop,	RailUnID, rightRailOvhgTop, 2 : RailUnID=RailUnID+1
	del 1
return

"Start End Symbol":
	DRAWINDEX 45
	fill gs_StartEndFill

	if gs_StartEndFillPen <> 0 then
		temp_FillStatus = 2
	else
		temp_FillStatus = 0
	endif

	add2 0, +xNosing
	IF gs_StartEndStyle_m = 1 THEN		! Style 1
		POLY2_B 2, 1+temp_FillStatus, gs_StartEndFillPen, gs_fill_pen,
		0,-xNosing,901,
		gs_CircleRadius,360,4001
	ENDIF

	IF gs_StartEndStyle_m = 2 THEN		! Style 2
		FOR kk=1 TO 2
			POLY2_B 6, 1+temp_FillStatus, gs_StartEndFillPen, gs_fill_pen,
				0,-xNosing,1,
				0+gs_CircleRadius,-xNosing,1,
				0,-xNosing,901,
				0,90,4001,
				0,-xNosing+gs_CircleRadius,0,
				0,-xNosing,-1

			POLY2_B 6, 1, gs_StartEndFillPen, gs_fill_pen,
				0,-xNosing,1,
				0,-xNosing+gs_CircleRadius,1,
				0,-xNosing,901,
				0,90,4001,
				0-gs_CircleRadius,-xNosing,0,
				0,-xNosing,-1
		ROT2 180
		ADD2 0, 2*xNosing
		NEXT kk
		DEL 4
	ENDIF

	IF gs_StartEndStyle_m = 3 THEN		! Style 3
		LINE2 0+gs_StartWidth,-xNosing-gs_StartHeight,0+gs_StartWidth,-xNosing+gs_StartHeight
		LINE2 0-gs_StartWidth,-xNosing-gs_StartHeight,0-gs_StartWidth,-xNosing+gs_StartHeight
	ENDIF

	! --- Hotspots of StartEnd Symbol
	IF gs_StartEndStyle_m = 1 | gs_StartEndStyle_m = 2 THEN		! Style 1-2
		ADD2 0,-xNosing
			FOR kk=1 to 4
				HOTSPOT2 0, 0,					StartSymbUNID, gs_CircleRadius, 1+128	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 -1, 0,					StartSymbUNID, gs_CircleRadius, 3+128	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_CircleRadius, 0,	StartSymbUNID, gs_CircleRadius,2		:StartSymbUNID=StartSymbUNID+1

				ROT2 90
			NEXT KK
			DEL 4
		DEL 1
	ENDIF

	IF gs_StartEndStyle_m = 3 THEN		! Style 3
		FOR kk=1 to 2
			ADD2 0, -xNosing
				! Symbol Width/2
				HOTSPOT2 0,				-gs_StartHeight, StartSymbUNID, gs_StartWidth, 1+128:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 -1,			-gs_StartHeight, StartSymbUNID, gs_StartWidth, 3	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, -gs_StartHeight, StartSymbUNID, gs_StartWidth, 2	:StartSymbUNID=StartSymbUNID+1

				HOTSPOT2 0,				gs_StartHeight, StartSymbUNID, gs_StartWidth, 1+128	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 -1,			gs_StartHeight, StartSymbUNID, gs_StartWidth, 3		:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, gs_StartHeight, StartSymbUNID, gs_StartWidth,2		:StartSymbUNID=StartSymbUNID+1
			DEL 1

			ADD2 0, -xNosing
				! Symbol Height
				HOTSPOT2 gs_StartWidth, 0,				StartSymbUNID, gs_StartHeight, 1+128:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, -1,				StartSymbUNID, gs_StartHeight, 3	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, gs_StartHeight, StartSymbUNID, gs_StartHeight, 2	:StartSymbUNID=StartSymbUNID+1

				HOTSPOT2 gs_StartWidth, 0,					StartSymbUNID, gs_StartHeight, 1+128:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, 1,					StartSymbUNID, gs_StartHeight, 3	:StartSymbUNID=StartSymbUNID+1
				HOTSPOT2 gs_StartWidth, -gs_StartHeight,	StartSymbUNID, gs_StartHeight, 2	:StartSymbUNID=StartSymbUNID+1
			DEL 1

		MUL2 -1,1
		NEXT kk
		DEL 2
	ENDIF
	del 1

	DRAWINDEX 40
RETURN


"Arrowhead Symbol":
	IF arrow_style_m = 1 | arrow_style_m = 4 | arrow_style_m = 7 THEN
		temp_ArrowDist = widthTotalTread/2
		temp_ArrowHeight = treadDepth
		if not(reverseWalkLine) & (i = 2 | i = 3) & walkingDirUPDN_m <> 5 then temp_ArrowHeight = treadDepth + xNosing
	ENDIF

	IF arrow_style_m = 2 | arrow_style_m = 5 | arrow_style_m = 8 THEN
		temp_ArrowDist = widthTotalTread/4
		temp_ArrowHeight = treadDepth
		if not(reverseWalkLine) & (i = 2 | i = 3) & walkingDirUPDN_m <> 5 then temp_ArrowHeight = treadDepth + xNosing
	ENDIF

	IF arrow_style_m = 3 | arrow_style_m = 6 | arrow_style_m = 9 THEN
		temp_ArrowDist = gs_ArrowHalfWidth
		temp_ArrowHeight = gs_ArrowHeight
	ENDIF

	if arrow_style_m = 1 | arrow_style_m = 2 | arrow_style_m = 3 then
		temp_ArrowMask=0
	else
		temp_ArrowMask=1
	endif

	POLY2_b 4, 1, penFillArrow, gs_fill_pen,
		-temp_ArrowDist,-temp_ArrowHeight, temp_ArrowMask,
		temp_ArrowDist,-temp_ArrowHeight, 1,
		0,0, 1,
		-temp_ArrowDist,-temp_ArrowHeight, -1

	! --- Arrowhead Fill Contour Points Conditions
	IF arrow_style_m = 4 | arrow_style_m = 5 | arrow_style_m = 6 THEN
		temp_1XFill=temp_ArrowDist
		lengthArrowHead = temp_ArrowHeight
	else
		lengthArrowHead = 0
	ENDIF

	IF arrow_style_m = 7 | arrow_style_m = 8 | arrow_style_m = 9 THEN
		temp_1XFill=0
	ENDIF

	if penFillArrow <> 0 then
		IF arrow_style_m <> 1 & arrow_style_m <> 2 & arrow_style_m <> 3 THEN
			fill gs_ArrowFill ! Always 64 (Foreground)
			POLY2_b 4, 2, penFillArrow, gs_fill_pen,
				-temp_1XFill,-temp_ArrowHeight, temp_ArrowMask,
				temp_ArrowDist,-temp_ArrowHeight, 1,
				0,0, 1,
				-temp_1XFill,-temp_ArrowHeight, -1
		ENDIF
	endif

	HOTSPOT2	0,0,	ArrowUNID: ArrowUNID=ArrowUNID+1

	! --- Hotspot editing of Height & Width of Arrowhead
	IF arrow_style_m = 3 | arrow_style_m = 6 | arrow_style_m = 9 THEN
		HOTSPOT2 gs_ArrowHalfWidth,0,				ArrowUNID, gs_ArrowHeight, 1+128	: ArrowUNID=ArrowUNID+1
		HOTSPOT2 gs_ArrowHalfWidth,-gs_ArrowHeight,	ArrowUNID, gs_ArrowHeight, 2		: ArrowUNID=ArrowUNID+1
		HOTSPOT2 gs_ArrowHalfWidth,1,				ArrowUNID, gs_ArrowHeight, 3		: ArrowUNID=ArrowUNID+1

		HOTSPOT2 -gs_ArrowHalfWidth,0,					ArrowUNID, gs_ArrowHeight, 1+128	: ArrowUNID=ArrowUNID+1
		HOTSPOT2 -gs_ArrowHalfWidth,-gs_ArrowHeight,	ArrowUNID, gs_ArrowHeight, 2		: ArrowUNID=ArrowUNID+1
		HOTSPOT2 -gs_ArrowHalfWidth,1,					ArrowUNID, gs_ArrowHeight, 3		: ArrowUNID=ArrowUNID+1

		HOTSPOT2 0,					-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 1+128	: ArrowUNID=ArrowUNID+1
		HOTSPOT2 gs_ArrowHalfWidth,	-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 2		: ArrowUNID=ArrowUNID+1
		HOTSPOT2 -1,				-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 3		: ArrowUNID=ArrowUNID+1

		HOTSPOT2 0,					-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 1+128 : ArrowUNID=ArrowUNID+1
		HOTSPOT2 -gs_ArrowHalfWidth,-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 2		: ArrowUNID=ArrowUNID+1
		HOTSPOT2 1,					-gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 3		: ArrowUNID=ArrowUNID+1
	ENDIF
RETURN


"left rail":

	rot2 90
	add2 0, 0

	if bShowRailOn1stRun then
		ADD2 -leftRailOvhgBottom-nosing*0, -leftRailOffset-leftRailFrameThk/2

		lraSimple=a+leftRailOvhgBottom+leftRailOvhgTop
		lraComplex=a-treadDepth
		additionXComplex=leftRailOvhgBottom+treadDepth/2
		additionZComplex=leftRailOvhgBottom*tan(ang)
		hrovL=treadDepth/2+leftRailOvhgBottom
		hrovR=treadDepth/2+leftRailOvhgTop
		IF leftRailType_m = 10 THEN	! Rail Post with Bars
			postNumber=max(2,(a-treadDepth)/(3*treadDepth))
		else
			postNumber=(a+leftRailOvhgBottom+leftRailOvhgTop)/(3*treadDepth)+1
		endif
		side = SIDE_LEFT
		gosub "callRailsForStair"

		DEL 1
	endif

	del 2

return


"right rail":

	rot2 90
	add2 0, -flightWidth

	if bShowRailOn1stRun then
		ADD2 -rightRailOvhgBottom-nosing*0,	rightRailOffset+rightRailFrameThk/2

		lraSimple=a+rightRailOvhgBottom+rightRailOvhgTop
		lraComplex=a-treadDepth
		additionXComplex=rightRailOvhgBottom+treadDepth/2
		additionZComplex=rightRailOvhgBottom*tan(ang)
		hrovL=treadDepth/2+rightRailOvhgBottom
		hrovR=treadDepth/2+rightRailOvhgTop
		IF rightRailType_m = 10 THEN	! Rail Post with Bars
			postNumber=max(2,(a-treadDepth)/(3*treadDepth))
		else
			postNumber=(a+rightRailOvhgBottom+rightRailOvhgTop)/(3*treadDepth)+1
		endif
		side = SIDE_RIGHT
		gosub "callRailsForStair"

		DEL 1
	endif

	del 2

return


"callRailsForStair":
! ------------------------------------------------------------------------------
!	lraSimple
!	lraComplex
!	additionXComplex
!	additionZComplex
!	hrovL: rail overhang start
!	hrovR: rail overhang end
!	postNumber:   number of posts
!	side: SIDE_LEFT or SIDE_RIGHT
! ==============================================================================
	ani = ang
	additionXComplex = additionXComplex
	additionZComplex = additionZComplex
	if side = SIDE_LEFT then
		dsComplex = leftRailDist+treadDepth/2*tan(ang)
	else
		dsComplex = rightRailDist+treadDepth/2*tan(ang)
	endif

	gosub "callRails"
return


! ==============================================================================
"callRails":
! ------------------------------------------------------------------------------
!	ani
!	additionXComplex
!	additionZComplex
!	dsComplex
!  ------------------
!	side: SIDE_LEFT or SIDE_RIGHT
!	lraSimple
!	lraComplex
!	hrovL: rail overhang start
!	hrovR: rail overhang end
!	postNumber:   number of posts
! ==============================================================================
	if side = SIDE_LEFT then
		railBarDepth		= leftRailBarDepth
		railBarDiam			= railBarDepth
		railHeight			= leftRailHeight
		railBarThk			= leftRailBarThk
		railFrameThk		= leftRailFrameThk
		railDist			= leftRailDist
		railType_m			= leftRailType_m
		railPostSize		= leftRailPostSize
		nBarsRail			= nBarsLeftRail
		if rightRailType_m = RAIL_WIRED then
			railBarThk		= leftRailWireThk
			railBarDepth	= leftRailWireDepth
			railBarDiam		= leftRailWireDiam
		endif
		bComplexRail		= bComplexRailLeft
	else
		railBarDepth		= rightRailBarDepth
		railBarDiam			= railBarDepth
		railHeight			= rightRailHeight
		railBarThk			= rightRailBarThk
		railFrameThk		= rightRailFrameThk
		railDist			= rightRailDist
		railType_m			= rightRailType_m
		railPostSize		= rightRailPostSize
		nBarsRail			= nBarsRightRail
		if rightRailType_m = RAIL_WIRED then
			railBarThk		= rightRailWireThk
			railBarDepth	= rightRailWireDepth
			railBarDiam		= rightRailWireDiam
		endif
		bComplexRail		= bComplexRailRight
	endif

	add2 additionXComplex * bComplexRail, 0
	call "railSymbol2D_m" parameters all	cfs					= 1,
											bEnable2DPosts		= bComplexRail,
											ptyp_m				= 1,
											ani					= ani,
											rom_m				= 1,
											rmm_m				= 1,
											LengthSize			= 0,
											lra					= lraSimple * NOT(bComplexRail) + lraComplex * (bComplexRail),
											hr					= railHeight,
											hrPerp				= railHeight,
											ab					= 0,
											rb					= 0,
											ds					= railDist,
											gs_AngleL			= 90,
											gs_AngleR			= 90,
											iHandRailStyle		= 1,
											handRailDiameter	= railFrameThk,
											handRailWidth		= railFrameThk,
											hroL				= hrovL,
											hroR				= hrovR,
											np					= postNumber,
											pd					= railPostSize,
											pw					= railPostSize,
											pth					= railFrameThk,
											gs_cont_pen			= railPen,
											sa					= 0,
											bBreakRailLine		= bBreakRailLine,
											breakLineAngle		= brLineAngle,
											breakLineDist		= breakLineDist,
											breakLineWidth		= breakLineW,
											bRailAboveBreakLine	= bRailAboveBreakLine,
											bShowRailBelowBrL	= bShowRailPart1,
											bShowRailAboveBrL	= bShowRailPart2,
											bPostNoCalculation	= (railType_m = 9),
											pit_m				= 2,
											dp					= treadDepth
	del 1

	bShowRailPart1			= 0
	bShowRailPart2			= 0

return

"carriage":

	if beamNum = 1 then
		add2 carriageBaseDist / 2 - beamThk / 2 - beamOffsetRight, 0
	else
		add2 carriageBaseDist - beamThk - beamOffsetRight, 0
	endif
	for wb = 1 to beamNum
		if bBreakCarriageLine then
			lengthMod	= -(carriageBaseDist - beamOffsetLeft - beamOffsetRight - beamThk) * tan(brLineAngle) * (wb = 2)
			if bShowCarriagePart1 then
				pen carriagePen
				if aboveStory then
					LINE_TYPE carriageLineType
				else
					if	(drawPart[1] and drawDashed[1]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE carriageLineType
					endif
				endif

				poly2_b 4, 1+2+4+64, gs_fill_pen, gs_back_pen,
					0, 0, 1,
					beamThk, 0, 1,
					beamThk, carrBreakLineDist + beamThk * tan(brLineAngle) / 2 + lengthMod, 1,
					0, carrBreakLineDist - beamThk * tan(brLineAngle) / 2 + lengthMod, 1
			endif

			if bShowCarriagePart2 then
				pen carriagePen
				if aboveStory then
					LINE_TYPE carriageLineType
				else
					if	(drawPart[2] and drawDashed[2]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE carriageLineType
					endif
				endif


				poly2_b 4, 1 + 2 * gs_FillAbove + 4+64, gs_fill_pen, gs_back_pen,
					0, carrBreakLineDist - beamThk * tan(brLineAngle) / 2 + lengthMod + carrBreakLineWidth, 1,
					beamThk, carrBreakLineDist + beamThk * tan(brLineAngle) / 2 + lengthMod + carrBreakLineWidth, 1,
					beamThk, beamLength, 1,
					0, beamLength, 1
			endif
		else
			if aboveStory then
				LINE_TYPE carriageLineType
			else
			pen carriagePen
				if drawPart[3] then
					if (drawDashed[3]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE carriageLineType
					endif
				else
					if	(NOT(bCarrAboveBreakLine) and drawDashed[1]) or\
						((bCarrAboveBreakLine) and drawDashed[2]) then
						LINE_TYPE dash_line
					else
						LINE_TYPE carriageLineType
					endif
				endif
			endif

			poly2_b 4, 1 + 2 * (NOT(bCarrAboveBreakLine) + bCarrAboveBreakLine * gs_FillAbove) + 4+64, gs_fill_pen, gs_back_pen,
				0, 0, 1,
				beamThk, 0, 1,
				beamThk, beamLength, 1,
				0, beamLength, 1
		endif
		add2 -carriageBaseDist + beamThk + beamOffsetLeft + beamOffsetRight, 0
	next wb
	del beamNum + 1

return

