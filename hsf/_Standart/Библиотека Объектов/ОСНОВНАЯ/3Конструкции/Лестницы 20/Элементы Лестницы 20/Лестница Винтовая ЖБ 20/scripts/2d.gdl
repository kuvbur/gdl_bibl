

! ---------- Hotspots ----------[

		!!! FlightUNID=1		!!! 1,100
		!!! RailUNID=1000		!!! 1000,1100,1200,1300,1400,1500
		!!! BreakUNID=2000		!!! NO
		!!! StartSymbUNID=3000	!!! 3000,3100
		!!! ArrowUNID=4000		!!! 4000,4100
		!!! RiseRunUNID=5000	!!! 5000
		!!! UpDownUNID=6000		!!! 6000
		!!! NumUNID=7000		!!! NO

! ---------- Hotspots ----------]

! ==============================================================================
! Settings of 2D Symbol Type
! Stories, where the object is placed on
! ==============================================================================

dim drawPart[3]		! 1 - lower,  2 - upper,  3 - full
dim drawDashed[3]	! 1 - lower,  2 - upper,  3 - full
dim drawSteps[3]	! 1 - lower,  2 - upper,  3 - full
dim drawDetails[3]	! 1 - lower,  2 - upper,  3 - full
dim drawNum[3]		! 1 - lower,  2 - upper,  3 - full

drawPart[1] 	= 0	! Lower
drawPart[2] 	= 0	! Upper
drawPart[3] 	= 0	! Full
drawDashed[1] 	= 0	! Lower
drawDashed[2] 	= 0	! Upper
drawDashed[3] 	= 0	! Full
drawSteps[1] 	= 0	! Lower
drawSteps[2] 	= 0	! Upper
drawSteps[3] 	= 0	! Full
drawDetails[1] 	= 0	! Lower
drawDetails[2] 	= 0	! Upper
drawDetails[3]	= 0	! Full
drawNum[1] 		= 0	! Lower
drawNum[2] 		= 0	! Upper
drawNum[3]		= 0	! Full

! ---------- Story Sensitive ----------[

abovestory = 0
belowstory = 0
homeStory = 0
if gs_StorySensitive then
	if GLOB_CH_STORY_DIST > EPS  then
		abovestory = 1
	else
		if GLOB_CH_STORY_DIST < -EPS  then
			belowstory = 1
		endif
	endif
endif
if not(abovestory) & not(belowstory) then homeStory = 1

bCarriageLineExist		= bShowCarriage and bEnableCarriageLine and (GLOB_SCALE <= iShowCarriageUpTo | iShowCarriageUpTo = 1)

! ---------- Story Sensitive ----------]

_iSymbolType = 1
if gs_detlevel_2D_m = DET2D_SCALESENSITIVE then
	if GLOB_SCALE <= _iScaleMD then									!! Detailed Scale
		_iSymbolType = iEnabledSymbolTypes[iSymbolGroup][3]
	else
		if GLOB_SCALE > _iScaleMD & GLOB_SCALE <= _iScaleSM then	!! Middle Scale
			_iSymbolType = iEnabledSymbolTypes[iSymbolGroup][2]
		else														!! Simple Scale
			_iSymbolType = iEnabledSymbolTypes[iSymbolGroup][1]
		endif
	endif
else
	_iSymbolType = gs_SymbolType_m
endif

if _iSymbolType = 1 then
	drawPart[3]		= 1		! Full
	drawDashed[3] 	= 1		! Full
	! Railing
	rail_m = RAILPOS_NONE
endif

if _iSymbolType = 2 then
	drawPart[3]	= 1		! Full
	! Railing
	rail_m = RAILPOS_NONE
ENDIF

if _iSymbolType = 3 then
	drawPart[1]	= 1
	! Railing
	rail_m = RAILPOS_NONE
ENDIF

if _iSymbolType = 4 then
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	! Railing
	rail_m = RAILPOS_NONE
ENDIF

if _iSymbolType = 5 then
	drawPart[1]	= 1	! Lower
	drawPart[2]	= 1	! Upper
	! Railing
	rail_m = RAILPOS_NONE
ENDIF

if _iSymbolType = 6 then
	drawPart[3]	= 1		! Full
	drawDashed[3] = 1	! Full
	drawSteps[3] = 1	! Full
	! Railing
	rail_m = RAILPOS_NONE
ENDIF

if _iSymbolType = 7 then
	drawPart[3]	= 1		! Full
	drawSteps[3] = 1	! Full
	! Railing
	rail_m = RAILPOS_NONE
ENDIF

if _iSymbolType = 8 then
	drawPart[1]	= 1		! Lower
	drawSteps[1] = 1	! Lower
	! Railing
	rail_m = RAILPOS_NONE
ENDIF

if _iSymbolType = 9 then
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	! Railing
	rail_m = RAILPOS_NONE
ENDIF

if _iSymbolType = 10 then
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
	! Railing
	rail_m = RAILPOS_NONE
ENDIF

if _iSymbolType = 11 then
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	! Railing
	rail_m = RAILPOS_NONE
ENDIF

if _iSymbolType = 12 then
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	! Railing
	rail_m = RAILPOS_NONE
ENDIF

if _iSymbolType = 13 then
	drawPart[3]	= 1		! Full
	drawDashed[3] = 1	! Full
	drawSteps[3] = 1	! Full
	drawDetails[3] = 1	! Full
ENDIF

if _iSymbolType = 14 then
	drawPart[3]	= 1		! Full
	drawSteps[3] = 1	! Full
	drawDetails[3] = 1	! Full
ENDIF

if _iSymbolType = 15 then
	drawPart[1]	= 1		! Lower
	drawSteps[1] = 1	! Lower
	drawDetails[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
endif

if _iSymbolType = 16 then
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawDetails[1] = 1	! Lower
ENDIF

if _iSymbolType = 17 then
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
	drawDetails[1] = 1	! Lower
ENDIF

if _iSymbolType = 18 then
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawDetails[1] = 1	! Lower
	drawDetails[2] = 1	! Upper
ENDIF

if _iSymbolType = 19 then
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawDetails[1] = 1	! Lower
ENDIF

if _iSymbolType = 20 then
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawDetails[1] = 1	! Lower
	drawDetails[2] = 1	! Upper
endif

! Numbering
if bShowNumbering then
	drawNum[1]		= drawPart[1] & (not(drawPart[2]) | (drawPart[2] & gs_NumBelow))
	drawNum[2]		= drawPart[2] & (not(drawPart[1]) | (drawPart[1] & gs_NumAbove))
	drawNum[3]		= drawPart[3]
endif

! Nosing
if not(covery) & ( not(cover) | ABS(ns) < EPS) then
	drawDetails[1] = 0
	drawDetails[2] = 0
	drawDetails[3] = 0
endif

! Buggy !!!!!!!!!!!!!!!!!!!!!!!!!!
if not(drawDetails[1]) & not(drawDetails[2]) & not(drawDetails[3]) then
	cover = 0		! Tread Cover
	covery = 0		! Riser Cover
	ns = 0			! Nosing Length
	covthicky = 0	! Riser Thickness
endif
! Buggy !!!!!!!!!!!!!!!!!!!!!!!!!!

! ---------- Stories below the home story ---------- [

if belowstory then
	drawPart[1]		= 0
	drawPart[2]		= 0
	drawPart[3]		= 1

	drawDashed[1]		= 0
	drawDashed[2]		= 0
	drawDashed[3]		= 1

	drawSteps[1] = 0
	drawSteps[2] = 0
	drawSteps[3] = 0

	drawDetails[1] = 0
	drawDetails[2] = 0
	drawDetails[3] = 0

	drawNum[1] = 0
	drawNum[2] = 0
	drawNum[3] = 0

	walkl			= 0
	gs_fill_type	= 65
	gs_back_pen		= 0
	rail_m = RAILPOS_NONE
	bShowRiseAndRunText				= 0

endif

! ---------- Stories above the home story ---------- [
if aboveStory then
	drawPart[1] = 0
	drawPart[2] = 0
	drawPart[3] = 0

	if gs_TreadStUp then
		drawSteps[1] = 1
		drawSteps[2] = 1
		drawSteps[3] = 1

		if drawDetails[1] | drawDetails[3] then
			drawDetails[1] = 1
			drawDetails[2] = 1
			drawDetails[3] = 1
		endif

	else
		drawSteps[1] = 0
		drawSteps[2] = 0
		drawSteps[3] = 0

		drawDetails[1] = 0
		drawDetails[2] = 0
		drawDetails[3] = 0
	endif

	if gs_BreaklineStUp = 0 then
		drawPart[3] = 1
	else
		if gs_LowerPartStUp then
			drawPart[1] = 1
		endif
		if gs_UpperPartStUp then
			drawPart[2] = 1
		endif
	endif

	if gs_numaStUp then
		drawNum[1]		= drawPart[1] & (not(drawPart[2]) | drawPart[2])
		drawNum[2]		= drawPart[2] & (not(drawPart[1]) | drawPart[1])
		drawNum[3]		= drawPart[3]
	else
		drawNum[1] = 0
		drawNum[2] = 0
		drawNum[3] = 0
	endif

	if gs_txStUp then
		bShowRiseAndRunText = 1
	else
		bShowRiseAndRunText = 0
	endif

endif


	! Arrow Size
		IF td> 0.26 THEN
		ArrowDist=0.2
		ELSE
		ArrowDist=td*SIN(45)
		ENDIF


	PEN gs_cont_pen
	FILL gs_fill_type

	IF rnu*fokszog <= 360 | \
		(_iSymbolType = 3 & drawPart[1] & not(drawPart[2]) ) | \
		(_iSymbolType = 8 & drawPart[1] & not(drawPart[2]) ) | \
		(_iSymbolType = 15 & drawPart[1] & not(drawPart[2]) ) THEN

		IF iFirstTread = FIRSTTREAD_ABOVE_FLOOR_LEVEL THEN
			fsz=fokszog
			temp_wldofsz=0
		ELSE
			fsz=0
			temp_wldofsz=fokszog
		ENDIF

		! Number of Steps
		temp_rnu=rnu
		IF iFirstTread = FIRSTTREAD_AT_FLOOR_LEVEL AND iTopTread = TOPTREAD_BELOW_FLOOR_LEVEL THEN temp_rnu=rnu-1
		IF iFirstTread = FIRSTTREAD_ABOVE_FLOOR_LEVEL AND iTopTread = TOPTREAD_AT_FLOOR_LEVEL THEN temp_rnu=rnu-1
		IF iFirstTread = FIRSTTREAD_ABOVE_FLOOR_LEVEL AND iTopTread = TOPTREAD_BELOW_FLOOR_LEVEL THEN temp_rnu=rnu-2
		temp_wldornu=temp_rnu
		IF iTopTread = TOPTREAD_AT_FLOOR_LEVEL THEN temp_wldornu=temp_rnu-1

		FlightUNID=1

		! Bottom Step/Right
		HOTSPOT2 0,0, FlightUNID, r,1 : FlightUNID=FlightUNID+1
		HOTSPOT2 -r*COS(fsz),-r*SIN(fsz), FlightUNID, r,3 : FlightUNID=FlightUNID+1
		HOTSPOT2 r*COS(fsz),r*SIN(fsz), FlightUNID, r,2 : FlightUNID=FlightUNID+1

		! Bottom Step/Left
		HOTSPOT2 (r)*COS(fsz),(r)*SIN(fsz), FlightUNID, flw,1 : FlightUNID=FlightUNID+1
		HOTSPOT2 (r+1)*COS(fsz),(r+1)*SIN(fsz), FlightUNID, flw,3 : FlightUNID=FlightUNID+1
		HOTSPOT2 (r-flw)*COS(fsz),(r-flw)*SIN(fsz), FlightUNID, flw,2 : FlightUNID=FlightUNID+1

		! Top Step/Right
		ROT2 (temp_rnu)*fokszog
			HOTSPOT2 0,0, FlightUNID, r,1 : FlightUNID=FlightUNID+1
			HOTSPOT2 -r*COS(fsz),-r*SIN(fsz), FlightUNID, r,3 : FlightUNID=FlightUNID+1
			HOTSPOT2 r*COS(fsz),r*SIN(fsz), FlightUNID, r,2 : FlightUNID=FlightUNID+1
		DEL 1

		! Top Step/Left
		ROT2 (temp_rnu)*fokszog
			HOTSPOT2 (r)*COS(fsz),(r)*SIN(fsz), FlightUNID, flw,1 : FlightUNID=FlightUNID+1
			HOTSPOT2 (r+1)*COS(fsz),(r+1)*SIN(fsz), FlightUNID, flw,3 : FlightUNID=FlightUNID+1
			HOTSPOT2 (r-flw)*COS(fsz),(r-flw)*SIN(fsz), FlightUNID, flw,2 : FlightUNID=FlightUNID+1
		DEL 1

		! Walking Line at Bottom Step
		ROT2 temp_wldofsz
			HOTSPOT2 0,0, FlightUNID, wldo,1 : FlightUNID=FlightUNID+1
			HOTSPOT2 -wldo*COS(fsz),-wldo*SIN(fsz), FlightUNID, wldo,3 : FlightUNID=FlightUNID+1
			HOTSPOT2 wldo*COS(fsz),wldo*SIN(fsz), FlightUNID, wldo,2 : FlightUNID=FlightUNID+1
		DEL 1

		! Walking Line at Top Step
		ROT2 (temp_wldornu)*fokszog
			HOTSPOT2 0,0, FlightUNID, wldo,1 : FlightUNID=FlightUNID+1
			HOTSPOT2 -wldo*COS(fsz),-wldo*SIN(fsz), FlightUNID, wldo,3 : FlightUNID=FlightUNID+1
			HOTSPOT2 wldo*COS(fsz),wldo*SIN(fsz), FlightUNID, wldo,2 : FlightUNID=FlightUNID+1
		DEL 1

	ELSE
		fsz=fokszog
		IF iTopTread = TOPTREAD_AT_FLOOR_LEVEL THEN temp_rnu360=rnu-1
		IF iTopTread = TOPTREAD_BELOW_FLOOR_LEVEL THEN temp_rnu360=rnu-2

		FlightUNID=100

		! Bottom Step/Right
		HOTSPOT2 0,0, FlightUNID, r,1 : FlightUNID=FlightUNID+1
		HOTSPOT2 -r*COS(fsz),-r*SIN(fsz), FlightUNID, r,3 : FlightUNID=FlightUNID+1
		HOTSPOT2 r*COS(fsz),r*SIN(fsz), FlightUNID, r,2 : FlightUNID=FlightUNID+1

		! Bottom Step/Left
		HOTSPOT2 (r)*COS(fsz),(r)*SIN(fsz), FlightUNID, flw,1 : FlightUNID=FlightUNID+1
		HOTSPOT2 (r+1)*COS(fsz),(r+1)*SIN(fsz), FlightUNID, flw,3 : FlightUNID=FlightUNID+1
		HOTSPOT2 (r-flw)*COS(fsz),(r-flw)*SIN(fsz), FlightUNID, flw,2 : FlightUNID=FlightUNID+1

		! Top Step/Right
		ROT2 (temp_rnu360)*fokszog
			HOTSPOT2 0,0, FlightUNID, r,1 : FlightUNID=FlightUNID+1
			HOTSPOT2 -r*COS(fsz),-r*SIN(fsz), FlightUNID, r,3 : FlightUNID=FlightUNID+1
			HOTSPOT2 r*COS(fsz),r*SIN(fsz), FlightUNID, r,2 : FlightUNID=FlightUNID+1

!			SET LINE_TYPE solid_line
!			LINE2 r*COS(fsz),r*SIN(fsz),(r-flw)*COS(fsz),(r-flw)*SIN(fsz)
		DEL 1

		! Top Step/Left
		ROT2 (temp_rnu360)*fokszog
			HOTSPOT2 (r)*COS(fsz),(r)*SIN(fsz), FlightUNID, flw,1 : FlightUNID=FlightUNID+1
			HOTSPOT2 (r+1)*COS(fsz),(r+1)*SIN(fsz), FlightUNID, flw,3 : FlightUNID=FlightUNID+1
			HOTSPOT2 (r-flw)*COS(fsz),(r-flw)*SIN(fsz), FlightUNID, flw,2 : FlightUNID=FlightUNID+1
		DEL 1

		! Walking Line at Bottom Step
		ROT2 fokszog
			HOTSPOT2 0,0, FlightUNID, wldo,1 : FlightUNID=FlightUNID+1
			HOTSPOT2 -1,0, FlightUNID, wldo,3 : FlightUNID=FlightUNID+1
			HOTSPOT2 wldo,0, FlightUNID, wldo,2 : FlightUNID=FlightUNID+1
		DEL 1

	ENDIF


	! ------------------------------------------------------------------------------
	! Nosing Length
	! ------------------------------------------------------------------------------

	Nosing = ns * cover + covthicky * covery
	! cover		! Tread Cover
	! covery	! Riser Cover
	! ns		! Nosing Length
	! covthicky	! Riser Thickness

	! ------------------------------------------------------------------------------
	! BREAK LINE Position
	! ------------------------------------------------------------------------------

	IF iFirstTread = FIRSTTREAD_ABOVE_FLOOR_LEVEL AND rnu*fokszog <= 360 THEN
		numSteptoBreakRight=INT(gs_BreakHeight/th) 	!!! Num. of Steps on Right Side
		i1ZZYZX=INT(ZZYZX/th)		!!! Num. of Steps if value of ZZYZX is less than BREAK LINE
		ELSE
		numSteptoBreakRight=INT(gs_BreakHeight/th)+1 !!! Num. of Steps on Right Side
		i1ZZYZX=INT(ZZYZX/th)+1		!!! Num. of Steps if value of ZZYZX is less than BREAK LINE
	ENDIF
	numSteptoBreakLeft=numSteptoBreakRight+1						!!! Num. of Steps on Left Side

	BreakNum=INT(gs_BreakHeight/th)

	if ZZYZX <= (BreakNum)*th & not(drawPart[3]) then
		drawPart[3] = 1		! IF value of ZZYZX is less than BREAK LINE
		drawPart[1] = 0
		drawPart[2] = 0

		drawSteps[3] = drawSteps[1]		! IF value of ZZYZX is less than BREAK LINE
		drawSteps[1] = 0
		drawSteps[2] = 0

		drawDetails[3] = drawDetails[1]		! IF value of ZZYZX is less than BREAK LINE
		drawDetails[1] = 0
		drawDetails[2] = 0

		drawNum[3] = drawNum[1]	| (aboveStory & not(drawPart[1]) & drawNum[2])	! IF value of ZZYZX is less than BREAK LINE
		drawNum[1] = 0
		drawNum[2] = 0
	endif

	! ------------------------------------------------------------------------------
	! Stair Slab Contour And Fill
	! ------------------------------------------------------------------------------

	! Fill above Break Line
	IF gs_FillAbove=1 THEN
		FullFill=2+64
		temp_FillTypeAbove=gs_fill_type
		temp_BackPen=gs_back_pen
	ELSE
		FullFill=0
		temp_FillTypeAbove=gs_FillTypeAbove	! because of Area Fill Selection
		temp_BackPen=0						! because of Area Fill Selection
	ENDIF

	! Nosing Values
	! Angle
	NosingOuterAngle=360*(Nosing)/(2*r*pi)
	NosingInnerAngle=360*(Nosing)/(2*(r-flw)*pi)

	! Nosing Coordinates at First Step
	NosingInnerY=(r-flw)*SIN(NosingInnerAngle)
	IF NosingInnerAngle = 0 THEN
		NosingInnerX=0
		ELSE
		NosingInnerX=NosingInnerY/TAN(NosingInnerAngle)
	ENDIF
	NosingOuterY=(r)*SIN(NosingOuterAngle)
	IF NosingOuterAngle = 0 THEN
		NosingOuterX=0
		ELSE
		NosingOuterX=NosingOuterY/TAN(NosingOuterAngle)
	ENDIF


	! ==========================================================================
	! Stair Slab Contour
	! ==========================================================================

	DRAWINDEX 10


	! --------------------------------------------------------------------------
	! ANGLE <= 360
	! --------------------------------------------------------------------------
	IF rnu*fokszog <= 360 | \
		(_iSymbolType = 3 & drawPart[1] & not(drawPart[2]) ) | \
		(_iSymbolType = 8 & drawPart[1] & not(drawPart[2]) ) | \
		(_iSymbolType = 15 & drawPart[1] & not(drawPart[2]) ) THEN

			IF iFirstTread = FIRSTTREAD_ABOVE_FLOOR_LEVEL THEN ROT2 fokszog

			IF iFirstTread = FIRSTTREAD_ABOVE_FLOOR_LEVEL THEN rnu=rnu-1
			IF iTopTread = TOPTREAD_BELOW_FLOOR_LEVEL THEN rnu=rnu-1


			PEN gs_cont_pen
			FILL gs_fill_type

			! Stair Slab FILL
			IF drawPart[3] THEN

					if aboveStory then
						PEN gs_LinePenStUp
						LINE_TYPE gs_LineTypeStUp
					else
						if drawDashed[3] then
							PEN gs_DashLinePen
							LINE_TYPE dash_line
						else
							PEN gs_cont_pen
							LINE_TYPE solid_line
						endif
					endif
					POLY2_b 9, 1+2+64, gs_fill_pen, gs_back_pen,
						r-flw,0,1,
						0,0,900,
						0,rnu*fokszog, 4000,
						(r-flw)*COS(rnu*fokszog),(r-flw)*SIN(rnu*fokszog),0,
						(r)*COS(rnu*fokszog),(r)*SIN(rnu*fokszog),1,
						0,0,900,
						0,-rnu*fokszog,4000,
						r,0,0,
						r-flw,0,-1

					IF not(drawDetails[3]) THEN
						LINE2 r-flw,0,r,0
						LINE2 (r-flw)*COS(rnu*fokszog),(r-flw)*SIN(rnu*fokszog),(r)*COS(rnu*fokszog),(r)*SIN(rnu*fokszog)
					ENDIF

					HOTLINE2 r-flw,0,r,0
					HOTLINE2 (r-flw)*COS(rnu*fokszog),(r-flw)*SIN(rnu*fokszog),(r)*COS(rnu*fokszog),(r)*SIN(rnu*fokszog)

			ELSE

				IF drawPart[1] THEN
					if aboveStory then
						PEN gs_LinePenStUp
						LINE_TYPE gs_LineTypeStUp
					else
						if drawDashed[1] then
							PEN gs_DashLinePen
							LINE_TYPE dash_line
						else
							PEN gs_cont_pen
							LINE_TYPE solid_line
						endif
					endif
					POLY2_b 7, 1+2+64, gs_fill_pen, gs_back_pen,
						r-flw,0,1,
						0,0,900,
						0,numSteptoBreakRight*fokszog, 4000,
						r*COS(numSteptoBreakRight*fokszog), r*SIN(numSteptoBreakRight*fokszog),1,
						0,0,900,
						0,-numSteptoBreakRight*fokszog,4000,
						r-flw,0,-1

					IF not(drawSteps[1]) THEN LINE2 (r-flw)*COS(numSteptoBreakRight*fokszog), (r-flw)*SIN(numSteptoBreakRight*fokszog),r*COS(numSteptoBreakRight*fokszog), r*SIN(numSteptoBreakRight*fokszog)
					IF not(drawDetails[1]) THEN LINE2 r-flw,0,r,0  !!Type<13 Line at Bottom Step
					HOTLINE2 r-flw,0,r,0
					HOTLINE2 (r-flw)*COS(numSteptoBreakRight*fokszog),(r-flw)*SIN(numSteptoBreakRight*fokszog),(r)*COS(numSteptoBreakRight*fokszog),(r)*SIN(numSteptoBreakRight*fokszog)
				ENDIF

				IF drawPart[2] THEN

						if aboveStory then
							PEN gs_LinePenStUp
							LINE_TYPE gs_LineTypeStUp
						else
							if drawDashed[2] then
								PEN gs_DashLinePen
								LINE_TYPE dash_line
							else
								PEN gs_cont_pen
								LINE_TYPE solid_line
							endif
						endif

						FILL temp_FillTypeAbove

						POLY2_b 9, 1+FullFill+64, gs_fill_pen, temp_BackPen,
							(r-flw)*COS(numSteptoBreakRight*fokszog), (r-flw)*SIN(numSteptoBreakRight*fokszog),1,
							0,0,900,
							0,(rnu-numSteptoBreakRight)*fokszog, 4000,
							(r-flw)*COS(rnu*fokszog),(r-flw)*SIN(rnu*fokszog),1,
							(r)*COS(rnu*fokszog),(r)*SIN(rnu*fokszog),1,
							0,0,900,
							0,-(rnu-numSteptoBreakRight)*fokszog,4000,
							(r)*COS(numSteptoBreakRight*fokszog), (r)*SIN(numSteptoBreakRight*fokszog),0,
							(r-flw)*COS(numSteptoBreakRight*fokszog), (r-flw)*SIN(numSteptoBreakRight*fokszog),-1

						IF not(drawDetails[2]) THEN LINE2 (r-flw)*COS(rnu*fokszog),(r-flw)*SIN(rnu*fokszog),(r)*COS(rnu*fokszog),(r)*SIN(rnu*fokszog)
						HOTLINE2 (r-flw)*COS(rnu*fokszog),(r-flw)*SIN(rnu*fokszog),(r)*COS(rnu*fokszog),(r)*SIN(rnu*fokszog)

						IF not(drawPart[1]) then LINE2 (r-flw)*COS(numSteptoBreakRight*fokszog), (r-flw)*SIN(numSteptoBreakRight*fokszog),r*COS(numSteptoBreakRight*fokszog), r*SIN(numSteptoBreakRight*fokszog)

					FILL gs_fill_type
				ENDIF

			ENDIF

			! Nosing
			IF (drawPart[1] & drawDetails[1]) | (drawPart[3] & drawDetails[3]) THEN

				if aboveStory then
					PEN gs_LinePenStUp
					LINE_TYPE gs_LineTypeStUp
				else
					if drawDashed[1] | drawDashed[3] then
						PEN gs_DashLinePen
						LINE_TYPE dash_line
					else
						PEN gs_cont_pen
						LINE_TYPE solid_line
					endif
				endif
				POLY2_b 7, 1+2+64, gs_fill_pen, gs_back_pen,
					r-flw,0,1,
					0,0,900,
					0,-NosingInnerAngle, 4000,
					(r)*COS(NosingOuterAngle),-(r)*SIN(NosingOuterAngle),1,
					0,0,900,
					0,NosingOuterAngle,4000,
					r-flw,0,-1
			ENDIF

			endp=rnu

		! CONTOUR HOTLINE

		IF drawPart[2] THEN
			HOTARC2 0,0,(r-flw),0,rnu*fokszog
			HOTARC2 0,0,r,0,rnu*fokszog
			ELSE
			HOTARC2 0,0,(r-flw),0,numSteptoBreakRight*fokszog
			HOTARC2 0,0,r,0,numSteptoBreakRight*fokszog
		ENDIF

		IF iFirstTread = FIRSTTREAD_ABOVE_FLOOR_LEVEL THEN DEL 1

	! --------------------------------------------------------------------------
	! ANGLE > 360
	! --------------------------------------------------------------------------
	ELSE	! IF 2D Symbol is a Circle


		PEN gs_cont_pen
		FILL gs_fill_type

		IF drawPart[3] THEN

			if aboveStory then
				PEN gs_LinePenStUp
				LINE_TYPE gs_LineTypeStUp
			else
				if drawDashed[3] then
					PEN gs_DashLinePen
					LINE_TYPE dash_line
				else
					PEN gs_cont_pen
					LINE_TYPE solid_line
				endif
			endif
			!!! rnu*fokszog > 360 THEN
			POLY2_b 3, 1+2+64, gs_fill_pen, gs_back_pen,
				0,0,900,
				r,360,4001,
				r-flw,360,4079
			LINE2 (r-flw)*COS(fokszog),(r-flw)*SIN(fokszog),(r)*COS(fokszog),(r)*SIN(fokszog)

		ELSE

			IF drawPart[1] THEN
				if aboveStory then
					PEN gs_LinePenStUp
					LINE_TYPE gs_LineTypeStUp
				else
					if drawDashed[1] then
						PEN gs_DashLinePen
						LINE_TYPE dash_line
					else
						PEN gs_cont_pen
						LINE_TYPE solid_line
					endif
				endif

				FILL gs_fill_type

				POLY2_b 9, 1+2+64, gs_fill_pen, gs_back_pen,
					(r-flw)*COS(fokszog),(r-flw)*SIN(fokszog),1,
					0,0,900,
					0,(numSteptoBreakRight-1)*fokszog, 4000,
					(r-flw)*COS(numSteptoBreakRight*fokszog), (r-flw)*SIN(numSteptoBreakRight*fokszog),0,
					r*COS(numSteptoBreakRight*fokszog), r*SIN(numSteptoBreakRight*fokszog),1,
					0,0,900,
					0,-(numSteptoBreakRight-1)*fokszog,4000,
					(r)*COS(fokszog),(r)*SIN(fokszog),0,
					(r-flw)*COS(fokszog),(r-flw)*SIN(fokszog),-1

				IF not(drawSteps[1]) THEN
					LINE2 (r-flw)*COS(fokszog),(r-flw)*SIN(fokszog),(r)*COS(fokszog),(r)*SIN(fokszog)
					LINE2 (r-flw)*COS(numSteptoBreakRight*fokszog), (r-flw)*SIN(numSteptoBreakRight*fokszog),r*COS(numSteptoBreakRight*fokszog), r*SIN(numSteptoBreakRight*fokszog)
				ENDIF
			ENDIF

			IF drawPart[2] THEN
				if aboveStory then
					PEN gs_LinePenStUp
					LINE_TYPE gs_LineTypeStUp
				else
					if drawDashed[2] then
						PEN gs_DashLinePen
						LINE_TYPE dash_line
					else
						PEN gs_cont_pen
						LINE_TYPE solid_line
					endif
				endif

				FILL temp_FillTypeAbove

				alphaStart =  fokszog
				alphaBegin =  numSteptoBreakRight * fokszog
				alphaEnd	= rnu * fokszog

				if abs(alphaEnd-alphaBegin) < 360 - eps | drawPart[1] then
					if not(drawPart[1]) then
						alphaUpperPart = alphaEnd - alphaBegin
						alphaClosedLine = alphaEnd
						mask = 1
					else
						alphaUpperPart = 360 - alphaBegin + alphaStart
						alphaClosedLine = fokszog
						mask = 0
					endif

					POLY2_b 9, 1+FullFill+64, gs_fill_pen, temp_BackPen,
						(r-flw)*COS(alphaBegin),(r-flw)*SIN(alphaBegin),	1,
						0,						0,							900,
						0,						alphaUpperPart,				4000,
						(r-flw)*COS(alphaClosedLine),	(r-flw)*SIN(alphaClosedLine),		mask,
						(r)*COS(alphaClosedLine),		(r)*SIN(alphaClosedLine),			1,
						0,						0,							900,
						0,						-alphaUpperPart,			4000,
						(r)*COS(alphaBegin),	(r)*SIN(alphaBegin),		0,
						(r-flw)*COS(alphaBegin),(r-flw)*SIN(alphaBegin),	-1

					if not(drawPart[1]) then line2 (r-flw)*COS(alphaBegin),(r-flw)*SIN(alphaBegin),(r)*COS(alphaBegin),(r)*SIN(alphaBegin)

				else
					POLY2_b 3, 1+FullFill+64, gs_fill_pen, temp_BackPen,
						0,0,900,
						r,360,4001,
						r-flw,360,4079

					if not(drawSteps[2]) then line2 (r-flw)*COS(alphaEnd),(r-flw)*SIN(alphaEnd),(r)*COS(alphaEnd),(r)*SIN(alphaEnd)
				endif
			ENDIF

		ENDIF

		HOTARC2 0,0,(r-flw),0,360
		HOTARC2 0,0,r,0,360
	ENDIF


	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	!!!!!!!!!!!!!!!!!!!!!!!!!! *** T R E A D S *** !!!!!!!!!!!!!!!!!!!!!!!

	IF iNoseType = NOSE_NORMAL THEN cns=Nosing ELSE cns=covthick

	!!!!!!!!!!!!!!!!!!!!!! *** ANGLE <= 360 *** !!!!!!!!!!!!!!!!!!!!
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	IF rnu*fokszog <= 360 | \
		(_iSymbolType = 3 & drawPart[1] & not(drawPart[2]) ) | \
		(_iSymbolType = 8 & drawPart[1] & not(drawPart[2]) ) | \
		(_iSymbolType = 15 & drawPart[1] & not(drawPart[2]) ) THEN

	IF iFirstTread = FIRSTTREAD_ABOVE_FLOOR_LEVEL THEN ROT2 fokszog
	IF drawPart[3] THEN

		IF drawSteps[3] THEN

			!!! *** T R E A D S
			if aboveStory then
				PEN gs_LinePenStUp
				LINE_TYPE gs_LineTypeStUp
			else
				if drawDashed[3] then
					PEN gs_DashLinePen
					LINE_TYPE dash_line
				else
					PEN gs_cont_pen
					LINE_TYPE solid_line
				endif
			endif
			FOR i=1 to endp-1
				dx=-(cns)*SIN(-i*fokszog)
				dy=-(cns)*COS(-i*fokszog)

				LINE2 (r-flw)*COS(i*fokszog)+dx, (r-flw)*SIN(i*fokszog)+dy,
					r*COS(i*fokszog)+dx, r*SIN(i*fokszog)+dy

				HOTLINE2 (r-flw)*COS(i*fokszog)+dx, (r-flw)*SIN(i*fokszog)+dy,
					r*COS(i*fokszog)+dx, r*SIN(i*fokszog)+dy
			NEXT i

			!!! *** N O S I N G
			IF drawDetails[3] THEN
				PEN gs_DashLinePen
				LINE_TYPE dash_line

				FOR i=0 to endp
					IF i=endp THEN
						if aboveStory then
							PEN gs_LinePenStUp
							LINE_TYPE gs_LineTypeStUp
						else
							if drawDashed[3] then
								PEN gs_DashLinePen
								LINE_TYPE dash_line
							else
								PEN gs_cont_pen
								LINE_TYPE solid_line
							endif
						endif
					endif

					LINE2 (r-flw)*COS(i*fokszog), (r-flw)*SIN(i*fokszog),
						r*COS(i*fokszog), r*SIN(i*fokszog)

				NEXT i
			ENDIF
		ENDIF

	ELSE

		IF (drawPart[1] & drawSteps[1]) THEN
			!!! *** T R E A D S
			if aboveStory then
				PEN gs_LinePenStUp
				LINE_TYPE gs_LineTypeStUp
			else
				if drawDashed[1] then
					PEN gs_DashLinePen
					LINE_TYPE dash_line
				else
					PEN gs_cont_pen
					LINE_TYPE solid_line
				endif
			endif
			FOR i=1 to numSteptoBreakRight
				dx=-(cns)*SIN(-i*fokszog)
				dy=-(cns)*COS(-i*fokszog)

				LINE2 (r-flw)*COS(i*fokszog)+dx, (r-flw)*SIN(i*fokszog)+dy,
					r*COS(i*fokszog)+dx, r*SIN(i*fokszog)+dy

				HOTLINE2 (r-flw)*COS(i*fokszog)+dx, (r-flw)*SIN(i*fokszog)+dy,
					r*COS(i*fokszog)+dx, r*SIN(i*fokszog)+dy
			NEXT i

			!!! *** N O S I N G
			IF drawDetails[1] THEN
				PEN gs_DashLinePen
				LINE_TYPE dash_line
				FOR i=0 to numSteptoBreakRight

					LINE2 (r-flw)*COS(i*fokszog), (r-flw)*SIN(i*fokszog),
						r*COS(i*fokszog), r*SIN(i*fokszog)

				NEXT i
			ENDIF
		ENDIF

		IF (drawPart[2] & drawSteps[2]) THEN

			!!! *** T R E A D S
			if aboveStory then
				PEN gs_LinePenStUp
				LINE_TYPE gs_LineTypeStUp
			else
				if drawDashed[2] then
					PEN gs_DashLinePen
					LINE_TYPE dash_line
				else
					PEN gs_cont_pen
					LINE_TYPE solid_line
				endif
			endif

			! Buggy !!!!!!!!!!!!
			if _iSymbolType <> 19 then
			! Buggy !!!!!!!!!!!!

				FOR i=numSteptoBreakLeft to endp-1
					dx=-(cns)*SIN(-i*fokszog)
					dy=-(cns)*COS(-i*fokszog)


					LINE2 (r-flw)*COS(i*fokszog)+dx, (r-flw)*SIN(i*fokszog)+dy,
						r*COS(i*fokszog)+dx, r*SIN(i*fokszog)+dy

					HOTLINE2 (r-flw)*COS(i*fokszog)+dx, (r-flw)*SIN(i*fokszog)+dy,
						r*COS(i*fokszog)+dx, r*SIN(i*fokszog)+dy
				NEXT i

			endif

			IF drawDetails[2] | _iSymbolType = 19 THEN
				!!! *** N O S I N G
				FOR i=numSteptoBreakLeft to endp
					PEN gs_DashLinePen
					LINE_TYPE dash_line


					IF i = endp THEN
						if aboveStory then
							PEN gs_LinePenStUp
							LINE_TYPE gs_LineTypeStUp
						else
							if drawDashed[2] then
								PEN gs_DashLinePen
								LINE_TYPE dash_line
							else
								PEN gs_cont_pen
								LINE_TYPE solid_line
							endif
						endif
					endif

					LINE2 (r-flw)*COS(i*fokszog), (r-flw)*SIN(i*fokszog),
						r*COS(i*fokszog), r*SIN(i*fokszog)

				NEXT i
			ENDIF

		ENDIF
	ENDIF
	IF iFirstTread = FIRSTTREAD_ABOVE_FLOOR_LEVEL THEN DEL 1

	!!!!!!!!!!!!!!!!!!!!!! *** ANGLE > 360 *** !!!!!!!!!!!!!!!!!!!!!
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	ELSE	!!! IF 2D Symbol is a Circle

	IF FRA(360/fokszog) >0.5 THEN !!! Last Step
		temp_360End=1
		ELSE
		temp_360End=0
	ENDIF

	IF drawPart[3] THEN

		IF drawSteps[3] THEN
			!!! *** T R E A D S
			if aboveStory then
				PEN gs_LinePenStUp
				LINE_TYPE gs_LineTypeStUp
			else
				if drawDashed[3] then
					PEN gs_DashLinePen
					LINE_TYPE dash_line
				else
					PEN gs_cont_pen
					LINE_TYPE solid_line
				endif
			endif
			FOR i=1 to 360/fokszog+temp_360End
				dx=-(cns)*SIN(-i*fokszog)
				dy=-(cns)*COS(-i*fokszog)

				LINE2 (r-flw)*COS(i*fokszog)+dx, (r-flw)*SIN(i*fokszog)+dy,
					r*COS(i*fokszog)+dx, r*SIN(i*fokszog)+dy

				HOTLINE2 (r-flw)*COS(i*fokszog)+dx, (r-flw)*SIN(i*fokszog)+dy,
					r*COS(i*fokszog)+dx, r*SIN(i*fokszog)+dy
			NEXT i

			!!! *** N O S I N G

			IF drawDetails[3] THEN
				PEN gs_DashLinePen
				LINE_TYPE dash_line
				FOR i=1 to 360/fokszog+temp_360End
					IF i=360/fokszog+temp_360End THEN PEN NosingPen
					IF i=360/fokszog+temp_360End THEN SET LINE_TYPE NosingLine

					LINE2 (r-flw)*COS(i*fokszog), (r-flw)*SIN(i*fokszog),
						r*COS(i*fokszog), r*SIN(i*fokszog)

				NEXT i
			ENDIF
		ENDIF

	ELSE

		IF drawPart[1] & drawSteps[1] THEN

			!!! *** T R E A D S
			if aboveStory then
				PEN gs_LinePenStUp
				LINE_TYPE gs_LineTypeStUp
			else
				if drawDashed[1] then
					PEN gs_DashLinePen
					LINE_TYPE dash_line
				else
					PEN gs_cont_pen
					LINE_TYPE solid_line
				endif
			endif
			FOR i=1 to numSteptoBreakRight
				dx=-(cns)*SIN(-i*fokszog)
				dy=-(cns)*COS(-i*fokszog)

				LINE2 (r-flw)*COS(i*fokszog)+dx, (r-flw)*SIN(i*fokszog)+dy,
					r*COS(i*fokszog)+dx, r*SIN(i*fokszog)+dy

				HOTLINE2 (r-flw)*COS(i*fokszog)+dx, (r-flw)*SIN(i*fokszog)+dy,
					r*COS(i*fokszog)+dx, r*SIN(i*fokszog)+dy
			NEXT i

			!!! *** N O S I N G
			IF drawDetails[1] THEN
				PEN gs_DashLinePen
				LINE_TYPE dash_line
				FOR i=1 to numSteptoBreakRight

					LINE2 (r-flw)*COS(i*fokszog), (r-flw)*SIN(i*fokszog),
						r*COS(i*fokszog), r*SIN(i*fokszog)

				NEXT i
			ENDIF
		ENDIF

		IF drawPart[2] & drawSteps[2] THEN
			! T R E A D S
			if aboveStory then
				PEN gs_LinePenStUp
				LINE_TYPE gs_LineTypeStUp
			else
				if drawDashed[2] then
					PEN gs_DashLinePen
					LINE_TYPE dash_line
				else
					PEN gs_cont_pen
					LINE_TYPE solid_line
				endif
			endif

			alphaStart =  fokszog
			alphaBegin =  numSteptoBreakRight * fokszog
			alphaEnd	= rnu * fokszog

			if abs(alphaEnd-alphaBegin) < 360 - eps | drawPart[1] then
				if not(drawPart[1]) then
					treadBegin = numSteptoBreakRight + 1
					treadEnd = rnu
				else
					treadBegin = numSteptoBreakRight + 1
					treadEnd = 360/fokszog
				endif
			else
				treadBegin = 1
				treadEnd = 360/fokszog
			endif

			! Buggy !!!!!!!!!!!!
			if _iSymbolType <> 19 then
			! Buggy !!!!!!!!!!!!

				FOR i = treadBegin to treadEnd

					dx=-(cns)*SIN(-i*fokszog)
					dy=-(cns)*COS(-i*fokszog)

					LINE2 (r-flw)*COS(i*fokszog)+dx, (r-flw)*SIN(i*fokszog)+dy,
						r*COS(i*fokszog)+dx, r*SIN(i*fokszog)+dy

					HOTLINE2 (r-flw)*COS(i*fokszog)+dx, (r-flw)*SIN(i*fokszog)+dy,
						r*COS(i*fokszog)+dx, r*SIN(i*fokszog)+dy
				NEXT i

			! Buggy !!!!!!!!!!!!
			endif
			! Buggy !!!!!!!!!!!!

			!!! *** N O S I N G

			IF drawDetails[2] | _iSymbolType = 19 THEN
				PEN gs_DashLinePen
				LINE_TYPE dash_line

				FOR i= treadBegin to treadEnd

					LINE2 (r-flw)*COS(i*fokszog), (r-flw)*SIN(i*fokszog),
						r*COS(i*fokszog), r*SIN(i*fokszog)

				NEXT i
			ENDIF

		ENDIF
	ENDIF

	ENDIF


	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	!!!!!!!!*** ARROWHEAD / WALKING LINE / START END SYMBOL*** !!!!!!!!!
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	IF walkl THEN
	DRAWINDEX 40

	IF rnu*fokszog <= 360| \
		(_iSymbolType = 3 & drawPart[1] & not(drawPart[2]) ) | \
		(_iSymbolType = 8 & drawPart[1] & not(drawPart[2]) ) | \
		(_iSymbolType = 15 & drawPart[1] & not(drawPart[2]) ) THEN


		IF iFirstTread = FIRSTTREAD_ABOVE_FLOOR_LEVEL THEN ROT2 fokszog

		!!! Start Point of Walking Lines
		IF iFirstTread = FIRSTTREAD_ABOVE_FLOOR_LEVEL THEN
			temp_fokszog=0
			temp_StartEndFokszog=0
		ELSE
			temp_fokszog=fokszog
			temp_StartEndFokszog=fokszog
		ENDIF

		IF iTopTread = TOPTREAD_BELOW_FLOOR_LEVEL THEN
			temp_endp=endp
		ELSE
			temp_endp=endp-1
		ENDIF

	ELSE
		temp_StartEndFokszog=fokszog
		temp_fokszog=fokszog
		temp_endp=rnu-1

	ENDIF



		!!!!!!!!!!!!!!!!!!!!!! ***	ARROWHEAD *** !!!!!!!!!!!!!!!!!!!!!!!!!!

		ArrowDist=gs_ArrowHalfWidth

		!!! ********** Arrowhead Contour Conditions
		IF arrow_style_m = ARROW_STYLE_1 OR arrow_style_m = ARROW_STYLE_2 OR arrow_style_m = ARROW_STYLE_3 THEN
			temp_ArrowMask=0
		else
			temp_ArrowMask=1
		ENDIF

		!!! ********** Arrowhead Contour Points Conditions
		IF arrow_style_m = ARROW_STYLE_1 OR arrow_style_m = ARROW_STYLE_4 OR arrow_style_m = ARROW_STYLE_7 THEN

			temp_HeadBelowX=(wldo)*COS((numSteptoBreakRight)*fokszog)
			temp_HeadBelowY=(wldo)*SIN((numSteptoBreakRight)*fokszog)
			temp_InnerBelowX=(r-flw)*COS((numSteptoBreakRight-1)*fokszog)
			temp_InnerBelowY=(r-flw)*SIN((numSteptoBreakRight-1)*fokszog)
			temp_OuterBelowX=(r)*COS((numSteptoBreakRight-1)*fokszog)
			temp_OuterBelowY=(r)*SIN((numSteptoBreakRight-1)*fokszog)

			temp_HeadAboveX=(wldo)*COS(INT(temp_endp)*fokszog)
			temp_HeadAboveY=(wldo)*SIN(INT(temp_endp)*fokszog)
			temp_InnerAboveX=(r-flw)*COS((INT(temp_endp)-1)*fokszog)
			temp_InnerAboveY=(r-flw)*SIN((INT(temp_endp)-1)*fokszog)
			temp_OuterAboveX=(r)*COS((INT(temp_endp)-1)*fokszog)
			temp_OuterAboveY=(r)*SIN((INT(temp_endp)-1)*fokszog)
		ENDIF

		IF arrow_style_m = ARROW_STYLE_2 OR arrow_style_m = ARROW_STYLE_5 OR arrow_style_m = ARROW_STYLE_8 THEN

			temp_HeadBelowX=(wldo)*COS((numSteptoBreakRight)*fokszog)
			temp_HeadBelowY=(wldo)*SIN((numSteptoBreakRight)*fokszog)
			temp_InnerBelowX=((wldo+R-flw)/2)*COS((numSteptoBreakRight-1)*fokszog)
			temp_InnerBelowY=((wldo+R-flw)/2)*SIN((numSteptoBreakRight-1)*fokszog)
			temp_OuterBelowX=((wldo+R)/2)*COS((numSteptoBreakRight-1)*fokszog)
			temp_OuterBelowY=((wldo+R)/2)*SIN((numSteptoBreakRight-1)*fokszog)

			temp_HeadAboveX=(wldo)*COS(INT(temp_endp)*fokszog)
			temp_HeadAboveY=(wldo)*SIN(INT(temp_endp)*fokszog)
			temp_InnerAboveX=((wldo+R-flw)/2)*COS((INT(temp_endp)-1)*fokszog)
			temp_InnerAboveY=((wldo+R-flw)/2)*SIN((INT(temp_endp)-1)*fokszog)
			temp_OuterAboveX=((wldo+R)/2)*COS((INT(temp_endp)-1)*fokszog)
			temp_OuterAboveY=((wldo+R)/2)*SIN((INT(temp_endp)-1)*fokszog)
		ENDIF

		IF arrow_style_m = ARROW_STYLE_3 OR arrow_style_m = ARROW_STYLE_6 OR arrow_style_m = ARROW_STYLE_9 THEN

			temp_HeadX=0
			temp_HeadY=0
			temp_InnerX=-ArrowDist
			temp_InnerY=-gs_ArrowHeight
			temp_OuterX=ArrowDist
			temp_OuterY=-gs_ArrowHeight
		ENDIF

		!!! ********** Arrowhead Fill Contour Points Conditions

		IF arrow_style_m = ARROW_STYLE_4 OR arrow_style_m = ARROW_STYLE_5 THEN
			temp_InnerBelowXFill=temp_InnerBelowX
			temp_InnerBelowYFill=temp_InnerBelowY
			temp_InnerAboveXFill=temp_InnerAboveX
			temp_InnerAboveYFill=temp_InnerAboveY
		ENDIF

		IF arrow_style_m = ARROW_STYLE_7 OR arrow_style_m = ARROW_STYLE_8 THEN
			temp_InnerBelowXFill=(wldo)*COS((numSteptoBreakRight-1)*fokszog)
			temp_InnerBelowYFill=(wldo)*SIN((numSteptoBreakRight-1)*fokszog)
			temp_InnerAboveXFill=(wldo)*COS(INT(temp_endp-1)*fokszog)
			temp_InnerAboveYFill=(wldo)*SIN(INT(temp_endp-1)*fokszog)
		ENDIF

		IF arrow_style_m = ARROW_STYLE_6 THEN
			temp_InnerXFill=temp_InnerX
		ENDIF

		IF arrow_style_m = ARROW_STYLE_9 THEN
			temp_InnerXFill=0
		ENDIF


		!!! ********** Arrowhead Symbols/ Contour and Fill

		PEN gs_wLinePen
		Fill gs_ArrowFill

		IF drawPart[3] | drawPart[2] THEN		!!! Above Break Line

			if aboveStory then
				LINE_TYPE gs_wLineTypeStUp
			else
				if drawDashed[3] | drawDashed[2] then
					LINE_TYPE gs_wLineTypeAbove
				else
					LINE_TYPE gs_wLineType1
				endif
			endif

			IF arrow_style_m <> ARROW_STYLE_3 AND arrow_style_m <> ARROW_STYLE_6 AND arrow_style_m <> ARROW_STYLE_9 THEN
			!!! ********* Arrow Style=1,2,4,5,7,8
			!!! ********* Geometry of ArrowHead Contour
				POLY2_b 4, 1, gs_ArrowFillPenAbove, gs_fill_pen,
					temp_HeadAboveX,temp_HeadAboveY, 1,
					temp_InnerAboveX,temp_InnerAboveY, temp_ArrowMask,
					temp_OuterAboveX,temp_OuterAboveY, 1,
					temp_HeadAboveX,temp_HeadAboveY, -1

				IF gs_ArrowFillPenAbove<>0 THEN
					IF arrow_style_m <> ARROW_STYLE_1 AND arrow_style_m <> ARROW_STYLE_2 THEN
						!!! Geometry of ArrowHead Fill
						POLY2_b 4, 1+2, gs_ArrowFillPenAbove, gs_fill_pen,
							temp_HeadAboveX,temp_HeadAboveY, 1,
							temp_InnerAboveXFill,temp_InnerAboveYFill, 0,
							temp_OuterAboveX,temp_OuterAboveY, 0,
							temp_HeadAboveX,temp_HeadAboveY, -1

					ENDIF
				ENDIF
			ELSE


			!!! ********* Arrow Style=3,6,9
			!!! ********* Geometry of ArrowHead Contour


				ROT2 temp_endp*fokszog
				ADD2 wldo,0
				POLY2_b 4, 1, gs_ArrowFillPen, gs_fill_pen,
					temp_HeadX,temp_HeadY, 1,
					temp_InnerX,temp_InnerY, temp_ArrowMask,
					temp_OuterX,temp_OuterY, 1,
					temp_HeadX,temp_HeadY, -1

				IF gs_ArrowFillPenAbove<>0 THEN
					IF arrow_style_m <> ARROW_STYLE_3 THEN
						!! Geometry of ArrowHead Fill
						POLY2_b 4, 1+2, gs_ArrowFillPenAbove, gs_fill_pen,
							temp_HeadX,temp_HeadY, 1,
							temp_InnerXFill,temp_InnerY, 0,
							temp_OuterX,temp_OuterY, 0,
							temp_HeadX,temp_HeadY, -1

					ENDIF
				ENDIF
				DEL 2
			ENDIF
		ENDIF

		IF drawPart[1] THEN		!!! Below Break Line


			if aboveStory then
				LINE_TYPE gs_wLineTypeStUp
			else
				if drawDashed[1] then
					LINE_TYPE gs_wLineTypeAbove
				else
					LINE_TYPE gs_wLineType1
				endif
			endif

			IF arrow_style_m <> ARROW_STYLE_3 AND arrow_style_m <> ARROW_STYLE_6 AND arrow_style_m <> ARROW_STYLE_9 THEN
			!!! ********* Arrow Style=1,2,4,5,7,8
			!!! ********* Geometry of ArrowHead Contour
				POLY2_b 4, 1, gs_ArrowFillPen, gs_fill_pen,
					temp_HeadBelowX,temp_HeadBelowY, 1,
					temp_InnerBelowX,temp_InnerBelowY, temp_ArrowMask,
					temp_OuterBelowX,temp_OuterBelowY, 1,
					temp_HeadBelowX,temp_HeadBelowY, -1

				IF gs_ArrowFillPen<>0 THEN
					IF arrow_style_m <> ARROW_STYLE_1 AND arrow_style_m <> ARROW_STYLE_2 THEN
						!!! Geometry of ArrowHead Fill
						POLY2_b 4, 1+2, gs_ArrowFillPen, gs_fill_pen,
							temp_HeadBelowX,temp_HeadBelowY, 1,
							temp_InnerBelowXFill,temp_InnerBelowYFill, 0,
							temp_OuterBelowX,temp_OuterBelowY, 0,
							temp_HeadBelowX,temp_HeadBelowY, -1
					ENDIF
				ENDIF


			ELSE
			!!! ********* Arrow Style=3,6,9
			!!! ********* Geometry of ArrowHead Contour

				ROT2 numSteptoBreakRight*fokszog
				ADD2 wldo,0
				POLY2_b 4, 1, gs_ArrowFillPen, gs_fill_pen,
					temp_HeadX,temp_HeadY, 1,
					temp_InnerX,temp_InnerY, temp_ArrowMask,
					temp_OuterX,temp_OuterY, 1,
					temp_HeadX,temp_HeadY, -1

				IF gs_ArrowFillPen<>0 THEN
					IF arrow_style_m <> ARROW_STYLE_3 THEN
						!!! Geometry of ArrowHead Fill
						POLY2_b 4, 1+2, gs_ArrowFillPen, gs_fill_pen,
							temp_HeadX,temp_HeadY, 1,
							temp_InnerXFill,temp_InnerY, 0,
							temp_OuterX,temp_OuterY, 0,
							temp_HeadX,temp_HeadY, -1

					ENDIF
				ENDIF
				DEL 2
			ENDIF

		ENDIF

		!!! ********* Hotspots of StartEnd Symbol
		IF drawPart[1] THEN
			ROT2 numSteptoBreakRight*fokszog

				ArrowUNID=4000
				HOTSPOT2 wldo,0,ArrowUNID: ArrowUNID=ArrowUNID+1

				IF arrow_style_m = ARROW_STYLE_3 OR arrow_style_m = ARROW_STYLE_6 OR arrow_style_m = ARROW_STYLE_9 THEN
					ADD2 wldo,0
					ROT2 180

						ArrowUNID=4001

						HOTSPOT2 -ArrowDist,0,	ArrowUNID, gs_ArrowHeight, 1+128 : ArrowUNID=ArrowUNID+1
						HOTSPOT2 -ArrowDist,gs_ArrowHeight, ArrowUNID, gs_ArrowHeight, 2 : ArrowUNID=ArrowUNID+1
						HOTSPOT2 -ArrowDist,-1,	ArrowUNID, gs_ArrowHeight, 3: ArrowUNID=ArrowUNID+1

						HOTSPOT2 ArrowDist,0,	ArrowUNID, gs_ArrowHeight, 1+128 : ArrowUNID=ArrowUNID+1
						HOTSPOT2 ArrowDist,gs_ArrowHeight, ArrowUNID, gs_ArrowHeight, 2 : ArrowUNID=ArrowUNID+1
						HOTSPOT2 ArrowDist,-1,	ArrowUNID, gs_ArrowHeight, 3: ArrowUNID=ArrowUNID+1

						HOTSPOT2 0,gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 1+128 : ArrowUNID=ArrowUNID+1
						HOTSPOT2 gs_ArrowHalfWidth,gs_ArrowHeight, ArrowUNID, gs_ArrowHalfWidth, 2 : ArrowUNID=ArrowUNID+1
						HOTSPOT2 -1,gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 3: ArrowUNID=ArrowUNID+1

						HOTSPOT2 0,gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 1+128 : ArrowUNID=ArrowUNID+1
						HOTSPOT2 -gs_ArrowHalfWidth,gs_ArrowHeight, ArrowUNID, gs_ArrowHalfWidth, 2 : ArrowUNID=ArrowUNID+1
						HOTSPOT2 1,gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 3: ArrowUNID=ArrowUNID+1

					DEL 2
				ENDIF

			DEL 1
		ENDIF

		IF drawPart[2] THEN
			ROT2 temp_endp*fokszog

			ArrowUNID=4100
			HOTSPOT2 wldo,0,ArrowUNID: ArrowUNID=ArrowUNID+1

				IF arrow_style_m = ARROW_STYLE_3 OR arrow_style_m = ARROW_STYLE_6 OR arrow_style_m = ARROW_STYLE_9 THEN
					ADD2 wldo,0
					ROT2 180

						ArrowUNID=4014

						HOTSPOT2 -ArrowDist,0,	ArrowUNID, gs_ArrowHeight, 1+128 : ArrowUNID=ArrowUNID+1
						HOTSPOT2 -ArrowDist,gs_ArrowHeight, ArrowUNID, gs_ArrowHeight, 2 : ArrowUNID=ArrowUNID+1
						HOTSPOT2 -ArrowDist,-1,	ArrowUNID, gs_ArrowHeight, 3: ArrowUNID=ArrowUNID+1

						HOTSPOT2 ArrowDist,0,	ArrowUNID, gs_ArrowHeight, 1+128 : ArrowUNID=ArrowUNID+1
						HOTSPOT2 ArrowDist,gs_ArrowHeight, ArrowUNID, gs_ArrowHeight, 2 : ArrowUNID=ArrowUNID+1
						HOTSPOT2 ArrowDist,-1,	ArrowUNID, gs_ArrowHeight, 3: ArrowUNID=ArrowUNID+1

						HOTSPOT2 0,gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 1+128 : ArrowUNID=ArrowUNID+1
						HOTSPOT2 gs_ArrowHalfWidth,gs_ArrowHeight, ArrowUNID, gs_ArrowHalfWidth, 2 : ArrowUNID=ArrowUNID+1
						HOTSPOT2 -1,gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 3: ArrowUNID=ArrowUNID+1

						HOTSPOT2 0,gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 1+128 : ArrowUNID=ArrowUNID+1
						HOTSPOT2 -gs_ArrowHalfWidth,gs_ArrowHeight, ArrowUNID, gs_ArrowHalfWidth, 2 : ArrowUNID=ArrowUNID+1
						HOTSPOT2 1,gs_ArrowHeight,	ArrowUNID, gs_ArrowHalfWidth, 3: ArrowUNID=ArrowUNID+1
					DEL 2
				ENDIF
			DEL 1
		ENDIF


		!!!!!!!!!!!!!!!!!!!!!! ***	WALKING LINE *** !!!!!!!!!!!!!!!!!!!!!!!!!!
		DRAWINDEX 30
		PEN gs_wLinePen

		IF drawPart[3] THEN

			if aboveStory then
				LINE_TYPE gs_wLineTypeStUp
			else
				if drawDashed[3] then
					LINE_TYPE gs_wLineTypeAbove
				else
					LINE_TYPE gs_wLineType1
				endif
			endif
			ARC2 0,0,wldo, temp_fokszog, INT(temp_endp)*fokszog
		ELSE
			IF drawPart[1] THEN
				if aboveStory then
					LINE_TYPE gs_wLineTypeStUp
				else
					if drawDashed[1] then
						LINE_TYPE gs_wLineTypeAbove
					else
						LINE_TYPE gs_wLineType1
					endif
				endif
				ARC2 0,0,wldo, temp_fokszog, numSteptoBreakRight*fokszog
			ENDIF

			IF drawPart[2] THEN
				if aboveStory then
					LINE_TYPE gs_wLineTypeStUp
				else
					if drawDashed[2] then
						LINE_TYPE gs_wLineTypeAbove
					else
						LINE_TYPE gs_wLineType1
					endif
				endif
				ARC2 0,0,wldo, numSteptoBreakRight*fokszog, INT(temp_endp)*fokszog
			ENDIF
		ENDIF


		!!!!!!!!!!!!!!!!!!!!!!!!!! *** START END SYMBOL *** !!!!!!!!!!!!!!!!!!
		DRAWINDEX 40


		fill gs_StartEndFill

		IF gs_StartEndFillPen<>0 THEN temp_FillStatus=2
		IF gs_StartEndFillPen=0 THEN temp_FillStatus=0

		ROT2 temp_StartEndFokszog
		ADD2 wldo,0
			IF drawPart[1] | drawPart[3] THEN
				if aboveStory then
					LINE_TYPE gs_wLineTypeStUp
				else
					if drawDashed[1] | drawDashed[3] then
						LINE_TYPE gs_wLineTypeAbove
					else
						LINE_TYPE gs_wLineType1
					endif
				endif
				IF gs_StartEndStyle_m = STARTSYMB_STYLE1 THEN
					POLY2_B 2, 1+temp_FillStatus, gs_StartEndFillPen, gs_fill_pen,
					0,0,901,
					gs_CircleRadius,360,4001
				ENDIF

				IF gs_StartEndStyle_m = STARTSYMB_STYLE2 THEN
					FOR kk=1 TO 2
						POLY2_B 6, 1+temp_FillStatus, gs_StartEndFillPen, gs_fill_pen,
							0,0,1,
							0+gs_CircleRadius,0,1,
							0,0,901,
							0,90,4001,
							0,0+gs_CircleRadius,0,
							0,0,-1

						POLY2_B 6, 1, gs_StartEndFillPen, gs_fill_pen,
							0,0,1,
							0,0+gs_CircleRadius,1,
							0,0,901,
							0,90,4001,
							0-gs_CircleRadius,0,0,
							0,0,-1
					ROT2 180
					ADD2 0,2*(0)
					NEXT kk
					DEL 4
				ENDIF

				IF gs_StartEndStyle_m = STARTSYMB_STYLE3 THEN
					LINE2 0+gs_StartWidth,0-gs_StartHeight,0+gs_StartWidth,0+gs_StartHeight
					LINE2 0-gs_StartWidth,0-gs_StartHeight,0-gs_StartWidth,0+gs_StartHeight
				ENDIF

			ENDIF


			!!! ********* Hotspots of StartEnd Symbol

			IF gs_StartEndStyle_m = STARTSYMB_STYLE1 OR gs_StartEndStyle_m = STARTSYMB_STYLE2 THEN

					StartSymbUNID=3000
					FOR kk=1 to 4
						HOTSPOT2 0, 0, StartSymbUNID, gs_CircleRadius, 1+128		:StartSymbUNID=StartSymbUNID+1
						HOTSPOT2 -1, 0, StartSymbUNID, gs_CircleRadius, 3+128	:StartSymbUNID=StartSymbUNID+1
						HOTSPOT2 gs_CircleRadius, 0, StartSymbUNID, gs_CircleRadius,2	:StartSymbUNID=StartSymbUNID+1

						ROT2 90
					NEXT KK
					DEL 4
			ENDIF

			IF gs_StartEndStyle_m = STARTSYMB_STYLE3 THEN

					StartSymbUNID=3100
					FOR kk=1 to 2
						ADD2 0, 0
							!!! Symbol Width/2
							HOTSPOT2 0, -gs_StartHeight, StartSymbUNID, gs_StartWidth, 1+128		:StartSymbUNID=StartSymbUNID+1
							HOTSPOT2 -1, -gs_StartHeight, StartSymbUNID, gs_StartWidth, 3	:StartSymbUNID=StartSymbUNID+1
							HOTSPOT2 gs_StartWidth, -gs_StartHeight, StartSymbUNID, gs_StartWidth,2	:StartSymbUNID=StartSymbUNID+1

							HOTSPOT2 0, gs_StartHeight, StartSymbUNID, gs_StartWidth, 1+128		:StartSymbUNID=StartSymbUNID+1
							HOTSPOT2 -1, gs_StartHeight, StartSymbUNID, gs_StartWidth, 3	:StartSymbUNID=StartSymbUNID+1
							HOTSPOT2 gs_StartWidth, gs_StartHeight, StartSymbUNID, gs_StartWidth,2	:StartSymbUNID=StartSymbUNID+1
						DEL 1

						ADD2 0, 0
							!!! Symbol Height
							HOTSPOT2 gs_StartWidth, 0, StartSymbUNID, gs_StartHeight, 1+128		:StartSymbUNID=StartSymbUNID+1
							HOTSPOT2 gs_StartWidth, -1, StartSymbUNID, gs_StartHeight, 3	:StartSymbUNID=StartSymbUNID+1
							HOTSPOT2 gs_StartWidth, gs_StartHeight, StartSymbUNID, gs_StartHeight,2	:StartSymbUNID=StartSymbUNID+1

							HOTSPOT2 gs_StartWidth, 0, StartSymbUNID, gs_StartHeight, 1+128		:StartSymbUNID=StartSymbUNID+1
							HOTSPOT2 gs_StartWidth, 1, StartSymbUNID, gs_StartHeight, 3	:StartSymbUNID=StartSymbUNID+1
							HOTSPOT2 gs_StartWidth, -gs_StartHeight, StartSymbUNID, gs_StartHeight,2	:StartSymbUNID=StartSymbUNID+1
						DEL 1

					MUL2 -1,1
					NEXT kk
					DEL 2
			ENDIF

		DEL 2

		IF rnu*fokszog <= 360| \
			(_iSymbolType = 3 & drawPart[1] & not(drawPart[2]) ) | \
			(_iSymbolType = 8 & drawPart[1] & not(drawPart[2]) ) | \
			(_iSymbolType = 15 & drawPart[1] & not(drawPart[2]) ) THEN

			IF iFirstTread = FIRSTTREAD_ABOVE_FLOOR_LEVEL THEN DEL 1
		ENDIF

	ENDIF		!!!! End of walkl


!===============================================================================
! --- Text / Up-Down Text / Numbering ---
!===============================================================================

! --- Oriented View --------------------------------------------------------------

angleViewRot = 0
if bShowRiseAndRunText | walkingDirUPDN_m <> WALKDIRSTR_NONE | (drawNum[1] | drawNum[2] | drawNum[3])  then
	rrr = REQUEST ("View_Rotangle", "", angleViewRot)
endif
totalRotate = (SYMB_ROTANGLE + angleViewRot) MOD 360

! --- Define Font Style --------------------------------------------------------

DEFINE STYLE "UPDN" fontType, UPDNfontsize, 5, 0		  	!!- UP/DN
SET STYLE "UPDN"

DEFINE STYLE "stepnum" fontType, gs_NumTextSize, 5, 0		!! - Numbering
SET STYLE "stepnum"

DEFINE STYLE myfs fontType,tdfs,5,0
SET STYLE myfs

! --- Rise and Run Text -------------------------------------------------------
DRAWINDEX 50

pen gs_text_pen

! Z DIMENSION
IF rnu*fokszog <= 360 THEN
	IF iTopTread = TOPTREAD_BELOW_FLOOR_LEVEL THEN rnuu=rnu ELSE rnuu=rnu
	IF iFirstTread = FIRSTTREAD_AT_FLOOR_LEVEL THEN rnuu=rnuu-1
ELSE
	IF iTopTread = TOPTREAD_BELOW_FLOOR_LEVEL THEN rnuu=rnu-2 ELSE rnuu=rnu-1
	IF iFirstTread = FIRSTTREAD_AT_FLOOR_LEVEL THEN rnuu=rnuu-2
ENDIF

if bShowRiseAndRunText then
	add2 COS(60) * wldo, SIN(60) * wldo
	rot2 -30
		call "Stair_RiseRun_Text" PARAMETERS ALL	totalRotate				= totalRotate - 30,
													iRotateType 			= 2,
													iRiseRunTextPosition	= 2,
													treadHeight				= th,
													treadDepth				= td,
													nRisers					= rnuu,
													flightWidth				= 0,
													RiseRunUNID				= 5000
	del 2
endif

! --- Up and Down Text -------------------------------------------------------
iReadable = 0
if iFirstTread = FIRSTTREAD_ABOVE_FLOOR_LEVEL then rot2 fokszog
if walkingDirUPDN_m <> WALKDIRSTR_NONE and walkl then
	set style "UPDN"
	pen UPDNfontpen

	nTransUPDN = 0
	nTransHotspot = 0
	add2 wldo+DirUPDN_X,DirUPDN_Y
	nTransUPDN = nTransUPDN + 1
	! Text Rotation - Readable / Parallel with Walking Line / Align with Symbol
	! ----------------------------------------------------------------------
	if typeTextRotation_UpDn_m = 2 then									! Readable
		if (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps)) then
			rot2 180
			nTransUPDN = nTransUPDN + 1
		endif
	else
		if typeTextRotation_UpDn_m = 1 then								! Parallel with Walking Line
			if SYMB_MIRRORED then
				iReadable = not(totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps)) - (totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps))
			else
				iReadable = not(totalRotate < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps)) - (totalRotate < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps))
			endif
			rot2 -90 * iReadable
			nTransUPDN = nTransUPDN + 1
		endif
	endif
	! ----------------------------------------------------------------------
	rot2 AngUPDN
	nTransUPDN = nTransUPDN + 1

	text2 0,0, walkingDirUPDN
	del nTransUPDN

	width	= STW (walkingDirUPDN)/1000*GLOB_SCALE
	rb		= width/2


	UpDownUNID=6000
	HOTSPOT2 wldo,			DirUPDN_Y, UpDownUNID, DirUPDN_X, 1+128 : UpDownUNID=UpDownUNID+1
	HOTSPOT2 wldo-1,		DirUPDN_Y, UpDownUNID, DirUPDN_X, 3		: UpDownUNID=UpDownUNID+1
	HOTSPOT2 wldo+DirUPDN_X,DirUPDN_Y, UpDownUNID, DirUPDN_X, 2		: UpDownUNID=UpDownUNID+1

	HOTSPOT2 wldo+DirUPDN_X,0,			UpDownUNID, DirUPDN_Y, 1+128: UpDownUNID=UpDownUNID+1
	HOTSPOT2 wldo+DirUPDN_X,-1,			UpDownUNID, DirUPDN_Y, 3	: UpDownUNID=UpDownUNID+1
	HOTSPOT2 wldo+DirUPDN_X,DirUPDN_Y,	UpDownUNID, DirUPDN_Y, 2	: UpDownUNID=UpDownUNID+1

	add2 wldo+DirUPDN_X,DirUPDN_Y
	nTransHotspot = nTransHotspot +1
	if typeTextRotation_UpDn_m = 1 then	! Parallel with Walking Line
		rot2 -90 * iReadable
		nTransHotspot = nTransHotspot +1
	endif
	HOTSPOT2 0,					0,				UpDownUNID,AngUPDN,6	: UpDownUNID=UpDownUNID+1
	HOTSPOT2 rb,				0,				UpDownUNID,AngUPDN,4+128: UpDownUNID=UpDownUNID+1
	HOTSPOT2 rb*COS(AngUPDN),	rb*SIN(AngUPDN),UpDownUNID,AngUPDN,5	: UpDownUNID=UpDownUNID+1
	del nTransHotspot
endif

if iFirstTread = FIRSTTREAD_ABOVE_FLOOR_LEVEL then del 1

! --- Numbering -------------------------------------------------------


IF rnu*fokszog > 360 AND bShowNumbering=1 THEN iFirstTread = FIRSTTREAD_ABOVE_FLOOR_LEVEL
IF iFirstTread = FIRSTTREAD_ABOVE_FLOOR_LEVEL THEN ROT2 fokszog

if (drawNum[1] | drawNum[2] | drawNum[3])  then
	if ZZYZX <= (BreakNum)*th THEN
		startNumber = i1ZZYZX
	else
		startNumber = numSteptoBreakRight
	endif

	if iTopTread = TOPTREAD_BELOW_FLOOR_LEVEL then rnu = rnu + 1
	txtd = 0.1
	fp = fokszog/3

	set style "stepnum"
	pen gs_NumTextPen
	poss = 0
	nTextTransformations = 0

	if drawNum[1] | drawNum[3] then
		for iNumStep = 1 to startNumber
			poss = poss + 1
			if not(iNumStep = rnu & iTopTread = TOPTREAD_BELOW_FLOOR_LEVEL) then
				if iFirstTread = FIRSTTREAD_AT_FLOOR_LEVEL then
					numTextTread = iNumStep + nStartNumbering - 1
				else
					numTextTread = iNumStep + nStartNumbering
				endif
				add2 (r-txtd)*COS((poss-1)*fokszog+fp), (r-txtd)*SIN((poss-1)*fokszog+fp)

				! Text Rotation - Readable / Align with Symbol
				! ----------------------------------------------------------------------
				if typeTextRotation_Num_m = 2 then								! Readable
					if (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps)) then
						rot2 180
						nTextTransformations = 1
					endif
				endif
				! ----------------------------------------------------------------------

				text2 0,0, numTextTread
				if nTextTransformations > 0 then del nTextTransformations
				del 1
			endif
		next iNumStep
	endif

	if drawNum[2] | drawNum[3] then
		if rnu * fokszog <= 360 then
			endNumber = rnu
		else
			if iTopTread = TOPTREAD_BELOW_FLOOR_LEVEL then endNumber = rnu-2
			if iTopTread = TOPTREAD_AT_FLOOR_LEVEL then endNumber = rnu-1
		endif

		for iNumStep = numSteptoBreakRight+1 to endNumber
			if iNumStep = INT(360/fokszog)+1 then txtd = txtd+tdfs/6
			if not(iNumStep = rnu and iTopTread = TOPTREAD_BELOW_FLOOR_LEVEL) then
				add2 (r-txtd)*COS((iNumStep-1)*fokszog+fp), (r-txtd)*SIN((iNumStep-1)*fokszog+fp)
				if iFirstTread = FIRSTTREAD_AT_FLOOR_LEVEL then
					numTextTread = iNumStep + nStartNumbering - 1
				else
					numTextTread = iNumStep + nStartNumbering
				endif
				! Text Rotation - Readable / Align with Symbol
				! ----------------------------------------------------------------------
				if typeTextRotation_Num_m = 2 then								! Readable
					if (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps)) then
						rot2 180
						nTextTransformations = 1
					endif
				endif
				! ----------------------------------------------------------------------
				text2 0,0, numTextTread
				if nTextTransformations > 0 then del nTextTransformations
				del 1
			endif
		next iNumStep
	endif
endif

if iFirstTread = FIRSTTREAD_ABOVE_FLOOR_LEVEL then del 1
pen gs_cont_pen

!===============================================================================
! --- Carriage Line ---
!===============================================================================

if bCarriageLineExist then
	fill gs_fill_type

	bShowCarriagePart1	= 0
	bShowCarriagePart2	= 0
	angle_breakline		= 90

	beamNum				= 1
	beamThk				= beamx
	beamOffsetRight		= 0
	beamOffsetLeft		= 0
	carriageBaseDist	= flw
	carrBreakLineWidth	= 20

	beamRadIn			= r - carriageBaseDist / 2 - beamThk / 2
	beamRadOut			= r - carriageBaseDist / 2 + beamThk / 2

	carrStartAngle		= 0
	if rnu * fokszog < 360 then
		carrEndAngle		= rnu * fokszog
	else
		carrEndAngle		= 360
	endif

	if drawPart[3] then
		!!!!!******************************      1st RUN
		rot2 0
			bCarrAboveBreakLine	= 0
			bBreakCarriageLine	= 0
			gosub "carriage"
		del 1
	else
		if drawPart[1] then
			!!!!!******************************      1st RUN
			rot2 carrStartAngle
				bCarrAboveBreakLine	= 0
				bBreakCarriageLine	= 1
				bShowCarriagePart1	= 1
				bShowCarriagePart2	= 0
				brLineAngle			= angle_breakline
				carrBreakLineDistAngle	= numSteptoBreakRight*fokszog - carrStartAngle
				gosub "carriage"
			del 1
		endif

		if drawPart[2] then
			!!!!!******************************      1st RUN
			rot2 numSteptoBreakRight*fokszog
				bCarrAboveBreakLine	= 1
				bBreakCarriageLine	= 1
				bShowCarriagePart1	= 0
				bShowCarriagePart2	= 1
				brLineAngle			= angle_breakline
				carrBreakLineDistAngle	= numSteptoBreakRight*fokszog
				gosub "carriage"
			del 1
		endif
	endif
endif

!===============================================================================
! --- Railings ---
!===============================================================================

_bShowRailIn2D = 1
if _bShowRailIn2D then
	IF iTopTread = TOPTREAD_AT_FLOOR_LEVEL THEN
		IF bComplexRailRight=0 OR bComplexRailLeft=0 THEN
			rnu=rnu-1
		ELSE
			rnu=rnu
		ENDIF
	ENDIF
	IF iTopTread = TOPTREAD_BELOW_FLOOR_LEVEL THEN
		IF bComplexRailRight=0 OR bComplexRailLeft=0 THEN
			rnu=rnu
		ELSE
			rnu=rnu+1
		ENDIF
	ENDIF

	fordul=fordul*1.00241
	fordul=fordul-fokszog/360

	if iFirstTread = FIRSTTREAD_ABOVE_FLOOR_LEVEL then
		fordul=fordul-fokszog/360
		zz=zzyzx-th
	else
		zz=zzyzx
	endif

	ker	= 2*pi*(r-flw-roffl)
	k	= 2*pi*(r+roffr)
	nlra=sqr(k*k*fordul*fordul+zz*zz)
	klra=sqr(ker*ker*fordul*fordul+zz*zz)

	ann=atn(zz/(k*fordul))
	ank=atn(zz/(ker*fordul))

	kr=r-flw-roffl+handRailWidthL /2
	rr=r+roffr-handRailWidthR/2
	res=res*360/fokszog

	bShowRailPart1		= 0
	bShowRailPart2		= 0
	breakLineDistAngle	= 50
	breakLineWidthAngle	= 0
	brLineAngle			= 90

	drawindex 30
	fill gs_fill_type

	if iFirstTread = FIRSTTREAD_ABOVE_FLOOR_LEVEL then rot2 fokszog

	! --- Left Rail ----------------------------------------------------------------
	if rail_m = 3 | rail_m = 1 then		! Left, Both
		if bSameRails then
			leftRailType_m = rightRailType_m
		endif

		handRailOvAngleL = hrol * 360 / (2 * (r-flw-roffl+ handRailWidthL / 2) * pi) * bComplexRailLeft
		if rnu * fokszog < 360 then
			tempRailAngleL	= fordul * 360
		else
			tempRailAngleL	= 360 - EPS * 100 - 2 * handRailOvAngleL
		endif

		if drawPart[3] then
			if bShowRailOnFloorPlan then
				if aboveStory then
					railPen	= gs_LinePenStUp
					LINE_TYPE railLineType
				else
					if drawDashed[3] then
						LINE_TYPE dash_line
					else
						LINE_TYPE solid_line
					endif
				endif
				pen railPen

				if bSymbolic2D then
					bShowRailOn1stRun		= 1
					bBreakRailLine			= 0
					bRailAboveBreakLine		= 0
					gosub "left rail"
				else
					rot2 -handRailOvAngleL
						POLY2_b 9, 1+2+64, gs_fill_pen, gs_back_pen,
							r-flw-roffl,0,1,
							0,0,900,
							0,tempRailAngleL + handRailOvAngleL * 2, 4000,
							(r-flw-roffl)*COS(tempRailAngleL + handRailOvAngleL * 2),(r-flw-roffl)*SIN(tempRailAngleL + handRailOvAngleL * 2),1,
							(r-flw+handRailWidthL -roffl)*COS(tempRailAngleL + handRailOvAngleL * 2),(r-flw+handRailWidthL -roffl)*SIN(tempRailAngleL + handRailOvAngleL * 2),1,
							0,0,900,
							0,-(tempRailAngleL + handRailOvAngleL * 2),4000,
							r-flw+handRailWidthL -roffl,0,1,
							r-flw-roffl,0,-1
					del 1
				endif
			endif

			if bShowRailAxis then
				line_type railAxisLineType
				pen gs_RailAxisPen
				ARC2 0,0,r-flw-roffl+handRailWidthL /2,-handRailOvAngleL,tempRailAngleL + handRailOvAngleL
			endif
		else		! Break Line - Railing
			if drawPart[1] & bShowRailOnFloorPlan then
				if aboveStory then
					railPen	= gs_LinePenStUp
					LINE_TYPE railLineType
				else
					if drawDashed[1] then
						LINE_TYPE dash_line
					else
						LINE_TYPE solid_line
					endif
				endif
				pen railPen

				if bSymbolic2D then
					bShowRailOn1stRun		= 1
					bBreakRailLine			= 1
					brLineAngle				= 90
					bShowRailPart1			= 1
					breakLineDistAngle		= numSteptoBreakRight*fokszog + handRailOvAngleL
					breakLineWidthAngle		= 0
					bRailAboveBreakLine		= 0
					gosub "left rail"
				else
					rot2 -handRailOvAngleL
						POLY2_b 9, 1+2+64, gs_fill_pen, gs_back_pen,
							r-flw-roffl,0,1,
							0,0,900,
							0,(numSteptoBreakRight*fokszog + handRailOvAngleL), 4000,
							(r-flw-roffl)*COS((numSteptoBreakRight*fokszog + handRailOvAngleL)),(r-flw-roffl)*SIN((numSteptoBreakRight*fokszog + handRailOvAngleL)),1,
							(r-flw+handRailWidthL -roffl)*COS((numSteptoBreakRight*fokszog + handRailOvAngleL)),(r-flw+handRailWidthL -roffl)*SIN((numSteptoBreakRight*fokszog + handRailOvAngleL)),1,
							0,0,900,
							0,-(numSteptoBreakRight*fokszog + handRailOvAngleL),4000,
							r-flw+handRailWidthL -roffl,0,1,
							r-flw-roffl,0,-1
					del 1
				endif
			endif

			if drawPart[2] & bShowRailOnFloorPlan and bShowRailAboveBreakLine then
				if aboveStory then
					railPen	= gs_LinePenStUp
					LINE_TYPE railLineType
				else
					if drawDashed[2] then
						LINE_TYPE dash_line
					else
						LINE_TYPE solid_line
					endif
				endif
				pen railPen
				FILL temp_FillTypeAbove

				if bSymbolic2D then
					bShowRailOn1stRun		= 1
					bBreakRailLine			= 1
					brLineAngle				= 90
					bShowRailPart2			= 1
					breakLineDistAngle		= numSteptoBreakRight*fokszog + handRailOvAngleL
					breakLineWidthAngle		= 0
					bRailAboveBreakLine		= 1
					gosub "left rail"
				else
					POLY2_b 9, 1+FullFill+64, gs_fill_pen, temp_BackPen,
						(r-flw-roffl)*COS(numSteptoBreakRight*fokszog), (r-flw-roffl)*SIN(numSteptoBreakRight*fokszog),1,
						0,0,900,
						0,tempRailAngleL + handRailOvAngleL - numSteptoBreakRight * fokszog, 4000,
						(r-flw-roffl)*COS(tempRailAngleL + handRailOvAngleL),(r-flw-roffl)*SIN(tempRailAngleL + handRailOvAngleL),1,
						(r-flw+handRailWidthL -roffl)*COS(tempRailAngleL + handRailOvAngleL),(r-flw+handRailWidthL -roffl)*SIN(tempRailAngleL + handRailOvAngleL),1,
						0,0,900,
						0,-tempRailAngleL + handRailOvAngleL + numSteptoBreakRight * fokszog,4000,
						(r-flw+handRailWidthL -roffl)*COS(numSteptoBreakRight*fokszog), (r-flw+handRailWidthL -roffl)*SIN(numSteptoBreakRight*fokszog),0,
						(r-flw-roffl)*COS(numSteptoBreakRight*fokszog), (r-flw-roffl)*SIN(numSteptoBreakRight*fokszog),-1
				endif
			endif

			if bShowRailAxis then
				line_type railAxisLineType
				pen gs_RailAxisPen

				if drawPart[1] then
					ARC2 0,0,r-flw-roffl+handRailWidthL /2,-handRailOvAngleL,numSteptoBreakRight*fokszog
				endif

				if drawPart[2] and bShowRailAboveBreakLine then
					ARC2 0,0,r-flw-roffl+handRailWidthL /2,numSteptoBreakRight*fokszog,tempRailAngleL + handRailOvAngleL
				endif
			endif
		endif

		if bShowRailOnFloorPlan then
			if bSameRails then
				RailUNID=1200

				HOTSPOT2 r-flw+handRailWidthL/2, 	0,		RailUNID, roffr, 1+128: RailUNID=RailUNID+1
				HOTSPOT2 r-flw+handRailWidthL/2-roffl,0,	RailUNID, roffr, 2: RailUNID=RailUNID+1
				HOTSPOT2 r-flw+handRailWidthL/2+1,	0,		RailUNID, roffr, 3: RailUNID=RailUNID+1

				ROT2 tempRailAngleL
					HOTSPOT2 r-flw+handRailWidthL/2, 	0,		RailUNID, roffr, 1+128: RailUNID=RailUNID+1
					HOTSPOT2 r-flw+handRailWidthL/2-roffl,0,	RailUNID, roffr, 2: RailUNID=RailUNID+1
					HOTSPOT2 r-flw+handRailWidthL/2+1,	0,		RailUNID, roffr, 3: RailUNID=RailUNID+1
				DEL 1
			else
				RailUNID=1100

				HOTSPOT2 r-flw+handRailWidthL/2, 	0,		RailUNID, roffl, 1+128: RailUNID=RailUNID+1
				HOTSPOT2 r-flw+handRailWidthL/2-roffl,0,	RailUNID, roffl, 2: RailUNID=RailUNID+1
				HOTSPOT2 r-flw+handRailWidthL/2+1,	0,		RailUNID, roffl, 3: RailUNID=RailUNID+1

				ROT2 tempRailAngleL
					HOTSPOT2 r-flw+handRailWidthL/2, 	0,		RailUNID, roffl, 1+128: RailUNID=RailUNID+1
					HOTSPOT2 r-flw+handRailWidthL/2-roffl,0,	RailUNID, roffl, 2: RailUNID=RailUNID+1
					HOTSPOT2 r-flw+handRailWidthL/2+1,	0,		RailUNID, roffl, 3: RailUNID=RailUNID+1
				DEL 1
			endif
		endif
	endif

	! --- Right Rail ----------------------------------------------------------------
	if rail_m = 2 | rail_m = 1 then		! Right, Both
		handRailOvAngleR = hror * 360 / (2 * (r-handRailWidthR / 2+roffr) * pi) * bComplexRailRight
		if rnu * fokszog < 360 then
			tempRailAngleR	= fordul * 360
		else
			tempRailAngleR	= 360 - EPS * 100 - 2 * handRailOvAngleR
		endif

		if drawPart[3] then
			if bShowRailOnFloorPlan then
				if aboveStory then
					railPen	= gs_LinePenStUp
					LINE_TYPE railLineType
				else
					if drawDashed[3] then
						LINE_TYPE dash_line
					else
						LINE_TYPE solid_line
					endif
				endif
				pen railPen

				if bSymbolic2D then
					bShowRailOn1stRun		= 1
					bBreakRailLine			= 0
					bRailAboveBreakLine		= 0
					gosub "right rail"
				else
					rot2 -handRailOvAngleR
						POLY2_b 9, 1+2+64, gs_fill_pen, gs_back_pen,
							r-handRailWidthR+roffr,0,1,
							0,0,900,
							0,tempRailAngleR + handRailOvAngleR * 2, 4000,
							(r-handRailWidthR+roffr)*COS(tempRailAngleR + handRailOvAngleR * 2),(r-handRailWidthR+roffr)*SIN(tempRailAngleR + handRailOvAngleR * 2),1,
							(r+roffr)*COS(tempRailAngleR + handRailOvAngleR * 2),(r+roffr)*SIN(tempRailAngleR + handRailOvAngleR * 2),1,
							0,0,900,
							0,-(tempRailAngleR + handRailOvAngleR * 2),4000,
							r+roffr,0,1,
							r-handRailWidthR+roffr,0,-1
					del 1
				endif
			endif

			if bShowRailAxis then
				line_type railAxisLineType
				pen gs_RailAxisPen
				ARC2 0,0,r+roffr-handRailWidthR/2,-handRailOvAngleR,tempRailAngleR + handRailOvAngleR
			endif
		else		! Break Line - Railing
			if drawPart[1] & bShowRailOnFloorPlan then
				if aboveStory then
					railPen	= gs_LinePenStUp
					LINE_TYPE railLineType
				else
					if drawDashed[1] then
						LINE_TYPE dash_line
					else
						LINE_TYPE solid_line
					endif
				endif
				pen railPen

				if bSymbolic2D then
					bShowRailOn1stRun		= 1
					bBreakRailLine			= 1
					brLineAngle				= 90
					bShowRailPart1			= 1
					breakLineDistAngle		= numSteptoBreakRight*fokszog + handRailOvAngleR
					breakLineWidthAngle		= 0
					bRailAboveBreakLine		= 0
					gosub "right rail"
				else
					rot2 -handRailOvAngleR
						POLY2_b 9, 1+2+64, gs_fill_pen, gs_back_pen,
							r-handRailWidthR+roffr,0,1,
							0,0,900,
							0,(numSteptoBreakRight*fokszog + handRailOvAngleR), 4000,
							(r-handRailWidthR+roffr)*COS((numSteptoBreakRight*fokszog + handRailOvAngleR)),(r-handRailWidthR+roffr)*SIN((numSteptoBreakRight*fokszog + handRailOvAngleR)),1,
							(r+roffr)*COS((numSteptoBreakRight*fokszog + handRailOvAngleR)),(r+roffr)*SIN((numSteptoBreakRight*fokszog + handRailOvAngleR)),1,
							0,0,900,
							0,-(numSteptoBreakRight*fokszog + handRailOvAngleR),4000,
							r+roffr,0,1,
							r-handRailWidthR+roffr,0,-1
					del 1
				endif
			endif

			if drawPart[2] & bShowRailOnFloorPlan and bShowRailAboveBreakLine then
				if aboveStory then
					railPen	= gs_LinePenStUp
					LINE_TYPE railLineType
				else
					if drawDashed[2] then
						LINE_TYPE dash_line
					else
						LINE_TYPE solid_line
					endif
				endif
				pen railPen
				FILL temp_FillTypeAbove

				if bSymbolic2D then
					bShowRailOn1stRun		= 1
					bBreakRailLine			= 1
					brLineAngle				= 90
					bShowRailPart2			= 1
					breakLineDistAngle		= numSteptoBreakRight*fokszog + handRailOvAngleR
					breakLineWidthAngle		= 0
					bRailAboveBreakLine		= 1
					gosub "right rail"
				else
					POLY2_b 9, 1+FullFill+64, gs_fill_pen, temp_BackPen,
						(r-handRailWidthR+roffr)*COS(numSteptoBreakRight*fokszog), (r-handRailWidthR+roffr)*SIN(numSteptoBreakRight*fokszog),1,
						0,0,900,
						0,tempRailAngleR + handRailOvAngleR - numSteptoBreakRight * fokszog, 4000,
						(r-handRailWidthR+roffr)*COS(tempRailAngleR + handRailOvAngleR),(r-handRailWidthR+roffr)*SIN(tempRailAngleR + handRailOvAngleR),1,
						(r+roffr)*COS(tempRailAngleR + handRailOvAngleR),(r+roffr)*SIN(tempRailAngleR + handRailOvAngleR),1,
						0,0,900,
						0,-tempRailAngleR + handRailOvAngleR + numSteptoBreakRight * fokszog,4000,
						(r+roffr)*COS(numSteptoBreakRight*fokszog), (r+roffr)*SIN(numSteptoBreakRight*fokszog),0,
						(r-handRailWidthR+roffr)*COS(numSteptoBreakRight*fokszog), (r-handRailWidthR+roffr)*SIN(numSteptoBreakRight*fokszog),-1
				endif
			endif

			if bShowRailAxis then
				line_type railAxisLineType
				pen gs_RailAxisPen

				if drawPart[1] then
					ARC2 0,0,r+roffr-handRailWidthR/2,-handRailOvAngleR,numSteptoBreakRight*fokszog
				endif

				if drawPart[2] and bShowRailAboveBreakLine then
					ARC2 0,0,r+roffr-handRailWidthR/2,numSteptoBreakRight*fokszog,tempRailAngleR + handRailOvAngleR
				endif
			endif
		endif

		if bShowRailOnFloorPlan then
			RailUNID=1000

			HOTSPOT2 r-handRailWidthR/2, 	0,	RailUNID, roffr, 1+128: RailUNID=RailUNID+1
			HOTSPOT2 r-handRailWidthR/2+roffr,0,	RailUNID, roffr, 2: RailUNID=RailUNID+1
			HOTSPOT2 r-handRailWidthR/2-1,	0,	RailUNID, roffr, 3: RailUNID=RailUNID+1

			ROT2 tempRailAngleR
			RailStartRY = 0
			HOTSPOT2 r-handRailWidthR/2, 	RailStartRY,	RailUNID, roffr, 1+128: RailUNID=RailUNID+1
			HOTSPOT2 r-handRailWidthR/2+roffr,RailStartRY,	RailUNID, roffr, 2: RailUNID=RailUNID+1
			HOTSPOT2 r-handRailWidthR/2-1,	RailStartRY,	RailUNID, roffr, 3: RailUNID=RailUNID+1
			DEL 1
		endif
	endif

	if iFirstTread = FIRSTTREAD_ABOVE_FLOOR_LEVEL then del 1
endif

END

"left rail":

	! ---  Rail on 1st Run -----------------------------------------------------
	if bShowRailOn1stRun then
		if bComplexRailLeft then rot2 fokszog/2*0
		add2 r-flw-roffl+handRailWidthL /2, 0
		rot2 90

		lraSimple=klra
		lraComplex=klra
		additionXComplex=0
		additionZComplex=0
		hrovL=hrol
		hrovR=hrol
		postNumber = npl
		side = SIDE_LEFT
		gosub "callRailsForStair"

		del 2
		if bComplexRailLeft then del 1
	endif

return

"right rail":

	! ---  Rail on 1st Run -----------------------------------------------------
	if bShowRailOn1stRun then
		if bComplexRailRight then rot2 fokszog/2*0
		add2 r+roffr-handRailWidthR/2, 0
		rot2 90

		lraSimple=nlra
		lraComplex=nlra
		additionXComplex=0
		additionZComplex=0
		hrovL=hror
		hrovR=hror
		postNumber = npr
		side = SIDE_RIGHT
		gosub "callRailsForStair"

		del 2
		if bComplexRailRight then del 1
	endif

return

"callRailsForStair":
! ------------------------------------------------------------------------------
!	lraSimple
!	lraComplex
!	additionXComplex
!	additionZComplex
!	hrovL: rail overhang start
!	hrovR: rail overhang end
!	postNumber:   number of posts
!	side: SIDE_LEFT or SIDE_RIGHT
! ==============================================================================
	additionXComplex = additionXComplex
	additionZComplex = additionZComplex
	gosub "callRails"
return

! ==============================================================================
"callRails":
! ------------------------------------------------------------------------------
!	ani
!	additionXComplex
!	additionZComplex
!	dsComplex
!  ------------------
!	side: SIDE_LEFT or SIDE_RIGHT
!	lraSimple
!	lraComplex
!	hrovL: rail overhang start
!	hrovR: rail overhang end
!	postNumber:   number of posts
! ==============================================================================
	if side = SIDE_LEFT then
		railBarDepth	= bwl
		railBarDiam		= bdl
		railHeight		= hrl
		railBarThk		= fthl
		handRailWidth	= handRailWidthL
		railDist		= dsl
		railType_m		= leftRailType_m
		railPostDia		= pdl
		railPostWidth	= pwl
		railPostThk		= pthl
		railPostType	= ptl_m
		nBarsRail		= nbl
		bt_m			= btl_m
		railFramesWSide	= fswl
		railFramesWTop	= ftwl
		railFramesWBot	= fbwl
		railBarHeight	= bhl
		railBarFillThk	= bthl
		abdist			= abdistl
		railFrameMat	= fmatl
		railBaluFillMat	= bmatl
		railPostMat		= pmatl
		nbt				= nbtl
		railFillDist	= fdfl
		bComplexRail	= bComplexRailLeft
		ani				= ank
		rb				= kr
		tempRailAngle	= tempRailAngleL
	else
		railBarDepth	= bwr
		railBarDiam		= bdr
		railHeight		= hrr
		railBarThk		= fthr
		handRailWidth	= handRailWidthR
		railDist		= dsr
		railType_m		= rightRailType_m
		railPostDia		= pdr
		railPostWidth	= pwr
		railPostThk		= pthr
		railPostType	= ptr_m
		nBarsRail		= nbr
		bt_m			= btr_m
		railFramesWSide	= fswr
		railFramesWTop	= ftwr
		railFramesWBot	= fbwr
		railBarHeight	= bhr
		railBarFillThk	= bthr
		abdist			= abdistr
		railFrameMat	= fmatr
		railBaluFillMat	= bmatr
		railPostMat		= pmatr
		nbt				= nbtr
		railFillDist	= fdfr
		bComplexRail	= bComplexRailRight
		ani				= ann
		rb				= rr
		tempRailAngle	= tempRailAngleR
	endif

	add2 additionXComplex * bComplexRail, 0
	call "railSymbol2D_m" parameters all	cfs					= 1,
											bEnable2DPosts		= bComplexRail,
											ptyp_m				= 3,
											ani					= ani,
											ab					= tempRailAngle,
											rb					= rb,
											rom_m				= 1,
											rmm_m				= 1,
											LengthSize			= 0,
											lra					= lraSimple * NOT(bComplexRail) + lraComplex * (bComplexRail),
											hr					= railHeight,
											hrPerp				= railHeight,
											ds					= railDist,
											gs_AngleL			= 90,
											gs_AngleR			= 90,
											iHandRailStyle		= 1,
											handRailDiameter	= handRailWidth,
											handRailWidth		= handRailWidth,
											hroL				= hrovL,
											hroR				= hrovR,
											np					= postNumber,
											pd					= railPostDia,
											pw					= railPostWidth,
											pth					= railPostThk,
											gs_cont_pen			= railPen,
											sa					= 0,
											bBreakRailLine		= bBreakRailLine,
											breakLineAngle		= brLineAngle,
											breakLineDistAngle	= breakLineDistAngle,
											breakLineWidthAngle	= breakLineWidthAngle,
											bRailAboveBreakLine	= bRailAboveBreakLine,
											bShowRailBelowBrL	= bShowRailPart1,
											bShowRailAboveBrL	= bShowRailPart2,
											bPostNoCalculation	= (railType_m = 9),
											pit_m				= 1,
											dp					= abdist,
											nbt					= nbt
	del 1

	bShowRailPart1			= 0
	bShowRailPart2			= 0

return

"carriage":

	drawindex 10

	if bBreakCarriageLine then
		if bShowCarriagePart1 then
			pen carriagePen
			if aboveStory then
				LINE_TYPE carriageLineType
			else
				if	(drawPart[1] and drawDashed[1]) then
					LINE_TYPE dash_line
				else
					LINE_TYPE carriageLineType
				endif
			endif

			poly2_b 9, 1+2+4+64, gs_fill_pen, gs_back_pen,
				beamRadIn,0,1,
				0,0,900,
				0,carrBreakLineDistAngle, 4000,
				beamRadIn*COS(carrBreakLineDistAngle),beamRadIn*SIN(carrBreakLineDistAngle),1,
				beamRadOut*COS(carrBreakLineDistAngle),beamRadOut*SIN(carrBreakLineDistAngle),1,
				0,0,900,
				0,-carrBreakLineDistAngle,4000,
				beamRadOut,0,1,
				beamRadIn,0,-1
		endif

		if bShowCarriagePart2 then
			pen carriagePen
			if aboveStory then
				LINE_TYPE carriageLineType
			else
				if	(drawPart[2] and drawDashed[2]) then
					LINE_TYPE dash_line
				else
					LINE_TYPE carriageLineType
				endif
			endif

			poly2_b 9, 1 + 2 * gs_FillAbove + 4+64, gs_fill_pen, gs_back_pen,
				beamRadIn,0,1,
				0,0,900,
				0,carrEndAngle - carrBreakLineDistAngle, 4000,
				beamRadIn*COS(carrEndAngle - carrBreakLineDistAngle),beamRadIn*SIN(carrEndAngle - carrBreakLineDistAngle),1,
				beamRadOut*COS(carrEndAngle - carrBreakLineDistAngle),beamRadOut*SIN(carrEndAngle - carrBreakLineDistAngle),1,
				0,0,900,
				0,-(carrEndAngle - carrBreakLineDistAngle),4000,
				beamRadOut,0,1,
				beamRadIn,0,-1
		endif
	else
		if aboveStory then
			LINE_TYPE carriageLineType
		else
		pen carriagePen
			if drawPart[3] then
				if (drawDashed[3]) then
					LINE_TYPE dash_line
				else
					LINE_TYPE carriageLineType
				endif
			else
				if	(NOT(bCarrAboveBreakLine) and drawDashed[1]) or\
					((bCarrAboveBreakLine) and drawDashed[2]) then
					LINE_TYPE dash_line
				else
					LINE_TYPE carriageLineType
				endif
			endif
		endif

		if rnu * fokszog < 360 then
			poly2_b 9, 1 + 2 * (NOT(bCarrAboveBreakLine) + bCarrAboveBreakLine * gs_FillAbove) + 4+64, gs_fill_pen, gs_back_pen,
				beamRadIn,0,1,
				0,0,900,
				0,carrEndAngle, 4000,
				beamRadIn*COS(carrEndAngle),beamRadIn*SIN(carrEndAngle),1,
				beamRadOut*COS(carrEndAngle),beamRadOut*SIN(carrEndAngle),1,
				0,0,900,
				0,-carrEndAngle,4000,
				beamRadOut,0,1,
				beamRadIn,0,-1
		else
			poly2_b 10, 1 + 2 * (NOT(bCarrAboveBreakLine) + bCarrAboveBreakLine * gs_FillAbove) + 4+64, gs_fill_pen, gs_back_pen,
				beamRadOut, 0, 1,
				0, 0, 900,
				0, 180, 4001,
				0, 180, 4001,
				beamRadOut, 0, -1,

				beamRadIn, 0, 1,
				0, 0, 900,
				0, 180, 4001,
				0, 180, 4001,
				beamRadIn, 0, -1
		endif
	endif

return

