

! ---------- Hotspots ----------[

	!!! FlightUNID=1		!!! 1
	!!! RailUNID=1000		!!! 1000,1100,1200
	!!! BreakUNID=2000		!!! 2000,2050,2100,2150
	!!! StartSymbUNID=3000	!!! 3000,3100
	!!! ArrowUNID=4000		!!! 4000,4100
	!!! RiseRunUNID=5000	!!! 5000,5100,5200
	!!! UpDownUNID=6000		!!! 6000
	!!! NumUNID=7000		!!! 7000,7100

! ---------- Hotspots ----------]

temp_wLineLength = 0
temp_wLineLengthAbove = 0

dim drawPart[3]		! 1 - lower,  2 - upper,  3 - full
dim drawDashed[3]	! 1 - lower,  2 - upper,  3 - full
dim drawSteps[3]	! 1 - lower,  2 - upper,  3 - full
dim drawDetails[3]	! 1 - lower,  2 - upper,  3 - full
dim drawNum[3]		! 1 - lower,  2 - upper,  3 - full

drawPart[1] 	= 0	! Lower
drawPart[2] 	= 0	! Upper
drawPart[3] 	= 0	! Full
drawDashed[1] 	= 0	! Lower
drawDashed[2] 	= 0	! Upper
drawDashed[3] 	= 0	! Full
drawSteps[1] 	= 0	! Lower
drawSteps[2] 	= 0	! Upper
drawSteps[3] 	= 0	! Full
drawDetails[1] 	= 0	! Lower
drawDetails[2] 	= 0	! Upper
drawDetails[3]	= 0	! Full
drawNum[1] 		= 0	! Lower
drawNum[2] 		= 0	! Upper
drawNum[3]		= 0	! Full

! ---------- Story Sensitive ----------[

abovestory = 0
belowstory = 0
if gs_StorySensitive then
	if GLOB_CH_STORY_DIST > EPS  then
		abovestory = 1
	else
		if GLOB_CH_STORY_DIST < -EPS  then
			belowstory = 1
		endif
	endif
endif

! ---------- Story Sensitive ----------]

! ---------- Settings of 2D Symbol Type ----------
_iSymbolType = 1
if gs_detlevel_2D_m = DET2D_SCALESENSITIVE then
	if GLOB_SCALE <= _iScaleMD then									!! Detailed Scale
		_iSymbolType = iEnabledSymbolTypes[iSymbolGroup][3]
	else
		if GLOB_SCALE > _iScaleMD & GLOB_SCALE <= _iScaleSM then	!! Middle Scale
			_iSymbolType = iEnabledSymbolTypes[iSymbolGroup][2]
		else														!! Simple Scale
			_iSymbolType = iEnabledSymbolTypes[iSymbolGroup][1]
		endif
	endif
else
	_iSymbolType = gs_SymbolType_m
endif

if _iSymbolType = 1 then
	drawPart[3]		= 1		! Full
	drawDashed[3] 	= 1		! Full
	! Railing
	rail_m = RAILPOS_NONE
endif

if _iSymbolType = 2 then
	drawPart[3]	= 1		! Full
	! Railing
	rail_m = RAILPOS_NONE
ENDIF

if _iSymbolType = 3 then
	drawPart[1]	= 1		! Lower
	! Railing
	rail_m = RAILPOS_NONE
ENDIF

if _iSymbolType = 4 then
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	! Railing
	rail_m = RAILPOS_NONE
ENDIF

if _iSymbolType = 5 then
	drawPart[1]	= 1	! Lower
	drawPart[2]	= 1	! Upper
	! Railing
	rail_m = RAILPOS_NONE
ENDIF

if _iSymbolType = 6 then
	drawPart[3]	= 1		! Full
	drawDashed[3] = 1	! Full
	drawSteps[3] = 1	! Full
	! Railing
	rail_m = RAILPOS_NONE
ENDIF

if _iSymbolType = 7 then
	drawPart[3]	= 1		! Full
	drawSteps[3] = 1	! Full
	! Railing
	rail_m = RAILPOS_NONE
ENDIF

if _iSymbolType = 8 then
	drawPart[1]	= 1		! Lower
	drawSteps[1] = 1	! Lower
	! Railing
	rail_m = RAILPOS_NONE
ENDIF

if _iSymbolType = 9 then
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	! Railing
	rail_m = RAILPOS_NONE
ENDIF

if _iSymbolType = 10 then
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
	! Railing
	rail_m = RAILPOS_NONE
ENDIF

if _iSymbolType = 11 then
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	! Railing
	rail_m = RAILPOS_NONE
ENDIF

if _iSymbolType = 12 then
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	! Railing
	rail_m = RAILPOS_NONE
ENDIF

if _iSymbolType = 13 then
	drawPart[3]	= 1		! Full
	drawDashed[3] = 1	! Full
	drawSteps[3] = 1	! Full
	drawDetails[3] = 1	! Full
ENDIF

if _iSymbolType = 14 then
	drawPart[3]	= 1		! Full
	drawSteps[3] = 1	! Full
	drawDetails[3] = 1	! Full
ENDIF

if _iSymbolType = 15 then
	drawPart[1]	= 1		! Lower
	drawSteps[1] = 1	! Lower
	drawDetails[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
endif

if _iSymbolType = 16 then
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawDetails[1] = 1	! Lower
ENDIF

if _iSymbolType = 17 then
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
	drawDetails[1] = 1	! Lower
ENDIF

if _iSymbolType = 18 then
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawDetails[1] = 1	! Lower
	drawDetails[2] = 1	! Upper
ENDIF

if _iSymbolType = 19 then
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawDashed[2] = 1	! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawDetails[1] = 1	! Lower
ENDIF

if _iSymbolType = 20 then
	drawPart[1]	= 1		! Lower
	drawPart[2]	= 1		! Upper
	drawSteps[1] = 1	! Lower
	drawSteps[2] = 1	! Upper
	drawDetails[1] = 1	! Lower
	drawDetails[2] = 1	! Upper
endif

! Numbering
if bShowNumbering then
	drawNum[1]		= drawPart[1] & (not(drawPart[2]) | (drawPart[2] & gs_NumBelow))
	drawNum[2]		= drawPart[2] & (not(drawPart[1]) | (drawPart[1] & gs_NumAbove))
	drawNum[3]		= drawPart[3]
endif

! Nosing
if not(covery) & ( not(cover) | ABS(ns) < EPS) then
	drawDetails[1] = 0
	drawDetails[2] = 0
	drawDetails[3] = 0
endif

! ---------- Stories below the home story ---------- [

bBackgroundFill = 1
if belowstory then
	drawPart[1]		= 0
	drawPart[2]		= 0
	drawPart[3]		= 1

	drawDashed[1]		= 0
	drawDashed[2]		= 0
	drawDashed[3]		= 1

	drawSteps[1] = 0
	drawSteps[2] = 0
	drawSteps[3] = 0

	drawDetails[1] = 0
	drawDetails[2] = 0
	drawDetails[3] = 0

	drawNum[1] = 0
	drawNum[2] = 0
	drawNum[3] = 0

	walkl			= 0
	gs_fill_type	= 65
	gs_back_pen		= 0
	rail_m = RAILPOS_NONE
	bShowRiseAndRunText		= 0

endif

! ---------- Stories above the home story ---------- [
if aboveStory then
	drawPart[1] = 0
	drawPart[2] = 0
	drawPart[3] = 0

	if gs_TreadStUp then
		drawSteps[1] = 1
		drawSteps[2] = 1
		drawSteps[3] = 1

		if drawDetails[1] | drawDetails[3] then
			drawDetails[1] = 1
			drawDetails[2] = 1
			drawDetails[3] = 1
		endif

	else
		drawSteps[1] = 0
		drawSteps[2] = 0
		drawSteps[3] = 0

		drawDetails[1] = 0
		drawDetails[2] = 0
		drawDetails[3] = 0
	endif

	if gs_BreaklineStUp = 0 then
		drawPart[3] = 1
	else
		if gs_LowerPartStUp then
			drawPart[1] = 1
		endif
		if gs_UpperPartStUp then
			drawPart[2] = 1
		endif
	endif

	if gs_numaStUp then
		if drawPart[1] then drawNum[1] = 1
		if drawPart[2] then drawNum[2] = 1
		if drawPart[3] then drawNum[3] = 1
	else
		drawNum[1] = 0
		drawNum[2] = 0
		drawNum[3] = 0
	endif

	if gs_txStUp then
		bShowRiseAndRunText = 1
	else
		bShowRiseAndRunText = 0
	endif

endif


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! Arrow Size
		IF td> 0.26 THEN
		ArrowDist=0.2
		ELSE
		ArrowDist=td*sin(45)
		ENDIF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

PEN gs_cont_pen
FILL gs_fill_type

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

flw=flw*th/abs(th)
lx=lx*th/abs(th)

!!! *** S T A I R	 S L A B

	FlightUNID=1
	HOTSPOT2 0,0, FlightUNID : FlightUNID=FlightUNID+1
	HOTSPOT2 0,ly+flw, FlightUNID : FlightUNID=FlightUNID+1

	HOTSPOT2 0,		0, FlightUNID, flw, 1+128 : FlightUNID=FlightUNID+1
	HOTSPOT2 flw,	0, FlightUNID, flw, 2 : FlightUNID=FlightUNID+1
	HOTSPOT2 -1,	0, FlightUNID, flw, 3 : FlightUNID=FlightUNID+1

	HOTSPOT2 flw,	0,  FlightUNID, ly, 1+128 : FlightUNID=FlightUNID+1
	HOTSPOT2 flw,	ly, FlightUNID, ly, 2 : FlightUNID=FlightUNID+1
	HOTSPOT2 flw,	-1, FlightUNID, ly, 3 : FlightUNID=FlightUNID+1

	HOTSPOT2 flw,	ly, FlightUNID, lx, 1+128 : FlightUNID=FlightUNID+1
	HOTSPOT2 flw+lx,ly, FlightUNID, lx, 2 : FlightUNID=FlightUNID+1
	HOTSPOT2 flw-1,	ly, FlightUNID, lx, 3 : FlightUNID=FlightUNID+1

	HOTSPOT2 flw,	ly+flw, FlightUNID, lx, 1+128 : FlightUNID=FlightUNID+1
	HOTSPOT2 flw+lx,ly+flw, FlightUNID, lx, 2 : FlightUNID=FlightUNID+1
	HOTSPOT2 flw-1,	ly+flw, FlightUNID, lx, 3 : FlightUNID=FlightUNID+1


	!!! *** T R E A D S *** !!!

	depthTreadIn=(abs(lx)+ly)/rnu
	depthTreadOut=(ly+abs(flw)+abs(lx)+abs(flw))/rnu

	!!! ***	B R E A K L I N E and A R R O W at Break Line
!		i11=(INT(rnu/5))
!		i21=(INT(rnu/5))+3
!
!		i22=INT(ly/depthTreadIn)-1
!		i12=i22-3
!
!		numSteptoBreakRight=MIN(i11,i12)
!		numSteptoBreakLeft=MIN(i21,i22)
!
!		IF numSteptoBreakRight<=0 THEN numSteptoBreakRight=0


	numSteptoBreakLeft=INT(gs_BreakHeight/th) 	!!! Num. of Steps on Right Side
	numSteptoBreakRight=numSteptoBreakLeft-3						!!! Num. of Steps on Left Side


	IF numSteptoBreakRight<=0 THEN numSteptoBreakRight=0
	IF numSteptoBreakLeft*depthTreadIn>ly THEN
		drawPart[3] = 1		! IF value of BREAK LINE is longer than ly (at corner)
		drawPart[1] = 0
		drawPart[2] = 0

		drawSteps[3] = drawSteps[1]
		drawSteps[1] = 0
		drawSteps[2] = 0

		drawDetails[3] = drawDetails[1]
		drawDetails[1] = 0
		drawDetails[2] = 0

		drawNum[3] = drawNum[1]	| (aboveStory & not(drawPart[1]) & drawNum[2])
		drawNum[1] = 0
		drawNum[2] = 0
	endif

!TEXT2 0,0,numSteptoBreakRight
!TEXT2 flw,0,numSteptoBreakLeft

	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	!!!!!!!!!!!!!! *** Stair Slab Contour And Fill *** !!!!!!!!!!!!!!!!!!!

	!!! *** Fill above Break Line
	IF gs_FillAbove=1 THEN
		FullFill=2+64
		temp_FillTypeAbove=gs_fill_type
		temp_BackPen=gs_back_pen
	ELSE
		FullFill=0
		temp_FillTypeAbove=gs_FillTypeAbove	!!! because of Area Fill Selection
		temp_BackPen=0						!!! because of Area Fill Selection
	ENDIF

	DRAWINDEX 10
	IF drawPart[3] THEN

			if aboveStory then
				PEN gs_LinePenStUp
				LINE_TYPE gs_LineTypeStUp
			else
				if drawDashed[3] then
					PEN gs_DashLinePen
					LINE_TYPE dash_line
				else
					PEN gs_cont_pen
					LINE_TYPE solid_line
				endif
			endif

			POLY2_b 7, 1+2+64, gs_fill_pen, gs_back_pen,
				0,0,1,
				0,ly+abs(flw),1,
				lx+flw,ly+abs(flw),1,
				lx+flw,ly,1,
				flw, ly, 1,
				flw, 0, 1,
				0,0,-1

	ELSE
		IF breakline_style_m = BREAKLINE_STRAIGHT THEN

			if drawPart[1] then
				if aboveStory then
					PEN gs_LinePenStUp
					LINE_TYPE gs_LineTypeStUp
				else
					if drawDashed[1] then
						PEN gs_DashLinePen
						LINE_TYPE dash_line
					else
						PEN gs_cont_pen
						LINE_TYPE solid_line
					endif
				endif

				POLY2_b 5, 1+2+64, gs_fill_pen, gs_back_pen,
					0,0,1,
					0,numSteptoBreakRight*depthTreadOut,1,
					flw,numSteptoBreakLeft*depthTreadIn,1,
					flw,0,1,
					0,0,-1

				BreakUNID=2000
				HOTSPOT2 0, numSteptoBreakRight*depthTreadOut, BreakUNID: BreakUNID=BreakUNID+1
				HOTSPOT2 flw, numSteptoBreakLeft*depthTreadIn, BreakUNID: BreakUNID=BreakUNID+1

			ENDIF

			if drawPart[2] then
				if aboveStory then
					PEN gs_LinePenStUp
					LINE_TYPE gs_LineTypeStUp
				else
					if drawDashed[2] then
						PEN gs_DashLinePen
						LINE_TYPE dash_line
					else
						PEN gs_cont_pen
						LINE_TYPE solid_line
					endif
				endif

				FILL temp_FillTypeAbove
				POLY2_b 7, 1+FullFill, gs_fill_pen, temp_BackPen,
					0,numSteptoBreakRight*depthTreadOut+brkLineY,1,
					flw,numSteptoBreakLeft*depthTreadIn+brkLineY,1,
					flw,ly,1,
					lx+flw,ly,1,
					lx+flw,ly+abs(flw),1,
					0,ly+abs(flw),1,
					0,numSteptoBreakRight*depthTreadOut+brkLineY,-1

				!!! BREAK LINE
				BreakUNID=2050
				HOTSPOT2 flw/2,	numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2, BreakUNID, brkLineY, 1+128 : BreakUNID=BreakUNID+1
				HOTSPOT2 flw/2,	numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2-1, BreakUNID, brkLineY, 3 : BreakUNID=BreakUNID+1
				HOTSPOT2 flw/2,	numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2+brkLineY, BreakUNID, brkLineY, 2 : BreakUNID=BreakUNID+1

				HOTSPOT2 0, numSteptoBreakRight*depthTreadOut+brkLineY, BreakUNID: BreakUNID=BreakUNID+1
				HOTSPOT2 flw, numSteptoBreakLeft*depthTreadIn+brkLineY, BreakUNID: BreakUNID=BreakUNID+1
			ENDIF

		ELSE
			if breakline_style_m = BREAKLINE_ZIGZAG_CHI then
				angle_breakline=ATN((numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/flw)
				ZigZag1Y=(2/5*flw)*tan(angle_breakline)
				ZigZag2Y=(2/5*flw)*tan(angle_breakline)

				IF drawPart[1] THEN

					if aboveStory then
						PEN gs_LinePenStUp
						LINE_TYPE gs_LineTypeStUp
					else
						if drawDashed[1] then
							PEN gs_DashLinePen
							LINE_TYPE dash_line
						else
							PEN gs_cont_pen
							LINE_TYPE solid_line
						endif
					endif

					POLY2_b 9, 1+2+64, gs_fill_pen, gs_back_pen,
						0,0,1,
						0,numSteptoBreakRight*depthTreadOut,1,
						4/10*flw,numSteptoBreakRight*depthTreadOut+ZigZag1Y,1,
						4/10*flw,numSteptoBreakLeft*depthTreadIn-ZigZag1Y+brkLineY,1,
						6/10*flw,numSteptoBreakRight*depthTreadOut+ZigZag1Y,1,
						6/10*flw,numSteptoBreakLeft*depthTreadIn-ZigZag1Y,1,
						flw,numSteptoBreakLeft*depthTreadIn,1,
						flw,0,1,
						0,0,-1

					!!! BREAK LINE
					BreakUNID=2100
					HOTSPOT2 flw/2,	numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2, BreakUNID, brkLineY, 1+128 : BreakUNID=BreakUNID+1
					HOTSPOT2 flw/2,	numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2-1, BreakUNID, brkLineY, 3 : BreakUNID=BreakUNID+1
					HOTSPOT2 flw/2,	numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2+brkLineY, BreakUNID, brkLineY, 2 : BreakUNID=BreakUNID+1

					HOTSPOT2 0, numSteptoBreakRight*depthTreadOut, BreakUNID: BreakUNID=BreakUNID+1
					HOTSPOT2 flw, numSteptoBreakLeft*depthTreadIn,BreakUNID: BreakUNID=BreakUNID+1
				ENDIF

				IF drawPart[2] THEN

					if aboveStory then
						PEN gs_LinePenStUp
						LINE_TYPE gs_LineTypeStUp
					else
						if drawDashed[2] then
							PEN gs_DashLinePen
							LINE_TYPE dash_line
						else
							PEN gs_cont_pen
							LINE_TYPE solid_line
						endif
					endif

					FILL temp_FillTypeAbove

					POLY2_b 11, 1+FullFill, gs_fill_pen, temp_BackPen,
						0,numSteptoBreakRight*depthTreadOut+brkLineY,1,
						4/10*flw,numSteptoBreakRight*depthTreadOut+brkLineY+ZigZag2Y,1,
						4/10*flw,numSteptoBreakLeft*depthTreadIn-ZigZag1Y+brkLineY,1,
						6/10*flw,numSteptoBreakRight*depthTreadOut+ZigZag1Y,1,
						6/10*flw,numSteptoBreakRight*depthTreadOut+brkLineY+ZigZag2Y+((numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)-2*ZigZag1Y),1,
						flw,numSteptoBreakLeft*depthTreadIn+brkLineY,1,
						flw,ly,1,
						lx+flw,ly,1,
						lx+flw,ly+abs(flw),1,
						0,ly+abs(flw),1,
						0,numSteptoBreakRight*depthTreadOut+brkLineY,-1

					BreakUNID=2150
					HOTSPOT2 0, numSteptoBreakRight*depthTreadOut+brkLineY, BreakUNID: BreakUNID=BreakUNID+1
					HOTSPOT2 flw, numSteptoBreakLeft*depthTreadIn+brkLineY, BreakUNID: BreakUNID=BreakUNID+1
				ENDIF
			else		!!!ZigZag
				angle_breakline=ATN((numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/flw)
				ZigZag1Y=(2/5*flw)*tan(angle_breakline)
				ZigZag2Y=(7/20*flw)*tan(angle_breakline)

				IF drawPart[1] THEN

					if aboveStory then
						PEN gs_LinePenStUp
						LINE_TYPE gs_LineTypeStUp
					else
						if drawDashed[1] then
							PEN gs_DashLinePen
							LINE_TYPE dash_line
						else
							PEN gs_cont_pen
							LINE_TYPE solid_line
						endif
					endif

					POLY2_b 9, 1+2+64, gs_fill_pen, gs_back_pen,
						0,0,1,
						0,numSteptoBreakRight*depthTreadOut,1,
						4/10*flw,numSteptoBreakRight*depthTreadOut+ZigZag1Y,1,
						4/10*flw,numSteptoBreakLeft*depthTreadIn-ZigZag1Y,1,
						6/10*flw,numSteptoBreakRight*depthTreadOut+ZigZag1Y,1,
						6/10*flw,numSteptoBreakLeft*depthTreadIn-ZigZag1Y,1,
						flw,numSteptoBreakLeft*depthTreadIn,1,
						flw,0,1,
						0,0,-1

					!!! BREAK LINE
					BreakUNID=2100
					HOTSPOT2 flw/2,	numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2, BreakUNID, brkLineY, 1+128 : BreakUNID=BreakUNID+1
					HOTSPOT2 flw/2,	numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2-1, BreakUNID, brkLineY, 3 : BreakUNID=BreakUNID+1
					HOTSPOT2 flw/2,	numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2+brkLineY, BreakUNID, brkLineY, 2 : BreakUNID=BreakUNID+1

					HOTSPOT2 0, numSteptoBreakRight*depthTreadOut, BreakUNID: BreakUNID=BreakUNID+1
					HOTSPOT2 flw, numSteptoBreakLeft*depthTreadIn,BreakUNID: BreakUNID=BreakUNID+1
				ENDIF

				IF drawPart[2] THEN

					if aboveStory then
						PEN gs_LinePenStUp
						LINE_TYPE gs_LineTypeStUp
					else
						if drawDashed[2] then
							PEN gs_DashLinePen
							LINE_TYPE dash_line
						else
							PEN gs_cont_pen
							LINE_TYPE solid_line
						endif
					endif

					FILL temp_FillTypeAbove

					POLY2_b 11, 1+FullFill, gs_fill_pen, temp_BackPen,
						0,numSteptoBreakRight*depthTreadOut+brkLineY,1,
						7/20*flw,numSteptoBreakRight*depthTreadOut+brkLineY+ZigZag2Y,1,
						7/20*flw,numSteptoBreakRight*depthTreadOut+brkLineY+ZigZag2Y+((numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)-2*ZigZag1Y),1,
						11/20*flw,numSteptoBreakRight*depthTreadOut+brkLineY+ZigZag2Y,1,
						11/20*flw,numSteptoBreakRight*depthTreadOut+brkLineY+ZigZag2Y+((numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)-2*ZigZag1Y),1,
						flw,numSteptoBreakLeft*depthTreadIn+brkLineY,1,
						flw,ly,1,
						lx+flw,ly,1,
						lx+flw,ly+abs(flw),1,
						0,ly+abs(flw),1,
						0,numSteptoBreakRight*depthTreadOut+brkLineY,-1

					BreakUNID=2150
					HOTSPOT2 0, numSteptoBreakRight*depthTreadOut+brkLineY, BreakUNID: BreakUNID=BreakUNID+1
					HOTSPOT2 flw, numSteptoBreakLeft*depthTreadIn+brkLineY, BreakUNID: BreakUNID=BreakUNID+1
				ENDIF
			endif
		ENDIF
	ENDIF

	!!!!!!!!!!!!!!!!!!!!!! *** CONTOUR HOTLINE *** !!!!!!!!!!!!!!!!!

	IF drawPart[2] THEN
		HOTLINE2 0,0,  flw,0
		HOTLINE2 0,0, 0,ly+abs(flw)
		HOTLINE2 0,ly+abs(flw), lx+flw,ly+abs(flw)
		HOTLINE2 lx+flw,ly+abs(flw), lx+flw, ly
		HOTLINE2 lx+flw,ly, flw, ly
		HOTLINE2 flw, ly, flw,0
	ELSE
		HOTLINE2 0,0,  0,numSteptoBreakRight*depthTreadOut
		HOTLINE2 0,numSteptoBreakRight*depthTreadOut, flw,numSteptoBreakLeft*depthTreadIn
		HOTLINE2 flw,numSteptoBreakLeft*depthTreadIn, flw,0
		HOTLINE2 0,0, flw,0
	ENDIF


!===============================================================================
! --- Text / Up-Down Text / Numbering ---
!===============================================================================

! --- Oriented View ------------------------------------------------------------

angleViewRot = 0
if bShowRiseAndRunText | walkingDirUPDN_m <> WALKDIRSTR_NONE | (drawNum[1] | drawNum[2] | drawNum[3]) then
	rrr = REQUEST ("View_Rotangle", "", angleViewRot)
endif
totalRotate = (SYMB_ROTANGLE + angleViewRot) MOD 360


! --- Define Font Style --------------------------------------------------------

define style "UPDN" fontType, UPDNfontsize, 5, 0		  	!!- UP/DN

DEFINE STYLE "stepnum" fontType, gs_NumTextSize, 7, 0		!! - Numbering

DEFINE STYLE "stepnum2" fontType, gs_NumTextSize, 3, 0		!! - Numbering

! --- Rise and Run Text -------------------------------------------------------
DRAWINDEX 50

if bShowRiseAndRunText then
	call "Stair_RiseRun_Text" PARAMETERS ALL	totalRotate				= totalRotate,
												iRotateType 			= 1,
												iRiseRunTextPosition	= 1,
												flightWidth				= flw,
												nRisers					= rnu,
												treadHeight				= th,
												treadDepth				= td,
												RiseRunUNID				= 5000
endif


! --- Up and Down Text -------------------------------------------------------
iReadable = 0
if walkingDirUPDN_m <> WALKDIRSTR_NONE and walkl then
	set STYLE "UPDN"
	pen UPDNfontpen

	nTransUPDN = 0
	nTransHotspot = 0
	add2 flw/2+DirUPDN_X,DirUPDN_Y
	nTransUPDN = nTransUPDN + 1
	! Text Rotation - Readable / Parallel with Walking Line / Align with Symbol
	! ----------------------------------------------------------------------
	if typeTextRotation_UpDn_m = 2 then									! Readable
		if (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps)) then
			rot2 180
			nTransUPDN = nTransUPDN + 1
		endif
	else
		if typeTextRotation_UpDn_m = 1 then								! Parallel with Walking Line
			if not(SYMB_MIRRORED) then
				iReadable = (totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps))- not(totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps))
			else
				iReadable = (totalRotate < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps))- not(totalRotate < (gs_readable_angle - 90 + eps) | totalRotate > (gs_readable_angle + 180 - 90 + eps))
			endif
			rot2 -90 * iReadable
			nTransUPDN = nTransUPDN + 1
		endif
	endif
	! ----------------------------------------------------------------------
	rot2 AngUPDN
	nTransUPDN = nTransUPDN + 1

	text2 0,0, walkingDirUPDN

	del nTransUPDN

	width	= STW (walkingDirUPDN)/1000*GLOB_SCALE
	rb		= width/2

	UpDownUNID=6000
	hotspot2 flw/2,				DirUPDN_Y,	UpDownUNID, DirUPDN_X, 1+128	: UpDownUNID=UpDownUNID+1
	hotspot2 flw/2-1,			DirUPDN_Y,	UpDownUNID, DirUPDN_X, 3		: UpDownUNID=UpDownUNID+1
	hotspot2 flw/2+DirUPDN_X,	DirUPDN_Y,	UpDownUNID, DirUPDN_X, 2		: UpDownUNID=UpDownUNID+1

	hotspot2 flw/2+DirUPDN_X,	0,			UpDownUNID, DirUPDN_Y, 1+128	: UpDownUNID=UpDownUNID+1
	hotspot2 flw/2+DirUPDN_X,	-1,			UpDownUNID, DirUPDN_Y, 3		: UpDownUNID=UpDownUNID+1
	hotspot2 flw/2+DirUPDN_X,	DirUPDN_Y,	UpDownUNID, DirUPDN_Y, 2		: UpDownUNID=UpDownUNID+1

	ADD2 flw/2+DirUPDN_X,DirUPDN_Y
	nTransHotspot = nTransHotspot +1
	if typeTextRotation_UpDn_m = 1 then	! Parallel with Walking Line
		rot2 -90 * iReadable
		nTransHotspot = nTransHotspot +1
	endif
	hotspot2 0,					0,				UpDownUNID,	AngUPDN,6		: UpDownUNID=UpDownUNID+1
	hotspot2 rb,				0,				UpDownUNID,	AngUPDN,4+128	: UpDownUNID=UpDownUNID+1
	hotspot2 rb*cos(AngUPDN),	rb*sin(AngUPDN),UpDownUNID,	AngUPDN,5		: UpDownUNID=UpDownUNID+1
	del nTransHotspot

endif

! --- Numbering ----------------------------------------------------------------

if (drawNum[1] | drawNum[2] | drawNum[3]) then
	if DirNumText_x <= flw/2 then
		endNumBelow		= numSteptoBreakRight
		startNumAbove_1 = numSteptoBreakRight+1
		startNumAbove_2 = INT((ly+flw)/depthTreadOut)
		depthTread		= depthTreadOut
	else
		endNumBelow		= numSteptoBreakLeft-1
		startNumAbove_1 = numSteptoBreakLeft
		startNumAbove_2 = INT((ly)/depthTreadIn)
		depthTread		= depthTreadIn
	endif

	set style "stepnum"
	pen gs_NumTextPen

	rrrr = REQUEST ("Height_of_style", "stepnum", strHeight)
	strHeight = strHeight / 1000 * GLOB_SCALE
	nTextTransformations = 0

	if drawNum[1] | drawNum[3] then
		nTextPos = 0
		add2 DirNumText_X, -depthTread + DirNumText_Y
		nTextPos = nTextPos + 1
		for iNumStep = 0 to endNumBelow
			add2 0, depthTread
			nTextPos = nTextPos + 1

			! Text Rotation - Readable / Align with Symbol
			! ----------------------------------------------------------------------
			if typeTextRotation_Num_m = 2 then								! Readable
				if (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps)) then
					rot2 180
					strWidth = STW(str("%.0", iNumStep + nStartNumbering)) / 1000 * GLOB_SCALE
					add2 -strWidth, -strHeight
					nTextTransformations = 2
				endif
			endif
			! ----------------------------------------------------------------------

			text2 0, 0, iNumStep + nStartNumbering
			if nTextTransformations > 0 then del nTextTransformations
		next iNumStep
		del nTextPos

		NumUNID = 7000
		hotspot2 0,				DirNumText_Y, NumUNID, DirNumText_X, 1+128	:NumUNID=NumUNID+1
		hotspot2 -1,			DirNumText_Y, NumUNID, DirNumText_X, 3		:NumUNID=NumUNID+1
		hotspot2 DirNumText_X,	DirNumText_Y, NumUNID, DirNumText_X, 2		:NumUNID=NumUNID+1

		hotspot2 DirNumText_X, 0,				NumUNID, DirNumText_Y, 1+128	:NumUNID=NumUNID+1
		hotspot2 DirNumText_X, -1,				NumUNID, DirNumText_Y, 3		:NumUNID=NumUNID+1
		hotspot2 DirNumText_X, DirNumText_Y,	NumUNID, DirNumText_Y, 2		:NumUNID=NumUNID+1
	endif

	if drawNum[2] | drawNum[3] then
		nTextPos = 0
	   ! ----- After Break Line the TreadNum of the first Flight -----
		add2 DirNumText_X, depthTread * endNumBelow + DirNumText_Y
		nTextPos = nTextPos + 1

		for iNumStep = startNumAbove_1 to startNumAbove_2 -1
			add2 0,depthTread
			nTextPos = nTextPos + 1

			! Text Rotation - Readable / Align with Symbol
			! ----------------------------------------------------------------------
			if typeTextRotation_Num_m = 2 then								! Readable
				if (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps)) then
					rot2 180
					strWidth = STW(str("%.0", iNumStep + nStartNumbering)) / 1000 * GLOB_SCALE
					add2 -strWidth, -strHeight
					nTextTransformations = 2
				endif
			endif
			! ----------------------------------------------------------------------
			text2 0, 0, iNumStep + nStartNumbering
			if nTextTransformations > 0 then del nTextTransformations

		next iNumStep
		del nTextPos

		nTextPos = 0
		! ----- After Break Line the TreadNum of the second Flight -----
		set style "stepnum2"
		rrrr = REQUEST ("Height_of_style", "stepnum2", strHeight)
		strHeight = strHeight / 1000 * GLOB_SCALE

		add2 (lx+flw)-(rnu-startNumAbove_2)*depthTread-DirNumText_Y,ly+flw-DirNumText_X
		nTextPos = nTextPos + 1

		for iNumStep = startNumAbove_2 to rnu-1
			add2 depthTread,0
			nTextPos = nTextPos + 1

			! Text Rotation - Readable / Align with Symbol
			! ----------------------------------------------------------------------
			if typeTextRotation_Num_m = 2 then								! Readable
				if (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps)) then
					rot2 180
					strWidth = STW(str("%.0", iNumStep + nStartNumbering)) / 1000 * GLOB_SCALE
					add2 strWidth, strHeight
					nTextTransformations = 2
				endif
			endif
			! ----------------------------------------------------------------------

			text2 0, 0, iNumStep + nStartNumbering
			if nTextTransformations > 0 then del nTextTransformations
		next iNumStep
		del nTextPos

		NumUNID = 7100
		ADD2 lx+flw,ly+flw
		ROT2 -90
		HOTSPOT2 0,				-DirNumText_Y, NumUNID, DirNumText_X, 1+128		:NumUNID=NumUNID+1
		HOTSPOT2 -1,			-DirNumText_Y, NumUNID, DirNumText_X, 3	:NumUNID=NumUNID+1
		HOTSPOT2 DirNumText_X,	-DirNumText_Y, NumUNID, DirNumText_X,2	:NumUNID=NumUNID+1
		DEL 2

		ADD2 lx+flw,ly+flw
		ROT2 90
		HOTSPOT2 -DirNumText_X,	0,				NumUNID, DirNumText_Y, 1+128		:NumUNID=NumUNID+1
		HOTSPOT2 -DirNumText_X, -1,				NumUNID, DirNumText_Y, 3	:NumUNID=NumUNID+1
		HOTSPOT2 -DirNumText_X, DirNumText_Y,	NumUNID, DirNumText_Y,2	:NumUNID=NumUNID+1
		DEL 2
	endif

endif

PEN gs_cont_pen

	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	!!!!!!!!*** ARROWHEAD / WALKING LINE / START END SYMBOL*** !!!!!!!!!
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	DRAWINDEX 40
	IF walkl THEN


		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!!!!!!!!!!!!!!!!!!!!!!!!!! *** ARROWHEAD *** !!!!!!!!!!!!!!!!!!!!!!!!

		!!! *** Arrow Size
		IF td> 0.26 then
		ArrowDist=gs_ArrowHalfWidth
		ELSE
		ArrowDist=gs_ArrowHalfWidth
		ENDIF

		!!! ********** Arrowhead Contour Conditions
		IF arrow_style_m = ARROW_STYLE_1 OR arrow_style_m = ARROW_STYLE_2 OR arrow_style_m = ARROW_STYLE_3 THEN
			temp_ArrowMask=0
		else
			temp_ArrowMask=1
		endif

		!!! ********** Arrowhead Contour Points Conditions
		IF arrow_style_m = ARROW_STYLE_1 OR arrow_style_m = ARROW_STYLE_4 OR arrow_style_m = ARROW_STYLE_7 THEN
			temp_1XContour=0
			temp_2XContour=flw
			temp_1YContourBreak=0
			temp_2YContourBreak=0
		endif

		IF arrow_style_m = ARROW_STYLE_2 OR arrow_style_m = ARROW_STYLE_5 OR arrow_style_m = ARROW_STYLE_8 THEN
			temp_1XContour=flw/4
			temp_2XContour=flw*3/4
			temp_1YContourBreak=0
			temp_2YContourBreak=0
		endif

		IF arrow_style_m = ARROW_STYLE_3 OR arrow_style_m = ARROW_STYLE_6 OR arrow_style_m = ARROW_STYLE_9 THEN
			temp_1XContour=flw/2-ArrowDist
			temp_2XContour=flw/2+ArrowDist
			temp_1YContourBreak=(numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2-numSteptoBreakRight*depthTreadOut)-gs_ArrowHeight
			temp_2YContourBreak=(numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2-numSteptoBreakRight*depthTreadOut)-gs_ArrowHeight
		endif

		!!! ********** Arrowhead Fill Contour Points Conditions
		IF arrow_style_m = ARROW_STYLE_4 OR arrow_style_m = ARROW_STYLE_5 OR arrow_style_m = ARROW_STYLE_6 THEN
			temp_1XFill=temp_1XContour
		endif

		IF arrow_style_m = ARROW_STYLE_7 OR arrow_style_m = ARROW_STYLE_8 OR arrow_style_m = ARROW_STYLE_9 THEN
			temp_1XFill=flw/2
		endif

		!!! ********** Walking Line Length Conditions
		temp_wLineLength = 0
		temp_wLineLengthAbove = 0
		IF arrow_style_m = ARROW_STYLE_4 OR arrow_style_m = ARROW_STYLE_5 THEN temp_wLineLength=numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2-numSteptoBreakRight*depthTreadOut
		IF arrow_style_m = ARROW_STYLE_4 OR arrow_style_m = ARROW_STYLE_5 THEN temp_wLineLengthAbove=numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2-numSteptoBreakRight*depthTreadOut
		IF arrow_style_m = ARROW_STYLE_6 THEN temp_wLineLength=gs_ArrowHeight
		IF arrow_style_m = ARROW_STYLE_6 THEN temp_wLineLengthAbove=gs_ArrowHeight


		PEN gs_wLinePen
		Fill gs_ArrowFill


		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		IF not(drawPart[3]) THEN				!!! with Break Line !!!
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

				!!! ********** Geometry of ArrowHead Contour at Break Line

				IF drawPart[1] THEN
					if aboveStory then
						LINE_TYPE gs_wLineTypeStUp
					else
						if drawDashed[1] then
							LINE_TYPE gs_wLineTypeAbove
						else
							LINE_TYPE gs_wLineType1
						endif
					endif

					ADD2 0,numSteptoBreakRight*depthTreadOut
					POLY2_b 4, 1, gs_ArrowFillPen, gs_fill_pen,
						temp_1XContour,temp_1YContourBreak, temp_ArrowMask,
						temp_2XContour,temp_2YContourBreak, 1,
						flw/2,(numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2-numSteptoBreakRight*depthTreadOut), 1,
						temp_1XContour,temp_1YContourBreak, -1

					IF gs_ArrowFillPen<>0 THEN
						IF arrow_style_m <> ARROW_STYLE_1 AND arrow_style_m <> ARROW_STYLE_2 AND arrow_style_m <> ARROW_STYLE_3 THEN
							!!! Geometry of ArrowHead Fill
							POLY2_b 4, 2, gs_ArrowFillPen, gs_fill_pen,
								temp_1XFill,temp_1YContourBreak, temp_ArrowMask,
								temp_2XContour,temp_2YContourBreak, 1,
								flw/2,(numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2-numSteptoBreakRight*depthTreadOut), 1,
								temp_1XFill,temp_1YContourBreak, -1
						ENDIF
					ENDIF
					DEL 1
				ENDIF


				IF drawPart[2] THEN		!!IF No Contour above Break Line
					if aboveStory then
						LINE_TYPE gs_wLineTypeStUp
					else
						if drawDashed[2] then
							LINE_TYPE gs_wLineTypeAbove
						else
							LINE_TYPE gs_wLineType1
						endif
					endif
					!!! ********* Geometry of ArrowHead Contour
					ADD2 lx+flw-depthTreadOut+((depthTreadOut-depthTreadIn)/2),ly+flw/2
					ADD2 -(numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2-numSteptoBreakRight*depthTreadOut),0
					ROT2 -90
					ADD2 -flw/2,0
						POLY2_b 4, 1, gs_ArrowFillPen, gs_fill_pen,
							temp_1XContour,temp_1YContourBreak, temp_ArrowMask,
							temp_2XContour,temp_2YContourBreak, 1,
							flw/2,(numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2-numSteptoBreakRight*depthTreadOut), 1,
							temp_1XContour,temp_1YContourBreak, -1

						IF gs_ArrowFillPenAbove<>0 THEN
							IF arrow_style_m <> ARROW_STYLE_1 AND arrow_style_m <> ARROW_STYLE_2 AND arrow_style_m <> ARROW_STYLE_3 THEN
								!!! Geometry of ArrowHead Fill
								POLY2_b 4, 2, gs_ArrowFillPenAbove, gs_fill_pen,
									temp_1XFill,temp_1YContourBreak, temp_ArrowMask,
									temp_2XContour,temp_2YContourBreak, 1,
									flw/2,(numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2-numSteptoBreakRight*depthTreadOut), 1,
									temp_1XFill,temp_1YContourBreak, -1
							ENDIF
						ENDIF
					DEL 4
				ENDIF


		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		ELSE			!!! NO BREAK LINE !!!
		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


					if aboveStory then
						LINE_TYPE gs_wLineTypeStUp
					else
						if drawDashed[3] then
							LINE_TYPE gs_wLineTypeAbove
						else
							LINE_TYPE gs_wLineType1
						endif
					endif
					!!! ********* Geometry of ArrowHead Contour
					ADD2 lx+flw-depthTreadOut+((depthTreadOut-depthTreadIn)/2),ly+flw/2
					ADD2 -(numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2-numSteptoBreakRight*depthTreadOut),0
					ROT2 -90
					ADD2 -flw/2,0
						POLY2_b 4, 1, gs_ArrowFillPen, gs_fill_pen,
							temp_1XContour,temp_1YContourBreak, temp_ArrowMask,
							temp_2XContour,temp_2YContourBreak, 1,
							flw/2,(numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2-numSteptoBreakRight*depthTreadOut), 1,
							temp_1XContour,temp_1YContourBreak, -1

						IF gs_ArrowFillPenAbove<>0 THEN
							IF arrow_style_m <> ARROW_STYLE_1 AND arrow_style_m <> ARROW_STYLE_2 AND arrow_style_m <> ARROW_STYLE_3 THEN
								!!! Geometry of ArrowHead Fill
								POLY2_b 4, 2, gs_ArrowFillPen, gs_fill_pen,
									temp_1XFill,temp_1YContourBreak, temp_ArrowMask,
									temp_2XContour,temp_2YContourBreak, 1,
									flw/2,(numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2-numSteptoBreakRight*depthTreadOut), 1,
									temp_1XFill,temp_1YContourBreak, -1

							ENDIF
						ENDIF
					DEL 4

		ENDIF

		!!!!!!!!!!!!!!!!!!!!!! *** ARROWHEAD HOTSPOTS*** !!!!!!!!!!!!!!!!!!!!!!

		IF drawPart[1] THEN

			!!! ********** Hotspot editing of Height and Width of Arrowhead
			IF arrow_style_m = ARROW_STYLE_3 OR arrow_style_m = ARROW_STYLE_6 OR arrow_style_m = ARROW_STYLE_9 THEN

				ArrowUNID=4000
				ADD2 flw/2+ArrowDist,numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2
				ROT2 180
					HOTSPOT2 0,0,	ArrowUNID, gs_ArrowHeight, 1+128 : ArrowUNID=ArrowUNID+1
					HOTSPOT2 0,gs_ArrowHeight, ArrowUNID, gs_ArrowHeight, 2 : ArrowUNID=ArrowUNID+1
					HOTSPOT2 0,-1,	ArrowUNID, gs_ArrowHeight, 3: ArrowUNID=ArrowUNID+1
				DEL 2

				ADD2 flw/2-ArrowDist,numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2
				ROT2 180
					HOTSPOT2 0,0,	ArrowUNID, gs_ArrowHeight, 1+128 : ArrowUNID=ArrowUNID+1
					HOTSPOT2 0,gs_ArrowHeight, ArrowUNID, gs_ArrowHeight, 2 : ArrowUNID=ArrowUNID+1
					HOTSPOT2 0,-1,	ArrowUNID, gs_ArrowHeight, 3: ArrowUNID=ArrowUNID+1
				DEL 2

				ADD2 flw/2,numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2-gs_ArrowHeight
					HOTSPOT2 0,0,	ArrowUNID, gs_ArrowHalfWidth, 1+128 : ArrowUNID=ArrowUNID+1
					HOTSPOT2 gs_ArrowHalfWidth,0, ArrowUNID, gs_ArrowHalfWidth, 2 : ArrowUNID=ArrowUNID+1
					HOTSPOT2 -1,0,	ArrowUNID, gs_ArrowHalfWidth, 3: ArrowUNID=ArrowUNID+1
				DEL 1

				ADD2 flw/2,numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2-gs_ArrowHeight
					HOTSPOT2 0,0,	ArrowUNID, gs_ArrowHalfWidth, 1+128 : ArrowUNID=ArrowUNID+1
					HOTSPOT2 -gs_ArrowHalfWidth,0, ArrowUNID, gs_ArrowHalfWidth, 2 : ArrowUNID=ArrowUNID+1
					HOTSPOT2 1,0,	ArrowUNID, gs_ArrowHalfWidth, 3: ArrowUNID=ArrowUNID+1
				DEL 1
			ENDIF
		ENDIF


		IF drawPart[2] THEN

			!!! ********** Hotspot editing of Height and Width of Arrowhead
			IF arrow_style_m = ARROW_STYLE_3 OR arrow_style_m = ARROW_STYLE_6 OR arrow_style_m = ARROW_STYLE_9 THEN

				ArrowUNID=4100
				ADD2 flw+lx-depthTreadOut+((depthTreadOut-depthTreadIn)/2), ly+abs(flw/2)
				ROT2 90
					HOTSPOT2 ArrowDist,0,	ArrowUNID, gs_ArrowHeight, 1+128 : ArrowUNID=ArrowUNID+1
					HOTSPOT2 ArrowDist,gs_ArrowHeight, ArrowUNID, gs_ArrowHeight, 2 : ArrowUNID=ArrowUNID+1
					HOTSPOT2 ArrowDist,-1,	ArrowUNID, gs_ArrowHeight, 3: ArrowUNID=ArrowUNID+1
				DEL 2

				ADD2 flw+lx-depthTreadOut+((depthTreadOut-depthTreadIn)/2), ly+abs(flw/2)
				ROT2 90
					HOTSPOT2 -ArrowDist,0,	ArrowUNID, gs_ArrowHeight, 1+128 : ArrowUNID=ArrowUNID+1
					HOTSPOT2 -ArrowDist,gs_ArrowHeight, ArrowUNID, gs_ArrowHeight, 2 : ArrowUNID=ArrowUNID+1
					HOTSPOT2 -ArrowDist,-1,	ArrowUNID, gs_ArrowHeight, 3: ArrowUNID=ArrowUNID+1
				DEL 2

				ADD2 flw+lx-depthTreadOut+((depthTreadOut-depthTreadIn)/2)-gs_ArrowHeight, ly+abs(flw/2)
				ROT2 90
					HOTSPOT2 0,0,	ArrowUNID, gs_ArrowHalfWidth, 1+128 : ArrowUNID=ArrowUNID+1
					HOTSPOT2 gs_ArrowHalfWidth,0, ArrowUNID, gs_ArrowHalfWidth, 2 : ArrowUNID=ArrowUNID+1
					HOTSPOT2 -1,0,	ArrowUNID, gs_ArrowHalfWidth, 3: ArrowUNID=ArrowUNID+1
				DEL 2

				ADD2 flw+lx-depthTreadOut+((depthTreadOut-depthTreadIn)/2)-gs_ArrowHeight, ly+abs(flw/2)
				ROT2 90
					HOTSPOT2 0,0,	ArrowUNID, gs_ArrowHalfWidth, 1+128 : ArrowUNID=ArrowUNID+1
					HOTSPOT2 -gs_ArrowHalfWidth,0, ArrowUNID, gs_ArrowHalfWidth, 2 : ArrowUNID=ArrowUNID+1
					HOTSPOT2 01,0,	ArrowUNID, gs_ArrowHalfWidth, 3: ArrowUNID=ArrowUNID+1
				DEL 2

			ENDIF
		ENDIF

	PEN gs_cont_pen
	FILL gs_fill_type


		PEN gs_wLinePen

		!!!!!!!!!!!!!!!!!!!!!! ***	WALKING LINE *** !!!!!!!!!!!!!!!!!!!!!!!!!!

		IF drawPart[3] THEN
			if aboveStory then
				LINE_TYPE gs_wLineTypeStUp
			else
				if drawDashed[3] then
					LINE_TYPE gs_wLineTypeAbove
				else
					LINE_TYPE gs_wLineType1
				endif
			endif

			LINE2 flw/2,0, flw/2,ly
			HOTSPOT2 flw/2,0

			IF th >=0 THEN
				ARC2 flw,ly, abs(flw/2), 90, 180
			ELSE
				ARC2 flw,ly, abs(flw/2), 0, 90
			ENDIF
			LINE2 flw, ly+abs(flw/2),  flw+lx-depthTreadOut+((depthTreadOut-depthTreadIn)/2)-temp_wLineLengthAbove, ly+abs(flw/2)
			HOTSPOT2 flw+lx-depthTreadOut+((depthTreadOut-depthTreadIn)/2), ly+abs(flw/2)
		ELSE

			IF drawPart[1] THEN

				if aboveStory then
					LINE_TYPE gs_wLineTypeStUp
				else
					if drawDashed[1] then
						LINE_TYPE gs_wLineTypeAbove
					else
						LINE_TYPE gs_wLineType1
					endif
				endif
				LINE2 flw/2,0, flw/2,numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2-temp_wLineLength
				HOTSPOT2 flw/2,0
				HOTSPOT2 flw/2,numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2
			ENDIF

			IF drawPart[2] THEN
				if aboveStory then
					LINE_TYPE gs_wLineTypeStUp
				else
					if drawDashed[2] then
						LINE_TYPE gs_wLineTypeAbove
					else
						LINE_TYPE gs_wLineType1
					endif
				endif
				LINE2 flw/2,numSteptoBreakRight*depthTreadOut+(numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/2+brkLineY, flw/2,ly
				IF th >=0 THEN
					ARC2 flw,ly, abs(flw/2), 90, 180
				ELSE
					ARC2 flw,ly, abs(flw/2), 0, 90
				ENDIF
				LINE2 flw, ly+abs(flw/2),  flw+lx-depthTreadOut+((depthTreadOut-depthTreadIn)/2)-temp_wLineLengthAbove, ly+abs(flw/2)
				HOTSPOT2 flw+lx-depthTreadOut+((depthTreadOut-depthTreadIn)/2), ly+abs(flw/2)
			ENDIF

		ENDIF

		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!!!!!!!!!!!!!!!!!!!!!!!!! *** START END SYMBOL *** !!!!!!!!!!!!!!!!!!

				Fill gs_StartEndFill

					IF gs_StartEndFillPen<>0 THEN temp_FillStatus=2
					IF gs_StartEndFillPen=0 THEN temp_FillStatus=0

					IF drawPart[1] | drawPart[3] THEN
						if aboveStory then
							LINE_TYPE gs_wLineTypeStUp
						else
							if drawDashed[1] | drawDashed[3] then
								LINE_TYPE gs_wLineTypeAbove
							else
								LINE_TYPE gs_wLineType1
							endif
						endif
						IF gs_StartEndStyle_m = STARTSYMB_STYLE1 THEN

							POLY2_B 2, 1+temp_FillStatus, gs_StartEndFillPen, gs_fill_pen,
							flw/2,0,901,
							gs_CircleRadius,360,4001

						ENDIF


						IF gs_StartEndStyle_m = STARTSYMB_STYLE2 THEN

							FOR kk=1 TO 2
								POLY2_B 6, 1+temp_FillStatus, gs_StartEndFillPen, gs_fill_pen,
									flw/2,0,1,
									flw/2+gs_CircleRadius,0,1,
									flw/2,0,901,
									0,90,4001,
									flw/2,0+gs_CircleRadius,0,
									flw/2,0,-1

								POLY2_B 6, 1, gs_StartEndFillPen, gs_fill_pen,
									flw/2,0,1,
									flw/2,0+gs_CircleRadius,1,
									flw/2,0,901,
									0,90,4001,
									flw/2-gs_CircleRadius,0,0,
									flw/2,0,-1
							ROT2 180
							ADD2 -flw,2*(0)
							NEXT kk
							DEL 4

						ENDIF

						IF gs_StartEndStyle_m = STARTSYMB_STYLE3 THEN
							LINE2 flw/2+gs_StartWidth,0-gs_StartHeight,flw/2+gs_StartWidth,0+gs_StartHeight
							LINE2 flw/2-gs_StartWidth,0-gs_StartHeight,flw/2-gs_StartWidth,0+gs_StartHeight
						ENDIF


						!!! ********* Hotspots of StartEnd Symbol
						IF gs_StartEndStyle_m = STARTSYMB_STYLE1 OR gs_StartEndStyle_m = STARTSYMB_STYLE2 THEN
							StartSymbUNID=3000
							ADD2 flw/2,0
								FOR kk=1 to 4
									HOTSPOT2 0, 0, StartSymbUNID, gs_CircleRadius, 1+128		:StartSymbUNID=StartSymbUNID+1
									HOTSPOT2 -1, 0, StartSymbUNID, gs_CircleRadius, 3+128	:StartSymbUNID=StartSymbUNID+1
									HOTSPOT2 gs_CircleRadius, 0, StartSymbUNID, gs_CircleRadius,2	:StartSymbUNID=StartSymbUNID+1

									ROT2 90
								NEXT KK
								DEL 4
							DEL 1
						ENDIF

						IF gs_StartEndStyle_m = STARTSYMB_STYLE3 THEN
							StartSymbUNID=3100
							ADD2 flw/2,0
								FOR kk=1 to 2
									ADD2 0, 0
										!!! Symbol Width/2
										HOTSPOT2 0, -gs_StartHeight, StartSymbUNID, gs_StartWidth, 1+128		:StartSymbUNID=StartSymbUNID+1
										HOTSPOT2 -1, -gs_StartHeight, StartSymbUNID, gs_StartWidth, 3	:StartSymbUNID=StartSymbUNID+1
										HOTSPOT2 gs_StartWidth, -gs_StartHeight, StartSymbUNID, gs_StartWidth,2	:StartSymbUNID=StartSymbUNID+1

										HOTSPOT2 0, gs_StartHeight, StartSymbUNID, gs_StartWidth, 1+128		:StartSymbUNID=StartSymbUNID+1
										HOTSPOT2 -1, gs_StartHeight, StartSymbUNID, gs_StartWidth, 3	:StartSymbUNID=StartSymbUNID+1
										HOTSPOT2 gs_StartWidth, gs_StartHeight, StartSymbUNID, gs_StartWidth,2	:StartSymbUNID=StartSymbUNID+1
									DEL 1

									ADD2 0, 0
										!!! Symbol Height
										HOTSPOT2 gs_StartWidth, 0, StartSymbUNID, gs_StartHeight, 1+128		:StartSymbUNID=StartSymbUNID+1
										HOTSPOT2 gs_StartWidth, -1, StartSymbUNID, gs_StartHeight, 3	:StartSymbUNID=StartSymbUNID+1
										HOTSPOT2 gs_StartWidth, gs_StartHeight, StartSymbUNID, gs_StartHeight,2	:StartSymbUNID=StartSymbUNID+1

										HOTSPOT2 gs_StartWidth, 0, StartSymbUNID, gs_StartHeight, 1+128		:StartSymbUNID=StartSymbUNID+1
										HOTSPOT2 gs_StartWidth, 1, StartSymbUNID, gs_StartHeight, 3	:StartSymbUNID=StartSymbUNID+1
										HOTSPOT2 gs_StartWidth, -gs_StartHeight, StartSymbUNID, gs_StartHeight,2	:StartSymbUNID=StartSymbUNID+1
									DEL 1

								MUL2 -1,1
								NEXT kk
								DEL 2
							DEL 1
						ENDIF
					ENDIF

	ENDIF	!!! 	End of walkl=1

	nx=0
	ny=0
	kx=flw
	ky=0
	vernyul=0



	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	!!!!!!!!!!!!!!!!!!!!!!!!!! *** T R E A D S *** !!!!!!!!!!!!!!!!!!!!!!!


	PEN gs_cont_pen
	FILL gs_fill_type

	DRAWINDEX 10
	IF drawPart[3] & drawSteps[3] THEN

		FOR i=1 to rnu

			IF depthTreadIn*i < ly THEN
				kyp=ky
				kxp=kx
				ky=depthTreadIn*i
				kx=flw
			ELSE
				kyp=ky
				kxp=kx
				ky=ly
				kx=flw+(depthTreadIn*i-ly)*th/abs(th)
			ENDIF
			IF depthTreadOut*i < ly+abs(flw) THEN
				nyp=ny
				nxp=nx
				ny=i*depthTreadOut
			ELSE
				nyp=ny
				nxp=nx
				ny=ly+abs(flw)
				nx=(i*depthTreadOut-ny)*th/abs(th)
			ENDIF

			!!!!!!!!!!!!!!!!!!!!!! ***	N O S I N G *** !!!!!!!!!!!!!!!!!!!!!!!!!!


			aa=sqr((ny-ky)*(ny-ky)+(nx-kx)*(nx-kx))
			IF ABS(ny-ky)<EPS THEN
				dx=covthicky+ns
			ELSE
				dx=(covthicky+ns)*aa/abs(ny-ky)
			ENDIF
			IF nx-kx=0 THEN
				dy=ns+covthicky
			ELSE
				dy=(covthicky+ns)*aa/abs(nx-kx)
			ENDIF

			IF (i-1)*depthTreadIn <= ly THEN
				kyp=kyp-dy
			ELSE
				kxp=kxp-dx
			ENDIF
			IF (i-1)*depthTreadOut <= ly+abs(flw) THEN
				nyp=nyp-dy
			ELSE
				nxp=nxp-dx
			ENDIF

			!!! *** T R E A D S

				if drawDetails[3] then

					PEN gs_DashLinePen
					LINE_TYPE dash_line

					IF i < rnu THEN LINE2 kx,ky, nx,ny
					IF _iSymbolType = 13 OR _iSymbolType = 14 THEN
						IF i > 1  THEN HOTLINE2 kx,ky, nx,ny
					ENDIF
				ENDIF


			!!! *** N O S I N G


				if aboveStory then
					PEN gs_LinePenStUp
					LINE_TYPE gs_LineTypeStUp
				else
					if drawDashed[3] then
						PEN gs_DashLinePen
						LINE_TYPE dash_line
					else
						PEN gs_cont_pen
						LINE_TYPE solid_line
					endif
				endif

				IF i > 1  THEN LINE2 kxp,kyp, nxp,nyp
				IF _iSymbolType = 6 OR _iSymbolType = 7 THEN
					IF i > 1  THEN HOTLINE2 kxp,kyp, nxp,nyp
				ENDIF


		NEXT i
	ENDIF




	IF not(drawPart[3]) THEN

		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!!!!!!!!! *** T R E A D S__BELOW __B R E A K L I N E *** !!!!!!!!!!!!

		IF drawPart[1] & drawSteps[1] THEN

			FOR i=1 to numSteptoBreakLeft

			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			!!!!!!!!!!!!!!!!!!!!! *** TREADS AND NOSING *** !!!!!!!!!!!!!!!!!!!!!!

			IF depthTreadIn*i < ly THEN
				kyp=ky
				kxp=kx
				ky=depthTreadIn*i
				kx=flw
			ELSE
				kyp=ky
				kxp=kx
				ky=ly
				kx=flw+(depthTreadIn*i-ly)*th/abs(th)
			ENDIF
			IF depthTreadOut*i < ly+abs(flw) THEN
				nyp=ny
				nxp=nx
				ny=i*depthTreadOut
			ELSE
				nyp=ny
				nxp=nx
				ny=ly+abs(flw)
				nx=(i*depthTreadOut-ny)*th/abs(th)
			ENDIF


			aa=sqr((ny-ky)*(ny-ky)+(nx-kx)*(nx-kx))
			IF ABS(ny-ky)<EPS THEN
				dx=covthicky+ns
			ELSE
				dx=(covthicky+ns)*aa/abs(ny-ky)
			ENDIF
			IF nx-kx=0 THEN
				dy=ns+covthicky
			ELSE
				dy=(covthicky+ns)*aa/abs(nx-kx)
			ENDIF

			IF (i-1)*depthTreadIn <= ly THEN
				kyp=kyp-dy
			ELSE
				kxp=kxp-dx
			ENDIF
			IF (i-1)*depthTreadOut <= ly+abs(flw) THEN
				nyp=nyp-dy
			ELSE
				nxp=nxp-dx
			ENDIF


			!!! *** T R E A D S

				!! *** Coordinate of Points
				MM=numSteptoBreakRight		!! Num. of Riser at Break Line

				NN=numSteptoBreakRight+1		!! Num. of Riser
				TreadP1X=((NN-MM)*depthTreadOut*flw)/((MM+3-NN)*depthTreadIn+(NN-MM)*depthTreadOut)
				TreadP1Y=NN*depthTreadOut-(NN*(depthTreadOut-depthTreadIn)/flw)*TreadP1X

				NN=(NN+1)	!! Num. of Riser
				TreadP2X=((NN-MM)*depthTreadOut*flw)/((MM+3-NN)*depthTreadIn+(NN-MM)*depthTreadOut)
				TreadP2Y=NN*depthTreadOut-(NN*(depthTreadOut-depthTreadIn)/flw)*TreadP2X

				TreadPXEND=nx
				TreadPYEND=ny
				IF i=numSteptoBreakRight+1 THEN TreadPXEND=TreadP1X
				IF i=numSteptoBreakRight+1 THEN TreadPYEND=TreadP1Y
				IF i=numSteptoBreakRight+2 THEN TreadPXEND=TreadP2X
				IF i=numSteptoBreakRight+2 THEN TreadPYEND=TreadP2Y
				IF i=numSteptoBreakRight+3 THEN TreadPXEND=flw
				IF i=numSteptoBreakRight+3 THEN TreadPYEND=numSteptoBreakLeft*depthTreadIn

				if drawDetails[1] then

					PEN gs_DashLinePen
					LINE_TYPE dash_line

					LINE2 kx,ky, TreadPXEND,TreadPYEND
					IF _iSymbolType >= 13 AND i > 1 THEN HOTline2 kx,ky, TreadPXEND,TreadPYEND
				ENDIF


			!!! *** N O S I N G

				!! *** Coordinate of Points
				MM=numSteptoBreakRight		!! Num. of Riser at Break Line
				NosingY=(dy)

				NNN=numSteptoBreakRight+1		!! Num. of Riser
				NosingP1X=(((NNN-MM)*depthTreadOut-NosingY)*flw)/((MM+3-NNN)*depthTreadIn+(NNN-MM)*depthTreadOut)
				NosingP1Y=NNN*depthTreadOut-NosingY-NNN*(depthTreadOut-depthTreadIn)/flw*NosingP1X

				NNN=(NNN+1)	!! Num. of Riser
				NosingP2X=(((NNN-MM)*depthTreadOut-NosingY)*flw)/((MM+3-NNN)*depthTreadIn+(NNN-MM)*depthTreadOut)
				NosingP2Y=NNN*depthTreadOut-NosingY-NNN*(depthTreadOut-depthTreadIn)/flw*NosingP2X

				NosingPXEND=nxp
				NosingPYEND=nyp
				IF i=numSteptoBreakRight+2 THEN NosingPXEND=NosingP1X
				IF i=numSteptoBreakRight+2 THEN NosingPYEND=NosingP1Y
				IF i=numSteptoBreakRight+3 THEN NosingPXEND=NosingP2X
				IF i=numSteptoBreakRight+3 THEN NosingPYEND=NosingP2Y

				if aboveStory then
					PEN gs_LinePenStUp
					LINE_TYPE gs_LineTypeStUp
				else
					if drawDashed[1] then
						PEN gs_DashLinePen
						LINE_TYPE dash_line
					else
						PEN gs_cont_pen
						LINE_TYPE solid_line
					endif
				endif

					IF i > 1 THEN line2 kxp,kyp, NosingPXEND,NosingPYEND
					IF _iSymbolType < 13 AND i > 1 THEN HOTline2 kxp,kyp, NosingPXEND,NosingPYEND

			NEXT i

		ENDIF



		!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		!!!!!!!!!! *** T R E A D S__Above __B R E A K L I N E *** !!!!!!!!!!!!

		IF drawPart[2] & drawSteps[2] THEN

			FOR i=numSteptoBreakRight to rnu

			!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			!!!!!!!!!!!!!!!!!!!!! *** TREADS AND NOSING *** !!!!!!!!!!!!!!!!!!!!!!

				IF depthTreadIn*i < ly THEN
					kyp=ky
					kxp=kx
					ky=depthTreadIn*i
					kx=flw
				ELSE
					kyp=ky
					kxp=kx
					ky=ly
					kx=flw+(depthTreadIn*i-ly)*th/abs(th)
				ENDIF
				IF depthTreadOut*i < ly+abs(flw) THEN
					nyp=ny
					nxp=nx
					ny=i*depthTreadOut
				ELSE
					nyp=ny
					nxp=nx
					ny=ly+abs(flw)
					nx=(i*depthTreadOut-ny)*th/abs(th)
				ENDIF


				aa=sqr((ny-ky)*(ny-ky)+(nx-kx)*(nx-kx))
				IF ABS(ny-ky)<EPS THEN
					dx=covthicky+ns
				ELSE
					dx=(covthicky+ns)*aa/abs(ny-ky)
				ENDIF
				IF nx-kx=0 THEN
					dy=ns+covthicky
				ELSE
					dy=(covthicky+ns)*aa/abs(nx-kx)
				ENDIF

				IF (i-1)*depthTreadIn <= ly THEN
					kyp=kyp-dy
				ELSE
					kxp=kxp-dx
				ENDIF
				IF (i-1)*depthTreadOut <= ly+abs(flw) THEN
					nyp=nyp-dy
				ELSE
					nxp=nxp-dx
				ENDIF


			!!! *** T R E A D S

				!! *** Coordinate of Points
				MM=numSteptoBreakRight		!! Num. of Riser at Break Line

				NN=numSteptoBreakRight+1		!! Num. of Riser
				TreadP3X=((-brkLineY+(NN-MM)*depthTreadOut)*flw)/((MM+3-NN)*depthTreadIn+(NN-MM)*depthTreadOut)
				TreadP3Y=NN*depthTreadOut-NN*(depthTreadOut-depthTreadIn)/flw*TreadP3X

				NN=(NN+1)	!! Num. of Riser
				TreadP4X=((-brkLineY+(NN-MM)*depthTreadOut)*flw)/((MM+3-NN)*depthTreadIn+(NN-MM)*depthTreadOut)
				TreadP4Y=NN*depthTreadOut-(NN*(depthTreadOut-depthTreadIn)/flw)*TreadP4X

				NN=(NN+1)	!! Num. of Riser
				TreadP5X=((-brkLineY+(NN-MM)*depthTreadOut)*flw)/((MM+3-NN)*depthTreadIn+(NN-MM)*depthTreadOut)
				TreadP5Y=NN*depthTreadOut-(NN*(depthTreadOut-depthTreadIn)/flw)*TreadP5X


				TreadPXEND2=kx
				TreadPYEND2=ky
				IF i=numSteptoBreakRight+1 THEN TreadPXEND2=TreadP3X
				IF i=numSteptoBreakRight+1 THEN TreadPYEND2=TreadP3Y
				IF i=numSteptoBreakRight+2 THEN TreadPXEND2=TreadP4X
				IF i=numSteptoBreakRight+2 THEN TreadPYEND2=TreadP4Y
				IF i=numSteptoBreakRight+3 THEN TreadPXEND2=TreadP5X
				IF i=numSteptoBreakRight+3 THEN TreadPYEND2=TreadP5Y

				if drawDetails[2] then 		! IF covery or ABS(ns)>EPS and cover THEN
					PEN gs_DashLinePen
					LINE_TYPE dash_line

					if i > numSteptoBreakRight & i < rnu then
						LINE2 TreadPXEND2,TreadPYEND2, nx,ny
						HOTline2 TreadPXEND2,TreadPYEND2, nx,ny
					ENDIF
				ENDIF


			!!! *** N O S I N G

				!! *** Coordinate of Points
				MM=numSteptoBreakRight		!! Num. of Riser at Break Line
				NosingY=(dy)

				NNN=numSteptoBreakRight+1		!! Num. of Riser
				NosingP3X=((-brkLineY+(NNN-MM)*depthTreadOut-NosingY)*flw)/((MM+3-NNN)*depthTreadIn+(NNN-MM)*depthTreadOut)
				NosingP3Y=NNN*depthTreadOut-NosingY-NNN*(depthTreadOut-depthTreadIn)/flw*NosingP3X

				NNN=(NNN+1)	!! Num. of Riser
				NosingP4X=((-brkLineY+(NNN-MM)*depthTreadOut-NosingY)*flw)/((MM+3-NNN)*depthTreadIn+(NNN-MM)*depthTreadOut)
				NosingP4Y=NNN*depthTreadOut-NosingY-NNN*(depthTreadOut-depthTreadIn)/flw*NosingP4X

				NNN=(NNN+1)	!! Num. of Riser
				NosingP5X=((-brkLineY+(NNN-MM)*depthTreadOut-NosingY)*flw)/((MM+3-NNN)*depthTreadIn+(NNN-MM)*depthTreadOut)
				NosingP5Y=NNN*depthTreadOut-NosingY-NNN*(depthTreadOut-depthTreadIn)/flw*NosingP5X

				NNN=(NNN+1)	!! Num. of Riser
				NosingP6X=((-brkLineY+(NNN-MM)*depthTreadOut-NosingY)*flw)/((MM+3-NNN)*depthTreadIn+(NNN-MM)*depthTreadOut)
				NosingP6Y=NNN*depthTreadOut-NosingY-NNN*(depthTreadOut-depthTreadIn)/flw*NosingP6X

				NosingPXEND2=kxp
				NosingPYEND2=kyp
				IF i=numSteptoBreakRight+2 THEN NosingPXEND2=NosingP3X
				IF i=numSteptoBreakRight+2 THEN NosingPYEND2=NosingP3Y
				IF i=numSteptoBreakRight+3 THEN NosingPXEND2=NosingP4X
				IF i=numSteptoBreakRight+3 THEN NosingPYEND2=NosingP4Y
				IF i=numSteptoBreakRight+4 THEN NosingPXEND2=NosingP5X
				IF i=numSteptoBreakRight+4 THEN NosingPYEND2=NosingP5Y
!				IF covery or ABS(ns)>EPS and cover THEN
!					IF i=numSteptoBreakRight+5 THEN NosingPXEND2=NosingP6X
!					IF i=numSteptoBreakRight+5 THEN NosingPYEND2=NosingP6Y
!				ENDIF


					if aboveStory then
						PEN gs_LinePenStUp
						LINE_TYPE gs_LineTypeStUp
					else
						if drawDashed[2] then
							PEN gs_DashLinePen
							LINE_TYPE dash_line
						else
							PEN gs_cont_pen
							LINE_TYPE solid_line
						endif
					endif

					IF i > numSteptoBreakRight+1 THEN  LINE2 NosingPXEND2,NosingPYEND2, nxp,nyp
					IF _iSymbolType < 13 AND i > 4 THEN HOTline2 NosingPXEND2,NosingPYEND2, nxp,nyp


			NEXT i
		ENDIF

	ENDIF

!===============================================================================
! --- Railings ---
!===============================================================================

_bShowRailIn2D = 1
if _bShowRailIn2D then
	angle_breakline = ATN((numSteptoBreakLeft*depthTreadIn-numSteptoBreakRight*depthTreadOut)/flw)

	SlabAlfa=ATN(th/depthTreadIn)
	SlabAlfaOut=ATN(th/depthTreadOut)

	bShowRailPart1	= 0
	bShowRailPart2	= 0
	breakLineW		= brkLineY
	breakLineDist	= 0
	brLineAngle		= 45

	drawindex 30
	fill gs_fill_type

	! --- Left Rail ----------------------------------------------------------------
	if rail_m = 3 | rail_m = 1 then		! Left, Both
		if bSameRails then
			leftRailType_m = rightRailType_m
		endif

		!!! *** Railings Points
		!!! at Start Step
		RailStartLLX=-roffl				!!Left
		RailStartLRX=handRailWidthL-roffl

		IF NOT(bComplexRailLeft) THEN		!!Left
			RailStartLY=0
		ELSE
			RailStartLY=depthTreadOut/2 - (td/2-handRailWidthL/2)
		ENDIF

		!!! at Break Line
		MM=numSteptoBreakRight		!! Num. of Riser at Break Line
		N=numSteptoBreakRight		!! Num. of Riser

		RailBreakLLX=RailStartLLX				!!Left
		RailBreakLLY=N*depthTreadOut+(((N+3)*depthTreadIn-N*depthTreadOut)*RailBreakLLX)/flw
		RailBreakLRX=RailStartLRX
		RailBreakLRY=N*depthTreadOut+(((N+3)*depthTreadIn-N*depthTreadOut)*RailBreakLRX)/flw

		!!! at Corner
		RailCornerLLX=RailStartLLX				!!Left
		RailCornerLLY=ly+flw+roffl
		RailCornerLRX=RailStartLRX
		RailCornerLRY=ly+flw-handRailWidthL+roffl

		!!! at End Step
		IF NOT(bComplexRailLeft) THEN				!!Left
			RailEndLX=flw+lx-depthTreadOut
		ELSE
			RailEndLX=lx+flw-depthTreadOut+td/2+(td/2-handRailWidthL)
		ENDIF

		RailEndLLY=RailCornerLLY				!!Left
		RailEndLRY=RailCornerLRY

		if drawPart[3] then
			if bShowRailOnFloorPlan then
				if aboveStory then
					railPen	= gs_LinePenStUp
					LINE_TYPE railLineType
				else
					if drawDashed[3] then
						LINE_TYPE dash_line
					else
						LINE_TYPE solid_line
					endif
				endif
				pen railPen

				if bSymbolic2D then
					bShowRailOn1stRun		= 1
					bShowRailOn1stLanding1	= 1
					bShowRailOn1stLanding2	= 1
					bShowRailOn2ndRun		= 1
					bBreakRailLine			= 0
					bRailAboveBreakLine		= 0
					gosub "left rail"
				else
					poly2_b 7, 1+2+64, gs_fill_pen, gs_back_pen,
						RailStartLLX,RailStartLY,1,
						RailCornerLLX,RailCornerLLY,1,
						RailEndLX,RailEndLLY,1,
						RailEndLX,RailEndLRY,1,
						RailCornerLRX,RailCornerLRY,1,
						RailStartLRX,RailStartLY,1,
						RailStartLLX,RailStartLY,-1
				endif
			endif

			if bShowRailAxis then
				line_type railAxisLineType
				pen gs_RailAxisPen
				LINE2 RailStartLLX+handRailWidthL/2,RailStartLY,RailStartLLX+handRailWidthL/2,RailCornerLLY-handRailWidthL/2
				LINE2 RailStartLLX+handRailWidthL/2,RailCornerLLY-handRailWidthL/2,RailEndLX,RailCornerLLY-handRailWidthL/2
			endif
		else		! Break Line - Railing
			if drawPart[1] & bShowRailOnFloorPlan then
				if aboveStory then
					railPen	= gs_LinePenStUp
					LINE_TYPE railLineType
				else
					if drawDashed[1] then
						LINE_TYPE dash_line
					else
						LINE_TYPE solid_line
					endif
				endif
				pen railPen

				if bSymbolic2D then
					bShowRailOn1stRun		= 1
					bShowRailOn2ndRun		= 0
					bBreakRailLine			= 1
					brLineAngle				= angle_breakline
					bShowRailPart1			= 1
					breakLineDist			= RailBreakLLY + handRailWidthL * TAN(angle_breakline) + ((td/2-handRailWidthL/2) - depthTreadOut/2) * bComplexRailLeft
					breakLineW				= brkLineY
					bRailAboveBreakLine		= 0
					gosub "left rail"
				else
					poly2_b 5, 1+2+64, gs_fill_pen, gs_back_pen,
						RailStartLLX,RailStartLY,1,
						RailBreakLLX,RailBreakLLY,1,
						RailBreakLRX,RailBreakLRY,1,
						RailStartLRX,RailStartLY,1,
						RailStartLLX,RailStartLY,-1
				endif
			endif

			if drawPart[2] & bShowRailOnFloorPlan and bShowRailAboveBreakLine then
				if aboveStory then
					railPen	= gs_LinePenStUp
					LINE_TYPE railLineType
				else
					if drawDashed[2] then
						LINE_TYPE dash_line
					else
						LINE_TYPE solid_line
					endif
				endif
				pen railPen
				FILL temp_FillTypeAbove

				if bSymbolic2D then
					bShowRailOn1stRun		= 1
					bShowRailOn2ndRun		= 0
					bBreakRailLine			= 1
					brLineAngle				= angle_breakline
					bShowRailPart2			= 1
					breakLineDist			= RailBreakLLY + handRailWidthL * TAN(angle_breakline) + ((td/2-handRailWidthL/2) - depthTreadOut/2) * bComplexRailLeft
					breakLineW				= brkLineY
					bRailAboveBreakLine		= 1
					gosub "left rail"

					bShowRailOn1stRun		= 0
					bShowRailOn2ndRun		= 1
					bBreakRailLine			= 0
					bRailAboveBreakLine		= 1
					gosub "left rail"
				else
					poly2_b 7, 1 + FullFill, gs_fill_pen, temp_BackPen,
						RailStartLLX,RailBreakLLY+brkLineY,1,
						RailCornerLLX,RailCornerLLY,1,
						RailEndLX,RailEndLLY,1,
						RailEndLX,RailEndLRY,1,
						RailCornerLRX,RailCornerLRY,1,
						RailStartLRX,RailBreakLRY+brkLineY,1,
						RailStartLLX,RailBreakLLY+brkLineY,-1
				endif
			endif

			if bShowRailAxis then
				line_type railAxisLineType
				pen gs_RailAxisPen

				if drawPart[1] then
					LINE2 RailStartLLX+handRailWidthL/2,RailStartLY,RailStartLLX+handRailWidthL/2,RailBreakLLY + handRailWidthL / 2 * TAN(angle_breakline)
				endif

				if drawPart[2] and bShowRailAboveBreakLine then
					LINE2 RailStartLLX+handRailWidthL/2,RailBreakLLY+brkLineY + handRailWidthL / 2 * TAN(angle_breakline),RailStartLLX+handRailWidthL/2,RailCornerLLY-handRailWidthL/2
					LINE2 RailStartLLX+handRailWidthL/2,RailCornerLLY-handRailWidthL/2,RailEndLX,RailCornerLLY-handRailWidthL/2
				endif
			endif
		endif

		if bShowRailOnFloorPlan then
			if bSameRails then
				RailUNID=1200
				HOTSPOT2 handRailWidthL/2, 	RailStartLY,	RailUNID, roffr, 1+128: RailUNID=RailUNID+1
				HOTSPOT2 handRailWidthL/2-roffr,RailStartLY,	RailUNID, roffr, 2: RailUNID=RailUNID+1
				HOTSPOT2 handRailWidthL/2+1,	RailStartLY,	RailUNID, roffr, 3: RailUNID=RailUNID+1

				IF gs_2DContourAbove=1 THEN
					HOTSPOT2 RailEndLX, ly+flw-handRailWidthL/2,	RailUNID, roffr, 1+128: RailUNID=RailUNID+1
					HOTSPOT2 RailEndLX,	ly+flw-handRailWidthL/2+roffr,	RailUNID, roffr, 2: RailUNID=RailUNID+1
					HOTSPOT2 RailEndLX,	ly+flw-handRailWidthL/2-1,	RailUNID, roffr, 3: RailUNID=RailUNID+1
				ENDIF
			else
				RailUNID=1100
				HOTSPOT2 handRailWidthL/2, 	RailStartLY,	RailUNID, roffl, 1+128: RailUNID=RailUNID+1
				HOTSPOT2 handRailWidthL/2-roffl,RailStartLY,	RailUNID, roffl, 2: RailUNID=RailUNID+1
				HOTSPOT2 handRailWidthL/2+1,	RailStartLY,	RailUNID, roffl, 3: RailUNID=RailUNID+1

				IF gs_2DContourAbove=1 THEN
					HOTSPOT2 RailEndLX, ly+flw-handRailWidthL/2,	RailUNID, roffl, 1+128: RailUNID=RailUNID+1
					HOTSPOT2 RailEndLX,	ly+flw-handRailWidthL/2+roffl,	RailUNID, roffl, 2: RailUNID=RailUNID+1
					HOTSPOT2 RailEndLX,	ly+flw-handRailWidthL/2-1,	RailUNID, roffl, 3: RailUNID=RailUNID+1
				ENDIF
			endif
		endif
	endif

	! --- Right Rail ---------------------------------------------------------------
	pen gs_cont_pen
	if rail_m = 2 | rail_m = 1 then		! Right, Both
		!!! *** Railings Points
		!!! at Start Step
		RailStartRLX=flw-handRailWidthR+roffr		!! Right
		RailStartRRX=flw+roffr

		RailStartRY=0

		!!! at Break Line
		MM=numSteptoBreakRight		!! Num. of Riser at Break Line
		N=numSteptoBreakRight		!! Num. of Riser

		RailBreakRLX=RailStartRLX		!!Right
		RailBreakRLY=N*depthTreadOut+(((N+3)*depthTreadIn-N*depthTreadOut)*RailBreakRLX)/flw
		RailBreakRRX=RailStartRRX
		RailBreakRRY=N*depthTreadOut+(((N+3)*depthTreadIn-N*depthTreadOut)*RailBreakRRX)/flw

		!!! at Corner
		RailCornerRLX=RailStartRLX				!!Right
		RailCornerRLY=ly+handRailWidthR-roffr
		RailCornerRRX=RailStartRRX
		RailCornerRRY=ly-roffr

		IF NOT(bComplexRailRight) THEN						!!Right
			RailEndRX=flw+lx-depthTreadIn
		ELSE
			RailEndRX=flw+lx-handRailWidthR
		ENDIF

		RailEndRLY=RailCornerRLY
		RailEndRRY=RailCornerRRY

		if drawPart[3] then
			if bShowRailOnFloorPlan then
				if aboveStory then
					railPen	= gs_LinePenStUp
					LINE_TYPE railLineType
				else
					if drawDashed[3] then
						LINE_TYPE dash_line
					else
						LINE_TYPE solid_line
					endif
				endif
				pen railPen

				if bSymbolic2D then
					bShowRailOn1stRun		= 1
					bShowRailOn2ndRun		= 1
					bBreakRailLine			= 0
					bRailAboveBreakLine		= 0
					gosub "right rail"
				else
					poly2_b 7, 1+2+64, gs_fill_pen, gs_back_pen,
						RailStartRLX,RailStartRY,1,
						RailCornerRLX,RailCornerRLY,1,
						RailEndRX,RailEndRLY,1,
						RailEndRX,RailEndRRY,1,
						RailCornerRRX,RailCornerRRY,1,
						RailStartRRX,RailStartRY,1,
						RailStartRLX,RailStartRY,-1
				endif
			endif

			if bShowRailAxis then
				line_type railAxisLineType
				pen gs_RailAxisPen
				LINE2 RailStartRLX+handRailWidthR/2,RailStartRY,RailStartRLX+handRailWidthR/2,RailCornerRLY-handRailWidthR/2
				LINE2 RailStartRLX+handRailWidthR/2,RailCornerRLY-handRailWidthR/2,RailEndRX,RailCornerRLY-handRailWidthR/2
			endif
		else
			if drawPart[1] & bShowRailOnFloorPlan then
				if aboveStory then
					railPen	= gs_LinePenStUp
					LINE_TYPE railLineType
				else
					if drawDashed[1] then
						LINE_TYPE dash_line
					else
						LINE_TYPE solid_line
					endif
				endif
				pen railPen

				if bSymbolic2D then
					bShowRailOn1stRun		= 1
					bShowRailOn2ndRun		= 0
					bBreakRailLine			= 1
					brLineAngle				= angle_breakline
					bShowRailPart1			= 1
					breakLineDist			= RailBreakRLY - depthTreadIn/2 + depthTreadIn/2 + handRailWidthR * TAN(angle_breakline)
					breakLineW				= brkLineY
					bRailAboveBreakLine		= 0
					gosub "right rail"
				else
					poly2_b 5, 1 + FullFill, gs_fill_pen, gs_back_pen,
						RailStartRLX,RailStartRY,1,
						RailBreakRLX,RailBreakRLY,1,
						RailBreakRRX,RailBreakRRY,1,
						RailStartRRX,RailStartRY,1,
						RailStartRLX,RailStartRY,-1
				endif
			endif

			if drawPart[2] & bShowRailOnFloorPlan and bShowRailAboveBreakLine then
				if aboveStory then
					railPen	= gs_LinePenStUp
					LINE_TYPE railLineType
				else
					if drawDashed[2] then
						LINE_TYPE dash_line
					else
						LINE_TYPE solid_line
					endif
				endif
				pen railPen
				FILL temp_FillTypeAbove

				if bSymbolic2D then
					bShowRailOn1stRun		= 1
					bShowRailOn2ndRun		= 0
					bBreakRailLine			= 1
					brLineAngle				= angle_breakline
					bShowRailPart2			= 1
					breakLineDist			= RailBreakRLY - depthTreadIn/2 + depthTreadIn/2 + handRailWidthR * TAN(angle_breakline)
					breakLineW				= brkLineY
					bRailAboveBreakLine		= 1
					gosub "right rail"

					bShowRailOn1stRun		= 0
					bShowRailOn2ndRun		= 1
					bBreakRailLine			= 0
					bRailAboveBreakLine		= 1
					gosub "right rail"
				else
					IF RailBreakRRY+brkLineY<=ly-roffr THEN
						poly2_b 7, 1 + FullFill, gs_fill_pen, temp_BackPen,
							RailStartRLX,RailBreakRLY+brkLineY,1,
							RailCornerRLX,RailCornerRLY,1,
							RailEndRX,RailEndRLY,1,
							RailEndRX,RailEndRRY,1,
							RailCornerRRX,RailCornerRRY,1,
							RailStartRRX,RailBreakRRY+brkLineY,1,
							RailStartRLX,RailBreakRLY+brkLineY,-1
					else
						poly2_b 7, 1 + FullFill, gs_fill_pen, temp_BackPen,
							RailStartRLX,RailStartRY,1,
							RailCornerRLX,RailCornerRLY,1,
							RailEndRX,RailEndRLY,1,
							RailEndRX,RailEndRRY,1,
							RailCornerRRX,RailCornerRRY,1,
							RailStartRRX,RailStartRY,1,
							RailStartRLX,RailStartRY,-1
					endif
				endif
			endif

			if bShowRailAxis then
				line_type railAxisLineType
				pen gs_RailAxisPen

				if drawPart[1] then
					LINE2 RailStartRLX+handRailWidthR/2,RailStartRY,RailStartRLX+handRailWidthR/2,RailBreakRLY + handRailWidthR / 2 * TAN(angle_breakline)
				endif
				if drawPart[2] then
					LINE2 RailStartRLX+handRailWidthR/2,RailBreakRLY+brkLineY + handRailWidthR / 2 * TAN(angle_breakline),RailStartRLX+handRailWidthR/2,RailCornerRLY-handRailWidthR/2
					LINE2 RailStartRLX+handRailWidthR/2,RailCornerRLY-handRailWidthR/2,RailEndRX,RailCornerRLY-handRailWidthR/2
				endif
			endif
		endif

		if bShowRailOnFloorPlan then
			RailUNID=1000
			HOTSPOT2 flw-handRailWidthR/2, 	RailStartRY,	RailUNID, roffr, 1+128: RailUNID=RailUNID+1
			HOTSPOT2 flw-handRailWidthR/2+roffr,RailStartRY,	RailUNID, roffr, 2: RailUNID=RailUNID+1
			HOTSPOT2 flw-handRailWidthR/2-1,	RailStartRY,	RailUNID, roffr, 3: RailUNID=RailUNID+1

			IF gs_2DContourAbove=1 THEN
				HOTSPOT2 RailEndRX, ly+handRailWidthR/2,	RailUNID, roffr, 1+128: RailUNID=RailUNID+1
				HOTSPOT2 RailEndRX,	ly+handRailWidthR/2-roffr,	RailUNID, roffr, 2: RailUNID=RailUNID+1
				HOTSPOT2 RailEndRX,	ly+handRailWidthR/2+1,	RailUNID, roffr, 3: RailUNID=RailUNID+1
			ENDIF
		endif
	endif
endif

END

"left rail":

	PostOffset=0
	PostOffsetHgt=0

	! ---  Rail on 1st Run -----------------------------------------------------
	if bShowRailOn1stRun then
		if bComplexRailLeft then
			ymeredek=(ly+flw+roffl-depthTreadOut)*TAN(SlabAlfaOut)
			ang=ATN(ymeredek/((ly+flw+roffl-depthTreadOut)))
		else
			ymeredek=(ly+flw+roffl)*TAN(SlabAlfaOut)
			ang=ATN(ymeredek/(ly+flw+roffl))
		endif

		ADD2 (flw-roffl+handRailWidthL/2)-flw, 0
		ROT2 90

		lraSimple=ly+flw+roffl
		lraComplex=(ly+flw+roffl-depthTreadOut)
		additionXComplex=depthTreadOut/2
		additionZComplex=0
		hrovL=td/2-handRailWidthL/2
		hrovR=td/2-handRailWidthL/2
		postNumber = npl
		side = SIDE_LEFT
		gosub "callRailsForStair"

		DEL 2
	endif

	! ---  Rail on 2nd Run -----------------------------------------------------
	if bShowRailOn2ndRun then
		add2 -flw, roffl-handRailWidthL/2+ly+flw

		if bComplexRailLeft then
			SimpleBarDiff=hrl-hrhl
			ymeredek=(lx+flw-depthTreadOut+roffl)*TAN(SlabAlfaOut)
			ang=ATN(ymeredek/(lx+flw+roffl-depthTreadOut))

			ADD2 flw-roffl+td/2, 0
			ADD2 -handRailWidthL-td/2, -handRailWidthL/2
		ELSE
			SimpleBarDiff = (hrl-bhl) * (leftRailType_m = 3)
			ymeredek=(lx+flw-depthTreadOut+roffl-handRailWidthL)*TAN(SlabAlfaOut)
			ang=ATN(ymeredek/(lx+flw+roffl-depthTreadOut-handRailWidthL))

			ADD2 flw-roffl+handRailWidthL, 0
			ADD2 -handRailWidthL, -handRailWidthL/2
		ENDIF

		IF hrtl_m = HANDRAIL_RECTANGULAR & not(bComplexRailLeft) & (leftRailType_m <> 3) THEN
			poly2_b 4, 1 + 2 * NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove + 4+64, gs_fill_pen, gs_back_pen,
				0, 0, 1,
				handRailWidthL, 0, 1,
				handRailWidthL, handRailWidthL, 1,
				0, handRailWidthL, 1
		ENDIF
		DEL 1

		lraSimple=lx+flw+roffl-depthTreadOut-handRailWidthL
		lraComplex=lx+flw+roffl-depthTreadOut
		additionXComplex=0
		additionZComplex=0
		hrovL=td/2-handRailWidthL
		hrovR=td/2-handRailWidthL
		postNumber = npl
		side = SIDE_LEFT
		gosub "callRailsForStair"

		DEL 2
	endif

return


"right rail":

	! ---  Rail on 1st Run -----------------------------------------------------
	if bShowRailOn1stRun then
		if bComplexRailRight then
			ymeredek=(ly-roffr-depthTreadIn)*TAN(SlabAlfa)
			ang=ATN(ymeredek/(ly-roffr-depthTreadIn))
		else
			ymeredek=(ly-roffr)*TAN(SlabAlfa)
			ang=ATN(ymeredek/(ly-roffr))
		endif

		ADD2 (flw+roffr-handRailWidthR/2), 0
		ROT2 90

		lraSimple=ly-roffr
		lraComplex=ly-roffr-depthTreadIn
		additionXComplex=depthTreadIn/2
		additionZComplex=0
		hrovL=depthTreadIn/2
		hrovR=depthTreadIn/2
		postNumber = npr
		side = SIDE_RIGHT
		gosub "callRailsForStair"

		DEL 2
	endif

	! --- Railing on the 2nd run -----------------------------------------------
	if bShowRailOn2ndRun then
		if bComplexRailRight then
			ymeredek=(lx-depthTreadIn-roffr)*TAN(SlabAlfa)
			PostOffset=-depthTreadIn/2
			ang=ATN(ymeredek/(lx-roffr-depthTreadIn))

			ADD2 flw+depthTreadIn, 0
		else
			ymeredek=(lx-depthTreadIn-roffr)*TAN(SlabAlfa)
			PostOffset=0
			ang=ATN(ymeredek/(lx-roffr-depthTreadIn))

			ADD2 flw+handRailWidthR, 0
		endif

		ADD2 0, ly-roffr+handRailWidthR/2
		ADD2 roffr, 0
		ADD2 -handRailWidthR+PostOffset, 0

		!!! Handrails Connection at Corner/Right Side
		SimpleBarDiff = (hrr-bhr) * (rightRailType_m = 3)
		ADD2 -handRailWidthR, -handRailWidthR/2
			IF NOT(bComplexRailRight) AND roffr >= 0 THEN
				IF (rightRailType_m = 3 & btypr_m = BAR_RECTANGULAR) | hrtr_m = HANDRAIL_RECTANGULAR THEN
					poly2_b 4, 1 + 2 * NOT(bRailAboveBreakLine) + bRailAboveBreakLine * gs_FillAbove + 4+64, gs_fill_pen, gs_back_pen,
						0, 0, 1,
						handRailWidthR, 0, 1,
						handRailWidthR, handRailWidthR, 1,
						0, handRailWidthR, 1
				endif
			ENDIF
		DEL 1

		lraSimple=lx-roffr-depthTreadIn
		lraComplex=lx-roffr-depthTreadIn
		additionXComplex=0
		additionZComplex=0
		hrovL=depthTreadIn/2
		hrovR=depthTreadIn/2
		postNumber = npr
		side = SIDE_RIGHT
		gosub "callRailsForStair"

		DEL 4
	endif

return

"callRailsForStair":
! ------------------------------------------------------------------------------
!	lraSimple
!	lraComplex
!	additionXComplex
!	additionZComplex
!	hrovL: rail overhang start
!	hrovR: rail overhang end
!	postNumber:   number of posts
!	side: SIDE_LEFT or SIDE_RIGHT
! ==============================================================================
	ani = ang
	additionXComplex = additionXComplex
	additionZComplex = additionZComplex
	gosub "callRails"
return

! ==============================================================================
"callRails":
! ------------------------------------------------------------------------------
!	ani
!	additionXComplex
!	additionZComplex
!	dsComplex
!  ------------------
!	side: SIDE_LEFT or SIDE_RIGHT
!	lraSimple
!	lraComplex
!	hrovL: rail overhang start
!	hrovR: rail overhang end
!	postNumber:   number of posts
! ==============================================================================
	if side = SIDE_LEFT then
		railBarDepth	= bwl
		railBarDiam		= bdl
		railHeight		= hrl
		railBarThk		= fthl
		handRailWidth	= handRailWidthL
		railDist		= dsl
		railType_m		= leftRailType_m
		railPostDia		= pdl
		railPostWidth	= pwl
		railPostThk		= pthl
		railPostType	= ptl_m
		nBarsRail		= nbl
		bt_m			= btl_m
		railFramesWSide	= fswl
		railFramesWTop	= ftwl
		railFramesWBot	= fbwl
		railBarHeight	= bhl
		railBarFillThk	= bthl
		abdist			= abdistl
		railFrameMat	= fmatl
		railBaluFillMat	= bmatl
		railPostMat		= pmatl
		nbt				= nbtl
		railFillDist	= fdfl
		bComplexRail	= bComplexRailLeft
	else
		railBarDepth	= bwr
		railBarDiam		= bdr
		railHeight		= hrr
		railBarThk		= fthr
		handRailWidth	= handRailWidthR
		railDist		= dsr
		railType_m		= rightRailType_m
		railPostDia		= pdr
		railPostWidth	= pwr
		railPostThk		= pthr
		railPostType	= ptr_m
		nBarsRail		= nbr
		bt_m			= btr_m
		railFramesWSide	= fswr
		railFramesWTop	= ftwr
		railFramesWBot	= fbwr
		railBarHeight	= bhr
		railBarFillThk	= bthr
		abdist			= abdistr
		railFrameMat	= fmatr
		railBaluFillMat	= bmatr
		railPostMat		= pmatr
		nbt				= nbtr
		railFillDist	= fdfr
		bComplexRail	= bComplexRailRight
	endif

	add2 additionXComplex * bComplexRail, 0
	call "railSymbol2D_m" parameters all	cfs					= 1,
											bEnable2DPosts		= bComplexRail,
											ptyp_m				= 1,
											ani					= ani,
											rom_m				= 1,
											rmm_m				= 1,
											LengthSize			= 0,
											lra					= lraSimple * NOT(bComplexRail) + lraComplex * (bComplexRail),
											hr					= railHeight,
											hrPerp				= railHeight,
											ab					= 0,
											rb					= 0,
											ds					= railDist,
											gs_AngleL			= 90,
											gs_AngleR			= 90,
											iHandRailStyle		= 1,
											handRailDiameter	= handRailWidth,
											handRailWidth		= handRailWidth,
											hroL				= hrovL,
											hroR				= hrovR,
											np					= postNumber,
											pd					= railPostDia,
											pw					= railPostWidth,
											pth					= railPostThk,
											gs_cont_pen			= railPen,
											sa					= 0,
											bBreakRailLine		= bBreakRailLine,
											breakLineAngle		= brLineAngle,
											breakLineDist		= breakLineDist,
											breakLineWidth		= brkLineY,
											bRailAboveBreakLine	= bRailAboveBreakLine,
											bShowRailBelowBrL	= bShowRailPart1,
											bShowRailAboveBrL	= bShowRailPart2,
											bPostNoCalculation	= (railType_m = 9),
											pit_m				= 1,
											dp					= abdist,
											nbt					= nbt
	del 1

	bShowRailPart1			= 0
	bShowRailPart2			= 0

return


