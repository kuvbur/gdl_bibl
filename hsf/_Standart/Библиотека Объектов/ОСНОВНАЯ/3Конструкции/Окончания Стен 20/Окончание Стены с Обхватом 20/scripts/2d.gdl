
!text2 0, 0, SYMB_MIRRORED

rot2 -90

if GLOB_STRUCTURE_DISPLAY <> STRUCTURE_ENTIRE_STRUCTURE then end
! ==============================================================================
! THE WALL AREA
! ==============================================================================
drawindex 30
if WALL_COMPS_NAME = "" or WALL_SKINS_NUMBER < EPS then

! ===== SIMPLE WALL =====

	pen WALL_SECT_PEN

	! --- draw contours ---
	startY = yWallStart
	endY = yWallEnd
	call "SkinRect" PARAMETERS startX = 0, startY = startY,
			endX = length, endY = endY,
			innerRadius = r0, outerRadius = r0 + WALL_THICKNESS,
			incAngle = wallIncl, trapType = 1,

			startLinePen = WALL_SECT_PEN,
			startLineLineType = WALL_LINETYPE,
			startLineCont = 1,

			topLinePen = WALL_SECT_PEN,
			topLineLineType = WALL_LINETYPE,
			topLineCont = 1,

			bottomLinePen = WALL_SECT_PEN,
			bottomLineLineType = WALL_LINETYPE,
			bottomLineCont = 1

	! --- cut contours (if skin type: 2 - above cutplane) ---
	startSkin  = 0
	if WALL_SKINS_NUMBER > EPS then
		for i = 1 to WALL_SKINS_NUMBER
			startSkin = endSkin
			endSkin = startSkin + WALL_SKINS_PARAMS[i][SKIN_THICKNESS]
			if abs(WALL_SKINS_PARAMS[i][SKIN_TYPE] - 2) < EPS then
				call "SkinRect" PARAMETERS startX = 0, startY = startSkin,
						endX = length, endY = endSkin,
						innerRadius = r0, outerRadius = r0 + WALL_THICKNESS,
						incAngle = wallIncl, trapType = trapType,
						fillType = 1
			endif
		next i
	endif

else

! ===== COMPOSITE WALL =====

	! --- index of the last core skin (which goes trapeze) ---
	trapezoidCoreSkin = 0
	for j = 1 to WALL_SKINS_NUMBER
		if abs(WALL_SKINS_PARAMS [j][SKIN_THICKEN_TRAPEZOID] - 1) < EPS then
			trapezoidCoreSkin = j
		endif
	next j

	! --- composite wall`s parameters---
	currBeg = 0
	for i = 1 to WALL_SKINS_NUMBER
		if (i >= trapezoidCoreSkin and SYMB_MIRRORED) or (i <= trapezoidCoreSkin and not(SYMB_MIRRORED)) or abs(wallIncl) < EPS then
			skinThickness = WALL_SKINS_PARAMS[i][SKIN_THICKNESS]
		else
			skinThickness = WALL_SKINS_PARAMS[i][SKIN_THICKNESS] / cos(wallIncl)
		endif
		startSkin = currBeg
		endSkin = currBeg + skinThickness

		if (i > trapezoidCoreSkin and SYMB_MIRRORED) or (i < trapezoidCoreSkin and not(SYMB_MIRRORED)) then
			trapType = 0
		else
			if trapezoidCoreSkin = i then

				compositeThickness = 0
				for j = 1 to WALL_SKINS_NUMBER
					if (j >= trapezoidCoreSkin and SYMB_MIRRORED) or (j <= trapezoidCoreSkin and not(SYMB_MIRRORED)) or abs(wallIncl) < EPS then
						compositeThickness = compositeThickness + WALL_SKINS_PARAMS[j][SKIN_THICKNESS]
					else
						compositeThickness = compositeThickness + WALL_SKINS_PARAMS[j][SKIN_THICKNESS] / cos(wallIncl)
					endif
				next j
				if (WALL_END_THICKNESS <= WALL_START_THICKNESS) then
					modifier = WALL_END_THICKNESS - compositeThickness
				else
					modifier = WALL_START_THICKNESS - compositeThickness
				endif

				if onWallBeg then
					if WALL_THICKNESS > WALL_END_THICKNESS then
						modifier = modifier + WALL_THICKNESS - WALL_END_THICKNESS
					endif
				else
					if WALL_THICKNESS > WALL_START_THICKNESS then
						modifier = modifier + (WALL_THICKNESS - WALL_START_THICKNESS)
					endif
				endif
				endSkin = endSkin + modifier
				currBeg = currBeg + modifier
				trapType = 1
			else
				trapType = 2
			endif
		endif

		! --- draw contours (if skin type: 0 - cut) ---
		if ((endSkin > EPS and startSkin < endSkin) or trapezoidCoreSkin = i) and abs(WALL_SKINS_PARAMS[i][SKIN_TYPE]) < EPS then
			if i = iLeftMost then
				topLinePen = WALL_SKINS_PARAMS[i][SKIN_UPPER_LINE_PEN]
			else
				topLinePen = 0
			endif
			if i = iRightMost then
				bottomLinePen = WALL_SKINS_PARAMS[i][SKIN_LOWER_LINE_PEN]
			else
				bottomLinePen = 0
			endif

			call "SkinRect" PARAMETERS startX = 0, startY = startSkin,
					endX = length, endY = endSkin,
					innerRadius = r0, outerRadius = r0 + WALL_THICKNESS,
					incAngle = wallIncl, trapType = trapType,

					startLinePen = WALL_SKINS_PARAMS[i][SKIN_END_FACE_PEN],
					startLineLineType = WALL_SKINS_PARAMS[i][SKIN_END_LINE_TYPE],
					startLineCont = 1,

					bottomLinePen = bottomLinePen,
					bottomLineLineType = WALL_SKINS_PARAMS[i][SKIN_END_LINE_TYPE],
					bottomLineCont = 1,

					topLinePen = topLinePen,
					topLineLineType = WALL_SKINS_PARAMS[i][SKIN_END_LINE_TYPE],
					topLineCont = 1
		else
		! --- cut contours (if skin type: 2 - above cutplane) ---
			if abs(WALL_SKINS_PARAMS[i][SKIN_TYPE] - 2) < EPS then
				call "SkinRect" PARAMETERS startX = 0, startY = startSkin,
						endX = length, endY = endSkin,
						innerRadius = r0, outerRadius = r0 + WALL_THICKNESS,
						incAngle = wallIncl, trapType = trapType,
						fillType = 1
			endif
		endif

		currBeg = currBeg + skinThickness

	next i

endif

if 0 then
	wallline2 0, 0, 1, 0
endif

! ==============================================================================
! THE END-CAP
! ==============================================================================
drawindex 20
line_type 1
fill gs_fill_type

call "SkinRect" PARAMETERS startX = -thickCap, startY = yWallStart-thickFirst,
		endX = length, endY = yWallStart,
		innerRadius = r0, outerRadius = r0 + WALL_THICKNESS,
		incAngle = wallIncl, trapType = trapFirst,
		fillPen = gs_fill_pen, fillBGPen = gs_back_pen,
		startLinePen = gs_cont_pen, startLineCont = 1,
		endLinePen = gs_cont_pen, endLineCont = 1,
		bottomLinePen = 0, topLinePen = gs_cont_pen, topLineCont = 1
call "SkinRect" PARAMETERS startX = -thickCap, startY = yWallEnd,
		endX = length, endY = yWallEnd + thickSecond,
		innerRadius = r0, outerRadius = r0 + WALL_THICKNESS,
		incAngle = wallIncl, trapType = trapSecond,
		fillPen = gs_fill_pen, fillBGPen = gs_back_pen,
		startLinePen = gs_cont_pen, startLineCont = 1,
		endLinePen = gs_cont_pen, endLineCont = 1,
		bottomLinePen = gs_cont_pen, bottomLineCont = 1, topLinePen = 0
call "SkinRect" PARAMETERS startX = -thickCap, startY = yWallStart,
		endX = 0, endY = yWallEnd,
		innerRadius = r0, outerRadius = r0 + WALL_THICKNESS,
		incAngle = wallIncl, trapType = 1,
		fillPen = gs_fill_pen, fillBGPen = gs_back_pen,
		startLinePen = gs_cont_pen, startLineCont = 1


! ==============================================================================
! HOTSPOTS
! ==============================================================================

unID = 1

! --- editable side hotspots ---
xMidHotspot = (length - thickCap) / 2
addition1First = 0
addition1Second = 0
addition3First = 0
addition3Second = 0
if SYMB_MIRRORED then
	addition1First = xMidHotspot * tan(wallIncl)
	addition3First = length * tan(wallIncl)
else
	addition1Second = xMidHotspot * tan(wallIncl)
	addition3Second = length * tan(wallIncl)
endif

xMoveTo = xMidHotspot
gosub 1

if SYMB_MIRRORED then
	HOTSPOT2 0, addition1First + yWallStart, unID, thickOtherSide, 1+128				! base
	unID = unID + 1
	HOTSPOT2 0, addition1First+0.1 + yWallStart, unID, thickOtherSide, 3				! reference
	unID = unID + 1
	HOTSPOT2 0, addition1First-thickOtherSide + yWallStart, unID, thickOtherSide, 2	! moving
	unID = unID + 1

	HOTSPOT2 0, addition1Second + yWallEnd, unID, thickRefSide, 1+128			! base
	unID = unID + 1
	HOTSPOT2 0, addition1Second + yWallEnd-0.1, unID, thickRefSide, 3			! reference
	unID = unID + 1
	HOTSPOT2 0, addition1Second + yWallEnd+thickRefSide, unID, thickRefSide, 2	! moving
	unID = unID + 1
else
	HOTSPOT2 0, addition1First + yWallStart, unID, thickRefSide, 1+128				! base
	unID = unID + 1
	HOTSPOT2 0, addition1First+0.1 + yWallStart, unID, thickRefSide, 3				! reference
	unID = unID + 1
	HOTSPOT2 0, addition1First-thickRefSide + yWallStart, unID, thickRefSide, 2		! moving
	unID = unID + 1

	HOTSPOT2 0, addition1Second + yWallEnd, unID, thickOtherSide, 1+128			! base
	unID = unID + 1
	HOTSPOT2 0, addition1Second + yWallEnd-0.1, unID, thickOtherSide, 3			! reference
	unID = unID + 1
	HOTSPOT2 0, addition1Second + yWallEnd+thickOtherSide, unID, thickOtherSide, 2	! moving
	unID = unID + 1
endif

del moveStepNum

! --- fix hotspots ---

xMoveTo = length
gosub 1
HOTSPOT2 0, additionIfMirr+yWallStart-thickFirst, unID	! fix
unID = unID + 1
HOTSPOT2 0, additionNotMirr+yWallEnd+thickSecond, unID	! fix
unID = unID + 1
del moveStepNum

xMoveTo = -thickCap
gosub 1
HOTSPOT2 0, additionIfMirr+yWallStart-thickFirst, unID	! fix
unID = unID + 1
HOTSPOT2 0, additionNotMirr+yWallEnd+thickSecond, unID	! fix
unID = unID + 1
del moveStepNum

! --- editable hotspot on the main side ---

yMainSideHotspot = (-thickFirst + yWallStart + thickSecond + yWallEnd) / 2
if r0 < EPS then

	HOTSPOT2 0, yMainSideHotspot, unID, thickCap, 1+128		! base
	unID = unID + 1
	HOTSPOT2 0.1, yMainSideHotspot, unID, thickCap, 3		! reference
	unID = unID + 1
	HOTSPOT2 -thickCap, yMainSideHotspot, unID, thickCap, 2	! moving
	unID = unID + 1


else

	revAngleExtra = 0
	if onWallBeg then
		revAngleExtra = 512
	endif
	HOTSPOT2 0, yMainSideHotspot, unID, thickCapAngle, 4+128	! base
	unID = unID + 1
	xMoveTo = 0.1
	gosub 1
	HOTSPOT2 0, yMainSideHotspot, unID, thickCapAngle, 7		! reference
	unID = unID + 1
	del moveStepNum
	xMoveTo = -thickCap
	gosub 1
	HOTSPOT2 0, yMainSideHotspot, unID, thickCapAngle, 5, thickCap		! moving - display param: thickCap
	unID = unID + 1
	del moveStepNum
	if onWallBeg then
		HOTSPOT2 0, r0+WALL_THICKNESS, unID, thickCapAngle, 6+revAngleExtra	! centerpoint
	else
		HOTSPOT2 0, -r0, unID, thickCapAngle, 6+revAngleExtra				! centerpoint
	endif
	unID = unID + 1

endif

! --- replace AC hotspots at the ends ---
call "Resize Wall End" PARAMETERS GS_HotspotUnIDBegin = 20000,
		cutWidthAngle = cutWidthAngle, AC_CutWidth = AC_CutWidth,
		r0 = r0, wallIncl = wallIncl, onWallBeg = onWallBeg


! --- draw view and overhead skins ---
drawindex 10
currBeg = 0
firstStart = 0

for i = 1 to WALL_SKINS_NUMBER
	skinThickness = WALL_SKINS_PARAMS[i][SKIN_THICKNESS]
	startSkin = currBeg
	endSkin = currBeg + skinThickness

	if (i < iLeftmost or i > iRightmost) and (endSkin > EPS and startSkin + EPS < endSkin) then

		startLinePen	= WALL_SKINS_PARAMS[i][SKIN_END_FACE_PEN]
		if i + 1 = iLeftMost then
			bottomLinePen	= 0
		else
			bottomLinePen	= WALL_SKINS_PARAMS[i][SKIN_LOWER_LINE_PEN]
		endif
		if i - 1 = iRightmost then
			topLinePen		= 0
		else
			topLinePen		= WALL_SKINS_PARAMS[i][SKIN_UPPER_LINE_PEN]
		endif

		pen startLinePen
		line_type WALL_SKINS_PARAMS[i][SKIN_END_LINE_TYPE]
		line_property 0

		! Overhead view
		! ----------------------------------------------------------------------
		if round_int(WALL_SKINS_PARAMS[i][SKIN_TYPE]) = 2 then
			if i < iLeftmost then
				firstStart = 0
				if i = iLeftmost - 1 then line2 length, endSkin, length, firstStart
			endif
			if i > iRightmost then
				if firstStart = 0 then firstStart = startSkin
				if i = WALL_SKINS_NUMBER then line2 length, endSkin, length, firstStart
			endif
		else
		! Uncut view
		! ----------------------------------------------------------------------
			if i > iLeftmost then
				line2 length, endSkin, length, startSkin
			endif
			if i < iRightmost then
				line2 length, endSkin, length, startSkin
			endif
		endif

		line_type 1
		if abs(WALL_SKINS_PARAMS[i][SKIN_TYPE] - 1) < EPS then
			fillPattern = WALL_SKINS_PARAMS[i][SKIN_FILL]
		else
			fillPattern = 0
		endif
		if GLOB_CONTEXT = 5 then lengthOver = length else lengthOver = 0
		call "SkinRect" PARAMETERS startX = -thickCap, startY = startSkin,
				endX = lengthOver, endY = endSkin,
				innerRadius = r0, incAngle = wallIncl,
				trapType = 0,
				fillPattern = fillPattern, fillPen = WALL_SKINS_PARAMS[i][SKIN_FILL_PEN], fillBGPen = WALL_SKINS_PARAMS[i][SKIN_FILL_BACK_PEN],
				fillType = 2,
				bLocalFill = WALL_SKINS_PARAMS[i][SKIN_FILL_ORIENTATION], bCoverFill = 1,
				startLinePen	= startLinePen,		startLineLineType	= WALL_SKINS_PARAMS[i][SKIN_END_LINE_TYPE],	startLineCont	= 0,
				bottomLinePen	= bottomLinePen,	bottomLineLineType	= WALL_SKINS_PARAMS[i][SKIN_LOWER_LINE_TYPE],	bottomLineCont	= 0,
				topLinePen		= topLinePen,		topLineLineType		= WALL_SKINS_PARAMS[i][SKIN_UPPER_LINE_TYPE],	topLineCont		= 0
	endif

	currBeg = currBeg + skinThickness

next i

end


! =============================================================================
! === SUBROUTINES
! =============================================================================

! =============================================================================
!		Move the coorinate system to a given X coordinate
! -----------------------------------------------------------------------------
! Input Parameters:
!	r0:			inner radius of the curved wall (0 otherwise)
!	wallIncl:	signed inclination of trapeze wall (0 otherwise)
!	alpha:		angle of the object in curved wall
!	length:		full length of the object
!	xMoveTo:	the X coordinate to move to
! Output:
!	additionIfMirr:		Y addition at the current X position if SYMB_MIRRORED = 1
!	additionNotMirr:	Y addition at the current X position if SYMB_MIRRORED = 0
!	moveStepNum:		number of the transformation added by the subroutine
! Remark:
!	The macro moves the coordinate system to the desired X coordinate,
!	after the place operation write a 'del moveStepNum' command
! =============================================================================

1:

additionIfMirr = 0
additionNotMirr = 0
if r0 > EPS then

	if onWallBeg then
		add2 0, r0+WALL_THICKNESS
		rot2 alpha * xMoveTo / length
		add2 0, -r0-WALL_THICKNESS
	else
		add2 0, -r0
		rot2 -alpha * xMoveTo / length
		add2 0, r0
	endif

	moveStepNum = 3

else

	if SYMB_MIRRORED then
		additionIfMirr = xMoveTo * tan(wallIncl)
	else
		additionNotMirr = xMoveTo * tan(wallIncl)
	endif

	add2 xMoveTo, 0
	moveStepNum = 1

endif

return


