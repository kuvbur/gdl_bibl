
EPS				= 0.0001
minSize			= 0.20
minHood			= 0.40
newEdgeLength	= 2.00
minSinkCounter	= 0.3

! ------------------------------------------------------------------------------
! Maximum Elements
! ------------------------------------------------------------------------------
nMaxAccessory		= 8
nMaxSegment			= 20
newElementDistance	= 0.1
ovenH				= 0.5

! ------------------------------------------------------------------------------
! Definitions
! ------------------------------------------------------------------------------
dim stLayoutType[6]
	stLayoutType[1] = `Прямая`
	stLayoutType[2] = `L-образная`
	stLayoutType[3] = `U-образная`
	stLayoutType[4] = `Камбуз`
	stLayoutType[5] = `Остров`
	stLayoutType[6] = `Специальная`

LAYOUT_STRAIGHT		= 1
LAYOUT_L_SHAPE		= 2
LAYOUT_U_SHAPE		= 3
LAYOUT_GALLEY		= 4
LAYOUT_ISLAND		= 5
LAYOUT_CUSTOM		= 6

SYMBTYPE_TALL		= 1
SYMBTYPE_SINK		= 2
SYMBTYPE_COOKTOP	= 3
SYMBTYPE_OVEN		= 4
SYMBTYPE_REFRI		= 5
SYMBTYPE_DISHWASH	= 6
SYMBTYPE_WASH		= 7

dim stSinkType[6]
	stSinkType[1] = `Круглая`
	stSinkType[2] = `Односпальная`
	stSinkType[3] = `Одна Чаша с Крылом`
	stSinkType[4] = `Двуспальная`
	stSinkType[5] = `Две Чаши с Крылом`
	stSinkType[6] = `Три Чаши`

ACC_SINK_ROUND			= 1
ACC_SINK_SINGLE			= 2
ACC_SINK_SINGLE_DRAIN	= 3
ACC_SINK_DOUBLE			= 4
ACC_SINK_DOUBLE_DRAIN	= 5
ACC_SINK_TRIPLE			= 6

dim stCooktopType[3]
	stCooktopType[1] = `2 конфорки`
	stCooktopType[2] = `4 конфорки`
	stCooktopType[3] = `5 конфорок`

ACC_COOKTOP_2	= 1
ACC_COOKTOP_4	= 2
ACC_COOKTOP_5	= 3

dim stHoodType[3]
	stHoodType[1] = `Настенная`
	stHoodType[2] = `Подвесная`
	stHoodType[3] = `Встроенная`

ACC_HOOD_WALL		= 1
ACC_HOOD_HANGING	= 2
ACC_HOOD_BUILTIN	= 3

dim stRefrigeratorType[5]
	stRefrigeratorType[1] = `Морозильная Камера Вверху`
	stRefrigeratorType[2] = `Морозильная Камера Внизу`
	stRefrigeratorType[3] = `Морозильная Камера Сбоку`
	stRefrigeratorType[4] = `Французская Дверь`
	stRefrigeratorType[5] = `Компактный`

ACC_REFRI_TOP		= 1
ACC_REFRI_BOTTOM	= 2
ACC_REFRI_SIDE		= 3
ACC_REFRI_FRENCH	= 4
ACC_REFRI_COMPACT	= 5

dim	stTextRot[3]
	stTextRot[1] = `Читаемый`
	stTextRot[2] = `Всегда Горизонтально`
	stTextRot[3] = `Выровнять по Символу`

dim stSymbType[2]
	stSymbType[1] = `Символический`
	stSymbType[2] = `Текст`

SYMBTYPE_SYMBOL		= 1
SYMBTYPE_TEXT		= 2


! ==============================================================================
!
! Default Change (only debug)
!
! ==============================================================================
if bChangeDefault then
	!Reference Line
	dim tempRefLinePoints_1[][2]
	dim tempRefLinePoints_2[][2]
	dim tempRefLinePoints_3[][2]
	tempRefLinePoints_1 = refLinePoints_1	: parameters tempRefLinePoints_1 = tempRefLinePoints_1
	tempRefLinePoints_2 = refLinePoints_2	: parameters tempRefLinePoints_2 = tempRefLinePoints_2
	tempRefLinePoints_3 = refLinePoints_3	: parameters tempRefLinePoints_3 = tempRefLinePoints_3

	!Wall Cabinet
	dim wallCabinetPos2_1[][2]
	dim wallCabinetPos2_2[][2]
	wallCabinetPos2_1 = wallCabinetPos_1	: parameters wallCabinetPos2_1	= wallCabinetPos2_1
	wallCabinetPos2_2 = wallCabinetPos_2	: parameters wallCabinetPos2_2	= wallCabinetPos2_2

	!Tall Cabinet
	dim tallCabinetWidth2[]
	dim tallCabPos2[][2]
	tallCabinetWidth2 = tallCabinetWidth	: parameters tallCabinetWidth2	= tallCabinetWidth2
	tallCabPos2 = tallCabPos				: parameters tallCabPos2		= tallCabPos2

	!Sink
	dim sinkWidth2[]
	dim sinkPos2[][2]
	sinkWidth2 = sinkWidth					: parameters sinkWidth2	= sinkWidth2
	sinkPos2 = sinkPos						: parameters sinkPos2	= sinkPos2

	!Cooktop
	dim cooktopWidth2[]
	dim cooktopPos2[][2]
	cooktopWidth2 = cooktopWidth			: parameters cooktopWidth2	= cooktopWidth2
	cooktopPos2 = cooktopPos				: parameters cooktopPos2	= cooktopPos2

	!Oven
	dim ovenWidth2[]
	dim ovenPos2[][2]
	ovenWidth2 = ovenWidth					: parameters ovenWidth2	= ovenWidth2
	ovenPos2 = ovenPos						: parameters ovenPos2	= ovenPos2

	!Refigerator
	dim refrigeratorWidth2[]
	dim refrigeratorPos2[][2]
	refrigeratorWidth2 = refrigeratorWidth	: parameters refrigeratorWidth2	= refrigeratorWidth2
	refrigeratorPos2 = refrigeratorPos		: parameters refrigeratorPos2	= refrigeratorPos2

	!DishWasher
	dim dishwasherWidth2[]
	dim dishwasherPos2[][2]
	dishwasherWidth2 = dishwasherWidth		: parameters dishwasherWidth2	= dishwasherWidth2
	dishwasherPos2 = dishwasherPos			: parameters dishwasherPos2		= dishwasherPos2

	!Washer
	dim washerWidth2[]
	dim washerPos2[][2]
	washerWidth2 = washerWidth				: parameters washerWidth2	= washerWidth2
	washerPos2 = washerPos					: parameters washerPos2		= washerPos2

endif


! ==============================================================================
!
! Geometry
!
! ==============================================================================

values "layoutType" stLayoutType
values "iLayoutType" LAYOUT_STRAIGHT, LAYOUT_L_SHAPE, LAYOUT_U_SHAPE, LAYOUT_GALLEY, LAYOUT_ISLAND, LAYOUT_CUSTOM
if GLOB_MODPAR_NAME = "layoutType" then
	iLayoutType = 1
	for i = 1 to vardim1(stLayoutType)
		if layoutType = stLayoutType[i] then
			iLayoutType = i
			i = vardim1(stLayoutType)
		endif
	next i
	parameters iLayoutType = iLayoutType
else
	iLayoutType = max(min(iLayoutType,vardim1(stLayoutType)),1)
	parameters layoutType = stLayoutType[iLayoutType]
endif

! ------------------------------------------------------------------------------
! Change Geometry
! ------------------------------------------------------------------------------
bGeometryChanged = 0
if	GLOB_MODPAR_NAME = "layoutType"			| \
	GLOB_MODPAR_NAME = "iLayoutType"		| \
	GLOB_MODPAR_NAME = "nChains"			| \
	GLOB_MODPAR_NAME = "nChains"			| \
	GLOB_MODPAR_NAME = "nChainSegment_1"	| \
	GLOB_MODPAR_NAME = "nChainSegment_2"	| \
	GLOB_MODPAR_NAME = "nChainSegment_3"	| \
	GLOB_MODPAR_NAME = "refLinePoints_1"	| \
	GLOB_MODPAR_NAME = "refLinePoints_2"	| \
	GLOB_MODPAR_NAME = "refLinePoints_3"	then
	bGeometryChanged = 1
endif

if GLOB_SCRIPT_TYPE = 2 | GLOB_SCRIPT_TYPE = 3 then
	if GLOB_CONTEXT = 1 | GLOB_CONTEXT = 5 then bGeometryChanged = 1	!! Always recalculate
endif

! ------------------------------------------------------------------------------
! References Line
! ------------------------------------------------------------------------------
dim bChains[3]
	bChains[1] = 1
	bChains[2] = (iLayoutType = LAYOUT_CUSTOM) * (nChains > 1)
	bChains[3] = (iLayoutType = LAYOUT_CUSTOM) * (nChains > 2)


dim	nRefPoint[6]
	nRefPoint[LAYOUT_STRAIGHT]	= 2
	nRefPoint[LAYOUT_L_SHAPE]	= 3
	nRefPoint[LAYOUT_U_SHAPE]	= 4
	nRefPoint[LAYOUT_GALLEY]	= 4
	nRefPoint[LAYOUT_ISLAND]	= 4
	nRefPoint[LAYOUT_CUSTOM]	= (nChainSegment_1 + 1) + bChains[2] * (nChainSegment_2 + 1) + bChains[3] * (nChainSegment_3 + 1)

nTotalRefPoint = nRefPoint[iLayoutType]

dim nRefPoints[3]
dim	bIsLine[]
dim refLinePoints[][2]

if iLayoutType <> LAYOUT_CUSTOM then
	for i = nTotalRefPoint to 1 step -1
		if i > 1 then bIsLine[i-1]	= 1
		refLinePoints[i][1]	= refLinePoints_1[i][1]
		refLinePoints[i][2]	= refLinePoints_1[i][2]
	next i
	nRefPoints[1] = nTotalRefPoint
	nRefPoints[2] = 0
	nRefPoints[3] = 0
else
	n = nTotalRefPoint

	! ------- Chain 3 --------
	if bChains[3] then
		nRefPoints[3] = nChainSegment_3 + 1

		! Check Segment Array
		if vardim1(refLinePoints_3) < nRefPoints[3] then
			nDimRefPoints = vardim1(refLinePoints_3)
			if nDimRefPoints >= 2 then
				tempDeltaX = refLinePoints_3[nDimRefPoints][1] - refLinePoints_3[nDimRefPoints-1][1]
				tempDeltaY = refLinePoints_3[nDimRefPoints][2] - refLinePoints_3[nDimRefPoints-1][2]

				if abs(tempDeltaX) < eps then
					if tempDeltaY > 0 then
						lastAngle = 270
					else
						lastAngle = 90
					endif
				else
					lastAngle = atn( tempDeltaY / tempDeltaX)
					if tempDeltaX > 0 then lastAngle = lastAngle + 180
				endif
			else
				lastAngle = 0
			endif

			dim tempRefLinePoints[][2]
			for i = nRefPoints[3] to nDimRefPoints+1 step -1
				tempRefLinePoints[i][1] = refLinePoints_3[nDimRefPoints][1] - (i-nDimRefPoints) * newEdgeLength * cos(lastAngle)
				tempRefLinePoints[i][2] = refLinePoints_3[nDimRefPoints][2] - (i-nDimRefPoints) * newEdgeLength * sin(lastAngle)
			next i
			for i = nDimRefPoints to 1 step -1
				tempRefLinePoints[i][1] = refLinePoints_3[i][1]
				tempRefLinePoints[i][2] = refLinePoints_3[i][2]
			next i
			dim refLinePoints_3[][2]
			refLinePoints_3 = tempRefLinePoints
			parameters refLinePoints_3 = refLinePoints_3
		endif

		! Calculate RefLinePoints
		for i = nRefPoints[3] to 1 step -1
			if i = 1 then
				bIsLine[n-1]	= 0
			else
				bIsLine[n-1]	= 1
			endif
			refLinePoints[n][1]	= refLinePoints_3[i][1]
			refLinePoints[n][2]	= refLinePoints_3[i][2]
			n = n - 1
		next i
	else
		nRefPoints[3] = 0
	endif

	! ------- Chain 2 --------
	if bChains[2] then
		nRefPoints[2] = nChainSegment_2 + 1

		! Check Segment Array
		if vardim1(refLinePoints_2) < nRefPoints[2] then
			nDimRefPoints = vardim1(refLinePoints_2)
			if nDimRefPoints >= 2 then
				tempDeltaX = refLinePoints_2[nDimRefPoints][1] - refLinePoints_2[nDimRefPoints-1][1]
				tempDeltaY = refLinePoints_2[nDimRefPoints][2] - refLinePoints_2[nDimRefPoints-1][2]
				if abs(tempDeltaX) < eps then
					if tempDeltaY > 0 then
						lastAngle = 270
					else
						lastAngle = 90
					endif
				else
					lastAngle = atn( tempDeltaY / tempDeltaX)
					if tempDeltaX > 0 then lastAngle = lastAngle + 180
				endif
			else
				lastAngle = 0
			endif

			dim tempRefLinePoints[][2]
			for i = nRefPoints[2] to nDimRefPoints+1 step -1
				tempRefLinePoints[i][1] = refLinePoints_2[nDimRefPoints][1] - (i-nDimRefPoints) * newEdgeLength * cos(lastAngle)
				tempRefLinePoints[i][2] = refLinePoints_2[nDimRefPoints][2] - (i-nDimRefPoints) * newEdgeLength * sin(lastAngle)
			next i
			for i = nDimRefPoints to 1 step -1
				tempRefLinePoints[i][1] = refLinePoints_2[i][1]
				tempRefLinePoints[i][2] = refLinePoints_2[i][2]
			next i
			dim refLinePoints_2[][2]
			refLinePoints_2 = tempRefLinePoints
			parameters refLinePoints_2 = refLinePoints_2
		endif

		! Calculate RefLinePoints
		for i = nRefPoints[2] to 1 step -1
			if i = 1 then
				bIsLine[n-1]	= 0
			else
				bIsLine[n-1]	= 1
			endif
			refLinePoints[n][1]	= refLinePoints_2[i][1]
			refLinePoints[n][2]	= refLinePoints_2[i][2]
			n = n - 1
		next i
	else
		nRefPoints[2] = 0
	endif

	! ------- Chain 1 --------
	nRefPoints[1] = nChainSegment_1 + 1

	! Check Segment Array
	if vardim1(refLinePoints_1) < nRefPoints[1] then
		nDimRefPoints = vardim1(refLinePoints_1)
		if nDimRefPoints >= 2 then
			tempDeltaX = refLinePoints_1[nDimRefPoints][1] - refLinePoints_1[nDimRefPoints-1][1]
			tempDeltaY = refLinePoints_1[nDimRefPoints][2] - refLinePoints_1[nDimRefPoints-1][2]
			if abs(tempDeltaX) < eps then
				if tempDeltaY > 0 then
					lastAngle = 270
				else
					lastAngle = 90
				endif
			else
				lastAngle = atn( tempDeltaY / tempDeltaX)
				if tempDeltaX > 0 then lastAngle = lastAngle + 180
			endif
		else
			lastAngle = 0
		endif

		dim tempRefLinePoints[][2]
		for i = nRefPoints[1] to nDimRefPoints+1 step -1
			tempRefLinePoints[i][1] = refLinePoints_1[nDimRefPoints][1] - (i-nDimRefPoints) * newEdgeLength * cos(lastAngle)
			tempRefLinePoints[i][2] = refLinePoints_1[nDimRefPoints][2] - (i-nDimRefPoints) * newEdgeLength * sin(lastAngle)
		next i
		for i = nDimRefPoints to 1 step -1
			tempRefLinePoints[i][1] = refLinePoints_1[i][1]
			tempRefLinePoints[i][2] = refLinePoints_1[i][2]
		next i
		dim refLinePoints_1[][2]
		refLinePoints_1 = tempRefLinePoints
		parameters refLinePoints_1 = refLinePoints_1
	endif

	! Calculate RefLinePoints
	for i = nRefPoints[1] to 1 step -1
		if i > 1 then bIsLine[n-1]	= 1
		refLinePoints[n][1]	= refLinePoints_1[i][1]
		refLinePoints[n][2]	= refLinePoints_1[i][2]
		n = n - 1
	next i
endif


if iLayoutType = LAYOUT_GALLEY | iLayoutType = LAYOUT_ISLAND then bIsLine[2] = 0
if iLayoutType = LAYOUT_ISLAND then
	nWallCabinet = 0
	refLinePoints[3][1] = refLinePoints[2][1]
	refLinePoints[3][2] = refLinePoints[2][2]
	refLinePoints[4][1] = refLinePoints[1][1]
	refLinePoints[4][2] = refLinePoints[1][2]
endif


! ------------------------------------------------------------------------------
! Calculate Contour Points
! ------------------------------------------------------------------------------
dim	oppsidePoints[][2]
dim contourPoints[][]
dim nContour[]
dim	refAngle[]
dim bIsSect[]
nPoly = 1

for i = nTotalRefPoint to 1 step -1
	if i = nTotalRefPoint | i = 1 then
		bIsSect[i] = 0
	else
		if bIsLine[i] & bIsLine[i-1] then
			bIsSect[i] = 1
		else
			bIsSect[i] = 0
		endif
	endif

	if i < nTotalRefPoint then
		tempDeltaX = refLinePoints[i+1][1] - refLinePoints[i][1]
		tempDeltaY = refLinePoints[i+1][2] - refLinePoints[i][2]

		if abs(tempDeltaX) < eps then
			if tempDeltaY > 0 then
				refAngle[i] = 270
			else
				refAngle[i] = 90
			endif
		else
			refAngle[i] = atn( tempDeltaY / tempDeltaX)
			if tempDeltaX > 0 then refAngle[i] = refAngle[i] + 180
		endif
	endif
next i

dim tempOffset[][2]
offsetSize = counterDepth
gosub "polyLineOffset"
oppsidePoints = tempOffset

startRef		= 1
nCurrentPoly	= 0
for i = 2 to min(nTotalRefPoint-1, vardim1(bIsLine))
	if not(bIsLine[i]) & bIsLine[i-1] then nPoly = nPoly + 1
next i

for i = 1 to nPoly
	nCurrentPoly = nCurrentPoly + 1
	gosub "fillContour"
	startRef = cur
next i


! ------------------------------------------------------------------------------
! Calculate Axis Points
! ------------------------------------------------------------------------------
dim	axisPoints[][2]
dim tempOffset[][2]
offsetSize = counterDepth / 2
gosub "polyLineOffset"
axisPoints = tempOffset



! ==============================================================================
!
! Elements
!
! ==============================================================================

! ------------------------------------------------------------------------------
! Accessory number
! ------------------------------------------------------------------------------
nofSink 			= bSink			* nSink
nofCooktops			= bCooktop		* nCooktops
nofOvens			= bOven			* nOvens
nofRefrigerators	= bRefrigerator	* nRefrigerators
nofDishwasher		= bDishwasher	* nDishwasher
nofWasher			= bWasher		* nWasher


! ------------------------------------------------------------------------------
! Accessory Elements Arrays
! ------------------------------------------------------------------------------
dim bElemPosChanged[]
dim bNewElementPos[]
dim elementPos[][2]
dim elementSizes[]
dim elementTypes[][2]
dim nIsSegment[]
nElement 	= nTallCabinet + nofSink + nofCooktops + nofOvens + nofRefrigerators + nofDishwasher + nofWasher
nE = nElement

dim	isTall[]
bChange = (GLOB_MODPAR_NAME = "nTallCabinet" | bGeometryChanged)
for i = nTallCabinet to 1 step -1
	elementPos[nE][1]	= tallCabPos[i][1]
	elementPos[nE][2]	= tallCabPos[i][2]
	bElemPosChanged[nE]	= (abs(tallCabPos[i][1] - tallCabPos2[i][1]) > EPS | abs(tallCabPos[i][2] - tallCabPos2[i][2]) > EPS | bChange | nSegmentTall[i] = 0)
	bNewElementPos[nE]	= (i > nPrevTallCabinet)
	nIsSegment[nE]		= nSegmentTall[i]
	elementSizes[nE]	= tallCabinetWidth[i]
	elementTypes[nE][1]	= SYMBTYPE_TALL
	elementTypes[nE][2]	= i
	isTall[i]			= nE
	nE = nE - 1
next i

dim	isSink[]
bChange = (GLOB_MODPAR_NAME = "bSink" | GLOB_MODPAR_NAME = "nSink" | bGeometryChanged)
for i = nofSink to 1 step -1
	elementPos[nE][1]	= sinkPos[i][1]
	elementPos[nE][2]	= sinkPos[i][2]
	bElemPosChanged[nE]	= (abs(sinkPos[i][1] - sinkPos2[i][1]) > EPS | abs(sinkPos[i][2] - sinkPos2[i][2]) > EPS | bChange | nSegmentSink[i] = 0)
	bNewElementPos[nE]	= (i > nPrevSink)
	nIsSegment[nE]		= nSegmentSink[i]
	elementSizes[nE]	= sinkWidth[i]
	elementTypes[nE][1]	= SYMBTYPE_SINK
	elementTypes[nE][2]	= i
	isSink[i]			= nE
	nE = nE - 1
next i

dim	isCooktop[]
bChange = (GLOB_MODPAR_NAME = "bCooktoop" | GLOB_MODPAR_NAME = "nCooktops" | bGeometryChanged)
for i = nofCooktops to 1 step -1
	elementPos[nE][1]	= cooktopPos[i][1]
	elementPos[nE][2]	= cooktopPos[i][2]
	bElemPosChanged[nE]	= (abs(cooktopPos[i][1] - cooktopPos2[i][1]) > EPS | abs(cooktopPos[i][2] - cooktopPos2[i][2]) > EPS | bChange | nSegmentCooktop[i] = 0)
	bNewElementPos[nE]	= (i > nPrevCooktops)
	nIsSegment[nE]		= nSegmentCooktop[i]
	elementSizes[nE]	= cooktopWidth[i]
	elementTypes[nE][1]	= SYMBTYPE_COOKTOP
	elementTypes[nE][2]	= i
	isCooktop[i]		= nE
	nE = nE - 1
next i

dim	isOven[]
bChange = (GLOB_MODPAR_NAME = "bOven" | GLOB_MODPAR_NAME = "nOvens" | bGeometryChanged)
for i = nofOvens to 1 step -1
	elementPos[nE][1]	= ovenPos[i][1]
	elementPos[nE][2]	= ovenPos[i][2]
	bElemPosChanged[nE]	= (abs(ovenPos[i][1] - ovenPos2[i][1]) > EPS | abs(ovenPos[i][2] - ovenPos2[i][2]) > EPS | bChange | nSegmentOven[i] = 0)
	bNewElementPos[nE]	= (i > nPrevOvens)
	nIsSegment[nE]		= nSegmentOven[i]
	elementSizes[nE]	= ovenWidth[i]
	elementTypes[nE][1]	= SYMBTYPE_OVEN
	elementTypes[nE][2]	= i
	isOven[i]			= nE
	nE = nE - 1
next i

dim	isRefri[]
bChange = (GLOB_MODPAR_NAME = "bRefrigerator" | GLOB_MODPAR_NAME = "nRefrigerators" | bGeometryChanged)
for i = nofRefrigerators to 1 step -1
	elementPos[nE][1]	= refrigeratorPos[i][1]
	elementPos[nE][2]	= refrigeratorPos[i][2]
	bElemPosChanged[nE]	= (abs(refrigeratorPos[i][1] - refrigeratorPos2[i][1]) > EPS | abs(refrigeratorPos[i][2] - refrigeratorPos2[i][2]) > EPS | bChange | nSegmentRefri[i] = 0)
	bNewElementPos[nE]	= (i > nPrevRefri)
	nIsSegment[nE]		= nSegmentRefri[i]
	elementSizes[nE]	= refrigeratorWidth[i]
	elementTypes[nE][1]	= SYMBTYPE_REFRI
	elementTypes[nE][2]	= i
	isRefri[i]			= nE
	nE = nE - 1
next i

dim	isDishwash[]
bChange = (GLOB_MODPAR_NAME = "bDishwasher" | GLOB_MODPAR_NAME = "nDishwasher" | bGeometryChanged)
for i = nofDishwasher to 1 step -1
	elementPos[nE][1]	= dishwasherPos[i][1]
	elementPos[nE][2]	= dishwasherPos[i][2]
	bElemPosChanged[nE]	= (abs(dishwasherPos[i][1] - dishwasherPos2[i][1]) > EPS | abs(dishwasherPos[i][2] - dishwasherPos2[i][2]) > EPS | bChange | nSegmentDishwasher[i] = 0)
	bNewElementPos[nE]	= (i > nPrevDishwasher)
	nIsSegment[nE]		= nSegmentDishwasher[i]
	elementSizes[nE]	= dishwasherWidth[i]
	elementTypes[nE][1]	= SYMBTYPE_DISHWASH
	elementTypes[nE][2]	= i
	isDishwash[i]		= nE
	nE = nE - 1
next i

dim	isWasher[]
bChange = (GLOB_MODPAR_NAME = "bWasher" | GLOB_MODPAR_NAME = "nWasher" | bGeometryChanged)
for i = nofWasher to 1 step -1
	elementPos[nE][1]	= washerPos[i][1]
	elementPos[nE][2]	= washerPos[i][2]
	bElemPosChanged[nE]	= (abs(washerPos[i][1] - washerPos2[i][1]) > EPS | abs(washerPos[i][2] - washerPos2[i][2]) > EPS | bChange | nSegmentWasher[i] = 0)
	bNewElementPos[nE]	= (i > nPrevWasher)
	nIsSegment[nE]		= nSegmentWasher[i]
	elementSizes[nE]	= washerWidth[i]
	elementTypes[nE][1]	= SYMBTYPE_WASH
	elementTypes[nE][2]	= i
	isWasher[i]			= nE
	nE = nE - 1
next i


! ------------------------------------------------------------------------------
! Elements Position
! ------------------------------------------------------------------------------
dim elementXY[][2]
dim elementAngle[]
dim elementWidth[][4]

for i = nElement to 1 step -1
	if bNewElementPos[i] then		!New accessory, place out the contour
		nIsSegment[i] = 1
		elementAngle[i] = refAngle[1]
		elementXY[i][1] = refLinePoints[1][1]+cos(elementAngle[i])*(elementSizes[i]/2 + lastPointLength + newElementDistance) + cos(90-elementAngle[i]) * counterDepth / 2
		elementXY[i][2] = refLinePoints[1][2]+sin(elementAngle[i])*(elementSizes[i]/2 + lastPointLength + newElementDistance) - sin(90-elementAngle[i]) * counterDepth / 2
		lastPointLength = lastPointLength + newElementDistance + elementSizes[i]
		bElemPosChanged[i] = 1
	else
		if bElemPosChanged[i] then
			!Point Distances
			dim axisDistance[][3]	!(1) distance, (2,3) projection points x,y
			dim srcPolygon[5][2]
			xp = elementPos[i][1]
			yp = elementPos[i][2]

			bFound = 0
			for j = nTotalRefPoint-1 to 1 step -1
				if bIsLine[j] then
					x11 = axisPoints[j][1]
					y11 = axisPoints[j][2]
					x12 = axisPoints[j+1][1]
					y12 = axisPoints[j+1][2]
					gosub "pointLineDistance"
					axisDistance[j][1] = dist
					axisDistance[j][2] = xx
					axisDistance[j][3] = yy

					srcPolygon[1][1] = refLinePoints[j][1]
					srcPolygon[1][2] = refLinePoints[j][2]
					srcPolygon[2][1] = refLinePoints[j+1][1]
					srcPolygon[2][2] = refLinePoints[j+1][2]
					srcPolygon[3][1] = oppsidePoints[j+1][1]
					srcPolygon[3][2] = oppsidePoints[j+1][2]
					srcPolygon[4][1] = oppsidePoints[j][1]
					srcPolygon[4][2] = oppsidePoints[j][2]
					srcPolygon[5][1] = refLinePoints[j][1]
					srcPolygon[5][2] = refLinePoints[j][2]
					pntX = xp
					pntY = yp
					gosub "pointInsidePolygon"
					if ret = 1 then
						axisDistance[j][1] = axisDistance[j][1] - counterDepth / 2
						bFound = 1
						nIsSegment[i] = j
						j = 1
					endif
				endif
			next j

			!Segment Definitions
			if not(bFound) then
				nIsSegment[i] = 1
				distMin = 9999999
				for j = 1 to nTotalRefPoint-1
					if bIsLine[j] then
						if axisDistance[j][1] < distMin then
							distMin = axisDistance[j][1]
							nIsSegment[i] = j
						endif
					endif
				next j
			endif

			elementXY[i][1] = axisDistance[nIsSegment[i]][2]
			elementXY[i][2] = axisDistance[nIsSegment[i]][3]
			elementAngle[i] = refAngle[nIsSegment[i]]
		else
			elementXY[i][1] = elementPos[i][1]
			elementXY[i][2] = elementPos[i][2]
			elementAngle[i] = refAngle[nIsSegment[i]]
		endif
	endif

	!Position
	elementWidth[i][1] = elementXY[i][1]+cos(elementAngle[i])*elementSizes[i] / 2
	elementWidth[i][2] = elementXY[i][2]+sin(elementAngle[i])*elementSizes[i] / 2
	elementWidth[i][3] = elementXY[i][1]-cos(elementAngle[i])*elementSizes[i] / 2
	elementWidth[i][4] = elementXY[i][2]-sin(elementAngle[i])*elementSizes[i] / 2

	n = elementTypes[i][2]
	if n > 0 & n <= nMaxAccessory & bElemPosChanged[i] then

		if elementTypes[i][1] = SYMBTYPE_TALL & GLOB_MODPAR_NAME <> "tallCabinetWidth" & GLOB_MODPAR_NAME <> "tallCabinetWidth2" then
			tallCabPos[n][1]	= elementXY[i][1]
			tallCabPos[n][2]	= elementXY[i][2]
			tallCabPos2[n][1]	= elementXY[i][1]
			tallCabPos2[n][2]	= elementXY[i][2]
			nSegmentTall[n]		= nIsSegment[i]
			parameters	tallCabPos[n][1] 	= tallCabPos[n][1],
						tallCabPos[n][2] 	= tallCabPos[n][2],
						tallCabPos2[n][1]	= tallCabPos2[n][1],
						tallCabPos2[n][2]	= tallCabPos2[n][2],
						nSegmentTall[n]		= nSegmentTall[n]
		endif

		if elementTypes[i][1] = SYMBTYPE_SINK & GLOB_MODPAR_NAME <> "sinkWidth" & GLOB_MODPAR_NAME <> "sinkWidth2" & GLOB_MODPAR_NAME <> "sinkWidthHalf" then
			sinkPos[n][1]	= elementXY[i][1]
			sinkPos[n][2]	= elementXY[i][2]
			sinkPos2[n][1]	= elementXY[i][1]
			sinkPos2[n][2]	= elementXY[i][2]
			nSegmentSink[n]	= nIsSegment[i]
			parameters	sinkPos[n][1] 	= sinkPos[n][1],
						sinkPos[n][2] 	= sinkPos[n][2],
				 		sinkPos2[n][1]	= sinkPos2[n][1],
						sinkPos2[n][2]	= sinkPos2[n][2],
						nSegmentSink[n]	= nSegmentSink[n]
		endif

		if elementTypes[i][1] = SYMBTYPE_COOKTOP & GLOB_MODPAR_NAME <> "cooktopWidth" & GLOB_MODPAR_NAME <> "cooktopWidth2" then
			cooktopPos[n][1]	= elementXY[i][1]
			cooktopPos[n][2]	= elementXY[i][2]
			cooktopPos2[n][1]	= elementXY[i][1]
			cooktopPos2[n][2]	= elementXY[i][2]
			nSegmentCooktop[n]	= nIsSegment[i]
			parameters	cooktopPos[n][1]	= cooktopPos[n][1],
						cooktopPos[n][2]	= cooktopPos[n][2],
						sinkPos2[n][1]		= sinkPos2[n][1],
						sinkPos2[n][2]		= sinkPos2[n][2],
						nSegmentSink[n]		= nSegmentSink[n]
		endif

		if elementTypes[i][1] = SYMBTYPE_OVEN & GLOB_MODPAR_NAME <> "ovenWidth" & GLOB_MODPAR_NAME <> "ovenWidth2" then
			ovenPos[n][1]	= elementXY[i][1]
			ovenPos[n][2]	= elementXY[i][2]
			ovenPos2[n][1]	= elementXY[i][1]
			ovenPos2[n][2]	= elementXY[i][2]
			nSegmentOven[n]	= nIsSegment[i]
			parameters	ovenPos[n][1]	= ovenPos[n][1],
						ovenPos[n][2]	= ovenPos[n][2],
						ovenPos2[n][1]	= ovenPos2[n][1],
						ovenPos2[n][2]	= ovenPos2[n][2],
						nSegmentOven[n]	= nSegmentOven[n]
		endif

		if elementTypes[i][1] = SYMBTYPE_REFRI & GLOB_MODPAR_NAME <> "refrigeratorWidth" & GLOB_MODPAR_NAME <> "refrigeratorWidth2" then
			refrigeratorPos[n][1]	= elementXY[i][1]
			refrigeratorPos[n][2]	= elementXY[i][2]
			refrigeratorPos2[n][1]	= elementXY[i][1]
			refrigeratorPos2[n][2]	= elementXY[i][2]
			nSegmentRefri[n]		= nIsSegment[i]
			parameters	refrigeratorPos[n][1]	= refrigeratorPos[n][1],
						refrigeratorPos[n][2]	= refrigeratorPos[n][2],
						refrigeratorPos2[n][1]	= refrigeratorPos2[n][1],
						refrigeratorPos2[n][2]	= refrigeratorPos2[n][2],
						nSegmentRefri[n]		= nSegmentRefri[n]
		endif

		if elementTypes[i][1] = SYMBTYPE_DISHWASH & GLOB_MODPAR_NAME <> "dishwasherWidth" & GLOB_MODPAR_NAME <> "dishwasherWidth2" then
			dishwasherPos[n][1]		= elementXY[i][1]
			dishwasherPos[n][2]		= elementXY[i][2]
			dishwasherPos2[n][1]	= elementXY[i][1]
			dishwasherPos2[n][2]	= elementXY[i][2]
			nSegmentDishwasher[n]	= nIsSegment[i]
			parameters	dishwasherPos[n][1] = dishwasherPos[n][1],
						dishwasherPos[n][2] = dishwasherPos[n][2],
						dishwasherPos2[n][1]	= dishwasherPos2[n][1],
						dishwasherPos2[n][2]	= dishwasherPos2[n][2],
						nSegmentDishwasher[n]	= nSegmentDishwasher[n]
		endif

		if elementTypes[i][1] = SYMBTYPE_WASH & GLOB_MODPAR_NAME <> "washerWidth" & GLOB_MODPAR_NAME <> "washerWidth2" then
			washerPos[n][1]		= elementXY[i][1]
			washerPos[n][2]		= elementXY[i][2]
			washerPos2[n][1]	= elementXY[i][1]
			washerPos2[n][2]	= elementXY[i][2]
			nSegmentWasher[n]	= nIsSegment[i]
			parameters	washerPos[n][1] = washerPos[n][1],
						washerPos[n][2] = washerPos[n][2],
						washerPos2[n][1]	= washerPos2[n][1],
						washerPos2[n][2]	= washerPos2[n][2],
						nSegmentWasher[n]	= nSegmentWasher[n]
		endif
	endif

next i

dim bOvenInTall[]
for i = nofOvens to 1 step -1
	bOvenInTall[i] = 0
	for j = 1 to nTallCabinet
		if nSegmentOven[i] = nSegmentTall[j] then
			tx1 = cos(refAngle[nSegmentTall[j]]) * (tallCabinetWidth[j]/2-EPS)
			ty1 = sin(refAngle[nSegmentTall[j]]) * (tallCabinetWidth[j]/2-EPS)

			tx2 = sin(refAngle[nSegmentTall[j]]) * (counterDepth/2-EPS)
			ty2 = cos(refAngle[nSegmentTall[j]]) * (counterDepth/2-EPS)

			tx3 = sin(refAngle[nSegmentTall[j]]) * (-counterDepth/2+EPS)
			ty3 = cos(refAngle[nSegmentTall[j]]) * (-counterDepth/2+EPS)

			dim tallPolygon[5][2]
			srcPolygon[1][1] = tallCabPos[j][1] + tx1 + tx2
			srcPolygon[1][2] = tallCabPos[j][2] + ty1 - ty2
			srcPolygon[2][1] = tallCabPos[j][1] - tx1 + tx2
			srcPolygon[2][2] = tallCabPos[j][2] - ty1 - ty2
			srcPolygon[3][1] = tallCabPos[j][1] - tx1 + tx3
			srcPolygon[3][2] = tallCabPos[j][2] - ty1 - ty3
			srcPolygon[4][1] = tallCabPos[j][1] + tx1 + tx3
			srcPolygon[4][2] = tallCabPos[j][2] + ty1 - ty3
			srcPolygon[5][1] = tallCabPos[j][1] + tx1 + tx2
			srcPolygon[5][2] = tallCabPos[j][2] + ty1 - ty2
			pntX = ovenPos[i][1]
			pntY = ovenPos[i][2]

			gosub "pointInsidePolygon"

			if ret = 1 then
				bOvenInTall[i] = 1
			else
				bOvenInTall[i] = 0
			endif
		endif
	next j
next i


! ==============================================================================
!
! Wall Cabinet
!
! ==============================================================================

if nWallCabinet > 0 then
	bChange = (GLOB_MODPAR_NAME = "nWallCabinet" | bGeometryChanged)
	bWallChangeNum = bChange
	dim bWallCabChange[]
	if not(bChange) then
		for i = nWallCabinet to 1 step -1
			bWallCabChange[i]	= ( abs(wallCabinetPos_1[i][1] - wallCabinetPos2_1[i][1]) > EPS | \
									abs(wallCabinetPos_1[i][2] - wallCabinetPos2_1[i][2]) > EPS | \
									abs(wallCabinetPos_2[i][1] - wallCabinetPos2_2[i][1]) > EPS | \
									abs(wallCabinetPos_2[i][2] - wallCabinetPos2_2[i][2]) > EPS | \
									nWallSegment[i][1] = 0 | nWallSegment[i][2] = 0)
			if bWallCabChange[i] then bWallChangeNum = bWallChangeNum + 1
		next i
	else
		for i = nWallCabinet to 1 step -1
			bWallCabChange[i] = bChange
		next i
	endif

	if bWallChangeNum > 0 then

		! Calculate Wall Cabinet Axis Points
		dim	wallAxisPoints[][2]
		dim tempOffset[][2]
		offsetSize = wallCabinetDepth / 2
		gosub "polyLineOffset"
		wallAxisPoints = tempOffset

		dim wallOppside[][2]
		dim tempOffset[][2]
		offsetSize = wallCabinetDepth
		gosub "polyLineOffset"
		wallOppside = tempOffset

		dim bisectAngle[]
		dim axisSectDist[]

		for i = nTotalRefPoint - 1 to 2 step -1
			bisectAngle[i-1]	= (refAngle[i] - refAngle[i-1]) / 2
			axisSectDist[i-1]	= tan(bisectAngle[i-1]) * (wallCabinetDepth / 2)
		next i


		for i = nWallCabinet to 1 step -1
			if bWallCabChange[i] then
				dim wallElementXY[4]
				dim wallAxisDistance[][6]	!(1) distance, (2,3) projection points x,y
				dim srcPolygon[5][2]

				for j = nTotalRefPoint-1 to 1 step -1
					if bIsLine[j] then
						srcPolygon[1][1] = refLinePoints[j][1]
						srcPolygon[1][2] = refLinePoints[j][2]
						srcPolygon[2][1] = refLinePoints[j+1][1]
						srcPolygon[2][2] = refLinePoints[j+1][2]
						srcPolygon[3][1] = oppsidePoints[j+1][1]
						srcPolygon[3][2] = oppsidePoints[j+1][2]
						srcPolygon[4][1] = oppsidePoints[j][1]
						srcPolygon[4][2] = oppsidePoints[j][2]
						srcPolygon[5][1] = refLinePoints[j][1]
						srcPolygon[5][2] = refLinePoints[j][2]

						for h = 2 to 1 step -1
							if h = 1 then
								xp = wallCabinetPos_1[i][1]
								yp = wallCabinetPos_1[i][2]
							else
								xp = wallCabinetPos_2[i][1]
								yp = wallCabinetPos_2[i][2]
							endif

							x11 = wallAxisPoints[j][1]
							y11 = wallAxisPoints[j][2]
							x12 = wallAxisPoints[j+1][1]
							y12 = wallAxisPoints[j+1][2]

							bStartSegment	= 0
							bEndSegment		= 0
							if j = 1 then
								bStartSegment	= 1
							else
								if not(bIsLine[j-1]) then bStartSegment	= 1
							endif
							if j = nTotalRefPoint-1 then
								bEndSegment = 1
							else
								if not(bIsLine[j+1]) then bEndSegment = 1
							endif

							if bStartSegment & bEndSegment then
								gosub "pointLineDistance"
							else
								gosub "pointSegmentDistance"

								if state = 1 & bStartSegment then
									gosub "pointLineDistance"
								else
									if state = 2 & bEndSegment then
										gosub "pointLineDistance"
									endif
								endif
							endif

							wallAxisDistance[j][(h-1)*3+1] = dist
							wallAxisDistance[j][(h-1)*3+2] = xx
							wallAxisDistance[j][(h-1)*3+3] = yy

							pntX = xp
							pntY = yp
							gosub "pointInsidePolygon"
							if ret = 1 then wallAxisDistance[j][(h-1)*3+1] = wallAxisDistance[j][(h-1)*3+1] - counterDepth / 2
						next h
					endif
				next j


				!Segment Definitions
				nWallSegment[i][1] = 1
				nWallSegment[i][2] = 1
				distMin1 = 9999999
				distMin2 = 9999999
				for j = 1 to nTotalRefPoint-1
					if bIsLine[j] then
						if wallAxisDistance[j][1] < distMin1 then
							distMin1 = wallAxisDistance[j][1]
							nWallSegment[i][1] = j
						endif
						if wallAxisDistance[j][4] < distMin2 then
							distMin2 = wallAxisDistance[j][4]
							nWallSegment[i][2] = j
						endif
					endif
				next j

				wallElementXY[4] = wallAxisDistance[nWallSegment[i][2]][6]
				wallElementXY[3] = wallAxisDistance[nWallSegment[i][2]][5]
				wallElementXY[2] = wallAxisDistance[nWallSegment[i][1]][3]
				wallElementXY[1] = wallAxisDistance[nWallSegment[i][1]][2]

				wallCabinetPos_2[i][2]	= wallElementXY[4]
				wallCabinetPos_2[i][1]	= wallElementXY[3]
				wallCabinetPos_1[i][2]	= wallElementXY[2]
				wallCabinetPos_1[i][1]	= wallElementXY[1]

				parameters	wallCabinetPos_1[i][1]	= wallCabinetPos_1[i][1],
							wallCabinetPos_1[i][2]	= wallCabinetPos_1[i][2],
							wallCabinetPos_2[i][1]	= wallCabinetPos_2[i][1],
							wallCabinetPos_2[i][2]	= wallCabinetPos_2[i][2]

				parameters	wallCabinetPos2_1[i][1]	= wallCabinetPos_1[i][1],
							wallCabinetPos2_1[i][2]	= wallCabinetPos_1[i][2],
							wallCabinetPos2_2[i][1]	= wallCabinetPos_2[i][1],
							wallCabinetPos2_2[i][2]	= wallCabinetPos_2[i][2]


				! Continuous
				if nWallSegment[i][1] <= nWallSegment[i][2] then
					bWallReverse = 0
					tempSegment1 = nWallSegment[i][1]
					tempSegment2 = nWallSegment[i][2]
					tempXY1 = 1
					tempXY2 = 3
				else
					bWallReverse = 1
					tempSegment1 = nWallSegment[i][2]
					tempSegment2 = nWallSegment[i][1]
					tempXY1 = 3
					tempXY2 = 1
				endif

				isWallContinuous[i] = 1
				for j = tempSegment1 to tempSegment2
					if not(bIsLine[j]) then
						isWallContinuous[i] = 0
						j = tempSegment2
					endif
				next j
				parameters isWallContinuous[i] = isWallContinuous[i]


				! ----- Turning -----
				if isWallContinuous[i] & iLayoutType<>LAYOUT_STRAIGHT & iLayoutType<>LAYOUT_GALLEY & iLayoutType<>LAYOUT_ISLAND then
					bTurnEnd	= 0
					bTurnStart	= 0
					dim sectPoints[2][4]

					distStart1	= sqr( (wallAxisPoints[tempSegment1  ][1]-wallElementXY[tempXY1])^2 + (wallAxisPoints[tempSegment1  ][2]-wallElementXY[tempXY1+1])^2 )
					distStart2	= sqr( (wallAxisPoints[tempSegment1+1][1]-wallElementXY[tempXY1])^2 + (wallAxisPoints[tempSegment1+1][2]-wallElementXY[tempXY1+1])^2 )
					distEnd1	= sqr( (wallAxisPoints[tempSegment2  ][1]-wallElementXY[tempXY2])^2 + (wallAxisPoints[tempSegment2  ][2]-wallElementXY[tempXY2+1])^2 )
					distEnd2	= sqr( (wallAxisPoints[tempSegment2+1][1]-wallElementXY[tempXY2])^2 + (wallAxisPoints[tempSegment2+1][2]-wallElementXY[tempXY2+1])^2 )

					bStartSegment1	= 0
					bEndSegment1	= 0
					bStartSegment2	= 0
					bEndSegment2	= 0
					if tempSegment1 = 1 then
						bStartSegment1	= 1
					else
						if not(bIsLine[tempSegment1-1]) then bStartSegment1	= 1
					endif
					if tempSegment1 = nTotalRefPoint-1 then
						bEndSegment1 = 1
					else
						if not(bIsLine[tempSegment1+1]) then bEndSegment1 = 1
					endif

					if tempSegment2 = 1 then
						bStartSegment2	= 1
					else
						if not(bIsLine[tempSegment2-1]) then bStartSegment2	= 1
					endif
					if tempSegment2 = nTotalRefPoint-1 then
						bEndSegment2 = 1
					else
						if not(bIsLine[tempSegment2+1]) then bEndSegment2 = 1
					endif


					if bStartSegment1 then
						if distStart2 < abs(axisSectDist[tempSegment1])-EPS then

							x11 = refLinePoints[tempSegment1][1]
							y11 = refLinePoints[tempSegment1][2]
							x12 = refLinePoints[tempSegment1+1][1]
							y12 = refLinePoints[tempSegment1+1][2]

							x21 = wallOppside[tempSegment1+1][1]
							y21 = wallOppside[tempSegment1+1][2]
							x22 = wallOppside[tempSegment1+2][1]
							y22 = wallOppside[tempSegment1+2][2]

							gosub "intersection_Segment_Segment"

							if state = 1 then
								bTurnStart			= 1
								sectPoints[1][1]	= cx
								sectPoints[1][2]	= cy
								sectPoints[1][3]	= refLinePoints[tempSegment1+1][1]
								sectPoints[1][4]	= refLinePoints[tempSegment1+1][2]
								tempSegment1		= tempSegment1 + 1
							else
								if state = 2 then
									bTurnStart			= 1
									sectPoints[1][1]	= refLinePoints[tempSegment1+1][1] + cos(90-refAngle[tempSegment1]) * wallCabinetDepth
									sectPoints[1][2]	= refLinePoints[tempSegment1+1][2] - sin(90-refAngle[tempSegment1]) * wallCabinetDepth
									sectPoints[1][3]	= refLinePoints[tempSegment1+1][1]
									sectPoints[1][4]	= refLinePoints[tempSegment1+1][2]
								endif
							endif
						endif
					else
						if distStart1 < abs(axisSectDist[tempSegment1-1])-EPS then

							x11 = refLinePoints[tempSegment1-1][1]
							y11 = refLinePoints[tempSegment1-1][2]
							x12 = refLinePoints[tempSegment1][1]
							y12 = refLinePoints[tempSegment1][2]

							x21 = wallOppside[tempSegment1][1]
							y21 = wallOppside[tempSegment1][2]
							x22 = wallOppside[tempSegment1+1][1]
							y22 = wallOppside[tempSegment1+1][2]

							gosub "intersection_Segment_Segment"

							if state = 1 then
								bTurnStart			= 1
								sectPoints[1][1]	= cx
								sectPoints[1][2]	= cy
								sectPoints[1][3]	= refLinePoints[tempSegment1][1]
								sectPoints[1][4]	= refLinePoints[tempSegment1][2]
							else
								if state = 2 then
									bTurnStart			= 1
									sectPoints[1][1]	= refLinePoints[tempSegment1][1] + cos(90-refAngle[tempSegment1-1]) * wallCabinetDepth
									sectPoints[1][2]	= refLinePoints[tempSegment1][2] - sin(90-refAngle[tempSegment1-1]) * wallCabinetDepth
									sectPoints[1][3]	= refLinePoints[tempSegment1][1]
									sectPoints[1][4]	= refLinePoints[tempSegment1][2]
									tempSegment1		= tempSegment1 - 1
								endif
							endif
						else
							if not(bEndSegment1) then
								if distStart2 < abs(axisSectDist[tempSegment1])-EPS then

									x11 = refLinePoints[tempSegment1][1]
									y11 = refLinePoints[tempSegment1][2]
									x12 = refLinePoints[tempSegment1+1][1]
									y12 = refLinePoints[tempSegment1+1][2]

									x21 = wallOppside[tempSegment1+1][1]
									y21 = wallOppside[tempSegment1+1][2]
									x22 = wallOppside[tempSegment1+2][1]
									y22 = wallOppside[tempSegment1+2][2]

									gosub "intersection_Segment_Segment"

									if state = 1 then
										bTurnStart			= 1
										sectPoints[1][1]	= cx
										sectPoints[1][2]	= cy
										sectPoints[1][3]	= refLinePoints[tempSegment1+1][1]
										sectPoints[1][4]	= refLinePoints[tempSegment1+1][2]
										tempSegment1		= tempSegment1 + 1
									else
										if state = 2 then
											bTurnStart			= 1
											sectPoints[1][1]	= refLinePoints[tempSegment1+1][1] + cos(90-refAngle[tempSegment1]) * wallCabinetDepth
											sectPoints[1][2]	= refLinePoints[tempSegment1+1][2] - sin(90-refAngle[tempSegment1]) * wallCabinetDepth
											sectPoints[1][3]	= refLinePoints[tempSegment1+1][1]
											sectPoints[1][4]	= refLinePoints[tempSegment1+1][2]
											tempSegment1		= tempSegment1 - 1
										endif
									endif
								endif
							endif
						endif
					endif


					if bEndSegment2 & tempSegment2-1 > 0 then
						if distEnd1 < abs(axisSectDist[tempSegment2-1])-EPS then

							x11 = refLinePoints[tempSegment2][1]
							y11 = refLinePoints[tempSegment2][2]
							x12 = refLinePoints[tempSegment2+1][1]
							y12 = refLinePoints[tempSegment2+1][2]

							x21 = wallOppside[tempSegment2-1][1]
							y21 = wallOppside[tempSegment2-1][2]
							x22 = wallOppside[tempSegment2][1]
							y22 = wallOppside[tempSegment2][2]

							gosub "intersection_Segment_Segment"

							if state = 1 then
								if not(tempSegment1 = tempSegment2) then
									bTurnEnd			= 1
									sectPoints[2][1]	= cx
									sectPoints[2][2]	= cy
									sectPoints[2][3]	= refLinePoints[tempSegment2][1]
									sectPoints[2][4]	= refLinePoints[tempSegment2][2]
									tempSegment2		= tempSegment2 - 1
								endif
							else
								if state = 2 then
									bTurnEnd			= 1
									sectPoints[2][1]	= refLinePoints[tempSegment2][1] + cos(90-refAngle[tempSegment2]) * wallCabinetDepth
									sectPoints[2][2]	= refLinePoints[tempSegment2][2] - sin(90-refAngle[tempSegment2]) * wallCabinetDepth
									sectPoints[2][3]	= refLinePoints[tempSegment2][1]
									sectPoints[2][4]	= refLinePoints[tempSegment2][2]
								endif
							endif
						endif
					else
						if distEnd2 < abs(axisSectDist[tempSegment2])-EPS then

							x11 = refLinePoints[tempSegment2+1][1]
							y11 = refLinePoints[tempSegment2+1][2]
							x12 = refLinePoints[tempSegment2+2][1]
							y12 = refLinePoints[tempSegment2+2][2]

							x21 = wallOppside[tempSegment2][1]
							y21 = wallOppside[tempSegment2][2]
							x22 = wallOppside[tempSegment2+1][1]
							y22 = wallOppside[tempSegment2+1][2]

							gosub "intersection_Segment_Segment"

							if state = 1 then
								bTurnEnd			= 1
								sectPoints[2][1]	= cx
								sectPoints[2][2]	= cy
								sectPoints[2][3]	= refLinePoints[tempSegment2+1][1]
								sectPoints[2][4]	= refLinePoints[tempSegment2+1][2]
							else
								if state = 2 then
									bTurnEnd			= 1
									sectPoints[2][1]	= refLinePoints[tempSegment2+1][1] + cos(90-refAngle[tempSegment2+1]) * wallCabinetDepth
									sectPoints[2][2]	= refLinePoints[tempSegment2+1][2] - sin(90-refAngle[tempSegment2+1]) * wallCabinetDepth
									sectPoints[2][3]	= refLinePoints[tempSegment2+1][1]
									sectPoints[2][4]	= refLinePoints[tempSegment2+1][2]
									tempSegment2		= tempSegment2 + 1
								endif
							endif
						else
							if not(bStartSegment2) then
								if distEnd1 < abs(axisSectDist[tempSegment2-1])-EPS then

									x11 = refLinePoints[tempSegment2][1]
									y11 = refLinePoints[tempSegment2][2]
									x12 = refLinePoints[tempSegment2+1][1]
									y12 = refLinePoints[tempSegment2+1][2]

									x21 = wallOppside[tempSegment2-1][1]
									y21 = wallOppside[tempSegment2-1][2]
									x22 = wallOppside[tempSegment2][1]
									y22 = wallOppside[tempSegment2][2]

									gosub "intersection_Segment_Segment"

									if state = 1 then
										if not(tempSegment1 = tempSegment2) then
											bTurnEnd			= 1
											sectPoints[2][1]	= cx
											sectPoints[2][2]	= cy
											sectPoints[2][3]	= refLinePoints[tempSegment2][1]
											sectPoints[2][4]	= refLinePoints[tempSegment2][2]
										endif
									else
										if state = 2 then
											bTurnEnd			= 1
											sectPoints[2][1]	= refLinePoints[tempSegment2][1] + cos(90-refAngle[tempSegment2]) * wallCabinetDepth
											sectPoints[2][2]	= refLinePoints[tempSegment2][2] - sin(90-refAngle[tempSegment2]) * wallCabinetDepth
											sectPoints[2][3]	= refLinePoints[tempSegment2][1]
											sectPoints[2][4]	= refLinePoints[tempSegment2][2]
										endif
									endif
								endif
							else
								if distStart2 < abs(axisSectDist[tempSegment2])-EPS then

									x11 = refLinePoints[tempSegment2+1][1]
									y11 = refLinePoints[tempSegment2+1][2]
									x12 = refLinePoints[tempSegment2+2][1]
									y12 = refLinePoints[tempSegment2+2][2]

									x21 = wallOppside[tempSegment2][1]
									y21 = wallOppside[tempSegment2][2]
									x22 = wallOppside[tempSegment2+1][1]
									y22 = wallOppside[tempSegment2+1][2]

									gosub "intersection_Segment_Segment"

									if state = 1 then

										bTurnStart			= 1
										sectPoints[1][1]	= cx
										sectPoints[1][2]	= cy
										sectPoints[1][3]	= refLinePoints[tempSegment2+1][1]
										sectPoints[1][4]	= refLinePoints[tempSegment2+1][2]
									else
										if state = 2 then
											bTurnStart			= 1
											sectPoints[1][1]	= refLinePoints[tempSegment2+1][1] + cos(90-refAngle[tempSegment2+1]) * wallCabinetDepth
											sectPoints[1][2]	= refLinePoints[tempSegment2+1][2] - sin(90-refAngle[tempSegment2+1]) * wallCabinetDepth
											sectPoints[1][3]	= refLinePoints[tempSegment2+1][1]
											sectPoints[1][4]	= refLinePoints[tempSegment2+1][2]
											tempSegment2		= tempSegment2 + 1
										endif
									endif
								endif
							endif
						endif
					endif
				endif

				if bWallReverse then
					nWallSegment[i][2]	= tempSegment1
					nWallSegment[i][1]	= tempSegment2
				else
					nWallSegment[i][1]	= tempSegment1
					nWallSegment[i][2]	= tempSegment2
				endif
				parameters	nWallSegment[i][1] = nWallSegment[i][1],
							nWallSegment[i][2] = nWallSegment[i][2]


				! ----- Route ----
				if isWallContinuous[i] then
					nWallContour[i]				= max(0, tempSegment2 - tempSegment1) + 2
					nCol						= nWallContour[i] * 2

					if bTurnEnd then
						wallCoords1[i][nCol]	= sectPoints[2][4]	: nCol = nCol - 1
						wallCoords1[i][nCol]	= sectPoints[2][3]	: nCol = nCol - 1
					else
						wallCoords1[i][nCol]	= wallElementXY[tempXY2+1] + sin(90-refAngle[tempSegment2]) * wallCabinetDepth / 2	: nCol = nCol - 1
						wallCoords1[i][nCol]	= wallElementXY[tempXY2  ] - cos(90-refAngle[tempSegment2]) * wallCabinetDepth / 2	: nCol = nCol - 1
					endif

					for j = tempSegment2 to tempSegment1+1 step -1
						wallCoords1[i][nCol]	= refLinePoints[j][2]	: nCol = nCol - 1
						wallCoords1[i][nCol]	= refLinePoints[j][1]	: nCol = nCol - 1
					next j

					if bTurnStart then
						wallCoords1[i][nCol]	= sectPoints[1][4]	: nCol = nCol - 1
						wallCoords1[i][nCol]	= sectPoints[1][3]	: nCol = nCol - 1
					else
						wallCoords1[i][nCol]	= wallElementXY[tempXY1+1] + sin(90-refAngle[tempSegment1]) * wallCabinetDepth / 2	: nCol = nCol - 1
						wallCoords1[i][nCol]	= wallElementXY[tempXY1  ] - cos(90-refAngle[tempSegment1]) * wallCabinetDepth / 2	: nCol = nCol - 1
					endif


					nCol						= nWallContour[i] * 2
					if bTurnEnd then
						wallCoords2[i][nCol]	= sectPoints[2][2]	: nCol = nCol - 1
						wallCoords2[i][nCol]	= sectPoints[2][1]	: nCol = nCol - 1
					else
						wallCoords2[i][nCol]	= wallElementXY[tempXY2+1] - sin(90-refAngle[tempSegment2]) * wallCabinetDepth / 2	: nCol = nCol - 1
						wallCoords2[i][nCol]	= wallElementXY[tempXY2  ] + cos(90-refAngle[tempSegment2]) * wallCabinetDepth / 2	: nCol = nCol - 1
					endif

					for j = tempSegment2 to tempSegment1+1 step -1
						wallCoords2[i][nCol]	= wallOppside[j][2]	: nCol = nCol - 1
						wallCoords2[i][nCol]	= wallOppside[j][1]	: nCol = nCol - 1
					next j

					if bTurnStart then
						wallCoords2[i][nCol]	= sectPoints[1][2]	: nCol = nCol - 1
						wallCoords2[i][nCol]	= sectPoints[1][1]	: nCol = nCol - 1
					else
						wallCoords2[i][nCol]	= wallElementXY[tempXY1+1] - sin(90-refAngle[tempSegment1]) * wallCabinetDepth / 2	: nCol = nCol - 1
						wallCoords2[i][nCol]	= wallElementXY[tempXY1  ] + cos(90-refAngle[tempSegment1]) * wallCabinetDepth / 2	: nCol = nCol - 1
					endif

				else

					dx = wallElementXY[tempXY2  ] - wallElementXY[tempXY1]
					dy = wallElementXY[tempXY2+1] - wallElementXY[tempXY1+1]
					if abs(dx) < EPS then
						if dy > 0 then
							wallAngle = 90
						else
							wallAngle = 270
						endif
					else
						wallAngle = atn(dy/dx)
						if dx > 0 then wallAngle = wallAngle + 180
					endif

					nWallContour[i]		= 2
					wallCoords1[i][4]	= wallElementXY[tempXY2+1] - sin(90-wallAngle) * wallCabinetDepth / 2
					wallCoords1[i][3]	= wallElementXY[tempXY2  ] + cos(90-wallAngle) * wallCabinetDepth / 2
					wallCoords1[i][2]	= wallElementXY[tempXY1+1] - sin(90-wallAngle) * wallCabinetDepth / 2
					wallCoords1[i][1]	= wallElementXY[tempXY1  ] + cos(90-wallAngle) * wallCabinetDepth / 2

					wallCoords2[i][4]	= wallElementXY[tempXY2+1] + sin(90-wallAngle) * wallCabinetDepth / 2
					wallCoords2[i][3]	= wallElementXY[tempXY2  ] - cos(90-wallAngle) * wallCabinetDepth / 2
					wallCoords2[i][2]	= wallElementXY[tempXY1+1] + sin(90-wallAngle) * wallCabinetDepth / 2
					wallCoords2[i][1]	= wallElementXY[tempXY1  ] - cos(90-wallAngle) * wallCabinetDepth / 2

				endif

				parameters nWallContour[i] = nWallContour[i]
				for j = 1 to nWallContour[i]
					parameters	wallCoords1[i][j*2-1]	= wallCoords1[i][j*2-1],
								wallCoords1[i][j*2]		= wallCoords1[i][j*2],
								wallCoords2[i][j*2-1]	= wallCoords2[i][j*2-1],
								wallCoords2[i][j*2]		= wallCoords2[i][j*2]
				next j

			endif
		next i
	endif
endif


! ------------------------------------------------------------------------------
! Accessories
! ------------------------------------------------------------------------------
if nofSink > 0 then
	gs_sink_type_m = 1
	!if iSinkType = ACC_SINK_ROUND			then gs_sink_type_m = 1
	if iSinkType = ACC_SINK_SINGLE			then gs_sink_type_m = 2
	if iSinkType = ACC_SINK_SINGLE_DRAIN	then gs_sink_type_m = 4
	if iSinkType = ACC_SINK_DOUBLE			then gs_sink_type_m = 3
	if iSinkType = ACC_SINK_DOUBLE_DRAIN	then gs_sink_type_m = 9
	if iSinkType = ACC_SINK_TRIPLE			then gs_sink_type_m = 8
endif

if nofCooktops > 0 then
	CooktopType_m = 2
	!if iCooktopType = ACC_COOKTOP_2	then CooktopType_m = 2
	if iCooktopType = ACC_COOKTOP_4		then CooktopType_m = 6
	if iCooktopType = ACC_COOKTOP_5		then CooktopType_m = 11

	if bHood then
		dim hoodWidthPos[][6]
		for i = nofCooktops to 1 step -1
			tx = sin(elementAngle[isCooktop[i]]) * counterDepth/2
			ty = cos(elementAngle[isCooktop[i]]) * counterDepth/2

			hoodWidthPos[i][1] = cooktopPos[i][1]-tx
			hoodWidthPos[i][2] = cooktopPos[i][2]+ty
			hoodWidthPos[i][3] = hoodWidthPos[i][1]+cos(elementAngle[isCooktop[i]])*hoodWidth[i] / 2
			hoodWidthPos[i][4] = hoodWidthPos[i][2]+sin(elementAngle[isCooktop[i]])*hoodWidth[i] / 2
			hoodWidthPos[i][5] = hoodWidthPos[i][1]-cos(elementAngle[isCooktop[i]])*hoodWidth[i] / 2
			hoodWidthPos[i][6] = hoodWidthPos[i][2]-sin(elementAngle[isCooktop[i]])*hoodWidth[i] / 2
		next i
	endif
endif

displayText =	nofOvens *			(iOvenSymbType		 = SYMBTYPE_TEXT) + \
				nofRefrigerators *	(iRefriSymbType		 = SYMBTYPE_TEXT) + \
				nofDishwasher *		(iDishwasherSymbType = SYMBTYPE_TEXT) + \
				nofWasher *			(iWasherSymbType	 = SYMBTYPE_TEXT)


! ==============================================================================
!
! End of Master Script
!
! ==============================================================================

goto "endMasterSript"

! ==============================================================================
! PolyLineOffset
! ------------------------------------------------------------------------------
! Input variables:
!	offsetSize:
!	refLinePoints[][2]:
!	bIsLine[]:
!	refAngle[]:
!	bIsSect[]:
! Returned variable:
!	tempOffset[][2]
! ==============================================================================
"polyLineOffset":
	dim tempPoints[][2]

	for i = nTotalRefPoint-1 to 1 step -1
		cx1 = refLinePoints[i][1] + cos(90-refAngle[i]) * offsetSize
		cy1 = refLinePoints[i][2] - sin(90-refAngle[i]) * offsetSize

		cx2 = refLinePoints[i+1][1] + cos(90-refAngle[i]) * offsetSize
		cy2 = refLinePoints[i+1][2] - sin(90-refAngle[i]) * offsetSize

		tempPoints[i*2-1][1]	= cx1
		tempPoints[i*2-1][2]	= cy1
		tempPoints[i*2][1]		= cx2
		tempPoints[i*2][2]		= cy2
	next i

	for i = nTotalRefPoint to 1 step -1
		if bIsSect[i] then
			x11 = tempPoints[i*2][1]
			y11 = tempPoints[i*2][2]
			x12 = tempPoints[i*2-1][1]
			y12 = tempPoints[i*2-1][2]

			x21 = tempPoints[(i-1)*2-1][1]
			y21 = tempPoints[(i-1)*2-1][2]
			x22 = tempPoints[(i-1)*2][1]
			y22 = tempPoints[(i-1)*2][2]

			gosub "intersection_Line_Line"
			if state = 1 then
				tempOffset[i][1] = cx
				tempOffset[i][2] = cy
			else
				tempOffset[i][1] = tempPoints[i*2-1][1]
				tempOffset[i][2] = tempPoints[i*2-1][2]
			endif
		else
			if i = 1 then
				tempOffset[i][1] = tempPoints[1][1]
				tempOffset[i][2] = tempPoints[1][2]
			else
				if i = nTotalRefPoint then
					tempOffset[i][1] = tempPoints[(i-1)*2][1]
					tempOffset[i][2] = tempPoints[(i-1)*2][2]
				else
					if bIsLine[i] & not(bIsLine[i-1]) then
						tempOffset[i][1] = tempPoints[i*2-1][1]
						tempOffset[i][2] = tempPoints[i*2-1][2]
					else
						if not(bIsLine[i]) & bIsLine[i-1] then
							tempOffset[i][1] = tempPoints[(i-1)*2][1]
							tempOffset[i][2] = tempPoints[(i-1)*2][2]
						else
							!Nothing
							tempOffset[i][1] = 0
							tempOffset[i][2] = 0
						endif
					endif
				endif
			endif
		endif
	next i
return


! ==============================================================================
! Fill Polygon Contour
! ------------------------------------------------------------------------------
! Input variables:
!	nCurrentPoly:	current polygon number
!	startRef:		actual start point number
! Returned variable:
!	contourPoints:
!	nContour:
! ==============================================================================
"fillContour":
	cur = startRef

	if not(bIsLine[startRef]) then
		for k = startRef to nTotalRefPoint-1
			if bIsLine[k] then
				startRef = k
				cur = startRef
				k = nTotalRefPoint - 1
			endif
		next k
	endif

	for k = startRef to nTotalRefPoint
		put refLinePoints[cur][1], refLinePoints[cur][2]

		if k < nTotalRefPoint then
			if not(bIsLine[cur]) then
				k = nTotalRefPoint
			endif
		endif

		cur = cur + 1
	next k

	if (cur-1) > startRef then
		for k = (cur-1) to startRef step -1
			put oppsidePoints[k][1], oppsidePoints[k][2]
		next k
	endif

	if nsp > 7 then
		nContour[nCurrentPoly] = nsp/2
		pnum = nsp
		for k = 1 to pnum
			contourPoints[nCurrentPoly][k] = get(1)
		next k
	else
		print "Error in fill poly", nsp, cur
		for k = 1 to nsp
			temp = get(1)
		next k
	endif
return


! ==============================================================================
! Direction Angle
! ------------------------------------------------------------------------------
! Input variables:
!	vx, vy:		vector
!
! Returned variable:
!	angle:		direction angle of the vector
! ==============================================================================

"directionAngle":
	if abs(vx) < EPS & abs(vy) < EPS then
		angle = 0
		return
	endif

	if abs(vx) < EPS then
		if vy > 0 then
			angle = 90
		else
			angle = 270
		endif
	else
		angle = atn(vy / vx)
		if vx >= 0 then
			if angle < 0 then
				angle = angle + 360
			endif
		else
			angle = 180 + angle
		endif
	endif
return


! ==============================================================================
! Line - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12	line #1
!	x21,y21, x22,y22	line #2
!
! Returned variables:
!	state:			   -1 = no intersection point, coincident lines
!						0 = no intersection point, parallel lines
!						1 = valid intersection point
!	cx, cy:				intersection point
! ==============================================================================

"intersection_Line_Line":
	v1x = x11-x12
	v2x = x21-x22
	v1y = y11-y12
	v2y = y21-y22

	lliDiv = v1x * v2y - v1y * v2x

	temp1 = x11 * y12 - y11 * x12
	temp2 = x21 * y22 - y21 * x22

	if abs(lliDiv) > EPS then
		! Intersection

		tempx = temp1 * v2x - v1x * temp2
		tempy = temp1 * v2y - v1y * temp2

		state = 1
		cx = (tempx / lliDiv)
		cy = (tempy / lliDiv)
	else
		! No Intersection
		cx = 0
		cy = 0
		if abs(abs(temp1) - abs(temp2)) < EPS then
			state = -1			! Coincident lines
		else
			state = 0			! Paralel
		endif

	endif

return


! ==============================================================================
! Segment - Segment intersection
! ==============================================================================
! Input:
!	EPS:				epsylon
!	x11,y11, x12,y12	line #1
!	x21,y21, x22,y22	line #2
!
! Output:
!	ret:			output status
!						-1: no intersection, segments is not parallel
!						 0: no intersection, parallel segments
!						 1: intersection point lies on S1 segment, but not lies on S2
!						 2: intersection point lies on S2 segment, but not lies on S1
!						 3: intersection point lies on both segments
!	cx:				intersection point X
!	cy:				intersection point Y
! ==============================================================================

"intersection_Segment_Segment":
	gosub "intersection_Line_Line"

	if state then
		state = 0

		if abs(x11 - x12) < EPS then
			if (y11-EPS <= cy & cy <= y12+EPS) | (y11+EPS >= cy & cy >= y12-EPS) then state = 1
		else
			if (x11-EPS <= cx & cx <= x12+EPS) | (x11+EPS >= cx & cx >= x12-EPS) then state = 1
		endif
		if abs(x21 - x22) < EPS then
			if (y21-EPS <= cy & cy <= y22+EPS) | (y21+EPS >= cy & cy >= y22-EPS) then state = state + 2
		else
			if (x21-EPS <= cx & cx <= x22+EPS) | (x21+EPS >= cx & cx >= x22-EPS) then state = state + 2
		endif

		if state = 0 then state = -1
	endif
return


! ==============================================================================
! Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	xo,yo,ro:			circle
!	x1,y1, x2,y2		line
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = one intersection point (tangential line)
!						2 = two intersection points
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
! ==============================================================================

"intersection_Circle_Line":
	tempX1 = x1 - xo: tempY1 = y1 - yo
	tempX2 = x2 - xo: tempY2 = y2 - yo

	if abs(tempX2 - tempX1) < EPS then				!!Függöleges
		if abs(ro - tempX1) < EPS then				!!Függöleges érintő
			state = 1
			xa = tempX1
			ya = 0
			xb = tempX1
			yb = 0
		else
			if -ro < tempX1 & ro > tempX1 then		!! Vonal függölegesen kétponton metszi kört
				state = 2
				xa = tempX1
				ya = sqr(abs(ro^2 - tempX1^2))
				xb = tempX1
				yb = -sqr(abs(ro^2 - tempX1^2))

			else
				state = 0: xa = 0: ya = 0: xb = 0: yb = 0
			endif
		endif
	else
		kf = (tempY2 - tempY1) / (tempX2 - tempX1)
		ad = 1 + kf^2
		bd = 2 * tempY1 * kf - 2 * tempX1 * kf^2
		cd = tempY1^2 - 2 * tempX1 * tempY1 * kf + tempX1^2 * kf^2 - ro^2

		if bd^2 - 4 * ad * cd < 0 then
			state = 0: xa = 0: ya = 0: xb = 0: yb = 0
		else
			xa = (-bd + sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			ya = tempY1 + (xa - tempX1) * kf
			xb = (-bd - sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			yb = tempY1 + (xb - tempX1) * kf

			if abs(xa - xb) < EPS then state = 1 else state = 2
		endif
	endif

	if state = 2 then
		da = sqr((tempX1 - xa)^2 + (tempY1 - ya)^2)
		db = sqr((tempX1 - xb)^2 + (tempY1 - yb)^2)

		if db < da then
			xxo = xa: yyo = ya
			xa = xb:  ya = yb
			xb = xxo: yb = yyo
		endif
	endif

	xa = xa + xo: ya = ya + yo
	xb = xb + xo: yb = yb + yo
return


! ==============================================================================
! Circle - Circle Intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x1,y1,r1			circle #1
!	x2,y2,r2			circle #2
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = one intersection point (tangential line)
!						2 = two intersection points
!	xa, ya:				intersection point #1
!	ya, yb:				intersection point #2
! ==============================================================================

"intersection_Circle_Circle":
	vx =	x2-x1
	vy =	y2-y1
	gosub "directionAngle"


	d = sqr( (vx)^2+(vy)^2 )

	if d>(r1+r2) or abs(d)<EPS then 	! No Intersection
		state = 0
		return
	endif

	if abs(d-(r1+r2))<EPS then 			! One Intersection

		state =  1
		xa = x1 + ((x2-x1)*r1)/(r1+r2)
		ya = y1 + ((y2-y1)*r1)/(r1+r2)

		xb = xa
		yb = ya
		return
	endif


	! Check if one circle inside the another

	x = (d^2 - r2^2 + r1^2) / (2*d)
	y = sqr(abs(4*d^2*r1^2-(d^2-r2^2+r1^2)^2))/(d*2)
	xa = x1 + y*sin(-angle) + x*cos(-angle)
	ya = y1 + y*cos(-angle) - x*sin(-angle)
	xb = x1 - y*sin(-angle) + x*cos(-angle)
	yb = y1 - y*cos(-angle) - x*sin(-angle)

	state =	2
return


! ==============================================================================
! Segment - Point Distance 2D
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12	line
!	xp, yp				point
!
! Returned variables:
!	state:				0 = projections
!						1 = beyond the 'x11,y11' end of segment
!						2 = beyond the 'x12,y12' end of segment
!	dist				distance
!	xx,yy				projection points
! ==============================================================================

"pointSegmentDistance":
	tempA = xp - x11
	tempB = yp - y11
	tempC = x12 - x11
	tempD = y12 - y11

	tempDot = tempA * tempC + tempB * tempD
	tempLengthSq = tempC * tempC + tempD * tempD
	if abs(tempLengthSq) < EPS then
		tempPar = -1
	else
		tempPar	= tempDot / tempLengthSq
	endif

	if (tempPar < 0) then
		xx = x11
		yy = y12
		state = 1
	else
		if (tempPar > 1) then
			xx = x12
			yy = y12
			state = 2
		else
			xx = x11 + tempPar * tempC
			yy = y11 + tempPar * tempD
			state = 0
		endif
	endif

	dist = sqr((xp-xx)^2 + (yp-yy)^2)
return


! ==============================================================================
! Segment - Point Distance 2D
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12	line
!	xp, yp				point
!
! Returned variables:
!	dist				distance
!	xx,yy				projection points
! ==============================================================================

"pointLineDistance":
	tempA = xp - x11
	tempB = yp - y11
	tempC = x12 - x11
	tempD = y12 - y11

	tempDot = tempA * tempC + tempB * tempD
	tempLengthSq = tempC * tempC + tempD * tempD
	if abs(tempLengthSq) < EPS then
		tempPar	= tempDot
	else
		tempPar	= tempDot / tempLengthSq
	endif

	xx = x11 + tempPar * tempC
	yy = y11 + tempPar * tempD

	dist = sqr((xp-xx)^2 + (yp-yy)^2)
return


! ==============================================================================
! Point inside polygon check
! ==============================================================================
! Input:
!	srcPolygon:		input source of polygon
!	pntX:			point X
!	pntY:			point Y
! Output:
!	ret:			output status
!						0: Error
!						1: Inside
!						2: Outside
!						3: On Edge
!						4: On Point
! ==============================================================================
! Remarks:
!	The polygon can be convex or concave too
!	It works with polygons containing straight segments only
!	The polygon can't contains holes
!	The input polygon from polygon must be closed
! ==============================================================================
"pointInsidePolygon":
	pipNumPnts = vardim1(srcPolygon)
	if pipNumPnts = 0 then return	! Error

	ret = 0		! Error
	pipEnd = 0
	pipIntersection = 0

	pipX0 = srcPolygon[pipNumPnts - 1][1]
	pipY0 = srcPolygon[pipNumPnts - 1][2]
	pipX1 = srcPolygon[1][1]
	pipY1 = srcPolygon[1][2]

	for pipI=1 to pipNumPnts - 1

		! Point on polygon vertex test
		if abs(pipX1 - pntX) < EPS & abs(pipY1 - pntY) < EPS then
			ret		= 4					! OnPoint
			pipI	= pipNumPnts - 1	! Force end loop
			pipEnd	= 1
		endif

		! Point on edge test
		pipSegLength = sqr((pipX0 - pipX1)^2 + (pipY0 - pipY1)^2)
		if pipSegLength > EPS & not(pipEnd) then
			if abs(abs((pipY0 - pipY1) * (pntX - pipX1) - (pipX0 - pipX1) * (pntY - pipY1)) / pipSegLength) < EPS then
				ret		= 3					! OnEdge
				pipI	= pipNumPnts - 1	! Force end loop
				pipEnd	= 1
			endif
		endif

		pipX2 = srcPolygon[pipI + 1][1]
		pipY2 = srcPolygon[pipI + 1][2]

		x11 = pipX1
		y11 = pipY1
		x12 = pipX2
		y12 = pipY2
		x21 = pntX
		y21 = pntY
		x22 = pntX + 1000
		y22 = pntY

		gosub "intersection_Segment_Segment"		! Result: state, cx,cy

		if state = 3 then
			if abs(x12 - cx) > EPS | abs(y12 - cy) > EPS then
				if abs(x11 - cx) < EPS & abs(y11 - cy) < EPS then
					if sgn(pipY0 - pntY) <> sgn(pipY2 - pntY) then
						pipIntersection = pipIntersection + 1
					endif
				else
					pipIntersection = pipIntersection + 1
				endif
			endif
		endif

		pipX0 = pipX1
		pipY0 = pipY1

		pipX1 = pipX2
		pipY1 = pipY2
	next pipI

	if pipEnd then return	! Already have valid result

	if (pipIntersection % 2 = 0) then	! Outside
		ret = 2
	else	! Inside
		ret = 1
	endif
return


! ==============================================================================
! GET GDL Polygon
! ------------------------------------------------------------------------------
! Input variables:
!	ch:				Channel ID
!	polygonID:		Polygon ID
!	mask:
!
! Returned variables:
!	GDL stack:			GDL polygon
! ==============================================================================

"getGDLpolygonFromAPI":
	dim resVertices[]
	numVertices = CALLFUNCTION (ch, "GetVertices", polygonID, resVertices)
	numVertices = numVertices / 3

	dim contArr[]
	numContours = CALLFUNCTION (ch, "GetContourEnds", polygonID, contArr)

	!dim inhEdgeInfos[]
	!numEdges = CALLFUNCTION (ch, "GetInhEdgeInfos", polygonID, inhEdgeInfos)

	for contIndex = 1 to numContours
		if contIndex = 1 then
			begIdx = 0
		else
			begIdx = endIdx +1
		endif
		if contIndex = numContours then
			endIdx = numVertices - 1
		else
			endIdx = contArr[contIndex + 1] - 2 -(contIndex - 1)
		endif

		bClosed = 0
		bStartWithLast = 0

		index = endIdx * 3
		lastVertX = resVertices[index + 1]
		lastVertY = resVertices[index + 2]
		lastVertA = resVertices[index + 3]
		!edgeInfo  = inhEdgeInfos[endIdx + 1]

		if abs(lastVertA) > EPS then
			put lastVertX, lastVertY, mask
			bStartWithLast = 1
		endif

		for vertIndex = begIdx to endIdx
			index = vertIndex * 3
			actVertX = resVertices[index + 1]
			actVertY = resVertices[index + 2]
			actVertA = resVertices[index + 3]

			! ------------------------------------------------------------------------------
			! Show inherited edge information number
			! ------------------------------------------------------------------------------
			!
			!			text2	(lastVertX + actVertX) / 2,
			!					(lastVertY + actVertY) / 2,
			!					edgeInfo
			! ------------------------------------------------------------------------------

			if vertIndex = begIdx then
				if bStartWithLast then
					ac2gdl_spx = lastVertX
					ac2gdl_spy = lastVertY
				else
					ac2gdl_spx = actVertX
					ac2gdl_spy = actVertY
				endif
			endif

			!if abs(lastVertA) > EPS then
			!	ac2gdl_mx = (actVertX + lastVertX) / 2
			!	ac2gdl_my = (actVertY + lastVertY) / 2
			!	ac2gdl_ratio = 1 / 2 / tan (lastVertA / 2)
			!
			!	ac2gdl_cx = ac2gdl_mx - ac2gdl_ratio * (actVertY - lastVertY)	! Arc center
			!	ac2gdl_cy = ac2gdl_my + ac2gdl_ratio * (actVertX - lastVertX)
			!
			!	put ac2gdl_cx,	ac2gdl_cy,	900+mask,
			!		0,			lastVertA,	4000+mask
			!else
			!	if edgeInfo then
			!		line2 lastVertX, lastVertY, actVertX, actVertY
			!	endif
			!endif

			bPointMatch = 0
			if vertIndex = endIdx then
				if abs(ac2gdl_spx - actVertX) < EPS & abs(ac2gdl_spy - actVertY) < EPS then
					put actVertX, actVertY, -1
					bClosed		= 1
					bPointMatch = 1
				endif
			endif
			if not(bPointMatch) then
				if vertIndex < endIdx | not(bStartWithLast) then
					if abs(lastVertX - actVertX) > EPS | abs(lastVertY - actVertY) > EPS then
						!edgeInfo  = inhEdgeInfos[vertIndex + 1]
						put actVertX, actVertY, mask
					endif
				endif
			endif

			lastVertX = actVertX
			lastVertY = actVertY
			lastVertA = actVertA

		next vertIndex

		if not(bClosed) then	! Close the polygon if it has holes
			put ac2gdl_spx, ac2gdl_spy, -1
		endif

	next contIndex
return


! ==============================================================================
!
! End of Macros Script
!
! ==============================================================================

"endMasterSript":


