
! -----------------------------------------------------------------------------
! geometry parameters for Rounded Corner Minimal Space
! -----------------------------------------------------------------------------

if iStyle = 3 and abs(A-B) > EPS then
	temp_a = 2 * (sin(45)*A)
	temp_b = 2 * (sin(45)*B)
	widthBottomMax = sqr (temp_a^2 + temp_b^2)
	side1 = (B/A) * MSFront
	side2 = MSFront / (B/A)
	maxWidth1 = widthBottomMax/2 + side1
	maxWidth2 = widthBottomMax/2 + side2
	delta1 = (maxWidth1 - MSWidth/2) / (B/A)
	delta2 = (maxWidth2 - MSWidth/2) * (B/A)
endif

! -----------------------------------------------------------------------------
! Scale
! -----------------------------------------------------------------------------

call "2dDetailLevel" parameters gs_detlevel_2D_m = gs_detlevel_2D_m,
				returned_parameters det2D

! -----------------------------------------------------------------------------
! Hotspots 2D
! -----------------------------------------------------------------------------

! -----------------------------------------------------------------------------
! Shower Tray Types
! -----------------------------------------------------------------------------
pen gs_cont_pen
fill gs_fill_type
DrawingNum = 1
drawindex 20

ress = gs_resol / 360 * 90
if ress - int(ress) < 0.5 then
	ress = int(ress)
	beta = 90 / ress
else
	ress = int(ress) + 1
	beta = 90 / ress
endif

gosub iStyle

! -----------------------------------------------------------------------------
! Minimal Space
! -----------------------------------------------------------------------------
drawindex 10
gosub "minimalspace"

! -----------------------------------------------------------------------------
! MEP Connections
! -----------------------------------------------------------------------------
if bShowMEP then
	gosub "mepconnection"
endif

end

! =============================================================================
! SUBRUTINES
!
! =============================================================================

! -----------------------------------------------------------------------------
! Shower Tray Rectangular
! -----------------------------------------------------------------------------

1:

	if DrawingNum = 1 then	! Top

		call "Resize_A_B_ZZYZX" parameters ALL

		add2 a/2, 0

		unID = 1
		hotspot2    0, B/2, unID : unID = unID + 1
		hotspot2  A/2, B/2, unID : unID = unID + 1
		hotspot2 -A/2, B/2, unID : unID = unID + 1
		hotspot2    0,   0, unID : unID = unID + 1
		hotspot2    0,   B, unID : unID = unID + 1

		poly2_b 4, 1+2+4+64,gs_fill_pen, gs_back_pen,
			 A/2,	0,	1,
			 A/2,	B,	1,
			-A/2,	B,	1,
			-A/2,	0,	1

		! --- 1/50, 1/100 ---
		if det2D <> 1 then
			if iSymbolType = 1 then
				rect2 -A/2+showerBorderWidth, showerBorderWidth, A/2-showerBorderWidth, B-showerBorderWidth
			endif
			if iSymbolType = 2 then
				R = showerBorderRadOuter
				poly2_b 9, 1+4,gs_fill_pen, gs_back_pen,
					-A/2+showerBorderWidth+R,showerBorderWidth,1,
					 A/2-showerBorderWidth-R,showerBorderWidth,1,
					 A/2-showerBorderWidth,showerBorderWidth+R,1001,
					 A/2-showerBorderWidth,B-showerBorderWidth-R,1,
					 A/2-showerBorderWidth-R,B-showerBorderWidth,1001,
					-A/2+showerBorderWidth+R,B-showerBorderWidth,1,
					-A/2+showerBorderWidth,B-showerBorderWidth-R,1001,
					-A/2+showerBorderWidth,showerBorderWidth+R,1,
					-A/2+showerBorderWidth+R,showerBorderWidth,1001
			endif

			! --- 1/50 ---
			if det2D = 3 then
				if iSymbolType = 1 then
					alpha = atn((A/2-2*0.05) / (B/2-2*0.05))
					line2 -A/2+0.05,0.05,	-0.08*sin(alpha),B/2-0.08*cos(alpha)
					line2 -A/2+0.05,B-0.05,	-0.08*sin(alpha),B/2+0.08*cos(alpha)
					line2  A/2-0.05,0.05,	 0.08*sin(alpha),B/2-0.08*cos(alpha)
					line2  A/2-0.05,B-0.05,	 0.08*sin(alpha),B/2+0.08*cos(alpha)
				endif
				if iSymbolType = 2 then
					line2 -a / 2 + drainPosX * 2 - showerBorderWidth, drainPosY, a / 2 - showerBorderWidth - showerBorderRadOuter, drainPosY
					line2 -a / 2 + drainPosX, drainPosY * 2 - showerBorderWidth, -a / 2 + drainPosX, b - showerBorderWidth - showerBorderRadOuter

					line2	-a / 2 + drainPosX + (drainPosX - showerBorderWidth) * cos(simbolLineAngle), drainPosY + (drainPosX - showerBorderWidth) * sin(simbolLineAngle),
							a / 2 - showerBorderWidth - showerBorderRadOuter, b - showerBorderWidth - showerBorderRadOuter
				endif
			endif

			! --- Drain ---
			add2 -a / 2, 0
				if iSymbolType = 1 then
					add2 drainPosX, drainPosY
						circle2 0,0, 0.08
						circle2 0,0, 0.05
						line2 0,-0.05, 0,0.05
						line2 0.05,0,-0.05,0
					del 1
				endif
				if iSymbolType = 2 then
					circle2 drainPosX, drainPosY, 0.025
				endif
			del 1
		endif
		del 1
	endif
return

! -----------------------------------------------------------------------------
! Shower Tray Corner
! -----------------------------------------------------------------------------

2:
	if  DrawingNum = 1 then	! Top
		add2 a, 0
		rot2 90
		poly2_b 6, 1+2+4+64, gs_fill_pen, gs_back_pen,
				0, 0, 1,
				0, a, 1,
				b, a, 1,
				b, a - xsl, 1,
				ysl, 0, 1,
				0, 0, -1
		unID = 1
		hotspot2   0, a, unID : unID = unID + 1
		hotspot2   0, 0, unID : unID = unID + 1
		hotspot2   b, a, unID : unID = unID + 1
		hotspot2   b, a - xsl, unID : unID = unID + 1
		hotspot2 ysl,   0, unID : unID = unID + 1
		hotspot2 b/2, a/2, unID : unID = unID  + 1

		if det2D <> 1 then
			rrr		= 0.07
			dist	= 0.05

			alpha1 = atn ((b - ysl) / (a - xsl))
			alpha2 = 90 - alpha1

			! coordinates of point in slanted positions

			x1 = b - dist
			y1 = a - xsl + (rrr + dist) * tan (alpha1 / 2)

			x2 = b - dist - rrr * (1 - cos (alpha1))
			y2 = y1 - rrr * sin (alpha1)

			x4 = ysl - (dist + rrr) * tan (alpha2 / 2)
			y4 = dist

			x3 = x4 + rrr * sin (alpha2)
			y3 = dist + rrr - rrr * cos (alpha2)

			poly2_b 11, 1+4, gs_fill_pen, gs_back_pen,
				dist, dist + rrr, 1,
				dist, a - dist - rrr, 1,
				dist + rrr, a - dist, 1001,
				b - dist - rrr, a - dist, 1,
				b - dist, a - dist - rrr, 1001,
				x1, y1, 1,
				x2, y2, 1001,
				x3, y3, 1,
				x4, y4, 1001,
				dist + rrr, dist, 1,
				dist, dist + rrr, 1001

			! --- Drain ---
			rot2 -90
			add2 -a, 0
				circle2 drainPosX, drainPosY, 0.025
			del 2

			if det2D > 2 then ! additional lines
				add2 b/2, a/2
				aa = b/2
				bb = a/2

				line2  aa/4,  bb/4,  3*aa/4,  3*bb/4
				line2 -aa/4,  bb/4, -3*aa/4,  3*bb/4
				line2 -aa/4, -bb/4, -3*aa/4, -3*bb/4

				del 1
			endif
		endif
		del 2
	endif

return

! -----------------------------------------------------------------------------
! Shower Tray Rounded Corner
! -----------------------------------------------------------------------------

3:

	if DrawingNum = 1 then	! Top

		! --- 1/50 ---
		if det2D = 3 then
			if iSymbolType = 1 then
				alpha = 45
				line2 showerBorderWidth, showerBorderWidth, drainPosX-0.08*sin(alpha), drainPosY-0.08*cos(alpha)

				alpha2 = beta * 4
				line2	showerBorderWidth + showerBorderRadOuter + showerBorderRadRound1 * cos(alpha2),
						showerBorderWidth + showerBorderRadOuter + showerBorderRadRound2 * sin(alpha2),
						drainPosX+0.08*sin(alpha), drainPosY+0.08*cos(alpha)

				line2 showerBorderWidth, b - showerBorderWidth, drainPosX-0.08*sin(alpha), drainPosY+0.08*cos(alpha)
				line2 a - showerBorderWidth, showerBorderWidth, drainPosX+0.08*sin(alpha), drainPosY-0.08*cos(alpha)
			endif
			if iSymbolType = 2 then
				add2 a / 2, 0
					line2 -a / 2 + drainPosX * 2 - showerBorderWidth, drainPosY, a / 2 - showerBorderWidth - showerBorderRadOuter, drainPosY
					line2 -a / 2 + drainPosX, drainPosY * 2 - showerBorderWidth, -a / 2 + drainPosX, b - showerBorderWidth - showerBorderRadOuter
	
					alpha2 = beta * 4
					line2	-a / 2 + drainPosX + (drainPosX - showerBorderWidth) * cos(simbolLineAngle),
							drainPosY + (drainPosX - showerBorderWidth) * sin(simbolLineAngle),
							-a / 2 + showerBorderWidth + showerBorderRadOuter + showerBorderRadRound1 * cos(alpha2) - showerBorderRadOuter * cos(simbolLineAngle),
							showerBorderWidth + showerBorderRadOuter + showerBorderRadRound2 * sin(alpha2) - showerBorderRadOuter * sin(simbolLineAngle)
				del 1
			endif
		endif

		! --- 1/50, 1/100 ---
		add2 a / 2, 0

		gosub "rounded outer contour"

		if det2D <> 1 then
			if iSymbolType = 1 then
				gosub "buffer Points for Round Tray"

				poly2_b 4 + ress * 1, 1+4,gs_fill_pen, gs_back_pen,
					a / 2 - showerBorderWidth, showerBorderWidth, 1,
					get (ress * 3),
					-a / 2 + showerBorderWidth + showerBorderRadOuter, b - showerBorderWidth, 1,
					-a / 2 + showerBorderWidth, b - showerBorderWidth, 1,
					-a / 2 + showerBorderWidth, showerBorderWidth, 1
			endif

			if iSymbolType = 2 then
				gosub "buffer Points for Round Tray"

				poly2_b 8 + ress * 4, 1+4,gs_fill_pen, gs_back_pen,
					-a / 2 + showerBorderWidth + showerBorderRadOuter, showerBorderWidth, 1,
					a / 2 - showerBorderWidth - showerBorderRadOuter, showerBorderWidth, 1,
					get (ress * 3),
					a / 2 - showerBorderWidth, showerBorderWidth + showerBorderRadOuter, 1,
					get (ress * 3),
					get (ress * 3),
					-a / 2 + showerBorderWidth, b - showerBorderWidth - showerBorderRadOuter, 1,
					-a / 2 + showerBorderWidth, showerBorderWidth + showerBorderRadOuter, 1,
					get (ress * 3),
					-a / 2 + showerBorderWidth + showerBorderRadOuter, showerBorderWidth, 1,
					a / 2 - showerBorderWidth - showerBorderRadOuter, showerBorderWidth, 1,
					-a / 2 + showerBorderWidth + showerBorderRadOuter, showerBorderWidth, -1
			endif

			! --- Drain ---
			add2 -a / 2, 0
				if iSymbolType = 1 then
					add2 drainPosX, drainPosY
						circle2 0,0, 0.08
						circle2 0,0, 0.05
						line2 0,-0.05, 0,0.05
						line2 0.05,0,-0.05,0
					del 1
				endif
				if iSymbolType = 2 then
					circle2 drainPosX, drainPosY, 0.025
				endif
			del 1
		endif

		del 1

		line_type 1
	endif

return

! -----------------------------------------------------------------------------
! Minimal Space
! -----------------------------------------------------------------------------

"minimalspace":

	_MSFront = MSFront
	if iStyle = 2 then
	_MSFront = MSFront_2
	endif
	if iStyle = 3 then
	_MSFront = MSFront_3
	endif

	if iStyle = 1 then
		add2 a/2, 0
		call "fa_minimalspace" parameters 	MSType				= 10,
											A					= A,
											B					= B,
											unID				= 3000,
											MSFront				= _MSFront,
											MSAdditionalLength	= MSAdditionalLength
		del 1
	endif
	if iStyle = 2 then
		add2 a, 0
		rot2 90
		reqBMinSpace = 0
		if _MSFront > EPS then
			call "fa_minimalspace" parameters all MSType = 0, unID = 3000,
									returned_parameters reqBMinSpace,
														MSFillType,
														MSFillPen,
														MSFillBackPen,
														MSContLineType,
														MSContLinePen
		endif

		if reqBMinSpace <> 0 then
			unID = 3000
			FILL MSFillType
			line_type MSContLineType
			pen MSContLinePen

			x1 = ysl
			y1 = 0

			x2 = b
			y2 = a - xsl

			sidelength = sqr ((x2 - x1)^2 + (y2 - y1)^2)

			alpha = atn ((y2 - y1) / (x2 - x1))

			add2 x1, y1
			rot2 alpha
			poly2_b 5, 1+2+4+64, MSFillPen, MSFillBackPen,
						   0,            0,      1,
				0, -_MSFront, 1,
				sidelength, -_MSFront, 1,
				sidelength, 0, 0,
				0, 0, -1

			hotspot2 0, -_MSFront, unID : unID = unID + 1
			hotspot2 sidelength, -_MSFront, unID : unID = unID + 1

			del 2
		endif
		del 2
	endif
	if iStyle = 3 then
		reqBMinSpace = 0
		if _MSFront > EPS and MSWidth > EPS then
			call "fa_minimalspace" parameters all MSType = 0, unID = 3000,
									returned_parameters reqBMinSpace,
														MSFillType,
														MSFillPen,
														MSFillBackPen,
														MSContLineType,
														MSContLinePen
		endif
		if reqBMinSpace <> 0 then
			add2	showerBorderWidth + showerBorderRadOuter + (a - showerBorderWidth - showerBorderRadOuter) * cos(45),
					showerBorderWidth + showerBorderRadOuter + (b - showerBorderWidth - showerBorderRadOuter) * sin(45)
			rot2 -atn(b/a)

			unID = 3000
			FILL MSFillType
			line_type MSContLineType
			pen MSContLinePen

			hotspot2  0, 0, unID : unID = unID + 1

			if abs(A-B) < EPS then			!A and B are equal
				rrr = sqr (((a - showerBorderWidth - showerBorderRadOuter) * sin (45))^2 + ((a - showerBorderWidth - showerBorderRadOuter) * sin (45))^2)

				if (sqr ((a - showerBorderWidth - showerBorderRadOuter)^2 + (b - showerBorderWidth - showerBorderRadOuter)^2) - MSWidth) > EPS then
					delta = rrr - sqr (rrr^2 - (MSWidth / 2)^2)

					put	-MSWidth / 2, -delta, 0,
						 0, 			-rrr, 		900,
						 MSWidth / 2, 	-delta, 	3001,
						 MSWidth / 2, 	_MSFront, 	1,
						-MSWidth / 2, 	_MSFront, 	1,
						-MSWidth / 2, 	-delta, 	-1

					hotspot2 -MSWidth / 2, 0, unID : unID = unID + 1
					hotspot2  MSWidth / 2, 0, unID : unID = unID + 1

				else
					maxWidth = 2 * (A - showerBorderWidth - showerBorderRadOuter + _MSFront)
					minWidth = sqr ((a - showerBorderWidth - showerBorderRadOuter)^2 + (b - showerBorderWidth - showerBorderRadOuter)^2)
					deltaAdd = maxWidth/2 - MSWidth/2
					deltaMax = A - showerBorderWidth - showerBorderRadOuter - minWidth / 2

					put	-minWidth / 2, 	-deltaMax, 0,
						 0, 			-rrr, 		900,
						 minWidth / 2, 	-deltaMax, 	3001,
						 MSWidth / 2, 	_MSFront - deltaAdd, 	1,
						 MSWidth / 2, 	_MSFront, 	1,
						-MSWidth / 2, 	_MSFront, 	1,
						-MSWidth / 2, 	_MSFront - deltaAdd, 	1,
						-MSWidth / 2, 	-deltaMax, 	-1

					hotspot2 -MSWidth / 2, MSFront - deltaAdd, unID : unID = unID + 1
					hotspot2  MSWidth / 2, MSFront - deltaAdd, unID : unID = unID + 1
				endif
			else
				if (widthBottomMax/2 - MSWidth/2) > EPS then
					put	-MSWidth / 2, 0, 		1,
						 MSWidth / 2, 0, 		1,
						 MSWidth / 2, _MSFront,  1,
						-MSWidth / 2, _MSFront,  1,
						-MSWidth / 2, 0, 		-1
				else
					put	-widthBottomMax/2, 	0, 		1,
						-MSWidth/2, 		_MSFront-delta1, 1,
						-MSWidth/2, 		_MSFront, 1,
						MSWidth/2, 			_MSFront, 1,
						MSWidth/2, 			_MSFront-delta2, 1,
						widthBottomMax/2, 	0, 		1,
						-widthBottomMax/2, 	0, 		-1

					hotspot2 -MSWidth / 2, _MSFront - delta1, unID : unID = unID + 1
					hotspot2  MSWidth / 2, _MSFront - delta2, unID : unID = unID + 1
				endif
			endif
			poly2_b nsp/3, 1+2+4+64, MSFillPen, MSFillBackPen,
					get(nsp)

			hotspot2  MSWidth / 2, _MSFront, unID : unID = unID + 1
			hotspot2 -MSWidth / 2, _MSFront, unID : unID = unID + 1

			del 2
		endif
	endif
return


! -----------------------------------------------------------------------------
! MEP Connections
! -----------------------------------------------------------------------------

"mepconnection":

	rot2 -SYMB_ROTANGLE * (DrawingNum > 1 and NOT(SYMB_MIRRORED))+SYMB_ROTANGLE * (DrawingNum > 1 and SYMB_MIRRORED)

	if DrawingNum = 2 then project2 -3, 90, 2	! Bottom
	if DrawingNum = 3 then project2 4, 270, 2	! Front
	if DrawingNum = 4 then project2 4, 90, 2	! Back
	if DrawingNum = 5 then project2 4, 180*(SYMB_MIRRORED), 2		! Right
	if DrawingNum = 6 then project2 4, 180*NOT(SYMB_MIRRORED), 2	! Left


	! --- CONNECTIONS --- !

	call "MEP_m_ConnectionsACL_4" PARAMETERS SetProgram = SetProgram,
		ui_current_con = ui_current_con,
		MEP_NumberConnections = MEP_NumberConnections,
		MEP_NumConnectionData = gs_Connections,
		gs_AddConnections = gs_AddConnections,
		DrawingNum = DrawingNum,
		MEP_InsShow = 0,
		MEP_cline_show = 0,
		gs_cont_pen = gs_cont_pen,
		gs_fill_type=gs_fill_type,
		gs_fill_pen=gs_fill_pen,
		gs_back_pen=gs_back_pen,
		ConPosX_1=ConPosX_1, ConPosY_1=ConPosY_1, ConLength_1=ConLength_1, ConEdit_1 = 0

	del 1

return


! -----------------------------------------------------------------------------
! Shower Treay Rounded Corner detail
! -----------------------------------------------------------------------------


"rounded outer contour":

	if abs(A-B) < EPS then			!A and B are equal
		poly2_b 7, 1+2+4+64, gs_fill_pen, gs_back_pen,
			a / 2, 0, 1,
			a / 2, showerBorderWidth + showerBorderRadOuter, 1,
			0, 1, 800,
			-a / 2 + showerBorderWidth + showerBorderRadOuter, b, 1001,
			-a / 2, b, 1,
			-a / 2, 0, 1,
			a / 2, 0, 1
	else
		gosub "buffer Points for Round Tray 2"
	
		poly2_b 6 + ress, 1+2+4+64, gs_fill_pen, gs_back_pen,
			a / 2, 0, 1,
			a / 2, showerBorderWidth + showerBorderRadOuter, 1,
			get (ress * 3),
			-a / 2 + showerBorderWidth + showerBorderRadOuter, b, 1,
			-a / 2, b, 1,
			-a / 2, 0, 1,
			a / 2, 0, 1
	endif

	unID = 1
	hotspot2 -a / 2, 0,		unID : unID = unID + 1
	hotspot2 -a / 2, b,		unID : unID = unID + 1
	hotspot2 a / 2, 0,		unID : unID = unID + 1
	hotspot2 -a / 2, b / 2,	unID : unID = unID + 1
	hotspot2 0, 0,			unID : unID = unID + 1

return

"buffer Points for Round Tray":

	if iSymbolType = 1 then
		alpha = 0
		for ii = 1 to ress
			put -a / 2 + showerBorderWidth + showerBorderRadOuter + showerBorderRadRound1 * cos(alpha), showerBorderWidth + showerBorderRadOuter + showerBorderRadRound2 * sin(alpha), 1
			alpha = alpha + beta
		next ii
	else
		alpha = -90
		for ii = 1 to ress
			put a / 2 - showerBorderWidth - showerBorderRadOuter + showerBorderRadOuter * cos(alpha), showerBorderWidth + showerBorderRadOuter + showerBorderRadOuter * sin(alpha), 1
			alpha = alpha + beta
		next ii
		
		alpha = 0
		for ii = 1 to ress
			put -a / 2 + showerBorderWidth + showerBorderRadOuter + showerBorderRadRound1 * cos(alpha), showerBorderWidth + showerBorderRadOuter + showerBorderRadRound2 * sin(alpha), 1
			alpha = alpha + beta
		next ii
		
		alpha = 90
		for ii = 1 to ress
			put -a / 2 + showerBorderWidth + showerBorderRadOuter + showerBorderRadOuter * cos(alpha), b - showerBorderWidth - showerBorderRadOuter + showerBorderRadOuter * sin(alpha), 1
			alpha = alpha + beta
		next ii
		
		alpha = 180
		for ii = 1 to ress
			put -a / 2 + showerBorderWidth + showerBorderRadOuter + showerBorderRadOuter * cos(alpha), showerBorderWidth + showerBorderRadOuter + showerBorderRadOuter * sin(alpha), 1
			alpha = alpha + beta
		next ii
	endif

return

"buffer Points for Round Tray 2":

	alpha = 0
	for ii = 1 to ress
		put		-a / 2 + showerBorderWidth + showerBorderRadOuter + (showerBorderRadRound1 + showerBorderWidth) * cos(alpha),
				showerBorderWidth + showerBorderRadOuter + (showerBorderRadRound2 + showerBorderWidth) * sin(alpha), 1

		alpha = alpha + beta
	next ii

return




