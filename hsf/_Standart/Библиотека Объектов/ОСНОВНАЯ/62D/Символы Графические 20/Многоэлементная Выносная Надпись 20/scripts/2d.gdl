
PAPER_TO_MODEL = GLOB_SCALE / 1000

textBoxOffset			= textBoxOffsetPaper * PAPER_TO_MODEL

totalTextLength			= (textBoxLengthPaper - textBoxOffsetPaper * 2) * PAPER_TO_MODEL

totalTextHeight 		= totalTextHeightPaper 		* PAPER_TO_MODEL
textBoxHeight			= textBoxHeightPaper 		* PAPER_TO_MODEL

titleTextHeight			= titleTextHeightPaper 		* PAPER_TO_MODEL
labelTextHeight			= labelTextHeightPaper 		* PAPER_TO_MODEL

totalTitleTextHeight	= totalTitleTextHeightPaper * PAPER_TO_MODEL

bEnableArrowHead		= 0
if NOT(bHideArrowHead) or (bHideArrowHead and GLOB_SCALE < hideArrowHeadFrom) then
	bEnableArrowHead	= 1
endif

titleTextPos			= 0
if iTitleTextAlign = TEXT_ALIGN_CENTER	then titleTextPos = totalTextLength / 2
if iTitleTextAlign = TEXT_ALIGN_RIGHT	then titleTextPos = totalTextLength

labelTextPos			= 0
if iLabelTextAlign = TEXT_ALIGN_CENTER	then labelTextPos = totalTextLength / 2
if iLabelTextAlign = TEXT_ALIGN_RIGHT	then labelTextPos = totalTextLength

commonPointPosY			= commonPointPosYPaper			* PAPER_TO_MODEL

textBoxLength			= textBoxLengthPaper			* PAPER_TO_MODEL
headBoxLength			= headBoxLengthPaper			* PAPER_TO_MODEL
headBoxWidth			= headBoxWidthPaper				* PAPER_TO_MODEL
headBoxOffsetLeftRight	= headBoxOffsetLeftRightPaper	* PAPER_TO_MODEL
headBoxOffsetUpDown		= headBoxOffsetUpDownPaper		* PAPER_TO_MODEL
headShapeSidePointXPos	= headShapeSidePointXPosPaper	* PAPER_TO_MODEL

define fill "solidFillForMultiLabel" 255, 255, 255, 255, 255, 255, 255, 255, 1, 0, 0

unID = 1

! ==========================================================================
! Hotspots
! ==========================================================================

hotspot2	0,		0,			unID, textBoxPosX,  1 + 128	: unID = unID + 1
hotspot2   	-1,		0,			unID, textBoxPosX, 	3		: unID = unID + 1
hotspot2 	textBoxPosX,	0,	unID, textBoxPosX, 	2		: unID = unID + 1

add2 textBoxPosX, 0
	hotspot2	0,				0,	unID, textBoxLengthPaper_M,		1 + 1024 + 128, textBoxLengthPaper		: unID = unID + 1
	hotspot2   	-1,				0,	unID, textBoxLengthPaper_M, 	3 + 1024,		textBoxLengthPaper		: unID = unID + 1
	hotspot2 	textBoxLength,	0,	unID, textBoxLengthPaper_M, 	2 + 1024,		textBoxLengthPaper		: unID = unID + 1
del 1

! ==========================================================================
! Title, Label Texts
! ==========================================================================

angleViewRot = 0
rrr = REQUEST ("View_Rotangle", "", angleViewRot)
totalRotate = (SYMB_ROTANGLE + angleViewRot) MOD 360

if iTextOrientation = ORIENTATION_READABLE and (totalRotate > (90 + EPS) and totalRotate < (90 + 180 + EPS)) then
	add2 textBoxLength, - textBoxHeight
	rot2 180
endif

gosub "titletext"
gosub "labeltext"

if iTextOrientation = ORIENTATION_READABLE and (totalRotate > (90 + EPS) and totalRotate < (90 + 180 + EPS)) then del 2

! ==========================================================================
! Headshape
! ==========================================================================

if bShowLabelFrame then gosub "headshape"

! ==========================================================================
! Leaders, Line Connections
! ==========================================================================

if bEnablePointersOnSide1 then
	gosub "commonLineLeft"
	gosub "leadersLeft"
endif

if bEnablePointersOnSide2 then
	gosub "commonLineRight"
	gosub "leadersRight"
endif

if iLineConnType = LINECONNTYPE_UTEXT or iLineConnType = LINECONNTYPE_UTITLE then gosub "lineConnection"

!================================================================================
end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
!================================================================================

"titletext":

	pen titleTextPen
	set style "titleTextStyle"

	add2 textBoxOffset + textBoxPosX + titleTextPos, -textBoxOffset
		for j = 1 to realTitleRowNum
			if titleTextRow[j] <> "" then
				paragraph "titleParagraph" iTitleTextAlign, 0, 0, 0, 1, 0
					pen titleTextPen
					set style "titleTextStyle"
					titleTextRow[j]
				endparagraph
				textblock "titleTextBlock" 0, iTitleTextAlign, 0, titleTextWidthFactor / 100, titleTextSpacingFactor / 100, 1, "titleParagraph"
				add2 0, -titleTextHeight * (j - 1) * titleTextLeading / 100
					richtext2 0, 0, "titleTextBlock"
				del 1
			endif
		next j
	del 1

return

"labeltext":

	pen labelTextPen
	set style "labelTextStyle"

	add2 0, -totalTitleTextHeight
		add2 textBoxOffset + textBoxPosX + labelTextPos, - textBoxOffset
			for j = 1 to realLabelRowNum
				if labelTextRow[j] <> "" then
					paragraph "labelParagraph" iLabelTextAlign, 0, 0, 0, 1, 0
						pen labelTextPen
						set style "labelTextStyle"
						labelTextRow[j]
					endparagraph
					textblock "labelTextBlock" 0, iLabelTextAlign, 0, labelTextWidthFactor / 100, labelTextSpacingFactor / 100, 1, "labelParagraph"
					add2 0, -labelTextHeight * (j - 1) * labelTextLeading / 100
						richtext2 0, 0, "labelTextBlock"
					del 1
				endif
			next j
		del 1
	del 1

return

"commonLineLeft":

	pen pointerPen
	line_type pointerLineType

	add2 0, commonPointPosY
		line2 totalCommonPointLeftPosX, 0, - headBoxOffsetLeftRight + textBoxPosX, 0

		add2 textBoxPosX, 0
			hotspot2	0,						0,	unID, commonPointLeftPosX,  1 + 128	: unID = unID + 1
			hotspot2   	-1,						0,	unID, commonPointLeftPosX, 	3		: unID = unID + 1
			hotspot2 	commonPointLeftPosX,	0,	unID, commonPointLeftPosX, 	2		: unID = unID + 1
		del 1
	del 1

return

"commonLineRight":

	pen pointerPen
	line_type pointerLineType

	add2 0, commonPointPosY
		line2 headBoxLength - headBoxOffsetLeftRight + textBoxPosX, 0, totalCommonPointRightPosX, 0

		add2 textBoxPosX, 0
			hotspot2	0,						0,	unID, commonPointRightPosX, 	1 + 128	: unID = unID + 1
			hotspot2   	-1,						0,	unID, commonPointRightPosX, 	3		: unID = unID + 1
			hotspot2 	commonPointRightPosX,	0,	unID, commonPointRightPosX, 	2		: unID = unID + 1
		del 1
	del 1

return

"leadersLeft":
	add2 commonPointLeftPosX + textBoxPosX, 0
	for i = 1 to iPointerNumSide1
		line_type pointerLineType
		pen pointerPen

		add2 0,commonPointPosY

		length_p1	= SQR(((leaderPointsLeftPosXEnd[i])^2)+((leaderPointsLeftPosYEnd[i])^2))
		length_n1	= 2 * length_p1
		midPointX	= leaderPointsLeftPosXStart[i] + leaderPointsLeftPosXEnd[i]
		midPointY	= leaderPointsLeftPosYStart[i] + leaderPointsLeftPosYEnd[i]

		if (ABS(leaderPointsLeftPosXEnd[i])<EPS & ABS(leaderPointsLeftPosYEnd[i])<EPS) then
			if (ABS(leaderPointsLeftPosXStart[i])<EPS & ABS(leaderPointsLeftPosYStart[i])<EPS) then
				angle1=0
			else
				length_p1	= SQR(((leaderPointsLeftPosXStart[i])^2)+((leaderPointsLeftPosYStart[i])^2))
				if (leaderPointsLeftPosXStart[i]) > 0 THEN
					angle1=ASN(((leaderPointsLeftPosYStart[i]))/length_p1)+180
				else
					angle1=-1*(ASN(((leaderPointsLeftPosYStart[i]))/length_p1))
				endif
			endif
		else
			if (leaderPointsLeftPosXEnd[i]) > 0 THEN
				angle1=ASN(((leaderPointsLeftPosYEnd[i]))/length_p1)
			else
				angle1=-1*(ASN(((leaderPointsLeftPosYEnd[i]))/length_p1))+180
			endif
		endif

		arrowHeadLength		= 0
		if bEnableArrowHead then
			add2 leaderPointsLeftPosXStart[i], leaderPointsLeftPosYStart[i]
			rot2 angle1
				gosub "arrowHead"
			del 2
		endif

		arrowHeadLengthXMod	= arrowHeadLength * COS(angle1)
		arrowHeadLengthYMod	= arrowHeadLength * SIN(angle1)

		if iPointerType = POINTER_STRAIGHT then
			LINE2 leaderPointsLeftPosXStart[i] + arrowHeadLengthXMod, leaderPointsLeftPosYStart[i] + arrowHeadLengthYMod, midPointX, midPointY
			LINE2 midPointX, midPointY, 0, 0
		else
			SPLINE2A 2,0,leaderPointsLeftPosXStart[i] + arrowHeadLengthXMod,leaderPointsLeftPosYStart[i] + arrowHeadLengthYMod,angle1,0,length_n1,
						0,0,0,length_n1,0
		endif

		!!! pointer
		HOTSPOT2 0,									leaderPointsLeftPosYStart[i],	unID,	leaderPointsLeftPosXStart[i],	1+128	: unID=unID+1
		HOTSPOT2 -1,								leaderPointsLeftPosYStart[i],	unID,	leaderPointsLeftPosXStart[i],	3		: unID=unID+1
		HOTSPOT2 leaderPointsLeftPosXStart[i],		leaderPointsLeftPosYStart[i],	unID,	leaderPointsLeftPosXStart[i],	2		: unID=unID+1

		HOTSPOT2 leaderPointsLeftPosXStart[i],		0,								unID,	leaderPointsLeftPosYStart[i],	1+128	: unID=unID+1
		HOTSPOT2 leaderPointsLeftPosXStart[i],		-1,								unID,	leaderPointsLeftPosYStart[i],	3		: unID=unID+1
		HOTSPOT2 leaderPointsLeftPosXStart[i],		leaderPointsLeftPosYStart[i],	unID,	leaderPointsLeftPosYStart[i],	2		: unID=unID+1

		!!! Tangent
		HOTSPOT2 leaderPointsLeftPosXStart[i],		midPointY,						unID, leaderPointsLeftPosXEnd[i],		1+128	: unID=unID+1
		HOTSPOT2 leaderPointsLeftPosXStart[i]-1,	midPointY,						unID, leaderPointsLeftPosXEnd[i],		3		: unID=unID+1
		HOTSPOT2 midPointX,							midPointY,						unID, leaderPointsLeftPosXEnd[i],		2		: unID=unID+1

		HOTSPOT2 midPointX,							leaderPointsLeftPosYStart[i],	unID, leaderPointsLeftPosYEnd[i],		1+128	: unID=unID+1
		HOTSPOT2 midPointX,							leaderPointsLeftPosYStart[i]-1,	unID, leaderPointsLeftPosYEnd[i],		3		: unID=unID+1
		HOTSPOT2 midPointX,							midPointY,						unID, leaderPointsLeftPosYEnd[i],		2		: unID=unID+1

		del 1
	next i
	del 1

return

"leadersRight":
	add2 totalCommonPointRightPosX, 0
	for i = 1 to iPointerNumSide2
		line_type pointerLineType
		pen pointerPen

		add2 0,commonPointPosY

		length_p1	= SQR(((leaderPointsRightPosXEnd[i])^2)+((leaderPointsRightPosYEnd[i])^2))
		length_n1	= 2 * length_p1
		midPointX	= leaderPointsRightPosXStart[i] + leaderPointsRightPosXEnd[i]
		midPointY	= leaderPointsRightPosYStart[i] + leaderPointsRightPosYEnd[i]

		if (ABS(leaderPointsRightPosXEnd[i])<EPS & ABS(leaderPointsRightPosYEnd[i])<EPS) then
			if (ABS(leaderPointsRightPosXStart[i])<EPS & ABS(leaderPointsRightPosYStart[i])<EPS) then
				angle1=0
			else
				length_p1	= SQR(((leaderPointsRightPosXStart[i])^2)+((leaderPointsRightPosYStart[i])^2))
				if (leaderPointsRightPosXStart[i]) > 0 THEN
					angle1=ASN(((leaderPointsRightPosYStart[i]))/length_p1)
				else
					angle1=-1*(ASN(((leaderPointsRightPosYStart[i]))/length_p1))+180
				endif
			endif
		else
			if (leaderPointsRightPosXEnd[i]) > 0 THEN
				angle1= 180 + ASN(((leaderPointsRightPosYEnd[i]))/length_p1)
			else
				angle1= 180 -1*(ASN(((leaderPointsRightPosYEnd[i]))/length_p1))+180
			endif
		endif

		arrowHeadLength		= 0
		if bEnableArrowHead then
			add2 leaderPointsRightPosXStart[i], leaderPointsRightPosYStart[i]
			rot2 180 + angle1
				gosub "arrowHead"
			del 2
		endif

		arrowHeadLengthXMod	= arrowHeadLength * COS(angle1)
		arrowHeadLengthYMod	= arrowHeadLength * SIN(angle1)

		if iPointerType = POINTER_STRAIGHT then
			LINE2 leaderPointsRightPosXStart[i] - arrowHeadLengthXMod, leaderPointsRightPosYStart[i] - arrowHeadLengthYMod, midPointX, midPointY
			LINE2 midPointX, midPointY, 0, 0
		else
			SPLINE2A 2,0,leaderPointsRightPosXStart[i] - arrowHeadLengthXMod, leaderPointsRightPosYStart[i] - arrowHeadLengthYMod, angle1,0,-length_n1,
						0,0,0,-length_n1,0
		endif

		!!! pointer
		HOTSPOT2 0,									leaderPointsRightPosYStart[i],	unID,	leaderPointsRightPosXStart[i],	1+128	: unID=unID+1
		HOTSPOT2 -1,								leaderPointsRightPosYStart[i],	unID,	leaderPointsRightPosXStart[i],	3		: unID=unID+1
		HOTSPOT2 leaderPointsRightPosXStart[i],		leaderPointsRightPosYStart[i],	unID,	leaderPointsRightPosXStart[i],	2		: unID=unID+1

		HOTSPOT2 leaderPointsRightPosXStart[i],		0,								unID,	leaderPointsRightPosYStart[i],	1+128	: unID=unID+1
		HOTSPOT2 leaderPointsRightPosXStart[i],		-1,								unID,	leaderPointsRightPosYStart[i],	3		: unID=unID+1
		HOTSPOT2 leaderPointsRightPosXStart[i],		leaderPointsRightPosYStart[i],	unID,	leaderPointsRightPosYStart[i],	2		: unID=unID+1

		!!! Tangent
		HOTSPOT2 leaderPointsRightPosXStart[i],		midPointY,						unID, leaderPointsRightPosXEnd[i],		1+128	: unID=unID+1
		HOTSPOT2 leaderPointsRightPosXStart[i]-1,	midPointY,						unID, leaderPointsRightPosXEnd[i],		3		: unID=unID+1
		HOTSPOT2 midPointX,							midPointY,						unID, leaderPointsRightPosXEnd[i],		2		: unID=unID+1

		HOTSPOT2 midPointX,							leaderPointsRightPosYStart[i],	unID, leaderPointsRightPosYEnd[i],		1+128	: unID=unID+1
		HOTSPOT2 midPointX,							leaderPointsRightPosYStart[i]-1,	unID, leaderPointsRightPosYEnd[i],		3		: unID=unID+1
		HOTSPOT2 midPointX,							midPointY,						unID, leaderPointsRightPosYEnd[i],		2		: unID=unID+1

		del 1
	next i
	del 1

return

"arrowHead":

	pen arrowHeadPen
	fill solidFillForMultiLabel

	arrowHeadSize		= arrowHeadSizePaper * PAPER_TO_MODEL

	if iArrowHeadType = 1 then
		poly2_b 3, 1 + 4, arrowHeadPen, arrowHeadPen,
			arrowHeadSize / 2, arrowHeadSize / 2, 1,
			0, 0, 1,
			arrowHeadSize / 2, -arrowHeadSize / 2, 0

		arrowHeadLength = arrowHeadSize / 2
	endif
	if iArrowHeadType = 2 then
		poly2_b 3, 1 + 4, arrowHeadPen, arrowHeadPen,
			arrowHeadSize / 2, arrowHeadSize / 2, 1,
			0, 0, 1,
			arrowHeadSize / 2, -arrowHeadSize / 2, 1

		arrowHeadLength = arrowHeadSize / 2
	endif
	if iArrowHeadType = 3 then
		poly2_b 3, 1 + 2 + 4, arrowHeadPen, arrowHeadPen,
			arrowHeadSize / 2, arrowHeadSize / 2, 1,
			0, 0, 1,
			arrowHeadSize / 2, -arrowHeadSize / 2, 1

		arrowHeadLength = arrowHeadSize / 2
	endif
	if iArrowHeadType = 4 then
		line2 -arrowHeadSize / 2, -arrowHeadSize / 2, arrowHeadSize / 2, arrowHeadSize / 2
	endif
	if iArrowHeadType = 5 then
		poly2_b 5, 1 + 4, arrowHeadPen, arrowHeadPen,
			-arrowHeadSize / 2, 0, 1,
			0, 1, 800,
			arrowHeadSize / 2, 0, 1001,
			0, -1, 800,
			-arrowHeadSize / 2, 0, 1001

		arrowHeadLength = arrowHeadSize / 2
	endif
	if iArrowHeadType = 6 then
		poly2_b 5, 1 + 2 + 4, arrowHeadPen, arrowHeadPen,
			-arrowHeadSize / 2, 0, 1,
			0, 1, 800,
			arrowHeadSize / 2, 0, 1001,
			0, -1, 800,
			-arrowHeadSize / 2, 0, 1001

		arrowHeadLength = arrowHeadSize / 2
	endif
	if iArrowHeadType = 7 then
		line2 0, -arrowHeadSize / 2, 0, arrowHeadSize / 2
	endif
	if iArrowHeadType = 8 then
		poly2_b 3, 1 + 4, arrowHeadPen, arrowHeadPen,
			(arrowHeadSize / 2) / TAN(15), arrowHeadSize / 2, 1,
			0, 0, 1,
			(arrowHeadSize / 2) / TAN(15), -arrowHeadSize / 2, 0

		arrowHeadLength = (arrowHeadSize / 2) / TAN(15)
	endif
	if iArrowHeadType = 9 then
		poly2_b 3, 1 + 4, arrowHeadPen, arrowHeadPen,
			(arrowHeadSize / 2) / TAN(15), arrowHeadSize / 2, 1,
			0, 0, 1,
			(arrowHeadSize / 2) / TAN(15), -arrowHeadSize / 2, 1

		arrowHeadLength = (arrowHeadSize / 2) / TAN(15)
	endif
	if iArrowHeadType = 10 then
		poly2_b 3, 1 + 2 + 4, arrowHeadPen, arrowHeadPen,
			(arrowHeadSize / 2) / TAN(15), arrowHeadSize / 2, 1,
			0, 0, 1,
			(arrowHeadSize / 2) / TAN(15), -arrowHeadSize / 2, 1

		arrowHeadLength = (arrowHeadSize / 2) / TAN(15)
	endif
	if iArrowHeadType = 11 then
		line2 -(arrowHeadSize / 2) / TAN(60), -arrowHeadSize / 2, (arrowHeadSize / 2) / TAN(60), arrowHeadSize / 2
	endif
	if iArrowHeadType = 12 then
		poly2_b 5, 1 + 4, arrowHeadPen, arrowHeadPen,
			-arrowHeadSize / 2, 0, 1,
			0, 1, 800,
			arrowHeadSize / 2, 0, 1001,
			0, -1, 800,
			-arrowHeadSize / 2, 0, 1001

		line2 -arrowHeadSize / 2, 0, arrowHeadSize / 2, 0
		line2 0, -arrowHeadSize / 2, 0, arrowHeadSize / 2

		arrowHeadLength = arrowHeadSize / 2
	endif
	if iArrowHeadType = 13 then
		poly2_b 5, 1 + 4, arrowHeadPen, arrowHeadPen,
			-arrowHeadSize / 2, 0, 1,
			0, 1, 800,
			arrowHeadSize / 2, 0, 1001,
			0, -1, 800,
			-arrowHeadSize / 2, 0, 1001

		poly2_b 4, 1 + 2 + 4, arrowHeadPen, arrowHeadPen,
			0, 0, 1,
			-arrowHeadSize / 2, 0, 0,
			0, -1, 800,
			0, -arrowHeadSize / 2, 1001

		poly2_b 4, 1 + 2 + 4, arrowHeadPen, arrowHeadPen,
			0, 0, 1,
			arrowHeadSize / 2, 0, 0,
			0, 1, 800,
			0, arrowHeadSize / 2, 1001

		arrowHeadLength = arrowHeadSize / 2
	endif
	if iArrowHeadType = 14 then
		poly2_b 3, 1 + 4, arrowHeadPen, arrowHeadPen,
			arrowHeadSize / 2, arrowHeadSize / 2, 1,
			0, 0, 1,
			arrowHeadSize / 2, -arrowHeadSize / 2, 0

		arrowHeadLength = arrowHeadSize / 2
	endif

	pen pointerPen
	if	iArrowHeadType = 1 |\
		iArrowHeadType = 8 |\
		iArrowHeadType = 14 then

		line2 0, 0, arrowHeadLength, 0
	endif

return

"lineConnection":

	pen pointerPen

	line2 - headBoxOffsetLeftRight + textBoxPosX, commonPointPosY, textBoxLength + headBoxOffsetLeftRight + textBoxPosX, commonPointPosY

return

"headshape":

	pen pointerPen
	line_type 1
	fill fillMarkerBackground

	add2 textBoxPosX, 0
		if iShapeHeadBox = HEADSHAPE_CIRCLE then
			poly2_b 2, 1 + 2 * bFrameOpaque + 4, frameOpaquePen, frameOpaquePen,
				textBoxLength / 2, - textBoxHeight / 2, 900,
				headBoxLength / 2, 360, 4001

			if NOT(bAutoHeadBox) then
				add2 MAX(textBoxLength, textBoxLength / 2 + textBoxHeight / 2), -textBoxHeight / 2
					hotspot2	0,		0,					unID, headBoxOffsetLeftRightPaper_M,	1 + 128 + 1024,	headBoxLengthPaper		: unID = unID + 1
					hotspot2   	-1,	0,						unID, headBoxOffsetLeftRightPaper_M,	3 + 1024,		headBoxLengthPaper		: unID = unID + 1
					hotspot2 	headBoxOffsetLeftRight,	0,	unID, headBoxOffsetLeftRightPaper_M,	2 + 1024,		headBoxLengthPaper		: unID = unID + 1
				del 1
			endif
		endif

		if iShapeHeadBox = HEADSHAPE_RECT then
			add2 - headBoxOffsetLeftRight, headBoxOffsetUpDown
				poly2_b 4, 1 + 2 * bFrameOpaque + 4, frameOpaquePen, frameOpaquePen,
					0, 0, 1,
					headBoxLength, 0, 1,
					headBoxLength, - headBoxWidth, 1,
					0, - headBoxWidth, 1
			del 1

			if NOT(bAutoHeadBox) then
				add2 textBoxLength + headBoxOffsetLeftRight, 0
					hotspot2	0,	0,						unID, headBoxOffsetUpDownPaper_M, 1 + 128 + 1024,	headBoxWidthPaper		: unID = unID + 1
					hotspot2   	0,	-1,						unID, headBoxOffsetUpDownPaper_M, 3 + 1024,			headBoxWidthPaper		: unID = unID + 1
					hotspot2 	0,	headBoxOffsetUpDown,	unID, headBoxOffsetUpDownPaper_M, 2 + 1024,			headBoxWidthPaper		: unID = unID + 1
				del 1

				add2 textBoxLength, headBoxOffsetUpDown
					hotspot2	0,		0,					unID, headBoxOffsetLeftRightPaper_M, 1 + 128 + 1024,	headBoxLengthPaper		: unID = unID + 1
					hotspot2   	-1,		0,					unID, headBoxOffsetLeftRightPaper_M, 3 + 1024,			headBoxLengthPaper		: unID = unID + 1
					hotspot2 	headBoxOffsetLeftRight,	0,	unID, headBoxOffsetLeftRightPaper_M, 2 + 1024,			headBoxLengthPaper		: unID = unID + 1
				del 1
			endif
		endif

		if iShapeHeadBox = HEADSHAPE_DIAMOND then
			add2 textBoxLength / 2, - textBoxHeight  / 2
				poly2_b 4, 1 + 2 * bFrameOpaque + 4, frameOpaquePen, frameOpaquePen,
					headBoxLength / 2, 0, 1,
					0, - headBoxWidth / 2, 1,
					- headBoxLength / 2, 0, 1,
					0, headBoxWidth / 2, 1
			del 1

			if NOT(bAutoHeadBox) then
				add2 textBoxLength + headBoxOffsetLeftRight, 0
					hotspot2	0,	0,						unID, headBoxOffsetUpDownPaper_M,	1 + 128 + 1024,	headBoxWidthPaper		: unID = unID + 1
					hotspot2   	0,	-1,						unID, headBoxOffsetUpDownPaper_M, 	3 + 1024,		headBoxWidthPaper		: unID = unID + 1
					hotspot2 	0,	headBoxOffsetUpDown,	unID, headBoxOffsetUpDownPaper_M, 	2 + 1024,		headBoxWidthPaper		: unID = unID + 1
				del 1

				add2 textBoxLength, headBoxOffsetUpDown
					hotspot2	0,		0,						unID, headBoxOffsetLeftRightPaper_M, 1 + 128 + 1024,	headBoxLengthPaper		: unID = unID + 1
					hotspot2   	-1,	0,							unID, headBoxOffsetLeftRightPaper_M, 3 + 1024,			headBoxLengthPaper		: unID = unID + 1
					hotspot2 	headBoxOffsetLeftRight,	0,		unID, headBoxOffsetLeftRightPaper_M, 2 + 1024,			headBoxLengthPaper		: unID = unID + 1
				del 1
			endif
		endif

		if iShapeHeadBox = HEADSHAPE_ELLIPSE then
			mul2 1, headBoxWidth / headBoxLength
				poly2_b 2, 1 + 2 * bFrameOpaque + 4, frameOpaquePen, frameOpaquePen,
					textBoxLength / 2, - textBoxHeight / 2 / (headBoxWidth / headBoxLength), 900,
					headBoxLength / 2, 360, 4001
			del 1

			if NOT(bAutoHeadBox) then
				add2 textBoxLength + headBoxOffsetLeftRight, 0
					hotspot2	0,	0,						unID, headBoxOffsetUpDownPaper_M, 1 + 128 + 1024,	headBoxWidthPaper		: unID = unID + 1
					hotspot2   	0,	-1,						unID, headBoxOffsetUpDownPaper_M, 3 + 1024,			headBoxWidthPaper		: unID = unID + 1
					hotspot2 	0,	headBoxOffsetUpDown,	unID, headBoxOffsetUpDownPaper_M, 2+ 1024,			headBoxWidthPaper		: unID = unID + 1
				del 1

				add2 textBoxLength, headBoxOffsetUpDown
					hotspot2	0,		0,						unID, headBoxOffsetLeftRightPaper_M, 1 + 128 + 1024,	headBoxLengthPaper		: unID = unID + 1
					hotspot2   	-1,	0,							unID, headBoxOffsetLeftRightPaper_M, 3 + 1024,			headBoxLengthPaper		: unID = unID + 1
					hotspot2 	headBoxOffsetLeftRight,	0,		unID, headBoxOffsetLeftRightPaper_M, 2 + 1024,			headBoxLengthPaper		: unID = unID + 1
				del 1
			endif
		endif

		if iShapeHeadBox = HEADSHAPE_OVAL then
			add2 - headBoxOffsetLeftRight, headBoxOffsetUpDown
				poly2_b 6, 1 + 2 * bFrameOpaque + 4, frameOpaquePen, frameOpaquePen,
					headBoxLength - headBoxWidth / 2, 0, 1,
					1, 0, 800,
					headBoxLength - headBoxWidth / 2, - headBoxWidth, 1001,
					headBoxWidth / 2, - headBoxWidth, 1,
					-1, 0, 800,
					headBoxWidth / 2, 0, 1001
			del 1

			if NOT(bAutoHeadBox) then
				add2 textBoxLength + headBoxOffsetLeftRight, 0
					hotspot2	0,	0,						unID, headBoxOffsetUpDownPaper_M, 1 + 128 + 1024,		headBoxWidthPaper		: unID = unID + 1
					hotspot2   	0,	-1,						unID, headBoxOffsetUpDownPaper_M, 3 + 1024,			headBoxWidthPaper		: unID = unID + 1
					hotspot2 	0,	headBoxOffsetUpDown,	unID, headBoxOffsetUpDownPaper_M, 2 + 1024,			headBoxWidthPaper		: unID = unID + 1
				del 1

				add2 textBoxLength, headBoxOffsetUpDown
					hotspot2	0,		0,						unID, headBoxOffsetLeftRightPaper_M, 1 + 128 + 1024,	headBoxLengthPaper		: unID = unID + 1
					hotspot2   	-1,	0,							unID, headBoxOffsetLeftRightPaper_M, 3 + 1024,		headBoxLengthPaper		: unID = unID + 1
					hotspot2 	headBoxOffsetLeftRight,	0,		unID, headBoxOffsetLeftRightPaper_M, 2 + 1024,			headBoxLengthPaper		: unID = unID + 1
				del 1
			endif
		endif

		if iShapeHeadBox = HEADSHAPE_HEXAGON then
			add2 - headBoxOffsetLeftRight, headBoxOffsetUpDown
				poly2_b 6, 1 + 2 * bFrameOpaque + 4, frameOpaquePen, frameOpaquePen,
					headShapeSidePointXPos, 0, 1,
					headBoxLength - headShapeSidePointXPos, 0, 1,
					headBoxLength, - headBoxWidth / 2, 1,
					headBoxLength - headShapeSidePointXPos, - headBoxWidth, 1,
					headShapeSidePointXPos, - headBoxWidth, 1,
					0, - headBoxWidth / 2, 1
			del 1

			if NOT(bAutoHeadBox) then
				add2 textBoxLength + headBoxOffsetLeftRight, 0
					hotspot2	0,	0,						unID, headBoxOffsetUpDownPaper_M, 1 + 128 + 1024,	headBoxWidthPaper		: unID = unID + 1
					hotspot2   	0,	-1,						unID, headBoxOffsetUpDownPaper_M, 3 + 1024,		headBoxWidthPaper		: unID = unID + 1
					hotspot2 	0,	headBoxOffsetUpDown,	unID, headBoxOffsetUpDownPaper_M, 2 + 1024,		headBoxWidthPaper		: unID = unID + 1
				del 1

				add2 textBoxLength, headBoxOffsetUpDown
					hotspot2	0,		0,						unID, headBoxOffsetLeftRightPaper_M, 1 + 128 + 1024,	headBoxLengthPaper		: unID = unID + 1
					hotspot2   	-1,	0,							unID, headBoxOffsetLeftRightPaper_M, 3 + 1024,			headBoxLengthPaper		: unID = unID + 1
					hotspot2 	headBoxOffsetLeftRight,	0,		unID, headBoxOffsetLeftRightPaper_M, 2 + 1024,			headBoxLengthPaper		: unID = unID + 1
				del 1

				add2 textBoxLength + headBoxOffsetLeftRight, headBoxOffsetUpDown
					hotspot2	0,		0,						unID, headShapeSidePointXPosPaper_M,  	1 + 128 + 1024, headShapeSidePointXPosPaper	: unID = unID + 1
					hotspot2   	1,	0,							unID, headShapeSidePointXPosPaper_M, 	3 + 1024,		headShapeSidePointXPosPaper		: unID = unID + 1
					hotspot2 	-headShapeSidePointXPos,	0,	unID, headShapeSidePointXPosPaper_M, 	2 + 1024,		headShapeSidePointXPosPaper		: unID = unID + 1
				del 1
			endif
		endif

		if iShapeHeadBox = HEADSHAPE_OCTOGON then
			add2 - headBoxOffsetLeftRight, headBoxOffsetUpDown
				poly2_b 8, 1 + 2 * bFrameOpaque + 4, frameOpaquePen, frameOpaquePen,
					headShapeSidePointXPos, 0, 1,
					headBoxLength - headShapeSidePointXPos, 0, 1,
					headBoxLength, - headBoxWidth / 3, 1,
					headBoxLength, - headBoxWidth * 2 / 3, 1,
					headBoxLength - headShapeSidePointXPos, - headBoxWidth, 1,
					headShapeSidePointXPos, - headBoxWidth, 1,
					0, - headBoxWidth * 2 / 3, 1,
					0, - headBoxWidth / 3, 1
			del 1

			if NOT(bAutoHeadBox) then
				add2 textBoxLength + headBoxOffsetLeftRight, 0
					hotspot2	0,	0,						unID, headBoxOffsetUpDownPaper_M, 1 + 128 + 1024,		headBoxWidthPaper		: unID = unID + 1
					hotspot2   	0,	-1,						unID, headBoxOffsetUpDownPaper_M, 3 + 1024,			headBoxWidthPaper		: unID = unID + 1
					hotspot2 	0,	headBoxOffsetUpDown,	unID, headBoxOffsetUpDownPaper_M, 2 + 1024,			headBoxWidthPaper		: unID = unID + 1
				del 1

				add2 textBoxLength, headBoxOffsetUpDown
					hotspot2	0,		0,						unID, headBoxOffsetLeftRightPaper_M, 1 + 128 + 1024,	headBoxLengthPaper		: unID = unID + 1
					hotspot2   	-1,		0,						unID, headBoxOffsetLeftRightPaper_M, 3 + 1024,		headBoxLengthPaper		: unID = unID + 1
					hotspot2 	headBoxOffsetLeftRight,	0,		unID, headBoxOffsetLeftRightPaper_M, 2 + 1024,		headBoxLengthPaper		: unID = unID + 1
				del 1

				add2 textBoxLength + headBoxOffsetLeftRight, headBoxOffsetUpDown
					hotspot2	0,		0,						unID, headShapeSidePointXPosPaper_M,  	1 + 128 + 1024, headShapeSidePointXPosPaper	: unID = unID + 1
					hotspot2   	1,		0,						unID, headShapeSidePointXPosPaper_M, 	3 + 1024,		headShapeSidePointXPosPaper		: unID = unID + 1
					hotspot2 	- headShapeSidePointXPos,	0,	unID, headShapeSidePointXPosPaper_M, 	2 + 1024,		headShapeSidePointXPosPaper		: unID = unID + 1
				del 1
			endif
		endif

		if iShapeHeadBox = HEADSHAPE_POINTED_RECT then
			add2 - headBoxOffsetLeftRight, headBoxOffsetUpDown
				poly2_b 6, 1 + 2 * bFrameOpaque + 4, frameOpaquePen, frameOpaquePen,
					textBoxHeight / 3, 0, 1,
					headBoxLength - textBoxHeight / 3, 0, 1,
					headBoxLength, - headBoxWidth / 2, 1,
					headBoxLength - textBoxHeight / 3, - headBoxWidth, 1,
					textBoxHeight / 3, - headBoxWidth, 1,
					0, - headBoxWidth / 2, 1
			del 1

			if NOT(bAutoHeadBox) then
				add2 textBoxLength + headBoxOffsetLeftRight, 0
					hotspot2	0,	0,						unID, headBoxOffsetUpDownPaper_M, 1 + 128 + 1024,	headBoxWidthPaper		: unID = unID + 1
					hotspot2   	0,	-1,						unID, headBoxOffsetUpDownPaper_M, 3 + 1024,			headBoxWidthPaper		: unID = unID + 1
					hotspot2 	0,	headBoxOffsetUpDown,	unID, headBoxOffsetUpDownPaper_M, 2 + 1024,			headBoxWidthPaper		: unID = unID + 1
				del 1

				add2 textBoxLength, headBoxOffsetUpDown
					hotspot2	0,		0,					unID, headBoxOffsetLeftRightPaper_M, 1 + 128 + 1024,	headBoxLengthPaper		: unID = unID + 1
					hotspot2   	-1,		0,					unID, headBoxOffsetLeftRightPaper_M, 3 + 1024,			headBoxLengthPaper		: unID = unID + 1
					hotspot2 	headBoxOffsetLeftRight,	0,	unID, headBoxOffsetLeftRightPaper_M, 2 + 1024,			headBoxLengthPaper		: unID = unID + 1
				del 1
			endif
		endif
	del 1

return


