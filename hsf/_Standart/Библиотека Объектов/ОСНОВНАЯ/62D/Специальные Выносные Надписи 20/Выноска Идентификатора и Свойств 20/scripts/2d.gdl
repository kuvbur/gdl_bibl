
! ==============================================================================
! Functions:
! - Offered Tools: all
! - Content: Name and ID and Material
! - Size: paper size
! ==============================================================================
_isPreview = (GLOB_CONTEXT = 5)
_paperToModel = GLOB_SCALE/1000

! resizing paper size parameters values to model length
widthTextBoxContent_mm		= widthTextBoxContent_mm * _paperToModel
widthHead_mm				= widthHead_mm * _paperToModel
heightHead_mm				= heightHead_mm * _paperToModel
distanceLabelHead_mm		= distanceLabelHead_mm * _paperToModel
thkLeaderLine_mm 			= thkLeaderLine_mm * _paperToModel
lengthExtensionLine_mm		= lengthExtensionLine_mm * _paperToModel
thkExtensionLine_mm			= thkExtensionLine_mm * _paperToModel

gosub "install_label_position"

gosub "collect_content"

gosub "position_and_draw_label"

! ==============================================================================
END	!END	!END	!END	!END	!END	!END	!END	!END	!END	!END
! ==============================================================================

! ==============================================================================
"install_label_position":
! ------------------------------------------------------------------------------
! Label positioning - global behavior for Marker form Labels
! - origin is where AC gives, the table begins with top left anchor
! - orientation is rotated with the parent structure by default
! - without AC Arrow
!		- drawing the full symbol marker form
! 		- the origin is at the arrow peak
! 		- rotating with parent elem direction
! 		- Reference Point is cordinated by user
! - with AC Arrow
!		- drawing only the head text
!		- the origin is at the boundary
!		- handling of rotation is belongs to AC (AC_CustomReadabilty OFF)
!		- Reference Point is cordinated at Pointer tabpage
!
! LABEL_POSITION 	- position of the label
! 					- array[3][2] containing the coordinates of the 3 points defining the label position
!
! - the other transformations live in the label_marker_macro
! ==============================================================================

	nTrans = 0

	if LABEL_CUSTOM_ARROW then

		add2 	LABEL_POSITION [2][1]	+	LABEL_POSITION [3][1],
				LABEL_POSITION [2][2]	+	LABEL_POSITION [3][2]

	endif

return

! ==============================================================================
"collect_content":
! ------------------------------------------------------------------------------
! ==============================================================================
	nTrans = 0

	_nRowLabel = 0
	dim _sRowsOfLabel[][]
		_sRowsOfLabel[1][1] = ""
	dim _sContentStringsHead[][]
		_sContentStringsHead[1][1] = ""

	_sSeparator = " "
	_sSuffixName = ""
	_sSuffixID = ""

	dim _iUnitLocal[12]
		for iA = 1 to 12
			_iUnitLocal[iA] = 0	! no need unit
		next iA

	if i1stRowContent <> CONTENT_PROPERTY then
		_i1stRowContent = i1stRowContent
		_stCustomText1 = stCustomText1
	else
		_stPropertyValue = ""
		_i1stRowContent = CONTENT_CUSTOM
		_stPropertyID = stPropertyID1
		gosub "getPropertyValue"
		_stCustomText1 = _stPropertyValue
	endif

	dim _iSelectedContent[]
	_iSelectedContent[1]= _i1stRowContent
	_iIDText 			= iIDText1
	_sSuffixID			= _sSeparator
	_sSuffixName 		= _sSeparator
	_stCustomText 		= _stCustomText1 + _sSeparator
	gosub "call_general_label_macro"	! returned text array, _nRowLabel, _sRowsOfLabel
	_sContentStringsHead = _sRowsOfLabel
	_numRow = vardim1(_sContentStringsHead)
	_numColu = vardim2(_sContentStringsHead)

	if b2ndRowContent then

		if i2ndRowContent <> CONTENT_PROPERTY then
			_i2ndRowContent = i2ndRowContent
			_stCustomText2 = stCustomText2
		else
			_stPropertyValue = ""
			_i2ndRowContent = CONTENT_CUSTOM
			_stPropertyID = stPropertyID2
			gosub "getPropertyValue"
			_stCustomText2 = _stPropertyValue
		endif

		dim _iSelectedContent[]
		_iSelectedContent[1]= _i2ndRowContent
		_iIDText 			= iIDText2
		_sSuffixID			= _sSeparator
		_sSuffixName 		= _sSeparator
		_stCustomText 		= _stCustomText2 + _sSeparator
		gosub "call_general_label_macro"	! returned text array, _nRowLabel, _sRowsOfLabel
		if iArrangeContent = ARRANGE_ROW then
			for iRow = 1 to vardim1(_sRowsOfLabel)
				for iColu = 1 to vardim2(_sRowsOfLabel)
					_sContentStringsHead[iRow][_numColu + iColu] = _sRowsOfLabel[iRow][iColu]
				next iColu
			next iRow
		else
			for iRow = 1 to vardim1(_sRowsOfLabel)
				for iColu = 1 to vardim2(_sRowsOfLabel)
					_sContentStringsHead[_numRow + iRow][iColu] = _sRowsOfLabel[iRow][iColu]
				next iColu
			next iRow
		endif
		_numRow = vardim1(_sContentStringsHead)
		_numColu = vardim2(_sContentStringsHead)
	endif

	if b3rdRowContent then

		if i3rdRowContent <> CONTENT_PROPERTY then
			_i3rdRowContent = i3rdRowContent
			_stCustomText3 = stCustomText3
		else
			_stPropertyValue = ""
			_i3rdRowContent = CONTENT_CUSTOM
			_stPropertyID = stPropertyID3
			gosub "getPropertyValue"
			_stCustomText3 = _stPropertyValue
		endif

		dim _iSelectedContent[]
		_iSelectedContent[1]= _i3rdRowContent
		_iIDText 			= iIDText3
		_sSuffixID			= ""
		_sSuffixName 		= ""
		_stCustomText 		= _stCustomText3
		gosub "call_general_label_macro"	! returned text array, _nRowLabel, _sRowsOfLabel
		if iArrangeContent = ARRANGE_ROW then
			for iRow = 1 to vardim1(_sRowsOfLabel)
				for iColu = 1 to vardim2(_sRowsOfLabel)
					_sContentStringsHead[iRow][_numColu + iColu] = _sRowsOfLabel[iRow][iColu]
				next iColu
			next iRow
		else
			for iRow = 1 to vardim1(_sRowsOfLabel)
				for iColu = 1 to vardim2(_sRowsOfLabel)
					_sContentStringsHead[_numRow + iRow][iColu] = _sRowsOfLabel[iRow][iColu]
				next iColu
			next iRow
		endif
		_numRow = vardim1(_sContentStringsHead)
		_numColu = vardim2(_sContentStringsHead)
	endif

return

! ==============================================================================
"position_and_draw_label":
! ------------------------------------------------------------------------------
! Text Style tabpage:
! LABEL_CUSTOM_ARROW 		- use symbol arrow option
!								- on/off 1 if the Use symbol arrow checkbox is checked, 0 otherwise
! LABEL_ARROW_LINETYPE 		- line type of the line of the arrow
! LABEL_ARROW_PEN 			- pen of the arrow
! LABEL_FONT_NAME 			- font name
! LABEL_TEXT_SIZE			- text size
! LABEL_TEXT_PEN 			- pen of the text
! LABEL_TEXT_BG_PEN			- text box background pen
! 								- 0 if opaque is off, the background pen otherwise
! LABEL_FONT_STYLE2 		- font style in the settings dialog box
!								- 0 - normal, otherwise j1 + 2*j2 + 4*j3 + 32*j6 + 64*j7 + 128*j8, j1 - bold, j2 - italic, j3 - underline, j6 - superscript, j7 - subscript, j8 - strikethrough
!								- there is strikethrough and this global works well with define style{2} !
! LABEL_FRAME_ON			- label frame on/off 1 if the label frame is checked, 0 otherwise
! LABEL_ROTANGLE 			- rotation angle using by AC (this rotation is not from GDL)
! LABEL_TEXT_ALIGN			- text alignment for full table
!								- 1 - left aligned, 2 - center aligned, 3 - right aligned, 4 - full justified
! LABEL_TEXT_LEADING 		- line spacing factor
! LABEL_TEXT_WIDTH_FACT 	- width factor
! LABEL_TEXT_CHARSPACE_FACT - spacing factor
! ==============================================================================

	_angleParentDirection = 0
	if not(_isPreview) then
		_angleParentDirection = LABEL_ASSOC_ELEM_ORIENTATION
	endif

	call "label_marker_form" parameters AC_CustomReadability = AC_CustomReadability,
		bUseBuiltinPointer			= not(LABEL_CUSTOM_ARROW),
		bAlwaysReadable				= LABEL_ALWAYS_READABLE,
		bEnableHeadWithPointer		= 1,

		! Position
		iReferencePoint				= 5,
		iLabelOrientation 			= iLabelOrientation,
		bFlipLabel 					= bFlipLabel,
		!bMirrorLabel 				= bMirrorLabel,
		anglePosition 				= LABEL_ROTANGLE,
		angleParentPosition			= _angleParentDirection,

		! Paragraph Format
		bEnablePrefixColumn			= 0,
		bUsePrefixColumn			= 0,
		bWrapText					= LABEL_TEXT_WRAP,
		widthTextBoxContent_mm		= widthTextBoxContent_mm,
		xFirstIndentParagraph		= 0,
		xLeftIndentParagraph		= 0,
		xRightIndentParagraph		= 0,
		xTabPositionParagraph		= 0,
		widthFactorTextBlock		= LABEL_TEXT_WIDTH_FACT,
		charspaceFactorTextBlock	= LABEL_TEXT_CHARSPACE_FACT,
		iFixedHeightTextBlock		= 0,		! fixed_height 	1: the placed TEXTBLOCK will be scale-independent and all specified length type parameters will mean millimeters, !
										!0: the placed TEXTBLOCK will be scale-dependent and all specified length type parameters will mean meters in model space

		! Head apperance
		sContentStringsHead			= _sContentStringsHead,
		bEnableCustomHeaderStyle 	= 0,
		penTextHeader				= LABEL_TEXT_PEN,
		fontTypeHeader				= LABEL_FONT_NAME,
		sizeFontHeader_mm			= LABEL_TEXT_SIZE,
		bBoldStyleHeader			= bittest(LABEL_FONT_STYLE2,0),
		bItalicStyleHeader			= bittest(LABEL_FONT_STYLE2,1),
		bUnderlineStyleHeader		= bittest(LABEL_FONT_STYLE2,2),
		bStrikethroughStyleHeader	= bittest(LABEL_FONT_STYLE2,7),
		iAlignmentHeader			= LABEL_TEXT_ALIGN,	! 1: left aligned, 2: center aligned, 3: right aligned, 4: full justified
		sizeLeadingHeader			= LABEL_TEXT_LEADING,
		widthTextBoxOffset			= LABEL_FRAME_OFFSET * _paperToModel,

		! Body skin list appearance
		bUseTextBoxOnLine				= 0,

		! Label Head Representation
		bEnableHeadSwitch			= 0,							! Enable to switch the Show Label Head ON-OFF
		bShowHead					= 1,
		iShapeHead					= iShapeHead,
		bFitFrameToText	= bFitFrameToText,
		widthHead_mm				= widthHead_mm,
		heightHead_mm				= heightHead_mm,
		bLinkSizes					= bLinkSizes,
		bShowHeadContour			= LABEL_FRAME_ON,
		penHead						= LABEL_ARROW_PEN,
		lineTypeHead				= LABEL_ARROW_LINETYPE,
		bShowFill					= 1,
		fillType					= filltypeBackground,
		penForeground				= LABEL_TEXT_BG_PEN,
		penBackground				= LABEL_TEXT_BG_PEN,
		bEnableSeparatorLine		= _bEnableSeparatorLine,
		bShowSeparatorLines			= bShowSeparatorLines,

		! Label Line Representation
		distanceLabelHead_mm		= distanceLabelHead_mm,
		bEnableLeaderLine			= 1,
		bShowLeaderLine				= bShowLeaderLine,
		penLeaderLine				= LABEL_ARROW_PEN,
		linetypeLeaderLine			= LABEL_ARROW_LINETYPE,
		iLeaderLineStyle			= iLeaderLineStyle,
		thkLeaderLine_mm			= thkLeaderLine_mm,
		iExtensionLineStyle 		= iExtensionLineStyle,
		lengthExtensionLine_mm		= lengthExtensionLine_mm,
		thkExtensionLine_mm			= thkExtensionLine_mm,

		bDebug						= 0

	del nTrans : nTrans = 0

return


! ==============================================================================
"getPropertyValue":
! ==============================================================================
	dim	propertyValues[]
	m = REQUEST ("Property_Value_Of_Parent", _stPropertyID, _typeValue, dim1, dim2, propertyValues)

	if m > 3 then
		for j = 1 to vardim1(propertyValues)
			if j > 1 then
				_stPropertyValue = _stPropertyValue + "; "
			endif

			if _typeValue = 4 then
				_stPropertyValue = _stPropertyValue + propertyValues[j]
			else
				if _typeValue = 3 then
					_stPropertyValue = _stPropertyValue + str ("%.2", propertyValues[j])
				else
					if _typeValue = 2 then
						_stPropertyValue = _stPropertyValue + str ("%.0", propertyValues[j])
					else
						if propertyValues[j] > 0 then
							_stPropertyValue = _stPropertyValue + `ИСТИНА`
						else
							_stPropertyValue = _stPropertyValue + `ЛОЖЬ`
						endif
					endif
				endif
			endif
		next j
	else
		_stPropertyValue = "<" + `Значение Свойства` + ">"
	endif
	r = REQUEST ("Property_Name", _stPropertyID, _typeName, _groupName, _propertyName)
	if strstr(_propertyName, "Масса ед")>EPS and strstr(_stPropertyValue, "кг")<EPS then _stPropertyValue = _stPropertyValue + "кг"
return


! ==============================================================================
"call_general_label_macro":
! ------------------------------------------------------------------------------
! input:
!	i1stRowContent, i2ndRowContent, i3rdRowContent
!	iIDPlacing
!	_sSeparator
!	iIDText
!
! input variable
!	totalRotate
!	_drawContent - 0 - calculating only, 1 - draw text
!
! output variable:
!	_widthTextBlock, _heightTextBlock
! ==============================================================================

	_nRowLabel = 0
	dim tempsRowsOfLabel[]
		tempsRowsOfLabel[1] = ""
	call "label_content_macro" parameters all iSelectedContent = _iSelectedContent,
			iUnitLocal					= _iUnitLocal,
			bUseInSingleRank			= 0,

			bUsePrefixColumn			= 0,

			bShowSuperScript			= 1,
			bShowUnit					= 0,
			bShow2D						= 0,

			iIDText						= _iIDText,
			sPrefixID					= "",
			sSuffixID					= _sSuffixID,

			sPrefixName 				= "",
			sSuffixName					= _sSuffixName,

			sTextDataCustom				= _stCustomText,

		 returned_parameters _nRowLabel, tempsRowsOfLabel

		! making from one dimensioned array to two dimensioned
		idx = 0
		dim _sRowsOfLabel[][]
			_sRowsOfLabel[1][1] = ""
		for i = 1 to _nRowLabel
			for j = 1 to 5		! no need the full 30 cells, there is only one content by macrocalling (1 content need 5 cells)
				_sRowsOfLabel[i][j] = tempsRowsOfLabel[idx + j]
			next j
			idx = idx + 30
		next i
return

