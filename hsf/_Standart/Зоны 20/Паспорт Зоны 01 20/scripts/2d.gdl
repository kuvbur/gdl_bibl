
PAPER_TO_MODEL		= GLOB_SCALE / 1000	! Convert paper size to model size
MODEL_TO_PAPER		= 1000 / GLOB_SCALE	! Convert model size to paper size

if bScaleSensitive then
	_iScale = SCALE_200
	if GLOB_SCALE < 100 + eps then _iScale = SCALE_100
	if GLOB_SCALE < 50  + eps then _iScale = SCALE_50
else
	_iScale = SCALE_INSENSITIVE
endif

! number of available rows is managed by "maxFunctionOrder" parameter
dim functionOrder2D[14]
	functionOrder2D[1] = iOrder_1[_iScale]
	functionOrder2D[2] = iOrder_2[_iScale]
	functionOrder2D[3] = iOrder_3[_iScale]
	functionOrder2D[4] = iOrder_4[_iScale]
	functionOrder2D[5] = iOrder_5[_iScale]
	functionOrder2D[6] = iOrder_6[_iScale]
	functionOrder2D[7] = iOrder_7[_iScale]
	functionOrder2D[8] = iOrder_8[_iScale]
	functionOrder2D[9] = iOrder_9[_iScale]
	functionOrder2D[10] = iOrder_10[_iScale]
	functionOrder2D[11] = iOrder_11[_iScale]
	functionOrder2D[12] = iOrder_12[_iScale]
	functionOrder2D[13] = iOrder_13[_iScale]
	functionOrder2D[14] = iOrder_14[_iScale]

! ==============================================================================
! Content
! 1 : None					->	""
! 2 : Zone Name				->	title
! 3 : Zone No.				->	title
! 4 : Measured Area			->	title + calculeted value with unit
! 5 : Measured Tsubo Area	-> 	title + calculeted value with unit / duplicated areas (TAI)
! 6 : Calculated Area		->	title + calculeted value with unit
! 7 : Calculated Tsubo Area	-> 	title + calculeted value with unit / duplicated areas (TAI)
! 8 : Flooring				->	title
! 9 : Perimeter				->	title + calculeted value with unit
! 10 : Ceiling Height		->	title + calculeted value with unit
! 11 : Volume				->	title + calculeted value with unit
! 12 : Occupancy			->	title
! 13 : Zone ID				->	title
! 14 : Additional Tags		->	Parametergruop
! 15 : Custom Text			->	title
! 16 : Room Number			->	title (USA)
! 17 : Zone Name and Number	->	title (USA)
! 18 : Surface Code			->	title (USA)
! ==============================================================================

! Displayed groups and their booleans line by line
! ------------------------------------------------------------------------------
dim bParam[]
dim iParentGroup[]
for i = 1 to maxRowNumber
	bParam[i] = 0
	iParentGroup[i] = 0
next i

for i = 1 to numDisplayedGroup[_iScale]
! Just String
	if functionOrder2D[i] = ORDER_ZONE_ID then			bParam[ROW_ZONE_ID]		= 1 : iParentGroup[ROW_ZONE_ID] 	= ORDER_ZONE_ID
	if functionOrder2D[i] = ORDER_ZONE_NAME then		bParam[ROW_ZONE_NAME]	= 1 : iParentGroup[ROW_ZONE_NAME] 	= ORDER_ZONE_NAME

	if functionOrder2D[i] = ORDER_ZONE_NUMBER then	bParam[ROW_ZONE_NUMBER]	= 1 : iParentGroup[ROW_ZONE_NUMBER] = ORDER_ZONE_NUMBER
! calculeted value with unit
	if not(bEnableTsuboArea) | (bEnableTsuboArea and iAreaUnit <> AREA_UNIT_TSUBO_ONLY) then 
		if functionOrder2D[i] = ORDER_MEAS_AREA then	bParam[ROW_MEAS_AREA]	= 1 : iParentGroup[ROW_MEAS_AREA] 	= ORDER_MEAS_AREA
	endif
	if bEnableTsuboArea and iAreaUnit <> AREA_UNIT_PROJECT then
		if functionOrder2D[i] = ORDER_MEAS_AREA then	bParam[ROW_MEAS_AREA_TSUBO]	= 1 : iParentGroup[ROW_MEAS_AREA_TSUBO] 	= ORDER_MEAS_AREA
	endif
	if not(bEnableTsuboArea) | (bEnableTsuboArea and iAreaUnit <> AREA_UNIT_TSUBO_ONLY) then 
		if functionOrder2D[i] = ORDER_CALC_AREA then	bParam[ROW_CALC_AREA]	= 1 : iParentGroup[ROW_CALC_AREA] 	= ORDER_CALC_AREA
	endif
	if bEnableTsuboArea and iAreaUnit <> AREA_UNIT_PROJECT then
		if functionOrder2D[i] = ORDER_CALC_AREA then	bParam[ROW_CALC_AREA_TSUBO]	= 1 : iParentGroup[ROW_CALC_AREA_TSUBO] 	= ORDER_CALC_AREA
	endif
! Just String
	if functionOrder2D[i] = ORDER_FLOORING then		bParam[ROW_FLOORING]	= 1 : iParentGroup[ROW_FLOORING] 	= ORDER_FLOORING
! calculeted value with unit
	if functionOrder2D[i] = ORDER_PERIMETER then		bParam[ROW_PERIMETER]	= 1 : iParentGroup[ROW_PERIMETER] 	= ORDER_PERIMETER
	if functionOrder2D[i] = ORDER_CEIL_HEIGHT then	bParam[ROW_CEIL_HEIGHT]	= 1 : iParentGroup[ROW_CEIL_HEIGHT] = ORDER_CEIL_HEIGHT
	if functionOrder2D[i] = ORDER_VOLUME then			bParam[ROW_VOLUME]		= 1 : iParentGroup[ROW_VOLUME] 		= ORDER_VOLUME
! Just String
	if functionOrder2D[i] = ORDER_OCCUPANCY then		bParam[ROW_OCCUPANCY]	= 1 : iParentGroup[ROW_OCCUPANCY] 		= ORDER_OCCUPANCY
	if functionOrder2D[i] = ORDER_CUSTOM_TEXT then	bParam[ROW_CUSTOM_TEXT]	= 1 : iParentGroup[ROW_CUSTOM_TEXT] 	= ORDER_CUSTOM_TEXT
	if functionOrder2D[i] = ORDER_ROOM_NUMBER then	bParam[ROW_ROOM_NUMBER]	= 1 : iParentGroup[ROW_ROOM_NUMBER] 	= ORDER_ROOM_NUMBER
	if functionOrder2D[i] = ORDER_NAME_AND_NUMBER then bParam[ROW_NAME_AND_NUMBER]	= 1 : iParentGroup[ROW_NAME_AND_NUMBER] 	= ORDER_NAME_AND_NUMBER
	if functionOrder2D[i] = ORDER_SURFACE_CODE then	bParam[ROW_SURFACE_CODE]	= 1 : iParentGroup[ROW_SURFACE_CODE] 	= ORDER_SURFACE_CODE
! String Table
	if functionOrder2D[i] = ORDER_ADD_TAGS then
		for iSet = 0 to _numTnCRow - 1
			bParam[ROW_ADD_TAGS + iSet] = 4 : iParentGroup[ROW_ADD_TAGS + iSet] = ORDER_ADD_TAGS
		next iSet
	endif
next i

dim stRowDescription[]
	stRowDescription[ROW_NONE] 				= ``
	stRowDescription[ROW_ZONE_NAME] 		= `Имя Зоны`
	stRowDescription[ROW_ZONE_NUMBER]		= `Номер Зоны`
	stRowDescription[ROW_MEAS_AREA] 		= `Измеренная Площадь`
	stRowDescription[ROW_MEAS_AREA_TSUBO]	= `Измеренная Площадь в Тсубо`
	stRowDescription[ROW_CALC_AREA] 		= `Вычисленная Площадь`
	stRowDescription[ROW_CALC_AREA_TSUBO]	= `Вычисленная Площадь в Тсубо`
	stRowDescription[ROW_FLOORING] 			= `Пол`
	stRowDescription[ROW_PERIMETER] 		= `Периметр`
	stRowDescription[ROW_CEIL_HEIGHT] 		= `Высота Потолка`
	stRowDescription[ROW_VOLUME] 			= `Объем`
	stRowDescription[ROW_OCCUPANCY] 		= `Расчетное Число Людей`
	stRowDescription[ROW_ZONE_ID] 			= `ID Зоны`
	stRowDescription[ROW_CUSTOM_TEXT] 		= `Специальный Текст`
	stRowDescription[ROW_ROOM_NUMBER] 		= `Номер Помещения`
	stRowDescription[ROW_NAME_AND_NUMBER] 	= `Имя и Номер Зоны`
	stRowDescription[ROW_SURFACE_CODE] 	= `Код Покрытия`
	for iSet = 0 to _numTnCRow - 1
		stRowDescription[ROW_ADD_TAGS + iSet] = `Дополнительные Метки`
	next iSet

! Displayed strings and prefixes
! ------------------------------------------------------------------------------
dim titleString[]
for i = 1 to maxRowNumber
	titleString[i] = ""
next i

catname = ""
catcode = ""
rrr = request("Zone_category", "", catname, catcode)


dim _MasterID[]
result = 0
if GLOB_SCRIPT_TYPE <> 5 then ! Parameter Script 
	result = REQUEST("Full_ID_of_parent", "", _MasterID)
endif

titleString[ROW_ZONE_ID] = ""
if result then
	if iShowZoneIDAs = IDVALUE_IDNUMBER then
		titleString[ROW_ZONE_ID] = _MasterID[vardim1(_MasterID)]
	else
		for i = 1 to vardim1 (_MasterID)
			titleString[ROW_ZONE_ID] = titleString[ROW_ZONE_ID] + _MasterID[i]
		next i
	endif
else
	if iShowZoneIDAs = IDVALUE_IDNUMBER then
		titleString[ROW_ZONE_ID] = "<" + `ID Зоны` + ">"
	else
		titleString[ROW_ZONE_ID] = "<" + `Основной ID Зоны` + ">"
	endif
endif
if cn_zn then					! Display Category Name as Zone name
	titleString[ROW_ZONE_NAME] = catname
else
	titleString[ROW_ZONE_NAME] = ROOM_NAME
endif
titleString[ROW_ZONE_NUMBER] = ROOM_NUMBER
titleString[ROW_MEAS_AREA] = GrossAreaText
if bEnableTsuboArea then
	titleString[ROW_MEAS_AREA_TSUBO] = GrossAreaText
endif
titleString[ROW_CALC_AREA] = areatext
if bEnableTsuboArea then
	titleString[ROW_CALC_AREA_TSUBO] = areatext
endif
titleString[ROW_FLOORING] = basec
titleString[ROW_PERIMETER] = peritext
if iTypeCeilContent = CEIL_VALUE then
	titleString[ROW_CEIL_HEIGHT] = ceiltext
else
	titleString[ROW_CEIL_HEIGHT] = strTypeCeilContent[2]
endif
titleString[ROW_VOLUME] = VolumeText
titleString[ROW_OCCUPANCY] = gs_occupancy_text + result_occupancy
titleString[ROW_CUSTOM_TEXT]	= prefixCustomText + contentCustomText
if bEnableZone1CustomText2 then
	titleString[ROW_ROOM_NUMBER]	= prefixRoomNumber + contentRoomNumber
endif

if bByCategoryNameAndNumber then					! Display Category Name as Zone name
	_sName = catname
else
	_sName = ROOM_NAME
endif
if iOrderNameandNumber = ZONE_NAME_FIRST then
	titleString[ROW_NAME_AND_NUMBER] = _sName + " " + ROOM_NUMBER
else
	titleString[ROW_NAME_AND_NUMBER] = ROOM_NUMBER + " " + _sName
endif

if bEnableZone1SurfaceCode then
	dim _contentSurfaceCode[4][3]
	SC_PREF = 1
	SC_SEPR = 2
	SC_NAME = 3
	! Initialization
	for iSc = 1 to 4
		_contentSurfaceCode[iSc][SC_PREF] = ""
		_contentSurfaceCode[iSc][SC_SEPR] = ""
		_contentSurfaceCode[iSc][SC_NAME] = ""
	next iSc

	if iComponentSurfaceCode <> SURFACE_NAME then
		_contentSurfaceCode[1][SC_PREF] = contentFloorFinish 
		_contentSurfaceCode[2][SC_PREF] = contentBaseFinish 
		_contentSurfaceCode[3][SC_PREF] = contentWallFinish 
		_contentSurfaceCode[4][SC_PREF] = contentCeilingFinish
	endif

	if iComponentSurfaceCode <> CUSTOM_CODE then
		rrr = request ("Name_of_material", matFloorFinish, _contentSurfaceCode[1][SC_NAME] )
		rrr = request ("Name_of_material", matBaseFinish, _contentSurfaceCode[2][SC_NAME] )
		rrr = request ("Name_of_material", matWallFinish, _contentSurfaceCode[3][SC_NAME] )
		rrr = request ("Name_of_material", matCeilingFinish, _contentSurfaceCode[4][SC_NAME] )
	endif

	for iSc = 1 to 4
		if _contentSurfaceCode[iSc][SC_PREF] <> "" and _contentSurfaceCode[iSc][SC_NAME] <> "" then
			_contentSurfaceCode[iSc][SC_SEPR] = " "
		endif
	next iSc

	! for calculating symmetric cell sizes, the longest win, the cells separators are the frame offset
	dim _sSurfaceCodesByRow[4]
	for iSc = 1 to 4
		_sSurfaceCodesByRow[iSc] = _contentSurfaceCode[iSc][SC_PREF] + _contentSurfaceCode[iSc][SC_SEPR] + _contentSurfaceCode[iSc][SC_NAME]
	next iSc 

	_maxCell = 0
	_hasMaxCell = 0
	for k = 1 to 4
		if (max(_maxCell, stw(_sSurfaceCodesByRow[k]) ) - stw(_sSurfaceCodesByRow[k])) < EPS then
			_hasMaxCell = k
			_maxCell = stw(_sSurfaceCodesByRow[k])
		endif
	next k

	_separator = " "
	titleString[ROW_SURFACE_CODE]= _sSurfaceCodesByRow[1] + _separator + \
									_separator + _sSurfaceCodesByRow[2] + _separator +\
									_separator + _sSurfaceCodesByRow[3] + _separator +\
									_separator + _sSurfaceCodesByRow[4]

endif

for iSet = 0 to _numTnCRow - 1
	titleString[ROW_ADD_TAGS + iSet] = _contentTnC[iSet+1]
next iSet

! Displayed quantities
! ------------------------------------------------------------------------------
dim quantities[]
for i = 1 to maxRowNumber
	quantities[i] = 0
next i
_calcTsubo = 3.3060

quantities[ROW_ZONE_NAME]		= 0
quantities[ROW_ZONE_NUMBER]		= 0
quantities[ROW_MEAS_AREA]		= ROOM_AREA
if bEnableTsuboArea then
	quantities[ROW_MEAS_AREA_TSUBO]	= ROOM_AREA / _calcTsubo
endif
quantities[ROW_CALC_AREA]	= ROOM_CALC_AREA
if bEnableTsuboArea then
	quantities[ROW_CALC_AREA_TSUBO]	= ROOM_CALC_AREA / _calcTsubo
endif
quantities[ROW_FLOORING]		= 0
quantities[ROW_PERIMETER]		= ROOM_PERIM
quantities[ROW_CEIL_HEIGHT]		= ROOM_HEIGHT
quantities[ROW_VOLUME]			= ROOM_VOLUME
quantities[ROW_OCCUPANCY]		= 0
quantities[ROW_ZONE_ID]			= 0
quantities[ROW_ADD_TAGS]		= 0
quantities[ROW_CUSTOM_TEXT]		= 0
if bEnableZone1CustomText2 then
	quantities[ROW_ROOM_NUMBER]		= 0
endif
quantities[ROW_NAME_AND_NUMBER] = 0
if bEnableZone1SurfaceCode then
	quantities[ROW_SURFACE_CODE] = 0
endif
for iSet = 0 to _numTnCRow - 1
	quantities[ROW_ADD_TAGS + iSet] = 0
next iSet

! Displayed quantities formats
! ------------------------------------------------------------------------------
dim iQuantitiyFormats[]
for i = 1 to maxRowNumber
	iQuantitiyFormats[i] = 0
next i
dim sCustomQuantitiyFormats[]
for i = 1 to maxRowNumber
	sCustomQuantitiyFormats[i] = ""
next i

iQuantitiyFormats[ROW_ZONE_NAME]	= 0
iQuantitiyFormats[ROW_ZONE_NUMBER]	= 0
iQuantitiyFormats[ROW_MEAS_AREA]	= 9		! unitType = "Area_dimension"
if bEnableTsuboArea then
	iQuantitiyFormats[ROW_MEAS_AREA_TSUBO]	= 0
	sCustomQuantitiyFormats[ROW_MEAS_AREA_TSUBO] = "%~0." + str(iAreaDecimalOptions,1,0) + `Тсубо`
endif
iQuantitiyFormats[ROW_CALC_AREA]= 9		! unitType = "Area_dimension"
if bEnableTsuboArea then
	iQuantitiyFormats[ROW_CALC_AREA_TSUBO]	= 0
	sCustomQuantitiyFormats[ROW_CALC_AREA_TSUBO] = "%~0." + str(iAreaDecimalOptions,1,0) + `Тсубо`
endif
iQuantitiyFormats[ROW_FLOORING]		= 0
iQuantitiyFormats[ROW_PERIMETER]	= 10	! unitType = "Calc_length_unit"
if iTypeCeilContent = CEIL_VALUE then
	iQuantitiyFormats[ROW_CEIL_HEIGHT] = 10	! unitType = "Calc_length_unit"
else
	iQuantitiyFormats[ROW_CEIL_HEIGHT] = 0
endif
iQuantitiyFormats[ROW_VOLUME]		= 12	! unitType = "Calc_volume_unit"
iQuantitiyFormats[ROW_OCCUPANCY]	= 0
iQuantitiyFormats[ROW_ZONE_ID]		= 0
iQuantitiyFormats[ROW_ADD_TAGS]		= 0
for iSet = 0 to _numTnCRow - 1
	iQuantitiyFormats[ROW_ADD_TAGS + iSet] = 0
next iSet
iQuantitiyFormats[ROW_CUSTOM_TEXT]	= 0
if bEnableZone1CustomText2 then
	iQuantitiyFormats[ROW_ROOM_NUMBER]	= 0
endif
iQuantitiyFormats[ROW_NAME_AND_NUMBER]= 0
if bEnableZone1SurfaceCode then
	iQuantitiyFormats[ROW_SURFACE_CODE] = 0
endif


! ==============================================================================
! Frame Function : "Show Frame" Boolean
! On: assign the unique settings (every line've own frame)
! Off: turn off and hide everything about the frame
! ==============================================================================

dim _rowFrame[]
	_rowFrame[ROW_NONE] = 0
	_rowFrame[ROW_ZONE_NAME] 		= bFrameName
	_rowFrame[ROW_ZONE_NUMBER] 		= bFrameNum
	_rowFrame[ROW_MEAS_AREA] 		= bFrameGrossArea
	_rowFrame[ROW_MEAS_AREA_TSUBO]	= bFrameGrossArea
	_rowFrame[ROW_CALC_AREA] 		= bFrameArea
	_rowFrame[ROW_CALC_AREA_TSUBO]	= bFrameArea
	_rowFrame[ROW_FLOORING] 		= bFrameCode
	_rowFrame[ROW_PERIMETER] 		= bFramePeri
	_rowFrame[ROW_CEIL_HEIGHT] 		= bFrameCeil
	_rowFrame[ROW_VOLUME] 			= bFrameVolume
	_rowFrame[ROW_OCCUPANCY] 		= gs_show_frame_occupancy
	_rowFrame[ROW_ZONE_ID] 			= bFrameZoneID
	_rowFrame[ROW_CUSTOM_TEXT] 		= bFrameCustomText
	_rowFrame[ROW_ROOM_NUMBER] 		= bFrameRoomNumber
	_rowFrame[ROW_NAME_AND_NUMBER] 	= bFrameNameAndNumber
	_rowFrame[ROW_SURFACE_CODE] 	= bFrameSurfaceCode
	for iSet = 0 to _numTnCRow - 1
		_rowFrame[ROW_ADD_TAGS + iSet] = bFrameAdditionalTags
	next iSet

if not(bFrame[_iScale]) then
	for iFrame = 1 to vardim1(_rowFrame)
		_rowFrame[iFrame] = 0
	next iFrame
endif

iValidZone		= 0
for i = 1 to numDisplayedGroup[_iScale]
	if functionOrder2D[i] <> ORDER_NONE then iValidZone = iValidZone + 1
next i
if iValidZone = 0 then end
for i = numDisplayedGroup[_iScale] + 1 to maxFunctionOrder
	functionOrder2D[i] = ORDER_NONE
next i

! ==============================================================================
! Row_Number's Definition
! ==============================================================================
nFrontNoneRows = 0
bOnlyNone = 1
for iFront = 1 to numDisplayedGroup[_iScale]
	if functionOrder2D[iFront] = ORDER_NONE  & bOnlyNone = 1 then
	   nFrontNoneRows = nFrontNoneRows + 1
	else
	   bOnlyNone = 0
	endif
next iFront
nBackNoneRows = 0
bOnlyNone = 1
for iBack = numDisplayedGroup[_iScale] to 1 step -1
	if functionOrder2D[iBack] = ORDER_NONE & bOnlyNone = 1 then
	   nBackNoneRows = nBackNoneRows + 1
	else
	   bOnlyNone = 0
	endif
next iBack

! Real Row Order
dim RowOrder[]
j = 1
for iOrder = nFrontNoneRows+1 to numDisplayedGroup[_iScale] - nBackNoneRows
	for iValue = 1 to _maxGroupDisplay
		if functionOrder2D[iOrder] = iValue then
			for iRow = 1 to maxRowNumber
				if iParentGroup[iRow] = iValue then
					RowOrder[j] = iRow
					j = j + 1
				endif
			next iRow
			if functionOrder2D[iOrder] = ORDER_NONE then
				RowOrder[j] = ROW_NONE
				j = j + 1
			endif
		endif
	next iValue
next iOrder

! ==============================================================================
! Style
! ==============================================================================

dim penFont[]
	penFont[ROW_NONE] = 1
	penFont[ROW_ZONE_NAME]		= zonapen
	penFont[ROW_ZONE_NUMBER]	= zonopen
	penFont[ROW_MEAS_AREA]		= GrossAreaPen
	penFont[ROW_MEAS_AREA_TSUBO]= GrossAreaPen
	penFont[ROW_CALC_AREA]		= areapen
	penFont[ROW_CALC_AREA_TSUBO]= areapen
	penFont[ROW_FLOORING]		= codepen
	penFont[ROW_PERIMETER]		= peripen
	penFont[ROW_CEIL_HEIGHT]	= ceilhpen
	penFont[ROW_VOLUME]			= VolumePen
	penFont[ROW_OCCUPANCY]		= gs_pen_font_occupancy
	penFont[ROW_ZONE_ID]		= fontpenZoneID
	penFont[ROW_CUSTOM_TEXT]	= customTextPen
	penFont[ROW_ROOM_NUMBER]	= roomNumberPen
	penFont[ROW_NAME_AND_NUMBER] = nameAndNumberPen
	penFont[ROW_SURFACE_CODE]	= surfaceCodepen
	for iSet = 0 to _numTnCRow - 1
		penFont[ROW_ADD_TAGS + iSet] = AdditionalTagsPen
	next iSet


dim nameStyle[]
	nameStyle[ROW_NONE]				= "Nonestyle"
	nameStyle[ROW_ZONE_NAME]		= "znamestyle"
	nameStyle[ROW_ZONE_NUMBER]		= "znumstyle"
	nameStyle[ROW_MEAS_AREA]		= "GrossArStyle"
	nameStyle[ROW_MEAS_AREA_TSUBO]	= "GrossArStyleTsubo"
	nameStyle[ROW_CALC_AREA]		= "arstyle"
	nameStyle[ROW_CALC_AREA_TSUBO]	= "arstyleTsubo"
	nameStyle[ROW_FLOORING]			= "codestyle"
	nameStyle[ROW_PERIMETER]		= "pestyle"
	nameStyle[ROW_CEIL_HEIGHT]		= "chstyle"
	nameStyle[ROW_VOLUME]			= "VolStyle"
	nameStyle[ROW_OCCUPANCY]		= "OccuStyle"
	nameStyle[ROW_ZONE_ID]			= "ZoneIDStyle"
	nameStyle[ROW_CUSTOM_TEXT]		= "CustomStyle"
	nameStyle[ROW_ROOM_NUMBER]		= "roomNumberStyle"
	nameStyle[ROW_NAME_AND_NUMBER]	= "NameAndNumberStyle"
	nameStyle[ROW_SURFACE_CODE]		= "surfaceCodeStyle"
	for iSet = 0 to _numTnCRow - 1
		nameStyle[ROW_ADD_TAGS + iSet] = "AdditionalTagsStyle"
	next iSet

dim styleFont[]
	styleFont[ROW_NONE] = 0
	styleFont[ROW_ZONE_NAME] = zonaBoldStyle + zonaItalicStyle * 2 + zonaUnderlStyle * 4
	styleFont[ROW_ZONE_NUMBER] = zonoBoldStyle + zonoItalicStyle * 2 + zonoUnderlStyle * 4
	styleFont[ROW_MEAS_AREA] = GrossAreaBoldStyle + GrossAreaItalicStyle * 2 + GrossAreaUnderlStyle * 4
	styleFont[ROW_MEAS_AREA_TSUBO] = GrossAreaBoldStyle + GrossAreaItalicStyle * 2 + GrossAreaUnderlStyle * 4
	styleFont[ROW_CALC_AREA] = areaBoldStyle + areaItalicStyle * 2 + areaUnderlStyle * 4
	styleFont[ROW_CALC_AREA_TSUBO] = areaBoldStyle + areaItalicStyle * 2 + areaUnderlStyle * 4
	styleFont[ROW_FLOORING] = codeBoldStyle + codeItalicStyle * 2 + codeUnderlStyle * 4
	styleFont[ROW_PERIMETER] = periBoldStyle + periItalicStyle * 2 + periUnderlStyle * 4
	styleFont[ROW_CEIL_HEIGHT] = ceilhBoldStyle + ceilhItalicStyle * 2 + ceilhUnderlStyle * 4
	styleFont[ROW_VOLUME] = VolumeBoldStyle + VolumeItalicStyle * 2 + VolumeUnderlStyle * 4
	styleFont[ROW_OCCUPANCY] = OccupancyBoldStyle + OccupancyItalicStyle * 2 + OccupancyUnderlStyle * 4
	styleFont[ROW_ZONE_ID] = ZoneIDBoldStyle + ZoneIDItalicStyle * 2 + ZoneIDUnderlStyle * 4
	styleFont[ROW_CUSTOM_TEXT] = customTextBoldStyle + customTextItalicStyle * 2 + customTextUnderlStyle * 4
	styleFont[ROW_ROOM_NUMBER] = roomNumberBoldStyle + roomNumberItalicStyle * 2 + roomNumberUnderlStyle * 4
	styleFont[ROW_NAME_AND_NUMBER] = nameAndNumberBoldStyle + nameAndNumberItalicStyle * 2 + nameAndNumberUnderlStyle * 4
	styleFont[ROW_SURFACE_CODE] = surfaceCodeBoldStyle + surfaceCodeItalicStyle * 2 + surfaceCodeUnderlStyle * 4
	for iSet = 0 to _numTnCRow - 1
		styleFont[ROW_ADD_TAGS + iSet] = AdditionalTagsBoldStyle + AdditionalTagsItalicStyle * 2 + AdditionalTagsUnderlStyle * 4
	next iSet

dim sizeFont[]

if iFontSizeType = FONTSCALE_PAPER then
	sizeFont[ROW_NONE]			= sizeFontData_mm[_iScale]
	sizeFont[ROW_ZONE_NAME]		= ROOM_LSIZE
	sizeFont[ROW_ZONE_NUMBER]	= sizeFontData_mm[_iScale]
	sizeFont[ROW_MEAS_AREA]		= sizeFontData_mm[_iScale]
	sizeFont[ROW_MEAS_AREA_TSUBO]= sizeFontData_mm[_iScale]
	sizeFont[ROW_CALC_AREA]		= sizeFontData_mm[_iScale]
	sizeFont[ROW_CALC_AREA_TSUBO]= sizeFontData_mm[_iScale]
	sizeFont[ROW_FLOORING]		= sizeFontData_mm[_iScale]
	sizeFont[ROW_PERIMETER]		= sizeFontData_mm[_iScale]
	sizeFont[ROW_CEIL_HEIGHT]	= sizeFontData_mm[_iScale]
	sizeFont[ROW_VOLUME]		= sizeFontData_mm[_iScale]
	sizeFont[ROW_OCCUPANCY]		= sizeFontData_mm[_iScale]
	sizeFont[ROW_ZONE_ID]		= sizeFontData_mm[_iScale]
	sizeFont[ROW_CUSTOM_TEXT]	= sizeFontData_mm[_iScale]
	sizeFont[ROW_ROOM_NUMBER]	= sizeFontData_mm[_iScale]
	sizeFont[ROW_NAME_AND_NUMBER] = ROOM_LSIZE
	sizeFont[ROW_SURFACE_CODE]	= sizeFontData_mm[_iScale]
	for iSet = 0 to _numTnCRow - 1
		sizeFont[ROW_ADD_TAGS + iSet] = sizeFontData_mm[_iScale]
	next iSet
else
	! style commands font size go on always as paper size
	! so need to be corrected
	_modelToPaper = 1000/GLOB_SCALE

	sizeFont[ROW_NONE]			= sizeFontData_model[_iScale] * _modelToPaper
	sizeFont[ROW_ZONE_NAME]		= ROOM_LSIZE * 100/GLOB_SCALE
	sizeFont[ROW_ZONE_NUMBER]	= sizeFontData_model[_iScale] * _modelToPaper
	sizeFont[ROW_MEAS_AREA]		= sizeFontData_model[_iScale] * _modelToPaper
	sizeFont[ROW_MEAS_AREA_TSUBO] = sizeFontData_model[_iScale] * _modelToPaper
	sizeFont[ROW_CALC_AREA]		= sizeFontData_model[_iScale] * _modelToPaper
	sizeFont[ROW_CALC_AREA_TSUBO] = sizeFontData_model[_iScale] * _modelToPaper
	sizeFont[ROW_FLOORING]		= sizeFontData_model[_iScale] * _modelToPaper
	sizeFont[ROW_PERIMETER]		= sizeFontData_model[_iScale] * _modelToPaper
	sizeFont[ROW_CEIL_HEIGHT]	= sizeFontData_model[_iScale] * _modelToPaper
	sizeFont[ROW_VOLUME]		= sizeFontData_model[_iScale] * _modelToPaper
	sizeFont[ROW_OCCUPANCY]		= sizeFontData_model[_iScale] * _modelToPaper
	sizeFont[ROW_ZONE_ID]		= sizeFontData_model[_iScale] * _modelToPaper
	sizeFont[ROW_CUSTOM_TEXT]	= sizeFontData_model[_iScale] * _modelToPaper
	sizeFont[ROW_ROOM_NUMBER]	= sizeFontData_model[_iScale] * _modelToPaper
	sizeFont[ROW_NAME_AND_NUMBER] = ROOM_LSIZE * 100/GLOB_SCALE
	sizeFont[ROW_SURFACE_CODE]	= sizeFontData_model[_iScale] * _modelToPaper
	for iSet = 0 to _numTnCRow - 1
		sizeFont[ROW_ADD_TAGS + iSet] = sizeFontData_model[_iScale] * _modelToPaper
	next iSet

endif

dim typeFont[]
	typeFont[ROW_NONE]				= zonofont ! not relevant
	typeFont[ROW_ZONE_NAME]			= AC_TextFont_1
	typeFont[ROW_ZONE_NUMBER]		= zonofont
	typeFont[ROW_MEAS_AREA]			= GrossAreaFont
	typeFont[ROW_MEAS_AREA_TSUBO]	= GrossAreaFont
	typeFont[ROW_CALC_AREA]			= areafont
	typeFont[ROW_CALC_AREA_TSUBO]	= areafont
	typeFont[ROW_FLOORING]			= codefont
	typeFont[ROW_PERIMETER]			= perifont
	typeFont[ROW_CEIL_HEIGHT]		= ceilhfont
	typeFont[ROW_VOLUME]			= VolumeFont
	typeFont[ROW_OCCUPANCY]			= gs_type_font_occupancy
	typeFont[ROW_ZONE_ID]			= fonttypeZoneID
	typeFont[ROW_CUSTOM_TEXT]		= fonttypeCustomText
	typeFont[ROW_ROOM_NUMBER]		= fonttypeRoomNumber
	typeFont[ROW_NAME_AND_NUMBER]	= fonttypeNameAndNumber
	typeFont[ROW_SURFACE_CODE]		= fonttypeSurfaceCode
	for iSet = 0 to _numTnCRow - 1
		typeFont[ROW_ADD_TAGS + iSet] = AdditionalTagsFont
	next iSet

dim heightStyle[]
for i = 1 to maxRowNumber
	if i = ROW_SURFACE_CODE then
		! drawing Surface Codes in the center of code cells
		_iAnchor = 2
	else
		_iAnchor = iAlignment[_iScale]
	endif

	define style  nameStyle[i]		typeFont[i], sizeFont[i], _iAnchor, styleFont[i]
	rrr = request("Height_of_style", nameStyle[i], heightStyle[i])
next i

dim lengthFrameOffset[]
	for i = 1 to maxRowNumber
		lengthFrameOffset[i] = 2

		! exeptions
		if (i = ROW_ZONE_NAME & not(bZoneNameAllign) & not(_rowFrame[ROW_ZONE_NAME]) ) |\
			(i = ROW_NAME_AND_NUMBER & not(bNameAllignNameAndNumber) & not(_rowFrame[ROW_NAME_AND_NUMBER])) then
			lengthFrameOffset[i] = 0
		endif			

	next i


mul2 PAPER_TO_MODEL, PAPER_TO_MODEL

dim lengthContentString[]
dim heightRow[]
for i = 1 to maxRowNumber
	lengthContentString[i] = 0
	heightRow[i] = 0
next i
max_len = 0
max_h = 0

for iCalculated = 1 to vardim1(RowOrder)
	iRow = RowOrder[iCalculated]

 	style nameStyle[iRow]
	if bParam[iRow] | iRow = ROW_NONE then
		j			= iRow
		bShowText	= 0
		gosub "calculateorDrawUnit"	! returned totalLength = calculeted value with unit
		lengthContentString[iRow] = totalLength
		if iRoW = ROW_SURFACE_CODE then	! keep out of using paragraph
			_calc = 1 : _draw = 0
			gosub "calc_or_draw_SurfaceCode" ! returned lengthContentString[], totalHeight
		endif

		heightRow[iRow] = totalHeight
		lengthContentString[iRow] = lengthContentString[iRow] + lengthFrameOffset[iRow]

		if max_len < lengthContentString[iRow] then
			max_len = lengthContentString[iRow]
		endif

		max_h = max_h + heightRow[iRow]

	endif
next iCalculated

if (iTypeStampWidth[_iScale] = WIDTH_CUSTOM) then
	max_len = widthFixedStamp[_iScale]
endif

max_h = - max_h
! ==============================================================================
! Position
! ==============================================================================

xPosAnchor = 0
yPosAnchor = 0

if iAnchorStamp[_iScale] = ANCHOR_TOP_MIDDLE |\
	iAnchorStamp[_iScale] = ANCHOR_CENTER |\
	iAnchorStamp[_iScale] = ANCHOR_BOTTOM_MIDDLE then xPosAnchor = -max_len/2

if iAnchorStamp[_iScale] = ANCHOR_TOP_RIGHT |\
	iAnchorStamp[_iScale] = ANCHOR_MIDDLE_RIGHT |\
	iAnchorStamp[_iScale] = ANCHOR_BOTTOM_RIGHT then  xPosAnchor = -max_len

if iAnchorStamp[_iScale] = ANCHOR_MIDDLE_LEFT |\
	iAnchorStamp[_iScale] = ANCHOR_CENTER |\
	iAnchorStamp[_iScale] = ANCHOR_MIDDLE_RIGHT then yPosAnchor = -max_h/2

if iAnchorStamp[_iScale] = ANCHOR_BOTTOM_LEFT |\
	iAnchorStamp[_iScale] = ANCHOR_BOTTOM_MIDDLE |\
	iAnchorStamp[_iScale] = ANCHOR_BOTTOM_RIGHT then yPosAnchor = -max_h

add2 xPosAnchor, yPosAnchor

! ==============================================================================
! Draw stamp line by line
! ==============================================================================

vlen = 0
_upper = 0 : _lower = 0

for i = 1 to vardim1(RowOrder)
	iRow = RowOrder[i]

	! check the line before and after the current one to set frame
	if i > 1 then _upper = _rowFrame[RowOrder[i-1]]
	if i < vardim1(RowOrder) then
		_lower = _rowFrame[RowOrder[i+1]]
	else
		_lower = 0
	endif

	gosub "drawTextandFrame"

	vlen = vlen + heightRow[iRow]
next i


! ==============================================================================
! Hotspot
! ==============================================================================

hotspot2 0, 0
hotspot2 max_len, 0
hotspot2 0, max_h
hotspot2 max_len, max_h
hotspot2 max_len/2, max_h/2

fill filltypeBackgroundFill[_iScale]
poly2_B{2}	5,2, penBackgroundFill[_iScale], backpenBackgroundFill[_iScale],
	0,		0,		0,
	0,		0,		1,
	0,		max_h,	1,
	max_len, max_h,	1,
	max_len, 0,		1,
	0,		0,		1

if bShowMiddleHotspots[_iScale] then
   hotspot2 max_len/2, 0
   hotspot2 max_len/2, max_h
   hotspot2 0, max_h/2
   hotspot2 max_len, max_h/2
endif

end


! ==============================================================================
! Subroutines
! ==============================================================================

"drawTextandFrame":

	pen penFont[iRow]
	style nameStyle[iRow]

	bShowText = 1
	j = iRow
	if iRow = ROW_SURFACE_CODE then
		! drawing Surface Codes in the center of code cells
		add2 0,-vlen

		_calc = 0 : _draw = 1
		gosub "calc_or_draw_SurfaceCode"

		del 1
	else

		if iAlignment[_iScale] = ALIIGN_LEFT then
			add2 lengthFrameOffset[iRow]/2,-vlen
		endif
		if iAlignment[_iScale] = ALIIGN_CENTERED then add2 max_len/2,-vlen
		if iAlignment[_iScale] = ALIIGN_RIGHT then
			add2 max_len - lengthFrameOffset[iRow]/2,-vlen
		endif

		gosub "calculateorDrawUnit"

		del 1
	endif

	gosub "DrawOneFrame"

return

! ==============================================================================
! DrawOneFrame
! Parameters: heightRow[iRow], iOrder
! ==============================================================================
"DrawOneFrame":											! Frame

	if _rowFrame[iRow] then
		pen penFrame[_iScale]
		if not(bCellLineInside[_iScale]) then
			line2 0, -vlen, 0, -vlen - heightRow[iRow]								!Vertical 1
			line2 max_len, -vlen, max_len, -vlen - heightRow[iRow]					!Vertical 2

			if _upper = 0 then
				! line before doesn't have a top neighbor or the neighbors frame is off
				line2 0, -vlen, max_len, -vlen
			endif
			if _lower = 0 then
				! line after doesn't have a bottom neighbor or the neighbors frame is off
				line2 0, -vlen - heightRow[iRow], max_len, -vlen - heightRow[iRow]
			endif
		else
			rect2	0, -vlen, max_len, -vlen - heightRow[iRow]
		endif
		if iRow = ROW_SURFACE_CODE and bCellLineInside[_iScale] = 1 then
			style nameStyle[iRow]
			_posx =  _widthcells
			line2	_posx, -vlen, _posx, -vlen - heightRow[iRow]
			_posx = _posx + _widthcells
			line2	_posx, -vlen, _posx, -vlen - heightRow[iRow]
			_posx = _posx + _widthcells
			line2	_posx, -vlen, _posx, -vlen - heightRow[iRow]
		endif
	endif

return


! ==============================================================================
! Calculate width of the strings OR draw it
! input:
!    quantities, iQuantitiyFormats,fonttype,fontsize,fontstyle
! globals:
!    totalLength
! ==============================================================================
"calculateorDrawUnit":

	mul2 MODEL_TO_PAPER, MODEL_TO_PAPER
	call "quantity_text_writer" parameters 	lengthValue = quantities[j],
										iUnitType = iQuantitiyFormats[j],
										GS_iMarkerDir = 1,
										horizontalAlignment = iAlignment[_iScale],	! 1:Left, 2:Center, 3:Right
										verticalAlignment = 2,				! Alignment_Top
										AC_TextFont = typeFont[j],
										AC_TextSize = sizeFont[j],
										AC_TextStyle = styleFont[j],
										szPrefix = titleString[j],
										AC_Readable = 0,
										gs_readable_angle = 90,
										useLeadingAndDescent = 1,
										bShowText = bShowText,
										bShowUnit = 1,
										custom_form = sCustomQuantitiyFormats[j],
										bUseTextblock = (iTypeStampWidth[_iScale] = WIDTH_CUSTOM),
										widthFixedSize = widthFixedStamp[_iScale] - lengthFrameOffset[j],
				returned_parameters		totalLength,
										totalHeight
	del 1
return

! ==============================================================================
"calc_or_draw_SurfaceCode":
! ==============================================================================
! Surface Codes have different drawing method
!  - Cells are symmetric
!  - Strings are always drawing with centered anchor point
!  - The length of cells is following the widthest cells size
! Input:
! 	_sSurfaceCodesByRow[]
!				- surface code data by cells
!				- [_hasMaxCell]: the widthest string of Surface Code
!	lengthFrameOffset[ROW_SURFACE_CODE]
!				- frame offset of Surface Code
!	max_len
!				- maximum width of zone
!				- with frame offset
!	max_len
!				- maximum width of zone
!				- with frame offset
! Output:
! 	lengthContentString[ROW_SURFACE_CODE]
!				- lengths of the Surface Code Row with all four cells within
!				- with frame offset
!	totalHeight
!				- height of Surface Code
! ==============================================================================
	style nameStyle[ROW_SURFACE_CODE]

	if _calc = 1 then
		! for general calculating and keep out of using paragraph
		lengthContentString[ROW_SURFACE_CODE] = ( stw(_sSurfaceCodesByRow[_hasMaxCell]) + lengthFrameOffset[ROW_SURFACE_CODE]) * 4
		totalHeight = heightStyle[ROW_SURFACE_CODE]
	endif

	_widthcells = max_len/4

	if _draw = 1 then
		_posx =  _widthcells / 2
		for iSc = 1 to 4
			! if the stamp width is custom and the surface codes don't fit in - by design
			if stw(_sSurfaceCodesByRow[iSc]) > _widthcells then
				_sPoint = "..."
				for ip = strlen(_sSurfaceCodesByRow[iSc]) to 1 step -1
					_sRest = strsub(_sSurfaceCodesByRow[iSc], 1, ip )
					if (stw(_sRest) + stw(_sPoint) ) < _widthcells then
						text2	_posx, 0, _sRest + _sPoint
						ip = 1 ! force loop end
					endif
				next ip
			else
				text2	_posx, 0, _sSurfaceCodesByRow[iSc]
			endif
			_posx = _posx + _widthcells
		next iSc 
	endif

return


