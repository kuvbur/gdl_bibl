
error_layer = 0 : if strstr(GLOB_LAYER, "ARCHICAD",1)=0 then error_layer = 1
if not(check_layer) then error_layer = 0
if (somestuff_type_change<>0 and strlen(surname)<3) or error_layer then
	SYMB_VIEW_PEN = 48
	penContourHead = SYMB_VIEW_PEN
	penMarkerText = SYMB_VIEW_PEN
	penFillCloud = SYMB_VIEW_PEN
	backpenFillCloud = SYMB_VIEW_PEN
	penFillHead = SYMB_VIEW_PEN
	penDivisionLine = SYMB_VIEW_PEN
	penMarkerText = SYMB_VIEW_PEN
	penContourHead = SYMB_VIEW_PEN
	pen SYMB_VIEW_PEN
endif

if error_layer then
	backpenFillHead = SYMB_VIEW_PEN
	bFillCloud = 1
endif

define style "izm" AC_TextFont_1, max(10, AC_TextSize_1*5), 5, AC_TextStyle_1
nnn = request("Height_of_style", "izm", text_height)
if somestuff_type_change<>1 and somestuff_type_change<>0 then
	pen SYMB_VIEW_PEN
	set style "izm"
	contentFirstRow = "Изм №"+contentFirstRow
	if somestuff_type_change = 2 then contentFirstRow = contentFirstRow + " Зам"
	if somestuff_type_change = 3 then contentFirstRow = contentFirstRow + " Нов"
	if somestuff_type_change = 4 then contentFirstRow = contentFirstRow + " Аннул"
	text2 0,0,contentFirstRow
endif
if somestuff_type_change<>1 and somestuff_type_change<>0 then end

! ==============================================================================
! Oriented View
! ==============================================================================

_angleViewRot = 0
rrr = REQUEST ("View_Rotangle", "", _angleViewRot)
_totalRotate = 0
if GLOB_CONTEXT <> 5 then
	_totalRotate = (SYMB_ROTANGLE + _angleViewRot) MOD 360
endif

! ==============================================================================
! Set dimensions and used angle
! ==============================================================================
! set scale dependent parameter values
! replace PM scripts, because its not running at changing scale
! paper size parameters
define style "markertext_oneRow" AC_TextFont_1, AC_TextSize_1, 5, AC_TextStyle_1
define style "markertext_1stRow" AC_TextFont_1, AC_TextSize_1, 8, AC_TextStyle_1
define style "markertext_2ndRow" AC_TextFont_1, AC_TextSize_1, 2, AC_TextStyle_1
nnn = request("Height_of_style", "markertext_oneRow", text_height)

PAPER_TO_MODEL = GLOB_SCALE / 1000	! Convert paper size to model size

AC_Markersize = text_height

AC_Markersize 			= AC_Markersize * PAPER_TO_MODEL
widthHead_model 		= widthHead_mm * PAPER_TO_MODEL
widthHeadHalf_model		= widthHeadHalf_mm * PAPER_TO_MODEL
distanceHead_model		= distanceHead_mm * PAPER_TO_MODEL 
radiusCloud_model 		= radiusCloud_mm * PAPER_TO_MODEL
minradiusCloud_model 	= minradiusCloud_mm * PAPER_TO_MODEL
maxradiusCloud_model 	= maxradiusCloud_mm * PAPER_TO_MODEL
if abs(sin(_anglebyMaxRadius)) > EPS then
	lengthRounded_model 	= min ( (radiusCloud_mm * PAPER_TO_MODEL)/sin(_anglebyMaxRadius) - (radiusCloud_mm * PAPER_TO_MODEL),
									(_maxUsableRadius/sin(_anglebyMaxRadius) - _maxUsableRadius) )
endif

dim _widthHalfHead[14][3]
! Head Size from Origo to the External Line
! _widthHalfHead[][1] - half head size on the side
! _widthHalfHead[][2] - half head size on the top
! _widthHalfHead[][3] - half head size on the bottom
gosub "set_array_widthHalfHead"

unID = 1
vx = 0
vy = 0

bFeedBackInput = 0

! ==============================================================================
! Preview
! ==============================================================================

if GLOB_CONTEXT = 5 then

	distanceHead_model = AC_Markersize/2

	if _hasPolygon then
		AC_PolygonNodes = 5

		_widthPreviewPolygon = AC_Markersize/2
		_heightPreviewPolygon = AC_Markersize
		_posPreviewPolygon = 2*AC_Markersize/3

		AC_PolygonCoords[1][1] = _posPreviewPolygon
		AC_PolygonCoords[1][2] = -_heightPreviewPolygon/2
		AC_PolygonCoords[2][1] = _posPreviewPolygon + _widthPreviewPolygon
		AC_PolygonCoords[2][2] = -_heightPreviewPolygon/2
		AC_PolygonCoords[3][1] = _posPreviewPolygon + _widthPreviewPolygon
		AC_PolygonCoords[3][2] = _heightPreviewPolygon/2
		AC_PolygonCoords[4][1] = _posPreviewPolygon
		AC_PolygonCoords[4][2] = _heightPreviewPolygon/2
		AC_PolygonCoords[5][1] = _posPreviewPolygon
		AC_PolygonCoords[5][2] = -_heightPreviewPolygon/2

		_lengthVector[1] = _widthPreviewPolygon
		_lengthVector[2] = _heightPreviewPolygon
		_lengthVector[3] = _widthPreviewPolygon
		_lengthVector[4] = _heightPreviewPolygon

		_angleVector[1] = 0
		_angleVector[2] = 90
		_angleVector[3] = 180
		_angleVector[4] = 270

		if iTypeCloud = CLOUD_ROUNDED then
			_maxDistTangentPoint[1] = min(_lengthVector[1], _lengthVector[4])/2
			_maxDistTangentPoint[2] = min(_lengthVector[2], _lengthVector[1])/2
			_maxDistTangentPoint[3] = min(_lengthVector[3], _lengthVector[2])/2
			_maxDistTangentPoint[4] = min(_lengthVector[4], _lengthVector[3])/2
	
			_angVectorSide[1] = 90
			_angVectorSide[2] = 90
			_angVectorSide[3] = 90
			_angVectorSide[4] = 90
		endif

	else
		AC_RefCoord[1] = 0.5
		AC_RefCoord[2] = 0.5
	endif
endif

! ===================================================================
! Cloud
! ===================================================================

dim _radCloud[][]
dim _numCloud[]

dim _filletRadius[]
dim _filletCenterPoint[][]

if _hasPolygon then
	pen SYMB_VIEW_PEN
	fill typeFillCloud

	for i = 1 to AC_PolygonNodes - 1
		if iTypeCloud = CLOUD_POLYGON then
			line_type lineTypeCloud
			put AC_PolygonCoords[i][1], AC_PolygonCoords[i][2], 1
		endif

		if iTypeCloud = CLOUD_ROUNDED then
			line_type lineTypeCloud

			if i = 1 then
				xcoordLast = AC_PolygonCoords[AC_PolygonNodes - 1][1]
				ycoordLast = AC_PolygonCoords[AC_PolygonNodes - 1][2]
			else
				xcoordLast = AC_PolygonCoords[i-1][1]
				ycoordLast = AC_PolygonCoords[i-1][2]
			endif

			! defining dimensions of rounded peaks :
			! 1. radius of rounding arc
			! 2. distance of center of rounding arc from the peak
			! 3. suspended angle of rounding arc
			! 4. absolute coords of rounding arc center
			! 5. absolute coords of targentical points
			! -------------------------------------------------------

			! 1.1 calculate the angle of vector before the current peak
			! -------------------------------------------------------
			vx = AC_PolygonCoords[i][1] - xcoordLast
			vy = AC_PolygonCoords[i][2] - ycoordLast
			gosub "check_vector_direction_angle"
			_angleVectorBefore = angle

			! 1.2 the angle between two vector
			! -------------------------------------------------------
			_angleVectorSide = _angVectorSide[i]
			_usedalpha = _angleVectorSide/2
	
			! 1.3 calculate the used cloud circle radius
			! -------------------------------------------------------
			_maxUsableLocalRadius = tan(_usedalpha) * _maxDistTangentPoint[i]	! by design
			if radiusCloud_model > _maxUsableLocalRadius then
				_usedRadiusCloud = _maxUsableLocalRadius
			else
				_usedRadiusCloud = radiusCloud_model
			endif
	
			! 2. calculate distance from circle center point to peak
			! -------------------------------------------------------
			_lengthCircleCenter = _usedRadiusCloud/sin(_usedalpha)
	
			! 3.1 calculate status of angle - convex or concave (0/1)
			! -------------------------------------------------------
			_statusAngleConcave = 1
			if ((_angleVectorBefore - _angleVector[i] + 360) MOD 360 ) > 180 then
				_statusAngleConcave = 0
			endif

			! 3.2 calculate the subtended angle of rounded arc
			! -------------------------------------------------------
			_angleArc = (180 - _angleVectorSide)
			_usedVectorAngle = _angleVector[i]
			if _statusAngleConcave = 1 then
				_angleArc = -_angleArc
			endif

			! 4. calculate circle center coordinates
			! -------------------------------------------------------
			if not(_statusAngleConcave) then
				cx = AC_PolygonCoords[i][1] + _lengthCircleCenter * cos(_angleVectorSide/2 + _angleVector[i])
				cy = AC_PolygonCoords[i][2] + _lengthCircleCenter * sin(_angleVectorSide/2 + _angleVector[i])
			else
				cx = AC_PolygonCoords[i][1] - _lengthCircleCenter * cos(  (_angleVectorSide/2 + _angleVectorBefore))
				cy = AC_PolygonCoords[i][2] - _lengthCircleCenter * sin(  (_angleVectorSide/2 + _angleVectorBefore))
			endif

			! 5. calculate targentical point coordinates
			! -------------------------------------------------------
			x1 = xcoordLast
			y1 = ycoordLast
			x2 = AC_PolygonCoords[i][1]
			y2 = AC_PolygonCoords[i][2]
			px = cx
			py = cy
			gosub "segment_point_projection"	! returned px,py

			! fill stack with the correct coordinates
			! -------------------------------------------------------
			put px, py, 1
			put cx, cy, 900
			put 0, _angleArc, 4001	! Arc using centerpoint and angle

			! one editable hotspot in the peak where the maximum radius could be
			if _placeMaxRadius = i and GLOB_CONTEXT <> 5 then
				! find the vector angle between circle center and peak
				vx = AC_PolygonCoords[i][1] - cx
				vy = AC_PolygonCoords[i][2] - cy
				gosub "check_vector_direction_angle"	! returned angle

				add2 AC_PolygonCoords[i][1], AC_PolygonCoords[i][2]
				rot2 angle + 180

				hotspot2  0,					0,	unID, lengthRounded_m, 1+1024+128,	radiusCloud_mm : unID = unID + 1
				hotspot2 -1,					0,	unID, lengthRounded_m, 3+1024,		radiusCloud_mm : unID = unID + 1
				hotspot2  lengthRounded_model,	0,	unID, lengthRounded_m, 2+1024,		radiusCloud_mm : unID = unID + 1

				del 2
			endif

			_filletRadius[i] = _usedRadiusCloud
			_filletCenterPoint[i][1] = cx
			_filletCenterPoint[i][2] = cy

		endif
		if iTypeCloud = CLOUD_BISCUIT then
			line_type 1
			gosub "standard_cloudy"
		endif
		if iTypeCloud = CLOUD_PERIODIC then
			line_type 1
			gosub "standard_cloudy"
		endif
		if iTypeCloud = CLOUD_RANDOM then
			line_type 1
			gosub "standard_cloudy"
		endif
	next i
	poly2_b	nsp/3, 1 + 2*bFillCloud + 4, penFillCloud, backpenFillCloud,
		get(nsp)
endif


! ==============================================================================
! Marker Line
! ==============================================================================

! iLineKind:
LINEKIND_NO				= 0
LINEKIND_TO_CIRCLE		= 1
LINEKIND_TO_LINE		= 2
LINEKIND_TO_RECTANGLE	= 3
LINEKIND_TO_POLYGON		= 4
LINEKIND_TO_POINT		= 5

iLineKind = LINEKIND_NO

pen penContourHead
line_type 1

! old refcoord
	pntX = 0
	pntY = 0
! old pos_x pos_Y
	posX = 0	! last click positions
	posY = 0
_angleExternalLine = 0
drawindex 10
if bConnectionLine then
	! -----------------------------------------------------------------------------
	! defining status of head position compared to cloud polygon
	!
	!	if Component: Cloud and Marker Head or Cloud Only
	!	- inside			iLineKind = LINEKIND_NO
	!	- outside			iLineKind = LINEKIND_POLYGON
	!
	!	if Component: Cloud and Marker Head or Cloud Only
	!	- alwasy inside		iLineKind = LINEKIND_TO_POINT
	! -----------------------------------------------------------------------------
	if _hasPolygon then
		ret = 0		! Error
		pipEnd = 0
		pipIntersection = 0
	
		pipX0 = AC_PolygonCoords[AC_PolygonNodes - 1][1] + pntX
		pipY0 = AC_PolygonCoords[AC_PolygonNodes - 1][2] + pntY
		pipX1 = AC_PolygonCoords[1][1] + pntX
		pipY1 = AC_PolygonCoords[1][2] + pntY
	
		for pipI = 1 to AC_PolygonNodes - 1
	
			! Point on polygon vertex test
			if abs(pipX1 - posX) < EPS & abs(pipY1 - posY) < EPS then
				ret		= 4					! OnPoint
				pipI	= AC_PolygonNodes - 1	! Force end loop
				pipEnd	= 1
			endif
	
			! Point on edge test
			pipSegLength = sqr((pipX0 - pipX1)^2 + (pipY0 - pipY1)^2)
			if pipSegLength > EPS & not(pipEnd) then
				x1 = pipX0
				y1 = pipY0
				x2 = pipX1
				y2 = pipY1
				px = posX
				py = posY

				gosub "segment_point_projection"		! returned px,py

				if abs(px - posX) < EPS & abs(py - posY) < EPS then
					ret		= 3					! OnEdge
					pipEnd	= 1
				endif
			endif
	
			pipX2 = AC_PolygonCoords[pipI + 1][1] + pntX
			pipY2 = AC_PolygonCoords[pipI + 1][2] + pntY
	
			line1X1 = pipX1
			line1Y1 = pipY1
			line1X2 = pipX2
			line1Y2 = pipY2
	
			line2X1 = posX
			line2Y1 = posY
			line2X2 = posX + 1000
			line2Y2 = posY + 1

			gosub "segment_segment_intersection"
			! Result: state, cx,cy
	
			if state = 3 then
				if abs(line1X2 - cx) > EPS | abs(line1Y2 - cy) > EPS then
					if abs(line1X1 - cx) < EPS & abs(line1Y1 - cy) < EPS then
						if sgn(pipY0 - pntY) <> sgn(pipY2 - pntY) then
							pipIntersection = pipIntersection + 1
						endif
					else
						pipIntersection = pipIntersection + 1
					endif
				endif
			endif
	
			pipX0 = pipX1
			pipY0 = pipY1
	
			pipX1 = pipX2
			pipY1 = pipY2
		next pipI
	
		if (pipIntersection % 2 = 0) & ret <> 3 & ret <> 4 then	! Outside, On Edge, On Line
			iLineKind = LINEKIND_TO_POLYGON
		else
			iLineKind = LINEKIND_NO
		endif
	else
		iLineKind = LINEKIND_TO_POINT
	endif

	nearestPx = 0 : nearestPy = 0
	! -----------------------------------------------------------------------------
	! LINEKIND_TO_POLYGON
	!	-	calculate the nearest coordinates of cloud polygon from the head
	!		nearestPx, nearestPy
	! -----------------------------------------------------------------------------
	if iLineKind = LINEKIND_TO_POLYGON then
		nearestDist = 999999
	
		for i = 1 to AC_PolygonNodes - 1
	
			x1 = AC_PolygonCoords[i][1] + pntX
			y1 = AC_PolygonCoords[i][2] + pntY
	
			x2 = AC_PolygonCoords[i + 1][1] + pntX
			y2 = AC_PolygonCoords[i + 1][2] + pntX
	
			px = posX
			py = posY
			gosub "segment_point_projection"
	
			if state <> 0 then
				dist = (posX - px)^2 + (posY - py)^2
	
				if dist < nearestDist then
					nearestPx = px
					nearestPy = py
					nearestDist = dist

					_usedSegment = i
					nearestEdgex = AC_PolygonCoords[_usedSegment][1]
					nearestEdgey = AC_PolygonCoords[_usedSegment][2]
				endif
			endif
		next i

		if (iTypeCloud = CLOUD_ROUNDED) then

			! -------------------------------------------------------------------
			! searching for non-filleted part of used edge
			! -------------------------------------------------------------------

			! calculate control distance from tangential point to start corner
			! -------------------------------------------------------------------
			xs = AC_PolygonCoords[_usedSegment][1]
			ys = AC_PolygonCoords[_usedSegment][2]
			xe = AC_PolygonCoords[_usedSegment+1][1]
			ye = AC_PolygonCoords[_usedSegment+1][2]
			_nearestPx = nearestPx - AC_RefCoord[1]
			_nearestPy = nearestPy - AC_RefCoord[2]

			x1 = AC_PolygonCoords[_usedSegment][1]
			y1 = AC_PolygonCoords[_usedSegment][2]
			x2 = AC_PolygonCoords[_usedSegment+1][1]
			y2 = AC_PolygonCoords[_usedSegment+1][2]
			px = _filletCenterPoint[_usedSegment][1]
			py = _filletCenterPoint[_usedSegment][2]

			gosub "segment_point_projection"	! returned px, py tangential point coordinates

			controlDistS = (px - xs)^2 + (py - ys)^2

			! calculate control distance from tangential point to end corner
			! -------------------------------------------------------------------
			x1 = AC_PolygonCoords[_usedSegment][1]
			y1 = AC_PolygonCoords[_usedSegment][2]
			x2 = AC_PolygonCoords[_usedSegment + 1][1]
			y2 = AC_PolygonCoords[_usedSegment + 1][2]
			if _usedSegment + 1 > AC_PolygonNodes - 1 then		! if there is no more filletCenterPoint then go back to start
				px = _filletCenterPoint[1][1]
				py = _filletCenterPoint[1][2]
			else
				px = _filletCenterPoint[_usedSegment + 1][1]
				py = _filletCenterPoint[_usedSegment + 1][2]
			endif

			gosub "segment_point_projection"	! returned px,py

			controlDistE = (px - xe)^2 + (py - ye)^2

			! calculate distance from tangential point to start corner
			! -------------------------------------------------------------------
			distS = (_nearestPx - xs)^2 + (_nearestPy - ys)^2

			! calculate distance from tangential point to end corner
			! -------------------------------------------------------------------
			distE = (_nearestPx - xe)^2 + (_nearestPy - ye)^2


			! change nearest point if it is on the filleted part
			! -------------------------------------------------------------------
			if distS < controlDistS | distE < controlDistE then

				! searching for nearest corner point to marker head position 
				! -------------------------------------------------------------------
				_nearestDist = 999999
				_nearestCornerPointID = 0

				for i = 1 to AC_PolygonNodes - 1
					x1 = AC_PolygonCoords[i][1] + AC_RefCoord[1]
					y1 = AC_PolygonCoords[i][2] + AC_RefCoord[2]

					dist = (posX - x1)^2 + (posY - y1)^2

					if dist < _nearestDist then
						_nearestDist = dist
						_nearestCornerPointID = i
					endif
				next i

				if _nearestCornerPointID then
					xo = _filletCenterPoint[_nearestCornerPointID][1]
					yo = _filletCenterPoint[_nearestCornerPointID][2]
					ro = _filletRadius[_nearestCornerPointID]
					x1 = xo
					y1 = yo
					x2 = posX - AC_RefCoord[1]
					y2 = posY - AC_RefCoord[2]

					gosub "circle_line_intersection"

					! searching for nearest intersection point to corner
					! -------------------------------------------------------------------
					x1 = AC_PolygonCoords[_nearestCornerPointID][1]
					y1 = AC_PolygonCoords[_nearestCornerPointID][2]
			
					distA = (x1 - xa)^2 + (y1 - ya)^2
					distB = (x1 - xb)^2 + (y1 - yb)^2
			
					if distA < distB then
						_nearestPx = xa
						_nearestPy = ya
					else
						_nearestPx = xb
						_nearestPy = yb
					endif

					nearestPx = _nearestPx + AC_RefCoord[1]
					nearestPy = _nearestPy + AC_RefCoord[2]
				endif
			endif
		endif

		! calculation cloud circle chord on the nearest point
		if (iTypeCloud = CLOUD_BISCUIT | iTypeCloud = CLOUD_PERIODIC | iTypeCloud = CLOUD_RANDOM) then
			_dist = 0
			_rad = 0
			! Distance from act edge to the sectioned circle
			_distCircle = SQR(( nearestPx - nearestEdgex )^2 + ( nearestPy - nearestEdgey)^2)

			for iCC = 1 to _numCloud[_usedSegment]
				_dist = _dist + _radCloud[_usedSegment][iCC]*2
				if _dist > _distCircle then
					_rad = _radCloud[_usedSegment][iCC]
					iCC = _numCloud[_usedSegment]
				endif
			next iCC
		
			xC = abs(_dist - _distCircle)
			if xC > EPS & _rad > EPS then
				if xC > _rad then
					xC = xC -_rad
				else
					xC = _rad - xC
				endif
				_lengthChord = SQR(abs(_rad^2 - xC^2))
				nearestPx = nearestPx  - cos((_angleVector[_usedSegment] + 90) MOD 360) * _lengthChord
				nearestPy = nearestPy  - sin((_angleVector[_usedSegment] + 90) MOD 360) * _lengthChord
			endif
		endif
	endif

	! -----------------------------------------------------------------------------
	! LINEKIND_TO_POINT - Component: Marker Head Only
	!	- 	calculate the nearest coordinates of point from the head
	!		nearestPx, nearestPy
	! -----------------------------------------------------------------------------
	if iLineKind = LINEKIND_TO_POINT then
		nearestPx = AC_RefCoord[1]
		nearestPy = AC_RefCoord[2]
	endif

	if iLineKind <> LINEKIND_NO then
	nearestHx = 0 : nearestHy = 0
	! -----------------------------------------------------------------------------
	! LINEKIND_TO_x
	!	- 	calculate the nearest coordinates of head from the cloud polygon
	!		nearestHx, nearestHy
	! -----------------------------------------------------------------------------
		vx = posX - nearestPx
		vy = posY - nearestPy
		gosub "check_vector_direction_angle"	! returned angle
		gosub "set_connection_line_direction_angle"	! returned _angleExternalLine

		if iConnectionLine =  LINE_STRAIGHT then
			distanceHead_model = 0
			_angleExternalLine = angle
		endif

		if 	iShapeHead <> MARKER_HEAD_NONE &\
			iShapeHead <> MARKER_HEAD_CIRCLE &\
			iShapeHead <> MARKER_HEAD_LINE & iShapeHead <> MARKER_HEAD_GOST then
 
			!----------------------------------------------------------------------
			! Head origo
			!----------------------------------------------------------------------

			centerX = distanceHead_model * cos(_angleExternalLine - _totalRotate)
			centerY = distanceHead_model * sin(_angleExternalLine - _totalRotate)
			gosub "calculate_point_headform"

			if bFeedBackInput then
				poly2_b	nsp/3, 1 + 2*bFillHead + 4, penFillHead, backpenFillHead,
				use(nsp)
			endif

			buffer		= nsp/3
			nearestDist = 999999	
			line1X1 = get (1):	line1Y1 = get (1):	dummy = get (1)

			for iHead = 1 to buffer-1
	
				line1X2 = get (1):	line1Y2 = get (1):	dummy = get (1)

				if iConnectionLine =  LINE_BREAKPOINT then	
					line2X1 = posX
					line2Y1 = posY
				else
					line2X1 = nearestPx
					line2Y1 = nearestPy
				endif

				line2X2 = centerX
				line2Y2 = centerY
	
				gosub "segment_segment_intersection"
				! Result: state, cx,cy
	
				if state = 3 then
					dist = (posX - cx)^2 + (posY - cy)^2
					if dist < nearestDist then
						nearestHx = cx
						nearestHy = cy
						nearestDist = dist
					endif
				endif
	
				line1X1 = line1X2
				line1Y1 = line1Y2
			next iHead
		else
			if iShapeHead = MARKER_HEAD_LINE or iShapeHead = MARKER_HEAD_GOST then
				nearestHx = (distanceHead_model) * cos(_angleExternalLine - _totalRotate)
				nearestHy = (distanceHead_model) * sin(_angleExternalLine - _totalRotate)
			else	! Circle or None
				nearestHx = (distanceHead_model - AC_MarkerSize/2) * cos(_angleExternalLine - _totalRotate)
				nearestHy = (distanceHead_model - AC_MarkerSize/2) * sin(_angleExternalLine - _totalRotate)
			endif
		endif

	! -----------------------------------------------------------------------------
	! drawing the marker line
	! -----------------------------------------------------------------------------
		if iConnectionLine =  LINE_BREAKPOINT then
			! Marker Line from Origo to the Cloud
			! ---------------------------------------------------------------
			line2 posX, posY, nearestPx, nearestPy

			! Marker Line from Origo to the Head
			! ---------------------------------------------------------------
			line2 posX, posY, nearestHx, nearestHy
		else
			! Marker Line from Cloud Polygon to the Head
			! ---------------------------------------------------------------
			line2 nearestPx, nearestPy, nearestHx, nearestHy
		endif
	endif
endif

! ===================================================================
! Text Calculations
! ===================================================================

pen penMarkerText
style "markertext_oneRow"
text_length = max (stw(contentFirstRow), stw(contentSecondRow) * bDivisionLine)

text_length = text_length * PAPER_TO_MODEL
text_height = text_height * (1 + bDivisionLine) * PAPER_TO_MODEL

! ===================================================================
! Marker Head
! ===================================================================

pen penContourHead
fill typeFillHead
drawindex 20

nTrans = 0
usePut = 0

if _hasHead then
	! Place of Heads Origo ----------------------------------------------
	add2 posX, posY
	nTrans = nTrans + 1
	if iLineKind <> LINEKIND_NO and iConnectionLine = LINE_BREAKPOINT then

		! Custom Frame Hotspot
		if (iShapeHead = MARKER_HEAD_RECTANGLE |\
			iShapeHead = MARKER_HEAD_DIAMOND or iShapeHead = MARKER_HEAD_GOST ) then
			rot2 -_totalRotate
			add2 distanceHead_model * cos(_angleExternalLine), distanceHead_model * sin(_angleExternalLine)
			rot2 bVerticalTextPosition * 90
			hotspot2  0,					0,	unID, widthHeadHalf_m, 1+1024+128,	widthHead_mm : unID = unID + 1
			hotspot2  -1,					0,	unID, widthHeadHalf_m, 3+1024,		widthHead_mm : unID = unID + 1
			hotspot2  widthHeadHalf_model,	0,	unID, widthHeadHalf_m, 2+1024,		widthHead_mm : unID = unID + 1
	
			hotspot2  0,					0,	unID, widthHeadHalf_m, 1+1024+128,	widthHead_mm : unID = unID + 1
			hotspot2  1,					0,	unID, widthHeadHalf_m, 3+1024,		widthHead_mm : unID = unID + 1
			hotspot2  -widthHeadHalf_model,	0,	unID, widthHeadHalf_m, 2+1024,		widthHead_mm : unID = unID + 1
			del 3
		endif

		! Origo Hotspot
		rot2 _angleExternalLine - _totalRotate
		hotspot2 0,						0,	unID, distanceHead_m, 1+1024+128,	distanceHead_mm : unID = unID + 1
		hotspot2 -1,					0,	unID, distanceHead_m, 3+1024,		distanceHead_mm : unID = unID + 1
		hotspot2 distanceHead_model ,	0,	unID, distanceHead_m, 2+1024,		distanceHead_mm : unID = unID + 1
		del 1

		centerX = distanceHead_model * cos(_angleExternalLine - _totalRotate)
		centerY = distanceHead_model * sin(_angleExternalLine - _totalRotate)

		if iShapeHead = MARKER_HEAD_LINE then
			posAngle = 0
			if ((_angleExternalLine = 90 | _angleExternalLine = 270) and not(bVerticalTextPosition)) |\
				((_angleExternalLine = 0 | _angleExternalLine = 180) and bVerticalTextPosition) then
				posAngle = 90
			endif
			centerX = centerX + _widthHalfHead[iShapeHead][HEAD_SIZE_SIDE] * cos(_angleExternalLine - _totalRotate - posAngle)
			centerY = centerY + _widthHalfHead[iShapeHead][HEAD_SIZE_SIDE] * sin(_angleExternalLine - _totalRotate - posAngle)
		endif
	else
		centerX = 0
		centerY = 0
	endif

	! Draw the poligon of head from zero (last click) ----------------------------------------------
	if iShapeHead <> MARKER_HEAD_NONE & iShapeHead <> MARKER_HEAD_CIRCLE & iShapeHead <> MARKER_HEAD_LINE then

		! input centerX, centerY
		gosub "calculate_point_headform"
		if NSP>0 then
			poly2_b	nsp/3, 1 + 2*bFillHead + 4, penFillHead, backpenFillHead,
				get(nsp)
		endif

	else
		if iShapeHead = MARKER_HEAD_CIRCLE then
			poly2_b	2, 1 + 2*bFillHead + 4, penFillHead, backpenFillHead,
				centerX, centerY,		901,
				_widthHalfHead[MARKER_HEAD_CIRCLE][HEAD_SIZE_SIDE], 360, 	4001
		endif
	endif

	! Draw division line from origo ----------------------------------------------
	add2 centerX, centerY
	rot2 -_totalRotate
	nTrans = nTrans + 2

	if bDivisionLine then
		pen penDivisionLine
		if bVerticalTextPosition then
			line2 0, -_widthHalfHead[iShapeHead][HEAD_SIZE_DOWN], 0, _widthHalfHead[iShapeHead][HEAD_SIZE_UP]
		else
			line2 -_widthHalfHead[iShapeHead][HEAD_SIZE_SIDE], 0, _widthHalfHead[iShapeHead][HEAD_SIZE_SIDE], 0
		endif
	endif
	


	! ===================================================================
	! Text
	! ===================================================================

	if bVerticalTextPosition then
		rot2 90
		nTrans = nTrans + 1
	endif

	if not(bDivisionLine) then
		pen penMarkerText
		style "markertext_oneRow"
		if iShapeHead = MARKER_HEAD_GOST then
			add2 0, _widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_UP]
			nTrans = nTrans + 1
		endif
		text2 0,0,contentFirstRow
	else
		pen penMarkerText
		style "markertext_1stRow"
		text2 0,0,contentFirstRow

		pen penMarkerSecondText
		style "markertext_2ndRow"
		text2 0,0,contentSecondRow
	endif
	del nTrans

endif



END


! ==============================================================================
! Segment - Point Projection
! ------------------------------------------------------------------------------
! Input variables:
!	x1,y1, x2,y2:	Line Segment
!	px,py:			Point
!
! Returned variables:
!	state:			0 = no intersection point
!					1 = valid intersection point
!	px, py:			Projected Point
! ==============================================================================

"segment_point_projection":

	x21 = px
	y21 = py
	x22 = px + (y1 - y2)
	y22 = py - (x1 - x2)

	lliDiv = (x1-x2) * (y21-y22) - (y1-y2) * (x21-x22)

	segLength = ((x1 - x2)^2 + (y1 - y2)^2)

	if abs(lliDiv) > EPS then
		! Intersection

		temp1 = x1  * y2  - y1  * x2
		temp2 = x21 * y22 - y21 * x22

		tempx = temp1 * (x21-x22) - (x1-x2) * temp2
		tempy = temp1 * (y21-y22) - (y1-y2) * temp2

		state = 1
		px = (tempx / lliDiv)
		py = (tempy / lliDiv)

		endDist1 = ((px - x1)^2 + (py - y1)^2)
		endDist2 = ((px - x2)^2 + (py - y2)^2)
		if endDist1 > segLength | endDist2 > segLength then
			if endDist1 < endDist2 then
				px = x1
				py = y1
			else
				px = x2
				py = y2
			endif
		endif
	else
		! No Intersection
		state = 0
		px = 0
		py = 0
	endif

return

! ==============================================================================
! Segment - Segment intersection
! ==============================================================================
! Input:
!	line1X1:		line1 startpoint X
!	line1Y1:		line1 startpoint Y
!	line1X2:		line1 endpoint X
!	line1Y2:		line1 endpoint Y
!	line2X1:		line2 startpoint X
!	line2Y1:		line2 startpoint Y
!	line2X2:		line2 endpoint X
!	line2Y2:		line2 endpoint Y
!
! Output:
!	ret:			output status
!						-1: no intersection, segments is not paralel
!						 0: no intersection, parallel segments
!						 1: intersection point lies on S1 segment, but not lies on S2
!						 2: intersection point lies on S2 segment, but not lies on S1
!						 3: intersection point lies on both segments
!	cx:				intersection point X
!	cy:				intersection point Y
! ==============================================================================

"segment_segment_intersection":
	gosub "line_line_intersection"	! Intersection of Line - Line

	if state then
		state = 0

		if abs(line1X1 - line1X2) < EPS then
			if (line1Y1-EPS <= cy & cy <= line1Y2+EPS) | (line1Y1+EPS >= cy & cy >= line1Y2-EPS) then state = 1
		else
			if (line1X1-EPS <= cx & cx <= line1X2+EPS) | (line1X1+EPS >= cx & cx >= line1X2-EPS) then state = 1
		endif
		if abs(line2X1 - line2X2) < EPS then
			if (line2Y1-EPS <= cy & cy <= line2Y2+EPS) | (line2Y1+EPS >= cy & cy >= line2Y2-EPS) then state = state + 2
		else
			if (line2X1-EPS <= cx & cx <= line2X2+EPS) | (line2X1+EPS >= cx & cx >= line2X2-EPS) then state = state + 2
		endif

		if state = 0 then state = -1
	endif
return

! ==============================================================================
! Line - Line intersection
! ==============================================================================
! Input:
!	line1X1:		line1 startpoint X
!	line1Y1:		line1 startpoint Y
!	line1X2:		line1 endpoint X
!	line1Y2:		line1 endpoint Y
!	line2X1:		line2 startpoint X
!	line2Y1:		line2 startpoint Y
!	line2X2:		line2 endpoint X
!	line2Y2:		line2 endpoint Y
!
! Output:
!	state:			output status
!						 0: no intersection, parallel lines
!						 1: lines are intersects
!	cx:				intersection point X
!	cy:				intersection point Y
! ==============================================================================

"line_line_intersection":

	lliDiv = (line1X1-line1X2) * (line2Y1-line2Y2) - (line1Y1-line1Y2) * (line2X1-line2X2)

	if abs(lliDiv) > EPS then
		! Intersection

		temp1 = line1X1 * line1Y2 - line1Y1 * line1X2
		temp2 = line2X1 * line2Y2 - line2Y1 * line2X2

		tempx = temp1 * (line2X1-line2X2) - (line1X1-line1X2) * temp2
		tempy = temp1 * (line2Y1-line2Y2) - (line1Y1-line1Y2) * temp2

		state = 1
		cx = (tempx / lliDiv)
		cy = (tempy / lliDiv)
	else
		! No Intersection
		state = 0
		cx = 0
		cy = 0
	endif

return

! ==============================================================================
! Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	xo,yo,ro:			circle
!	x1,y1, x2,y2		line
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = one intersection point (tangential line)
!						2 = two intersection points
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
! ==============================================================================

"circle_line_intersection":
	tempX1 = x1 - xo: tempY1 = y1 - yo
	tempX2 = x2 - xo: tempY2 = y2 - yo

	if abs(tempX2 - tempX1) < EPS then
		if abs(ro - tempX1) < EPS then
			state = 1
			xa = tempX1
			ya = 0
			xb = tempX1
			yb = 0
		else
			state = 2
			xa = tempX1
			ya = sqr(ro^2 - tempX1^2)
			xb = tempX1
			yb = -sqr(ro^2 - tempX1^2)
		endif
	else
		kf = (tempY2 - tempY1) / (tempX2 - tempX1)
		ad = 1 + kf^2
		bd = 2 * tempY1 * kf - 2 * tempX1 * kf^2
		cd = tempY1^2 - 2 * tempX1 * tempY1 * kf + tempX1^2 * kf^2 - ro^2

		if bd^2 - 4 * ad * cd < 0 then
			state = 0: xa = 0: ya = 0: xb = 0: yb = 0
		else
			xa = (-bd + sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			ya = tempY1 + (xa - tempX1) * kf
			xb = (-bd - sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			yb = tempY1 + (xb - tempX1) * kf

			if abs(xa - xb) < EPS then state = 1 else state = 2
		endif
	endif

	if state = 2 then
		da = sqr((tempX1 - xa)^2 + (tempY1 - ya)^2)
		db = sqr((tempX1 - xb)^2 + (tempY1 - yb)^2)

		if db < da then
			xxo = xa: yyo = ya
			xa = xb:  ya = yb
			xb = xxo: yb = yyo
		endif
	endif

	xa = xa + xo: ya = ya + yo
	xb = xb + xo: yb = yb + yo
return

! ==============================================================================
! Segment - Point intersection
! ==============================================================================
! Input:
!	x1:		line1 startpoint X
!	y1:		line1 startpoint Y
!	x2:		line1 endpoint X
!	y2:		line1 endpoint Y
!	cx
!	cy
!
! Output:
!	status:			output status
!						-1: no intersection, segments is not paralel
!						 0: no intersection, parallel segments
!						 1: intersection point lies on S1 segment
! ==============================================================================

"segment_point_status":
	if state > 0 then
		state = 0

		if abs(x1 - x2) < EPS then
			if (y1-EPS <= cy & cy <= y2+EPS) | (y1+EPS >= cy & cy >= y2-EPS) then state = 1
		else
			if (x1-EPS <= cx & cx <= x2+EPS) | (x1+EPS >= cx & cx >= x2-EPS) then state = 1
		endif
		if state = 0 then state = -1
	endif
return


! ==============================================================================
! Marker Line Direction Angle
! ------------------------------------------------------------------------------
! Input variables:
!	angle:				angle of vector
!	_totalRotate		angle of oriented view
! Input parameter:
!	iRotateHead			HEAD_HORIZONTAL - always horizontal
!						HEAD_ROTATED - automatic calculating could be horizontal and vertical
! Returned variables:
!	_angleExternalLine:		marker line direction
! ==============================================================================

"set_connection_line_direction_angle":

	angle = angle + _totalRotate
	if angle < -eps then
		angle = angle + 360
	else
		angle = angle MOD 360
	endif

	if iRotateHead = HEAD_HORIZONTAL then
		if angle > 270 - EPS | angle <= 90  + EPS then _angleExternalLine = 0
		if angle > 90 - EPS & angle <= 270 + EPS then _angleExternalLine = 180
	else
		if angle > 315 - EPS | angle <= 45  + EPS then _angleExternalLine = 0
		if angle > 45  + EPS & angle <= 135 - EPS then _angleExternalLine = 90
		if angle > 135 - EPS & angle <= 225 + EPS then _angleExternalLine = 180
		if angle > 225 + EPS & angle <= 315 - EPS then _angleExternalLine = 270
	endif

return

! ==============================================================================
! Cloud polygon
! ------------------------------------------------------------------------------
! Input variables:
!	AC_PolygonCoords[i][1], AC_PolygonCoords[i][2] :	polygon coords
!	_lengthVector
!	radiusCloud_model
!	numRatioCloud
!
! Returned variables:
!	stack
! ==============================================================================

"standard_cloudy":

	put AC_PolygonCoords[i][1], AC_PolygonCoords[i][2], 1

	if iTypeCloud = CLOUD_BISCUIT then
		_numCloud[i] = max(1, INT(_lengthVector[i] / (radiusCloud_model*2)))
		for j = 1 to _numCloud[i]
			_radCloud[i][j] = _lengthVector[i] / _numCloud[i] /2
		next j
	endif

	if iTypeCloud = CLOUD_PERIODIC then
		_numCloud[i] = 2
		_perCloud = (numRatioCloud + 1) / min(1, numRatioCloud)
		_radCloud[i][1] = (_lengthVector[i] / _perCloud) * (1 / min(1, numRatioCloud)) /2
		_radCloud[i][2] = (_lengthVector[i] -_radCloud[i][1] * 2) /2
	endif

	if iTypeCloud = CLOUD_RANDOM then
		! inicialization
		_numCloud[i] 		= 1
		_radCloud[i][1] 	= 1

		! every vector has a own sample depending the distance from origo to draw the random cirlces
		if i = (AC_PolygonNodes - 1) then
			seed = _distancePointfromOrigo[1]
		else
			seed = _distancePointfromOrigo[i + 1]
		endif
		seed = seed + _distancePointfromOrigo[i]

		_length = _lengthVector[i]
		_minDivison = (minradiusCloud_model + maxradiusCloud_model) * 2
		_minDiameter = (min(minradiusCloud_model,maxradiusCloud_model)*2)
		_maxDiameter = (max(minradiusCloud_model,maxradiusCloud_model)*2)

		inum = 1
		while _length > EPS do
			! schema for dummy random sample
			seed = (seed * 214013 + 2531011) MOD (2^32)

			_numCloud[i] = inum

			! manual settings for the last circles
			if _length < _minDivison + EPS then
				if _length > _maxDiameter then
					_radCloud[i][inum] = min(minradiusCloud_model,maxradiusCloud_model)
					_restDiv = (_length - _radCloud[i][inum] * 2)
				else
					_radCloud[i][inum] = _length/2
					_restDiv = -1
				endif
			else
				! manual settings if the minimum and maximum range are the same
				if abs(_minDiameter - _maxDiameter) < EPS then
					_radCloud[i][inum] = _minDiameter/2
				else
				! calculating radius with random schema
					_radCloud[i][inum] = ((seed / 65536) MOD (maxradiusCloud_model - minradiusCloud_model)) + _minDiameter/2
				endif
				_restDiv = (_length - _radCloud[i][inum] * 2)
			endif
			_length = _restDiv

			inum = inum + 1
		endwhile
	endif

	bx = AC_PolygonCoords[i][1]
	by = AC_PolygonCoords[i][2]
	dim _radius[]
	for j = 1 to _numCloud[i]
		if j = 1 then
			_radius[i] = _radCloud[i][j]
		else
			_radius[i] = (_radCloud[i][j-1] + _radCloud[i][j])
		endif
		bx = bx + _radius[i] * cos(_angleVector[i])
		by = by + _radius[i] * sin(_angleVector[i])
		put bx, by, 900
		put 0, 180, 4001
	next j


return

! ==============================================================================================
"calculate_point_headform" :
! ----------------------------------------------------------------------------------------------
! input : 	
! 	centerX			Head Origo coord x
! 	centerY			Head Origo coord y
! 	_totalRotate		angle of oriented view
! 	AC_MarkerSize		height of the marker head
!
! output:
!	stack filled with head polygon relative coords (from head center)
! ==============================================================================================

	! Shape Type --------------------------------------------------------
	if iShapeHead = MARKER_HEAD_CIRCLE then

	endif

	if iShapeHead = MARKER_HEAD_TRIANGLE_UP then
		numPeak = 3
		alfa = 90 - _totalRotate
		usePut = 1
	endif

	if iShapeHead = MARKER_HEAD_TRIANGLE_DOWN then
		numPeak = 3
		alfa = 30 - _totalRotate
		usePut = 1
	endif

	if iShapeHead = MARKER_HEAD_RECTANGLE then
		_vectorRect = SQR(_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_SIDE]^2 + _widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_UP]^2)
		_alphaRect = ATN (_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_UP]/_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_SIDE])
		alfa1 = _alphaRect - _totalRotate
		alfa2 = 180 - _alphaRect - _totalRotate
		alfa3 = 180 + _alphaRect - _totalRotate
		alfa4 = 360 - _alphaRect - _totalRotate
		put	_vectorRect * cos(alfa1) + centerX,	_vectorRect * sin(alfa1) + centerY,	 1
		put _vectorRect * cos(alfa2) + centerX,	_vectorRect * sin(alfa2) + centerY,	 1
		put _vectorRect * cos(alfa3) + centerX,	_vectorRect * sin(alfa3) + centerY,	 1
		put _vectorRect * cos(alfa4) + centerX,	_vectorRect * sin(alfa4) + centerY,	 1
		put	_vectorRect * cos(alfa1) + centerX,	_vectorRect * sin(alfa1) + centerY,	 1
	endif

	if iShapeHead = MARKER_HEAD_PENTAGON_UP then
		numPeak = 5
		alfa = 90- _totalRotate
		usePut = 1
	endif

	if iShapeHead = MARKER_HEAD_PENTAGON_DOWN then
		numPeak = 5
		alfa = 54- _totalRotate
		usePut = 1
	endif

	if iShapeHead = MARKER_HEAD_HEXAGON then
		numPeak = 6
		alfa = 90 - _totalRotate
		usePut = 1
	endif

	if iShapeHead = MARKER_HEAD_HEXAGON_ROTATED then
		numPeak = 6
		alfa = 60 - _totalRotate
		usePut = 1
	endif

	if iShapeHead = MARKER_HEAD_OCTOGON then
		numPeak = 8
		alfa = 67.5 - _totalRotate
		usePut = 1
	endif

	if iShapeHead = MARKER_HEAD_OCTOGON_ROTATED then
		numPeak = 8
		alfa = 0 - _totalRotate
		usePut = 1
	endif

	if iShapeHead = MARKER_HEAD_DIAMOND then
		alfa = -_totalRotate
		put	_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_SIDE] * cos(alfa) + centerX,	_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_SIDE]  * sin(alfa) + centerY,		 1
		put _widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_UP] * cos(alfa+90) + centerX,	_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_UP] * sin(alfa+90) + centerY,			 1
		put _widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_SIDE] * cos(alfa+180) + centerX, _widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_SIDE] * sin(alfa+180) + centerY,		 1
		put _widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_DOWN] * cos(alfa+270) + centerX,_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_DOWN] * sin((alfa+270)) + centerY,	 1
		put	_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_SIDE] * cos(alfa) + centerX,	_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_SIDE]  * sin(alfa) + centerY,		 1
	endif
	if iShapeHead = MARKER_HEAD_GOST then
		put	-_widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_SIDE] + _widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_DOWN] + centerX, _widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_UP]*2.3 + centerY, 1
		put	_widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_SIDE] + centerX, _widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_UP]*2.3 + centerY, 1
		put	_widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_SIDE] - _widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_DOWN] + centerX, centerY, 1
		put	-_widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_SIDE] + centerX, centerY, 1
	endif
	if usePut then
		for i = 1 to numPeak + 1
			put AC_MarkerSize/2 * cos(alfa) + centerX, AC_MarkerSize/2 * sin(alfa) + centerY, 1
			alfa = alfa + 360 / numPeak
		next i

	endif

!		poly2_b	nsp/3, 1 + 2*bFillHead + 4, penFillHead, backpenFillHead,
!			get(nsp)

return

! ==============================================================================================
"set_array_widthHalfHead":
! ----------------------------------------------------------------------------------------------
! input : 	
! 	widthHead_model
! 	AC_MarkerSize		height of the marker head
!
! output:
!	_widthHalfHead temporary array
! ==============================================================================================

	if _hasHead then
		_widthHalfHead[MARKER_HEAD_CIRCLE][HEAD_SIZE_SIDE] 	= AC_Markersize/2
		_widthHalfHead[MARKER_HEAD_CIRCLE][HEAD_SIZE_UP] 	= AC_Markersize/2
		_widthHalfHead[MARKER_HEAD_CIRCLE][HEAD_SIZE_DOWN] 	= AC_Markersize/2
	
		_widthHalfHead[MARKER_HEAD_TRIANGLE_UP][HEAD_SIZE_SIDE] 	= AC_Markersize/2 * tan(30)
		_widthHalfHead[MARKER_HEAD_TRIANGLE_UP][HEAD_SIZE_UP] 		= AC_Markersize/2
		_widthHalfHead[MARKER_HEAD_TRIANGLE_UP][HEAD_SIZE_DOWN] 	= AC_Markersize/2 * sin(30)
	
		_widthHalfHead[MARKER_HEAD_TRIANGLE_DOWN][HEAD_SIZE_SIDE] 	= AC_Markersize/2 * tan(30)
		_widthHalfHead[MARKER_HEAD_TRIANGLE_DOWN][HEAD_SIZE_UP] 	= AC_Markersize/2 * sin(30)
		_widthHalfHead[MARKER_HEAD_TRIANGLE_DOWN][HEAD_SIZE_DOWN] 	= AC_Markersize/2
	
		if not(bVerticalTextPosition) then
			_widthHalfHead[MARKER_HEAD_RECTANGLE][HEAD_SIZE_SIDE] 		= widthHead_model/2
			_widthHalfHead[MARKER_HEAD_RECTANGLE][HEAD_SIZE_UP] 		= AC_Markersize/2
			_widthHalfHead[MARKER_HEAD_RECTANGLE][HEAD_SIZE_DOWN] 		= AC_Markersize/2
		else
			_widthHalfHead[MARKER_HEAD_RECTANGLE][HEAD_SIZE_SIDE] 		= AC_Markersize/2
			_widthHalfHead[MARKER_HEAD_RECTANGLE][HEAD_SIZE_UP] 		= widthHead_model/2
			_widthHalfHead[MARKER_HEAD_RECTANGLE][HEAD_SIZE_DOWN] 		= widthHead_model/2
		endif
	
		_widthHalfHead[MARKER_HEAD_PENTAGON_UP][HEAD_SIZE_SIDE] 	= AC_Markersize/2 * sin(36) + AC_Markersize/2 * cos(36) * tan(18)
		_widthHalfHead[MARKER_HEAD_PENTAGON_UP][HEAD_SIZE_UP] 		= AC_Markersize/2
		_widthHalfHead[MARKER_HEAD_PENTAGON_UP][HEAD_SIZE_DOWN] 	= AC_Markersize/2 * cos(36)
	
		_widthHalfHead[MARKER_HEAD_PENTAGON_DOWN][HEAD_SIZE_SIDE] 	= AC_Markersize/2 * sin(36) + AC_Markersize/2 * cos(36) * tan(18)
		_widthHalfHead[MARKER_HEAD_PENTAGON_DOWN][HEAD_SIZE_UP] 	= AC_Markersize/2 * cos(36)
		_widthHalfHead[MARKER_HEAD_PENTAGON_DOWN][HEAD_SIZE_DOWN] 	= AC_Markersize/2
	
		_widthHalfHead[MARKER_HEAD_HEXAGON][HEAD_SIZE_SIDE]			= AC_Markersize/2 * cos(30)
		_widthHalfHead[MARKER_HEAD_HEXAGON][HEAD_SIZE_UP] 			= AC_Markersize/2
		_widthHalfHead[MARKER_HEAD_HEXAGON][HEAD_SIZE_DOWN] 		= AC_Markersize/2
	
		_widthHalfHead[MARKER_HEAD_HEXAGON_ROTATED][HEAD_SIZE_SIDE] = AC_Markersize/2
		_widthHalfHead[MARKER_HEAD_HEXAGON_ROTATED][HEAD_SIZE_UP] 	= AC_Markersize/2 * cos(30)
		_widthHalfHead[MARKER_HEAD_HEXAGON_ROTATED][HEAD_SIZE_DOWN] = AC_Markersize/2 * cos(30)
	
		_widthHalfHead[MARKER_HEAD_OCTOGON][HEAD_SIZE_SIDE] 	= AC_Markersize/2 * cos(22.5)
		_widthHalfHead[MARKER_HEAD_OCTOGON][HEAD_SIZE_UP] 		= AC_Markersize/2 * cos(22.5)
		_widthHalfHead[MARKER_HEAD_OCTOGON][HEAD_SIZE_DOWN] 	= AC_Markersize/2 * cos(22.5)
	
		_widthHalfHead[MARKER_HEAD_OCTOGON_ROTATED][HEAD_SIZE_SIDE] 	= AC_Markersize/2
		_widthHalfHead[MARKER_HEAD_OCTOGON_ROTATED][HEAD_SIZE_UP] 		= AC_Markersize/2
		_widthHalfHead[MARKER_HEAD_OCTOGON_ROTATED][HEAD_SIZE_DOWN] 	= AC_Markersize/2
	
		if not(bVerticalTextPosition) then
			_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_SIDE] 	= widthHead_model/2
			_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_UP] 		= AC_Markersize/2
			_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_DOWN] 	= AC_Markersize/2
		else
			_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_SIDE] 	= AC_Markersize/2
			_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_UP] 		= widthHead_model/2
			_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_DOWN] 	= widthHead_model/2
		endif
	
		_widthHalfHead[MARKER_HEAD_LINE][HEAD_SIZE_SIDE] 	= widthHead_model/2
		_widthHalfHead[MARKER_HEAD_LINE][HEAD_SIZE_UP] 		= widthHead_model/2
		_widthHalfHead[MARKER_HEAD_LINE][HEAD_SIZE_DOWN] 	= widthHead_model/2

		_widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_SIDE] 	= widthHead_model/2
		_widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_UP] 	= AC_Markersize/2
		_widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_DOWN] 	= TAN(30)*AC_Markersize
	
		if not(bVerticalTextPosition) then
			_widthHalfHead[MARKER_HEAD_NONE][HEAD_SIZE_SIDE] 	= widthHead_model/2
			_widthHalfHead[MARKER_HEAD_NONE][HEAD_SIZE_UP] 		= widthHead_model/2
			_widthHalfHead[MARKER_HEAD_NONE][HEAD_SIZE_DOWN] 	= widthHead_model/2
		else
			_widthHalfHead[MARKER_HEAD_NONE][HEAD_SIZE_SIDE] 	= widthHead_model/2
			_widthHalfHead[MARKER_HEAD_NONE][HEAD_SIZE_UP] 		= widthHead_model/2
			_widthHalfHead[MARKER_HEAD_NONE][HEAD_SIZE_DOWN] 	= widthHead_model/2
		endif
	endif
return

! ===================================================================
! Drawing Hidden Easter Egg
! ===================================================================
"draw_easteregg":

	dim _nodeposPerpendicular[][2]
	_posPerpendicularX = 0 : _posPerpendicularY = 0

	lowY = 9999999
	highY = -9999999
	numLowY = 0  : numHighY = 0

	for iEgg = 1 to AC_PolygonNodes - 1 
		highY =	max(highY, AC_PolygonCoords[iEgg][2])
		lowY =	min(lowY, AC_PolygonCoords[iEgg][2])
	next iEgg

	for iEgg = 1 to AC_PolygonNodes - 1
		if abs(AC_PolygonCoords[iEgg][2] - highY) < EPS then
			numHighY = numHighY + 1
			_nodeposPerpendicular[numHighY][1] = AC_PolygonCoords[iEgg][1]
			_nodeposPerpendicular[numHighY][2] = AC_PolygonCoords[iEgg][2]

			! calculate the length of vector
			! --------------------------------------
			vx2 = _nodeposPerpendicular[numHighY][1]
			vy2 = _nodeposPerpendicular[numHighY][2]
			vx1 = 0
			vy1 = 0
			gosub "calculation_vector_length"

			if lengthfromHead < _templengthVector then
				_posPerpendicularX = _nodeposPerpendicular[numHighY][1]
				_posPerpendicularY = _nodeposPerpendicular[numHighY][2]
			endif
			lengthfromHead = _templengthVector
		endif

		if abs(AC_PolygonCoords[iEgg][2] - lowY) < EPS then numLowY = numLowY + 1
	next iEgg

	if numHighY = 2 and numLowY = 4 then
		add2 _posPerpendicularX, _posPerpendicularY

		! calculate the length of vector
		! --------------------------------------
		vx2 = _nodeposPerpendicular[1][1]
		vy2 = _nodeposPerpendicular[1][2]
		vx1 = _nodeposPerpendicular[2][1]
		vy1 = _nodeposPerpendicular[2][2]
		gosub "calculation_vector_length"	! returned  _templengthVector

		mul2  1/2 *  _templengthVector / 6.652 , 1/2 *  _templengthVector / 5.875 !  6.652376 , 5.874670 ! A/6.652 , B/5.875

		gosub "draw_sheephead"

		del 2
	endif

return

"draw_sheephead":
! A 6652, B 5875
spline2a      5,      2, 
        -1.462806924883, 1.213729460734,            0,            0,            0, 
        -3.001647523691, 1.882617670684, 184.8102224932, 0.8626380456399, 0.0515818108589, 
        -3.13867381209, 1.831273775225, 229.7698826915, 0.05070509770323, 0.08781228901577, 
        -3.081631522984, 1.59904754631, 307.82439341, 0.0930796662307, 0.5839367853911, 
        -1.637418434888, 0.6367522972408, 327.6145022132, 0.2325225849634,            0
spline2a      7,      2, 
        -1.462806924883, 1.213729460734,            0,            0,            0, 
        -1.612335632903, 1.418704817114, 129.7979168026, 0.1269382928864, 0.4612915196699, 
        -2.804047941567, 2.03938687603, 171.0653255825, 0.4633194391976, 0.2023064883303, 
        -3.329274104522, 1.916157727706, 237.6787871728, 0.1943545284217, 0.2125275766289, 
        -3.158040479736, 1.358798846914, 311.0192943517, 0.2228287264787, 0.4891018044228, 
        -1.919815400265, 0.6552776641342, 350.4944163365, 0.4887816500814, 0.09775161573636, 
        -1.637418434888, 0.6367522972408, 22.38088320968, 0.04015839495368,            0
spline2a      8,      2, 
        1.722265191958, 1.369425847384,            0,            0,            0, 
        1.772877223843, 1.56554747094, 69.47932593457, 0.1014211631169, 0.2581979362188, 
        2.30430355864, 2.096973805737, 28.18197548157, 0.2601691556868, 0.2591603726132, 
        3.038178020978, 2.242483397407, 346.3910084264, 0.2568983783142, 0.07697563030885, 
        3.231867304149, 2.132125925733, 307.0513830919, 0.07637706672501, 0.09306752020001, 
        3.271529993102, 1.866691007352, 259.5445485484, 0.09405714999007, 0.3346072195229, 
        2.615105057213, 1.176384708828, 203.848444684, 0.3395434115233, 0.3147891255886, 
        2.013284375299, 0.9961621122291,            0, 7.105427357601E-015,            0
spline2a      8,      2, 
        2.013284375299, 0.9961621122291,            0,            0,            0, 
        2.404770739631, 1.203575222151, 26.07852548748, 0.2215383871443, 0.2937273502758, 
        3.076137044892, 1.71105706261, 67.39793564261, 0.2882599578557, 0.05407258710112, 
        3.115203980908, 1.867481341418, 83.87209497783, 0.05410556869236, 0.05629746960895, 
        3.088790052863, 2.027382261894, 126.2192339222, 0.05561401919644, 0.08111844943962, 
        2.866272219466, 2.078497471847, 187.0140885906, 0.0839077464514, 0.4050897281606, 
        1.8361422637, 1.514935439054, 229.5966643091, 0.4052754199074, 0.0924039229305, 
        1.722265191958, 1.369425847384,            0, 7.105427357601E-015,            0
spline2a      4,      2, 
        -1.379723809596, 1.741134354981,            0,            0,            0, 
        -1.340183159686, 1.973984848898, 72.49830727357, 0.1184108098141, 0.2049584642244, 
        -0.932400012622, 2.386236852627, 16.90251314034, 0.2045361730063, 0.2053697138371, 
        -0.35967911409, 2.296047578186, 322.0202488149, 0.1760747338875,            0
spline2a      3,      2, 
        -0.35967911409, 2.296047578186,            0,            0,            0, 
        -0.08646445317309, 2.68076403407, 20.05181226743, 0.2476894135188, 0.2132905342232, 
        0.4231928713952, 2.447537015161, 295.2293132341, 0.1961142458859,            0
spline2a      3,      2, 
        0.4231928713952, 2.447537015161,            0,            0,            0, 
        0.871470356042, 2.553161395537, 322.8134851513, 0.2513029466391, 0.1447182430718, 
        1.002673185834, 2.195239932784, 246.4968398284, 0.0906601381834,            0
spline2a      3,      2, 
        1.002673185834, 2.195239932784,            0,            0,            0, 
        1.467107106668, 2.313848509553, 342.2668515446, 0.2489648604894, 0.1595020210346, 
        1.744842890519, 2.012709639241, 262.1073692591, 0.09926621420051,            0
spline2a      4,      2, 
        -1.379723809596, 1.741134354981,            0,            0,            0, 
        -1.36311471613, 2.368909970971, 63.61140790301, 0.3221938759708, 0.2876131833683, 
        -0.6543418995372, 2.70241768449, 350.1334032134, 0.2891491091376, 0.08714508055951, 
        -0.4322841242566, 2.574093294925, 317.3311055119, 0.1336129526413,            0
spline2a      3,      2, 
        -0.4322841242566, 2.574093294925,            0,            0,            0, 
        0.03690511833423, 2.95344410964, 354.8618519507, 0.3233041240605, 0.2220732586325, 
        0.4799484349887, 2.620886399069, 268.2019743013, 0.09361378424401,            0
spline2a      3,      2, 
        0.4799484349887, 2.620886399069,            0,            0,            0, 
        0.8766375116287, 2.768424827525, 344.5008819924, 0.2236981041455, 0.2614074319109, 
        1.086238400283, 2.320377459749, 207.9940161522, 0.05352803085541,            0
spline2a      3,      2, 
        1.086238400283, 2.320377459749,            0,            0,            0, 
        1.421756612049, 2.445898796373, 357.1451933258, 0.1830663794467, 0.291108287041, 
        1.744842890519, 2.012709639241, 218.6483937178, 0.08646458840327,            0
spline2a     13,      2, 
        -0.3492675208874, 0.3480909543309,            0,            0,            0, 
        -0.4151686040715, 0.5545810149745, 122.184736672, 0.1092790656682, 0.07807505365693, 
        -0.5799213120318, 0.7193337229348, 140.2598012672, 0.07833677360249, 0.04448992302389, 
        -0.6889073564975, 0.7947057326781, 156.0968897808, 0.04437702244609, 0.06645898328059, 
        -0.8845959260162, 0.8241325852373, 177.670186255, 0.0667659230677, 0.0265285543391, 
        -0.9640484279261, 0.8241325852373, 184.3967110049, 0.02651204751805, 0.03585770625781, 
        -1.068513754511, 0.80059110319, 201.0998582704, 0.03584716189063, 0.02290195641854, 
        -1.122953431746, 0.762336194863, 236.2720644515, 0.02271654069879, 0.04272226829705, 
        -1.11265403335, 0.6416860993702, 296.4266452917, 0.04375831031234, 0.03190873567135, 
        -1.058214356116, 0.5637049400883, 313.5078220918, 0.03190658421672, 0.03659519810091, 
        -0.9699337984379, 0.500437207086, 337.3584350973, 0.03654220291765, 0.034200928461, 
        -0.8698824997366, 0.4827810955505, 0.4621314646031, 0.03425204272695, 0.06863601214457, 
        -0.7345189779643, 0.503379892342,            0, 7.105427357601E-015,            0
spline2a      7,      2, 
        -0.7345189779643, 0.503379892342,            0,            0,            0, 
        -0.8046769245933, 0.5476322914999, 40.9050585617, 0.06087902687429, 0.03684809561535, 
        -0.7208921360567, 0.6068947029038, 72.78623562349, 0.03553889724661, 0.02493040144651, 
        -0.7198055516847, 0.6799410076972, 72.60928895197, 0.02487842182899, 0.03618090710834, 
        -0.6418243924028, 0.6416860993702, 318.2076773922, 0.04672095785418, 0.04565532593227, 
        -0.5314736953057, 0.5607622548324, 322.7551392627, 0.04569378015496, 0.1408306813806, 
        -0.3492675208874, 0.3480909543309,            0, 1.42108547152E-014,            0
spline2a      8,      2, 
        1.698653586865, 0.5518836160612,            0,            0,            0, 
        1.677296754352, 0.7013814436548, 90.87275755326, 0.07563862333675, 0.05027285458087, 
        1.710857491159, 0.8447773191017, 58.66773028017, 0.05008136500822, 0.0533703388269, 
        1.835947510166, 0.9332556252285, 8.523429528622, 0.05323619169316, 0.02941137151117, 
        1.915272888072, 0.9118987927151, 314.1520822121, 0.02910783246571, 0.03972277643335, 
        1.939680696659, 0.7990126780016, 269.3707170047, 0.04049228920013, 0.06781705260279, 
        1.893916055559, 0.612903137528, 221.1222441339, 0.06624434850959, 0.06956915486971, 
        1.762724084405, 0.5854443528679,            0, 7.105427357601E-015,            0
spline2a      7,      2, 
        1.762724084405, 0.5854443528679,            0,            0,            0, 
        1.78637385727, 0.6250623130055, 63.73489684855, 0.02309078623536, 0.02689166388849, 
        1.78637385727, 0.6927440738917, 146.9127839513, 0.02522902410744, 0.004750285572484, 
        1.773131773619, 0.6971581017756, 176.7118302327, 0.004748237126632, 0.023335653554, 
        1.737819550547, 0.6456611097969, 261.0217576359, 0.02505173403573, 0.01967150907063, 
        1.726048809524, 0.5882787473065, 246.1293301898, 0.01960193244568, 0.02293210229109, 
        1.698653586865, 0.5518836160612,            0,            0,            0
spline2a     10,      2, 
        1.85209729385, 0.5191382598017,            0,            0,            0, 
        1.663530022651, 0.1250538503287, 264.7445107396, 0.2218827833399, 0.2581415135197, 
        1.908887099017, -0.5976739549383, 288.3800979239, 0.2619783430727, 0.1995306871972, 
        1.963635601906, -1.189240185647, 267.5148567779, 0.200092622767, 0.2214530129647, 
        1.734562104184, -1.649238455453, 174.6991818167, 0.197945846735, 0.1312746289144, 
        1.539457000074, -1.386409025423, 77.99311084049, 0.1311298596677, 0.01424855557069, 
        1.555474620054, -1.347465851734, 53.81854956254, 0.01419901517035, 0.02002193733518, 
        1.602625945155, -1.311061511738, 30.15535364876, 0.02009748334256, 0.08484956069598, 
        1.806544526089, -1.164195413995, 52.22661493143, 0.08441414854323, 0.1352635612244, 
        1.877522094462, -0.9088880411916,            0, 7.105427357601E-015,            0
spline2a      3,      2, 
        1.877522094462, -0.9088880411916, 302.5688681914,            0, 0.03241207153661, 
        1.646642609092, -1.16107385967, 207.7344102802, 0.1538799540827, 0.2773253917361, 
        0.9356203785141, -0.9135700085829, 130.1165851185, 0.2854867860723,            0
spline2a      9,      2, 
        0.9356203785141, -0.9135700085829,            0,            0,            0, 
        1.123421616065, -1.226288717302, 326.6574578597, 0.1871472044248, 0.1025053351851, 
        1.409694241568, -1.335281014993, 338.3654866464, 0.1028783708849, 0.01792736386313, 
        1.45394402401, -1.363582640602, 306.237637375, 0.01778177926879, 0.01027335470722, 
        1.465626969456, -1.391785425128, 284.738512047, 0.01030672763901, 0.07114066041973, 
        1.460648768883, -1.597419200883, 243.9207311994, 0.07042207181014, 0.110060981726, 
        1.17747693875, -1.721272809049, 181.8111814165, 0.1133430919991, 0.1670023287165, 
        0.6969482071991, -1.614488646483, 153.0355827173, 0.1667838228729, 0.3715298962693, 
        0.1661451765521, -1.104315067374,            0, 7.105427357601E-015,            0
spline2a      3,      2, 
        0.1661451765521, -1.104315067374,            0,            0,            0, 
        0.7392795446311, -1.786296581156, 340.8752573466, 0.4613447005756, 0.3112014209948, 
        1.522770200265, -1.698428470244, 60.6961991209, 0.134072438539,            0
spline2a      6,      2, 
        1.522770200265, -1.698428470244,            0,            0,            0, 
        1.733697916702, -1.768822824028, 359.1686621766, 0.1127870129052, 0.2323273201029, 
        2.065570908353, -1.240515027762, 82.86510982704, 0.2493257968945, 0.2342763442875, 
        2.01941758012, -0.5495527157643, 108.1131143172, 0.2337843394782, 0.2275455794198, 
        1.793419352465, 0.0878329106681, 95.8495954853, 0.2264846518464, 0.2191967582349, 
        1.85209729385, 0.5191382598017,            0,            0,            0
spline2a      3,      2, 
        1.659111595562, -1.846284603013, 245.8022479588,            0, 0.4154026746653, 
        1.005772125174, -2.325165807484, 168.1065757329, 0.2991658918216, 0.4578815221622, 
        0.09066581578031, -1.534352809274, 94.12794021754, 0.1278205667251,            0
spline2a      8,      2, 
        2.261707868316, 0.5878410004667,            0,            0,            0, 
        2.36714960141, 0.329508754385, 269.9494788511, 0.1423768721878, 0.1107138753987, 
        2.240619521697, 0.02899981506542, 235.405648031, 0.1117231711186, 0.139748229039, 
        2.0771848354, -0.3400462507656, 274.7901878133, 0.1376371838163, 0.04997612812519, 
        2.140449875257, -0.4665763304791, 325.8482941459, 0.04963556753858, 0.06033300943826, 
        2.314428734863, -0.508753023717, 347.0165349905, 0.0609958800174, 0.1084226363436, 
        2.52794824438, -0.7222725332335, 284.1202668145, 0.1080932874659, 0.2730893989271, 
        2.230075348388, -1.120315075666,            0,            0,            0
spline2a      3,      2, 
        2.230075348388, -1.120315075666,            0,            0,            0, 
        2.536598684163, -1.426838411441, 275.1757665394, 0.2301251007225, 0.230378417543, 
        2.289552921192, -1.783719313052,            0,            0,            0
spline2a      3,      2, 
        2.289552921192, -1.783719313052,            0,            0,            0, 
        2.289552921192, -2.187912623248, 245.2288399738, 0.2070110186265, 0.2364559827507, 
        1.92050685536, -2.460303767076,            0, 7.105427357601E-015,            0
spline2a     15,      2, 
        2.261707868316, 0.5878410004667,            0,            0,            0, 
        2.472631835826, 0.1477076366503, 260.6903639936, 0.2551920174168, 0.1432453692033, 
        2.35265767717, -0.2539075304786, 276.8198466324, 0.141794275516, 0.01599879861789, 
        2.365610433285, -0.299589804256, 298.0809612031, 0.01598686956473, 0.02202836946961, 
        2.40873540074, -0.3490621430933, 319.9060487978, 0.02209368139087, 0.1768103408176, 
        2.803193625628, -0.6475475234681, 287.9762861618, 0.1707830087821, 0.1746682590772, 
        2.56737761856, -1.083106525195, 230.2974625812, 0.1831823973165, 0.01997745607762, 
        2.550133466201, -1.132579495703, 299.6874949658, 0.01897816402658, 0.01705082773007, 
        2.595541770808, -1.150659530437, 352.4928300992, 0.01764467878078, 0.1458979123052, 
        2.855914492175, -1.438360521677, 273.5162297978, 0.1456889610811, 0.1624154609793, 
        2.597887379294, -1.800085902429, 202.8010024649, 0.164048263762, 0.03856227113464, 
        2.509983977065, -1.862592642723, 253.668904974, 0.03748310048423, 0.02318899505334, 
        2.516299228438, -1.930687321245, 284.0582546976, 0.02350636816659, 0.1429743362133, 
        2.403564611255, -2.316564274631, 225.0296526793, 0.1428257651745, 0.2595363358401, 
        1.92050685536, -2.460303767076,            0,            0,            0
spline2a      3,      2, 
        -2.463192176862, 0.3697392414947,            0,            0,            0, 
        -2.577069248604, -0.009850997645785, 290.7341805886, 0.2094230060943, 0.2278414241208, 
        -2.197479009463, -0.2072379219988,            0, 1.42108547152E-014,            0
spline2a      3,      2, 
        -2.197479009463, -0.2072379219988,            0,            0,            0, 
        -2.478375786427, -0.9967856194111, 288.8430010977, 0.4440001689429, 0.4766580721193, 
        -1.696419893798, -1.429518492031,            0,            0,            0
spline2a      3,      2, 
        -1.696419893798, -1.429518492031,            0,            0,            0, 
        -1.772337941626, -1.968536631611, 301.9664947799, 0.2912283510079, 0.3058414152866, 
        -1.218136192481, -2.12796453205,            0, 3.552713678801E-015,            0
spline2a      3,      2, 
        -1.218136192481, -2.12796453205,            0,            0,            0, 
        -1.322101866613, -2.417854661793, 264.1709807134, 0.1554246597788, 0.5186006674954, 
        -0.5272819572453, -2.742900719457,            0, 7.105427357601E-015,            0
spline2a     16,      2, 
        -2.463192176862, 0.3697392414947,            0,            0,            0, 
        -2.799177057576, 0.08177168249833, 250.0189039416, 0.2286363914103, 0.181018841162, 
        -2.61465402466, -0.318028222152, 349.5003540849, 0.176196712432, 0.02774486228019, 
        -2.53911022469, -0.3438904080894, 313.3946636475, 0.02724355544337, 0.04713763189859, 
        -2.588293591386, -0.4586171996113, 228.1217412126, 0.05256044965151, 0.2230095335269, 
        -2.715702352209, -1.073693975996, 286.4055353831, 0.2237829492624, 0.258947746482, 
        -2.18410028119, -1.556968586013, 349.2467645992, 0.2587934562604, 0.02935114246422, 
        -2.10637735207, -1.58894639247, 309.42010941, 0.02882955093759, 0.05459199146608, 
        -2.174703595115, -1.718007073778, 229.3402586734, 0.06119181380412, 0.1921288709838, 
        -2.039416063975, -2.192369842239, 323.9347351689, 0.2015179342656, 0.1674490897074, 
        -1.56735921249, -2.287392432489, 10.59510647834, 0.1679264641093, 0.03067242015671, 
        -1.483849359879, -2.294984237272, 315.6735843359, 0.02956771989296, 0.04339506655164, 
        -1.539055987948, -2.39373426308, 224.6574626898, 0.04977522979756, 0.106727838709, 
        -1.618381365854, -2.680526013974, 285.9803897437, 0.1064765535871, 0.1696310125378, 
        -1.216218167009, -2.917936504859, 356.3771743017, 0.1749248309752, 0.3597179778417, 
        -0.5272819572453, -2.742900719457,            0,            0,            0
spline2a      3,      2, 
        0.09066581578031, -1.534352809274, 302.9577501077,            0, 0.2262061797239, 
        1.082228339477, -2.168585062674, 1.093944490369, 0.4155084915194, 0.3414303360316, 
        1.659111595562, -1.846284603013,            0, 7.105427357601E-015,            0



return

