
scal = GLOB_SCALE / 1000
unID = 10000
! === Model View Option ===
if not(bOverrideMVO[1]) then	! 2D representation
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "gs_fill_type", tmp)
	if qq > 0 then gs_fill_type = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "gs_cont_pen", tmp)
	if qq > 0 then gs_cont_pen = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "gs_cont_pen_num", tmp)
	if qq > 0 then gs_cont_pen_num = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "gs_fill_pen", tmp)
	if qq > 0 then gs_fill_pen = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "gs_fill_pen_num", tmp)
	if qq > 0 then gs_fill_pen_num = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "gs_back_pen", tmp)
	if qq > 0 then gs_back_pen = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "gs_back_pen_num", tmp)
	if qq > 0 then gs_back_pen_num = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "bShowGridX", tmp)
	if qq > 0 then bShowGridX = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "bShowGridY", tmp)
	if qq > 0 then bShowGridY = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "penGrid", tmp)
	if qq > 0 then penGrid = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "penGrid_num", tmp)
	if qq > 0 then penGrid_num = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "bShowPatternSymbol", tmp)
	if qq > 0 then bShowPatternSymbol = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "penPattSymbol", tmp)
	if qq > 0 then penPattSymbol = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "penPattSymbol_num", tmp)
	if qq > 0 then penPattSymbol_num = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "bShowAcc2d", tmp)
	if qq > 0 then bShowAcc2d = tmp
endif
if not(bOverrideMVO[3]) then	! Text style
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "fontType", tmp)
	if qq > 0 then fontType = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "sizFont", tmp)
	if qq > 0 then sizFont = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "sizFontImp", tmp)
	if qq > 0 then sizFontImp = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "penText", tmp)
	if qq > 0 then penText = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "penText_num", tmp)
	if qq > 0 then penText_num = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "penOpaque", tmp)
	if qq > 0 then penOpaque = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "penOpaque_num", tmp)
	if qq > 0 then penOpaque_num = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "penFrame", tmp)
	if qq > 0 then penFrame = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "penFrame_num", tmp)
	if qq > 0 then penFrame_num = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "bBold", tmp)
	if qq > 0 then bBold = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "bItalic", tmp)
	if qq > 0 then bItalic = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "bUnderline", tmp)
	if qq > 0 then bUnderline = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "bOpaque", tmp)
	if qq > 0 then bOpaque = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "bFrame", tmp)
	if qq > 0 then bFrame = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "iAlignment", tmp)
	if qq > 0 then iAlignment = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "textLeading", tmp)
	if qq > 0 then textLeading = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "bHorizontalText", tmp)
	if qq > 0 then bHorizontalText = tmp
endif
if not(bOverrideMVO[4]) then	! Text block content
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "bTextArea", tmp)
	if qq > 0 then bTextArea = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "bTextPanelQty", tmp)
	if qq > 0 then bTextPanelQty = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "bTextAccType", tmp)
	if qq > 0 then bTextAccType = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "prfxArea", tmp)
	if qq > 0 then prfxArea = tmp
	qq = LIBRARYGLOBAL ("Libraryflobals-pokr", "iTextFields", tmp)
	if qq > 0 then
		bTextFields[1] = bittest (tmp, 1)
		bTextFields[2] = bittest (tmp, 2)
	endif
endif

success = LIBRARYGLOBAL ("Libraryflobals-pokr", "show_fill", show_fill)
if show_fill then
	gs_fill_type = fillr
	gs_fill_pen = fill_pen
	gs_back_pen = fill_bac
endif

if penGrid>255 or penGrid<1 then penGrid = 1
! --- Model View Option ---

penRed = 1
qq = request ("pen_of_rgb", "1 0 0", penRed)

drawindex 10

if bIntWiz then
	for w = 1 to nc - 1
		idx = 2 * w - 1
		put field_poly[1][idx], field_poly[1][idx + 1], (field_poly_st[1][w] > 0)
	next w
endif

if not(bIntWiz) then
	bMovedHP = not(bSetOrigin) and not(bActiveSelection) and not(bShowAccPalette)
	for w = 1 to nc - 1
		idx = 2 * w - 1
		put field_poly[1][idx], field_poly[1][idx + 1], (field_poly_st[1][w] > 0)
		if field_poly_st[1][w] > 0 then
			if w = 1 * (nIntHotspots + 1) + 1 then unID = 11000
			if w = 2 * (nIntHotspots + 1) + 1 then unID = 12000
			if w = 3 * (nIntHotspots + 1) + 1 then unID = 13000
			if ((w - 1) mod (nIntHotspots + 1)) > 0 or bMovedIntNodes then
				if bMovedHP then
					unID = unID + 1 : hotspot2 field_poly[1][idx], 0, unID, field_poly[1][idx + 1], 1 + 128
					unID = unID + 1 : hotspot2 field_poly[1][idx], -0.1, unID, field_poly[1][idx + 1], 3
					unID = unID + 1 : hotspot2 field_poly[1][idx], field_poly[1][idx + 1], unID, field_poly[1][idx + 1], 2
					unID = unID + 1 : hotspot2 0, field_poly[1][idx + 1], unID, field_poly[1][idx], 1 + 128
					unID = unID + 1 : hotspot2 -0.1, field_poly[1][idx + 1], unID, field_poly[1][idx], 3
					unID = unID + 1 : hotspot2 field_poly[1][idx], field_poly[1][idx + 1], unID, field_poly[1][idx], 2
				else
					unID = unID + 3 : hotspot2 field_poly[1][idx], field_poly[1][idx + 1], unID
					unID = unID + 3 : hotspot2 field_poly[1][idx], field_poly[1][idx + 1], unID
				endif
			else
				if w = 1 then
					unID = unID + 6 : hotspot2 0, 0, unID
				endif
				if w = 1 * (nIntHotspots + 1) + 1 then
					unID = 11000
					if bMovedHP then
						unID = unID + 1 : hotspot2 0, 0, unID, b, 1 + 256
						unID = unID + 1 : hotspot2 0, -0.1, unID, b, 3
						unID = unID + 1 : hotspot2 0, b, unID, b, 2
						unID = unID + 1 : hotspot2 0, b, unID, a, 1 + 256
						unID = unID + 1 : hotspot2 -0.1, b, unID, a, 3
						unID = unID + 1 : hotspot2 a, b, unID, a, 2
					else
						unID = unID + 3 : hotspot2 0, b, unID
						unID = unID + 3 : hotspot2 0, b, unID
					endif
				endif
				if w = 2 * (nIntHotspots + 1) + 1 then
					unID = 12000
					if bMovedHP then
						unID = unID + 1 : hotspot2 a, 0, unID, b, 1 + 256
						unID = unID + 1 : hotspot2 a, -0.1, unID, b, 3
						unID = unID + 1 : hotspot2 a, b, unID, b, 2
						unID = unID + 1 : hotspot2 0, b, unID, a, 1 + 256
						unID = unID + 1 : hotspot2 -0.1, b, unID, a, 3
						unID = unID + 1 : hotspot2 a, b, unID, a, 2
					else
						unID = unID + 3 : hotspot2 a, b, unID
						unID = unID + 3 : hotspot2 a, b, unID
					endif
				endif
				if w = 3 * (nIntHotspots + 1) + 1 then
					unID = 13000
					if bMovedHP then
						unID = unID + 1 : hotspot2 a, 0, unID, b, 1 + 256
						unID = unID + 1 : hotspot2 a, -0.1, unID, b, 3
						unID = unID + 1 : hotspot2 a, b, unID, b, 2
						unID = unID + 1 : hotspot2 0, 0, unID, a, 1 + 256
						unID = unID + 1 : hotspot2 -0.1, b, unID, a, 3
						unID = unID + 1 : hotspot2 a, 0, unID, a, 2
					else
						unID = unID + 3 : hotspot2 a, 0, unID
						unID = unID + 3 : hotspot2 a, 0, unID
					endif
				endif
			endif
		endif
	next w
endif

put 0, 0, 700
for w = 1 to nHoles
	for q = 1 to n_hpoly[w]
		idx = 2 * q - 1
		put hole_poly[w][idx], hole_poly[w][idx + 1], (hole_poly_st[w][q] >= 0) - (hole_poly_st[w][q] < 0)
	next q
next w

line_type 1
pen gs_cont_pen
fill gs_fill_type
poly2_b nsp / 3, 7,
	gs_fill_pen, gs_back_pen,
	get (nsp)


define line_type "rotrect" 1,
	2, 0.02 / GLOB_SCALE, 0.04 / GLOB_SCALE

! *** Selection grid (rectangle) ***
if bActiveSelection then
	unID = 9900
	add2 fieldOrig[1][1], fieldOrig[1][2]
	rot2 fieldRot[1]
		line_type "rotrect"
		rect2 selRect[1][1], selRect[1][2], selRect[2][1], selRect[2][2]
		unID = unID + 1 : hotspot2 selRect[1][1], 0, unID, selRect[1][2], 1 + 128
		unID = unID + 1 : hotspot2 selRect[1][1], -0.1, unID, selRect[1][2], 3
		unID = unID + 1 : hotspot2 selRect[1][1], selRect[1][2], unID, selRect[1][2], 2
		unID = unID + 1 : hotspot2 0, selRect[1][2], unID, selRect[1][1], 1 + 128
		unID = unID + 1 : hotspot2 -0.1, selRect[1][2], unID, selRect[1][1], 3
		unID = unID + 1 : hotspot2 selRect[1][1], selRect[1][2], unID, selRect[1][1], 2

		unID = unID + 1 : hotspot2 selRect[1][1], 0, unID, selRect[2][2], 1 + 128
		unID = unID + 1 : hotspot2 selRect[1][1], -0.1, unID, selRect[2][2], 3
		unID = unID + 1 : hotspot2 selRect[1][1], selRect[2][2], unID, selRect[2][2], 2
		unID = unID + 1 : hotspot2 0, selRect[2][2], unID, selRect[1][1], 1 + 128
		unID = unID + 1 : hotspot2 -0.1, selRect[2][2], unID, selRect[1][1], 3
		unID = unID + 1 : hotspot2 selRect[1][1], selRect[2][2], unID, selRect[1][1], 2

		unID = unID + 1 : hotspot2 selRect[2][1], 0, unID, selRect[2][2], 1 + 128
		unID = unID + 1 : hotspot2 selRect[2][1], -0.1, unID, selRect[2][2], 3
		unID = unID + 1 : hotspot2 selRect[2][1], selRect[2][2], unID, selRect[2][2], 2
		unID = unID + 1 : hotspot2 0, selRect[2][2], unID, selRect[2][1], 1 + 128
		unID = unID + 1 : hotspot2 -0.1, selRect[2][2], unID, selRect[2][1], 3
		unID = unID + 1 : hotspot2 selRect[2][1], selRect[2][2], unID, selRect[2][1], 2

		unID = unID + 1 : hotspot2 selRect[2][1], 0, unID, selRect[1][2], 1 + 128
		unID = unID + 1 : hotspot2 selRect[2][1], -0.1, unID, selRect[1][2], 3
		unID = unID + 1 : hotspot2 selRect[2][1], selRect[1][2], unID, selRect[1][2], 2
		unID = unID + 1 : hotspot2 0, selRect[1][2], unID, selRect[2][1], 1 + 128
		unID = unID + 1 : hotspot2 -0.1, selRect[1][2], unID, selRect[2][1], 3
		unID = unID + 1 : hotspot2 selRect[2][1], selRect[1][2], unID, selRect[2][1], 2

		unID = unID + 1 : hotspot2 xPosSelection, 0, unID, yPosSelection, 1 + 128
		unID = unID + 1 : hotspot2 xPosSelection, -0.1, unID, yPosSelection, 3
		unID = unID + 1 : hotspot2 xPosSelection, yPosSelection, unID, yPosSelection, 2
		unID = unID + 1 : hotspot2 0, yPosSelection, unID, xPosSelection, 1 + 128
		unID = unID + 1 : hotspot2 -0.1, yPosSelection, unID, xPosSelection, 3
		unID = unID + 1 : hotspot2 xPosSelection, yPosSelection, unID, xPosSelection, 2

		line_type 1

		drawindex 20

		fill "25 %"
		if sx1 <> sx2 and sy1 <> sy2 then
			poly2_b 4, 6,
				gs_fill_pen, 0,
				sx1, sy1, 1, 
				sx1, sy2, 1, 
				sx2, sy2, 1,
				sx2, sy1, 1
		endif

		! * Panel selection (raster) *
		for w = 1 to dimx
			for q = 1 to dimy
				if accSel[w][q] and bInPoly[w][q] then
					add2 (ddimx + w) * xSizCeiPanel, (ddimy + q) * ySizCeiPanel
						fill "50 %"
						poly2_b 4, 6,
							gs_fill_pen, 0,
							0, 0, 1,
							0, ySizCeiPanel, 1,
							xSizCeiPanel, ySizCeiPanel, 1,
							xSizCeiPanel, 0, 1
					del 1
				endif
			next q
		next w
	del 2
endif

drawindex 30

if not(bMoving) and (bShowAcc2d or bActiveSelection) then
	maxSizAcc = min (xSizCeiPanel, ySizCeiPanel)
	add2 fieldOrig[1][1], fieldOrig[1][2]
	rot2 fieldRot[1]
		for w = 1 to dimx
			for q = 1 to dimy
				add2 (ddimx + w) * xSizCeiPanel + xSizCeiPanel / 2, (ddimy + q) * ySizCeiPanel + ySizCeiPanel / 2
				rot2 accRot[w][q]
				mul2 sgnMirr, 1
					xCP = xSizCeiPanel
					yCP = ySizCeiPanel
					if abs (abs (accRot[w][q]) - 90) < eps then
						xCP = ySizCeiPanel
						yCP = xSizCeiPanel
					endif
					if accType[w][q] > 100 and bInPoly[w][q] then
						hotspot2 0,0
						gosub 10000 + accType[w][q]
					endif
				del 3
			next q
		next w
	del 2
endif

if not(bMoving) and (bShowPatternSymbol or bActiveSelection) and bShowPatternSymbol then
	pen penPattSymbol
	line_type 1
	add2 fieldOrig[1][1], fieldOrig[1][2]
	rot2 fieldRot[1]
		for w = 1 to dimx
			for q = 1 to dimy
				add2 (ddimx + w) * xSizCeiPanel + xSizCeiPanel / 2, (ddimy + q) * ySizCeiPanel + ySizCeiPanel / 2
					xCP = xSizCeiPanel
					yCP = ySizCeiPanel
					if abs (abs (panelRot[w][q]) - 90) < eps then
						xCP = ySizCeiPanel
						yCP = xSizCeiPanel
					endif
					if iPanelType[w][q] <> 0 and bInPoly[w][q] then
						hotspot2 0,0
						gosub 20000 + 10 * iPanelType[w][q]
					else
						if bInPoly[w][q] then 
							gosub 20000 + 10 * iCeiPanelType
							hotspot2 0,0
						endif
					endif
				del 1
			next q
		next w
	del 2
endif


! -----

! rotated coordinates of polygon
bStack2 = 1
gosub 40
bStack2 = 0
	
! hotspots at all field corner
unID = 20000
if bIntWiz then
	for w = 1 to n_fpoly[w0]
		unID = unID + 1 : hotspot2 get (2), unID
		qq = get (1)
	next w
else
	for w = 1 to n_fpoly[w0]
		qq = get (1)
		qq = get (1)
		qq = get (1)
	next w
endif

drawindex 30

if bSetOrigin then
	add2 fieldOrig[w0][1], fieldOrig[w0][2]
		rot2 fieldRot[w0]
			gosub 100		! arrow
		del 1
		gosub 102			! graphical editing (rotation)
	del 1
	gosub 101				! graphical editing (moving)
endif

! drawing lines
for qx = 1 to 2
	alf = fieldRot[w0] + (2 - qx) * 90
	gosub 40
	if qx = 1 then
		qq = sxmin
		sxmin = symin
		symin = qq
		qq = sxmax
		sxmax = symax
		symax = qq
	endif
	if bMoving THEN
		yy1 = 0
		yy2 = 0
		yys = 1
	else
		if qx = 1 then
			yy1 = int (sxmin / xSizCeiPanel) * xSizCeiPanel
			yy2 = int (sxmax / xSizCeiPanel) * xSizCeiPanel
			yys = xSizCeiPanel
		else
			yy1 = int (symin / ySizCeiPanel) * ySizCeiPanel
			yy2 = int (symax / ySizCeiPanel) * ySizCeiPanel
			yys = ySizCeiPanel
		endif
	endif
	for yy = yy1 to yy2 step yys
		gosub 50
	next yy
next qx


! ===========================================================================
! === T O O L B O X === T O O L B O X === T O O L B O X === T O O L B O X ===
! ===========================================================================
unID = 30000

drawindex 50

if bShowAccPalette then
	line_type 1
	pen penAccPalette
	fill fillTBframe
	
	qq = request ("pen_of_rgb", "1 1 1", penWhite)
	
	add2 xPosTB, yPosTB
	rot2 -symbRotAng
		poly2_b 10, 7,
			penAccPalette, penAccPalette,
			0, 0, 1,
			wTB, 0, 1,
			wTB, -hTB, 1,
			0, -hTB, 1,
			0, 0, -1,
			wTBframe, -wTBframe, 1,
			wTBframe, -hTB + wTBframe, 1,
			wTB - wTBframe, -hTB + wTBframe, 1,
			wTB - wTBframe, -wTBframe, 1,
			wTBframe, -wTBframe, -1
		poly2_b 5, 7,
			penWhite, penWhite,
			wTBframe, -wTBframe, 1,
			wTBframe, -hTB + wTBframe, 1,
			wTB - wTBframe, -hTB + wTBframe, 1,
			wTB - wTBframe, -wTBframe, 1,
			wTBframe, -wTBframe, -1
	
		xCP = 0.9
		yCP = 0.9
		nn = 1
		for w = 1 to nTools
			add2 xTBtool[w], yTBtool[w]
				pen penAccPalette
				rect2 -wTBicon / 2, -hTBicon / 2, wTBicon / 2, hTBicon / 2
				if w = ndTB[nn] then
					line2 -wTBicon / 2 - frmTBIcons, -hTBicon / 2 - frmTBIcons, wTBicon / 2 + frmTBIcons, -hTBicon / 2 - frmTBIcons
					nn = nn + 1
				endif
				mul2 wTBicon * 0.9, hTBicon * 0.9
				mul2 sgnMirr, 1
					if typTBtool[w] = "P" then
						pen penPattSymbol
						rect2 -0.5, -0.5, 0.5, 0.5
						q = 1
						panelRot[w][q] = 0
						gosub 20000 + 10 * idTBtool[w]
					endif
					if typTBtool[w] = "A" then gosub 80000 + idTBtool[w]
					if typTBtool[w] = "Z" then gosub 90000 + 10 * idTBtool[w]
				del 2
	
				! --- Tools moving ---
				unID = unID + 1 : hotspot2 xPosTBtool[w], 0, unID, yPosTBtool[w], 1 + 128
				unID = unID + 1 : hotspot2 xPosTBtool[w], -0.1, unID, yPosTBtool[w], 3
				unID = unID + 1 : hotspot2 xPosTBtool[w], yPosTBtool[w], unID, yPosTBtool[w], 2
				unID = unID + 1 : hotspot2 0, yPosTBtool[w], unID, xPosTBtool[w], 1 + 128
				unID = unID + 1 : hotspot2 -0.1, yPosTBtool[w], unID, xPosTBtool[w], 3
				unID = unID + 1 : hotspot2 xPosTBtool[w], yPosTBtool[w], unID, xPosTBtool[w], 2
	
				! --- Tools icon (moving) ---
				if ABS (xPosTBtool[w]) > wTBicon or \
					yPosTBtool[w] > -yTBtool[w] + hTBicon / 2 or \
					yPosTBtool[w] < -hTB - yTBtool[w] - hTBicon / 2 then
					add2 xPosTBtool[w], yPosTBtool[w]
					mul2 wTBicon, hTBicon
					mul2 sgnMirr, 1
						if typTBtool[w] = "P" then
							pen penPattSymbol
							rect2 -0.5, -0.5, 0.5, 0.5
							q = 1
							panelRot[w][q] = 0
							gosub 20000 + 10 * idTBtool[w]
						endif
						if typTBtool[w] = "A" then gosub 80000 + idTBtool[w]
						if typTBtool[w] = "Z" then gosub 90000 + 10 * idTBtool[w]
					del 3
				endif
	
				if nOpenTool[w] > 0 then
					add2 wTBicon / 2 * sgnMirr, -hTBicon / 2
						unID = unID + 1 : hotspot2 0, 0, unID, openTB[w], 1 + 128
						unID = unID + 1 : hotspot2 -0.1 * sgnMirr, 0, unID, openTB[w], 3
						unID = unID + 1 : hotspot2 openTB[w] * sgnMirr, 0, unID, openTB[w], 2
	
						if openToolID = w then
							add2 frmTBIcons * sgnMirr, -frmTBIcons
							mul2 sgnMirr, 1
								pen penAccPalette
								wSideTB = nOpenTool[w] * (wTBicon + frmTBIcons) + frmTBIcons
								poly2_b 5, 7,
									penWhite, penWhite,
									0, 0, 1,
									wSideTB, 0, 1,
									wSideTB, hTBicon + 2 * frmTBIcons, 1,
									0, hTBicon + 2 * frmTBIcons, 1,
									0, 0, -1
								for q = 1 to nOpenTool[w]
									add2 frmTBIcons + (q - 1) * (wTBicon + frmTBIcons) + wTBicon / 2, frmTBIcons + hTBicon / 2
										pen penAccPalette
										rect2 -wTBicon / 2, -hTBicon / 2, wTBicon / 2, hTBicon / 2
										mul2 wTBicon * 0.9, hTBicon * 0.9
											if typTBtool[w] = "P" then
												pen penPattSymbol
												rect2 -0.5, -0.5, 0.5, 0.5
												panelRot[w][q] = 0
												gosub 20000 + 10 * idTBtools[w][q]
											endif
											if typTBtool[w] = "A" then gosub 80000 + idTBtools[w][q]
										del 1
	
										unID = unID + 1 : hotspot2 0, 0, unID, openTBside[q], 1 + 128
										unID = unID + 1 : hotspot2 0, -0.1, unID, openTBside[q], 3
										unID = unID + 1 : hotspot2 0, openTBside[q], unID, openTBside[q], 2
									del 1
								next q
							del 2
						endif
					del 1
				endif
			del 1
		next w
	del 2

	! --- Toolbox moving ---
	unID = unID + 1 : hotspot2 xPosTB, 0, unID, yPosTB, 1 + 128
	unID = unID + 1 : hotspot2 xPosTB, -0.1, unID, yPosTB, 3
	unID = unID + 1 : hotspot2 xPosTB, yPosTB, unID, yPosTB, 2
	unID = unID + 1 : hotspot2 0, yPosTB, unID, xPosTB, 1 + 128
	unID = unID + 1 : hotspot2 -0.1, yPosTB, unID, xPosTB, 3
	unID = unID + 1 : hotspot2 xPosTB, yPosTB, unID, xPosTB, 2
	
	! --- Toolbox resizing ---
	add2 xPosTB, yPosTB
	rot2 -symbRotAng
		unID = unID + 1 : hotspot2 0, 0, unID, wTB, 1 + 128
		unID = unID + 1 : hotspot2 -0.1, 0, unID, wTB, 3
		unID = unID + 1 : hotspot2 wTB, 0, unID, wTB, 2
	
		unID = unID + 1 : hotspot2 0, 0, unID, hTB, 1 + 128
		unID = unID + 1 : hotspot2 0, 0.1, unID, hTB, 3
		unID = unID + 1 : hotspot2 0, -hTB, unID, hTB, 2
	del 2
endif


! ===========================================================================
! === I N F O B O X === I N F O B O X === I N F O B O X === I N F O B O X ===
! ===========================================================================
unID = 40000

drawindex 40

line_type 1

define style "textbox" fontType, sizFont, 5 + iAlignment, bBold + 2 * bItalic + 4 * bUnderline
define style "area2" fontType, sizFont * 0.65, 7, bBold + 2 * bItalic
style "textbox"
qq = request ("height_of_style", "textbox", hStyl)
hStyl = hStyl * scal * textLeading / 100

if bHorizontalText then
	rotTextField[1] = 0
	textang = SYMB_ROTANGLE * (2 * SYMB_MIRRORED - 1)
	bMoveTextBlock = 0
else
	textang = (SYMB_ROTANGLE + rotTextField[1]) mod 360
	rotTextField[1] = rotTextField[1] * (1 - 2 * SYMB_MIRRORED)
	bMoveTextBlock = (textang > 90 + eps) * (textang < 270 + eps)
	textang = 180 * bMoveTextBlock + rotTextField[1]
endif

add2 posTextField[1][1], posTextField[1][2]
rot2 textang

	dim txtData[][2]
	n = 0

! user text fields
	for w = 1 to vardim1 (bTextFields)
		if bTextFields[w] then
			n = n + 1
			txtData[n][1] = textFields[w]
			txtData[n][2] = ""
		endif
	next w

! area calculation
	dText = 0
	if bTextArea then
		qq = request ("Area_dimension", "", areaUnit)
		areaU = ""
		areaU2 = ""
		if strstr (areaUnit, "m") > 0 then
			areaU = "m"
			areaU2 = "2"
			if strstr (areaUnit, "cm") > 0 then areaU = "cm"
			if strstr (areaUnit, "mm") > 0 then areaU = "mm"
		else
			if strstr (areaUnit, "sqf") > 0 then areaU = "sq ft"
			if strstr (areaUnit, "sqi") > 0 then areaU = "sq inch"
		endif
		polyArea = 0
		for q = 1 to nc - 1
			idx = 2 * q - 1
			x1 = field_poly[1][idx]
			y1 = field_poly[1][idx + 1]
			x2 = field_poly[1][idx + 2]
			y2 = field_poly[1][idx + 3]
			polyArea = polyArea + (x2 + x1) * (y2 - y1)
		next q
		polyArea = abs (polyArea) / 2
		holeArea = 0
		for wo = 1 to nHoles
			for q = 1 to n_hpoly[wo] - 1
				idx = 2 * q - 1
				x1 = hole_poly[wo][idx]
				y1 = hole_poly[wo][idx + 1]
				x2 = hole_poly[wo][idx + 2]
				y2 = hole_poly[wo][idx + 3]
				holeArea = holeArea + (x2 + x1) * (y2 - y1)
			next q
		next wo
		holeArea = abs (holeArea) / 2
		polyArea = polyArea - holeArea
		n = n + 1
		txtData[n][1] = prfxArea + str (areaUnit, polyArea) + " " + areaU
		txtData[n][2] = areaU2
		style "area2"
		wFrm2 = stw (areaU2) * scal
		if SYMB_MIRRORED then
			dText = wFrm2 * ((1 - iAlignment) / 2)
		else
			dText = wFrm2 * ((1 - iAlignment) / 2 - 1)
		endif
	endif

!!! panel quantity
!!	if bTextPanelQty then
!!	endif

! accessories quantities
	if bTextAccType then
		dim nAcc[]
		for w = 1 TO dimx
			for q = 1 to dimy
				if accType[w][q] > 100 and (bInPoly[w][q] or bMoving) then
					grpAcc = int (accType[w][q] / 100)
					if grpAcc <> 3 then
						nAcc[grpAcc] = nAcc[grpAcc] + 1
					else
						for w3 =1 to vardim1 (stAccSafTypes)
							if accType[w][q] = stAccSafTypesID[w3] then nAcc[4 + w3] = nAcc[4 + w3] + 1
						next w3
					endif
				endif
			next q
		next w
		for w = 1 to vardim1 (nAcc)
			if nAcc[w] > 0 then
				n = n + 1
				txtPc = stPiece
				if nAcc[w] > 1 then txtPc = stPieces
				if w > 4 then
					txtData[n][1] = stAccSafTypes[w - 4] + ": " + str (nAcc[w], 1, 0) + " " + txtPc
				else
					txtData[n][1] = stAccTypes[w] + ": " + str (nAcc[w], 1, 0) + " " + txtPc
				endif
				txtData[n][2] = ""
			endif
		next w
	endif

! writing textblock content
	pen penText
	wFrm = 0
	style "textbox"
	for w = 1 to n
		ww = stw (txtData[w][1]) * scal
		if txtData[w][2] <> "" then ww = ww + wFrm2
		wFrm = max (wFrm, ww)
	next w
	add2 wFrm * bMoveTextBlock * iAlignment, 0
		for w = 1 to n
			style "textbox"
			add2 dText * (txtData[w][2] <> ""), ((n + 1) / 2 - w) * hStyl
				text2 0, 0, txtData[w][1]
				ww = stw (txtData[w][1]) * scal
				if txtData[w][2] <> "" then
					add2 ww * ((1 - iAlignment) / 2 - SYMB_MIRRORED), -sizFont * scal / 5
						style "area2"
						ww2 = stw (txtData[w][2]) * scal * SYMB_MIRRORED
						text2 -ww2, 0, txtData[w][2]
					del 1
				endif
			del 1
		next w
	del 1

	if n > 0 then
! --- Hotspots on bounding box of textblock ---
		add2 -(wFrm - dwFrm) * iAlignment / 2 + wFrm * bMoveTextBlock * iAlignment, 0
			unID = unID + 1 : hotspot2 -wFrm / 2, -hStyl * n / 2, unID
			unID = unID + 1 : hotspot2 -wFrm / 2, hStyl * n / 2, unID
			unID = unID + 1 : hotspot2 wFrm / 2, hStyl * n / 2, unID
			unID = unID + 1 : hotspot2 wFrm / 2, -hStyl * n / 2, unID
		del 1

! --- Frame, opaque ---
		drawindex 40
		dwFrm = 1 * scal
		wFrm = wFrm + dwFrm
		if (bOpaque or bFrame) and not(bMoving) then
			pen penFrame
			add2 -(wFrm - dwFrm) * iAlignment / 2 + wFrm * bMoveTextBlock * iAlignment, 0
				poly2_b 4, bFrame + 2 * bOpaque + 4,
					penOpaque, penOpaque,
					-wFrm / 2, -hStyl * n / 2, 1,
					-wFrm / 2, hStyl * n / 2, 1,
					wFrm / 2, hStyl * n / 2, 1,
					wFrm / 2, -hStyl * n / 2, 1
			del 1
		endif
		if bMoving then
			add2 -(wFrm + dwFrm) * iAlignment / 2 + wFrm * bMoveTextBlock * iAlignment, 0
				poly2_ 4, 5,
					-wFrm / 2, -hStyl * n / 2, 1,
					-wFrm / 2, hStyl * n / 2, 1,
					wFrm / 2, hStyl * n / 2, 1,
					wFrm / 2, -hStyl * n / 2, 1
			del 1
		endif
	endif
del 2

if n > 0 then
! --- Textbox moving ---
	unID = unID + 1 : hotspot2 posTextField[1][1], 0, unID, posTextField[1][2], 1 + 128
	unID = unID + 1 : hotspot2 posTextField[1][1], -0.1, unID, posTextField[1][2], 3
	unID = unID + 1 : hotspot2 posTextField[1][1], posTextField[1][2], unID, posTextField[1][2], 2
	unID = unID + 1 : hotspot2 0, posTextField[1][2], unID, posTextField[1][1], 1 + 128
	unID = unID + 1 : hotspot2 -0.1, posTextField[1][2], unID, posTextField[1][1], 3
	unID = unID + 1 : hotspot2 posTextField[1][1], posTextField[1][2], unID, posTextField[1][1], 2
! --- Textbox rotating ---
	if not(bHorizontalText) then
		rotlin = 1 * (1 - 2 * (iAlignment = 1))
		add2 posTextField[1][1], posTextField[1][2]
			unID = unID + 1 : hotspot2 0, 0, unID, rotTextField[1], 6 + 512 * SYMB_MIRRORED
			unID = unID + 1 : hotspot2 rotlin * COS (rotTextField[1]), rotlin * SIN (rotTextField[1]), unID, rotTextField[1], 5
			unID = unID + 1 : hotspot2 rotlin, 0, unID, rotTextField[1], 4
		del 1
	endif
endif


end

! ==================================================================================
! ==================================================================================
! ==================================================================================

50:
! *** rotated coordinates of holes ***
nsectpx = 0
nsectpy = 0
nsectpox = 0
for wo = 1 TO nHoles
	for q = 1 to n_hpoly[wo]
		idx = 2 * q - 1
		put hole_poly[wo][idx], hole_poly[wo][idx + 1], SGN (hole_poly_st[wo][q])
	next q
	nrpoly = n_hpoly[wo]
	rpoly = hole_poly
	rpoly_st = hole_poly_st[wo]
	gosub 200
	rotopng = rotcrds
	add2 fieldOrig[w0][1], fieldOrig[w0][2]
	rot2 alf
		npol = n_hpoly[wo]
		crds = rotopng
		viscod = -1
		gosub 1000			! line
		nsectpox = nsectpx
		sectpox = sectpx
	del 2
next wo
gosub 1250

add2 fieldOrig[w0][1], fieldOrig[w0][2]
rot2 alf
	viscod = 1
	npol = n_fpoly[w0]
	crds = rotcont
	gosub 1000			! line
	nsectp = nsectpx
	sectp = sectpx
	if nsectp > 0 then gosub 1300
	gosub 1200
del 2
return

! *********************************************************************
100:	! arrow
nyx = max (0.25, min (xSizCeiPanel, ySizCeiPanel) * 0.9)
nyy = nyx / 12
nyy2 = nyx / 6
pen penOriginFill
poly2_b 10, 7,
	penOriginFill, penOriginFill,
	0, nyy, 1,
	nyx - nyy2, nyy, 1,
	nyx - nyy2, nyy2, 1,
	nyx, 0, 1,
	nyx - nyy2, -nyy2, 1,
	nyx - nyy2, -nyy, 1,
	0, - nyy, 1,
	0, 0, 901,
	0, nyy, 1001,
	0, nyy, -1

return
101:	! graph. editing (arrow)
! moving
unID = 1000
unID = unID + 1 : hotspot2 fieldOrig[w0][1], 0, unID, fieldOrig[w0][2], 1+128
unID = unID + 1 : hotspot2 fieldOrig[w0][1], -0.1, unID, fieldOrig[w0][2], 3
unID = unID + 1 : hotspot2 fieldOrig[w0][1], fieldOrig[w0][2], unID, fieldOrig[w0][2], 2
unID = unID + 1 : hotspot2 0, fieldOrig[w0][2], unID, fieldOrig[w0][1], 1+128
unID = unID + 1 : hotspot2 -0.1, fieldOrig[w0][2], unID, fieldOrig[w0][1], 3
unID = unID + 1 : hotspot2 fieldOrig[w0][1], fieldOrig[w0][2], unID, fieldOrig[w0][1], 2
return
102:	! graph. editing (arrow)
! rotating
unID = 1100
unID = unID + 1 : hotspot2 0, 0, unID, fieldRot[w0], 6
unID = unID + 1 : hotspot2 nyx*COS (fieldRot[w0]), nyx*SIN (fieldRot[w0]), unID, fieldRot[w0], 5
unID = unID + 1 : hotspot2 nyx, 0, unID, fieldRot[w0], 4
unID = unID + 1 : hotspot2 nyx*COS (45), nyx*SIN (45), unID
unID = unID + 1 : hotspot2 0, nyx, unID
return

110:	! boundary rectangle
line_type "rotrect"
rot2 90 * (2 - qx)
	poly2 4, 5,
		rtxmin, rtymin,
		rtxmax, rtymin,
		rtxmax, rtymax,
		rtxmin, rtymax
del 1
line_type 1
return

! *****************************
! intersection point edits
1000:
if viscod > 0 then nsectpx = 0
for w = 1 to npol - 1
	x1 = crds[w][1]
	y1 = crds[w][2]
	x2 = crds[w + 1][1]
	y2 = crds[w + 1][2]
	dx = x2 - x1
	dy = y2 - y1
	scp = 0
	if abs (yy-y1) < eps then
		xa = x1
		ya = y1
		scp = 1
	else
		if abs (yy - y2) > eps then
			if abs (abs (yy - y1) + abs (yy - y2) - abs (dy)) < eps then
				xa = x1 + dx / dy * (yy - y1)
				ya = yy
				scp = 2
			endif
		endif
	endif
	if scp = 1 then
		prevind = (w - 1) * (w > 1) + (npol - 1) * (w = 1)
		prevy = crds[prevind][2]
		if sgn (prevy - yy) * sgn (y2 - yy) <> -1 then scp = 0
	endif
	if scp > 0 then
		nsectpx = nsectpx + 1
		sectpx[nsectpx][1] = xa
		sectpx[nsectpx][2] = ya
		sectpx[nsectpx][3] = viscod
	endif
next w
! Sort intersections (based on x)
for ws = 1 to nsectpx * (viscod > 0)
	for ws2 = ws + 1 to nsectpx
		if sectpx[ws][1] > sectpx[ws2][1] then
			qq = sectpx[ws2][1]
			sectpx[ws2][1] = sectpx[ws][1]
			sectpx[ws][1] = qq
		endif
	next ws2
next ws
return

1200:				! drawing sections
pen penGrid
if qx = 1 and bShowGridY or qx = 2 and bShowGridX or bMoving then
	if qx = 1 then iET = iEdgeTypeY
	if qx = 2 then iET = iEdgeTypeX
	if iET < 3 then line_type ltEdgeType1
	if iET = 3 then line_type ltEdgeType2
	if iET = 4 then line_type ltEdgeType3
	for w = 1 to nsectp - 1 step 2
		hotline2 sectp[w][1], sectp[w][2], sectp[w + 1][1], sectp[w + 1][2]
		hotspot2 sectp[w][1], sectp[w][2]
		hotspot2 sectp[w + 1][1], sectp[w + 1][2]
		line2 sectp[w][1], sectp[w][2], sectp[w + 1][1], sectp[w + 1][2]
	next w
endif
return

1250:				! polygons per hole sections concatenation
! Sorting (based on x)
for ws = 1 to nsectpox
	for ws2 = ws + 1 to nsectpox
		if sectpox[ws][1] > sectpox[ws2][1] then
			qq = sectpox[ws2][1]
			sectpox[ws2][1] = sectpox[ws][1]
			sectpox[ws][1] = qq
			qq = sectpox[ws2][3]
			sectpox[ws2][3] = sectpox[ws][3]
			sectpox[ws][3] = qq
		endif
	next ws2
next ws
for w = 1 to nsectpox step 2
	sectpox[w][3] = 1
	sectpox[w+1][3] = -1
next w
! filtering
sumvis = 0
visind = 0
vis0 = 0
for ws = 1 to nsectpox
	sumvis = sumvis + sectpox[ws][3]
	if (sumvis = 1 and vis0 = 0) OR sumvis = 0 then
		visind = visind + 1
		sectpox[visind][1] = sectpox[ws][1]
		sectpox[visind][2] = sectpox[ws][2]
		sectpox[visind][3] = -1
	endif
	vis0 = sumvis
next ws
nsectpox = visind * (visind > 1)
return

1300:				! determine the visibility of the lines
! Section ends statuses
for w = 1 to nsectp step 2
	sectp[w][3] = 1
	sectp[w+1][3] = -1
next w
for w = 1 to nsectpox step 2
	sectpox[w][3] = -1
	sectpox[w+1][3] = 1
next w
maxx = sectp[nsectp][1]
! adding up the points array
for w = 1 to nsectpox
	sectp[nsectp+w][1] = sectpox[w][1]
	sectp[nsectp+w][2] = sectpox[w][2]
	sectp[nsectp+w][3] = sectpox[w][3]
next w
nsectp = nsectp + nsectpox
! Sorting
for ws = 1 to nsectp
	for ws2 = ws + 1 to nsectp
		if sectp[ws][1] > sectp[ws2][1] then
			qq = sectp[ws2][1]
			sectp[ws2][1] = sectp[ws][1]
			sectp[ws][1] = qq
			qq = sectp[ws2][3]
			sectp[ws2][3] = sectp[ws][3]
			sectp[ws][3] = qq
		endif
	next ws2
next ws
! filtering
sumvis = 0
visind = 0
vis0 = 0
vis1 = 0
for ws = 1 to nsectp
	sumvis = sumvis+sectp[ws][3]
	if ((sumvis = 1 and vis0 = 0) or (sumvis = 0 and vis1 = 1)) and sectp[visind + 1][1] < maxx + eps then
		visind = visind + 1
		sectp[visind][1] = sectp[ws][1]
		sectp[visind][2] = sectp[ws][2]
		sectp[visind][3] = -1
		vis1 = 1 - vis1
	endif
	vis0 = sumvis
next ws
nsectp = visind * (visind > 1)
return

! ===================================================================================
! ============ A C C E S S O R I E S ================================================
! ===================================================================================
! --- ventilation ---
10101:
	pen penAccVent
	thk = 0.03 		! Panel thickness
	tLem = 0.005 	! Plate thickness
	wPer = 0.04  	! Rim width
	numLem = 6   	! Plate number
	alfa = 25    	! Plate angle
	beta = 45

	dim edgeWidthX[]
	for i = 1 to numLem
		edgeWidthX[i] = i * (yCp - 2 * wPer - 2 * (tLem + thk/TAN(alfa))) / numLem
	next I
	dim edgeWidthY[6]
	for i = 1 to numLem
		edgeWidthY[i] = i * (xCp - 2 * wPer - 2 * (tLem + thk/TAN(alfa))) / numLem
	next I

	rect2 -xCp/2, -yCp/2, xCp/2, yCp/2
	rect2 -xCp/2 + wPer, -yCp/2 + wPer, xCp/2 - wPer, yCp/2 - wPer
	for i = 1 to numLem - 1
		rect2 -edgeWidthY[i]/2 - thk/TAN(alfa), -edgeWidthX[i]/2 - thk/TAN(alfa), edgeWidthY[i]/2 + thk/TAN(alfa), edgeWidthX[i]/2 + thk/TAN(alfa)
	next i
return

10102:
	pen penAccVent
	thk = 0.03   	! Panel thickness
	tLem = 0.005 	! Plate thickness
	wPer = 0.06 	! Rim width
	alfa = 18    	! Plate angle
	numLem = 8   	! Plate number

	dim distX[]
	for i = 1 to numLem
		distX[i] = i * (yCp - 2 * wPer) / numLem
	next I

	rect2 -xCp/2, -yCp/2, xCp/2, yCp/2
	rect2 -xCp/2 + wPer, -yCp/2 + wPer, xCp/2 - wPer, yCp/2 - wPer

	for i = 1 to numLem
		add2 0, -(yCp - 2*wPer) / 2 + distX[i] - distX[1]
		line2 -(xCp - 2*wPer) / 2, 0, (xCp - 2*wPer) / 2, 0
		del 1
	next i
return

10111:
	pen penAccVent
	xVen = min (xCP, yCP, 0.25)  	! Width

	rect2 -xVen/2, -xVen/2, xVen/2, xVen/2

	for i = 1 to 5
		circle2 0, 0, (0.9 - i * 0.15) * xVen / 2
	next i
return

10112:
	pen penAccVent
	rVent = min (xCP / 2, yCP / 2, 0.15)  		! radius

	circle2 0, 0, rVent
	circle2 0, 0, rVent - 0.03
	circle2 0, 0, rVent - 0.07
return

10121:
	pen penAccVent
	r2 = max (min (xSizCeiPanel, ySizCeiPanel) * 0.90, 0.25) / 2
	r1= r2 * 0.3
	for wv = 0 to 11
		rot2 wv * 30
			line2 0, r1, 0, r2
		del 1
	next wv
return


! --- lighting ---
10201:
	pen penAccLig
	rr = max (min (xSizCeiPanel, ySizCeiPanel) / 2, 0.20)
102010:
	circle2 0, 0, rr / 2
	rot2 45
		line2 -rr / 2, 0, rr / 2, 0
		line2 0, -rr / 2, 0, rr / 2
	del 1
return

10202:
	pen penAccLig
	xy = max (min (xSizCeiPanel, ySizCeiPanel) / 2, 0.20)
	rect2 -xy / 2, -xy / 2, xy / 2, xy / 2
	line2 -xy / 2, -xy / 2, xy / 2, xy / 2
	line2 -xy / 2, xy / 2, xy / 2, -xy / 2
return

10203:
	pen penAccLig
	rect2 -xCP / 2, -yCP / 2, xCP / 2, yCP / 2
	line2 -xCP / 2, -yCP / 2, xCP / 2, yCP / 2
	line2 -xCP / 2, yCP / 2, xCP / 2, -yCP / 2
return

10204:
	pen penAccLig
	rr = max (min (xSizCeiPanel, ySizCeiPanel) / 2, 0.30)
	circle2 0, 0, rr / 2
	circle2 0, 0, rr / 2 - 0.01
	rr = rr -0.05
	rot2 45
		line2 -rr / 2, 0, rr / 2, 0
		line2 0, -rr / 2, 0, rr / 2
	del 1
return

10211:
	pen penAccLig
	pen penAccLig
	rr = max (min (xSizCeiPanel, ySizCeiPanel) / 3, 0.15)
	add2 -xCP / 4, -yCP / 4
		gosub 102010
	del 1
	add2 xCP / 4, yCP / 4
		gosub 102010
	del 1
return

10221:
	pen penAccLig
102210:
	rr = max (min (xSizCeiPanel, ySizCeiPanel) / 6, 0.10)
	circle2 0, 0, rr / 2
	circle2 0, 0, rr / 3
	rot2 45
		line2 -rr / 3, 0, rr / 3, 0
		line2 0, -rr / 3, 0, rr / 3
	del 1
return

10222:
	pen penAccLig
	add2 -xCP / 4, 0
		gosub 102210
	del 1
	add2 xCP / 4, 0
		gosub 102210
	del 1
return

10223:
	pen penAccLig
	add2 -xCP / 4, -yCP / 4
		gosub 102210
	del 1
	add2 xCP / 4, -yCP / 4
		gosub 102210
	del 1
	add2 0, yCP / 4
		gosub 102210
	del 1
return

10224:
	pen penAccLig
	add2 -xCP / 4, -yCP / 4
		gosub 102210
	del 1
	add2 xCP / 4, -yCP / 4
		gosub 102210
	del 1
	add2 -xCP / 4, yCP / 4
		gosub 102210
	del 1
	add2 xCP / 4, yCP / 4
		gosub 102210
	del 1
return

10226:
	pen penAccLig
	add2 -xCP / 3, -yCP / 4
		gosub 102210
	del 1
	add2 -xCP / 3, yCP / 4
		gosub 102210
	del 1
	add2 0, -yCP / 4
		gosub 102210
	del 1
	add2 0, yCP / 4
		gosub 102210
	del 1
	add2 xCP / 3, -yCP / 4
		gosub 102210
	del 1
	add2 xCP / 3, yCP / 4
		gosub 102210
	del 1
return

10231:
	pen penAccLig
	xCP = xCP - 0.04
	wv = min (yCP / 4, 0.15)
	dwv = 0.02
	rect2 -xCP / 2, -wv / 2, xCP / 2, wv / 2
	rect2 -xCP / 2 + dwv, -wv / 2 + dwv, xCP / 2 - dwv, wv / 2 - dwv
	line2 -xCP / 2 + dwv, -wv / 2 + dwv, xCP / 2 - dwv, wv / 2 - dwv
	line2 -xCP / 2 + dwv, wv / 2 - dwv, xCP / 2 - dwv, -wv / 2 + dwv
return

10236:
	pen penAccLig
	xCP = xCP - 0.04
	wv = yCP - 0.04
	dwv = 0.02
	rect2 -xCP / 2, -wv / 2, xCP / 2, wv / 2
	rect2 -xCP / 2 + dwv, -wv / 2 + dwv, xCP / 2 - dwv, wv / 2 - dwv
	line2 -xCP / 2 + dwv, -wv / 2 + dwv, xCP / 2 - dwv, wv / 2 - dwv
	line2 -xCP / 2 + dwv, wv / 2 - dwv, xCP / 2 - dwv, -wv / 2 + dwv
return


! --- safety ---
10301:
	pen penAccSaf
	circle2 0, 0, 0.04
	for ws = 0 to 11
		rot2 ws * 30
			line2 0, 0.05, 0, 0.06
		del 1
	next ws
return

10302:
	pen penAccSaf
	r1 = 0.06
	r2 = 0.04
	circle2 0, 0, r1
	circle2 0, 0, r2
return

10303:
	pen penAccSaf
	r1 = 0.06
	r2 = 0.025
	circle2 0, 0, r1
!	circle2 0, 0, r2
	for wa = 1 to 8
		rot2 wa * 45
			line2 r1, 0, r2, 0
		del 1
	next wa
return

10311:
	pen penAccSaf
	rr = max (min (xSizCeiPanel, ySizCeiPanel) / 2, 0.20)
	ii = rr / 3
	circle2 0, 0, rr / 2
	rect2 -ii, ii / 2, ii / 2, -ii / 2
	rect2 -ii / 2, ii / 2, ii / 4, ii  / 2 + ii / 6
	poly2 4, 1,
		ii / 2, ii / 6,
		ii, ii / 2,
		ii, -ii / 2,
		ii / 2, -ii / 6
return


! --- audio ---
10401:
	pen penAccAud
	rr = max (min (xSizCeiPanel, ySizCeiPanel) / 2, 0.20)
	circle2 0, 0, rr / 2
104010:
	xx = rr / 4
	add2 -xx / 4, 0
		rect2 -xx, xx / 2, 0, -xx / 2
		poly2 4, 1,
			0, xx / 2,
			xx, xx * 3 / 2,
			xx, -xx * 3 / 2,
			0, -xx / 2
	del 1
return

10402:
	pen penAccAud
	xy = max (min (xSizCeiPanel, ySizCeiPanel) / 2, 0.20)
	rect2 -xy / 2, -xy / 2, xy / 2, xy / 2
	rr = xy
	goto 104010
return

10403:
	pen penAccAud
!	xy = max (min (xSizCeiPanel, ySizCeiPanel) * 0.80, 0.20)
	rr = max (min (xSizCeiPanel, ySizCeiPanel) / 4, 0.10)
!	line2 -xy / 2, xy / 2, -xy / 10, xy / 10
!	line2 -xy / 2, -xy / 2, -xy / 10, -xy / 10
!	line2 xy / 2, xy / 2, xy / 10, xy / 10
!	line2 xy / 2, -xy / 2, xy / 10, -xy / 10
	circle2 -rr, 0, rr / 2
	circle2 rr, 0, rr / 2
	circle2 0, -rr, rr / 2
	circle2 0, rr, rr / 2
	rr = rr * 1.2
	goto 104010
return

! ===================================================================================
! ============ P A T T E R N S ======================================================
! ===================================================================================
19990:	! empty panel
	xyCP = sqr (xCP ^ 2 + yCP ^ 2)
	dash1 = 0.03
	nL = round_int ((xyCP - dash1) / 0.10)
	dash2 = (xyCP - dash1) / nL - dash1
	add2 -xCP / 2, -yCP / 2
	rot2 atn (yCP / xCP)
		for wp = 0 to nL
			line2 wp * (dash1 + dash2), 0, wp * (dash1 + dash2) + dash1, 0
		next wp
	del 2
	add2 -xCP / 2, yCP / 2
	rot2 -atn (yCP / xCP)
		for wp = 0 to nL
			line2 wp * (dash1 + dash2), 0, wp * (dash1 + dash2) + dash1, 0
		next wp
	del 2
return

20000:
return

21000:
return

21010:
	s0 = 0.03
	xx = xCP / 2 - s0
	yy = yCP / 2 - s0
	rot2 panelRot[w][q]
		rect2 -xx, -yy, xx, yy
	del 1
return

21020:
	s0 = 0.03
	xx = xCP / 4
	yy = yCP / 4
	rot2 panelRot[w][q]
		rect2 -xx, -yy, xx, yy
	del 1
return

21120:
	s0 = 0.03
	xx = xCP / 2 - s0
	yy = yCP / 2 - s0
	xx2 = xx - s0
	yy2 = yy - s0
	xx3 = xx2 - 2 * s0
	yy3 = yy2 - 2 * s0
	rot2 panelRot[w][q]
		rect2 -xx, -yy, xx, yy
		rect2 -xx2, -yy2, xx2, yy2
		rect2 -xx3, -yy3, xx3, yy3
	del 1
return

21210:
bitSegm = 1
goto 212100

21220:
bitSegm = 1 + 4
goto 212100

21240:
bitSegm = 1 + 2 + 4 + 8
goto 212100

21250:
bitSegm = 1 + 8
goto 212100

212100:
	s0 = 0.03
	xx = xCP / 2 - s0
	yy = yCP / 2 - s0
	for wp = 0 to 3
		if bittest (bitSegm, wp) then
			rot2 wp * 90 + panelRot[w][q]
			add2 xCP / 2 * (wp mod 2 = 0) + yCP / 2 * (wp mod 2 = 1), xCP / 2 * (wp mod 2 = 1) + yCP / 2 * (wp mod 2 = 0)
				rect2 -xx, -yy, -s0, -s0
			del 2
		endif
		qq = xx
		xx = yy
		yy = qq
	next wp
return

22020:
	s0 = 0.03
	xx = xCP / 2 - s0
	yy = yCP / 2 - s0
	xx3 = xx - 3 * s0
	yy3 = yy - 3 * s0
	rr3 = min (xx3, yy3)
	rot2 panelRot[w][q]
		if rr3 > thkCeiPanel / 2 + eps then
			circle2 0, 0, rr3
		endif
	del 1
return

22120:
	s0 = 0.03
	xx = xCP / 2 - s0
	yy = yCP / 2 - s0
	xx2 = xx - s0
	yy2 = yy - s0
	xx3 = xx2 - 2 * s0
	yy3 = yy2 - 2 * s0
	rr3 = min (xx3, yy3)
	rot2 panelRot[w][q]
		rect2 -xx, -yy, xx, yy
		rect2 -xx2, -yy2, xx2, yy2
		if rr3 > thkCeiPanel / 2 + eps then
			circle2 0, 0, rr3
		endif
	del 1
return

22210:
bitSegm = 1
goto 222100

22220:
bitSegm = 1 + 4
goto 222100

22240:
bitSegm = 1 + 2 + 4 + 8
goto 222100

22250:
bitSegm = 1 + 8
goto 222100

222100:
	s0 = 0.03
	xx = xCP / 2 - s0
	yy = yCP / 2 - s0
	rr3 = min (xx, yy)
	for wp = 0 to 3
		if bittest (bitSegm, wp) then
			rot2 wp * 90 + panelRot[w][q]
			add2 xCP / 2 * (wp mod 2 = 0) + yCP / 2 * (wp mod 2 = 1), xCP / 2 * (wp mod 2 = 1) + yCP / 2 * (wp mod 2 = 0)
				if rr3 > thkCeiPanel / 2 + eps then
					arc2 0, 0, rr3, 180, 270
				endif
			del 2
		endif
	next wp
return

28010:
s0 = 0.025
rPerf = 0.010 / 2
dPerf = 0.030
npx = round_int ((xCP - 2 * s0) / dPerf)
npy = round_int ((yCP - 2 * s0) / dPerf)
dPerfx = (xCP - 2 * s0) / npx
dPerfy = (yCP - 2 * s0) / npy
rot2 panelRot[w][q]
	for wpx = 0 to npx
		dpx =  -xCP / 2 + s0 + wpx * dPerfx
		for wpy = 0 to npy
			dpy =  -yCP / 2 + s0 + wpy * dPerfy
			circle2 dpx, dpy, rPerf
		next wpy
	next wpx
del 1
return

28110:
s0 = 0.025
rPerf = 0.010 / 2
dPerf = 0.030
npx = round_int ((xCP - 2 * s0) / dPerf)
npy = round_int ((yCP - 2 * s0) / dPerf)
dPerfx = (xCP - 2 * s0) / npx
dPerfy = (yCP - 2 * s0) / npy
rot2 panelRot[w][q]
	for wpx = 0 to npx
		dpx =  -xCP / 2 + s0 + wpx * dPerfx
		for wpy = 0 to npy / 3
			dpy =  -yCP / 2 + s0 + wpy * dPerfy
			circle2 dpx, dpy, rPerf
		next wpy
		for wpy = ceil (npy * 2 / 3) to npy
			dpy =  -yCP / 2 + s0 + wpy * dPerfy
			circle2 dpx, dpy, rPerf
		next wpy
	next wpx
del 1
return

28210:
s0 = 0.020
nsx = round_int (xCP / 0.15)
nsy = round_int (yCP / 0.15)
xs = xCP / nsx - 2 * s0
ys = yCP / nsy - 2 * s0
ds = ys / 11
rot2 panelRot[w][q]
	for wpy = 0 to nsy - 1
		for wpx = 0 to nsx - 1
		dpx = -xCP / 2 + wpx * (2 * s0 + xs) + s0
		dpy = -yCP / 2 + wpy * (2 * s0 + ys) + s0 + ds / 2
			for qp = 0 to 5
				add2 dpx, dpy + qp * 2 * ds
					line2 0, 0, xs, 0
				del 1
			next qp
		next wpx
	next wpy
del 1
return

! ===================================================================================
! ============ T O O L B O X   I C O N S ============================================
! ===================================================================================
! --- ventilation ---
80101:
	pen penAccVent
	nt = 8
	for wt = 2 to nt - 1
		rect2 -wt / nt / 2, -wt / nt / 2, wt / nt / 2, wt / nt / 2
	next wt
return

80102:
	pen penAccVent
	rect2 -0.45, -0.45, 0.45, 0.45
	rect2 -0.40, -0.40, 0.40, 0.40
	nt = 8
	for wt = 1 to nt - 1
		line2 -0.40, -0.40 + wt * 0.80 / nt, 0.40, -0.40 + wt * 0.80 / nt
	next wt
return

80111:
	pen penAccVent
	nt = 8
	for wt = 2 to nt - 1
		circle2 0, 0, wt / nt / 2
	next wt
return

80112:
	pen penAccVent
	circle2 0, 0, 0.30
	circle2 0, 0, 0.24
	circle2 0, 0, 0.16
return

80121:
	pen penAccVent
	for wt = 0 to 11
		rot2 wt * 30
			line2 0.15, 0, 0.45, 0
		del 1
	next wt
return


! --- lighting ---
80201:
	pen penAccLig
	r = 0.3
802010:
	circle2 0, 0, r
	rot2 45
		line2 -r, 0, r, 0
		line2 0, -r, 0, r
	del 1
return

80202:
	pen penAccLig
	rect2 -0.25, -0.25, 0.25, 0.25
	line2 -0.25, -0.25, 0.25, 0.25
	line2 -0.25, 0.25, 0.25, -0.25
return

80203:
	pen penAccLig
	rect2 -0.45, -0.45, 0.45, 0.45
	line2 -0.45, -0.45, 0.45, 0.45
	line2 -0.45, 0.45, 0.45, -0.45
return

80204:
	pen penAccLig
	r1 = 0.30
	r2 = 0.28
	r3 = 0.17
	circle2 0, 0, r1
	circle2 0, 0, r2
	line2 -r3, -r3, r3, r3
	line2 -r3, r3, r3, -r3
return

80211:
	pen penAccLig
	r = 0.20
	add2 -0.25, -0.25
		gosub 802010
	del 1
	add2 0.25, 0.25
		gosub 802010
	del 1
return

80221:
	pen penAccLig
	r1 = 0.10
	r2 = 0.08
	circle2 0, 0, r1
	circle2 0, 0, r2
	rot2 45
		line2 -r2, 0, r2, 0
		line2 0, -r2, 0, r2
	del 1
return

80222:
	add2 -0.25, 0
		gosub 80221
	del 1
	add2 0.25, 0
		gosub 80221
	del 1
return

80223:
	add2 -0.25, -0.25
		gosub 80221
	del 1
	add2 0.25, -0.25
		gosub 80221
	del 1
	add2 0, 0.25
		gosub 80221
	del 1
return

80224:
	add2 -0.25, -0.25
		gosub 80221
	del 1
	add2 0.25, -0.25
		gosub 80221
	del 1
	add2 -0.25, 0.25
		gosub 80221
	del 1
	add2 0.25, 0.25
		gosub 80221
	del 1
return

80226:
	add2 -0.35, -0.25
		gosub 80221
	del 1
	add2 0, -0.25
		gosub 80221
	del 1
	add2 0.35, -0.25
		gosub 80221
	del 1
	add2 -0.35, 0.25
		gosub 80221
	del 1
	add2 0, 0.25
		gosub 80221
	del 1
	add2 0.35, 0.25
		gosub 80221
	del 1
return

80231:
	pen penAccLig
	rect2 -0.45, -0.20, 0.45, 0.20
	rect2 -0.42, -0.17, 0.42, 0.17
	line2 -0.35, 0.00, 0.35, 0.00
return

80236:
	pen penAccLig
	rect2 -0.45, -0.45, 0.45, 0.45
	rect2 -0.42, -0.42, 0.42, 0.42
	line2 -0.35, 0.22, 0.35, 0.22
	line2 -0.35, 0.00, 0.35, 0.00
	line2 -0.35, -0.22, 0.35, -0.22
return


! --- safety ---
80301:
	pen penAccSaf
	circle2 0, 0, 0.05
	circle2 0, 0, 0.20
	for wt = 0 to 11
		rot2 wt * 30
			line2 0.25, 0, 0.30, 0
		del 1
	next wt
return

80302:
	pen penAccSaf
	circle2 0, 0, 0.15
	circle2 0, 0, 0.20
return

80303:
	pen penAccSaf
	r1 = 0.18
	r2 = 0.13
	circle2 0, 0, r1
!	circle2 0, 0, r2
	for wa = 1 to 8
		rot2 wa * 45
			line2 r1, 0, r2, 0
		del 1
	next wa
return

80311:
	pen penAccSaf
	rr = 0.4
	ii = rr * 0.6
	circle2 0, 0, rr
	rect2 -ii, ii / 2, ii / 2, -ii / 2
	rect2 -ii / 2, ii / 2, ii / 4, ii  / 2 + ii / 6
	poly2 4, 1,
		ii / 2, ii / 6,
		ii, ii / 2,
		ii, -ii / 2,
		ii / 2, -ii / 6
return


! --- audio ---
80401:
	pen penAccAud
	rr = 0.3
	circle2 0, 0, rr
	xx = rr / 3
804010:
	add2 -xx / 4, 0
		rect2 -xx, xx / 2, 0, -xx / 2
		poly2 4, 1,
			0, xx / 2,
			xx, xx * 3 / 2,
			xx, -xx * 3 / 2,
			0, -xx / 2
	del 1
return

80402:
	pen penAccAud
	rect2 -0.30, -0.30, 0.30, 0.30
	xx = 0.10
	goto 804010
return

80403:
	pen penAccAud
	rr = 0.25
	circle2 -rr, 0, rr / 2
	circle2 rr, 0, rr / 2
	circle2 0, -rr, rr / 2
	circle2 0, rr, rr / 2
	rr = rr * 1.2
	xx = 0.08
	goto 804010
return

! ---------------------------------
90010:
	pen penAccpalette
	line2 0, -0.45, 0, -0.35
	line2 0, -0.25, 0, 0.45
	pen penRed
	add2 0, -0.1
	mul2 1, 0.6
		poly2_b 15, 7, 
			penRed, penRed,
			-0.303, 0.175, 1, 
			0, 0, 900, 
			0, 180, 4001, 
			0.303, -0.175, 1, 
			0, 90, 4001, 
			0.175, 0.303, 1, 
			0.208, 0.360, 1, 
			0.084, 0.327, 1, 
			0.117, 0.203, 1, 
			0.15, 0.260, 1, 
			0, -90, 4001, 
			0.260, -0.15, 1, 
			0, -180, 4001, 
			-0.260, 0.15, 1, 
			-0.303, 0.175, 1
	del 2
return

90020:
	pen penAccpalette
	line2 0, -0.45, 0, 0.45
	pen penRed
	add2 0, -0.1
	mul2 1, 0.6
		poly2_b 8, 7, 
			penRed, penRed,
			-0.303, -0.175, 1, 
			-0.260, -0.15, 1, 
			0, 0, 900, 
			0, -113.3002345225, 4001, 
			-0.035, 0.298, 1, 
			-0.035, 0.348, 1, 
			0, 114.2608298842, 4001, 
			-0.303, -0.175, 1
		poly2_b 15, 7, 
			penRed, penRed,
			0.035, 0.348, 1, 
			0.035, 0.298, 1, 
			0, 0, 900, 
			0, -53.30023472325, 4001, 
			0.260, 0.15, 1, 
			0, -90, 4001, 
			0.15, -0.260, 1, 
			0.117, -0.203, 1, 
			0.084, -0.327, 1, 
			0.208, -0.360, 1, 
			0.175, -0.303, 1, 
			0, 90, 4001, 
			0.303, 0.175, 1, 
			0, 54.26082964241, 4001, 
			0.035, 0.348, 1
	del 2
return

90030:
pen penRed
fill fillTBframe
poly2_b 21, 7, 
		penRed, penRed,
        -0.003, 0.009, 1, 
        0.134, -0.131, 1, 
        0.239, -0.303, 1, 
        0.295, -0.300, 1, 
        0.166, -0.100, 1, 
        0.0268, 0.039, 1, 
        0.134, 0.148, 1, 
        0.300, 0.259, 1, 
        0.300, 0.300, 1, 
        0.107, 0.178, 1, 
        -0.003, 0.068, 1, 
        -0.112, 0.178, 1, 
        -0.305, 0.300, 1, 
        -0.305, 0.259, 1, 
        -0.139, 0.149, 1, 
        -0.032, 0.039, 1, 
        -0.171, -0.100, 1, 
        -0.300, -0.300, 1, 
        -0.245, -0.303, 1, 
        -0.139, -0.131, 1, 
        -0.003, 0.009, 1
return

90110:
	gosub 90010
901100:
	pen penPattSymbol
	poly2 4, 5,
		0.20, 0.45,
		0.45, 0.25,
		-0.20, 0.15,
		-0.45, 0.35
return

90120:
	gosub 90020
	gosub 901100
return

90130:
	gosub 90030
	gosub 901100
return

