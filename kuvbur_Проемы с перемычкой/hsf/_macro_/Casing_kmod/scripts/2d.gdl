
! Contact person: <NJ>

! ==============================================================================
! This macro draws the Casing
! ------------------------------------------------------------------------------
! Input parameters:
! Geometry ---------------------------------------------------------------------
!	A:						wallhole width (length) (Obsolete)
!	refWidth:				reference width in curved walls (length)
!	leftWidth:				wallhole's side distance from the origin at the left side (length)
!	rightWidth:				wallhole's side distance from the origin at the right side (length)
! Functions --------------------------------------------------------------------
!	gs_IsCurved:			Does the window follow the curvature of the wall? (0 / 1)
!	bParalellInCurvedWalls:	is the wallhole parallel in curved walls (0 / 1)
!	bShowEdgeHotspots:		Show hotspots at jamb extensions inner edge - CHE request (0 / 1)
! Reveal -----------------------------------------------------------------------
!	iRevealType:
!	gs_reveal_left_angle:
!	gs_reveal_right_angle:
! Corner Function --------------------------------------------------------------
!	bLeftCornerFunction:		Turn macro in Corner Window mode at the left side (0 / 1)
!	leftCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	leftConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
!	bRightCornerFunction:	Turn macro in Corner Window mode at the right side (0 / 1)
!	rightCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	rightConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
! Oversize ---------------------------------------------------------------------
!	gs_left_oversize:		Left opening oversize (length)
!	gs_right_oversize:		Right opening oversize (length)
! Casing -----------------------------------------------------------------------
!	gs_trim_inside:
!	gs_trim_outside:
!	gs_trim_width_in:		Width of inside Trim. (length)
!	gs_trim_width_out:		Width of outside Trim. (length)
!	gs_trim_offs_in:		Offset of Casing inside. (length)
!	gs_trim_offs_out:		Offset of Casing outside. (length)
!	gs_trim_thk_in:			Thickness of inside Trim. (length)
!	gs_trim_thk_out:		Thickness of outside Trim. (length)
!	gs_tw_left_in:			Width of inside casing on the left (length)
!	gs_tw_right_in:			Width of inside casing on the right (length)
!	gs_tw_left_out:			Width of outside casing on the left (length)
!	gs_tw_right_out:		Width of outside casing on the right (length)
! Sill -------------------------------------------------------------------------
!	bWindowSymbolAtMiddle:	Is the window symbol appears always on the middle of the wall (CHI special) (0 / 1)
! 2D Representation ------------------------------------------------------------
!	lod2D_Casing:			Level of detail. (integer, 0..1)
!	gs_pen_2D:				Cotour pen of the Trim, Sill and Board. (pen)
!	gs_trim_pen_cont:		Cotour pen of the cutted Trim.
!								If it is zero then gs_pen_2D defines the cutted contour pen. (pen)
!	gs_bFills:				Use fills (boolean)
!	gs_wallhole_fill:		Type of the fill on the Sill and Board. (fill type)
!	gs_wallhole_pen_fg:		Fill pen on the Sill and Board. (pen)
!	gs_wallhole_pen_bg:		Fill background pen on the Sill and Board. (pen)
!	gs_trim_fill_in:		Type of the fill on the inside Trim. (fill type)
!	gs_trim_pen_fg_in:		Fill pen on the inside Trim. (pen)
!	gs_trim_pen_bg_in:		Fill background pen on the inside Trim. (pen)
!	gs_trim_fill_out:		Type of the fill on the outside Trim. (fill type)
!	gs_trim_pen_fg_out:		Fill pen on the outside Trim. (pen)
!	gs_trim_pen_bg_out:		Fill background pen on the outside Trim. (pen)
! Ganging ----------------------------------------------------------------------
!	gs_stack_left:			Align to door/window on left side (0 / 1)
!	gs_stack_right:			Align to door/window on right side (0 / 1)
!	gs_stack_bottom:		Align to door/window on bottom side (0 / 1)
!
! Related Global Variables:
!	GLOB_SCRIPT_TYPE
!	GLOB_CONTEXT
!	WALL_THICKNESS
!	WALL_INCL
!	WALL_SECT_PEN
!	WIDO_FRAME_THICKNESS
!	WIDO_SILL
!	WIDO_ORIG_DIST
!	WIDO_REVEAL_SIDE
!	SYMB_MIRRORED
!	SYMB_ROTANGLE
!
! Hotspot IDs:
!	10010:		Outside Trim's left inner
!	10011:		Outside Trim's right inner
!	10012:		Inside Trim's left inner
!	10013:		Inside Trim's right inner
!
!	10020:		Outside Wall Contour left
!	10021:		Outside Wall Contour right
!	10022:		Inside Wall Contour left
!	10023:		Inside Wall Contour right
!
!	10030:		Outside Trim's left outer
!	10031:		Outside Trim's right outer
!	10032:		Inside Trim's left outer
!	10033:		Inside Trim's right outer
! ==============================================================================


! ==============================================================================
! Showing then unID's of hotspots
!
!
! ==============================================================================


if lod2D_Casing = 0 then end
if (bInsideCasingNotAvailableByReveal |\
	bInsideCasingNotAvailableByWallType |\
	bInsideCasingNotAvailableByFrameStyle) then
	bDrawInsideTrim  = 0
endif
if (bOutsideCasingNotAvailableByReveal |\
	bOutsideCasingNotAvailableByFrameStyle) then
	bDrawOutsideTrim = 0
endif
if not(bDrawInsideTrim | bDrawOutsideTrim) then end

! Save the current parameter buffer ============================================

dim savedQueueValues[]
call "SaveQueue_kmod" parameters returned_parameters savedQueueValues


if gs_trim_wallhole_pen_fg_in <= 0 then
	gs_trim_bFills_in			= gs_bFills
	gs_trim_wallhole_pen_fg_in	= gs_wallhole_pen_fg
	gs_trim_wallhole_pen_bg_in	= gs_wallhole_pen_bg

	gs_trim_wallhole_pen_sl_fg_in	= gs_wallhole_pen_sl_fg
	gs_trim_wallhole_pen_sl_bg_in	= gs_wallhole_pen_sl_bg
endif
if bPShapedLeftOpening | bPShapedRightOpening then
	gs_trim_wallhole_fill_in		= gs_wallhole_fill_sl
else
	gs_trim_wallhole_fill_in		= gs_wallhole_fill
endif

if gs_trim_wallhole_pen_fg_out <= 0 then
	gs_trim_bFills_out			= gs_bFills
	gs_trim_wallhole_pen_fg_out	= gs_wallhole_pen_fg
	gs_trim_wallhole_pen_bg_out	= gs_wallhole_pen_bg

	gs_trim_wallhole_pen_sl_fg_out	= gs_wallhole_pen_sl_fg
	gs_trim_wallhole_pen_sl_bg_out	= gs_wallhole_pen_sl_bg
endif
if bPShapedLeftOpening | bPShapedRightOpening then
	gs_trim_wallhole_fill_out		= gs_wallhole_fill_sl
else
	gs_trim_wallhole_fill_out		= gs_wallhole_fill
endif

if not(gs_trim_bFills_in)  then gs_trim_wallhole_fill_in  = 0
if not(gs_trim_bFills_out) then gs_trim_wallhole_fill_out = 0



gs_trim_pen_cont_out	= gs_trim_pen_cont
gs_trim_pen_cont_in		= gs_trim_pen_cont
line_type 1

if WIDO_REVEAL_SIDE then
	add2 0,-WIDO_FRAME_THICKNESS
else
	mul2 1,-1
endif

! ===== Handling 2D Detail Levels =====

if lod2D_Casing = 0 then
	bDrawOutsideTrim = 0
	bDrawInsideTrim  = 0
endif


if gs_stack_left then
	overSizeLeft = gs_left_oversize
	widoLeftJamb = 0
endif

if gs_stack_right then
	overSizeRight = gs_right_oversize
	widoRightJamb = 0
endif

if gs_trim_show_cover_in then
	gs_trim_jambext_nosing_in = 0
else
	gs_trim_thk_in = gs_trim_jambext_nosing_in
	gs_trim_offs_in = 0
endif
if gs_trim_show_cover_out then
	gs_trim_jambext_nosing_out = 0
else
	gs_trim_thk_out = gs_trim_jambext_nosing_out
	gs_trim_offs_out = 0
endif

trthL = gs_trim_thk_in / cos(trinfiL - gi1L)
trthR = gs_trim_thk_in / sin(90 - trinfiR - gi1R)

! ==============================================================================
!	Open PolyOperations Add-on Channel
! ==============================================================================
if bTShapedOpening & curvedWall & (bDrawInsideTrim | bDrawOutsideTrim) then
	ch = INITADDONSCOPE ("PolyOperations", "", "")

	PREPAREFUNCTION ch, "CreateContainer", "mySourceContainer", ""
	PREPAREFUNCTION ch, "CreateContainer", "myDestinationContainer", ""

	PREPAREFUNCTION ch, "SetSourceContainer",		"mySourceContainer", ""
	PREPAREFUNCTION ch, "SetDestinationContainer",	"myDestinationContainer", ""
endif


! ==============================================================================
!	Draw Inside Casing's Background Fill
! ==============================================================================

if bDrawInsideCasingFill & bDrawInsideTrim & isWindow & not(gs_stack_bottom) then

	set fill gs_trim_wallhole_fill_in
	line_property 0
	line_type 1
	pen gs_pen_2D

	if not(curvedWall) then
		if bLeftCornerFunction then
			bpx6 = leftRevealPnts[idxBoardEndRevealLeft][1] + gs_trim_thk_in * lx
			bpy6 = leftRevealPnts[idxBoardEndRevealLeft][2] + gs_trim_thk_in
		else
			if bInclinedWall then
				if gs_stack_left then
					bpx6 = leftRevealPnts[idxBoardEndRevealLeft][1]
					bpy6 = leftRevealPnts[idxBoardEndRevealLeft][2] + gs_trim_thk_in / incH
				else
					bpx6 = leftRevealPnts[idxBoardEndRevealLeft][1] + trin2L * incH - gs_trim_offs_in - trthL * sin(trinfiL)
!					bpy6 = leftRevealPnts[idxBoardEndRevealLeft][2] + (gs_trim_width_in - gs_trim_offs_in) * incV + (gs_trim_thk_in / incH*0 + trthL * cos(trinfiL)) * not(gs_trim_atframe_in)
					bpx60 = leftRevealPnts[idxBoardEndRevealLeft][1] + trin2L * incH - gs_trim_offs_in
					bpy6 = WALL_THICKNESS - WIDO_SILL + incX * bpx60 + trthL * cos(trinfiL)
				endif
			else
				bpx6 = leftRevealPnts[idxBoardEndRevealLeft][1] + not(gs_stack_left) * (trinL - gs_trim_offs_in - gs_trim_thk_in * tan(trinfiL) * not(gs_trim_atframe_in))
				bpy6 = leftRevealPnts[idxBoardEndRevealLeft][2] + gs_trim_thk_in * not(gs_trim_atframe_in)
			endif
		endif

		if bRightCornerFunction then
			bpx7 = rightRevealPnts[idxBoardEndRevealRight][1] - gs_trim_thk_in * rx
			bpy7 = rightRevealPnts[idxBoardEndRevealRight][2] + gs_trim_thk_in
		else
			if bInclinedWall then
				if gs_stack_right then
					bpx7 = rightRevealPnts[idxBoardEndRevealRight][1]
					bpy7 = rightRevealPnts[idxBoardEndRevealRight][2] + gs_trim_thk_in / incH
				else
					bpx7 = rightRevealPnts[idxBoardEndRevealRight][1] - trin2R * incH + gs_trim_offs_in + trthR * sin(trinfiR)	!- gs_trim_width_in + gs_trim_offs_in
!					bpy7 = rightRevealPnts[idxBoardEndRevealRight][2] - (gs_trim_width_in - gs_trim_offs_in) * incV + (gs_trim_thk_in / incH*0 + trthR * cos(trinfiR)) * not(gs_trim_atframe_in)
					bpx70 = rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + gs_trim_width_in*0 - trin2R * incH + gs_trim_offs_in
					bpy7 = WALL_THICKNESS - WIDO_SILL + incX * bpx70 + trthR * cos(trinfiR)
				endif
			else
				bpx7 = rightRevealPnts[idxBoardEndRevealRight][1] - not(gs_stack_right) * (trinR - gs_trim_offs_in - gs_trim_thk_in * tan(trinfiR) * not(gs_trim_atframe_in))
				bpy7 = rightRevealPnts[idxBoardEndRevealRight][2] + gs_trim_thk_in * not(gs_trim_atframe_in)
			endif
		endif

	else
		if wallIsLeft then
			alfaL = -atn((-leftRevealPnts[idxBoardEndRevealLeft-1][1])  / (WOD - WIDO_FRAME_THICKNESS))
			alfaR =  atn((rightRevealPnts[idxBoardEndRevealRight-1][1]) / (WOD - WIDO_FRAME_THICKNESS))
		else
			alfaL = -atn((-leftRevealPnts[idxBoardEndRevealLeft-1][1])  / WOD)
			alfaR =  atn((rightRevealPnts[idxBoardEndRevealRight-1][1]) / WOD)
		endif

		if gs_stack_left then
			bpx6 = leftRevealPnts[idxBoardEndRevealLeft][1] - gs_trim_thk_in * sin(alfaL)
			bpy6 = leftRevealPnts[idxBoardEndRevealLeft][2] + gs_trim_thk_in * cos(alfaL)
		else
			if bParalellInCurvedWalls then
				bpx6 = leftRevealPnts[idxBoardEndRevealLeft][1] + (gs_trim_width_in - gs_trim_offs_in)
				bpy6 = -signWallIsLeft * sqr((radBoard - signWallIsLeft * gs_trim_thk_in)^2 - bpx6^2) + WOD
			else
				x = leftRevealPnts[idxBoardEndRevealLeft][1]
				y = leftRevealPnts[idxBoardEndRevealLeft][2]
				alpha = (gs_trim_width_in - gs_trim_offs_in) * ArcLengthBoardToAngle
				gosub 1000
				bpx6 = x - gs_trim_thk_in * sin(alfaL)
				bpy6 = y + gs_trim_thk_in * cos(alfaL)
			endif
		endif

		if gs_stack_right then
			bpx7 = rightRevealPnts[idxBoardEndRevealRight][1] - gs_trim_thk_in * sin(alfaR)
			bpy7 = rightRevealPnts[idxBoardEndRevealRight][2] + gs_trim_thk_in * cos(alfaR)
		else
			if bParalellInCurvedWalls then
				bpx7 = rightRevealPnts[idxBoardEndRevealRight][1] - (gs_trim_width_in - gs_trim_offs_in)
				bpy7 = -signWallIsLeft * sqr((radBoard - signWallIsLeft * gs_trim_thk_in)^2 - bpx7^2) + WOD
			else
				x = rightRevealPnts[idxBoardEndRevealRight][1]
				y = rightRevealPnts[idxBoardEndRevealRight][2]
				alpha = -(gs_trim_width_in - gs_trim_offs_in) * ArcLengthBoardToAngle
				gosub 1000
				bpx7 = x - gs_trim_thk_in * sin(alfaR)
				bpy7 = y + gs_trim_thk_in * cos(alfaR)
			endif
		endif
	endif

	bCurvedAtWindowFrame	= (curvedWall & gs_IsCurved)

	put 0,WOD,900,
		leftRevealPnts[idxBoardEndRevealLeft - 1][1],	leftRevealPnts[idxBoardEndRevealLeft - 1][2],	0,
		leftRevealPnts[idxBoardEndRevealLeft][1],		leftRevealPnts[idxBoardEndRevealLeft][2],		0,
		bpx6,											bpy6,											0,
		bpx7,											bpy7,											3000 * curvedWall,
		rightRevealPnts[idxBoardEndRevealRight][1],		rightRevealPnts[idxBoardEndRevealRight][2],		0,
		rightRevealPnts[idxBoardEndRevealRight - 1][1],	rightRevealPnts[idxBoardEndRevealRight - 1][2],	0,
		leftRevealPnts[idxBoardEndRevealLeft - 1][1],	leftRevealPnts[idxBoardEndRevealLeft - 1][2],	3000 * (bCurvedAtWindowFrame)

	poly2_b nsp/3, 2+4+64, gs_trim_wallhole_pen_fg_in, gs_trim_wallhole_pen_bg_in,
		get(nsp)

	if not(gs_trim_atframe_in) & not(gs_board_inside) then
		if curvedWall then
			R = sqr(bpx6^2 + (bpy6 - WOD)^2)

			vx = bpx6
			vy = bpy6 - WOD
			gosub 103	! Direction Angle
			alpha = angle

			vx = bpx7
			vy = bpy7 - WOD
			gosub 103	! Direction Angle
			beta = angle

			if abs(alpha - beta) > EPS then
				arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
			endif

			if bLineCasingOffset & gs_trim_offs_in > eps then
				R = sqr(bpx6^2 + (bpy6 - gs_trim_thk_in - WOD)^2)

				vx = bpx6
				vy = bpy6 - gs_trim_thk_in - WOD
				gosub 103	! Direction Angle
				alpha = angle

				vx = bpx7
				vy = bpy7 - gs_trim_thk_in - WOD
				gosub 103	! Direction Angle
				beta = angle

				if abs(alpha - beta) > EPS then
					arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
				endif

			endif
		else
			line2 bpx6, bpy6, bpx7, bpy7

			if bLineCasingOffset & gs_trim_offs_in > eps then
				line2 bpx6, bpy6 - gs_trim_thk_in, bpx7, bpy7 - gs_trim_thk_in
			endif
		endif
	endif
endif


! ==============================================================================
!	Draw Outside Casing's Background Fill
! ==============================================================================

if bDrawOutsideCasingFill & bDrawOutsideTrim & isWindow & not(gs_stack_bottom) then
	set fill gs_trim_wallhole_fill_out
	line_property 0
	line_type 1
	pen gs_pen_2D

	if not(curvedWall) then
		if bLeftCornerFunction then
			spx4 = leftRevealPnts[idxSillStartRevealLeft][1] - gs_trim_thk_out * lx
			spy4 = -WIDO_SILL - gs_trim_thk_out * not(gs_trim_atframe_out)
		else
			spx4 = leftRevealPnts[idxSillStartRevealLeft][1] + not(gs_stack_left) * (gs_trim_width_out - gs_trim_offs_out + tolerOffsetLeftOut)
			spy4 = -WIDO_SILL - gs_trim_thk_out * not(gs_trim_atframe_out)
		endif

		if bRightCornerFunction then
			spx5 = rightRevealPnts[idxSillStartRevealRight][1] + gs_trim_thk_out * rx
			spy5 = -WIDO_SILL - gs_trim_thk_out * not(gs_trim_atframe_out)
		else
			spx5 = rightRevealPnts[idxSillStartRevealRight][1] - not(gs_stack_right) * (gs_trim_width_out - gs_trim_offs_out + tolerOffsetRightOut)
			spy5 = -WIDO_SILL - gs_trim_thk_out * not(gs_trim_atframe_out)
		endif
	else
		if wallIsLeft then
			alfaL = -atn((leftWidth)  / (WOD - WIDO_FRAME_THICKNESS))
			alfaR =  atn((rightWidth) / (WOD - WIDO_FRAME_THICKNESS))
		else
			alfaL = -atn((leftWidth)  / WOD)
			alfaR =  atn((rightWidth) / WOD)
		endif

		if gs_stack_left then
			spx4 = leftRevealPnts[idxSillStartRevealLeft][1] + gs_trim_thk_out * sin(alfaL)
			spy4 = leftRevealPnts[idxSillStartRevealLeft][2] - gs_trim_thk_out * cos(alfaL)
		else
			if bParalellInCurvedWalls then
				spx4 = leftRevealPnts[idxSillStartRevealLeft][1] + (gs_trim_width_out - gs_trim_offs_out + tolerOffsetLeftOut)
				spy4 = -signWallIsLeft * sqr((radSill + signWallIsLeft * gs_trim_thk_out)^2 - spx4^2) + WOD
			else
				x = leftRevealPnts[idxSillStartRevealLeft][1]
				y = leftRevealPnts[idxSillStartRevealLeft][2]
				alpha = (gs_trim_width_out - gs_trim_offs_out) * ArcLengthSillToAngle
				gosub 1000
				spx4 = x + gs_trim_thk_out * sin(alfaL)
				spy4 = y - gs_trim_thk_out * cos(alfaL)
			endif
		endif

		if gs_stack_right then
			spx5 = rightRevealPnts[idxSillStartRevealRight][1] + gs_trim_thk_out * sin(alfaR)
			spy5 = rightRevealPnts[idxSillStartRevealRight][2] - gs_trim_thk_out * cos(alfaR)
		else
			if bParalellInCurvedWalls then
				spx5 = rightRevealPnts[idxSillStartRevealRight][1] - (gs_trim_width_out - gs_trim_offs_out + tolerOffsetRightOut)
				spy5 = -signWallIsLeft * sqr((radSill + signWallIsLeft * gs_trim_thk_out)^2 - spx5^2) + WOD
			else
				x = rightRevealPnts[idxSillStartRevealRight][1]
				y = rightRevealPnts[idxSillStartRevealRight][2]
				alpha = -(gs_trim_width_out - gs_trim_offs_out) * ArcLengthSillToAngle
				gosub 1000
				spx5 = x + gs_trim_thk_out * sin(alfaR)
				spy5 = y - gs_trim_thk_out * cos(alfaR)
			endif
		endif
	endif

	bCurvedAtWindowFrame	= (curvedWall & gs_IsCurved)

	put 0,WOD,900
	for i = idxSillEndPlasterLeft to idxSillStartPlasterLeft step -1
		put leftRevealPnts[i][1],	leftRevealPnts[i][2],	0
	next i
	put	spx4,	spy4,	0,
		spx5,	spy5,	3000 * curvedWall

	for i = idxSillStartPlasterRight to idxSillEndPlasterRight
		put rightRevealPnts[i][1],	rightRevealPnts[i][2],	0
	next i
	put leftRevealPnts[idxSillEndPlasterLeft][1],	leftRevealPnts[idxSillEndPlasterLeft][2],	3000 * (bCurvedAtWindowFrame)

	poly2_b nsp/3, 2+4+64, gs_trim_wallhole_pen_fg_out, gs_trim_wallhole_pen_bg_out,
		get(nsp)

	if not(gs_trim_atframe_out) & not(gs_sill_outside) then
		if curvedWall then
			R = sqr(spx4^2 + (spy4 - WOD)^2)

			vx = spx4
			vy = spy4 - WOD
			gosub 103	! Direction Angle
			alpha = angle

			vx = spx5
			vy = spy5 - WOD
			gosub 103	! Direction Angle
			beta = angle

			if abs(alpha - beta) > EPS then
				arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
			endif
		else
			line2 spx4, spy4, spx5, spy5
		endif
	endif
endif



! ==============================================================================
!	Draw Casing
! ==============================================================================

bShowJambExtHotspots = bShowAddHotspots

spx1 = leftRevealPnts[2][1]
spy1 = leftRevealPnts[2][2] - WOD

spx8 = rightRevealPnts[2][1]
spy8 = rightRevealPnts[2][2] - WOD

bpx3 = leftRevealPnts[idxBoardEndRevealLeft - 1][1]
bpy3 = leftRevealPnts[idxBoardEndRevealLeft - 1][2] - WOD

bpx10 = rightRevealPnts[idxBoardEndRevealRight - 1][1]
bpy10 = rightRevealPnts[idxBoardEndRevealRight - 1][2] - WOD


! ==============================================================================
!	Draw Inside Trim
! ==============================================================================

if bDrawInsideTrim then

	pen gs_trim_pen_cont_in

	line_property 2
	set fill gs_trim_fill_in
	if not(curvedWall) or (curvedWall & gs_trim_atframe_in = 1) then

		! ===== Inside Trim - Straight Walls =====

		py = WALL_THICKNESS - WIDO_SILL

		if not(bLeftCornerFunction) & not(gs_stack_left) then

			if gs_trim_width_in > EPS & bShowJambExtension & gs_trim_atframe_in = 0 then

				! ===== Inside Trim - Straight Walls - Jamb Extension - Left =====

				thk = WIDO_FRAME_THICKNESS

				px1 = leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn
				px2 = leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn - gs_trim_jambext_nosing_in * tan(gs_reveal_left_angle)
				px3 = leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn - gs_trim_jambext_nosing_in * tan(gs_reveal_left_angle) + trinL * (1 - bInclinedWall) + trin2L * incH
				px4 = px1 + trinL

				py1 = thk * (gs_sectgar = 0)
				py2 = leftRevealPnts[idxBoardEndRevealLeft][2] + tolerOffsetLeftIn * incV + gs_trim_jambext_nosing_in
				py3 = leftRevealPnts[idxBoardEndRevealLeft][2] + (trin2L + tolerOffsetLeftIn) * incV + gs_trim_jambext_nosing_in
				py4 = thk * (gs_sectgar = 0)

				if bTelescopic then
					py1 = 0
					py4 = 0
					thk = 0
				endif

				! --- Casing Set Back on Sides ---
				if casingSetBackOnSides_in > EPS then
					py1 = py1 + casingSetBackOnSides_in
					py4 = py4 + casingSetBackOnSides_in
				endif

				set fill gs_trim_fill_in
				if py2 > thk & py3 > thk then
					poly2_b 4, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						px1,	py1,	1 + 32,
						px2,	py2,	1 + 32,
						px3,	py3,	1 + 32,
						px4,	py4,	1 + 32

					if bShowEdgeHotspots | (bShowJambExtHotspots & gs_trim_offs_in > EPS) then
						hotspot2 	px3, py3, 10012
!!!						text2 		px3, py3, "10012"
					endif
				endif

				if bPShapedLeftOpening & not(bDrawLeftSLBoard) then

					! ===== Inside Trim - Straight Walls - Jamb Extension - Lower Left =====

					px1 = px3 + gs_sidelight_WHole_width_left
					px2 = px4 + gs_sidelight_WHole_width_left

					set fill gs_trim_wallhole_fill_in

					poly2_b 4, 1+2+4+64, gs_trim_wallhole_pen_sl_fg_in, gs_trim_wallhole_pen_sl_bg_in,
						px1,	py1,																1,
						px2,	py2 + incX * (gs_sidelight_WHole_width_left + gs_trim_width_in),	((gs_trim_offs_in > EPS) | not(gs_trim_show_cover_in)),
						px3,	py3,																1,
						px4,	py4,																1
				endif
			endif

			if gs_tw_left_in > EPS & gs_trim_thk_in > EPS & gs_trim_show_cover_in & gs_sectgar = 0 then

				! ===== Inside Trim - Straight Walls - Casing - Left =====

				set fill gs_trim_fill_in
				if bInclinedWall & gs_trim_atframe_in = 0 then
					px1 = leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn + gs_trim_width_in*0 + trin2L * incH - gs_trim_offs_in
					px2 = px1 - incH * gs_tw_left_in + incV * gs_trim_thk_in
					px3 = px1 - incH * gs_tw_left_in
					px4 = px1 - trthL * sin(trinfiL)

					py1 = py - incX * (-leftRevealPnts[idxBoardEndRevealLeft][1] - tolerOffsetLeftIn - gs_trim_width_in*0 + gs_trim_offs_in) + (trin2L + tolerOffsetLeftIn*0) * incV
					py2 = py1 - incV * gs_tw_left_in + incV * incX * gs_trim_thk_in
					py3 = py1 + gs_trim_thk_in / incH - incV * gs_tw_left_in
					py4 = py1 + gs_trim_thk_in / incH*0 + trthL * cos(trinfiL)

					poly2_b 4, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						px1,	py1,	1 + 32,
						px2,	py2,	1 + 32,
						px3,	py3,	1 + 32,
						px4,	py4,	1 + 32

					if not(bShowEdgeHotspots) & bShowJambExtHotspots & gs_trim_offs_in < EPS then
						hotspot2 	px4, py4, 10012
!!!						text2 		px4, py4, "10012"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2 	px3, py3, 10032
!!!						text2 		px3, py3, "10032"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	px3, py3, 10002
!!!						text2 		px3, py3, "10002"
					endif

					if bPShapedLeftOpening & not(bDrawLeftSLBoard) then
						! ===== Inside Trim - Straight Walls - Casing - Lower Left =====

						px1 = px4 + gs_sidelight_WHole_width_left

						set fill gs_trim_wallhole_fill_in

						poly2_b 4, 1+2+4+64, gs_trim_wallhole_pen_sl_fg_in, gs_trim_wallhole_pen_sl_bg_in,
							px4,	py1,	1,
							px4,	py4,	1,
							px1,	py4 + incX * gs_sidelight_WHole_width_left,	1,
							px1,	py1 + incX * gs_sidelight_WHole_width_left,	gs_trim_offs_in > EPS
					endif
				else
					px1 = leftRevealPnts[idxBoardEndRevealLeft-gs_trim_atframe_in][1] + tolerOffsetLeftIn + trinL - gs_trim_offs_in
					px2 = px1 - gs_tw_left_in
					px3 = px2
					px4 = px1 - gs_trim_thk_in * tan(trinfiL) * not(gs_trim_atframe_in)

					if gs_trim_atframe_in = 0 then
						py1 = WALL_THICKNESS - WIDO_SILL
					else
						py1 = leftRevealPnts[idxBoardEndRevealLeft-1][2]
					endif
					py2 = py1
					py3 = py1 + gs_trim_thk_in
					py4 = py1 + gs_trim_thk_in

					poly2_b 4, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						px1,	py1,	1 + 32,
						px2,	py2,	1 + 32,
						px3,	py3,	1 + 32,
						px4,	py4,	1 + 32

					if not(bShowEdgeHotspots) & bShowJambExtHotspots & gs_trim_offs_in < EPS then
						hotspot2 	px1, py2, 10012
!!!						text2 		px1, py2, "10012"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2	px3, py3, 10032
!!!						text2 		px3, py3, "10032"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	px3, py3, 10002
!!!						text2 		px3, py3, "10002"
					endif

					if bPShapedLeftOpening & not(bDrawLeftSLBoard) then
						! ===== Inside Trim - Straight Walls - Casing - Lower Left =====

						px1 = px4 + gs_sidelight_WHole_width_left

						set fill gs_trim_wallhole_fill_in

						poly2_b 4, 1+2+4+64, gs_trim_wallhole_pen_sl_fg_in, gs_trim_wallhole_pen_sl_bg_in,
							px4,	py1,	1,
							px4,	py4,	1,
							px1,	py4,	1,
							px1,	py1,	gs_trim_offs_in > EPS
					endif
				endif
			endif
		endif

		if not(bRightCornerFunction) & not(gs_stack_right)then

			set fill gs_trim_fill_in
			if gs_trim_width_in > EPS & bShowJambExtension & gs_trim_atframe_in = 0 then

				! ===== Inside Trim - Straight Walls - Jamb Extension - Right =====

				thk = WIDO_FRAME_THICKNESS

				px1 = rightRevealPnts[idxBoardEndRevealRight-1][1] - tolerOffsetRightIn
				px2 = rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + gs_trim_jambext_nosing_in * tan(gs_reveal_right_angle)
				px3 = rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + gs_trim_jambext_nosing_in * tan(gs_reveal_right_angle) - trinR * (1 - bInclinedWall) - trin2R * incH
				px4 = px1 - trinR

				py1 = thk * (gs_sectgar = 0)
				py2 = rightRevealPnts[idxBoardEndRevealRight][2] - tolerOffsetRightIn * incV + gs_trim_jambext_nosing_in
				py3 = rightRevealPnts[idxBoardEndRevealRight][2] - (trin2R + tolerOffsetRightIn) * incV + gs_trim_jambext_nosing_in
				py4 = thk * (gs_sectgar = 0)

				if bTelescopic then
					py1 = 0
					py4 = 0
					thk = 0
				endif

				! --- Casing Set Back on Sides ---
				if casingSetBackOnSides_in > EPS then
					py1 = py1 + casingSetBackOnSides_in
					py4 = py4 + casingSetBackOnSides_in
				endif

				if py2 > thk & py3 > thk then
					poly2_b 4, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						px1,	py1,	1 + 32,
						px2,	py2,	1 + 32,
						px3,	py3,	1 + 32,
						px4,	py4,	1 + 32

					if bShowEdgeHotspots | (bShowJambExtHotspots & gs_trim_offs_in > EPS) then
						hotspot2 	px3, py3, 10013
!!!						text2 		px3, py3, "10013"
					endif
				endif

				if bPShapedRightOpening & not(bDrawRightSLBoard) then

					! ===== Inside Trim - Straight Walls - Jamb Extension - Lower Right =====

					px1 = px3 - gs_sidelight_WHole_width_right
					px2 = px4 - gs_sidelight_WHole_width_right

					set fill gs_trim_wallhole_fill_in

					poly2_b 4, 1+2+4+64, gs_trim_wallhole_pen_sl_fg_in, gs_trim_wallhole_pen_sl_bg_in,
						px1,	py1,																1,
						px2,	py2 - incX * (gs_sidelight_WHole_width_right + gs_trim_width_in),	((gs_trim_offs_in > EPS) | not(gs_trim_show_cover_in)),
						px3,	py3,																1,
						px4,	py4,																1
				endif
			endif

			if gs_tw_right_in > EPS & gs_trim_thk_in > EPS & gs_trim_show_cover_in & gs_sectgar = 0 then

				! ===== Inside Trim - Straight Walls - Casing - Right =====

				set fill gs_trim_fill_in
				if bInclinedWall & gs_trim_atframe_in = 0 then
					px1 = rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn + gs_trim_width_in*0 - trin2R * incH + gs_trim_offs_in
					px2 = px1 + incH * gs_tw_right_in + incV * gs_trim_thk_in
					px3 = px1 + incH * gs_tw_right_in
					px4 = px1 + trthR * sin(trinfiR)

					py1 = py + incX * px1
					py2 = py1 + incV * gs_tw_right_in + incV * incX * gs_trim_thk_in
					py3 = py1 + gs_trim_thk_in / incH + incV * gs_tw_right_in
					py4 = py1 + gs_trim_thk_in / incH*0 + trthR * cos(trinfiR)

					poly2_b 4, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						px1,	py1,	1 + 32,
						px2,	py2,	1 + 32,
						px3,	py3,	1 + 32,
						px4,	py4,	1 + 32

					if not(bShowEdgeHotspots) & bShowJambExtHotspots & gs_trim_offs_in < EPS then
						hotspot2 	px4, py4, 10013
!!!						text2 		px4, py4, "10013"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2 	px3, py3, 10033
!!!						text2 		px3, py3, "10033"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	px3, py3, 10003
!!!						text2 		px3, py3, "10003"
					endif

					if bPShapedRightOpening & not(bDrawRightSLBoard) then
						! ===== Inside Trim - Straight Walls - Casing - Lower Right =====

						px1 = px4 - gs_sidelight_WHole_width_right

						set fill gs_trim_wallhole_fill_in

						poly2_b 4, 1+2+4+64, gs_trim_wallhole_pen_sl_fg_in, gs_trim_wallhole_pen_sl_bg_in,
							px4,	py1,	1,
							px4,	py4,	1,
							px1,	py4 - incX * gs_sidelight_WHole_width_right,	1,
							px1,	py1 - incX * gs_sidelight_WHole_width_right,	gs_trim_offs_in > EPS
					endif
				else
					px1 = rightRevealPnts[idxBoardEndRevealright - gs_trim_atframe_in][1] - tolerOffsetRightIn - trinR + gs_trim_offs_in
					px2 = px1 + gs_tw_right_in
					px3 = px2
					px4 = px1 + gs_trim_thk_in * tan(trinfiR) * not(gs_trim_atframe_in)

					if gs_trim_atframe_in = 0 then
						py1 = WALL_THICKNESS - WIDO_SILL
					else
						py1 = rightRevealPnts[idxBoardEndRevealright-1][2]
					endif
					py2 = py1
					py3 = py1 + gs_trim_thk_in
					py4 = py1 + gs_trim_thk_in

					poly2_b 4, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						px1,	py1,	1 + 32,
						px2,	py2,	1 + 32,
						px3,	py3,	1 + 32,
						px4,	py4,	1 + 32

					if not(bShowEdgeHotspots) & bShowJambExtHotspots & gs_trim_offs_in < EPS then
						hotspot2 	px1, py2, 10013
!!!						text2 		px1, py2, "10013"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2 	px3, py3, 10033
!!!						text2 		px3, py3, "10033"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	px3, py3, 10003
!!!						text2 		px3, py3, "10003"
					endif

					if bPShapedRightOpening & not(bDrawRightSLBoard) then
						! ===== Inside Trim - Straight Walls - Casing - Lower Right =====

						px1 = px4 - gs_sidelight_WHole_width_right

						set fill gs_trim_wallhole_fill_in

						poly2_b 4, 1+2+4+64, gs_trim_wallhole_pen_sl_fg_in, gs_trim_wallhole_pen_sl_bg_in,
							px4,	py1,	1,
							px4,	py4,	1,
							px1,	py4,	1,
							px1,	py1,	gs_trim_offs_in > EPS
					endif
				endif
			endif
		endif

	else	! not(curvedWall)

		if bParalellInCurvedWalls = 0 then	! radial cutting in curved wall
			add2 0,WOD

			iSign = wallIsLeft - not(wallIsLeft)

			LengtToArc = iSign * 180 / rBoard / PI
			alfaTrimOffsetIn	= LengtToArc * gs_trim_offs_in
			alfaTrimWidthIn		= LengtToArc * gs_trim_width_in

			rBoardEdge = rBoard - iSign * gs_trim_thk_in
			rBoardJambNosing = rBoard - iSign * gs_trim_jambext_nosing_in

			if not(gs_stack_left) then

				if wallIsLeft then
					alfaLeftEdge = 180 + abs(alfaLeftIn)
				else
					alfaLeftEdge = -abs(alfaLeftIn)
				endif

				pyy1 = bpy3
				pyy2 = rBoard * cos(alfaLeftEdge)


				if gs_trim_show_cover_in then
					px1 = rBoard * sin(alfaLeftEdge - alfaTrimWidthIn) + tolerOffsetLeftIn
					py1 = ySign * sqr(rBoard^2 - px1^2)
				else
					px1 = rBoardJambNosing * sin(alfaLeftEdge - alfaTrimWidthIn) + tolerOffsetLeftIn
					py1 = ySign * sqr(rBoardJambNosing^2 - px1^2)
				endif

				px2 = rBoard * sin(alfaLeftEdge) + tolerOffsetLeftIn
				py2 = ySign * sqr((rBoard)^2 - px2^2)

				! --- Casing Set Back on Sides ---
				if casingSetBackOnSides_in > EPS then
					bpx3 = bpx3 + casingSetBackOnSides_in / tan(90 - alfaLeftEdge)
					pyy1 = pyy1 + casingSetBackOnSides_in
				endif

				if gs_trim_width_in > EPS & bShowJambExtension & (pyy1 < pyy2) then

					! ===== Inside Trim - Curved Walls - Jamb Extension - Left =====

					put bpx3 + tolerOffsetLeftIn, pyy1, 1 + 32

					if gs_IsCurved then
						xo = 0
						yo = 0
						ro = rBoard + iSign * (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS)

						x1 = -iSign * gs_trim_width_in * cos(alfaLeftEdge)
						y1 =  iSign * gs_trim_width_in * sin(alfaLeftEdge)

						x2 = x1 + bpx3
						y2 = y1 + bpy3

						gosub 100

						put 0,  0,  901 + 32,
							xb, yb, 3001 + 32
					else

						! --- Casing Set Back on Sides ---
						if casingSetBackOnSides_in > EPS then
							bpy3 = bpy3 + casingSetBackOnSides_in
						endif

						put bpx3 + tolerOffsetLeftIn - iSign * gs_trim_width_in / cos(alfaLeftEdge),
							bpy3, 1 + 32
					endif

					put px1, py1, 1 + 32,
						0,0, 901 + 32,
						px2, py2, 3001 + 32

					poly2_b nsp/3, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in, get(nsp)

					if bShowEdgeHotspots | (bShowJambExtHotspots & gs_trim_offs_in > EPS) then
						hotspot2 	px1, py1, 10012
!!!						text2 		px1, py1, "10012"
					endif
				endif

				if bPShapedLeftOpening & not(bDrawLeftSLBoard) then
					! ===== Inside Trim - Curved Walls - Jamb Extension - Lower Left =====

					px1LSL = -leftWidth + gs_sidelight_WHole_width_left + gs_trim_width_in
					py1LSL = ABS(SQR(rBoard^2 - px1LSL^2))

					put px1,	py1,	gs_trim_offs_in > EPS,
						0,		0,		900,
						px1LSL, ySign * py1LSL, 3001,
						px1LSL, bpy3,	1,
						bpx3 + tolerOffsetLeftIn - iSign * gs_trim_width_in / cos(alfaLeftEdge), bpy3-1, 1,
						bpx3 + tolerOffsetLeftIn - iSign * gs_trim_width_in / cos(alfaLeftEdge), bpy3, 1

					bCasingIsInside = 1
					line2 px1LSL, bpy3, px1LSL - gs_trim_width_in, bpy3
					gosub "DrawSidelightCasingCurvedWall"
				endif


				if gs_tw_left_in > EPS & gs_trim_thk_in > EPS & gs_trim_show_cover_in then

					! ===== Inside Trim - Curved Walls - Casing - Left =====

					alfaLeftTrimWidth	= LengtToArc * gs_tw_left_in

					if wallIsLeft then
						rot2 180 - abs(alfaLeftIn) + alfaTrimWidthIn - alfaTrimOffsetIn
					else
						rot2 abs(alfaLeftIn) + alfaTrimWidthIn - alfaTrimOffsetIn
					endif

					poly2_b 6, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						0, rBoardEdge, 1 + 32,
						0, rBoard, 1 + 32,
						0,0, 901 + 32,
						rBoard * sin(alfaLeftTrimWidth), rBoard * cos(alfaLeftTrimWidth), 3001 + 32,
						rBoardEdge * sin(alfaLeftTrimWidth), rBoardEdge * cos(alfaLeftTrimWidth), 1 + 32,
						0, rBoardEdge, 3001 + 32

					if not(bShowEdgeHotspots) & bShowJambExtHotspots & gs_trim_offs_in < EPS then
						hotspot2 	0, rBoardEdge, 10012
!!!						text2 		0, rBoardEdge, "10012"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2 	rBoardEdge * sin(alfaLeftTrimWidth), rBoardEdge * cos(alfaLeftTrimWidth), 10032
!!!						text2 		rBoardEdge * sin(alfaLeftTrimWidth), rBoardEdge * cos(alfaLeftTrimWidth), "10032"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	rBoardEdge * sin(alfaLeftTrimWidth), rBoardEdge * cos(alfaLeftTrimWidth), 10002
!!!						text2 		rBoardEdge * sin(alfaLeftTrimWidth), rBoardEdge * cos(alfaLeftTrimWidth), "10002"
					endif

					del 1
				endif

				if bPShapedLeftOpening & not(bDrawLeftSLBoard) then
					! ===== Inside Trim - Curved Walls - Casing - Lower Left =====

					px1	= px1 + iSign * gs_trim_offs_in * cos(alfaLeftEdge)
					py1	= py1 + ySign * gs_trim_offs_in * sin(alfaLeftEdge)
					px2	= px1 - iSign * gs_trim_thk_in * sin(alfaLeftEdge)
					py2	= py1 + ySign * gs_trim_thk_in * cos(alfaLeftEdge)

					px1LSL = -leftWidth + gs_sidelight_WHole_width_left + gs_trim_width_in - gs_trim_offs_in
					py1LSL = SQR(rBoard^2 - px1LSL^2)
					px2LSL = px1LSL
					py2LSL = py1LSL + ySign * gs_trim_thk_in

					put px2, py2,	1,
						0,		0,		900,
						px2LSL, ySign * py2LSL, 3001,
						px1LSL, ySign * py1LSL, gs_trim_offs_in > EPS,
						px1, py1,	3001

					bCasingIsInside = 1
					gosub "DrawSidelightCasingCurvedWall"
				endif
			endif

			if not(gs_stack_right) then

				if wallIsLeft then
					alfaRightEdge = -180 - abs(alfaRightIn)
				else
					alfaRightEdge = abs(alfaRightIn)
				endif

				pyy1 = bpy10
				pyy2 = rBoard * cos(alfaRightEdge)


				if gs_trim_show_cover_in then
					px1 = rBoard * sin(alfaRightEdge + alfaTrimWidthIn)
					py1 = rBoard * cos(alfaRightEdge + alfaTrimWidthIn)
				else
					px1 = rBoardJambNosing * sin(alfaRightEdge + alfaTrimWidthIn)
					py1 = rBoardJambNosing * cos(alfaRightEdge + alfaTrimWidthIn)
				endif

				! --- Casing Set Back on Sides ---
				if casingSetBackOnSides_in > EPS then
					bpx10 = bpx10 + casingSetBackOnSides_in / tan(90 - alfaRightEdge)
					pyy1 = pyy1 + casingSetBackOnSides_in
				endif

				if gs_trim_width_in  > EPS & bShowJambExtension & (pyy1 < pyy2) then

					! ===== Inside Trim - Curved Walls - Jamb Extension - Right =====

					put bpx10,
						pyy1, 1 + 32

					if gs_IsCurved then
						xo = 0
						yo = 0
						ro = rBoard + iSign * (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS)

						x1 = iSign * gs_trim_width_in * cos(alfaRightEdge)
						y1 = gs_trim_width_in * sin(alfaRightEdge)

						x2 = x1 + bpx10
						y2 = y1 + bpy10

						gosub 100

						put 0,  0,  901 + 32,
							xa, ya, 3001 + 32
					else
						! --- Casing Set Back on Sides ---
						if casingSetBackOnSides_in > EPS then
							bpy10 = bpy10 + casingSetBackOnSides_in
						endif

						put bpx10 + iSign * gs_trim_width_in / cos(alfaRightEdge),
							bpy10, 1 + 32
					endif


					put px1, py1, 1 + 32,
						0,0, 901 + 32,
						rBoard * sin(alfaRightEdge), pyy2, 3001 + 32

					poly2_b nsp/3, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in, get(nsp)

					if bShowEdgeHotspots | (bShowJambExtHotspots & gs_trim_offs_in > EPS) then
						hotspot2 	px1, py1, 10013
!!!						text2 		px1, py1, "10013"
					endif
				endif

				if bPShapedRightOpening & not(bDrawRightSLBoard) then
					! ===== Inside Trim - Curved Walls - Jamb Extension - Lower Right =====

					px1RSL = rightWidth - gs_sidelight_WHole_width_right - gs_trim_width_in
					py1RSL = SQR(rBoard^2 - px1RSL^2)

					put px1,	py1,	gs_trim_offs_in > EPS,
						0,		0,		900,
						px1RSL, ySign * py1RSL, 3001,
						px1RSL, pyy1,	1,
						bpx10 + iSign * gs_trim_width_in / cos(alfaRightEdge), bpy10 - 1, 1,
						bpx10 + iSign * gs_trim_width_in / cos(alfaRightEdge), bpy10, 1

					bCasingIsInside = 1
					line2 px1RSL, pyy1, px1RSL + gs_trim_width_in, pyy1
					gosub "DrawSidelightCasingCurvedWall"
				endif


				if gs_tw_right_in > EPS & gs_trim_thk_in > EPS & gs_trim_show_cover_in then

					! ===== Inside Trim - Curved Walls - Casing - Rignt =====

					alfaRightTrimWidth	= LengtToArc * gs_tw_right_in

					if wallIsLeft then
						rot2 180 + abs(alfaRightIn) - alfaTrimWidthIn + alfaTrimOffsetIn
					else
						rot2 -abs(alfaRightIn) - alfaTrimWidthIn + alfaTrimOffsetIn
					endif

					poly2_b 6, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						0, rBoardEdge, 1 + 32,
						0, rBoard, 1 + 32,
						0,0, 901 + 32,
						rBoard * sin(-alfaRightTrimWidth), rBoard * cos(-alfaRightTrimWidth), 3001 + 32,
						rBoardEdge * sin(-alfaRightTrimWidth), rBoardEdge * cos(-alfaRightTrimWidth), 1 + 32,
						0, rBoardEdge, 3001 + 32

					if not(bShowEdgeHotspots) & bShowJambExtHotspots & gs_trim_offs_in < EPS then
						hotspot2 	0, rBoardEdge, 10013
!!!						text2 		0, rBoardEdge, "10013"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2 	rBoardEdge * sin(-alfaRightTrimWidth), rBoardEdge * cos(-alfaRightTrimWidth), 10033
!!!						text2		rBoardEdge * sin(-alfaRightTrimWidth), rBoardEdge * cos(-alfaRightTrimWidth), "10033"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	rBoardEdge * sin(-alfaRightTrimWidth), rBoardEdge * cos(-alfaRightTrimWidth), 10003
!!!						text2 		rBoardEdge * sin(-alfaRightTrimWidth), rBoardEdge * cos(-alfaRightTrimWidth), "10003"
					endif

					del 1
				endif

				if bPShapedRightOpening & not(bDrawRightSLBoard) then
					! ===== Inside Trim - Curved Walls - Casing - Lower Right =====

					px1	= px1 - iSign * gs_trim_offs_in * cos(alfaRightEdge)
					py1	= py1 - ySign * gs_trim_offs_in * sin(alfaRightEdge)
					px2	= px1 - iSign * gs_trim_thk_in * sin(alfaRightEdge)
					py2	= py1 + ySign * gs_trim_thk_in * cos(alfaRightEdge)

					px1RSL = rightWidth - gs_sidelight_WHole_width_right - gs_trim_width_in + gs_trim_offs_in
					py1RSL = SQR(rBoard^2 - px1RSL^2)
					px2RSL = px1RSL
					py2RSL = py1RSL + ySign * gs_trim_thk_in

					put px2, py2,	1,
						0,		0,		900,
						px2RSL, ySign * py2RSL, 3001,
						px1RSL, ySign * py1RSL, gs_trim_offs_in > EPS,
						px1, py1,	3001

					bCasingIsInside = 1
					gosub "DrawSidelightCasingCurvedWall"
				endif
			endif

			del 1
		else	! parallel cutting in curved wall
			py = WALL_THICKNESS - WIDO_SILL

			if not(gs_stack_left) then
				if gs_trim_width_in > EPS & bShowJambExtension & gs_trim_atframe_in = 0 then

!					 ===== Inside Trim - Curved Walls - Jamb Extension - Left =====

					thk = WIDO_FRAME_THICKNESS

					px1 = leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn
					px2 = px1 + gs_trim_width_in

					py1 = ySign * sqr (rBoard^2 - (px1) ^2) + WOD
					py2 = ySign * sqr (rBoard^2 - (px1 + gs_trim_width_in) ^2) + WOD

					if py1 > WIDO_FRAME_THICKNESS & py2 > WIDO_FRAME_THICKNESS then
						poly2_b 4, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
							px1,	thk,	1 + 32,
							px1,	py1,	1 + 32,
							px2,	py2,	1 + 32,
							px2,	thk,	1 + 32

						if bShowJambExtHotspots & gs_trim_offs_in > EPS then
							hotspot2 	px2, py2, 10012
!!!							text2 		px2, py2, "10012"
						endif
					endif
				endif
			endif

			if not(gs_stack_right) then
				if gs_trim_width_in > EPS & bShowJambExtension & gs_trim_atframe_in = 0 then

!					 ===== Inside Trim - Curved Walls - Jamb Extension - Right =====

					thk = WIDO_FRAME_THICKNESS

					px1 = rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn
					px2 = px1 - gs_trim_width_in

					py1 = ySign * sqr (rBoard^2 - (px1) ^2) + WOD
					py2 = ySign * sqr (rBoard^2 - (px1 - gs_trim_width_in) ^2) + WOD

					if py1 > WIDO_FRAME_THICKNESS & py2 > WIDO_FRAME_THICKNESS then
						poly2_b 4, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
							px1,	thk,	1 + 32,
							px1,	py1,	1 + 32,
							px2,	py2,	1 + 32,
							px2,	thk,	1 + 32

						if bShowJambExtHotspots & gs_trim_offs_in > EPS then
							hotspot2 	px2, py2, 10012
!!!							text2 		px2, py2, "10012"
						endif
					endif
				endif
			endif

			add2 0,WOD

			iSign = wallIsLeft - not(wallIsLeft)

			alfaLeftParallel 	= abs (asn ( (leftRevealPnts[idxBoardEndRevealLeft][1] + gs_trim_width_in) / rBoard))
			alfaRightParallel 	= abs (asn ( (rightRevealPnts[idxBoardEndRevealRight][1] - gs_trim_width_in) / rBoard))

			LengtToArc = iSign * 180 / rBoard / PI
			alfaTrimOffsetIn	= LengtToArc * gs_trim_offs_in
			alfaTrimWidthIn		= LengtToArc * gs_trim_width_in

			rBoardEdge = rBoard - iSign * gs_trim_thk_in

			if not(gs_stack_left) then

				if wallIsLeft then
					alfaLeftEdge = 180 + abs(alfaLeft)
				else
					alfaLeftEdge = -abs(alfaLeft)
				endif

				pyy1 = bpy3
				pyy2 = rBoard * cos(alfaLeftEdge)

				if gs_tw_left_in > EPS & gs_trim_thk_in > EPS then

					! ===== Inside Trim - Curved Walls - Casing - Left =====

					alfaLeftTrimWidth	= LengtToArc * gs_tw_left_in

					if wallIsLeft then
						rot2 180
					else
						rot2 0
					endif

					px1 =  ySign * (leftRevealPnts[idxBoardEndRevealLeft][1] + tolerOffsetLeftIn + gs_trim_width_in - gs_trim_offs_in)
					px2 = -ySign * (rBoard * sin(alfaLeftParallel - ySign * (alfaLeftTrimWidth + alfaTrimOffsetIn)) - tolerOffsetLeftIn)
					px3 = -ySign * (rBoardEdge * sin(alfaLeftParallel - ySign * (alfaLeftTrimWidth + alfaTrimOffsetIn)) - tolerOffsetLeftIn)

					py1 = sqr(rBoard^2 - px1^2)
					py2 = sqr(rBoard^2 - px2^2)
					py3 = sqr(rBoardEdge^2 - px3^2)
					py4 = sqr(rBoardEdge^2 - px1^2)

					poly2_b 6, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						px1, py4, 1 + 32,
						px1, py1, 1 + 32,
						0, 0, 901 + 32,
						px2, py2, 3001 + 32,
						px3, py3, 1 + 32,
						px1, py4, 3001 + 32

					if bShowJambExtHotspots & gs_trim_offs_in < EPS then
						hotspot2 	px1, py4, 10012
!!!						text2 		px1, py4, "10012"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2 	px2, py2, 10032
!!!						text2 		px2, py2, "10032"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	px3, py3, 10002
!!!						text2 		px3, py3, "10002"
					endif

					del 1
				endif
			endif

			if not(gs_stack_right) then

				if wallIsLeft then
					alfaRightEdge = -180 - abs(alfaRight)
				else
					alfaRightEdge = abs(alfaRight)
				endif

				pyy1 = bpy10
				pyy2 = rBoard * cos(alfaRightEdge)

				if gs_tw_right_in > EPS & gs_trim_thk_in > EPS then

					! ===== Inside Trim - Curved Walls - Casing - Rignt =====

					alfaRightTrimWidth	= LengtToArc * gs_tw_right_in

					if wallIsLeft then
						rot2 180
					else
						rot2 0
					endif

					px1 = ySign * (rightRevealPnts[idxBoardEndRevealRight][1] - tolerOffsetRightIn - gs_trim_width_in + gs_trim_offs_in)
					px2 = ySign * (rBoard * sin(alfaRightParallel - ySign * (alfaRightTrimWidth + alfaTrimOffsetIn)) - tolerOffsetRightIn)
					px3 = ySign * (rBoardEdge * sin(alfaRightParallel - ySign * (alfaRightTrimWidth + alfaTrimOffsetIn)) - tolerOffsetRightIn)

					py1 = sqr(rBoard^2 - px1^2)
					py2 = sqr(rBoard^2 - px2^2)
					py3 = sqr(rBoardEdge^2 - px3^2)
					py4 = sqr(rBoardEdge^2 - px1^2)

					poly2_b 6, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						px1, py4, 1 + 32,
						px1, py1, 1 + 32,
						0, 0, 901 + 32,
						px2, py2, 3001 + 32,
						px3, py3, 1 + 32,
						px1, py4, 3001 + 32

					if bShowJambExtHotspots & gs_trim_offs_in < EPS then
						hotspot2 	px1, py4, 10013
!!!						text2 		px1, py4, "10013"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2 	px2, py2, 10033
!!!						text2 		px2, py2, "10033"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	px3, py3, 10003
!!!						text2 		px3, py3, "10003"
					endif

					del 1
				endif
			endif

			del 1
		endif
	endif	! not(curvedWall)

	if gs_stack_left & gs_trim_stack_left = 1 then
		if (tolerOffsStackCasLeftIn + trinL - gs_trim_offs_in) > EPS & gs_trim_thk_in > EPS then

			! ===== Inside Trim - Straight Walls - Casing at Ganging - Left =====
			px1 = leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsStackCasLeftIn + trinL - gs_trim_offs_in
			px2 = leftRevealPnts[idxBoardEndRevealLeft-1][1]
			px3 = px2 - gs_trim_thk_in * tan(alfaLeft) * ySign

			py1 = leftRevealPnts[idxBoardEndRevealLeft-1][2]
			py2 = py1 + gs_trim_thk_in

			poly2_b 4, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
				px1,	py1,	1 + 32,
				px2,	py1,	0 + 32,
				px3,	py2,	1 + 32,
				px1,	py2,	1 + 32

			if bShowJambExtHotspots & gs_trim_offs_in < EPS then
				hotspot2 	px1, py2, 10012
!!!				text2 		px1, py2, "10012"
			endif
			if isWindow & bShowAddHotspots then
				hotspot2 	px2, py2, 10032
!!!				text2 		px2, py2, "10032"
			endif
			if not(isWindow) & bShowAddHotspots then
				hotspot2 	px2, py2, 10002
!!!				text2 		px2, py2, "10002"
			endif
		endif
	endif

	if gs_stack_right & gs_trim_stack_right = 1 then
		if (tolerOffsStackCasRightIn + trinR - gs_trim_offs_in) > EPS & gs_trim_thk_in > EPS then

			! ===== Inside Trim - Straight Walls - Casing at Ganging - Right =====

			px1 = rightRevealPnts[idxBoardEndRevealRight-1][1] - tolerOffsStackCasRightIn - trinR + gs_trim_offs_in
			px2 = rightRevealPnts[idxBoardEndRevealRight-1][1]
			px3 = px2 + gs_trim_thk_in * tan(alfaRight) * ySign

			py1 = rightRevealPnts[idxBoardEndRevealRight-1][2]
			py2 = py1 + gs_trim_thk_in

			poly2_b 4, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
				px1,	py1,	1 + 32,
				px2,	py1,	0 + 32,
				px3,	py2,	1 + 32,
				px1,	py2,	1 + 32

			if bShowJambExtHotspots & gs_trim_offs_in < EPS then
				hotspot2 	px1, py2, 10013
!!!				text2 		px1, py2, "10013"
			endif
			if isWindow & bShowAddHotspots then
				hotspot2 	px2, py2, 10033
!!!				text2 		px2, py2, "10033"
			endif
			if not(isWindow) & bShowAddHotspots then
				hotspot2 	px2, py2, 10003
!!!				text2 		px2, py2, "10003"
			endif
		endif
	endif
endif


! ==============================================================================
!	Draw Outside Trim
! ==============================================================================

if bDrawOutsideTrim then

	pen gs_trim_pen_cont_out
	set fill gs_trim_fill_out
	line_property 2

	! --- Draw Trim Outside ---
	if not(curvedWall) or (curvedWall & gs_trim_atframe_out =1) then

		if not(bLeftCornerFunction) & not(gs_stack_left) then

!			add2 widoLeftJamb,0

			if gs_trim_width_out > EPS & (((WIDO_SILL > EPS) & (gs_trim_show_cover_out)) | not(gs_trim_show_cover_out)) & bShowJambExtension & gs_trim_atframe_out = 0 then

				! ===== Outside Trim - Straight Walls - Jamb Extension - Left =====

				px1 = leftRevealPnts[idxSillStartRevealLeft][1] + tolerOffsetLeftOut
				px2 = px1 + gs_trim_width_out

				py1 = leftRevealPnts[idxSillStartRevealLeft][2] - gs_trim_jambext_nosing_out
				py2 = leftRevealPnts[idxSillEndRevealLeft][2]

				! --- Casing Set Back on Sides ---
				if casingSetBackOnSides_out > EPS then
					py2 = py2 - casingSetBackOnSides_out
				endif

				poly2_b 4, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
					px1,	py1,	1 + 32,
					px1,	py2,	1 + 32,
					px2,	py2,	1 + 32,
					px2,	py1,	1 + 32

				if bShowEdgeHotspots | (bShowJambExtHotspots & gs_trim_offs_out > EPS) then
					hotspot2 	px2, py1, 10010
!!!					text2 		px2, py1, "10010"
				endif

				if bPShapedLeftOpening & not(bDrawLeftSLSill) then

					! ===== Outside Trim - Straight Walls - Jamb Extension - Lower Left =====

					px1 = px2 + gs_sidelight_WHole_width_left

					set fill gs_trim_wallhole_fill_out

					poly2_b 4, 1+2+4+64, gs_trim_wallhole_pen_sl_fg_out, gs_trim_wallhole_pen_sl_bg_out,
						px2,	py1,	1,
						px2,	py2,	1,
						px1,	py2,	1,
						px1,	py1,	((gs_trim_offs_out > EPS) | not(gs_trim_show_cover_out))
				endif
			endif

			set fill gs_trim_fill_out
			if gs_trim_width_out > EPS & bShowJambExtension & gs_sectgar then

				! ===== Outside Trim - Straight Walls - Jamb Extension - Left - SectionGarage =====

				px1 = leftRevealPnts[idxBoardEndRevealLeft-1][1] + tolerOffsetLeftIn
				px2 = px1 + gs_trim_width_out

				py1 = leftRevealPnts[idxSillEndRevealLeft][2]
				py2 = leftRevealPnts[idxBoardEndRevealLeft][2]

				poly2_b 4, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
					px1,	py1,	1 + 32,
					px1,	py2,	1 + 32,
					px2,	py2,	1 + 32,
					px2,	py1,	1 + 32

				if bShowJambExtHotspots & gs_trim_offs_out > EPS then
					hotspot2 	px2, -WIDO_SILL, 10010
!!!					text2 		px2, -WIDO_SILL, "10010"
				endif
			endif

			if gs_tw_left_out > EPS & gs_trim_thk_out > EPS & gs_trim_show_cover_out then

				! ===== Outside Trim - Straight Walls - Casing - Left =====

				px1 = leftRevealPnts[idxSillStartRevealLeft][1] + tolerOffsetLeftOut + gs_trim_width_out - gs_trim_offs_out
				px2 = px1 - gs_tw_left_out

				if gs_trim_atframe_out = 0 then
					py1 = -WIDO_SILL
					py2 = -WIDO_SILL - gs_trim_thk_out
				else
					py1 = leftRevealPnts[2][2]
					py2 = py1 - gs_trim_thk_out
				endif

				poly2_b 4, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
					px1,	py1,	1 + 32,
					px2,	py1,	1 + 32,
					px2,	py2,	1 + 32,
					px1,	py2,	1 + 32

				if not(bShowEdgeHotspots) & bShowJambExtHotspots & gs_trim_offs_out < EPS then
					hotspot2 	px1, py2, 10010
!!!					text2 		px1, py2, "10010"
				endif
				if isWindow & bShowAddHotspots then
					hotspot2 	px2, py2, 10030
!!!					text2 		px2, py2, "10030"
				endif
				if not(isWindow) & bShowAddHotspots then
					hotspot2 	px2, py2, 10000
!!!					text2 		px2, py2, "10000"
				endif

				if bPShapedLeftOpening & not(bDrawLeftSLSill) then

					! ===== Outside Trim - Straight Walls - Casing - Lower Left =====
					px2 = px1
					px1 = px1 + gs_sidelight_WHole_width_left

					set fill gs_trim_wallhole_fill_out

					poly2_b 4, 1+2+4+64, gs_trim_wallhole_pen_sl_fg_out, gs_trim_wallhole_pen_sl_bg_out,
						px2,	py1,	1,
						px2,	py2,	1,
						px1,	py2,	1,
						px1,	py1,	gs_trim_offs_out > EPS
				endif
			endif

!			del 1
		endif

		set fill gs_trim_fill_out
		if not(bRightCornerFunction) & not(gs_stack_right) then

!			add2 -widoRightJamb,0

			if gs_trim_width_out > EPS & (((WIDO_SILL > EPS) & (gs_trim_show_cover_out)) | not(gs_trim_show_cover_out)) & bShowJambExtension & gs_trim_atframe_out = 0 then

				! ===== Outside Trim - Straight Walls - Jamb Extension - Right =====

				px1 = rightRevealPnts[idxSillStartRevealRight][1] - tolerOffsetRightOut
				px2 = px1 - gs_trim_width_out

				py1 = rightRevealPnts[idxSillStartRevealRight][2] - gs_trim_jambext_nosing_out
				py2 = rightRevealPnts[idxSillEndRevealRight][2]

				! --- Casing Set Back on Sides ---
				if casingSetBackOnSides_out > EPS then
					py2 = py2 - casingSetBackOnSides_out
				endif

				poly2_b 4, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
					px1,	py1,	1 + 32,
					px1,	py2,	1 + 32,
					px2,	py2,	1 + 32,
					px2,	py1,	1 + 32

				if bShowEdgeHotspots | (bShowJambExtHotspots & gs_trim_offs_out > EPS) then
					hotspot2 	px2, py1, 10011
!!!					text2 		px2, py1, "10011"
				endif

				if bPShapedRightOpening & not(bDrawRightSLSill) then

					! ===== Outside Trim - Straight Walls - Jamb Extension - Lower Right =====

					px1 = px2 - gs_sidelight_WHole_width_right

					set fill gs_trim_wallhole_fill_out

					poly2_b 4, 1+2+4+64, gs_trim_wallhole_pen_sl_fg_out, gs_trim_wallhole_pen_sl_bg_out,
						px2,	py1,	1,
						px2,	py2,	1,
						px1,	py2,	1,
						px1,	py1,	((gs_trim_offs_out > EPS) | not(gs_trim_show_cover_out))
				endif
			endif

			set fill gs_trim_fill_out
			if gs_trim_width_out > EPS & bShowJambExtension & gs_sectgar then

				! ===== Outside Trim - Straight Walls - Jamb Extension - Right - SectionGarage =====

				px1 = rightRevealPnts[idxBoardEndRevealright-1][1] - tolerOffsetrightIn
				px2 = px1 - gs_trim_width_out

				py1 = rightRevealPnts[idxSillEndRevealright][2]
				py2 = rightRevealPnts[idxBoardEndRevealright][2]

				poly2_b 4, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
					px1,	py1,	1 + 32,
					px1,	py2,	1 + 32,
					px2,	py2,	1 + 32,
					px2,	py1,	1 + 32

				if bShowJambExtHotspots & gs_trim_offs_out > EPS then
					hotspot2 	px2, -WIDO_SILL, 10010
!!!					text2 		px2, -WIDO_SILL, "10010"
				endif
			endif

			if gs_tw_right_out > EPS & gs_trim_thk_out > EPS & gs_trim_show_cover_out then

				! ===== Outside Trim - Straight Walls - Casing - Right =====

				px1 = rightRevealPnts[2][1] - tolerOffsetRightOut - gs_trim_width_out + gs_trim_offs_out
				px2 = px1 + gs_tw_right_out

				if gs_trim_atframe_out = 0 then
					py1 = -WIDO_SILL
					py2 = -WIDO_SILL - gs_trim_thk_out
				else
					py1 = leftRevealPnts[2][2]
					py2 = leftRevealPnts[2][2] - gs_trim_thk_out
				endif

				poly2_b 4, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
					 px1,	py1,	1 + 32,
					 px2,	py1,	1 + 32,
					 px2,	py2,	1 + 32,
					 px1,	py2,	1 + 32

				if not(bShowEdgeHotspots) & bShowJambExtHotspots & gs_trim_offs_out < EPS then
					hotspot2 	px1, py2, 10011
!!!					text2 		px1, py2, "10011"
				endif
				if isWindow & bShowAddHotspots then
					hotspot2 	px2, py2, 10031
!!!					text2 		px2, py2, "10031"
				endif
				if not(isWindow) & bShowAddHotspots then
					hotspot2 	px2, py2, 10001
!!!					text2 		px2, py2, "10001"
				endif

				if bPShapedRightOpening & not(bDrawRightSLSill) then

					! ===== Outside Trim - Straight Walls - Casing - Lower Right =====

					px2 = px1
					px1 = px1 - gs_sidelight_WHole_width_right

					set fill gs_trim_wallhole_fill_out

					poly2_b 4, 1+2+4+64, gs_trim_wallhole_pen_sl_fg_out, gs_trim_wallhole_pen_sl_bg_out,
						px2,	py1,	1,
						px2,	py2,	1,
						px1,	py2,	1,
						px1,	py1,	gs_trim_offs_out > EPS
				endif
			endif

!			del 1
		endif

	else	! not(curvedWall)

		if bParalellInCurvedWalls = 0 then		! Radial cutting
			! ===== Outside Trim - Curved Walls =====

			add2 0,WOD

			iSign = wallIsLeft - not(wallIsLeft)

			LengtToArc = iSign * 180 / rSill / PI
			alfaTrimOffsetOut	= LengtToArc * gs_trim_offs_out
			alfaTrimWidthOut	= LengtToArc * gs_trim_width_out

			alfaTolerOffsetLeftOut	= LengtToArc * tolerOffsetLeftOut
			alfaTolerOffsetRightOut	= LengtToArc * tolerOffsetRightOut

			rSillEdge = rSill + iSign * gs_trim_thk_out
			rSillJambNosing = rSill + iSign * gs_trim_jambext_nosing_out

			if not(gs_stack_left) then

				if wallIsLeft then
					alfaLeftEdge = 180 + abs(alfaLeft) - iSign * alfaLeftJamb
				else
					alfaLeftEdge = -abs(alfaLeft) - iSign * alfaLeftJamb
				endif

				pyy1 = spy1
				pyy2 = rSill * cos(alfaLeftEdge)

				if gs_trim_show_cover_out then
					px1 = rSill * sin(alfaLeftEdge - alfaTrimWidthOut)
					py1 = rSill * cos(alfaLeftEdge - alfaTrimWidthOut)
				else
					px1 = rSillJambNosing * sin(alfaLeftEdge - alfaTrimWidthOut)
					py1 = rSillJambNosing * cos(alfaLeftEdge - alfaTrimWidthOut)
				endif

				! --- Casing Set Back on Sides ---
				if casingSetBackOnSides_out > EPS then
					spx1 = spx1 - casingSetBackOnSides_out / tan(90 - alfaLeftEdge)
					pyy1 = pyy1 - casingSetBackOnSides_out
				endif

				if gs_trim_width_out > EPS & bShowJambExtension then

					! ===== Outside Trim - Curved Walls - Jamb Extension - Left =====

					put spx1,
						pyy1, 1 + 32

					if gs_IsCurved then
						xo = 0
						yo = 0
						ro = rSill - iSign * WIDO_SILL

						x1 = -iSign * gs_trim_width_out * cos(alfaLeftEdge)
						y1 =  iSign * gs_trim_width_out * sin(alfaLeftEdge)

						x2 = x1 + spx1
						y2 = y1 + spy1

						gosub 100

						put 0,0,901 + 32,
							xb, yb, 3001 + 32
					else

						! --- Casing Set Back on Sides ---
						if casingSetBackOnSides_out > EPS then
							spy1 = spy1 - casingSetBackOnSides_out
						endif

						put spx1 - iSign * gs_trim_width_out / cos(alfaLeftEdge),
							spy1, 1 + 32
					endif

					put px1, py1, 1 + 32,
						0,0, 901 + 32,
						rSill * sin(alfaLeftEdge), pyy2, 3001 + 32

					poly2_b nsp/3, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out, get(nsp)

					if bShowEdgeHotspots | (bShowJambExtHotspots & gs_trim_offs_out > EPS) then
						hotspot2 	px1, py1, 10010
!!!						text2 		px1, py1, "10010"
					endif
				endif

				if bPShapedLeftOpening & not(bDrawLeftSLSill) then
					! ===== Outside Trim - Curved Walls - Jamb Extension - Lower Left =====

					px1LSL = -leftWidth + gs_reveal_left_sL + gs_sidelight_WHole_width_left + gs_trim_width_out
					py1LSL = ABS(SQR(rSill^2 - px1LSL^2))

					put px1,	py1,	gs_trim_offs_out > EPS,
						0,		0,		900,
						px1LSL, ySign * py1LSL, 3001,
						px1LSL, spy1,	1,
						spx1 - tolerOffsetLeftOut - iSign * gs_trim_width_out / cos(alfaLeftEdge), spy1+1, 1,
						spx1 - tolerOffsetLeftIn - iSign * gs_trim_width_out / cos(alfaLeftEdge), spy1, 1

					bCasingIsInside = 0
					line2 px1LSL, spy1, px1LSL - gs_trim_width_out, spy1
					gosub "DrawSidelightCasingCurvedWall"
				endif


				if gs_tw_left_out > EPS & gs_trim_thk_out > EPS & gs_trim_show_cover_out then

					! ===== Outside Trim - Curved Walls - Casing - Left =====

					alfaLeftTrimWidth	= LengtToArc * gs_tw_left_out

					if wallIsLeft then
						rot2 180 - abs(alfaLeft) + alfaTrimWidthOut - alfaTrimOffsetOut + iSign * alfaLeftJamb
					else
						rot2 abs(alfaLeft) + alfaTrimWidthOut - alfaTrimOffsetOut + iSign * alfaLeftJamb
					endif

					poly2_b 6, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
						0, rSillEdge, 1 + 32,
						0, rSill, 1 + 32,
						0,0, 901 + 32,
						rSill * sin(alfaLeftTrimWidth), rSill * cos(alfaLeftTrimWidth), 3001 + 32,
						rSillEdge * sin(alfaLeftTrimWidth), rSillEdge * cos(alfaLeftTrimWidth), 1 + 32,
						0, rSillEdge, 3001 + 32

					if not(bShowEdgeHotspots) & bShowJambExtHotspots & gs_trim_offs_out < EPS then
						hotspot2 	0, rSillEdge, 10010
!!!						text2 		0, rSillEdge, "10010"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2 	rSillEdge * sin(alfaLeftTrimWidth), rSillEdge * cos(alfaLeftTrimWidth), 10030
!!!						text2 		rSillEdge * sin(alfaLeftTrimWidth), rSillEdge * cos(alfaLeftTrimWidth), "10030"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	rSillEdge * sin(alfaLeftTrimWidth), rSillEdge * cos(alfaLeftTrimWidth), 10000
!!!						text2 		rSillEdge * sin(alfaLeftTrimWidth), rSillEdge * cos(alfaLeftTrimWidth), "10000"
					endif

					del 1
				endif

				if bPShapedLeftOpening & not(bDrawLeftSLSill) then
					! ===== Outside Trim - Curved Walls - Casing - Lower Left =====

					px1	= px1 + iSign * gs_trim_offs_out * cos(alfaLeftEdge)
					py1	= py1 + ySign * gs_trim_offs_out * sin(alfaLeftEdge)
					px2	= px1 + iSign * gs_trim_thk_out * sin(alfaLeftEdge)
					py2	= py1 - ySign * gs_trim_thk_out * cos(alfaLeftEdge)

					px1LSL = -leftWidth + gs_reveal_left_sL + gs_sidelight_WHole_width_left + gs_trim_width_out - gs_trim_offs_out
					py1LSL = SQR(rSill^2 - px1LSL^2)
					px2LSL = px1LSL
					py2LSL = py1LSL - ySign * gs_trim_thk_out

					put px2, py2,	1,
						0,		0,		900,
						px2LSL, ySign * py2LSL, 3001,
						px1LSL, ySign * py1LSL, gs_trim_offs_out > EPS,
						px1, py1,	3001

					bCasingIsInside = 0
					gosub "DrawSidelightCasingCurvedWall"
				endif
			endif

			if not(gs_stack_right) then

				if wallIsLeft then
					alfaRightEdge = -180 - abs(alfaRight) + iSign * alfaRightJamb
				else
					alfaRightEdge = abs(alfaRight) + iSign * alfaRightJamb
				endif

				pyy1 = spy8
				pyy2 = rSill * cos(alfaRightEdge)

				if gs_trim_show_cover_out then
					px1 = rSill * sin(alfaRightEdge + alfaTrimWidthOut)
					py1 = rSill * cos(alfaRightEdge + alfaTrimWidthOut)
				else
					px1 = rSillJambNosing * sin(alfaRightEdge + alfaTrimWidthOut)
					py1 = rSillJambNosing * cos(alfaRightEdge + alfaTrimWidthOut)
				endif

				! --- Casing Set Back on Sides ---
				if casingSetBackOnSides_out > EPS then
					spx8 = spx8 - casingSetBackOnSides_out / tan(90 - alfaRightEdge)
					pyy1 = pyy1 - casingSetBackOnSides_out
				endif

				if gs_trim_width_out > EPS & bShowJambExtension then

					! ===== Outside Trim - Curved Walls - Jamb Extension - Right =====

					put spx8,
						pyy1, 1 + 32

					if gs_IsCurved then
						xo = 0
						yo = 0
						ro = rSill - iSign * WIDO_SILL

						x1 = iSign * gs_trim_width_out * cos(alfaRightEdge)
						y1 = gs_trim_width_out * sin(alfaRightEdge)

						x2 = x1 + spx8
						y2 = y1 + spy8

						gosub 100

						put 0,0,901 + 32,
							xa, ya, 3001 + 32
					else

						! --- Casing Set Back on Sides ---
						if casingSetBackOnSides_out > EPS then
							spy8 = spy8 - casingSetBackOnSides_out
						endif

						put spx8 + iSign * gs_trim_width_out / cos(alfaRightEdge),
							spy8, 1 + 32
					endif

					put px1, py1, 1 + 32,
						0,0, 901 + 32,
						rSill * sin(alfaRightEdge), pyy2, 3001 + 32

					poly2_b nsp/3, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out, get(nsp)

					if bShowEdgeHotspots | (bShowJambExtHotspots & gs_trim_offs_out > EPS) then
						hotspot2 	px1, py1, 10011
!!!						text2 		px1, py1, "10011"
					endif
				endif

				if bPShapedRightOpening & not(bDrawRightSLSill) then
					! ===== Outside Trim - Curved Walls - Jamb Extension - Lower Right =====

					px1RSL = rightWidth - gs_reveal_right_sR - gs_sidelight_WHole_width_right - gs_trim_width_out
					py1RSL = ABS(SQR(rSill^2 - px1RSL^2))

					put px1,	py1,	gs_trim_offs_out > EPS,
						0,		0,		900,
						px1RSL, ySign * py1RSL, 3001,
						px1RSL, spy8,	1,
						spx8 + iSign * gs_trim_width_out / cos(alfaRightEdge), spy8+1, 1,
						spx8 + iSign * gs_trim_width_out / cos(alfaRightEdge), spy8, 1

					bCasingIsInside = 0
					line2 px1RSL, spy8, px1RSL + gs_trim_width_out, spy8
					gosub "DrawSidelightCasingCurvedWall"
				endif


				if gs_tw_right_out > EPS & gs_trim_thk_out > EPS & gs_trim_show_cover_out then

					! ===== Outside Trim - Curved Walls - Casing - Right =====

					alfaRightTrimWidth	= LengtToArc * gs_tw_right_out

					if wallIsLeft then
						rot2 180 + abs(alfaRight) - alfaTrimWidthOut + alfaTrimOffsetOut - iSign * alfaRightJamb
					else
						rot2 -abs(alfaRight) - alfaTrimWidthOut + alfaTrimOffsetOut - iSign * alfaRightJamb
					endif

					poly2_b 6, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
						0, rSillEdge, 1 + 32,
						0, rSill, 1 + 32,
						0,0, 901 + 32,
						rSill * sin(-alfaRightTrimWidth), rSill * cos(-alfaRightTrimWidth), 3001 + 32,
						rSillEdge * sin(-alfaRightTrimWidth), rSillEdge * cos(-alfaRightTrimWidth), 1 + 32,
						0, rSillEdge, 3001 + 32

					if not(bShowEdgeHotspots) & bShowJambExtHotspots & gs_trim_offs_out < EPS then
						hotspot2 	0, rSillEdge, 10011
!!!						text2 		0, rSillEdge, "10011"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2 	rSillEdge * sin(-alfaRightTrimWidth), rSillEdge * cos(-alfaRightTrimWidth), 10031
!!!						text2 		rSillEdge * sin(-alfaRightTrimWidth), rSillEdge * cos(-alfaRightTrimWidth), "10031"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	rSillEdge * sin(-alfaRightTrimWidth), rSillEdge * cos(-alfaRightTrimWidth), 10001
!!!						text2 		rSillEdge * sin(-alfaRightTrimWidth), rSillEdge * cos(-alfaRightTrimWidth), "10001"
					endif

					del 1
				endif
				if bPShapedRightOpening & not(bDrawRightSLSill) then
					! ===== Outside Trim - Curved Walls - Casing - Lower Right =====

					px1	= px1 - iSign * gs_trim_offs_out * cos(alfaRightEdge)
					py1	= py1 - ySign * gs_trim_offs_out * sin(alfaRightEdge)
					px2	= px1 + iSign * gs_trim_thk_out * sin(alfaRightEdge)
					py2	= py1 - ySign * gs_trim_thk_out * cos(alfaRightEdge)

					px1RSL = rightWidth - gs_reveal_right_sR - gs_sidelight_WHole_width_right - gs_trim_width_out + gs_trim_offs_out
					py1RSL = SQR(rSill^2 - px1RSL^2)
					px2RSL = px1RSL
					py2RSL = py1RSL - ySign * gs_trim_thk_out

					put px2, py2,	1,
						0,		0,		900,
						px2RSL, ySign * py2RSL, 3001,
						px1RSL, ySign * py1RSL, gs_trim_offs_out > EPS,
						px1, py1,	3001

					bCasingIsInside = 0
					gosub "DrawSidelightCasingCurvedWall"
				endif
			endif

			del 1
		else		! Parallel cutting in curved wall
			if not(gs_stack_left) then

				add2 widoLeftJamb,0

				if gs_trim_width_out > EPS & WIDO_SILL > EPS & bShowJambExtension & gs_trim_atframe_out = 0 then

					! ===== Outside Trim - Straight Walls - Jamb Extension - Left =====

					px1 = -leftWidth
					px2 = px1 + gs_trim_width_out

					py1 = leftRevealPnts[idxSillStartRevealLeft][2]
					py2 = ySign * sqr (rSill^2 - (leftRevealPnts[idxSillStartRevealLeft][1] + gs_trim_width_out) ^2) + WOD

					poly2_b 4, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
						px1,	0,		1 + 32,
						px1,	py1,	1 + 32,
						px2,	py2,	1 + 32,
						px2,	0,		1 + 32

					if bShowJambExtHotspots & gs_trim_offs_out > EPS then
						hotspot2 	px2, -WIDO_SILL, 10010
!!!						text2 		px2, -WIDO_SILL, "10010"
					endif
				endif

				del 1
			endif

			if not(gs_stack_right) then

				add2 -widoRightJamb, 0

				if gs_trim_width_out > EPS & WIDO_SILL > EPS & bShowJambExtension & gs_trim_atframe_out = 0 then

					! ===== Outside Trim - Curved Walls - Jamb Extension - Right =====

					px1 = rightWidth
					px2 = px1 - gs_trim_width_out

					py1 = rightRevealPnts[idxSillStartRevealRight][2]
					py2 = ySign * sqr (rSill^2 - (rightRevealPnts[idxSillStartRevealRight][1] - gs_trim_width_out) ^2) + WOD

					poly2_b 4, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
						px1,	0,		1 + 32,
						px1,	py1,	1 + 32,
						px2,	py2,	1 + 32,
						px2,	0,		1 + 32

					if bShowJambExtHotspots & gs_trim_offs_out > EPS then
						hotspot2 	px2, py2, 10010
!!!						text2 		px2, py2, "10010"
					endif
				endif

				del 1
			endif


			add2 0,WOD

			iSign = wallIsLeft - not(wallIsLeft)

			alfaLeftParallel 	= abs (asn ( (leftRevealPnts[idxSillStartRevealLeft][1] + gs_trim_width_out) / rSill))
			alfaRightParallel 	= abs (asn ( (rightRevealPnts[idxSillStartRevealRight][1] - gs_trim_width_out) / rSill))

			LengtToArc = iSign * 180 / rSill / PI
			alfaTrimOffsetOut	= LengtToArc * gs_trim_offs_out
			alfaTrimWidthOut	= LengtToArc * gs_trim_width_out

			alfaTolerOffsetLeftOut	= LengtToArc * tolerOffsetLeftOut
			alfaTolerOffsetRightOut	= LengtToArc * tolerOffsetRightOut

			rSillEdge = rSill + iSign * gs_trim_thk_out

			if not(gs_stack_left) then

				if wallIsLeft then
					alfaLeftEdge = 180 + abs(alfaLeft) - iSign * alfaLeftJamb
				else
					alfaLeftEdge = -abs(alfaLeft) - iSign * alfaLeftJamb
				endif

				pyy1 = spy1
				pyy2 = rSill * cos(alfaLeftEdge)

				if gs_tw_left_out > EPS & gs_trim_thk_out > EPS then

					! ===== Outside Trim - Curved Walls - Casing - Left =====

					alfaLeftTrimWidth	= LengtToArc * gs_tw_left_out

					if wallIsLeft then
						rot2 180 !- abs(alfaLeft) + alfaTrimWidthOut - alfaTrimOffsetOut + iSign * alfaLeftJamb
					else
						rot2 0	!abs(alfaLeft) + alfaTrimWidthOut - alfaTrimOffsetOut + iSign * alfaLeftJamb
					endif

					px1 = ySign * (leftRevealPnts[idxSillStartRevealLeft][1] + tolerOffsetLeftOut + gs_trim_width_out - gs_trim_offs_out)
					px2 = - ySign * rSill * sin(alfaLeftParallel - ySign * (-alfaTolerOffsetLeftOut + alfaLeftTrimWidth + alfaTrimOffsetOut))
					px3 = - ySign * rSillEdge * sin(alfaLeftParallel - ySign * (-alfaTolerOffsetLeftOut + alfaLeftTrimWidth + alfaTrimOffsetOut))

					py1 = sqr (rSill^2 - px1^2)
					py2 = rSill * cos(alfaLeftParallel - ySign * (-alfaTolerOffsetLeftOut + alfaLeftTrimWidth + alfaTrimOffsetOut))
					py3 = rSillEdge * cos(alfaLeftParallel - ySign * (-alfaTolerOffsetLeftOut + alfaLeftTrimWidth + alfaTrimOffsetOut))
					py4 = sqr (rSillEdge^2 - px1^2)

					poly2_b 6, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						px1, py4, 1 + 32,
						px1, py1, 1 + 32,
						0, 0, 901 + 32,
						px2, py2, 3001 + 32,
						px3, py3, 1 + 32,
						px1, py4, 3001 + 32

					if bShowJambExtHotspots & gs_trim_offs_out < EPS then
						hotspot2 	px1, py4, 10010
!!!						text2 		px1, py4, "10010"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2 	px2, py2, 10030
!!!						text2 		px2, py2, "10030"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	px3, py3, 10000
!!!						text2 		px3, py3, "10000"
					endif

					del 1
				endif
			endif

			if not(gs_stack_right) then

				if wallIsLeft then
					alfaRightEdge = -180 - abs(alfaRight) + iSign * alfaRightJamb
				else
					alfaRightEdge = abs(alfaRight) + iSign * alfaRightJamb
				endif

				pyy1 = spy8
				pyy2 = rSill * cos(alfaRightEdge)

				if gs_tw_right_out > EPS & gs_trim_thk_out > EPS then

					! ===== Outside Trim - Curved Walls - Casing - Right =====

					alfaRightTrimWidth	= LengtToArc * gs_tw_right_out

					if wallIsLeft then
						rot2 180 !+ abs(alfaRight) - alfaTrimWidthOut + alfaTrimOffsetOut - iSign * alfaRightJamb
					else
						rot2 0	!-abs(alfaRight) - alfaTrimWidthOut + alfaTrimOffsetOut - iSign * alfaRightJamb
					endif

					px1 = ySign * (rightRevealPnts[idxSillStartRevealRight][1] - tolerOffsetRightOut - gs_trim_width_out + gs_trim_offs_out)
					px2 = ySign * rSill * sin(alfaRightParallel - ySign * (-alfaTolerOffsetRightOut + alfarightTrimWidth + alfaTrimOffsetOut))
					px3 = ySign * rSillEdge * sin(alfarightParallel - ySign * (-alfaTolerOffsetRightOut + alfarightTrimWidth + alfaTrimOffsetOut))

					py1 = sqr (rSill^2 - px1^2)
					py2 = rSill * cos(alfarightParallel - ySign * (-alfaTolerOffsetRightOut + alfarightTrimWidth + alfaTrimOffsetOut))
					py3 = rSillEdge * cos(alfarightParallel - ySign * (-alfaTolerOffsetRightOut + alfarightTrimWidth + alfaTrimOffsetOut))
					py4 = sqr (rSillEdge^2 - px1^2)

					poly2_b 6, 1+2+4+32, gs_trim_pen_fg_in, gs_trim_pen_bg_in,
						px1, py4, 1 + 32,
						px1, py1, 1 + 32,
						0, 0, 901 + 32,
						px2, py2, 3001 + 32,
						px3, py3, 1 + 32,
						px1, py4, 3001 + 32

					if bShowJambExtHotspots & gs_trim_offs_out < EPS then
						hotspot2 	px1, py4, 10011
!!!						text2 		px1, py4, "10011"
					endif
					if isWindow & bShowAddHotspots then
						hotspot2 	px2, py2, 10031
!!!						text2 		px2, py2, "10031"
					endif
					if not(isWindow) & bShowAddHotspots then
						hotspot2 	px3, py3, 10001
!!!						text2 		px3, py3, "10001"
					endif

					del 1
				endif
			endif

			del 1

		endif

	endif	! not(curvedWall)

	if gs_stack_left then
		if (tolerOffsStackCasLeftOut + trim_offs_out_modify - gs_trim_offs_out) > EPS & gs_trim_thk_out > EPS & gs_trim_stack_left = 1 then

			! ===== Outside Trim - Casing at Ganging - Left =====

			px1 = leftRevealPnts[2][1]  + tolerOffsStackCasLeftOut + trim_offs_out_modify - gs_trim_offs_out
			px2 = leftRevealPnts[2][1]
			px3 = px2 + gs_trim_thk_out * tan(alfaLeft) * ySign

			py1 = leftRevealPnts[2][2]
			py2 = leftRevealPnts[2][2] - gs_trim_thk_out

			poly2_b 4, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
				px1,	py1,	1 + 32,
				px2,	py1,	0 + 32,
				px3,	py2,	1 + 32,
				px1,	py2,	1 + 32

			if bShowJambExtHotspots & gs_trim_offs_out < EPS then
				hotspot2 	px1, py2, 10010
!!!				text2		px1, py2, "10010"
			endif
			if isWindow & bShowAddHotspots then
				hotspot2 	px2, py2, 10030
!!!				text2 		px2, py2, "10030"
			endif
			if not(isWindow) & bShowAddHotspots then
				hotspot2 	px2, py2, 10000
!!!				text2 		px2, py2, "10000"
			endif
		endif
	endif

	if not(bRightCornerFunction) & gs_stack_right then
		if (tolerOffsStackCasRightOut + trim_offs_out_modify - gs_trim_offs_out) > EPS & gs_trim_thk_out > EPS & gs_trim_stack_right = 1 then

			! ===== Outside Trim - Casing at Ganging - Right =====

			px1 = rightRevealPnts[2][1] - tolerOffsStackCasRightOut - trim_offs_out_modify + gs_trim_offs_out
			px2 = rightRevealPnts[2][1]
			px3 = px2 - gs_trim_thk_out * tan(alfaRight) * ySign

			py1 = rightRevealPnts[2][2]
			py2 = rightRevealPnts[2][2] - gs_trim_thk_out

			poly2_b 4, 1+2+4+32, gs_trim_pen_fg_out, gs_trim_pen_bg_out,
				 px1,	py1,	1 + 32,
				 px2,	py1,	0 + 32,
				 px3,	py2,	1 + 32,
				 px1,	py2,	1 + 32

			if bShowJambExtHotspots & gs_trim_offs_out < EPS then
				hotspot2 	px1, py2, 10011
!!!				text2 		px1, py2, "10011"
			endif
			if isWindow & bShowAddHotspots then
				hotspot2 	px2, py2, 10031
!!!				text2 		px2, py2, "10031"
			endif
			if not(isWindow) & bShowAddHotspots then
				hotspot2 	px2, py2, 10001
!!!				text2 		px2, py2, "10001"
			endif
		endif
	endif
endif


! Restore the saved parameter buffer ===========================================

call "LoadQueue_kmod" parameters savedQueueValues = savedQueueValues


! ==============================================================================
!	Close PolyOperations Add-on Channel
! ==============================================================================
if bTShapedOpening & curvedWall & (bDrawInsideTrim | bDrawOutsideTrim) then
	CLOSEADDONSCOPE ch
endif



! ==============================================================================
 end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
! ==============================================================================


! ==============================================================================
! === SUBROUTINES
! ==============================================================================

! ==============================================================================
!		Cross points of circle (xo,yo,ro) and line (x1,y1, x2,y2)
! ------------------------------------------------------------------------------
! Input parameters:
!	xo, yo:		Circle center
!	ro:			Circle radius
!	x1, y1:		Line endpoint 1
!	x2, y2:		Line endpoint 2
! Output parameters:
!	state:		Status (0, 1, 2)
!				  0: No intersection
!				  1: One intersection
!				  2: Two intersections
!	xa, ya:		Cross point 1
!	xb, yb:		Cross point 2
! ==============================================================================

100:
	x1 = x1 - xo
	y1 = y1 - yo

	x2 = x2 - xo
	y2 = y2 - yo

	kf = (y2 - y1) / (x2 - x1)
	ad = 1 + kf * kf
	bd = 2 * y1 * kf - 2 * x1 * kf * kf
	cd = y1 * y1 - 2 * x1 * y1 * kf + x1 * x1 * kf * kf - ro * ro

	if bd * bd - 4 * ad * cd < 0 then
		state = 0
		xa = 0
		ya = 0
		xb = 0
		yb = 0
	else
		xa = (-bd + sqr(bd * bd - 4 * ad * cd)) / (2 * ad)
		ya = y1 + (xa - x1) * kf
		xb = (-bd - sqr(bd * bd - 4 * ad * cd)) / (2 * ad)
		yb = y1 + (xb - x1) * kf

		if abs(xa - xb) < EPS then
			state = 1
		else
			state = 2
		endif
	endif

	xa = xa + xo
	ya = ya + yo
	xb = xb + xo
	yb = yb + yo
return


! ==============================================================================
! Direction Angle
! ------------------------------------------------------------------------------
! Input variables:
!	vx, vy:				vector
!
! Returned variables:
!	alpha:				selected intersection point
! ==============================================================================

103:

if abs(vx) < EPS & abs(vy) < EPS then
	angle = 0
	return
endif

if abs(vx) < EPS then
	if vy > 0 then
		angle = 90
	else
		angle = 270
	endif
else
	angle = atn(vy / vx)
	if vx >= 0 then
		if angle < 0 then
			angle = angle + 360
		endif
	else
		angle = 180 + angle
	endif
endif

return


! ==============================================================================
! Rotate 2D points around curved wall's center
! ------------------------------------------------------------------------------
! Input variables:
!	x,y:				2D point
!	WOD:				"wido orig dist" in the wallhole coordinate system
!	alpha:				rotation angle
! Returned variables:
!	x,y:				rotated 2D point
! ==============================================================================

1000:
	xo = x
	yo = y - WOD
	x = xo * cos(signWallIsLeft * alpha) - yo * sin(signWallIsLeft * alpha)
	y = xo * sin(signWallIsLeft * alpha) + yo * cos(signWallIsLeft * alpha) + WOD
return




"DrawSidelightCasingCurvedWall":
! ==============================================================================
! Cuts Casing polygon with the facade plane of door frame in Curved Walls
! and also draws it
! ------------------------------------------------------------------------------
! ==============================================================================

	! Store casing polygon -------------------------------------------------------

	dim vertArr1[][3]
	dim inhEdgeInfos1[]
	defaultInhEdgeInfo = 0


	gosub "Convert GDL poly2_ to AC polygons"

	nContours1 = 1
	dim contArr1[]
	contArr1[1] = nVertices1 + 1

	if nVertices1 >= 2 then
		preparefunction ch, "Store", "CasingPoly", nVertices1, nContours1, vertArr1, contArr1, defaultInhEdgeInfo, inhEdgeInfos1
	endif


	! ------------------------------------------------------------------------------
	! Cut "CasingPoly" polygon with halfplane
	! ------------------------------------------------------------------------------

	if bCasingIsInside = 1 then
		PREPAREFUNCTION  ch, "HalfPlaneParams", "", 0, -1, WOD - WIDO_FRAME_THICKNESS
		set fill gs_trim_wallhole_fill_in
		ActCasingFillPen 		= gs_trim_wallhole_pen_sl_fg_in
		ActCasingFillBackPen	= gs_trim_wallhole_pen_sl_bg_in
	else
		PREPAREFUNCTION  ch, "HalfPlaneParams", "", 0, 1, -WOD
		set fill gs_trim_wallhole_fill_out
		ActCasingFillPen 		= gs_trim_wallhole_pen_sl_fg_out
		ActCasingFillBackPen	= gs_trim_wallhole_pen_sl_bg_out
	endif


	dim resPolyIDArray[]
	numPoly = CALLFUNCTION (ch, "PolyCut", "CasingPoly", resPolyIDArray)

	! ------------------------------------------------------------------------------
	! Draw resulting polygons
	! ------------------------------------------------------------------------------

	for jk = 1 to numPoly
		polygonID = resPolyIDArray[jk]

		gosub "GetResultingACPolygon"

		if nsp > 0 then
			poly2_b  nsp/3, 1+2+4+64, ActCasingFillPen, ActCasingFillBackPen,
				get(nsp)
		endif
	next jk


	PREPAREFUNCTION ch, "EmptyContainer", "mySourceContainer", ""
	PREPAREFUNCTION ch, "EmptyContainer", "myDestinationContainer", ""
return



"Convert GDL poly2_ to AC polygons":
! ==============================================================================
! Converts GDL poly2_b command values to AC polygon values
! ------------------------------------------------------------------------------
! ==============================================================================

idx = 1
inhEdgeInfosLast = 0

for i=1 to nsp/3
	px = get(1)
	py = get(1)
	ps = round_int (get(1))


	if idx > 1 then
		bSkipThisVertex = (abs(px - vertarr1[1][1]) < EPS & abs(py - vertarr1[1][2]) < EPS)	! Skip this vertex if this is a closing one
	else
		bSkipThisVertex = 0
	endif

	if ps < 900 | ps >= 1000 then	! Skip state '900'
		if not(bSkipThisVertex) then
			vertarr1[idx][1] = px
			vertarr1[idx][2] = py
		endif
		if ps >= 3000 & ps < 4000 then
			if idx > 1 then
				vx = vertarr1[idx-1][1] - 0
				vy = vertarr1[idx-1][2] !- WOD
				gosub 103	! Direction Angle
				savedAngle = angle

				vx = px - 0
				vy = py !- WOD
				gosub 103	! Direction Angle

				vertarr1[idx-1][3] = angle - savedAngle
				if not(bSkipThisVertex) then
					inhEdgeInfos1[idx] = bittest(ps, 0)
				endif
			endif
		else
			if not(bSkipThisVertex) then
				vertarr1[idx][3] = 0
				inhEdgeInfos1[idx] = bittest(ps, 0)
			endif
		endif
		if not(bSkipThisVertex) then
			idx = idx + 1
		endif
	endif
next i
nVertices1 = vardim1(vertarr1)

return


"GetResultingACPolygon":
! ==============================================================================
! Get GDL Polygon
! ------------------------------------------------------------------------------
! Input variables:
!	polygonID:			Polygon index
!
! Returned variables:
!	GDL stack:			GDL polygon
! ==============================================================================

	dim resVertices[]
	numVertices = callfunction(ch, "GETVERTICES", polygonID, resVertices)
	numVertices = numVertices / 3

	dim contArr[]
	numContours = callfunction(ch, "GETCONTOURENDS", polygonID, contArr)

	dim inhEdgeInfos[]
	numEdges = callfunction(ch, "GetInhEdgeInfos", polygonID, inhEdgeInfos)

	for contIndex = 1 to numContours

		if contIndex = 1 then
			begIdx = 0
		else
			begIdx = contArr[contIndex] - 1
		endif
		if contIndex = numContours then
			endIdx = numVertices - 1
		else
			endIdx = contArr[contIndex + 1] - 2
		endif

		bClosed = 0
		bStartWithLast = 0

		index = endIdx * 3
		ac2gdl_lpx = resVertices[index + 1]
		ac2gdl_lpy = resVertices[index + 2]
		ac2gdl_lpa = resVertices[index + 3]
		prevEdgeInfo = round_int(inhEdgeInfos[endIdx + 1])

		if abs(ac2gdl_lpa) > EPS then
			put ac2gdl_lpx, ac2gdl_lpy, 1
			bStartWithLast = 1
		endif

		for vertIndex = begIdx to endIdx
			index = vertIndex * 3
			ac2gdl_px = resVertices[index + 1]
			ac2gdl_py = resVertices[index + 2]
			ac2gdl_pa = resVertices[index + 3]
			edgeInfo	= round_int(inhEdgeInfos[vertIndex + 1])

			if vertIndex = begIdx then
				if bStartWithLast then
					ac2gdl_spx = ac2gdl_lpx
					ac2gdl_spy = ac2gdl_lpy
				else
					ac2gdl_spx = ac2gdl_px
					ac2gdl_spy = ac2gdl_py
				endif
			endif

			if abs(ac2gdl_lpa) > EPS then
				ac2gdl_mx = (ac2gdl_px + ac2gdl_lpx) / 2
				ac2gdl_my = (ac2gdl_py + ac2gdl_lpy) / 2
				ac2gdl_ratio = 1 / 2 / tan (ac2gdl_lpa / 2)

				ac2gdl_cx = ac2gdl_mx - ac2gdl_ratio * (ac2gdl_py - ac2gdl_lpy)	! Arc center
				ac2gdl_cy = ac2gdl_my + ac2gdl_ratio * (ac2gdl_px - ac2gdl_lpx)
				ac2gdl_rad = sqr((ac2gdl_cx - ac2gdl_px)^2 + (ac2gdl_cy - ac2gdl_py)^2)

				vx = ac2gdl_px - ac2gdl_cx
				vy = ac2gdl_py - ac2gdl_cy
				gosub 103	! Direction Angle
				alpha = angle

				vx = ac2gdl_lpx - ac2gdl_cx
				vy = ac2gdl_lpy - ac2gdl_cy
				gosub 103	! Direction Angle
				beta = angle

				put ac2gdl_cx,	ac2gdl_cy,	900,
					0,			ac2gdl_lpa,	4000 + edgeInfo

				if GLOB_CONTEXT <> 5 & (prevEdgeInfo > 0) then
					line_property 0
					arc2 ac2gdl_cx,	ac2gdl_cy, ac2gdl_rad, min(alpha,beta), max(alpha,beta)
				endif
			else
				if GLOB_CONTEXT <> 5 & (prevEdgeInfo > 0) then
					line_property 0
					line2 ac2gdl_lpx, ac2gdl_lpy, ac2gdl_px, ac2gdl_py
				endif
			endif

			if vertIndex > begIdx & abs(ac2gdl_spx - ac2gdl_px) < EPS & abs(ac2gdl_spy - ac2gdl_py) < EPS then
				put ac2gdl_px, ac2gdl_py, -1
				bClosed = 1
			else
				if vertIndex < endIdx | not(bStartWithLast) then
					put ac2gdl_px, ac2gdl_py, edgeInfo
				endif
			endif

			ac2gdl_lpx = ac2gdl_px
			ac2gdl_lpy = ac2gdl_py
			ac2gdl_lpa = ac2gdl_pa
			prevEdgeInfo = edgeInfo
		next vertIndex

		if not(bClosed) & numContours > 1 then	! Close the polygon if it has holes
			put ac2gdl_spx, ac2gdl_spy, -1
		endif

	next contIndex
return



