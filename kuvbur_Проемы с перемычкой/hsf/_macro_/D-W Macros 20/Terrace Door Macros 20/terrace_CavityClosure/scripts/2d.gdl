
! Contact person: <NJ>

! ==============================================================================
! This macro draws the cavity closure and turned plasters
! ------------------------------------------------------------------------------
! Input parameters:
!	refWidth:				reference width in curved walls (length)
!	leftWidth:				wallhole's side distance from the origin at the left side (length)
!	rightWidth:				wallhole's side distance from the origin at the right side (length)
!	bWndCurved:				is the window made of curved panels (0 / 1)
!	bParalellInCurvedWalls:	is the wallhole parallel in curved walls (0 / 1)
!	bDrawObjContourIn:
!	bDrawObjContourOut:
!	bDrawFrameContourLeft:	Draw the wall contour border on window frame at the left side (0 / 1)
!	bDrawFrameContourRight:	Draw the wall contour border on window frame at the left side (0 / 1)
!	bWindowSymbolAtMiddle:	Is the window symbol appears always on the middle of the wall (CHI special) (0 / 1)
! Corner Window Parameters -----------------------------------------------------
!	bCornerWindow:			is the hole a corner window? (0 / 1)
!	ac_corner_angle:		angle between connected walls in case of Corner Window (angle)
!	ac_diff_con_wall_thk:	indicates the equality thickness of the two connected walls (0 / 1)
!	ac_con_wall_thk:		thickness of the connected wall in case of Corner Window (length)
! Wallhole Cover Fill Parameter (only for polygon walls ) ----------------------
!	fillWallHole:			wallhole cover fill (only for polygon walls) (fill)
!	penWallHoleFg:			wallhole cover fill pen (only for polygon walls) (pen)
!	penWallHoleBg:			wallhole cover fill background pen (only for polygon walls) (pen)
!	penWallContour:			wallhole contour pen (only for polygon walls) (pen)
!	iWallContourLine		Identifies the wall cotours to be drawn
!								(integer; 1 = none, 2 = inside, 3 = outside, 4 = both)
!	gs_wcont_line_in:		type of the wall contour line inside (line type)
!	gs_wcont_line_out:		type of the wall contour line outside (line type)
! Oversize Parameters ----------------------------------------------------------
!	gs_left_oversize:		Left opening oversize (only for polygon walls) (length)
!	gs_right_oversize:		Right opening oversize (only for polygon walls) (length)
! Reveal Parameters ------------------------------------------------------------
!	iRevealType:			reveal type (integer)
!								0 = no Reveal
!								1 = Positive Reveal
!								2 = Negative Reveal
!								3 = Slanted Reveal
!								4 =
!	gs_reveal_left:			left reveal size (length)
!	gs_reveal_right:		left reveal size (length)
!	gs_reveal_left_angle:	left reveal angle in case of slanted reveal (angle)
!	gs_reveal_right_angle:	right reveal angle in case of slanted reveal (angle)
! Stacked Window Parameters ----------------------------------------------------
!	gs_stack_left:			align to door/window on left side (0 / 1)
!	gs_stack_right:			align to door/window on right side (0 / 1)
! Cavity Closure Parameters ----------------------------------------------------
!	gs_useWallFinishSkin:	use wall finish component (0 / 1)
!	gs_maxPlasterThk:		wall skin classification parameter (length)
!							consider Skin as Plaster if it is thinner this
!	gs_bAutoTurnIn:			automatic plaster return at Outside Face (0 / 1)
!	gs_bAutoTurnOut:		automatic plaster return at Inside Face (0 / 1)
!	gs_bOverIn:				number of turned plaster skins at Outside Face (integer)
!	gs_bOverOut:			number of turned plaster skins at Inside Face (integer)
!	gs_closureMethod:		controls the method being used for internal cavity closure
!	bCavityCloserLeft:		show cavity closure at left side
!	bCavityCloserRight:		show cavity closure at right side
!	gs_nTurn:				number of turned skins in traditional mode (integer value)
!	gs_bJoint:				is there an insulation strip at the front
!							 side of the turned skins (0 / 1) [MODE1]
!	gs_thkJoint:			strip thickness (length)
!	gs_penJoint:			strip contour pen (pen)
!	gs_ltJoint:				strip contour linetype (line type)
!	gs_fillJoint:			strip fill type (fill)
!	gs_penJointFg:			strip fill pen (pen)
!	gs_penJointBg:			strip fill background pen (pen)
!	gs_widthPlug:			heat insulation profile width (length) [MODE2]
!	gs_penPlug:				profile contour pen (pen)
!	gs_ltPlug:				profile contour linetype (line type)
!	gs_fillPlug:			profile fill type (fill)
!	gs_penPlugFg:			profile fill pen (pen)
!	gs_penPlugBg:			profile fill background pen (pen)
! ==============================================================================

slantLength = 0

if GLOB_CONTEXT = 6 | GLOB_CONTEXT = 46 then end	! List
if GLOB_CONTEXT = 5 then	! Object Settings Dialog
	bDrawObjContourIn	= 0
	bDrawObjContourOut	= 0
	bSettingsDialog		= 1
else
	bSettingsDialog		= 0
endif


! === save the current parameter buffer
dim savedQueueValues[]
call "SaveQueue" parameters returned_parameters savedQueueValues


! ==============================================================================
! Cut Wallhole with WALLHOLE2
! ==============================================================================

if WIDO_REVEAL_SIDE then
	mul2 1,-1
	add2 0,WIDO_FRAME_THICKNESS
endif

! ==============================================================================

! wallThkRefSide:	Wall side distance from the origo at the Outside Face
! wallThkOppSide:	Wall side distance from the origo at the Inside Face

if AC_WallType = 2 then		! Polygon Wall
	if WIDO_REVEAL_SIDE then
		wallThkRefSide	= max(0, -boundMinY) + 0.05
		wallThkOppSide	= max(0,  boundMaxY) + 0.05
	else
		wallThkRefSide	= max(0,  boundMaxY) + 0.05
		wallThkOppSide	= max(0, -boundMinY) + 0.05
	endif
else
	wallThkRefSide	= max(0, WIDO_SILL, bulgeHeightRefSide) + 0.2
	wallThkOppSide	= max(0, WALL_THICKNESS - WIDO_SILL, bulgeHeightOppSide) + 0.2
endif


! ==============================================================================
! Wallhole Polygon - No Reveal
!	for all wall types
! ==============================================================================

if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then

	! Curved Walls
	if not(bParalellInCurvedWalls) then
		dxOLeft	 =  iArchSign * wallThkOppSide * tan(leftAlfa)
		dxORight =  iArchSign * wallThkOppSide * tan(rightAlfa)
		dxRLeft	 = -iArchSign * wallThkRefSide * tan(leftAlfa)
		dxRRight = -iArchSign * wallThkRefSide * tan(rightAlfa)
	endif

	! Trapezoid Walls
	wallThkOppSide = wallThkOppSide + max(leftWidth, rightWidth) * tan(abs(WALL_INCL))

	if curvedWall then
		dxLeft		= bArchSign * WIDO_FRAME_THICKNESS * tan(leftAlfa)
		dxRight		= bArchSign * WIDO_FRAME_THICKNESS * tan(rightAlfa)
	else
		dxLeft 		= 0
		dxRight		= bCornerWindow * 2.0		! 2.0 m is large enought
	endif

	put	-leftWidth  - dxLeft  + dxOLeft,	-wallThkOppSide,	1,
		-leftWidth  - dxLeft  + dxRLeft,	 wallThkRefSide,	1,
		 rightWidth + dxRight - dxRRight,	 wallThkRefSide,	1,
		 rightWidth + dxRight - dxORight,	-wallThkOppSide,	1

	if curvedWall & bWndCurved then
		sxL = -rSillLine * sin(leftAlfa)
		syL = iArchSign * (-abs(WOD) + rSillLine * cos(leftAlfa))
	else
		sxL = -leftWidth - dxLeft
		syL = 0
	endif
	bxL = sxL
	byL = syL

	if curvedWall & bWndCurved then
		sxR = rSillLine * sin(rightAlfa)
		syR = iArchSign * (-abs(WOD) + rSillLine * cos(rightAlfa))
	else
		sxR = rightWidth + dxRight
		syR = 0
	endif
	bxR = sxR
	byR = syR
endif


! ==============================================================================
! Wallhole Polygon - Positive Reveal, Negative Reveal, Slanted Reveal
!	for all wall types
! ==============================================================================

if iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE | iRevealType = REVEAL_SLANTED then

	if iRevealType = REVEAL_POSITIVE then		! Positive Reveal
		if SYMB_ROTANGLE > EPS exor SYMB_MIRRORED then
			leftJamb	= WIDO_RIGHT_JAMB
			rightJamb	= WIDO_LEFT_JAMB
		else
			leftJamb	= WIDO_LEFT_JAMB
			rightJamb	= WIDO_RIGHT_JAMB
		endif
		leftJamb	= gs_reveal_left
		rightJamb	= gs_reveal_right

		! Trapezoid Walls
		wallThkOppSide = wallThkOppSide + max(leftWidth, rightWidth) * tan(abs(WALL_INCL))
	endif
	if iRevealType = REVEAL_NEGATIVE then
		leftJamb	= -gs_reveal_left
		rightJamb	= -gs_reveal_right

		! Trapezoid Walls
		wallThkOppSide = wallThkOppSide + max(leftWidth, rightWidth) * tan(abs(WALL_INCL))
	endif
	if iRevealType = REVEAL_SLANTED then
		leftJamb	= gs_reveal_left
		rightJamb	= gs_reveal_right
		leftAngle	= gs_reveal_left_angle
		rightAngle	= gs_reveal_right_angle
	endif

	if gs_stack_left then
		leftJamb	= 0
		leftAngle	= -signWallIsLeft * leftAlfa
	endif
	if gs_stack_right then
		rightJamb	= 0
		rightAngle	= -signWallIsLeft * rightAlfa
	endif

	alfaLeftJamb	= leftJamb  * ArcLengthSillToAngle
	alfaRightJamb	= rightJamb * ArcLengthSillToAngle

	if not(bParalellInCurvedWalls) then
		dxOLeft	 =  iArchSign * wallThkOppSide * tan(leftAlfa)
		dxORight =  iArchSign * wallThkOppSide * tan(rightAlfa)
		dxRLeft	 = -iArchSign * wallThkRefSide * tan(leftAlfa  - alfaLeftJamb)
		dxRRight = -iArchSign * wallThkRefSide * tan(rightAlfa - alfaRightJamb)
	endif

	if iRevealType = REVEAL_SLANTED then
		dxOLeft		= -wallThkOppSide * tan(leftAngle)
		dxORight	= -wallThkOppSide * tan(rightAngle)

		! Curved Walls
		if curvedWall then

			dyR = iArchSign * (-abs(WOD) + rSillLine * cos(rightAlfa))
			dxR = rightWidth - rSillLine * sin(rightAlfa)

			dyL = iArchSign * (-abs(WOD) + rSillLine * cos(leftAlfa))
			dxL = leftWidth - rSillLine * sin(leftAlfa)

			if bArchSign then
				xo = 0
				yo = -WOD
				ro = rBoard

				if bWndCurved then
					x1 = -rSillLine * sin(leftAlfa)
					y1 = iArchSign * (-abs(WOD) + rSillLine * cos(leftAlfa))
					x2 = x1 + sin(leftAngle)
					y2 = y1 + cos(leftAngle)
				else
					x1 = -leftWidth
					y1 = 0
					x2 = -leftWidth + dxOLeft
					y2 = -wallThkOppSide
				endif

				gosub 101	! Circle - Line intersection

				if state = 0 then
					hitYLeft = -WOD
				endif
				if state = 1 then
					hitYLeft = ya
				endif
				if state = 2 then
					hitYLeft = max(ya, yb)
				endif

				xo = 0
				yo = -WOD
				ro = rBoard

				if bWndCurved then
					x1 = rSillLine * sin(rightAlfa)
					y1 = iArchSign * (-abs(WOD) + rSillLine * cos(rightAlfa))
					x2 = x1 - sin(rightAngle)
					y2 = y1 + cos(rightAngle)
				else
					x1 = rightWidth
					y1 = 0
					x2 = rightWidth - dxORight
					y2 = -wallThkOppSide
				endif

				gosub 101	! Circle - Line intersection

				if state = 0 then
					hitYRight = -WOD
				endif
				if state = 1 then
					hitYRight = ya
				endif
				if state = 2 then
					hitYRight = max(ya, yb)
				endif

				wallThkOppSide	= -min(hitYLeft, hitYRight)
			endif

			if bWndCurved then
				dxOLeft		= (-wallThkOppSide - dyL) * tan(leftAngle)  + dxL
				dxORight	= (-wallThkOppSide - dyR) * tan(rightAngle) + dxR
			else
				dxOLeft		= (-wallThkOppSide) * tan(leftAngle)
				dxORight	= (-wallThkOppSide) * tan(rightAngle)
			endif
		endif

		! Trapezoid Walls
		if abs(WALL_INCL) > EPS then

			x11 = 0
			y11 = WIDO_SILL - WALL_THICKNESS
			x12 = 1
			y12 = y11 - iInclDir * tan(WALL_INCL)

			x21 = -leftWidth
			y21 = 0
			x22 = -leftWidth + dxOLeft
			y22 = -wallThkOppSide

			gosub 100		! Line - Line intersection

			if state = 1 then
				hitYLeft = cy
			endif

			x11 = 0
			y11 = WIDO_SILL - WALL_THICKNESS
			x12 = 1
			y12 = y11 - iInclDir * tan(WALL_INCL)

			x21 = rightWidth
			y21 = 0
			x22 = rightWidth - dxORight
			y22 = -wallThkOppSide

			gosub 100		! Line - Line intersection

			if state = 1 then
				hitYRight = cy
			endif

			wallThkOppSide	= -min(hitYLeft, hitYRight)
			dxOLeft			= -wallThkOppSide * tan(leftAngle)
			dxORight		= -wallThkOppSide * tan(rightAngle)
		endif
	endif

	if curvedWall then
		! Jamb arch length projection onto the X axis
		if bParalellInCurvedWalls then
			dxLeftJamb	= leftWidth  - rSillLine * sin(leftAlfa  - alfaLeftJamb)
			dxRightJamb	= rightWidth - rSillLine * sin(rightAlfa - alfaRightJamb)
		else
			dxLeftJamb	= leftWidth  - iArchSign * WOD * tan(leftAlfa  - alfaLeftJamb)
			dxRightJamb	= rightWidth - iArchSign * WOD * tan(rightAlfa - alfaRightJamb)
		endif
		dxLeft		= bArchSign * (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS * tan(leftAlfa)
		dxRight		= bArchSign * (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS * tan(rightAlfa)
	else
		dxLeftJamb	= leftJamb
		dxRightJamb	= rightJamb - bCornerWindow * 2.0		! 2.0 m is large enought
		dxLeft 		= 0
		dxRight		= bCornerWindow * 2.0					! 2.0 m is large enought
	endif

	rSillLine = rSill - iArchSign * WIDO_SILL	! Radius of the reveal at the Sill depth

	if curvedWall & bWndCurved then
		put	 0,										 WIDO_ORIG_DIST,	901,
			-leftWidth - dxLeft + dxOLeft,			-wallThkOppSide,	1

		if iRevealType = REVEAL_SLANTED & not(bWndCurved) then
			put -leftWidth - dxLeft,				 0,					1
		else
			put -rSillLine * sin(leftAlfa),					iArchSign * (-abs(WOD) + rSillLine * cos(leftAlfa)),					1
		endif
		put	-rSillLine * sin(leftAlfa  - alfaLeftJamb),		iArchSign * (-abs(WOD) + rSillLine * cos(leftAlfa  - alfaLeftJamb)),	1,
			-leftWidth  + dxLeftJamb  + dxRLeft,	 wallThkRefSide,	1,
			 rightWidth - dxRightJamb - dxRRight,	 wallThkRefSide,	1,
			 rSillLine * sin(rightAlfa  - alfaRightJamb),	iArchSign * (-abs(WOD) + rSillLine * cos(rightAlfa  - alfaRightJamb)),	1
		if iRevealType = REVEAL_SLANTED & not(bWndCurved) then
			put rightWidth + dxRight,				 0,					1
		else
			put rSillLine * sin(rightAlfa),					iArchSign * (-abs(WOD) + rSillLine * cos(rightAlfa)),					1
		endif
		put	 rightWidth + dxRight - dxORight,		-wallThkOppSide,	1

		sxL = -rSillLine * sin(leftAlfa  - alfaLeftJamb)
		syL = iArchSign * (-abs(WOD) + rSillLine * cos(leftAlfa  - alfaLeftJamb))
		if iRevealType = REVEAL_SLANTED & not(bWndCurved) then
			bxL = -leftWidth - dxLeft
			byL = 0
		else
			bxL = -rSillLine * sin(leftAlfa)
			byL = iArchSign * (-abs(WOD) + rSillLine * cos(leftAlfa))
		endif

		sxR = rSillLine * sin(rightAlfa  - alfaRightJamb)
		syR = iArchSign * (-abs(WOD) + rSillLine * cos(rightAlfa  - alfaRightJamb))
		if iRevealType = REVEAL_SLANTED & not(bWndCurved) then
			bxR = rightWidth + dxRight
			byR = 0
		else
			bxR = rSillLine * sin(rightAlfa)
			byR = iArchSign * (-abs(WOD) + rSillLine * cos(rightAlfa))
		endif
	else
		put	-leftWidth - dxLeft + dxOLeft,			-wallThkOppSide,	1,
			-leftWidth - dxLeft,					 0,					1,
			-leftWidth  + dxLeftJamb,				 0,					1,
			-leftWidth  + dxLeftJamb  + dxRLeft,	 wallThkRefSide,	1,
			 rightWidth - dxRightJamb - dxRRight,	 wallThkRefSide,	1,
			 rightWidth - dxRightJamb,				 0,					1,
			 rightWidth + dxRight,					 0,					1,
			 rightWidth + dxRight - dxORight,		-wallThkOppSide,	1

		sxL = -leftWidth  + dxLeftJamb
		syL = 0
		bxL = -leftWidth - dxLeft
		byL = 0

		sxR = rightWidth - dxRightJamb
		syR = 0
		bxR = rightWidth + dxRight
		byR = 0
	endif
else
	! no reveal
	alfaLeftJamb	= 0
	alfaRightJamb	= 0
endif

if GLOB_CONTEXT = 5 then
	poly2_b nsp/3, 2+4+64, 0,-1, get(nsp)
else
	wallhole2 nsp/3, 2, 0,-1, 0, 0, 0, get(nsp)
endif


! ==============================================================================
! Wall Contour Lines and Background Fill - Polygonal Walls
! ==============================================================================

! Defines of PolygonOperations macro ===========================================

OPERATION_CONVERT_POLYGON_AC_TO_GDL		= 1
OPERATION_POINT_INSIDE_POLYGON			= 2
OPERATION_LINE_LINE_INTERSECTION		= 3
OPERATION_SEGMENT_SEGMENT_INTERSECTION	= 4
OPERATION_INTERSECT_POLYGONS			= 5
OPERATION_CALCULATE_POLYGON_AREA		= 6
OPERATION_REVERSE_POLYGON				= 7

INPUT_NO			 = 0
INPUT_FROM_PARAMETER = 1
INPUT_FROM_GDL_STACK = 2

OUTPUT_TO_PARAMETER = 1
OUTPUT_TO_GDL_STACK = 2


if WIDO_REVEAL_SIDE then
	trAddY = -WIDO_FRAME_THICKNESS
	trMulY = -1
	sillDepth = abs(boundMinY - 1)
else
	trAddY =  0
	trMulY =  1
	sillDepth = boundMaxY + 1
endif

if AC_WallType = 2 & not(bSettingsDialog) then

	del top

	leftW	 = leftWidth
	rightW	 = rightWidth
	bContour = 1
	gosub 5000	! Get Wallhole Polygon

! Display cutting polygon ----- [
!dim ddd[][3]
!numPoints = nsp/3
!for ii=1 to numPoints
!	ddd[ii][1] = get(1)
!	ddd[ii][2] = get(1)
!	ddd[ii][3] = get(1)
!next ii
!for ii=1 to vardim1(ddd)
!	put ddd[ii][1], ddd[ii][2], 1
!next ii
!pen 20
!line_type 1
!line_property LINE_PROPERTY_CONTOUR
!poly2_b nsp/3, 1+4, penWallHoleFg, penWallHoleBg, get(nsp)
!for ii=1 to vardim1(ddd)
!	put ddd[ii][1], ddd[ii][2], ddd[ii][3]
!next ii
! ] ----- Display cutting polygon

	call "terrace_PolygonOperations",
		parameters	opcode 		= OPERATION_INTERSECT_POLYGONS,
					opmethod	= 3,
					edgeAttribute = 33,
					srcPolygon1	= INPUT_FROM_PARAMETER,
					polygon1	= AC_WallContourPolygon,
					srcPolygon2	= INPUT_FROM_GDL_STACK,
					result		= OUTPUT_TO_GDL_STACK

	pen WALL_SECT_PEN
	line_type WALL_LINETYPE
	line_property LINE_PROPERTY_CONTOUR

	if AC_Hole_Display_Option = 5 then		! 5 = Overhead All
		poly2_b nsp/3, 1+4, penWallHoleFg, penWallHoleBg, use(nsp)		! Wall Contour
	else
		if not(gs_stack_left) then
			if gs_left_oversize < EPS then
				line2 bxL,byL + trAddY, bxL - (iRevealType = REVEAL_SLANTED) * WIDO_FRAME_THICKNESS * tan(gs_reveal_left_angle),-trMulY * WIDO_FRAME_THICKNESS + trAddY
			endif
			if iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_SLANTED then
				if abs(bxL - sxL) > gs_left_oversize then
					line2 bxL,byL + trAddY, sxL,syL + trAddY
				endif
			endif
		endif

		if not(gs_stack_right) then
			if gs_right_oversize < EPS then
				line2 bxR,byR + trAddY, bxR + (iRevealType = REVEAL_SLANTED) * WIDO_FRAME_THICKNESS * tan(gs_reveal_right_angle),-trMulY * WIDO_FRAME_THICKNESS + trAddY
			endif
			if iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_SLANTED then
				if abs(bxR - sxR) > gs_right_oversize then
					line2 bxR,byR + trAddY, sxR,syR + trAddY
				endif
			endif
		endif
	endif

	numPoints = nsp/3
	for ii=1 to numPoints
		if ii = 1 then
			x1 = get(1)
			y1 = get(1)
			s1 = get(1)
			firstX = x1
			firstY = y1
			firstS = s1
		endif
		if ii = numPoints then
			x2 = firstX
			y2 = firstY
			s2 = firstS
		else
			x2 = get(1)
			y2 = get(1)
			s2 = get(1)
		endif

		if bittest(s1, 0) then
			wallline2 x1,y1, x2,y2

			if bDrawObjContourIn & bDrawObjContourOut then
				line2 x1,y1, x2,y2
			else
				if (bDrawObjContourOut & not(WIDO_REVEAL_SIDE)) | (bDrawObjContourIn & WIDO_REVEAL_SIDE) then
					if y1 > EPS | y2 > EPS then
						if y1 < -EPS | y2 < -EPS then	! need to split this line
							if y1 < -EPS then
								if abs(y2 + WIDO_REVEAL_SIDE * WIDO_FRAME_THICKNESS) > EPS then
									line2 x2,y2, x1,-WIDO_REVEAL_SIDE * WIDO_FRAME_THICKNESS
								endif
							else
								if abs(y1 + WIDO_REVEAL_SIDE * WIDO_FRAME_THICKNESS) > EPS then
									line2 x1,y1, x2,-WIDO_REVEAL_SIDE * WIDO_FRAME_THICKNESS
								endif
							endif
						else
							line2 x1,y1, x2,y2
						endif
					endif
				endif
				if (bDrawObjContourIn & not(WIDO_REVEAL_SIDE)) | (bDrawObjContourOut & WIDO_REVEAL_SIDE) then
					if y1 < -EPS | y2 < -EPS then
						if y1 > EPS | y2 > EPS then	! need to split this line
							if y1 > EPS then
								if abs(y2 + WIDO_REVEAL_SIDE * WIDO_FRAME_THICKNESS) > EPS then
									line2 x2,y2, x2,-WIDO_REVEAL_SIDE * WIDO_FRAME_THICKNESS
								endif
							else
								if abs(y1 + WIDO_REVEAL_SIDE * WIDO_FRAME_THICKNESS) > EPS then
									line2 x1,y1, x1,-WIDO_REVEAL_SIDE * WIDO_FRAME_THICKNESS
								endif
							endif
						else
							line2 x1,y1, x2,y2
						endif
					endif
				endif
			endif
		endif

		x1 = x2
		y1 = y2
		s1 = s2
	next ii

! Back Fill and Wall Contours ==================================================

	if (iWallContourLine > 1 | fillWallHole > 0) then
		pen penWallContour
		line_property LINE_PROPERTY_GENERIC
		fill fillWallHole

		if (iWallContourLine = 4 & gs_wcont_line_in = gs_wcont_line_out) | (iWallContourLine <= 1 & fillWallHole > 0) then

			leftW	 = leftWidth  - not(gs_stack_left)  * gs_left_oversize
			rightW	 = rightWidth - not(gs_stack_right) * gs_right_oversize
			bContour = 0
			gosub 5000

			if iWallContourLine <= 1 then
				opmethod = 1	! set staus 0 (invisible) for all edges
			else
				opmethod = 4	! edges from polygon1 with 0, edges from polygon2 with 1 status
			endif

			call "terrace_PolygonOperations",
				parameters	opcode 		= OPERATION_INTERSECT_POLYGONS,
							opmethod	= opmethod,
							edgeAttribute = 1,
							srcPolygon1	= INPUT_FROM_PARAMETER,
							polygon1	= AC_WallContourPolygon,
							srcPolygon2	= INPUT_FROM_GDL_STACK,
							result		= OUTPUT_TO_GDL_STACK

			line_type gs_wcont_line_out

			drawindex 30
			poly2_b nsp/3, 1 + 4 + 2 * (GLOB_CONTEXT = 5) + 64, penWallHoleFg, penWallHoleBg, use(nsp)					! Contour lines
			wallhole2 nsp/3, 1 + 2 + 4, penWallHoleFg, penWallHoleBg, 0, 0, 0, get(nsp)		! Back Fill
			drawindex 20
		else
			if iWallContourLine = 2 | iWallContourLine = 4 | fillWallHole > 0 then	! Inside

				leftW	 = leftWidth  - not(gs_stack_left)  * gs_left_oversize
				rightW	 = rightWidth - not(gs_stack_right) * gs_right_oversize
				bContour = 0
				gosub 5000

				if iWallContourLine = 2 | iWallContourLine = 4 then
					opmethod1 = 4	! edges from polygon1 with 0, edges from polygon2 with 1 status
					opmethod2 = 0	! edges with original status
				else
					opmethod1 = 1	! set staus 0 (invisible) for all edges
					opmethod2 = 1
				endif

				call "terrace_PolygonOperations",
					parameters	opcode 		= OPERATION_INTERSECT_POLYGONS,
								opmethod	= opmethod1,
								edgeAttribute = 1,
								srcPolygon1	= INPUT_FROM_PARAMETER,
								polygon1	= AC_WallContourPolygon,
								srcPolygon2	= INPUT_FROM_GDL_STACK,
								result		= OUTPUT_TO_GDL_STACK

				fullWidth = leftWidth + rightWidth
				dim splitPolygon[4][3]
					splitPolygon[1][1] = boundMinX - fullWidth:	splitPolygon[1][2] = 0.01
					splitPolygon[2][1] = boundMaxX + fullWidth:	splitPolygon[2][2] = 0.01
					splitPolygon[3][1] = boundMaxX + fullWidth:	splitPolygon[3][2] = boundMinY - 1
					splitPolygon[4][1] = boundMinX - fullWidth:	splitPolygon[4][2] = boundMinY - 1

				call "terrace_PolygonOperations",
					parameters	opcode 		= OPERATION_INTERSECT_POLYGONS,
								opmethod	= opmethod2,
								edgeAttribute = 1,
								srcPolygon1	= INPUT_FROM_PARAMETER,
								polygon1	= splitPolygon,
								srcPolygon2	= INPUT_FROM_GDL_STACK,
								result		= OUTPUT_TO_GDL_STACK

				line_type gs_wcont_line_in

				if nsp > 6 then
					drawindex 30
					poly2_b nsp/3, 1+2+4+64, penWallHoleFg, penWallHoleBg, get(nsp)		! Back Fill
					drawindex 20
				else
					for i=1 to nsp: n=get(1): next i
				endif
			endif

			if iWallContourLine = 3 | iWallContourLine = 4 | fillWallHole > 0 then	! Outside

				leftW	 = leftWidth  - not(gs_stack_left)  * gs_left_oversize
				rightW	 = rightWidth - not(gs_stack_right) * gs_right_oversize
				bContour = 0
				gosub 5000

				if iWallContourLine = 3 | iWallContourLine = 4 then
					opmethod1 = 4	! edges from polygon1 with 0, edges from polygon2 with 1 status
					opmethod2 = 0	! edges with original status
				else
					opmethod1 = 1	! set staus 0 (invisible) for all edges
					opmethod2 = 1
				endif

				call "terrace_PolygonOperations",
					parameters	opcode 		= OPERATION_INTERSECT_POLYGONS,
								opmethod	= opmethod1,
								edgeAttribute = 1,
								srcPolygon1	= INPUT_FROM_PARAMETER,
								polygon1	= AC_WallContourPolygon,
								srcPolygon2	= INPUT_FROM_GDL_STACK,
								result		= OUTPUT_TO_GDL_STACK

				fullWidth = leftWidth + rightWidth
				dim splitPolygon[4][3]
					splitPolygon[1][1] = boundMinX - fullWidth:	splitPolygon[1][2] = 0
					splitPolygon[2][1] = boundMaxX + fullWidth:	splitPolygon[2][2] = 0
					splitPolygon[3][1] = boundMaxX + fullWidth:	splitPolygon[3][2] = boundMaxY + 1
					splitPolygon[4][1] = boundMinX - fullWidth:	splitPolygon[4][2] = boundMaxY + 1

				call "terrace_PolygonOperations",
					parameters	opcode 		= OPERATION_INTERSECT_POLYGONS,
								opmethod	= opmethod2,
								edgeAttribute = 1,
								srcPolygon1	= INPUT_FROM_PARAMETER,
								polygon1	= splitPolygon,
								srcPolygon2	= INPUT_FROM_GDL_STACK,
								result		= OUTPUT_TO_GDL_STACK

				line_type gs_wcont_line_out

				if nsp > 6 then
					drawindex 30
					poly2_b nsp/3, 1+2+4+64, penWallHoleFg, penWallHoleBg, get(nsp)		! Back Fill
					drawindex 20
				else
					for i=1 to nsp: n=get(1): next i
				endif

			endif
		endif
	endif

! Hotspots =====================================================================

	leftW	 = leftWidth  - not(gs_stack_left)  * gs_left_oversize
	rightW	 = rightWidth - not(gs_stack_right) * gs_right_oversize
	bContour = 1
	gosub 5000

	call "terrace_PolygonOperations",
		parameters	opcode 		= OPERATION_INTERSECT_POLYGONS,
					opmethod	= 5,
					edgeAttribute = 1,
					srcPolygon1	= INPUT_FROM_PARAMETER,
					polygon1	= AC_WallContourPolygon,
					srcPolygon2	= INPUT_FROM_GDL_STACK,
					result		= OUTPUT_TO_GDL_STACK

	polyUnID = 11200	! Hotspot unID for polygonal wall corner points

	for i=1 to nsp/3
		px = get(1)
		py = get(1)
		ps = get(1)

		if ((px <> 0) | (py <> 0))  &  (i <> 1) then
			hotspot2 px,py, polyUnID
			polyUnID = polyUnID + 1
		endif
	next i

endif


! ==============================================================================
! Cavity Closure
! ==============================================================================

dim skinCummThkRef[]	! Cummulative skin thickness from the Outside Face (48 + 1 skins)) [VBAttr::MaxSkinNumber + 1]
dim skinCummThkOpp[]	! Cummulative skin thickness from the Inside Face (48 + 1 skins) [VBAttr::MaxSkinNumber + 1]

cumRefThk = 0
cumOppThk = 0

if bCompositeWall then
	for i=1 to WALL_SKINS_NUMBER
		idx = i: gosub 10	! Get proper index

		cumRefThk = cumRefThk + WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
		skinCummThkRef[idx] = cumRefThk

		idx = WALL_SKINS_NUMBER + 1 - idx	! reorder
		cumOppThk = cumOppThk + WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
		skinCummThkOpp[idx] = cumOppThk
	next i
endif


! ==============================================================================

thkSkinTurnIn = 0
if nSkinTurnIn > 0 then
	idx = nSkinTurnIn: gosub 10	! Get proper index
	thkSkinTurnIn = skinCummThkRef[idx]
endif
thkFinishSkinTurnIn = 0
if nFinishSkinTurnIn > 0 then
	idx = nFinishSkinTurnIn: gosub 10	! Get proper index
	thkFinishSkinTurnIn = skinCummThkRef[idx]
endif

thkSkinTurnOut = 0
if nSkinTurnOut > 0 then
	idx = WALL_SKINS_NUMBER - nSkinTurnOut + 1: gosub 10	! Get proper index
	thkSkinTurnOut = skinCummThkOpp[idx]
endif
thkFinishSkinTurnOut = 0
if nFinishSkinTurnOut > 0 then
	idx = WALL_SKINS_NUMBER - nFinishSkinTurnOut + 1: gosub 10	! Get proper index
	thkFinishSkinTurnOut = skinCummThkOpp[idx]
endif


! ==============================================================================
! Wall Contour Lines
! ==============================================================================

if AC_WallType <> 2 then
	if not(gs_stack_left) then

		sideSign	= -1
		distanceX	= leftWidth
		alfaX		= leftAlfa
		alfaJamb	= alfaLeftJamb
		revealWidth	= gs_reveal_left
		revealAngle	= gs_reveal_left_angle
		bDrawFrameContour	= bDrawFrameContourLeft
		bx = bxL
		by = byL
		sx = sxL
		sy = syL

		gosub 4000		! Wall End Lines
	endif

	if not(gs_stack_right) & not(bCornerWindow) then

		sideSign	= 1
		distanceX	= rightWidth
		alfaX		= rightAlfa
		alfaJamb	= alfaRightJamb
		revealWidth	= gs_reveal_right
		revealAngle	= gs_reveal_right_angle
		bDrawFrameContour	= bDrawFrameContourRight
		bx = bxR
		by = byR
		sx = sxR
		sy = syR

		gosub 4000		! Wall End Lines
	endif
endif


! ==============================================================================

del top

if curvedWall then
	if WIDO_REVEAL_SIDE then
		mul2 1,-1
		add2 0,WIDO_FRAME_THICKNESS
	endif
else
	if WIDO_REVEAL_SIDE then add2 0,-WIDO_FRAME_THICKNESS
	if SYMB_ROTANGLE > EPS then mul2 1, -1
	if wallIsLeft then
		add2 0, -WIDO_SILL
	else
		add2 0, -WALL_THICKNESS + WIDO_SILL
	endif
	if reorder then
		mul2 1,-1
		add2 0, -WALL_THICKNESS
	endif
endif


if bCompositeWall then

! Left Cavity Closure ==========================================================

	if curvedWall then
		numTrans = 0
	else
		mul2 -1, 1
		numTrans = 1
	endif

	sideSign	= -1
	distanceX	= leftWidth
	alfaX		= leftAlfa
	alfaJamb	= alfaLeftJamb
	revealWidth	= gs_reveal_left
	revealAngle	= gs_reveal_left_angle
	bx = bxL
	by = byL
	sx = sxL
	sy = syL

	if not(gs_stack_left) then
		gosub 1000		! Turn Plaster
	endif

	if bCavityCloserLeft then
		if iClosureMethod = CLOSURE_METHOD_TRADITIONAL	 then gosub 2000
		if iClosureMethod = CLOSURE_METHOD_PREFABRICATED then gosub 3000

	endif

	del numTrans

! Right Cavity Closure =========================================================

	if not(bCornerWindow) then
		if curvedWall then
			mul2 -1,1
			numTrans = 1
		else
			numTrans = 0
		endif

		sideSign	= 1
		distanceX	= rightWidth
		alfaX		= rightAlfa
		alfaJamb	= alfaRightJamb
		revealWidth = gs_reveal_right
		revealAngle	= gs_reveal_right_angle
		bx = bxR
		by = byR
		sx = sxR
		sy = syR

		if not(gs_stack_right) then
			gosub 1000		! Turn Plaster
		endif

		if bCavityCloserRight then
			if iClosureMethod = CLOSURE_METHOD_TRADITIONAL	 then gosub 2000
			if iClosureMethod = CLOSURE_METHOD_PREFABRICATED then gosub 3000

		endif

		del numTrans
	endif

endif	! bCompositeWall


! Restore the saved parameter buffer ===========================================

call "LoadQueue" parameters savedQueueValues = savedQueueValues

! ==============================================================================

if GLOB_STRUCTURE_DISPLAY = STRUCTURE_ENTIRE_STRUCTURE then
	thkSkinTurnInLeft	= thkSkinTurnIn
	thkSkinTurnOutLeft	= thkSkinTurnOut

	thkSkinTurnInRight	= thkSkinTurnIn
	thkSkinTurnOutRight	= thkSkinTurnOut
else
	thkSkinTurnInLeft	= thkSkinTurnIn  - thkFinishSkinTurnIn
	thkSkinTurnOutLeft	= thkSkinTurnOut - thkFinishSkinTurnOut

	thkSkinTurnInRight	= thkSkinTurnIn  - thkFinishSkinTurnIn
	thkSkinTurnOutRight	= thkSkinTurnOut - thkFinishSkinTurnOut
endif

if bCompositeWall then
	idx = 1: gosub 10	! Get proper index
	penSkinContourIn	= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
	ltSkinContourIn		= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])

	idx = WALL_SKINS_NUMBER: gosub 10	! Get proper index
	penSkinContourOut	= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN])
	ltSkinContourOut	= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE])
else
	penSkinContourIn	= WALL_SECT_PEN
	ltSkinContourIn		= WALL_LINETYPE

	penSkinContourOut	= WALL_SECT_PEN
	ltSkinContourOut	= WALL_LINETYPE
endif

end thkSkinTurnInLeft,	! Thickness of turned plaster skins at the Inside Face
	thkSkinTurnInRight,
	thkSkinTurnOutLeft,	! Thickness of turned plaster skins at the Outside Face
	thkSkinTurnOutRight,
	penSkinContourIn,	! Skin Contour Pen Opp. Side
	penSkinContourOut,	! Skin Contour Pen Ref. Side
	ltSkinContourIn,	! Skin Contour Line Type Opp. Side
	ltSkinContourOut,	! Skin Contour Line Type Ref. Side
	offsetSill,			! Thickness of hidden wall skins at sill side
	offsetBoard			! Thickness of hidden wall skins at board side

! ==============================================================================
! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
! ==============================================================================




! ==============================================================================
! === SUBROUTINES
! ==============================================================================

! ==============================================================================
!		Turn Plaster
! ------------------------------------------------------------------------------
! Input variables:
!	nSkinTurnIn:			number of turned plaster skins at the Outside Face
!	nSkinTurnOut:			number of turned plaster skins at the Inside Face
!	bFirstSkinAtReveal:		the first skin located at the reveal side of the window
!	iRevealType:			reveal type (0 = no reveal, 1 = positive, 2 = negative, 3 = slanted)
!	sideSign:				1: at the right side, -1: at the left side
!	distanceX:				horizontal distance from the original origo
!	alfaX:					alfa x in case of curved walls (alfaX > 0)
!	alfaJamb:				jamb alfa (alfaJamb > 0)
!	revealWidth:			width of the reveal
!	revealAngle:			angle of the Inside Face in case of Slanted os Splayed Reveal
!	skinCummThkRef:			precalculated cummulative skin thickness from the Outside Face
!	skinCummThkOpp:			precalculated cummulative skin thickness from the Inside Face
! ==============================================================================

1000:

	bSlantedInnerSide = (iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED)


! ==============================================================================
! Turn Plaster - at the Outside Face
! ==============================================================================

	if nSkinTurnIn > 0 then
		dx = 0
		slantLength = 0
		if bFirstSkinAtReveal then
			if iRevealType = REVEAL_POSITIVE then dx = -revealWidth
			if iRevealType = REVEAL_NEGATIVE then dx =  revealWidth
			if iRevealType = REVEAL_SLANTED  then dx = -revealWidth

			slantX = 0
			if bParalellInCurvedWalls then
				vectS = 0
				vectC = 1
			else
				vectS = sin(alfaX - alfaJamb)
				vectC = cos(alfaX - alfaJamb)
			endif
		else
			if iRevealType = REVEAL_SLANTED then slantLength = WALL_THICKNESS - WIDO_SILL						! Slanted Reveal
			if iRevealType = REVEAL_SPLAYED then slantLength = WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS	! Splayed Reveal

			if bSlantedInnerSide then
				slantX = tan(revealAngle)
				vectS = -sin(revealAngle) * signWallIsLeft
				vectC = cos(revealAngle)
			else
				slantX = 0
				if bParalellInCurvedWalls then
					vectS = 0
					vectC = 1
				else
					vectS = sin(alfaX)
					vectC = cos(alfaX)
				endif
			endif
		endif

		turnThk = 0

		for i = nSkinTurnIn to 1 step -1
			idx = i: gosub 10	! Get proper index

			skinThk = WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
			bFirst	= (i = nSkinTurnIn)
			bLast	= (i = 1)

			if reorder then
				cummThk = skinCummThkRef[idx + 1]
			else
				if idx > 1 then
					cummThk = skinCummThkRef[idx - 1]
				else
					cummThk = 0
				endif
			endif

			if curvedWall then

! Curved Wall ==================================================================

				if reorder then
					signReorder = -1
				else
					signReorder = 1
				endif

! p2 point ---------------------------------------------------------------------

				xo = 0
				yo = -WOD
				if bFirstSkinAtReveal then
					ro = rSill - cummThk * signReorder
				else
					ro = rBoard - cummThk * signReorder
				endif

				if bFirstSkinAtReveal then
					x2 = -sx * sideSign
					y2 =  sy
				else
					x2 = -bx * sideSign
					y2 =  by
				endif
				x1 = x2 + vectS
				y1 = y2 - vectC * signWallIsLeft

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px2 = cx
				py2 = cy


! p3 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x2 = -sx * sideSign + (turnThk + skinThk) * vectC
					y2 =  sy			+ (turnThk + skinThk) * vectS * signReorder
				else
					x2 = -bx * sideSign + (turnThk + skinThk) * vectC
					y2 =  by			- (turnThk + skinThk) * vectS * signReorder
				endif
				x1 = x2 + vectS
				y1 = y2 - vectC * signWallIsLeft

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px3 = cx
				py3 = cy


! p1 point ---------------------------------------------------------------------

				xo = 0
				yo = -WOD
				if bFirstSkinAtReveal then
					ro = rSill - skinCummThkRef[idx] * signReorder
				else
					ro = rBoard - skinCummThkRef[idx] * signReorder
				endif

				if bFirstSkinAtReveal then
					x2 = -sx * sideSign
					y2 =  sy
				else
					x2 = -bx * sideSign
					y2 =  by
				endif
				x1 = x2 + vectS
				y1 = y2 - vectC * signWallIsLeft

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px1 = cx
				py1 = cy


! p6 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x2 = -sx * sideSign + turnThk * vectC
					y2 =  sy			+ turnThk * vectS * signReorder
				else
					x2 = -bx * sideSign + turnThk * vectC
					y2 =  by			- turnThk * vectS * signReorder
				endif
				x1 = x2 + vectS
				y1 = y2 - vectC * signWallIsLeft

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px6 = cx
				py6 = cy


! Window's line or arch ========================================================

				if bWndCurved then
					xo = 0
					yo = -WOD
					ro = rSillLine + not(wallIsLeft exor reorder) * WIDO_FRAME_THICKNESS * signReorder
				else
					x11 = 0
					y11 = -not(wallIsLeft exor reorder) * WIDO_FRAME_THICKNESS
					x12 = 1
					y12 = y11
				endif


! p4 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x22 = -sx * sideSign + (turnThk + skinThk) * vectC
					y22 =  sy			 + (turnThk + skinThk) * vectS * signReorder
				else
					x22 = -bx * sideSign + (turnThk + skinThk) * vectC
					y22 =  by			 - (turnThk + skinThk) * vectS * signReorder
				endif
				x21 = x22 + vectS
				y21 = y22 - vectC * signWallIsLeft

				if bWndCurved then
					x1 = x21: y1 = y21
					x2 = x22: y2 = y22
					gosub 101	! Circle - Line intersection
					gosub 102	! Select good intersection point
				else
					gosub 100	! Line - Line intersection
				endif
				px4 = cx
				py4 = cy


! p5 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x22 = -sx * sideSign + turnThk * vectC
					y22 =  sy			 + turnThk * vectS * signReorder
				else
					x22 = -bx * sideSign + turnThk * vectC
					y22 =  by			 - turnThk * vectS * signReorder
				endif
				x21 = x22 + vectS
				y21 = y22 - vectC * signWallIsLeft

				if bWndCurved then
					x1 = x21: y1 = y21
					x2 = x22: y2 = y22
					gosub 101	! Circle - Line intersection
					gosub 102	! Select good intersection point
				else
					gosub 100	! Line - Line intersection
				endif
				px5 = cx
				py5 = cy

			else

! Straight Wall, Trapezoid Wall ================================================

				slantDiffUpper = not(bFirstSkinAtReveal) * bSlantedInnerSide * ((turnThk + skinThk) - (turnThk + skinThk) / cos(revealAngle))
				slantDiffLower = not(bFirstSkinAtReveal) * bSlantedInnerSide * (turnThk - turnThk / cos(revealAngle))

				py1 = cummThk + skinThk
				px1 = distanceX + dx + (slantLength - py1)* slantX

				py2 = cummThk
				px2 = distanceX + dx + (slantLength - py2)* slantX

				py3 = cummThk
				px3 = distanceX + dx - turnThk - skinThk + (slantLength - py3) * slantX + slantDiffUpper

				py4 = lengthPlasterTurnIn
				px4 = distanceX + dx - turnThk - skinThk + (slantLength - py4) * slantX + slantDiffUpper

				py5 = lengthPlasterTurnIn
				px5 = distanceX + dx - turnThk + (slantLength - py5)* slantX + slantDiffLower

				py6 = cummThk + skinThk
				px6 = distanceX + dx - turnThk + (slantLength - py6)* slantX + slantDiffLower
			endif

! Draw the turned plaster skins ================================================

			bShowSkin = (GLOB_STRUCTURE_DISPLAY = STRUCTURE_ENTIRE_STRUCTURE | (GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) > EPS))

			if bShowSkin then
				fill WALL_SKINS_PARAMS[idx][SKIN_FILL]
				bLocalFill = round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_ORIENTATION])

				wallblock2 6, 2 + 24 * bLocalFill + 32,
					WALL_SKINS_PARAMS[idx][SKIN_FILL_PEN],
					WALL_SKINS_PARAMS[idx][SKIN_FILL_BACK_PEN],
					0,0,0,
					px1,	py1,	0,
					px2,	py2,	0,
					px3,	py3,	0,
					px4,	py4,	0,
					px5,	py5,	0,
					px6,	py6,	0
			endif

			if WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN] > EPS then
				pen			WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN]
				line_type	WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE]
				line_property LINE_PROPERTY_INNER + bLast		! (1 / 2)

				if bShowSkin then
					wallline2	px2,py2, px3,py3
					wallline2	px3,py3, px4,py4

					if bLast & bDrawObjContourOut then
						line2	px2,py2, px3,py3
						line2	px3,py3, px4,py4
					endif
				endif
			endif

			if bFirst & bShowSkin & WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN] > EPS then
				pen			WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN]
				line_type	WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE]
				line_property LINE_PROPERTY_INNER

				if not(curvedWall) | (py6 < py5 exor wallIsLeft exor reorder) then
					wallline2	px5,py5, px6,py6
				endif
			endif

			turnThk = turnThk + skinThk
		next i

	endif


! ==============================================================================
! Turn Plaster - at the Inside Face
! ==============================================================================

	if nSkinTurnOut > 0 then
		if bFirstSkinAtReveal then
			dx = 0

			if iRevealType = REVEAL_SLANTED then slantLength = WALL_THICKNESS - WIDO_SILL						! Slanted Reveal
			if iRevealType = REVEAL_SPLAYED then slantLength = WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS	! Splayed Reveal

			if bSlantedInnerSide then
				slantX	=  tan(revealAngle)
				vectS	= -sin(revealAngle) * signWallIsLeft
				vectC	=  cos(revealAngle)
			else
				slantX	= 0
				if bParalellInCurvedWalls then
					vectS = 0
					vectC = 1
				else
					vectS = sin(alfaX)
					vectC = cos(alfaX)
				endif
			endif
		else
			dx = 0
			if iRevealType = REVEAL_POSITIVE then dx = -revealWidth
			if iRevealType = REVEAL_NEGATIVE then dx =  revealWidth
			if iRevealType = REVEAL_SLANTED  then dx = -revealWidth

			slantX	= 0
			if bParalellInCurvedWalls then
				vectS = 0
				vectC = 1
			else
				vectS = sin(alfaX - alfaJamb)
				vectC = cos(alfaX - alfaJamb)
			endif
		endif

		bIncSign = (SYMB_MIRRORED exor WIDO_REVEAL_SIDE exor reorder)
		iIncSign = bIncSign - not(bIncSign)

		turnThk = 0

		for i = WALL_SKINS_NUMBER - nSkinTurnOut + 1 to WALL_SKINS_NUMBER
			idx = i: gosub 10	! Get proper index

			skinThk = WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
			bFirst	= (i = WALL_SKINS_NUMBER - nSkinTurnOut + 1)
			bLast	= (i = WALL_SKINS_NUMBER)

			if reorder then
				if idx > 1 then
					cummThk = skinCummThkOpp[idx - 1]
				else
					cummThk = 0
				endif
			else
				cummThk = skinCummThkOpp[idx + 1]
			endif

			if bInclinedWall then
				if reorder then
					incDiffLower	= cummThk - cummThk / incH
					incDiffUpper	= skinCummThkOpp[idx + 0] - skinCummThkOpp[idx + 0] / incH
				else
					incDiffLower	= skinCummThkOpp[idx + 1] - skinCummThkOpp[idx + 1] / incH
					incDiffUpper	= skinCummThkOpp[idx + 0] - skinCummThkOpp[idx + 0] / incH
				endif
			else
				incDiffLower	= 0
				incDiffUpper	= 0
			endif

			slantDiffLower = bFirstSkinAtReveal * bSlantedInnerSide * ((turnThk + skinThk) - (turnThk + skinThk) / cos(revealAngle))
			slantDiffUpper = bFirstSkinAtReveal * bSlantedInnerSide * (turnThk - turnThk / cos(revealAngle))

			if curvedWall then

! Curved Wall ==================================================================

				if reorder then
					signReorder = -1
				else
					signReorder = 1
				endif

! p2 point ---------------------------------------------------------------------

				xo = 0
				yo = -WOD
				if bFirstSkinAtReveal then
					ro = rBoard + cummThk * signReorder
				else
					ro = rSill + cummThk * signReorder
				endif

				if bFirstSkinAtReveal then
					x2 = -bx * sideSign
					y2 =  by
				else
					x2 = -sx * sideSign
					y2 =  sy
				endif
				x1 = x2 + vectS
				y1 = y2 - vectC * signWallIsLeft

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px2 = cx
				py2 = cy

				bValidP2 = (state > 0)


! p3 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x2 = -bx * sideSign + (turnThk + skinThk) * vectC
					y2 =  by			+ (turnThk + skinThk) * vectS * signReorder
				else
					x2 = -sx * sideSign + (turnThk + skinThk) * vectC
					y2 =  sy			- (turnThk + skinThk) * vectS * signReorder
				endif
				x1 = x2 + vectS
				y1 = y2 - vectC * signWallIsLeft

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px3 = cx
				py3 = cy

				bValidP3 = (state > 0)


! p1 point ---------------------------------------------------------------------

				xo = 0
				yo = -WOD
				if bFirstSkinAtReveal then
					ro = rBoard + skinCummThkOpp[idx] * signReorder
				else
					ro = rSill + skinCummThkOpp[idx] * signReorder
				endif

				if bFirstSkinAtReveal then
					x2 = -bx * sideSign
					y2 =  by
				else
					x2 = -sx * sideSign
					y2 =  sy
				endif
				x1 = x2 + vectS
				y1 = y2 - vectC * signWallIsLeft

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px1 = cx
				py1 = cy

				bValidP1 = (state > 0)


! p6 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x2 = -bx * sideSign + turnThk * vectC
					y2 =  by			+ turnThk * vectS * signReorder
				else
					x2 = -sx * sideSign + turnThk * vectC
					y2 =  sy			- turnThk * vectS * signReorder
				endif
				x1 = x2 + vectS
				y1 = y2 - vectC * signWallIsLeft

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px6 = cx
				py6 = cy

				bValidP6 = (state > 0)


! Window's line or arch ========================================================

				if bWndCurved then
					xo = 0
					yo = -WOD
					ro = rSillLine - (wallIsLeft exor reorder) * WIDO_FRAME_THICKNESS * signReorder
				else
					x11 = 0
					y11 = -(wallIsLeft exor reorder) * WIDO_FRAME_THICKNESS
					x12 = 1
					y12 = y11
				endif


! p4 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x22 = -bx * sideSign + (turnThk + skinThk) * vectC
					y22 =  by			 + (turnThk + skinThk) * vectS * signReorder
				else
					x22 = -sx * sideSign + (turnThk + skinThk) * vectC
					y22 =  sy			 - (turnThk + skinThk) * vectS * signReorder
				endif
				x21 = x22 + vectS
				y21 = y22 - vectC * signWallIsLeft

				if bWndCurved then
					x1 = x21: y1 = y21
					x2 = x22: y2 = y22
					gosub 101	! Circle - Line intersection
					gosub 102	! Select good intersection point

					bValidP4 = (state > 0)
				else
					gosub 100	! Line - Line intersection

					bValidP4 = 1
				endif
				px4 = cx
				py4 = cy


! p5 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x22 = -bx * sideSign + turnThk * vectC
					y22 =  by			 + turnThk * vectS * signReorder
				else
					x22 = -sx * sideSign + turnThk * vectC
					y22 =  sy			 - turnThk * vectS * signReorder
				endif
				x21 = x22 + vectS
				y21 = y22 - vectC * signWallIsLeft

				if bWndCurved then
					x1 = x21: y1 = y21
					x2 = x22: y2 = y22
					gosub 101	! Circle - Line intersection
					gosub 102	! Select good intersection point

					bValidP5 = (state > 0)
				else
					gosub 100	! Line - Line intersection

					bValidP5 = 1
				endif
				px5 = cx
				py5 = cy


! Check for valid points =======================================================

				if abs(px3) < EPS and abs(py3) < EPS then
					px3 = px4
					py3 = py4
				endif
				if abs(px2) < EPS and abs(py2) < EPS then
					px2 = px3
					py2 = py3
				endif
				if abs(px6) < EPS and abs(py6) < EPS then
					px6 = px5
					py6 = py5
				endif
				if abs(px1) < EPS and abs(py1) < EPS then
					px1 = px6
					py1 = py6
				endif
			else

! Straight Wall, Trapezoid Wall ================================================

				if (bInclinedWall | bFirstSkinAtReveal) & (iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED) then

					if bFirstSkinAtReveal then
						x1 = bx * sideSign
						y1 =  by + WIDO_SILL + (iRevealType = REVEAL_SPLAYED) * WIDO_FRAME_THICKNESS
					else
						x1 = sx * sideSign
						y1 =  sy + WIDO_SILL + (iRevealType = REVEAL_SPLAYED) * WIDO_FRAME_THICKNESS
					endif

					x3 = x1 - (turnThk + skinThk) * cos(revealAngle)
					y3 = y1 + (turnThk + skinThk) * sin(revealAngle)

					x6 = x1 - turnThk * cos(revealAngle)
					y6 = y1 + turnThk * sin(revealAngle)

					if bInclinedWall then
						x11 = dx + cummThk * incV * iInclDir * sideSign * iIncSign
						y11 = WALL_THICKNESS - cummThk * incH
						x12 = x11 + incH
						y12 = y11 + incV * iInclDir * sideSign * iIncSign
					else
						x11 = dx
						y11 = WALL_THICKNESS - cummThk
						x12 = x11 + 1
						y12 = y11
					endif

					x21 = x1
					y21 = y1
					x22 = x21 + sin(revealAngle)
					y22 = y21 + cos(revealAngle)

					gosub 100		! Line - Line intersection
					px2 = cx
					py2 = cy

					x21 = x3
					y21 = y3
					x22 = x21 + sin(revealAngle)
					y22 = y21 + cos(revealAngle)

					gosub 100		! Line - Line intersection
					px3 = cx
					py3 = cy

					if bInclinedWall then
						x11 = dx + (skinCummThkOpp[idx]) * incV * iInclDir * sideSign * iIncSign
						y11 = WALL_THICKNESS - (skinCummThkOpp[idx]) * incH
						x12 = x11 + incH
						y12 = y11 + incV * iInclDir * sideSign * iIncSign
					else
						x11 = dx
						y11 = WALL_THICKNESS - skinCummThkOpp[idx]
						x12 = 1
						y12 = y11
					endif

					x21 = x1
					y21 = y1
					x22 = x21 + sin(revealAngle)
					y22 = y21 + cos(revealAngle)

					gosub 100		! Line - Line intersection
					px1 = cx
					py1 = cy

					x21 = x6
					y21 = y6
					x22 = x21 + sin(revealAngle)
					y22 = y21 + cos(revealAngle)

					gosub 100		! Line - Line intersection
					px6 = cx
					py6 = cy
				else
					px1 = distanceX + dx
					py1 = WALL_THICKNESS - cummThk - skinThk + (px1 - dx) * incHor * sideSign * iIncSign + incDiffUpper

					px2 = distanceX + dx
					py2 = WALL_THICKNESS - cummThk  + (px2 - dx) * incHor * sideSign * iIncSign + incDiffLower

					px3 = distanceX + dx - turnThk - skinThk
					py3 = WALL_THICKNESS - cummThk  + (px3 - dx) * incHor * sideSign * iIncSign + incDiffLower

					px6 = distanceX + dx - turnThk
					py6 = WALL_THICKNESS - cummThk - skinThk + (px6 - dx) * incHor * sideSign * iIncSign + incDiffUpper
				endif

				py4 = WALL_THICKNESS - lengthPlasterTurnOut
				px4 = distanceX + dx - turnThk - skinThk + (slantLength + (py4 - WALL_THICKNESS)) * slantX + slantDiffLower

				py5 = WALL_THICKNESS - lengthPlasterTurnOut
				px5 = distanceX + dx - turnThk + (slantLength + (py5 - WALL_THICKNESS)) * slantX + slantDiffUpper

				bValidP1 = 1
				bValidP2 = 1
				bValidP3 = 1
				bValidP4 = 1
				bValidP5 = 1
				bValidP6 = 1
			endif

! Draw the turned plaster skins ================================================

			bShowSkin = (GLOB_STRUCTURE_DISPLAY = STRUCTURE_ENTIRE_STRUCTURE | (GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) > EPS))

			if bShowSkin then
				fill		 WALL_SKINS_PARAMS[idx][SKIN_FILL]
				bLocalFill = round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_ORIENTATION])

				if bValidP1 then put px1,py1, 0
				if bValidP2 then put px2,py2, 0
				if bValidP3 then put px3,py3, 0
				if bValidP4 then put px4,py4, 0
				if bValidP5 then put px5,py5, 0
				if bValidP6 then put px6,py6, 0

				penFillFg = round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_PEN])
				penFillBg = round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_BACK_PEN])
				bDrawContour = 0
				gosub 200	! Draw wallblock with contour
			endif

			if WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN] > EPS then
				pen			WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN]
				line_type	WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE]
				line_property LINE_PROPERTY_INNER + bLast		! (1 / 2)

				if bShowSkin then
					wallline2	px2,py2, px3,py3
					wallline2	px3,py3, px4,py4

					if bLast & bDrawObjContourIn then
						line2	px2,py2, px3,py3
						line2	px3,py3, px4,py4
					endif
				endif
			endif

			if bFirst & bShowSkin & WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN] > EPS then
				pen			WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN]
				line_type	WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE]
				line_property LINE_PROPERTY_INNER

				wallline2	px5,py5, px6,py6
			endif

			turnThk = turnThk + skinThk
		next i

	endif

return


! ==============================================================================
!		Traditional Cavity Closure
! ------------------------------------------------------------------------------
! Input variables:
!	possibleSkinTurnIn:		number of possible plaster skins at the Outside Face
!	possibleSkinTurnOut:	number of possible plaster skins at the Inside Face
!	distanceX:				horizontal distance from the original origo
!	alfaX:					alfa x in case of curved walls (alfaX > 0)
!	alfaJamb:				jamb alfa (alfaJamb > 0)
!	revealWidth:			width of the reveal
! ==============================================================================

2000:
	nSkins = WALL_SKINS_NUMBER - possibleSkinTurnOut - possibleSkinTurnIn
	if nSkins < 3 then return

	gs_nTurn = min(gs_nTurn, nSkins - 2)
	signTurnDir = (gs_bTurnDir) - not(gs_bTurnDir)

	if gs_bTurnDir then
		idx = WALL_SKINS_NUMBER - possibleSkinTurnOut - 1: gosub 10	! Get proper index
		baseSkinLevel = skinCummThkRef[idx]

		idx = WALL_SKINS_NUMBER - possibleSkinTurnOut:	gosub 10	! Get proper index
		baseSkinIdx = idx
	else
		idx = possibleSkinTurnIn + 1: gosub 10	! Get proper index
		baseSkinIdx = idx
		baseSkinLevel = skinCummThkRef[baseSkinIdx]
	endif

	lengthSkinTurnIn = baseSkinLevel - signTurnDir * gs_bJoint * gs_thkJoint

!!!	idx = nSkinTurnIn + gs_nTurn: gosub 10	! Get proper index
	if gs_bTurnDir then
		idx = possibleSkinTurnIn + gs_nTurn: gosub 10	! Get proper index
		if idx > 0 then
			level_1 = skinCummThkRef[idx]
		else
			level_1 = 0
		endif
	else
		idx = WALL_SKINS_NUMBER - possibleSkinTurnOut - gs_nTurn: gosub 10	! Get proper index
		level_1 = skinCummThkRef[idx]
	endif

	idx = baseSkinIdx
	baseSkinFillType		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL])
	baseSkinFillFgPen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_PEN])
	baseSkinFillBgPen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_BACK_PEN])
	baseSkinFillOrientation	= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_ORIENTATION])
	baseSkinContLinePen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
	baseSkinContLineType	= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])

!!!	idx = nSkinTurnIn: gosub 10	! Get proper index
	if gs_bTurnDir then
		idx = possibleSkinTurnIn: gosub 10	! Get proper index
		if idx > 0 then
			level_2 = skinCummThkRef[idx]
		else
			level_2 = 0
		endif
	else
		idx = WALL_SKINS_NUMBER - possibleSkinTurnOut: gosub 10	! Get proper index
		level_2 = skinCummThkRef[idx]
	endif

	widthJoint = abs(level_1 - level_2)

	dx = 0
	bCuttedPlug = 0
	bNegativeTurn = 0

	vectS = -sin(revealAngle) * signWallIsLeft
	vectC =  cos(revealAngle)

	if bFirstSkinAtReveal exor not(gs_bTurnDir) then
		if iRevealType = REVEAL_POSITIVE then dx = -revealWidth
		if iRevealType = REVEAL_NEGATIVE then dx =  revealWidth
		if iRevealType = REVEAL_SLANTED  then dx = -revealWidth

		if not(curvedWall) then
			slantX = 0
			vectS = sin(alfaX - alfaJamb)
			vectC = cos(alfaX - alfaJamb)
		endif

		bCuttedPlug		= 0
		plugLeftDx		= 0
		plugOnWindow	= 0		! GER request

		bIncludeReveal	= 0

		if iRevealType <> REVEAL_NEGATIVE & revealWidth + EPS >= widthJoint & widthJoint + gs_thkJoint < WIDO_SILL then
			! note: widthJoint equals the summ width of the turned skins

			if gs_bTurnDir then
				baseSkinLevel = WIDO_SILL
				lengthSkinTurnIn = baseSkinLevel - gs_bJoint * gs_thkJoint
			else
				baseSkinLevel = WALL_THICKNESS - WIDO_SILL
				lengthSkinTurnIn = baseSkinLevel + gs_bJoint * gs_thkJoint
			endif
			plugOnWindow = 1
		else
			if iRevealType = REVEAL_NEGATIVE then
				plugLeftDx = 0

				if gs_bTurnDir then
					if baseSkinLevel - EPS > WIDO_SILL then
						bCuttedPlug = 1
					endif
				else
					if baseSkinLevel - EPS < WALL_THICKNESS - WIDO_SILL then
						bCuttedPlug = 1
					endif
				endif
			else
				if gs_bTurnDir then
					if lengthSkinTurnIn - EPS >= WIDO_SILL then
						if lengthSkinTurnIn < WIDO_SILL + EPS then
							plugLeftDx = revealWidth
						else
							bIncludeReveal = 1
							if bSlantedInnerSide then
								if iRevealType = REVEAL_SLANTED then slantDy = lengthSkinTurnIn - WIDO_SILL
								if iRevealType = REVEAL_SPLAYED then slantDy = lengthSkinTurnIn - WIDO_SILL - WIDO_FRAME_THICKNESS
								dx = slantDy * tan(revealAngle)
							else
								dx = 0
							endif
						endif
					else
						bCuttedPlug = 1
					endif
				else
					if lengthSkinTurnIn + EPS <= WALL_THICKNESS - WIDO_SILL then
						if lengthSkinTurnIn > WALL_THICKNESS - WIDO_SILL + EPS then
							plugLeftDx = revealWidth
						else
							bIncludeReveal = 1
							if bSlantedInnerSide then
								if iRevealType = REVEAL_SLANTED then slantDy = WALL_THICKNESS - lengthSkinTurnIn - WIDO_SILL
								if iRevealType = REVEAL_SPLAYED then slantDy = WALL_THICKNESS - lengthSkinTurnIn - WIDO_SILL - WIDO_FRAME_THICKNESS
								dx = slantDy * tan(revealAngle)
							else
								dx = 0
							endif
						endif
					else
						bCuttedPlug = 1
					endif
				endif
			endif
		endif
		if WIDO_SILL < EPS & (iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE) then
			bIncludeReveal = 0
		endif
	else

		if iRevealType = REVEAL_NEGATIVE then
			if gs_bTurnDir then
				if baseSkinLevel + EPS >= WALL_THICKNESS - WIDO_SILL & WIDO_SILL < WALL_THICKNESS then
					bIncludeReveal = 1
				endif
			else
				if baseSkinLevel + EPS <= WIDO_SILL & WIDO_SILL < WALL_THICKNESS then
					bIncludeReveal = 1
				endif
			endif
		else
			if gs_bTurnDir then
				if curvedWall & not(bWndCurved) then
					if wallIsLeft then
						sLevel = sqr(bx^2 + (by + WOD)^2) - rBoard
					else
						sLevel = WALL_THICKNESS - sqr(bx^2 + (by + WOD)^2) + rSill
					endif

					if baseSkinLevel - EPS >= sLevel then
						bCuttedPlug = 1
						plugLeftDx = -revealWidth
					endif
				else
					if baseSkinLevel + EPS > WALL_THICKNESS - WIDO_SILL then
						bCuttedPlug = 1
						plugLeftDx = -revealWidth
					endif
				endif
			else
				if curvedWall & not(bWndCurved) then
					if wallIsLeft then
						sLevel = rSill - sqr(bx^2 + (by + WOD)^2)
					else
						sLevel = sqr(bx^2 + (by + WOD)^2) - rSill
					endif

					if baseSkinLevel + EPS <= sLevel then
						bCuttedPlug = 1
						plugLeftDx = -revealWidth
					endif
				else
					if baseSkinLevel + EPS < WIDO_SILL then
						bCuttedPlug = 1
						plugLeftDx = -revealWidth
					endif
				endif
			endif
		endif

		if iRevealType = REVEAL_NEGATIVE then
			if gs_bTurnDir then
				if WALL_THICKNESS - WIDO_SILL < baseSkinLevel + EPS then
					dx = revealWidth
				endif
			else
				if WIDO_SILL > baseSkinLevel + EPS then
					dx = revealWidth
				endif
			endif
			bNegativeTurn = 1
		endif
		if iRevealType = REVEAL_SLANTED then slantLength = WALL_THICKNESS - WIDO_SILL
		if iRevealType = REVEAL_SPLAYED then slantLength = WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS

		if not(curvedWall) then
			if bSlantedInnerSide then
				slantX = tan(revealAngle)
				vectS = -sin(revealAngle) * signWallIsLeft
				vectC =  cos(revealAngle)
			else
				slantX = 0
				vectS = sin(alfaX)
				vectC = cos(alfaX)
			endif
		endif
	endif

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		bCuttedPlug		= 0
		bIncludeReveal	= 0
	endif

	if curvedWall then
		if reorder then
			rBegH = min(rSill, rBoard) + baseSkinLevel
			rEndH = min(rSill, rBoard) + baseSkinLevel - signTurnDir * gs_thkJoint
		else
			rBegH = max(rSill, rBoard) - baseSkinLevel
			rEndH = max(rSill, rBoard) - baseSkinLevel + signTurnDir * gs_thkJoint
		endif
		baseSkinRadius	= rEndH
		lengthToAngle	= (180 / rBegH / PI)	! Ref circle is on the rBegH
	endif

	dxAngle = dx * ArcLengthSillToAngle

	if iRevealType = REVEAL_SLANTED & not(bIncludeReveal) & wallIsLeft & (reorder exor gs_bTurnDir) then
		! In this special case we have to draw a normal positive reveal
		bSlantedInnerSide = 0
	endif


! Insulation Strip =============================================================

	if gs_bJoint then

		if not(bFirstSkinAtReveal exor not(gs_bTurnDir)) & bSlantedInnerSide & not(curvedWall) then widthJoint = widthJoint / cos(revealAngle)

		if gs_bTurnDir then
			slantDx = bSlantedInnerSide * not(bFirstSkinAtReveal exor not(gs_bTurnDir)) * (baseSkinLevel - gs_thkJoint - WALL_THICKNESS + WIDO_SILL) * tan(revealAngle)
		else
			slantDx = bSlantedInnerSide * not(bFirstSkinAtReveal exor not(gs_bTurnDir)) * (WIDO_SILL - baseSkinLevel - gs_thkJoint) * tan(revealAngle)
		endif

		if not(bFirstSkinAtReveal exor not(gs_bTurnDir)) & baseSkinLevel > WIDO_SILL then
			if gs_bTurnDir then
				plugLeftDx = (WALL_THICKNESS - lengthSkinTurnIn - WIDO_SILL) * tan(revealAngle)
			else
				plugLeftDx = (lengthSkinTurnIn - WIDO_SILL) * tan(revealAngle)
			endif
		endif

		if curvedWall then

			if bSlantedInnerSide | bParalellInCurvedWalls then

				xo = 0
				yo = -WOD

				ro = rBegH

				if (gs_bTurnDir exor reorder exor wallIsLeft) & bCuttedPlug then
					x1 = -sx * sideSign
					y1 =  sy
					x2 = x1 - sin(alfaX - alfaJamb)
					y2 = y1 + cos(alfaX - alfaJamb) * signWallIsLeft
				else
					x1 = -bx * sideSign
					y1 =  by
					x2 = x1 - vectS
					y2 = y1 + vectC * signWallIsLeft
				endif

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px1 = cx
				py1 = cy

				ro = baseSkinRadius

				x1 = -bx * sideSign - widthJoint * vectC
				y1 = by - widthJoint * vectS * signWallIsLeft
				x2 = x1 - vectS
				y2 = y1 + vectC * signWallIsLeft

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px3 = cx
				py3 = cy

				alpha =  atn(cx/(cy+WOD))
				px2 = px3 - signTurnDir * signReorder * signWallIsLeft * gs_thkJoint * sin(alpha)
				py2 = py3 - signTurnDir * signReorder * signWallIsLeft * gs_thkJoint * cos(alpha)

				ro = rEndH

				if (gs_bTurnDir exor reorder exor wallIsLeft) | not(bCuttedPlug) then
					x1 = -bx * sideSign
					y1 =  by
					x2 = x1 - vectS
					y2 = y1 + vectC * signWallIsLeft
				else
					x1 = -sx * sideSign
					y1 =  sy
					x2 = x1 - sin(alfaX - alfaJamb)
					y2 = y1 + cos(alfaX - alfaJamb) * signWallIsLeft
				endif

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px4 = cx
				py4 = cy

			else

				plugAngle = widthJoint * lengthToAngle
				alfaPlug = alfaX + (iRevealType = REVEAL_NEGATIVE) * dxAngle

				sin1 = sin(alfaPlug)
				cos1 = cos(alfaPlug) * signWallIsLeft
				sin2 = sin(alfaPlug + plugAngle + (iRevealType <> REVEAL_NEGATIVE) * dxAngle)
				cos2 = cos(alfaPlug + plugAngle + (iRevealType <> REVEAL_NEGATIVE) * dxAngle) * signWallIsLeft

				if bCuttedPlug then
					if gs_bTurnDir exor reorder exor wallIsLeft then
						alfaPlug3 = alfaX - alfaJamb
					else
						alfaPlug3 = alfaX
					endif
					sin3 = sin(alfaPlug3)
					cos3 = cos(alfaPlug3) * signWallIsLeft

					sin4 = sin(alfaX + dxAngle)
					cos4 = cos(alfaX + dxAngle) * signWallIsLeft
				endif

				if bCuttedPlug then
					px1 = -rBegH * sin3
					py1 = -WOD + rBegH * cos3
				else
					px1 = -rBegH * sin1
					py1 = -WOD + rBegH * cos1
				endif

				px2 = -rBegH * sin2
				py2 = -WOD + rBegH * cos2

				px3 = -rEndH * sin2
				py3 = -WOD + rEndH * cos2

				if bCuttedPlug then
					px4 = -rEndH * sin4
					py4 = -WOD + rEndH * cos4
				else
					px4 = -rEndH * sin1
					py4 = -WOD + rEndH * cos1
				endif
			endif
		else
			px1 = distanceX + dx + plugLeftDx
			py1 = baseSkinLevel

			px2 = distanceX + dx + plugLeftDx
			py2 = baseSkinLevel - signTurnDir * gs_thkJoint

			px3 = distanceX + dx - slantDx + widthJoint
			py3 = baseSkinLevel - signTurnDir * gs_thkJoint

			px4 = distanceX + dx - slantDx + widthJoint
			py4 = baseSkinLevel
		endif


! Draw Insulation Strip ========================================================

		if gs_showJoint then
			pen gs_penJoint
			line_type gs_ltJoint
			set fill gs_fillJoint
			line_property LINE_PROPERTY_INNER

			if bCuttedPlug then

				bDivide		= 0		! is sill line cross the insulation plug?
				divLength	= 0

				if bFirstSkinAtReveal then
					if gs_bTurnDir then
						bDivide = (baseSkinLevel + EPS  > WIDO_SILL & baseSkinLevel - gs_thkJoint - EPS < WIDO_SILL)
						divLength = baseSkinLevel - WIDO_SILL
					else
						bDivide = (baseSkinLevel - EPS < WIDO_SILL & baseSkinLevel + gs_thkJoint + EPS > WIDO_SILL)
						divLength = baseSkinLevel + gs_thkJoint - WIDO_SILL
					endif
				else
					if gs_bTurnDir then
						bDivide = (baseSkinLevel + EPS > WALL_THICKNESS - WIDO_SILL & baseSkinLevel - gs_thkJoint - EPS < WALL_THICKNESS - WIDO_SILL)
						divLength = baseSkinLevel - gs_thkJoint - (WALL_THICKNESS - WIDO_SILL)
					else
						bDivide = (baseSkinLevel - EPS < WALL_THICKNESS - WIDO_SILL & baseSkinLevel + gs_thkJoint + EPS > WALL_THICKNESS - WIDO_SILL)
						divLength = baseSkinLevel - (WALL_THICKNESS - WIDO_SILL)
					endif
				endif

				if iRevealType = REVEAL_SLANTED & not(plugOnWindow) & bDivide then
					px1Slant = abs(divLength * tan(revealAngle))
					px1Slant = max(0,px1Slant)
				else
					px1Slant = 0
				endif

				if bFirstSkinAtReveal then
					pySill = WIDO_SILL
				else
					pySill = WALL_THICKNESS - WIDO_SILL
				endif

				if curvedWall then
					if curvedWall & not(bWndCurved) & (iRevealType <> REVEAL_NEGATIVE) & (iRevealType > REVEAL_NO) & (py4 - EPS < by) & (py3 + EPS > by) then
						xo = 0
						yo = -WOD
						ro = baseSkinRadius - (reorder exor gs_bTurnDir) * gs_thkJoint

						x1 = 0
						y1 = by
						x2 = 1
						y2 = by

						gosub 101	! Circle - Line intersection
						gosub 102	! Select good intersection point

						if (reorder exor gs_bTurnDir) then
							put	cx,				cy,		1,
								px2,			py2,	3000 * curvedWall + 1,
								px3,			py3,	1,
								px4,			py4,	3000 * curvedWall + 1

							put	-sideSign * bx,	by,		1
						else
							put	 px1,			py1,	1,
								 px2,			py2,	3000 * curvedWall + 1,
								 px3,			py3,	1,
								 cx,			cy,		3000 * curvedWall + 1,
								-bx * sideSign,	by,		1
						endif
					else
						put	px1,			py1,	1,
							px2,			py2,	3000 * curvedWall + 1,
							px3,			py3,	1,
							px4,			py4,	3000 * curvedWall + 1

						if gs_bTurnDir exor reorder exor wallIsLeft then
							put	-sideSign * bx,	by,		1,
								-sideSign * sx,	sy,		1
						else
							put	-sideSign * sx,	sy,		1,
								-sideSign * bx,	by,		1
						endif
					endif
				else
					if gs_bTurnDir exor reorder exor wallIsLeft then
						put	px1,		py1,		1,
							px1,		pySill,		1,
							distanceX,	pySill,		1,
							distanceX + px1Slant,	py3,		1,
							px3,		py3,		1,
							px4,		py4,		1
					else
						put	distanceX + px1Slant, baseSkinLevel,	1,
							distanceX,	pySill,		1,
							px1,		pySill,		1,
							px2,		py2,		1,
							px3,		py3,		1,
							px4,		py4,		1
					endif
				endif

				penFillFg	= gs_penJointFg
				penFillBg	= gs_penJointBg
				bLocalFill	= 0
				bDrawContour = 1

				gosub 200	! Draw wallblock with contour
			else
				px1Slant = bSlantedInnerSide * bFirstSkinAtReveal * not(plugOnWindow) * gs_thkJoint * tan(revealAngle)	! Slanted Reveal

				if curvedWall then
					px1Slant = 0
				else
					if bFirstSkinAtReveal exor not(gs_bTurnDir) then
						px1Slant =  bSlantedInnerSide * not(plugOnWindow) * gs_thkJoint * tan(revealAngle)	! Slanted Reveal
					else
						if baseSkinLevel > WIDO_SILL then
							px1Slant = -bSlantedInnerSide * not(plugOnWindow) * gs_thkJoint * tan(revealAngle)	! Slanted Reveal
						else
							px1Slant = 0
						endif
					endif
				endif

				put	px1 + px1Slant,	py1,	1,
					px2,			py2,	3000 * curvedWall + 1,
					px3,			py3,	1,
					px4,			py4,	3000 * curvedWall + 1

				penFillFg	= gs_penJointFg
				penFillBg	= gs_penJointBg
				bLocalFill	= 0
				bDrawContour = 1

				gosub 200	! Draw wallblock with contour

			endif		! if bCuttedPlug then
		endif		! if gs_showJoint then
	endif		! if gs_bJoint then


! Turn Skins - Traditional Mode ================================================

	if bInclinedWall & not(iCavityClosureTurnDir = CAVITY_TURN_REFERENCE) then
		bStraightInside	 = 0
		bStraightOutside = 0
	else
		bStraightInside	 = 1
		bStraightOutside = 1
	endif
	turnThk = 0

	if gs_bTurnDir then
		startCount	= possibleSkinTurnIn + 1
		endCount	= possibleSkinTurnIn + gs_nTurn
	else
		startCount	= possibleSkinTurnOut + 1
		endCount	= possibleSkinTurnOut + gs_nTurn
	endif

	bHaveShownSkinBefore = (startCount > 1)		! Skin before the first turned skins is shown or not?
	if bHaveShownSkinBefore then
		prevSkinIdx = startCount - 1
		if gs_bTurnDir then
			idx = prevSkinIdx: gosub 10	! Get proper index
		else
			idx = WALL_SKINS_NUMBER - prevSkinIdx + 1: gosub 10	! Get proper index
		endif

		bHaveShownSkinBefore = not((GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY & WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] < EPS) | \
								   (GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) < EPS))
	endif

	for i = startCount to endCount

		if gs_bTurnDir then
			idx = i: gosub 10	! Get proper index
		else
			idx = WALL_SKINS_NUMBER - i + 1: gosub 10	! Get proper index
		endif

		skinThk = WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
		bFirst	= (i = startCount)
		bLast	= (i = endCount)

		if reorder then
			cummThk = skinCummThkRef[idx + 1]
		else
			if idx > 1 then
				cummThk = skinCummThkRef[idx - 1]
			else
				cummThk = 0
			endif
		endif


! Curved Wall ==================================================================

		if curvedWall then

			bSpecCase	= (not(bIncludeReveal) & not(wallIsLeft) & not(reorder exor gs_bTurnDir))

			if gs_bTurnDir then
				py1 = cummThk + skinThk
				slantL = slantLength - py1
			else
				py1 = cummThk
				slantL = slantLength - WALL_THICKNESS + py1
			endif

			slantX = 0

! p1 point ---------------------------------------------------------------------

			xo = 0
			yo = -WOD
			if bFirstSkinAtReveal then
				if gs_bTurnDir then
					ro = rSill - (cummThk + skinThk) * signReorder
				else
					ro = rSill - cummThk * signReorder
				endif
			else
				if gs_bTurnDir then
					ro = rBoard - (cummThk + skinThk) * signReorder
				else
					ro = rBoard - cummThk * signReorder
				endif
			endif

			if bSlantedInnerSide | bParalellInCurvedWalls then
				x1 = -bx * sideSign - (turnThk + skinThk) * vectC
				y1 =  by - (turnThk + skinThk) * vectS * signWallIsLeft
				x2 = x1 - vectS
				y2 = y1 + vectC * signWallIsLeft
			else
				alfa = alfaX + (turnThk + skinThk) * lengthToAngle + dxAngle

				x1 = 0
				y1 = -WOD
				x2 = -signWallIsLeft * sin(alfa)
				y2 =  cos(alfa) - WOD
			endif

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			px1 = cx
			py1 = cy


! Valid Skin Test --------------------------------------------------------------

			if reorder exor gs_bTurnDir then
				bSkipThisSkin = (baseSkinRadius > ro - EPS)
			else
				bSkipThisSkin = (baseSkinRadius < ro + EPS)
			endif


! p4 point ---------------------------------------------------------------------

			if bFirstSkinAtReveal then
				if gs_bTurnDir then
					ro4 = rSill - cummThk * signReorder
				else
					ro4 = rSill - (cummThk + skinThk) * signReorder
				endif
			else
				if gs_bTurnDir then
					ro4 = rBoard - cummThk * signReorder
				else
					ro4 = rBoard - (cummThk + skinThk) * signReorder
				endif
			endif
			ro = ro4

			if (bSlantedInnerSide & not(bSpecCase & bFirst)) | bParalellInCurvedWalls then
				x1 = -bx * sideSign - turnThk * vectC
				y1 =  by - turnThk * vectS* signWallIsLeft
				x2 = x1 - vectS
				y2 = y1 + vectC * signWallIsLeft
			else
				alfa = alfaX + turnThk * lengthToAngle + dxAngle

				x1 = 0
				y1 = -WOD
				x2 = -signWallIsLeft * sin(alfa)
				y2 =  cos(alfa) - WOD
			endif

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			px4 = cx
			py4 = cy


! p2 point ---------------------------------------------------------------------

			ro = baseSkinRadius

			if bSlantedInnerSide | bParalellInCurvedWalls then
				x1 = -bx * sideSign - (turnThk + skinThk) * vectC
				y1 =  by - (turnThk + skinThk) * vectS * signWallIsLeft
				x2 = x1 - vectS
				y2 = y1 + vectC * signWallIsLeft
			else
				alfa = alfaX + (turnThk + skinThk) * lengthToAngle + dxAngle

				x1 = 0
				y1 = -WOD
				x2 = -signWallIsLeft * sin(alfa)
				y2 =  cos(alfa) - WOD
			endif

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			px2 = cx
			py2 = cy


! p3 point ---------------------------------------------------------------------

			if (bSlantedInnerSide & not(bSpecCase & bFirst)) | bParalellInCurvedWalls then
				x1 = -bx * sideSign - turnThk * vectC
				y1 =  by - turnThk * vectS* signWallIsLeft
				x2 = x1 - vectS
				y2 = y1 + vectC * signWallIsLeft
			else
				alfa = alfaX + turnThk * lengthToAngle + dxAngle

				x1 = 0
				y1 = -WOD
				x2 = -signWallIsLeft * sin(alfa)
				y2 =  cos(alfa) - WOD
			endif

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			px3 = cx
			py3 = cy

			if bIncludeReveal & bFirst then
				if bNegativeTurn then
					px6 = -sideSign * bx
					py6 =  by

					px5 = -sideSign * sx
					py5 =  sy
				else
					px5 = -sideSign * bx
					py5 =  by

					px6 = -sideSign * sx
					py6 =  sy
				endif

				ro = ro4	! on the same circle as the p4 point

				alfa = alfaX - not(bNegativeTurn) * alfaJamb

				if bParalellInCurvedWalls then
					x1 = -sx * sideSign
					y1 =  sy
					x2 = x1
					y2 = y1 + 1
				else
					x1 = 0
					y1 = -WOD
					x2 = -signWallIsLeft * sin(alfa)
					y2 =  cos(alfa) - WOD
				endif

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px7 = cx
				py7 = cy

				if px4 > px7 - EPS then		! to avoid generating degenerated polygons
					px4 = px7
					py4 = py7
				endif
			endif

		else

! Straight Wall, Trapezoid Wall ================================================

			if bInclinedWall then
				inclinedWallDiffInside	= skinCummThkOpp[idx] / incH
				if idx > 1 then
					inclinedWallDiffOutside	= skinCummThkOpp[idx - 1] / incH
				else
					inclinedWallDiffOutside = 0
				endif
			endif
			slantDiffUpper = not(bFirstSkinAtReveal exor not(gs_bTurnDir)) * bSlantedInnerSide * ((turnThk + skinThk) - (turnThk + skinThk) / cos(revealAngle))
			slantDiffLower = not(bFirstSkinAtReveal exor not(gs_bTurnDir)) * bSlantedInnerSide * (turnThk - turnThk / cos(revealAngle))

			py2 = lengthSkinTurnIn
			if gs_bTurnDir then
				slantL = slantLength - py2
			else
				slantL = slantLength - WALL_THICKNESS+ py2
			endif
			px2 = distanceX + dx + turnThk + skinThk + slantL * slantX - slantDiffUpper

			if not(bStraightInside) then
				bStraightInside = (WALL_SKINS_PARAMS[idx][SKIN_THICKEN_TRAPEZOID])
			endif

			if gs_bTurnDir then
				py1 = cummThk + skinThk
				slantL = slantLength - py1
			else
				py1 = cummThk
				if bInclinedWall & not(bStraightInside) then
					py1 = WALL_THICKNESS - inclinedWallDiffInside
					py1 = py1 + (distanceX + dx + turnThk + skinThk) * incHor * sideSign * iInclDir
				endif
				slantL = slantLength - WALL_THICKNESS + py1
			endif

			if bInclinedWall & not(bStraightInside) & bSlantedInnerSide then
				x11 = 0
				y11 = WALL_THICKNESS - inclinedWallDiffInside
				x12 = x11 + incH * sideSign
				y12 = y11 + incV

				x21 = px2
				y21 = py2
				x22 = x21 + sin(revealAngle)
				y22 = y21 + cos(revealAngle)

				gosub 100	! Line - Line intersection

				px1 = cx
				py1 = cy
			else
				px1 = distanceX + dx + turnThk + skinThk + slantL * slantX - slantDiffUpper
			endif

			if gs_bTurnDir then
				bSkipThisSkin = (lengthSkinTurnIn < py1 + EPS)
			else
				bSkipThisSkin = (lengthSkinTurnIn > py1 - EPS)
			endif

			py3 = lengthSkinTurnIn
			if gs_bTurnDir then
				slantL = slantLength - py3
			else
				slantL = slantLength - WALL_THICKNESS + py3
			endif
			px3 = distanceX + dx + turnThk + slantL * slantX - slantDiffLower

			if bIncludeReveal & bFirst then
				if WIDO_SILL < EPS then
					py5 = cummThk
					px5 = distanceX + (py5 - WIDO_SILL)* tan(revealAngle)
				else
					if gs_bTurnDir exor bNegativeTurn then
						py5 = WIDO_SILL
					else
						py5 = WALL_THICKNESS - WIDO_SILL
					endif
					px5 = distanceX + bNegativeTurn * revealWidth

					if gs_bTurnDir exor bNegativeTurn then
						py6 = WIDO_SILL
					else
						py6 = WALL_THICKNESS - WIDO_SILL
					endif
					px6 = distanceX - not(bNegativeTurn) * revealWidth

					if gs_bTurnDir then
						py7 = cummThk
					else
						py7 = cummThk + skinThk
					endif
					px7 = distanceX - not(bNegativeTurn) * revealWidth
				endif
			endif

			if gs_bTurnDir then
				py4 = cummThk
				slantL = slantLength - py4
			else
				py4 = cummThk + skinThk
				if bInclinedWall & not(bStraightOutside)then
					py4 = WALL_THICKNESS - inclinedWallDiffOutside
					py4 = py4 + (distanceX + dx + turnThk) * incHor * sideSign * iInclDir
				endif
				slantL = slantLength - WALL_THICKNESS + py4
			endif

			if bInclinedWall & not(bStraightOutside) & bSlantedInnerSide then
				x11 = 0
				y11 = WALL_THICKNESS - inclinedWallDiffOutside
				x12 = x11 + incH * sideSign
				y12 = y11 + incV

				x21 = px3
				y21 = py3
				x22 = x21 + sin(revealAngle)
				y22 = y21 + cos(revealAngle)

				gosub 100	! Line - Line intersection

				px4 = cx
				py4 = cy
			else
				px4 = distanceX + dx + turnThk + (slantL)* slantX - slantDiffLower
			endif

			if not(bStraightOutside) then
				bStraightOutside = (WALL_SKINS_PARAMS[idx][SKIN_THICKEN_TRAPEZOID])
	        endif
		endif

! Draw the turned skins ========================================================

		bShowSkin = not(GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY & WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] < EPS)

		if not(bSkipThisSkin) & bShowSkin then

			skinFillType		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL])
			skinFillFgPen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_PEN])
			skinFillBgPen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_BACK_PEN])
			skinFillOrientation	= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_ORIENTATION])

			fill skinFillType
			bLocalFill	= skinFillOrientation
			penFillFg	= skinFillFgPen
			penFillBg	= skinFillBgPen

			if gs_bTurnDir then
				bCond = (baseSkinLevel - gs_thkJoint < WIDO_SILL)
			else
				bCond = (baseSkinLevel + gs_thkJoint < WIDO_SILL)
			endif

			if bFirst & abs(slantX) > EPS & bCond then

				if gs_bTurnDir then
					boardY = by + WALL_THICKNESS - WIDO_SILL
				else
					boardY = by + WIDO_SILL
				endif
				put	px1,			py1,	0,
					px2,			py2,	0,
					bx * sideSign,	py3,	0,
					bx * sideSign,	boardY, 0,
					px4,			py4,	0
			else
				if bIncludeReveal & bFirst then
					if WIDO_SILL < EPS then
						put	px1,	py1,	0,
							px2,	py2,	0,
							px3,	py3,	0,
							px5,	py5,	0,
							px4,	py4,	0
					else
						put	px1,	py1,	0,
							px2,	py2,	0,
							px3,	py3,	3000 * curvedWall,
							px5,	py5,	0,
							px6,	py6,	0,
							px7,	py7,	0,
							px4,	py4,	3000 * curvedWall
					endif
				else
					if curvedWall & not(bWndCurved) & bFirst & (iRevealType <> REVEAL_NEGATIVE) & (iRevealType > REVEAL_NO) & (py3 - EPS < by) & (py4 + EPS > by) then
						xo = 0
						yo = -WOD
						ro = baseSkinRadius

						x1 = 0
						y1 = by
						x2 = 1
						y2 = by

						gosub 101	! Circle - Line intersection
						gosub 102	! Select good intersection point

						put	 px1,			py1,	0,
							 px2,			py2,	0,
							 cx,			cy,		3000,
							-sx * sideSign,	sy,		0,
							 px4,			py4,	0

						px3 = -sx * sideSign
						py3 =  sy
					else
						put	px1,	py1,	0,
							px2,	py2,	0,
							px3,	py3,	3000 * curvedWall,
							px4,	py4,	0
					endif
				endif
			endif

			bDrawContour = 0
			gosub 200	! Draw wallblock

			bShowLine = 0
			if gs_bTurnDir then
				tempPen		 = round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN])
				tempLineType = round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE])
			else
				tempPen		 = round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
				tempLineType = round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])
			endif
			if tempPen > EPS then
				pen			tempPen
				line_type	tempLineType
				if GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY then
					line_property LINE_PROPERTY_CONTOUR
				else
					line_property LINE_PROPERTY_INNER
				endif

				wallline2	px1,py1, px2,py2

				if not(gs_bJoint) or gs_bJoint * not(gs_showJoint) then	! Contonouous mode
					if not(bForceContinousMode) & (baseSkinFillType <> skinFillType | baseSkinFillFgPen <> skinFillFgPen | baseSkinFillBgPen <> skinFillBgPen | baseSkinFillOrientation <> skinFillOrientation) then
						if baseSkinContLinePen > EPS then
						if not(gs_thkJoint) then pen baseSkinContLinePen
							line_type	baseSkinContLineType

							wallline2 px2,py2, px3,py3
						endif
					endif
				endif
			endif
		endif

		if bFirst & bShowSkin then
			if gs_bTurnDir then
				tempPen		 = round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
				tempLineType = round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])
			else
				tempPen		 = round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN])
				tempLineType = round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE])
			endif
			if tempPen > EPS then
				pen			tempPen
				line_type	tempLineType
				if bHaveShownSkinBefore then
					line_property LINE_PROPERTY_INNER
				else
					line_property LINE_PROPERTY_CONTOUR
				endif

				if not(curvedWall) | (py4 < py3 exor wallIsLeft exor reorder) then
					if abs(slantX) < EPS then
						if bIncludeReveal then
							if WIDO_SILL < EPS then
								wallline2	px3,py3, px5,py5
							else
								if ((wallIsLeft exor reorder) & maxSkinTurnIn = 0) | (not(wallIsLeft exor reorder) & maxSkinTurnOut = 0) then
									line_property LINE_PROPERTY_CONTOUR
								endif

								if not(bInclinedWall & not(gs_bTurnDir)) then
									! because the top of the "bIncludeReveal" polygon does not fit to the inclined wall's slanted side
									wallline2	px4,py4, px7,py7
								endif
							endif
						else
							wallline2	px3,py3, px4,py4
						endif
					endif
				else
					if curvedWall & bIncludeReveal then
						R = sqr(px4^2 + (py4 + WOD)^2)

						vx = px4
						vy = py4 + WOD
						gosub 103	! Direction Angle
						alpha = angle

						vx = px7
						vy = py7 + WOD
						gosub 103	! Direction Angle
						beta = angle

						if abs(alpha - beta) > EPS then
							wallarc2 0,-WOD, R, min(alpha,beta), max(alpha,beta)
						endif
					endif
				endif

				if iRevealType = REVEAL_NEGATIVE then

					line_property LINE_PROPERTY_INNER

					if curvedWall & bWndCurved then
						R = sqr(bx^2 + (by + WOD)^2)

						vx = -bx * sideSign
						vy =  by + WOD
						gosub 103	! Direction Angle
						alpha = angle

						vx = -sx * sideSign
						vy =  sy + WOD
						gosub 103	! Direction Angle
						beta = angle

						if abs(alpha - beta) > EPS then
							wallarc2 0,-WOD, R, min(alpha,beta), max(alpha,beta)
						endif
					else
						if curvedWall then
							revealY = by
							signTemp = -1
						else
							signTemp = 1
							if reorder exor wallIsLeft then
								revealY = by + WIDO_SILL
							else
								revealY = by + WALL_THICKNESS - WIDO_SILL
							endif
						endif

						wallline2	bx * signTemp * sideSign, revealY,
									sx * signTemp  * sideSign, revealY
						if bDrawObjContourIn | bDrawObjContourOut then
							line2	bx * signTemp  * sideSign, revealY,
									sx * signTemp  * sideSign, revealY
						endif
					endif
				endif
			endif
		endif

		turnThk = turnThk + skinThk
	next i
return


! ==============================================================================
!		Prefabricated Cavity Closure
! ------------------------------------------------------------------------------
! Input variables:
!	possibleSkinTurnIn:		number of possible plaster skins at the Outside Face
!	possibleSkinTurnOut:	number of possible plaster skins at the Inside Face
!	distanceX:				horizontal distance from the original origo
!	alfaX:					alfa x in case of curved walls (alfaX > 0)
!	alfaJamb:				jamb alfa (alfaJamb > 0)
!	revealWidth:			width of the reveal
!	skinCummThkRef:			precalculated cummulative skin thickness from the Outside Face
! ==============================================================================

3000:
	if lastCoreSkin = 0 then
		return
	endif

	nSkins = WALL_SKINS_NUMBER - possibleSkinTurnOut - possibleSkinTurnIn
	if nSkins < 3 then return

	bSlantedInnerSide	= (iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED)
	bNegativeReveal		= (iRevealType = REVEAL_NEGATIVE)

	fill gs_fillPlug
	pen gs_penPlug
	line_type gs_ltPlug
	line_property LINE_PROPERTY_INNER

	idx = possibleSkinTurnIn + 1
	gosub 10	! Get proper index
	begH = skinCummThkRef[idx]
	properBegIdx = idx

	idx = min(lastCoreSkin - 1, possibleSkinTurnIn + nSkins - 1)

	if idx < 1 then
		return
	endif

	gosub 10	! Get proper index

	endH = skinCummThkRef[idx]
	properEndIdx = idx

	if abs(endH - begH) < EPS then return

	if curvedWall then

! Curved Wall ==================================================================

		rWindowEdge = sqr((bx * sideSign)^2 + (by + WOD)^2)
		rRevealEdge = sqr((sx * sideSign)^2 + (sy + WOD)^2)

		if reorder then
			rBegH = min(rSill, rBoard) + begH
			rEndH = min(rSill, rBoard) + endH
		else
			rBegH = max(rSill, rBoard) - begH
			rEndH = max(rSill, rBoard) - endH
		endif
		plugAngle = gs_widthPlug * (180 / max(rBegH, rEndH) / PI)

		if wallIsLeft exor (iRevealType = REVEAL_NEGATIVE) then
			refH = min(rBegH, rEndH)
			oppH = max(rBegH, rEndH)
		else
			refH = max(rBegH, rEndH)
			oppH = min(rBegH, rEndH)
		endif

! Curved walls - Slanted Reveal ================================================

		if bSlantedInnerSide | bParalellInCurvedWalls then

			xo = 0
			yo = -WOD
			ro = refH

			if wallIsLeft then

				bPullBackPlug = 0

				if rWindowEdge < refH + EPS then
					bSlantedPlug = 0
				else
					bSlantedPlug = 1
				endif

				if (rWindowEdge < oppH & rWindowEdge > refH) then
					bCuttedPlug = 1
				else
					bCuttedPlug = 0
				endif
			else
				bPullBackPlug = (rWindowEdge > refH + EPS & rRevealEdge < refH + EPS)

				if rWindowEdge > refH + EPS & rRevealEdge > refH + EPS then
					bSlantedPlug = 0
				else
					bSlantedPlug = 1
				endif

				if (rWindowEdge > oppH & rWindowEdge < refH) | (rRevealEdge > oppH & rRevealEdge < refH) then
					bCuttedPlug = 1
				else
					bCuttedPlug = 0
				endif
			endif

			if bParalellInCurvedWalls then
				bCuttedPlug = 0
				bSlantedPlug =1
			endif

			if bSlantedPlug & not(bPullBackPlug) then
				if bWndCurved then
					x1 = -rSillLine * sin(alfaX)
					y1 = iArchSign * (-abs(WOD) + rSillLine * cos(alfaX))
					x2 = x1 - sin(revealAngle)
					y2 = y1 - cos(revealAngle)
				else
					x1 = -distanceX
					y1 = 0
					x2 = -distanceX - wallThkOppSide * tan(revealAngle)
					y2 = -wallThkOppSide
				endif

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point

				alfaPlug = -signWallIsLeft * atn(cx / (WOD + cy))

				ro = oppH
				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point

				alfaPlugOpp = -signWallIsLeft * atn(cx / (WOD + cy))

				sin1 = sin(alfaPlug)
				cos1 = cos(alfaPlug) * signWallIsLeft
				sin2 = sin(alfaPlug + plugAngle)
				cos2 = cos(alfaPlug + plugAngle) * signWallIsLeft
				sin3 = sin(alfaPlugOpp)
				cos3 = cos(alfaPlugOpp) * signWallIsLeft
				if bCuttedPlug then
					if bWndCurved then
						alpha = atn(bx * sideSign / (by + WOD))
					else
						alpha = atn(distanceX / WOD)
					endif
					sin4 = sin(alpha)
					cos4 = cos(alpha)
				endif

				if wallIsLeft exor reorder then
					if bCuttedPlug then
						x1 = -rBegH * sin4 * signWallIsLeft
						y1 = -WOD + rBegH * cos4 * signWallIsLeft
					else
						x1 = -rBegH * sin3
						y1 = -WOD + rBegH * cos3
					endif
				else
					x1 = -rBegH * sin1
					y1 = -WOD + rBegH * cos1
				endif

				x2 = -rBegH * sin2
				y2 = -WOD + rBegH * cos2

				x3 = -rEndH * sin2
				y3 = -WOD + rEndH * cos2

				if bCuttedPlug then
					if wallIsLeft exor reorder then
						x4 = -rEndH * sin1
						y4 = -WOD + rEndH * cos1

						x5 = -bx * sideSign
						y5 = by
					else
						x4 = -rEndH * sin4 * signWallIsLeft
						y4 = -WOD + rEndH * cos4 * signWallIsLeft

						x5 = -bx * sideSign
						y5 = by
					endif
				else
					if wallIsLeft exor reorder then
						x4 = -rEndH * sin1
						y4 = -WOD + rEndH * cos1
					else
						x4 = -rEndH * sin3
						y4 = -WOD + rEndH * cos3
					endif
				endif

				put x1,	y1,	1,
					x2,	y2,	3001,
					x3,	y3,	1,
					x4,	y4,	3001

				if bCuttedPlug then
					put x5,y5, 1
				endif

			else	! if bSlantedPlug & not(bPullBackPlug) then

				if bPullBackPlug then
					alfaPlug = abs(atn(bx / (by + WOD)))
				else
					alfaPlug = alfaX - alfaJamb
				endif

				sin1 = sin(alfaPlug)
				cos1 = cos(alfaPlug) * signWallIsLeft
				sin2 = sin(alfaPlug + plugAngle)
				cos2 = cos(alfaPlug + plugAngle) * signWallIsLeft

				x1 = -rBegH * sin1
				y1 = -WOD + rBegH * cos1

				x2 = -rBegH * sin2
				y2 = -WOD + rBegH * cos2

				x3 = -rEndH * sin2
				y3 = -WOD + rEndH * cos2

				x4 = -rEndH * sin1
				y4 = -WOD + rEndH * cos1

				put x1,y1, 1,
					x2,y2, 3001,
					x3,y3, 1,
					x4,y4, 3001
			endif	! if bSlantedPlug & not(bPullBackPlug) then ... else

		endif	! if bSlantedInnerSide then

! bPullBackPlug ================================================================

		if bWndCurved then
			if bNegativeReveal then
				if wallIsLeft then
					bPullBackPlug = (max(rBegH, rEndH) <= rSillLine + EPS)
				else
					bPullBackPlug = (min(rBegH, rEndH) >= rSillLine - EPS)
				endif
			else
				if wallIsLeft then
					bPullBackPlug = (min(rBegH, rEndH) <= rSillLine - EPS)
				else
					bPullBackPlug = (max(rBegH, rEndH) >= rSillLine + EPS)
				endif
			endif
		else
			if wallIsLeft then
				rCorner	= max(rWindowEdge, rRevealEdge)
			else
				rCorner	= min(rWindowEdge, rRevealEdge)
			endif

			if bNegativeReveal then
				if wallIsLeft then
					bPullBackPlug = (max(rBegH, rEndH) <= rCorner + EPS)
				else
					bPullBackPlug = (min(rBegH, rEndH) >= rCorner + EPS)
				endif
			else
				rWindowInnerEdge = sqr((distanceX)^2 + (WOD - WIDO_FRAME_THICKNESS)^2)

				if wallIsLeft then
					bPullBackPlug = ((min(rBegH, rEndH) < rCorner + EPS) | (min(rBegH, rEndH) < rWindowInnerEdge + EPS))
				else
					bPullBackPlug = ((max(rBegH, rEndH) > rCorner + EPS) | (max(rBegH, rEndH) > rWindowInnerEdge + EPS))
				endif
			endif
		endif

! Curved walls - not Slanted Reveal ============================================

		if not(bSlantedInnerSide | bParalellInCurvedWalls ) then

			if bPullBackPlug then
				if abs(bx) < abs(sx) exor bNegativeReveal then
					alfaPlug = abs(atn(abs(sx) / (WOD + sy)))
				else
					alfaPlug = abs(atn(abs(bx) / (WOD + by)))
				endif
			else
				alfaPlug = alfaX - alfaJamb
			endif

			alfaPlugOpp = alfaPlug

			sin1 = sin(alfaPlug)
			cos1 = cos(alfaPlug) * signWallIsLeft
			sin2 = sin(alfaPlug + plugAngle)
			cos2 = cos(alfaPlug + plugAngle) * signWallIsLeft
			sin3 = sin(alfaPlugOpp)
			cos3 = cos(alfaPlugOpp) * signWallIsLeft

			if wallIsLeft then
				x1 = -rBegH * sin1
				y1 = -WOD + rBegH * cos1
			else
				x1 = -rBegH * sin3
				y1 = -WOD + rBegH * cos3
			endif

			x2 = -rBegH * sin2
			y2 = -WOD + rBegH * cos2

			x3 = -rEndH * sin2
			y3 = -WOD + rEndH * cos2

			if wallIsLeft then
				x4 = -rEndH * sin3
				y4 = -WOD + rEndH * cos3
			else
				x4 = -rEndH * sin1
				y4 = -WOD + rEndH * cos1
			endif

			put x1,y1, 1,
				x2,y2, 3001,
				x3,y3, 1,
				x4,y4, 3001
		endif	! if bSlantedInnerSide then

	else	! if curvedWall then


! Straight and Trapezoid Wall ==================================================

		if wallIsLeft exor bNegativeReveal exor reorder then
			if iRevealType = REVEAL_NEGATIVE then
				revealLevel = WALL_THICKNESS - WIDO_SILL
				bPullBackPlug = (begH + EPS < revealLevel)
			else
				revealLevel = WIDO_SILL
				bPullBackPlug = (endH - EPS > revealLevel)
			endif
		else
			if iRevealType = REVEAL_NEGATIVE then
				revealLevel = WIDO_SILL
			else
				revealLevel = WALL_THICKNESS - WIDO_SILL
			endif
			bPullBackPlug = (begH + EPS < revealLevel)
		endif

		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
			posPlug = distanceX
			bPullBackPlug = 0
		endif
		if iRevealType = REVEAL_POSITIVE then
			posPlug = distanceX - not(bPullBackPlug) * revealWidth
		endif
		if iRevealType = REVEAL_NEGATIVE then
			posPlug = distanceX + bPullBackPlug * revealWidth
		endif
		if iRevealType = REVEAL_SLANTED then
			posPlug = distanceX - not(bPullBackPlug) * revealWidth
		endif

		if bSlantedInnerSide & bPullBackPlug then
			if wallIsLeft exor reorder then
				sillLine = WIDO_SILL
			else
				sillLine = WALL_THICKNESS - WIDO_SILL
			endif

			if wallIsLeft exor reorder then
				refH = endH
				oppH = begH
			else
				refH = begH
				oppH = endH
			endif

			x11 = distanceX
			y11 = sillLine
			x12 = x11 + sin(revealAngle)
			y12 = y11 + signWallIsLeft * signReorder * cos(revealAngle)

			x21 = 0
			y21 = refH
			x22 = 1
			y22 = refH

			gosub 100	! Line - Line intersection

			if sillLine < endH & sillLine > begH then
				put posPlug, sillLine, 1,
					posPlug, oppH, 1
			else
				put cx - (endH-begH) * tan(revealAngle), oppH, 1
			endif

			put	cx + gs_widthPlug, oppH, 1,
				cx + gs_widthPlug, refH, 1,
				cx, refH, 1
		else
			put	posPlug, begH, 1,
				posPlug, endH, 1,
				posPlug + gs_widthPlug, endH, 1,
				posPlug + gs_widthPlug, begH, 1
		endif

	endif	! if curvedWall then

! Draw Insulation Plug =========================================================

	bLocalFill	= 0
	penFillFg	= gs_penPlugFg
	penFillBg	= gs_penPlugBg
	bDrawContour = 1

	gosub 200	! Draw wallblock with contour


! Draw wall skin part ==========================================================

	if (wallIsLeft exor bNegativeReveal exor reorder) | bInclinedWall then
		if iRevealType = REVEAL_NEGATIVE & bInclinedWall then
			y1 = revealLevel
			y2 = endH
			if reorder then
				idx = properEndIdx - 1
			else
				idx = properEndIdx + 1
			endif
		else
			y1 = begH
			y2 = revealLevel
			idx = properBegIdx
		endif
	else
		y1 = revealLevel
		y2 = endH
		if reorder then
			idx = properEndIdx - 1
		else
			idx = properEndIdx + 1
		endif
	endif

	bShowSkin = not(GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY & WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] < EPS)

	if bShowSkin then
		if curvedWall then
			if (bPullBackPlug exor bNegativeReveal) & iRevealType > REVEAL_NO then
				aWindowEdge = atn(bx * sideSign / (by + WOD))
				aRevealEdge = atn(sx * sideSign / (sy + WOD))

				px1 = -bx * sideSign
				py1 =  by

				px2 = -sx * sideSign
				py2 =  sy

				if bParalellInCurvedWalls then
					xo = 0
					yo = -WOD
					ro = oppH

					x1 = px2
					y1 = py2
					x2 = x1
					y2 = y1 + 1

					gosub 101	! Circle - Line intersection
					gosub 102	! Select good intersection point
					px3 = cx
					py3 = cy

					x1 = px1
					y1 = py1
					x2 = x1
					y2 = y1 + 1

					gosub 101	! Circle - Line intersection
					gosub 102	! Select good intersection point
					px4 = cx
					py4 = cy
				else
					px3 = -signWallIsLeft * oppH * sin(aRevealEdge)
					py3 = -WOD + signWallIsLeft * oppH * cos(aRevealEdge)

					px4 = -signWallIsLeft * oppH * sin(aWindowEdge)
					py4 = -WOD + signWallIsLeft * oppH * cos(aWindowEdge)
				endif

				bSkip4 = (abs(px1 - px4) < EPS & abs(py1 - py4) < EPS)		! Avoid generating invalid polygon

				put	px1, py1, 0,
					px2, py2, 3000 * bWndCurved + 1

				if wallIsLeft then
					if bWndCurved then
						if not(bNegativeReveal) & oppH > rWindowEdge + EPS & refH < rWindowEdge - EPS then
							put px3, py3, 0,
								px4, py4, 3000
						endif
						if bNegativeReveal & refH > rWindowEdge + EPS & oppH < rWindowEdge - EPS then
							put px3, py3, 0,
								px4, py4, 3000
						endif
					else
						bOutPoint = 0
						if py3 > py2 exor bNegativeReveal then
							put px3, py3, 0
							bOutPoint = 1
						endif
						if (py4 > py1 exor bNegativeReveal) & not(bSkip4) then
							put px4, py4, 3000 * bOutPoint
						endif
					endif
				else
					if bWndCurved then
						if not(bNegativeReveal) & refH > rWindowEdge + EPS & oppH < rWindowEdge - EPS then
							put px3, py3, 0,
								px4, py4, 3000
						endif
						if bNegativeReveal & oppH > rWindowEdge + EPS & refH < rWindowEdge - EPS then
							put px3, py3, 0,
								px4, py4, 3000
						endif
					else
						bOutPoint = 0
						if py3 > py2 exor bNegativeReveal then
							put px3, py3, 0
							bOutPoint = 1
						endif
						if (py4 > py1 exor bNegativeReveal) & not(bSkip4) then
							put px4, py4, 3000 * bOutPoint
						endif
					endif
				endif

				fill		  round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL])
				bLocalFill	= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_ORIENTATION])
				penFillFg	= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_PEN])
				penFillBg	= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_BACK_PEN])

				if WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN] > EPS then
					pen WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN]
					line_type WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE]
					line_property LINE_PROPERTY_INNER
					bDrawContour = 1
				else
					bDrawContour = 0
				endif

				gosub 200	! Draw wallblock with contour
			endif

		else	! if curvedWall then

			if bPullBackPlug then
				x1 = distanceX
				if iRevealType = REVEAL_POSITIVE then x2 = distanceX - revealWidth
				if iRevealType = REVEAL_NEGATIVE then x2 = distanceX + revealWidth
				if iRevealType = REVEAL_SLANTED  then x2 = distanceX - revealWidth

				if y2 > y1 then
					fill		 WALL_SKINS_PARAMS[idx][SKIN_FILL]
					bLocalFill = round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_ORIENTATION])
					wallblock2 4, 2 + 24 * bLocalFill + 32,
						WALL_SKINS_PARAMS[idx][SKIN_FILL_PEN],
						WALL_SKINS_PARAMS[idx][SKIN_FILL_BACK_PEN],
						0,0,0,
						x1, y1, 1,
						x1, y2, 1,
						x2, y2, 1,
						x2, y1, 1
				endif

				if WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN] > EPS then
					pen WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN]
					line_type WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE]
					line_property LINE_PROPERTY_INNER

					if (wallIsLeft exor bNegativeReveal exor reorder) then
						wallline2 x1,y2, x2,y2
					else
						wallline2 x1,y1, x2,y1
					endif
				endif
			endif

		endif	! if curvedWall then
	endif
return



! ==============================================================================
! Wall Contour Lines
! ------------------------------------------------------------------------------
! Input variables:
! ==============================================================================

4000:

	if (wallIsLeft exor reorder) then
		if GLOB_STRUCTURE_DISPLAY = STRUCTURE_ENTIRE_STRUCTURE then
			bPlasterAtSill	= (nSkinTurnIn  > 0)
			bPlasterAtBoard	= (nSkinTurnOut > 0)

			thkPlasterAtSill	= thkSkinTurnIn
			thkPlasterAtBoard	= thkSkinTurnOut
		else
			bPlasterAtSill	= (nSkinTurnIn  - nFinishSkinTurnIn  > 0)
			bPlasterAtBoard	= (nSkinTurnOut - nFinishSkinTurnOut > 0)

			thkPlasterAtSill	= thkSkinTurnIn  - thkFinishSkinTurnIn
			thkPlasterAtBoard	= thkSkinTurnOut - thkFinishSkinTurnOut
		endif
	else
		if GLOB_STRUCTURE_DISPLAY = STRUCTURE_ENTIRE_STRUCTURE then
			bPlasterAtSill	= (nSkinTurnOut > 0)
			bPlasterAtBoard	= (nSkinTurnIn  > 0)

			thkPlasterAtSill	= thkSkinTurnOut
			thkPlasterAtBoard	= thkSkinTurnIn
		else
			bPlasterAtSill	= (nSkinTurnOut - nFinishSkinTurnOut > 0)
			bPlasterAtBoard	= (nSkinTurnIn  - nFinishSkinTurnIn  > 0)

			thkPlasterAtSill	= thkSkinTurnOut - thkFinishSkinTurnOut
			thkPlasterAtBoard	= thkSkinTurnIn  - thkFinishSkinTurnIn
		endif
	endif

	bNeedContourAtSill	= not(bCompositeWall) | not(bPlasterAtSill)
	bNeedContourAtBoard	= not(bCompositeWall) | not(bPlasterAtBoard)

	bDrawFrameContourAtSill = (bDrawObjContourIn | bDrawObjContourOut) | bPlasterAtSill

	if curvedWall then
		if bParalellInCurvedWalls then
			xo = 0
			yo = -WOD
			ro = rSill + ySign * offsetSill

			x1 = sx
			y1 = sy
			x2 = x1
			y2 = y1 + 1

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			px1 = cx
			py1 = cy
		else
			if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
				px1 = sideSign * (rSill + ySign * offsetSill) * sin(alfaX)
				py1 = -WOD - ySign * (rSill + ySign * offsetSill) * cos(alfaX)
			else
				px1 = sideSign * (rSill + ySign * offsetSill) * sin(alfaX - alfaJamb)
				py1 = -WOD - ySign * (rSill + ySign * offsetSill) * cos(alfaX - alfaJamb)
			endif
		endif

		px3 = bx
		py3 = by

		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE then
			if bParalellInCurvedWalls then
				xo = 0
				yo = -WOD
				ro = rBoard - ySign * offsetBoard

				x1 = bx
				y1 = by
				x2 = x1
				y2 = y1 + 1

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px2 = cx
				py2 = cy
			else
				px2 = sideSign * (rBoard - ySign * offsetBoard) * sin(alfaX)
				py2 = -WOD - ySign * (rBoard - ySign * offsetBoard) * cos(alfaX)

				if offsetSill > EPS & not(bDrawFrameContour) then
					cx = sideSign * (rSill + ySign * offsetSill) * sin(alfaX)
					cy = -WOD - ySign * (rSill + ySign * offsetSill) * cos(alfaX)
					if cy < py3 then
						px3 = cx
						py3 = cy
					endif
				endif
			endif

			if bWndCurved then
				px5 = bx - signWallIsLeft * sideSign * WIDO_FRAME_THICKNESS * sin(alfaX)
				py5 = by - WIDO_FRAME_THICKNESS * cos(alfaX)
			else
				if wallIsLeft then
					px5 = sideSign * distanceX
					py5 = -WIDO_FRAME_THICKNESS
				else
					px5 = bx + sideSign * (WIDO_FRAME_THICKNESS * tan(alfaX))
					py5 = -WIDO_FRAME_THICKNESS
				endif

				if bWindowSymbolAtMiddle then		! CHI Special
					dy = (WALL_THICKNESS - WIDO_FRAME_THICKNESS) / 2 - WIDO_SILL
					px5 = px5 - dy * signWallIsLeft * sideSign * tan(alfaX)
					py5 = py5 - dy
				endif

			endif
		endif

		if bWindowSymbolAtMiddle then		! CHI Special
			dy = (WALL_THICKNESS - WIDO_FRAME_THICKNESS) / 2 - WIDO_SILL
			px3 = px3 - dy * signWallIsLeft * sideSign * tan(alfaX)
			py3 = py3 - dy
		endif

		if bWndCurved then
			if iRevealType = REVEAL_NEGATIVE then
				px4 = sx
				py4 = sy
			else
				xo = 0
				yo = -WOD
				ro = rSillLine

				if bParalellInCurvedWalls then
					x1 = sx - sideSign * thkPlasterAtSill
					y1 = sy + signWallIsLeft * thkPlasterAtSill
					x2 = x1
					y2 = y1 + 1
				else
					x1 = sx - sideSign * thkPlasterAtSill * cos(alfaX - alfaJamb)
					y1 = sy + signWallIsLeft * thkPlasterAtSill * sin(alfaX - alfaJamb)
					x2 = x1 + signWallIsLeft * sideSign * sin(alfaX - alfaJamb)
					y2 = y1 + cos(alfaX - alfaJamb)
				endif

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px4 = cx
				py4 = cy
			endif
		else
			if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_SLANTED then
				if bParalellInCurvedWalls then
					px4 = sx - sideSign * thkPlasterAtSill
					py4 = sy
				else
					px4 = sx - sideSign * thkPlasterAtSill / cos(alfaX)
					py4 = sy
				endif
			else
				px4 = sx
				py4 = sy
			endif
		endif

		if iRevealType = REVEAL_SLANTED then
			xo = 0
			yo = -WOD
			ro = rBoard - ySign * offsetBoard

			x1 = bx
			y1 = by
			x2 = x1 - sideSign * sin(revealAngle)
			y2 = y1 + cos(revealAngle)

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			px2 = cx
			py2 = cy

			if offsetSill > EPS & not(bDrawFrameContour) then
				xo = 0
				yo = -WOD
				ro = rSill + ySign * offsetSill

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				if cy < py3 then
					px3 = cx
					py3 = cy
				endif
			endif

			if bWndCurved then
				ro = rSillLine - signWallIsLeft * WIDO_FRAME_THICKNESS

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px5 = cx
				py5 = cy
			else
				px5 = sideSign * (distanceX + WIDO_FRAME_THICKNESS * tan(revealAngle))
				py5 = -WIDO_FRAME_THICKNESS
			endif
		endif

		if iRevealType = REVEAL_SLANTED then
			alpha = revealAngle
			signTemp = -1
		else
			alpha = alfaX
			signTemp = signWallIsLeft
		endif
		if bWndCurved then
			xo = 0
			yo = -WOD
			ro = rSillLine - signWallIsLeft * WIDO_FRAME_THICKNESS

			if bParalellInCurvedWalls then
				x1 = bx - sideSign * thkPlasterAtBoard
				y1 = by
				x2 = x1
				y2 = y1 + 1
			else
				x1 = bx - sideSign * thkPlasterAtBoard * cos(alpha)
				y1 = by - thkPlasterAtBoard * sin(alpha)
				x2 = x1 + signTemp * sideSign * sin(alpha)
				y2 = y1 + cos(alpha)
			endif

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			px6 = cx
			py6 = cy
		else
			if bParalellInCurvedWalls then
				px6 = px5 - sideSign * thkPlasterAtBoard
				py6 = py5
			else
				px6 = px5 - sideSign * thkPlasterAtBoard / cos(alpha)
				py6 = py5
			endif
		endif
	else
		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
			px1 = sideSign * (distanceX - thkPlasterAtSill)
			py1 = WIDO_SILL - offsetSill
		endif
		if iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_SLANTED then
			px1 = sideSign * (distanceX - revealWidth - thkPlasterAtSill)
			py1 = WIDO_SILL - offsetSill
		endif
		if iRevealType = REVEAL_NEGATIVE then
			px1 = sideSign * (distanceX + revealWidth - thkPlasterAtSill)
			py1 = WIDO_SILL - offsetSill
		endif

		px3 = sideSign * distanceX
		py3 = 0

		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE then
			px2 = sideSign * distanceX
			if bInclinedWall then
				py2 = -WALL_THICKNESS + WIDO_SILL - sideSign * distanceX * iInclDir * tan(WALL_INCL) + offsetBoard / incH
			else
				py2 = -WALL_THICKNESS + WIDO_SILL - sideSign * distanceX * iInclDir * tan(WALL_INCL) + offsetBoard
			endif

			if offsetSill > EPS & not(bDrawFrameContour) then
				cx = px2
				cy = WIDO_SILL - offsetSill
				if cy < py3 then
					px3 = cx
					py3 = cy
				endif
			endif

			px5 = sideSign * distanceX
			py5 = -WIDO_FRAME_THICKNESS

			if bWindowSymbolAtMiddle then		! CHI Special
				dy = (WALL_THICKNESS - WIDO_FRAME_THICKNESS) / 2 - WIDO_SILL
				py5 = py5 - dy
			endif
		endif

		if iRevealType = REVEAL_SLANTED then
			if bInclinedWall then
				x11 = 0
				y11 = -WALL_THICKNESS + WIDO_SILL + offsetBoard / incH
				x12 = x11 + incH
				y12 = y11 - incV

				x21 = sideSign * distanceX
				y21 = 0
				x22 = x21 - sideSign * sin(revealAngle)
				y22 = y21 + cos(revealAngle)

				gosub 100		! Line - Line intersection
				px2 = cx
				py2 = cy

				if offsetSill > EPS & not(bDrawFrameContour) then
					x11 = 0
					y11 = WIDO_SILL - offsetSill
					x12 = x11 + 1
					y12 = y11

					gosub 100		! Line - Line intersection
					if cy < py3 then
						px3 = cx
						py3 = cy
					endif
				endif
			else
				px2 = sideSign * (distanceX + (WALL_THICKNESS - WIDO_SILL - offsetBoard) * tan(revealAngle))
				py2 = -WALL_THICKNESS + WIDO_SILL + distanceX * iInclDir * tan(WALL_INCL) + offsetBoard

				if offsetSill > EPS & not(bDrawFrameContour) then
					cx = sideSign * (distanceX + (-WIDO_SILL + offsetSill) * tan(revealAngle))
					cy = WIDO_SILL - offsetSill
					if cy < py3 then
						px3 = cx
						py3 = cy
					endif
				endif
			endif

			px5 = sideSign * (distanceX + WIDO_FRAME_THICKNESS * tan(revealAngle))
			py5 = -WIDO_FRAME_THICKNESS
		endif

		if bWindowSymbolAtMiddle then		! CHI Special
			dy = (WALL_THICKNESS - WIDO_FRAME_THICKNESS) / 2 - WIDO_SILL
			py3 = py3 - dy
		endif

		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
			px4 = px3 - sideSign * thkPlasterAtSill
			py4 = py3
		endif
		if iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_SLANTED then
			px4 = sideSign * (distanceX - revealWidth - thkPlasterAtSill)
			py4 = 0
		endif
		if iRevealType = REVEAL_NEGATIVE then
			px4 = sideSign * (distanceX + revealWidth)
			py4 = 0
		endif

		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE then
			px6 = px5 - sideSign * thkPlasterAtBoard
			py6 = py5
		endif
		if iRevealType = REVEAL_SLANTED then
			px6 = px5 - sideSign * thkPlasterAtBoard / cos(revealAngle)
			py6 = py5
		endif
	endif

	if bCompositeWall then
		idx = 1: gosub 10	! Get proper index
		penSkinContourIn	= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
		ltSkinContourIn		= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])

		idx = WALL_SKINS_NUMBER: gosub 10	! Get proper index
		penSkinContourOut	= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN])
		ltSkinContourOut	= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE])
	else
		penSkinContourIn	= WALL_SECT_PEN
		ltSkinContourIn		= WALL_LINETYPE

		penSkinContourOut	= WALL_SECT_PEN
		ltSkinContourOut	= WALL_LINETYPE
	endif

	if (wallIsLeft exor reorder) then
		penSkinContourSill	= penSkinContourIn
		ltSkinContourSill	= ltSkinContourIn

		penSkinContourBoard	= penSkinContourOut
		ltSkinContourBoard	= ltSkinContourOut
	else
		penSkinContourSill	= penSkinContourOut
		ltSkinContourSill	= ltSkinContourOut

		penSkinContourBoard	= penSkinContourIn
		ltSkinContourBoard	= ltSkinContourIn
	endif

	line_property LINE_PROPERTY_CONTOUR

	bEqualWallEndLineStyle = 1

	if bCompositeWall then
		penSkinContour	= round_int(WALL_SKINS_PARAMS[1][SKIN_END_FACE_PEN])
		ltSkinContour	= round_int(WALL_SKINS_PARAMS[1][SKIN_END_LINE_TYPE])

		for i = 2 to WALL_SKINS_NUMBER
			if abs(WALL_SKINS_PARAMS[i][SKIN_END_FACE_PEN] - penSkinContour) > EPS | \
			   abs(WALL_SKINS_PARAMS[i][SKIN_END_LINE_TYPE] - ltSkinContour) > EPS then

				bEqualWallEndLineStyle	= 0
				i = WALL_SKINS_NUMBER	! Force loop end
			endif
		next i
	endif

	if (iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO) & (not(bCompositeWall) | (bCompositeWall & bEqualWallEndLineStyle & bPlasterAtSill = 0 & bPlasterAtBoard = 0)) then
		if bCompositeWall then
			pen WALL_SKINS_PARAMS[1][SKIN_END_FACE_PEN]
			line_type WALL_SKINS_PARAMS[1][SKIN_END_LINE_TYPE]
		else
			pen WALL_SECT_PEN
			line_type WALL_LINETYPE
		endif

		wallline2 px1,py1, px2,py2
		if not(bSettingsDialog) & bDrawFrameContour then
				line2 px3,py3, px5,py5
		endif
	else
		if penSkinContourBoard > EPS then
			pen penSkinContourBoard
			line_type ltSkinContourBoard

			if bNeedContourAtBoard & py2 < py3 then
				wallline2 px2,py2, px3,py3
			endif

			if bCompositeWall & thkPlasterAtBoard > EPS then
				wallline2 px5,py5, px6,py6	! inner plaster - window frame contour
			endif

			if bDrawObjContourIn then
				wallline2 px2,py2, px3,py3	! full contour
			else
				if not(bNeedContourAtBoard) then
					wallline2 px3,py3, px5,py5	! only the frame's contour
				endif
			endif

			if not(bSettingsDialog) & bDrawFrameContour then
				if bCompositeWall & thkPlasterAtBoard > EPS then
					line2 px5,py5, px6,py6	! inner plaster - window frame contour
				endif
				line2 px3,py3, px5,py5	! only the frame's contour
			endif
		endif

		if penSkinContourSill > EPS then
			pen penSkinContourSill
			line_type ltSkinContourSill

			if bNeedContourAtSill & py1 > py4 then
				wallline2 px4,py4, px1,py1	! reveal contour
			endif

			if curvedWall & bWndCurved then	! reveal inner - window frame contour
				R = sqr(px3^2 + (py3 + WOD)^2)

				vx = px3
				vy = py3 + WOD
				gosub 103	! Direction Angle
				alpha = angle

				vx = px4
				vy = py4 + WOD
				gosub 103	! Direction Angle
				beta = angle

				if abs(alpha - beta) > EPS then
					wallarc2 0,-WOD, R, min(alpha,beta), max(alpha,beta)
					if not(bSettingsDialog) & bDrawFrameContour then
						arc2 0,-WOD, R, min(alpha,beta), max(alpha,beta)
					endif
				endif
			else
				if abs(px3 - px4) > EPS & offsetSill < WIDO_SILL then
					wallline2 px3,py3, px4,py4
					if not(bSettingsDialog) & bDrawFrameContour then
						if bDrawObjContourOut | iRevealType <> REVEAL_NEGATIVE then
							line2 px3,py3, px5,py5
						endif
					endif
				endif
			endif

			if bDrawObjContourOut & py1 > py4 then
				wallline2 px4,py4, px1,py1		! reveal contour
				if not(bSettingsDialog) & bDrawFrameContour then
					line2 px4,py4, px1,py1
				endif
			endif
		endif
	endif

return


! ==============================================================================
! Line - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12	line #1
!	x21,y21, x22,y22	line #2
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = valid intersection point
!	cx, cy:				intersection point
! ==============================================================================

100:
	lliDiv = (x11-x12) * (y21-y22) - (y11-y12) * (x21-x22)

	if abs(lliDiv) > EPS then
		! Intersection

		temp1 = x11 * y12 - y11 * x12
		temp2 = x21 * y22 - y21 * x22

		tempx = temp1 * (x21-x22) - (x11-x12) * temp2
		tempy = temp1 * (y21-y22) - (y11-y12) * temp2

		state = 1
		cx = (tempx / lliDiv)
		cy = (tempy / lliDiv)
	else
		! No Intersection
		state = 0
		cx = 0
		cy = 0
	endif
return


! ==============================================================================
! Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	xo,yo,ro:			circle
!	x1,y1, x2,y2		line
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = one intersection point (tangential line)
!						2 = two intersection points
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
! ==============================================================================

101:
	tempX1 = x1 - xo: tempY1 = y1 - yo
	tempX2 = x2 - xo: tempY2 = y2 - yo

	if abs(tempX2 - tempX1) < EPS then
		if abs(ro - abs(tempX1)) < EPS then
			state = 1
			xa = tempX1
			ya = 0
			xb = tempX1
			yb = 0
		else
			if abs(ro) - abs(tempX1) < 0 then
				state = 0: xa = 0: ya = 0: xb = 0: yb = 0
			else
				state = 2
				xa = tempX1
				ya = sqr(ro^2 - tempX1^2)
				xb = tempX1
				yb = -sqr(ro^2 - tempX1^2)
			endif
		endif
	else
		kf = (tempY2 - tempY1) / (tempX2 - tempX1)
		ad = 1 + kf^2
		bd = 2 * tempY1 * kf - 2 * tempX1 * kf^2
		cd = tempY1^2 - 2 * tempX1 * tempY1 * kf + tempX1^2 * kf^2 - ro^2

		if bd^2 - 4 * ad * cd < 0 then
			state = 0: xa = 0: ya = 0: xb = 0: yb = 0
		else
			xa = (-bd + sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			ya = tempY1 + (xa - tempX1) * kf
			xb = (-bd - sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			yb = tempY1 + (xb - tempX1) * kf

			if abs(xa - xb) < EPS then state = 1 else state = 2
		endif
	endif

	if state = 2 then
		da = sqr((tempX1 - xa)^2 + (tempY1 - ya)^2)
		db = sqr((tempX1 - xb)^2 + (tempY1 - yb)^2)

		if db < da then
			xxo = xa: yyo = ya
			xa = xb:  ya = yb
			xb = xxo: yb = yyo
		endif
	endif

	xa = xa + xo: ya = ya + yo
	xb = xb + xo: yb = yb + yo
return


! ==============================================================================
! Select good intersection point after Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	state:				intersection status
!	wallIsLeft:
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
!
! Returned variables:
!	cx, cy:				selected intersection point
! ==============================================================================

102:
	cx = 0
	cy = 0
	if state = 1 then
		cx = xa
		cy = ya
	endif
	if state = 2 then
		if wallIsLeft then
			if ya > yb then
				cx = xa
				cy = ya
			else
				cx = xb
				cy = yb
			endif
		else
			if ya < yb then
				cx = xa
				cy = ya
			else
				cx = xb
				cy = yb
			endif
		endif
	endif
return


! ==============================================================================
! Direction Angle
! ------------------------------------------------------------------------------
! Input variables:
!	vx, vy:				vector
!
! Returned variables:
!	alpha:				selected intersection point
! ==============================================================================

103:

if abs(vx) < EPS & abs(vy) < EPS then
	angle = 0
	return
endif

if abs(vx) < EPS then
	if vy > 0 then
		angle = 90
	else
		angle = 270
	endif
else
	angle = atn(vy / vx)
	if vx >= 0 then
		if angle < 0 then
			angle = angle + 360
		endif
	else
		angle = 180 + angle
	endif
endif

return


! ==============================================================================
! Draw wallblock with contour
! ------------------------------------------------------------------------------
! Input variables:
!	stack:				wallblock polygon
!	penFillFg			fill foreground pen (pen index)
!	penFillBg			fill background pen (pen index)
!	bLocalFill			fill orientation (0 / 1)
!	bDrawContour		draw contour lines
! ==============================================================================

200:
	if nsp >= 9 then
		wallblock2 nsp/3 + 1, 2 + 24 * bLocalFill + 32, penFillFg, penFillBg,
			0,0,0,
			0,-WOD,900,
			use(nsp)
	endif
	if nsp < 9 | not(bDrawContour) then
		for ii=1 to nsp
			n = get(1)
		next ii
		return
	endif

	numPoints = nsp/3
	for ii=1 to numPoints
		if ii = 1 then
			x1 = get(1)
			y1 = get(1)
			s1 = get(1)
			firstX = x1
			firstY = y1
			firstS = s1
		endif
		if ii = numPoints then
			x2 = firstX
			y2 = firstY
			s2 = firstS
		else
			x2 = get(1)
			y2 = get(1)
			s2 = get(1)
		endif

		if bittest(s2, 0) then
			if s2 >= 3000 then
				R = sqr(x2^2 + (y2 + WOD)^2)

				vx = x1
				vy = y1 + WOD
				gosub 103	! Direction Angle
				alpha = angle

				vx = x2
				vy = y2 + WOD
				gosub 103	! Direction Angle
				beta = angle

				if abs(alpha - beta) > EPS then
					wallarc2 0,-WOD, R, min(alpha,beta), max(alpha,beta)
				endif
			else
				wallline2 x1,y1, x2,y2
			endif
		endif

		x1 = x2
		y1 = y2
		s1 = s2
	next ii
return


5000:

	if bContour & gs_stack_left then
		put	boundMinX - 1,	trMulY * (-sillDepth) + trAddY,				0,
			boundMinX - 1,	trMulY * (WALL_THICKNESS - WIDO_SILL + 1),	0
	else
		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
			put	-leftW,	-trMulY * wallThkOppSide,	0,
				-leftW,	 trMulY * wallThkRefSide,	0
		endif
		if iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE | iRevealType = REVEAL_SLANTED then
			dxOLeft  = 0
			if iRevealType = REVEAL_SLANTED then
				dxOLeft		= (trAddY - wallThkOppSide) * tan(leftAngle)
			endif

			put	-leftW + dxOLeft,	-trMulY * wallThkOppSide,	0,
				-leftW,				 trMulY * byL + trAddY,		0,
				-leftW + leftJamb,	 trMulY * syL + trAddY,		0,
				-leftW + leftJamb,	 trMulY * wallThkRefSide,	0
		endif
	endif

	if bContour & gs_stack_right then
		put	boundMaxX + 1, 	trMulY * (WALL_THICKNESS - WIDO_SILL + 1),	0,
			boundMaxX + 1,	trMulY * (-sillDepth) + trAddY,				0
	else
		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
			put	rightW, trMulY * wallThkRefSide,	0,
				rightW,-trMulY * wallThkOppSide,	0
		endif
		if iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE | iRevealType = REVEAL_SLANTED then
			dxORight = 0
			if iRevealType = REVEAL_SLANTED then
				dxORight	= (trAddY - wallThkOppSide) * tan(rightAngle)
			endif

			put rightW - rightJamb,	 trMulY * wallThkRefSide,	0,
				rightW - rightJamb,	 trMulY * syR + trAddY,		0,
				rightW,				 trMulY * byR + trAddY,		0,
				rightW - dxORight,	-trMulY * wallThkOppSide,	0
		endif
	endif
return


