
! Contact person: <NJ>

! ==============================================================================
! This macro cuts the wallhole
! ------------------------------------------------------------------------------
! Input parameters:
! Geometry ---------------------------------------------------------------------
!	A:						Window nominal width (length)
!	B:						Window nominal height (length)
!	archHeight:				Height of the arc (length)
!	nArchResolution:		Arc resolution for arched windows (integer)
!								if nArchResolution < 3 then WALL_RESOL used instead
! Functions --------------------------------------------------------------------
!	iWindowShape:			Shape of the window (integer)
!								0 = rectangular (default)
!								1 = arched
!							Note: only the rectangular shape can be a Corner Window
!	AC_Hole_Hotspot_Control:
!	AC_HoleSideMaterial:
!	AC_HoleMaterialCurved:
! Reveal -----------------------------------------------------------------------
!	iRevealType:
!	gs_reveal_left_angle:
!	gs_reveal_right_angle:
!	gs_reveal_top_angle:
!	gs_reveal_bottom_angle:
! Corner Function --------------------------------------------------------------
!	bLeftCornerFunction:		Turn macro in Corner Window mode at the left side (0 / 1)
!	leftCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	leftConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
!	bRightCornerFunction:	Turn macro in Corner Window mode at the right side (0 / 1)
!	rightCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	rightConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
!	bCornerWindow:			Traditional Corner Window
! Oversize ---------------------------------------------------------------------
!	gs_left_oversize:		Left opening oversize (length)
!	gs_right_oversize:		Right opening oversize (length)
!	gs_upper_oversize:		Upper opening oversize (length)
!	gs_lower_oversize:		Lower opening oversize (length)
! Ganging ----------------------------------------------------------------------
!	gs_stack_left:			Align to door/window on left side (0 / 1)
!	gs_stack_right:			Align to door/window on right side (0 / 1)
!	gs_stack_top:			Align to door/window on upper side (0 / 1)
!	gs_stack_bottom:		Align to door/window on bottom side (0 / 1)
! Parapet ----------------------------------------------------------------------
!	gs_parapet_wall_inset:	Switch on / off the Wall Inset function. (0 / 1)
!	gs_parapet_inset_thk:	Depth of Wall Inset. (length)
!	gs_parapet_width:		Parapet width (length)
!	gs_parapet_height:		Parapet height (length)
!
! Related Global Variables:
!	WALL_THICKNESS
!	WALL_VIEW_PEN
!	WIDO_FRAME_THICKNESS
!	WIDO_SILL
!	WIDO_ORIG_DIST
!	WIDO_REVEAL_SIDE
!	SYMB_MIRRORED
!	SYMB_ROTANGLE
! ==============================================================================

_bCustomMatNicheTop		= 0

! === Turn Plaster in 3D ===[

thkPlasterAtSillLeft	= thkPlasterAtSillLeft		* gs_turn_plaster_show_3D
thkPlasterAtSillRight	= thkPlasterAtSillRight		* gs_turn_plaster_show_3D
thkPlasterAtSillTop		= thkPlasterAtSillTop		* gs_turn_plaster_show_3D
thkPlasterAtSillBottom	= thkPlasterAtSillBottom	* gs_turn_plaster_show_3D

thkPlasterAtSillSlLeft			= thkPlasterAtSillSlLeft		* gs_turn_plaster_show_3D
thkPlasterAtSillSlLeftBottom	= thkPlasterAtSillSlLeftBottom	* gs_turn_plaster_show_3D
thkPlasterAtSillSlRight			= thkPlasterAtSillSlRight		* gs_turn_plaster_show_3D
thkPlasterAtSillSlRightBottom	= thkPlasterAtSillSlRightBottom	* gs_turn_plaster_show_3D

thkPlasterAtBoardLeft	= thkPlasterAtBoardLeft		* gs_turn_plaster_show_3D
thkPlasterAtBoardRight	= thkPlasterAtBoardRight	* gs_turn_plaster_show_3D
thkPlasterAtBoardTop	= thkPlasterAtBoardTop		* gs_turn_plaster_show_3D
thkPlasterAtBoardBottom	= thkPlasterAtBoardBottom	* gs_turn_plaster_show_3D

thkPlasterAtBoardSlLeft			= thkPlasterAtBoardSlLeft		* gs_turn_plaster_show_3D
thkPlasterAtBoardSlLeftBottom	= thkPlasterAtBoardSlLeftBottom	* gs_turn_plaster_show_3D
thkPlasterAtBoardSlRight		= thkPlasterAtBoardSlRight		* gs_turn_plaster_show_3D
thkPlasterAtBoardSlRightBottom	= thkPlasterAtBoardSlRightBottom* gs_turn_plaster_show_3D

thkPlasterAtSill	= max(thkPlasterAtSillLeft, thkPlasterAtSillRight, thkPlasterAtSillTop, thkPlasterAtSillBottom)
thkPlasterAtBoard	= max(thkPlasterAtBoardLeft, thkPlasterAtBoardRight, thkPlasterAtBoardTop, thkPlasterAtBoardBottom)

SillPlasterAtFrame	= thkPlasterAtSill  * (iRevealType = REVEAL_NEGATIVE | (iRevealType = REVEAL_DOUBLE & iSillRevealType = REVEAL_NEGATIVE))
BoardPlasterAtFrame	= thkPlasterAtBoard * (iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | (iRevealType = REVEAL_DOUBLE & iBoardRevealType = REVEAL_NEGATIVE))

if not(bCut3DWallhole) then

	! void cut if no wallhole is needed
	addz -2 * WALL_THICKNESS - 1
	wallniche 4, 1, 2+16,
		0,0,1,	0.1,
		-0.1,	0,		31,
		-0.1,	0.1,	31,
		 0.1,	0.1,	31,
		 0.1,	0,		31
	del 1
	end
endif

!!! Chinese
signRevealSide = not(WIDO_REVEAL_SIDE) - WIDO_REVEAL_SIDE
SymbolMid_shiftDy = bDWSymbolAtMiddle * (WIDO_SILL - WALL_THICKNESS / 2 + WIDO_FRAME_THICKNESS / 2) * signRevealSide

addz -SymbolMid_shiftDy

! === Window Shape related definitions ===[

bNeedMiddleCut = 0

if iRevealType = REVEAL_DOUBLE then
	CustRevealOffsetDepth	= WIDO_FRAME_THICKNESS
	CustRevealLeftJamb		= revealInnerLeft
	CustRevealRightJamb		= revealInnerRight
	CustRevealTopJamb		= gs_reveal_double_innerTop
	CustRevealBottJamb		= gs_reveal_double_innerBottom
else
	CustRevealOffsetDepth	= 0
	CustRevealLeftJamb		= 0
	CustRevealRightJamb		= 0
	CustRevealTopJamb		= 0
	CustRevealBottJamb		= 0
endif

if thkPlasterAtBoardLeft > EPS | thkPlasterAtBoardRight > EPS | thkPlasterAtBoardTop > EPS | thkPlasterAtBoardBottom > EPS then
	bNeedMiddleCut = 1
	CustRevealOffsetDepth	= WIDO_FRAME_THICKNESS
endif
if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE | iRevealType = REVEAL_DOUBLE_SPLAYED then
	bNeedMiddleCut = 1
endif


if iWindowShape <> SHAPE_MULTISIDE then
	if nArchResolution < 3 then nArchResolution = WALL_RESOL
endif

if iWindowShape = SHAPE_ARCHED then
	if archHeight < EPS then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		if archHeight > (openingWidth / 2 - EPS) then
			archHeight = openingWidth / 2
			arcR = archHeight
			bHalfCircle = 1
		else
			arcR = (openingWidth / 2) / sin(2 * atn(archHeight / (openingWidth / 2)))
			bHalfCircle = 0
		endif
	endif
endif

if iWindowShape = SHAPE_HALFARCH then
	if archHeight < EPS then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		arcR = (openingWidth * openingWidth + archHeight * archHeight) / (2 * archHeight)
		shoulder_angle	= ACS(openingWidth / arcR)

		!Sill
		if curvedWall & not(bParalellInCurvedWalls) then
			thkPlasterAtSillLeft_distx	= thkPlasterAtSillLeft  / cos(alfaLeftOs  - alfaLeftJamb)
			thkPlasterAtSillRight_distx	= thkPlasterAtSillRight / cos(alfaRightOs - alfaRightJamb)
			offLeft		= leftWidth  - abs(WOD) * tan(alfaLeftOs  - alfaLeftJamb)  + gs_left_oversize  + thkPlasterAtSillLeft_distx  + SillPlasterAtFrame * tan(alfaLeftOs  - alfaLeftJamb)
			offRight	= rightWidth - abs(WOD) * tan(alfaRightOs - alfaRightJamb) + gs_right_oversize + thkPlasterAtSillRight_distx + SillPlasterAtFrame * tan(alfaRightOs - alfaRightJamb)
		else
			offLeft	 = leftJamb  + thkPlasterAtSillLeft
			offRight = rightJamb + thkPlasterAtSillRight
		endif
		offTop = upperJamb + thkPlasterAtSillTop
		x1 = rightWidth + overSizeRight * not(bRightCornerFunction) - offRight
		y1 = 0
		x2 = x1
		y2 = openingHeight+1
		xo = rightWidth + overSizeRight * not(bRightCornerFunction)
		yo = B + overSizeUpper - arcR
		ro = arcR - offTop

		GOSUB 101	! Circle - Line intersection
		if ya > yb then
			SillTopy	= ya
		else
			SillTopy	= yb
		endif
		SillTopx	= x1

		x1 = -leftWidth - overSizeLeft + offLeft
		x2 = x1
		GOSUB 101	! Circle - Line intersection
		if ya > yb then
			SillShouldy	= ya
		else
			SillShouldy	= yb
		endif
		SillShouldx	= x1

		!Board
		if curvedWall & not(bParalellInCurvedWalls) then
			thkPlasterAtBoardLeft_distx	 = thkPlasterAtBoardLeft  / cos(alfaLeftInnJamb)
			thkPlasterAtBoardRight_distx = thkPlasterAtBoardRight / cos(alfaRightInnJamb)
			if iRevealType = REVEAL_DOUBLE exor wallIsLeft then
				dxL = WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
				dxR = WIDO_FRAME_THICKNESS * tan(alfaRightOs)
			else
				dxL = 0
				dxR = 0
			endif

			offLeft		= CustRevealLeftJamb  + thkPlasterAtBoardLeft_distx  + BoardPlasterAtFrame * tan(alfaLeftInnJamb)  - dxL
			offRight	= CustRevealRightJamb + thkPlasterAtBoardRight_distx + BoardPlasterAtFrame * tan(alfaRightInnJamb) - dxR
		else
			offLeft		= CustRevealLeftJamb   + thkPlasterAtBoardLeft
			offRight	= CustRevealRightJamb  + thkPlasterAtBoardRight
		endif
		offTop = CustRevealTopJamb + thkPlasterAtBoardTop
		x1 = rightWidth + overSizeRight * not(bRightCornerFunction) - offRight
		y1 = 0
		x2 = x1
		y2 = openingHeight+1
		ro = arcR - offTop

		GOSUB 101	! Circle - Line intersection
		if ya > yb then
			BoardTopy	= ya
		else
			BoardTopy	= yb
		endif
		BoardTopx	= x1

		x1 = -leftWidth - overSizeLeft + offLeft
		x2 = x1
		GOSUB 101	! Circle - Line intersection
		if ya > yb then
			BoardShouldy	= ya
		else
			BoardShouldy	= yb
		endif
		BoardShouldx	= x1

		!Frame
		if curvedWall & not(bParalellInCurvedWalls) & wallIsLeft then
			offLeft		= -WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
			offRight	= -WIDO_FRAME_THICKNESS * tan(alfaRightOs)
		else
			offLeft		= 0
			offRight	= 0
		endif
		offTop = 0

		x1 = rightWidth + overSizeRight * not(bRightCornerFunction) - offRight
		y1 = 0
		x2 = x1
		y2 = openingHeight+1
		ro = arcR - offTop

		GOSUB 101	! Circle - Line intersection
		if ya > yb then
			FrameTopy	= ya
		else
			FrameTopy	= yb
		endif
		FrameTopx	= x1

		x1 = -leftWidth - overSizeLeft + offLeft
		x2 = x1
		GOSUB 101	! Circle - Line intersection
		if ya > yb then
			FrameShouldy	= ya
		else
			FrameShouldy	= yb
		endif
		FrameShouldx	= x1

		opWidth = openingWidth - leftJamb - rightJamb
		arcR_revealSide = (opWidth * opWidth + archHeight * archHeight) / (2 * archHeight)
		bFullArc = (abs(openingWidth - archHeight) < EPS)
	endif
endif

if iWindowShape = SHAPE_HALFROUND then

	ang_segm = 360 / nArchResolution

	offSillRight = rightJamb + thkPlasterAtSillRight

	xa = openingWidth * cos(-90)
	ya = openingHeight / 2 * sin(-90)
	if ABS(ya) < EPS then
		ang_cent = -90
	else
		ang_cent = ATN(xa/ya)
	endif

	xa_el = openingWidth * cos(-90 - ang_segm)
	ya_el = openingHeight / 2 * sin(-90 - ang_segm)
	if ABS(ya_el) < EPS then
		ang_cent_el = -90
	else
		ang_cent_el = ATN(xa_el/ya_el)
	endif

	xa_ut = openingWidth * cos(-90 + ang_segm)
	ya_ut = openingHeight / 2 * sin(-90 + ang_segm)
	if ABS(ya_ut) < EPS then
		ang_cent_ut = -90
	else
		ang_cent_ut = ATN(xa_ut/ya_ut)
	endif

	if xa_ut - ABS( offSillRight * sin(ang_cent_ut)) > offSillRight then
		x11 = offSillRight
		y11 = -openingHeight
		x12 = offSillRight
		y12 = openingHeight
		x21 = xa 	- ABS( offSillRight * sin(ang_cent))
		y21 = ya 	+ ( offSillRight * cos(ang_cent))
		x22 = xa_ut - ABS( offSillRight * sin(ang_cent_ut))
		y22 = ya_ut + ( offSillRight * cos(ang_cent_ut))
		GOSUB 100

		sillArcoffs = openingHeight/2 - ABS(cy)
	else
		sillArcoffs = 0
	endif


	offBoardRight = CustRevealRightJamb + thkPlasterAtBoardRight

	xa = openingWidth * cos(-90)
	ya = openingHeight / 2 * sin(-90)
	if ABS(ya) < EPS then
		ang_cent = -90
	else
		ang_cent = ATN(xa/ya)
	endif

	xa_el = openingWidth * cos(-90 - ang_segm)
	ya_el = openingHeight / 2 * sin(-90 - ang_segm)
	if ABS(ya_el) < EPS then
		ang_cent_el = -90
	else
		ang_cent_el = ATN(xa_el/ya_el)
	endif

	xa_ut = openingWidth * cos(-90 + ang_segm)
	ya_ut = openingHeight / 2 * sin(-90 + ang_segm)
	if ABS(ya_ut) < EPS then
		ang_cent_ut = -90
	else
		ang_cent_ut = ATN(xa_ut/ya_ut)
	endif

	if xa_ut - ABS( offBoardRight * sin(ang_cent_ut)) > offBoardRight then
		x11 = offBoardRight
		y11 = -openingHeight
		x12 = offBoardRight
		y12 = openingHeight
		x21 = xa 	- ABS( offBoardRight * sin(ang_cent))
		y21 = ya 	+ ( offBoardRight * cos(ang_cent))
		x22 = xa_ut - ABS( offBoardRight * sin(ang_cent_ut))
		y22 = ya_ut + ( offBoardRight * cos(ang_cent_ut))
		GOSUB 100

		boardArcoffs = openingHeight/2 - ABS(cy)
	else
		boardArcoffs = 0
	endif
endif

if iWindowShape = SHAPE_GOTHICARCH then
	if archHeight < EPS then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		arcR = (openingWidth / 4) + (archHeight * archHeight / openingWidth)
		centSillArcoffs		= archHeight - SQR((arcR - rightJamb - thkPlasterAtSillRight)^2 - (arcR - openingWidth/2)^2)
		centBoardArcoffs	= archHeight - SQR((arcR - CustRevealRightJamb - thkPlasterAtBoardRight)^2 - (arcR - openingWidth/2)^2)
	endif
endif

if iWindowShape = SHAPE_PENTAGON then
	if archHeight < EPS then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		tan_topAngle = archHeight / (openingWidth / 2)
	endif
endif

if iWindowShape = SHAPE_ELLIPSEARCH then
	if archHeight < EPS then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		middleRadiusEllips = (openingWidth * openingWidth / 4 - openingWidth * smallRadiusEllips + archHeight * archHeight) / (2 * archHeight - 2 * smallRadiusEllips)
		smallRadiusEllips_reveal = smallRadiusEllips - rightJamb - thkPlasterAtSillRight
		middleRadiusEllips_reveal = middleRadiusEllips - rightJamb - thkPlasterAtSillRight

		smallRadiusEllips_Innreveal = smallRadiusEllips - CustRevealRightJamb - thkPlasterAtBoardRight
		middleRadiusEllips_Innreveal = middleRadiusEllips - CustRevealRightJamb - thkPlasterAtBoardRight

		if abs(openingWidth / 2 - smallRadiusEllips) > EPS then
			alphaSide = atn ((middleRadiusEllips - archHeight) / (openingWidth / 2 - smallRadiusEllips))
		else
			alphaSide = 0
		endif
		alphaMiddle = (90 - alphaSide) * 2

		if abs((openingWidth - 2 * rightJamb) / 2 - smallRadiusEllips_reveal) > EPS then
			alphaSide_reveal = atn((middleRadiusEllips_reveal - (archHeight - rightJamb)) / ((openingWidth - 2 * rightJamb) / 2 - smallRadiusEllips_reveal))
		else
			alphaSide_reveal = 0
		endif
		alphaMiddle_reveal = 90 - alphaSide_reveal

		if abs((openingWidth - 2 * CustRevealRightJamb) / 2 - smallRadiusEllips_Innreveal) > EPS then
			alphaSide_Innreveal = atn((middleRadiusEllips_Innreveal - (archHeight - CustRevealRightJamb)) / ((openingWidth - 2 * CustRevealRightJamb) / 2 - smallRadiusEllips_Innreveal))
		else
			alphaSide_Innreveal = 0
		endif
		alphaMiddle_Innreveal = 90 - alphaSide_Innreveal
	endif
endif

if iWindowShape = SHAPE_TRAPEZOID then
	if archHeight < EPS then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		tan_topAngle = archHeight / ac_wallhole_width
		archHeight_reveal =  ((openingWidth + oversizeRight - leftJamb - rightJamb) * archHeight)  / (openingWidth + oversizeRight)
		archHeight_Innreveal =  ((openingWidth + oversizeRight - CustRevealLeftJamb - CustRevealRightJamb) * archHeight)  / (openingWidth + oversizeRight)

	endif
endif

if iWindowShape = SHAPE_TRIANGLE then
	tan_LeftSide = ac_wallhole_height / (ac_wallhole_width / 2 + gs_posTopEdge_triangle)
	tan_RightSide = ac_wallhole_height / (ac_wallhole_width / 2 - gs_posTopEdge_triangle)
endif

if iWindowShape = SHAPE_PARALLELOGRAM then
	if archHeight < EPS then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		tan_topAngle = archHeight / openingWidth
		upperJambModify =  (1 / cos(atn(archHeight / (openingWidth + oversizeRight))))
		archHeight_reveal =  ((openingWidth + oversizeRight - leftJamb - rightJamb) * archHeight)  / (openingWidth + oversizeRight)
		archHeight_Innreveal =  ((openingWidth + oversizeRight - CustRevealLeftJamb - CustRevealRightJamb) * archHeight)  / (openingWidth + oversizeRight)
	endif
endif

if iWindowShape = SHAPE_ROMBUS then
	upperJambModify	= (1 / cos(atn(openingHeight / openingWidth)))
	sideJambModify	= (1 / cos(atn(openingWidth / openingHeight)))
endif

if iWindowShape = SHAPE_MULTISIDE then
	if gs_numOfSides = 4 then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		if (gs_numOfSides MOD 2) = 0 then
			if (gs_numOfSides MOD 4) = 0 then
				normalRadius = (openingWidth / 2) / (cos (180 / gs_numOfSides))
			else
				normalRadius = openingWidth / 2
			endif
		else
			if gs_numOfSides = 3 then
				normalRadius = (openingWidth / 2) / (cos (30))
			else
				normalRadius = (openingWidth / 2) / (sin (((gs_numOfSides - 1) * 90) / gs_numOfSides))
			endif
		endif
		revealRadius	= normalRadius - rightJamb / cos (180 / gs_numOfSides)
		innrevealRadius	= normalRadius - CustRevealRightJamb / cos (180 / gs_numOfSides)
		plasterOffs		= thkPlasterAtSillRight		/ cos (180 / gs_numOfSides)
		innplasterOffs	= thkPlasterAtBoardRight	/ cos (180 / gs_numOfSides)
	endif
endif

if iWindowShape = SHAPE_OCTAGONAL then
	normalRadius	= openingHeight / (2 * cos (22.5))
	revealRadius	= (openingHeight - 2 * rightJamb) / (2 * cos (22.5))
	innrevealRadius	= (openingHeight - 2 * CustRevealRightJamb) / (2 * cos (22.5))
	plasterOffs		= (2 * thkPlasterAtSillRight) / (2 * cos (22.5))
	innplasterOffs	= (2 * thkPlasterAtBoardRight) / (2 * cos (22.5))
endif

if iWindowShape = SHAPE_HALFCIRCLE then
	archHeight = openingWidth / 2
	arcR = archHeight
endif

if iWindowShape = SHAPE_ARCHED_T then
	if archHeight < EPS then
		iWindowShape = SHAPE_T		! Switch back to rectangular T shape
	else
		if archHeight > (openingWidth / 2 - EPS) then
			archHeight = openingWidth / 2
			arcR = archHeight
			bHalfCircle = 1
		else
			arcR = (openingWidth / 2) / sin(2 * atn(archHeight / (openingWidth / 2)))
			bHalfCircle = 0
		endif
	endif
endif

if iWindowShape = SHAPE_T then
	if gs_sidelight_parapet_hgt_left < EPS & gs_sidelight_parapet_hgt_right < EPS then iWindowShape = SHAPE_RECTANGULAR
	if gs_sidelight_parapet_hgt_left < EPS & gs_sidelight_parapet_hgt_right > EPS then iWindowShape = SHAPE_HALF_T_RIGHT
	if gs_sidelight_parapet_hgt_left > EPS & gs_sidelight_parapet_hgt_right < EPS then iWindowShape = SHAPE_HALF_T_LEFT
endif

if iWindowShape = SHAPE_ARCHED_T then
	if gs_sidelight_parapet_hgt_left < EPS & gs_sidelight_parapet_hgt_right < EPS then iWindowShape = SHAPE_ARCHED
	if gs_sidelight_parapet_hgt_left < EPS & gs_sidelight_parapet_hgt_right > EPS then iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT
	if gs_sidelight_parapet_hgt_left > EPS & gs_sidelight_parapet_hgt_right < EPS then iWindowShape = SHAPE_ARCHED_HALF_T_LEFT
endif

if iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then
	if archHeight < EPS then
		if iWindowShape = SHAPE_ARCHED_HALF_T_LEFT then
			iWindowShape = SHAPE_HALF_T_LEFT	! Switch back to rectangular half - T shape
		else
			iWindowShape = SHAPE_HALF_T_RIGHT	! Switch back to rectangular half - T shape
		endif
	else
		if archHeight > (openingWidth / 2 - EPS) then
			archHeight = openingWidth / 2
			arcR = archHeight
			bHalfCircle = 1
		else
			arcR = (openingWidth / 2) / sin(2 * atn(archHeight / (openingWidth / 2)))
			bHalfCircle = 0
		endif
	endif
endif

if iWindowShape = SHAPE_HORSESHOE then
	RadArch = ((ArchHeight - gs_lowerArchHeight)^2 +(openingWidth/2)^2) / openingWidth

	x1 = 0
	y1 = 0
	x2 = 0
	y2 = openingHeight + 1
	xo = openingWidth / 2 - RadArch
	yo = openingHeight - (ArchHeight - gs_lowerArchHeight)
	ro = RadArch - rightJamb - thkPlasterAtSillRight

	gosub 101	! Circle - Line intersection

	if ya > yb then
		SillHighArcoffs = ya
	else
		SillHighArcoffs = yb
	endif

	ro = RadArch
	gosub 101	! Circle - Line intersection

	if ya > yb then
		FrameHighArcoffs = ya
	else
		FrameHighArcoffs = yb
	endif

	ro = RadArch - CustRevealRightJamb - thkPlasterAtBoardRight
	gosub 101	! Circle - Line intersection

	if ya > yb then
		BoardHighArcoffs = ya
	else
		BoardHighArcoffs = yb
	endif


	x1 = -openingWidth / 2
	y1 = openingHeight - ArchHeight - rightJamb - thkPlasterAtSillRight
	x2 = openingWidth / 2
	y2 = openingHeight - ArchHeight - rightJamb - thkPlasterAtSillRight
	xo = openingWidth / 2 - RadArch
	yo = openingHeight - (ArchHeight - gs_lowerArchHeight)
	ro = RadArch - rightJamb - thkPlasterAtSillRight

	gosub 101	! Circle - Line intersection

	if state then
		SillLowArcoffsy = ya

		if xa < xb then
			SillLowArcoffsx = xb
		else
			SillLowArcoffsx = xa
		endif
	else
		SillLowArcoffsx = openingWidth / 2 - RadArch
		SillLowArcoffsy = openingHeight - ArchHeight - rightJamb - thkPlasterAtSillRight
	endif

	y1 = openingHeight - ArchHeight
	y2 = openingHeight - ArchHeight
	ro = RadArch

	gosub 101	! Circle - Line intersection

	FrameLowArcoffsy = ya

	if xa < xb then
		FrameLowArcoffsx = xb
	else
		FrameLowArcoffsx = xa
	endif


	y1 = openingHeight - ArchHeight - CustRevealRightJamb - thkPlasterAtBoardRight
	y2 = openingHeight - ArchHeight - CustRevealRightJamb - thkPlasterAtBoardRight
	ro = RadArch - CustRevealRightJamb - thkPlasterAtBoardRight

	gosub 101	! Circle - Line intersection

	if state then
		BoardLowArcoffsy = ya

		if xa < xb then
			BoardLowArcoffsx = xb
		else
			BoardLowArcoffsx = xa
		endif
	else
		BoardLowArcoffsx = openingWidth / 2 - RadArch
		BoardLowArcoffsy = openingHeight - ArchHeight - CustRevealRightJamb - thkPlasterAtBoardRight
	endif
endif

if iWindowShape = SHAPE_OGEECENTERED then
	gs_shoulder_height	= openingHeight - ArchHeight

	RadArc = ((ArchHeight / 2)^2 + (openingWidth / 4)^2) / (openingWidth / 2)

	x1 = 0
	y1 = 0
	x2 = 0
	y2 = openingHeight
	xo = RadArc
	yo = openingHeight
	ro = RadArc + rightJamb + thkPlasterAtSillRight

	if thkPlasterAtSillRight | rightJamb then

		gosub 101	! Circle - Line intersection

		if ya < yb then
			centSillArcoffs = ya
		else
			centSillArcoffs = yb
		endif
	else
		centSillArcoffs = openingHeight
	endif


	ro = RadArc + CustRevealRightJamb + thkPlasterAtBoardRight

	if thkPlasterAtBoardRight | CustRevealRightJamb then

		gosub 101	! Circle - Line intersection

		if ya < yb then
			centBoardArcoffs = ya
		else
			centBoardArcoffs = yb
		endif
	else
		centBoardArcoffs = openingHeight
	endif
endif

if iWindowShape = SHAPE_SARACENIC then
	gs_shoulder_height	= openingHeight - ArchHeight
	rOrigArc = (ArchHeight)*COS(30)

	radArch = (openingWidth / 2 * tan(30) - ArchHeight) / (tan(30) - cos(60) * tan(30) - sin(60))

	FrametangArcx 	= openingWidth / 2 - radArch + (radArch) * cos(60)
	FrametangArcy 	= openingHeight - ArchHeight + (radArch) * sin(60)

	SilltangArcx = openingWidth / 2 - radArch + (radArch - rightJamb - thkPlasterAtSillRight) * cos(60)
	SilltangArcy = openingHeight - ArchHeight + (radArch - rightJamb - thkPlasterAtSillRight) * sin(60)
	centSillArcoffs = openingHeight - (rightJamb + thkPlasterAtSillRight) / cos(30)

	BoardtangArcx = openingWidth / 2 - radArch + (radArch - CustRevealRightJamb - thkPlasterAtBoardRight) * cos(60)
	BoardtangArcy = openingHeight - ArchHeight + (radArch - CustRevealRightJamb - thkPlasterAtBoardRight) * sin(60)
	centBoardArcoffs = openingHeight - (CustRevealRightJamb + thkPlasterAtBoardRight) / cos(30)

endif


! ]=== Window Shape related definitions ===

pen WALL_VIEW_PEN
if nArchResolution > 3 then resol nArchResolution

if AC_HoleSideMaterial then
	if WIDO_REVEAL_SIDE then
		matRevealSide	= WALL_MAT_A
		matOppositeSide = WALL_MAT_B
	else
		matRevealSide	= WALL_MAT_B
		matOppositeSide = WALL_MAT_A
	endif
else
	matRevealSide	= WALL_MAT_EDGE
	matOppositeSide = WALL_MAT_EDGE
endif


leftDx	= 0
rightDx	= 0
if bSlantedInnerSide then
	if curvedWall then

			if gs_stack_left  then
			gs_reveal_left_angle  = alfaLeftOs
!			rightDx = WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
			endif
			if gs_stack_right then
			gs_reveal_right_angle  = alfaRightOs
!			leftDx = WIDO_FRAME_THICKNESS * tan(alfaRightOs)
		endif

		if not(wallIsLeft) then
			leftDx	= 0
			rightDx	= 0
		endif
	endif
endif


if iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC then
	offsetInsideDepth	= WIDO_FRAME_THICKNESS
	offsetInsideLeft	= revealInnerLeft
	offsetInsideRight	= revealInnerRight
	offsetInsideTop		= gs_reveal_splayed_innerTop
	offsetInsideBott	= gs_reveal_splayed_innerBottom
else
	offsetInsideDepth	= 0
	offsetInsideRight	= 0
	offsetInsideLeft	= 0
	offsetInsideTop		= 0
	offsetInsideBott	= 0
endif
if iRevealType = REVEAL_DOUBLE_SPLAYED then
	offsetInsideDepth	= WIDO_FRAME_THICKNESS
	offsetOutsideDepth	= 0
endif

bSillIsHorizontal	= ( iWindowShape = SHAPE_RECTANGULAR			| \
						iWindowShape = SHAPE_ARCHED					| \
						iWindowShape = SHAPE_HALFARCH				| \
						iWindowShape = SHAPE_ELLIPSEARCH			| \
						iWindowShape = SHAPE_EYEBROWS				| \
						iWindowShape = SHAPE_PENTAGON				| \
						iWindowShape = SHAPE_TRAPEZOID				| \
						iWindowShape = SHAPE_TRIANGLE				| \
						iWindowShape = SHAPE_CORNER_TRIANGLE		| \
						iWindowShape = SHAPE_PARALLELOGRAM			| \
						iWindowShape = SHAPE_GOTHICARCH				| \
						iWindowShape = SHAPE_HALFCIRCLE				| \
						iWindowShape = SHAPE_QUARTERROUND			| \
						iWindowShape = SHAPE_QUARTERROUND_NOFRAME )


! ==============================================================================
! Wallhole Hotspots
! ==============================================================================

gs_wallhole_width_half = 0
gs_reveal_width_half = 0

if WIDO_REVEAL_SIDE then
	addz WIDO_FRAME_THICKNESS
	mulz -1
endif

unID = 11100

! Board side offsets
dxBL = leftRevealPnts[idxBoardEndRevealLeft][1]
dxBR = rightRevealPnts[idxBoardEndRevealRight][1]

! Reveal side offsets
dxSL = leftRevealPnts[idxSillStartRevealLeft][1]
dxSR = rightRevealPnts[idxSillStartRevealRight][1]

! Slanted and Splayed reveal offsets - at the Top
if bSlantedInnerSide & not(gs_stack_top) then
	dyBLT =  ((leftRevealPnts[idxBoardEndRevealLeft][2]  - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_top_angle) - (iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_SPLAYED) * gs_reveal_splayed_InnerTop)	! Top Left
	dyBRT = ((rightRevealPnts[idxBoardEndRevealRight][2] - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_top_angle) - (iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_SPLAYED) * gs_reveal_splayed_InnerTop)	! Top Right
else
	dyBLT = 0
	dyBRT = 0
endif

! Slanted and Splayed reveal offsets - at the Bottom
if bSlantedInnerSide & not(gs_stack_bottom) & isWindow then
	dyBLB =  ((leftRevealPnts[idxBoardEndRevealLeft][2]  - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_bottom_angle) - (iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_SPLAYED) * gs_reveal_splayed_InnerBottom)	! Bottom Left
	dyBRB = ((rightRevealPnts[idxBoardEndRevealRight][2] - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_bottom_angle) - (iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_SPLAYED) * gs_reveal_splayed_InnerBottom)	! Bottom Right
else
	dyBLB = 0
	dyBRB = 0
endif

if	iWindowShape = SHAPE_RECTANGULAR			| \
	iWindowShape = SHAPE_ARCHED					| \
	iWindowShape = SHAPE_ELLIPSEARCH			| \
	iWindowShape = SHAPE_EYEBROWS				| \
	iWindowShape = SHAPE_HALFCIRCLE				| \
	iWindowShape = SHAPE_HALFARCH				| \
	iWindowShape = SHAPE_PENTAGON				| \
	iWindowShape = SHAPE_QUARTERROUND			| \
	iWindowShape = SHAPE_QUARTERROUND_NOFRAME	| \
	iWindowShape = SHAPE_TRIANGLE				| \
	iWindowShape = SHAPE_GOTHICARCH				| \
	iWindowShape = SHAPE_CORNER_TRIANGLE		| \
	iWindowShape = SHAPE_TRAPEZOID then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0,-dyBLB,						0, unID
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0,-dyBRB,						0, unID
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | ((iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) & gs_mountingFrame) then
		if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
			hptsYL = -elevationOffset - (bSlantedOuterSide & not(gs_stack_bottom)) * ( -leftRevealPnts[idxSillStartRevealLeft][2]  - gs_mountingFrame_depth) * tan(gs_reveal_outerBottom_angle)
			hptsYR = -elevationOffset - (bSlantedOuterSide & not(gs_stack_bottom)) * (-rightRevealPnts[idxSillStartRevealRight][2] - gs_mountingFrame_depth) * tan(gs_reveal_outerBottom_angle)
		else
			hptsYL = -elevationOffset + gs_reveal_bottom + original_gs_reveal_bottom * not(bShowRevealSE)
			hptsYR = hptsYL
		endif

		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,hptsYL,	0, unID
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0,hptsYR,	0, unID
		del 1
		unID = unID + 2
	else
		if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
			hptsYL = -(bSlantedOuterSide & not(gs_stack_bottom)) * ( -leftRevealPnts[idxSillStartRevealLeft][2]  - gs_mountingFrame * gs_mountingFrame_depth) * tan(gs_reveal_outerBottom_angle) + gs_reveal_bottom * not(gs_stack_bottom)
			hptsYR = -(bSlantedOuterSide & not(gs_stack_bottom)) * (-rightRevealPnts[idxSillStartRevealRight][2] - gs_mountingFrame * gs_mountingFrame_depth) * tan(gs_reveal_outerBottom_angle) + gs_reveal_bottom * not(gs_stack_bottom)
		else
			hptsYL = -elevationOffset + gs_reveal_bottom * not(gs_stack_bottom)
			hptsYR = -elevationOffset + gs_reveal_bottom * not(gs_stack_bottom)
		endif

		if iWindowShape = SHAPE_TRIANGLE then
			_oleft = -(leftJamb + thkPlasterAtSillLeft) / sin(atn(tan_LeftSide))
			add -ac_wallhole_width / 2 - _oleft,			 0, leftRevealPnts[idxSillStartRevealLeft][2]
		else
			add leftRevealPnts[idxSillStartRevealLeft][1],	 0, leftRevealPnts[idxSillStartRevealLeft][2]
		endif
		hotspot 0,hptsYL,	0, unID
		del 1
		unID = unID + 2

		if iWindowShape = SHAPE_TRIANGLE then
			_oright = -(rightJamb + thkPlasterAtSillRight) / sin(atn(tan_RightSide))
			add ac_wallhole_width / 2 + _oright,			 0, rightRevealPnts[idxSillStartRevealRight][2]
		else
			add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		endif
		hotspot 0,hptsYR,	0, unID
		del 1
		unID = unID + 2

		if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
			hptsYL = gs_reveal_bottom * not(gs_stack_bottom)
			hptsYR = gs_reveal_bottom * not(gs_stack_bottom)
		else
			hptsYL = -elevationOffset + gs_reveal_bottom * not(gs_stack_bottom)
			hptsYR = -elevationOffset + gs_reveal_bottom * not(gs_stack_bottom)
		endif

		add leftRevealPnts[idxSillEndRevealLeft][1], 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,hptsYL,	0, unID
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0,hptsYR,	0, unID
		del 1
		unID = unID + 2

		if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
			hptsYL = 0
			hptsYR = 0
		else
			hptsYL = -elevationOffset
			hptsYR = -elevationOffset
		endif

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0,hptsYL,	0, unID
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0,hptsYR,	0, unID
		del 1
		unID = unID + 2
	endif
endif

if	iWindowShape = SHAPE_ARCHED_T				| \
	iWindowShape = SHAPE_T						| \
	iWindowShape = SHAPE_ARCHED_HALF_T_LEFT		| \
	iWindowShape = SHAPE_HALF_T_LEFT			| \
	iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT	| \
	iWindowShape = SHAPE_HALF_T_RIGHT then

	gs_sidelight_WHole_width_left 	= gs_sidelight_WHole_width_left * (iWindowShape = SHAPE_ARCHED_T | iWindowShape = SHAPE_T | iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | iWindowShape = SHAPE_HALF_T_LEFT)
	gs_sidelight_parapet_hgt_left 	= gs_sidelight_parapet_hgt_left * (iWindowShape = SHAPE_ARCHED_T | iWindowShape = SHAPE_T | iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | iWindowShape = SHAPE_HALF_T_LEFT)
	gs_sidelight_WHole_width_right 	= gs_sidelight_WHole_width_right * (iWindowShape = SHAPE_ARCHED_T | iWindowShape = SHAPE_T | iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT | iWindowShape = SHAPE_HALF_T_RIGHT)
	gs_sidelight_parapet_hgt_right 	= gs_sidelight_parapet_hgt_right * (iWindowShape = SHAPE_ARCHED_T | iWindowShape = SHAPE_T | iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT | iWindowShape = SHAPE_HALF_T_RIGHT)

	revealDiffLeft	= (gs_reveal_double_innerLeft_sL  - gs_reveal_double_innerLeft)
	revealDiffRight	= (gs_reveal_double_innerRight_sR - gs_reveal_double_innerRight)

! Board Side Hotspots ----------------------------------------------------------

	if	iWindowShape = SHAPE_ARCHED_T				| \
		iWindowShape = SHAPE_T						| \
		iWindowShape = SHAPE_ARCHED_HALF_T_LEFT		| \
		iWindowShape = SHAPE_HALF_T_LEFT then

		hptsYM = -dyBLB + (isWindow | gs_reveal_double_innerBottom > EPS) * gs_reveal_double_innerBottom
		hptsYL = -dyBLB + gs_sidelight_parapet_hgt_left  + gs_reveal_double_innerBottom_sL

		px = -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_double_innerLeft_sL
		if curvedWall then
			pz = WOD - signWallIsLeft * sqr(radBoard^2 - px^2)
		else
			pz = leftRevealPnts[idxBoardEndRevealLeft][2] + incX * px
		endif
		hotspot px, hptsYM, pz, unID
		unID = unID + 2
		if gs_sidelight_WHole_width_left > EPS & gs_sidelight_parapet_hgt_left > EPS then
			hotspot px, hptsYL, pz, unID
			unID = unID + 2
			hotspot leftRevealPnts[idxBoardEndRevealLeft][1], hptsYL, leftRevealPnts[idxBoardEndRevealLeft][2], unID
			unID = unID + 2
		else
			unID = unID + 4
		endif
	else
		unID = unID + 6
	endif

	if	iWindowShape = SHAPE_ARCHED_T				| \
		iWindowShape = SHAPE_T						| \
		iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT	| \
		iWindowShape = SHAPE_HALF_T_RIGHT then

		hptsYM = -dyBRB + (isWindow | gs_reveal_double_innerBottom > EPS) * gs_reveal_double_innerBottom
		hptsYR = -dyBRB + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR

		px = rightWidth - gs_sidelight_WHole_width_right - gs_reveal_double_innerRight_sR
		if curvedWall then
			pz = WOD - signWallIsLeft * sqr(radBoard^2 - px^2)
		else
			pz = leftRevealPnts[idxBoardEndRevealRight][2] + incX * px
		endif
		hotspot px, hptsYM, pz, unID
		unID = unID + 2
		if gs_sidelight_WHole_width_right > EPS & gs_sidelight_parapet_hgt_right > EPS then
			hotspot px, hptsYR, pz, unID
			unID = unID + 2
			hotspot rightRevealPnts[idxBoardEndRevealRight][1], hptsYR, rightRevealPnts[idxBoardEndRevealRight][2], unID
			unID = unID + 2
		else
			unID = unID + 4
		endif
	else
		unID = unID + 6
	endif

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		hptsYM = -elevationOffset
		hptsYL = -elevationOffset
		hptsYR = -elevationOffset

		if	iWindowShape = SHAPE_ARCHED_T				| \
			iWindowShape = SHAPE_T						| \
			iWindowShape = SHAPE_ARCHED_HALF_T_LEFT		| \
			iWindowShape = SHAPE_HALF_T_LEFT then

			px = -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_double_innerLeft_sL
			if curvedWall then
				pz = WOD - signWallIsLeft * sqr(radSill^2 - px^2)
			else
				pz = leftRevealPnts[idxSillStartRevealLeft][2] + incX * px
			endif
			hotspot px, hptsYM, pz, unID
			unID = unID + 2
			if gs_sidelight_WHole_width_left > EPS & gs_sidelight_parapet_hgt_left > EPS then
				hotspot px, hptsYL + gs_sidelight_parapet_hgt_left, pz, unID
				unID = unID + 2
				hotspot leftRevealPnts[idxSillStartRevealLeft][1], hptsYL + gs_sidelight_parapet_hgt_left, leftRevealPnts[idxSillStartRevealLeft][2], unID
				unID = unID + 2
			else
				unID = unID + 4
			endif
		else
			unID = unID + 6
		endif

		if	iWindowShape = SHAPE_ARCHED_T				| \
			iWindowShape = SHAPE_T						| \
			iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT	| \
			iWindowShape = SHAPE_HALF_T_RIGHT then

			px = rightWidth - gs_sidelight_WHole_width_right - gs_reveal_double_innerRight_sR
			if curvedWall then
				pz = WOD - signWallIsLeft * sqr(radSill^2 - px^2)
			else
				pz = leftRevealPnts[idxSillStartRevealRight][2] + incX * px
			endif
			hotspot px, hptsYM, pz, unID
			unID = unID + 2
			if gs_sidelight_WHole_width_right > EPS & gs_sidelight_parapet_hgt_right > EPS then
				hotspot px, hptsYR + gs_sidelight_parapet_hgt_right, pz, unID
				unID = unID + 2
				hotspot rightRevealPnts[idxSillStartRevealRight][1], hptsYR + gs_sidelight_parapet_hgt_right, rightRevealPnts[idxSillStartRevealRight][2], unID
				unID = unID + 2
			else
				unID = unID + 4
			endif
		else
			unID = unID + 6
		endif
	else
		bNegativeReveal = (iRevealType = REVEAL_NEGATIVE | (iRevealType = REVEAL_DOUBLE & iSillRevealType = REVEAL_NEGATIVE))

		hptsYM = -elevationOffset + (isWindow | gs_reveal_bottom > EPS) * gs_reveal_bottom
		hptsYL = -elevationOffset + gs_reveal_bottom_sL
		hptsYR = -elevationOffset + gs_reveal_bottom_sL

		revealDiffLeft	= (gs_reveal_left_sL  - gs_reveal_left)
		revealDiffRight	= (gs_reveal_right_sR - gs_reveal_right)

		px = -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_left_sL
		if curvedWall then
			pz = WOD - signWallIsLeft * sqr(radSill^2 - px^2)
		else
			pz = leftRevealPnts[idxSillStartRevealLeft][2] + incX * px
		endif
		hotspot px, hptsYM, pz, unID
		unID = unID + 2
		if gs_sidelight_WHole_width_left > EPS & gs_sidelight_parapet_hgt_left > EPS then
			hotspot px, hptsYL + gs_sidelight_parapet_hgt_left, pz, unID
			unID = unID + 2
			hotspot leftRevealPnts[idxSillStartRevealLeft][1], hptsYL + gs_sidelight_parapet_hgt_left, leftRevealPnts[idxSillStartRevealLeft][2], 	unID
			unID = unID + 2
		else
			unID = unID + 4
		endif

		hptsYL = -elevationOffset + gs_reveal_bottom_sR
		hptsYR = -elevationOffset + gs_reveal_bottom_sR

		px = rightWidth - gs_sidelight_WHole_width_right - gs_reveal_right_sR
		if curvedWall then
			pz = WOD - signWallIsLeft * sqr(radSill^2 - px^2)
		else
			pz = leftRevealPnts[idxSillStartRevealRight][2] + incX * px
		endif
		hotspot px, hptsYM, pz, unID
		unID = unID + 2
		if gs_sidelight_WHole_width_right > EPS & gs_sidelight_parapet_hgt_right > EPS then
			hotspot px, hptsYR + gs_sidelight_parapet_hgt_right, pz, unID
			unID = unID + 2
			hotspot rightRevealPnts[idxSillStartRevealRight][1], hptsYR + gs_sidelight_parapet_hgt_right, rightRevealPnts[idxSillStartRevealRight][2], unID
			unID = unID + 2
		else
			unID = unID + 4
		endif

		hptsYL = -elevationOffset + gs_reveal_bottom_sL
		hptsYR = -elevationOffset + gs_reveal_bottom_sL

		add leftRevealPnts[idxSillEndRevealLeft][1], 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot gs_sidelight_WHole_width_left + not(bNegativeReveal) * revealDiffLeft, hptsYM, 0, 	unID
		unID = unID + 2
		if gs_sidelight_WHole_width_left > EPS & gs_sidelight_parapet_hgt_left > EPS then
			hotspot gs_sidelight_WHole_width_left + not(bNegativeReveal) * revealDiffLeft,	hptsYL + gs_sidelight_parapet_hgt_left - bNegativeReveal * gs_reveal_bottom_sL,	0, 	unID
			unID = unID + 2
			hotspot 0, hptsYL + gs_sidelight_parapet_hgt_left - bNegativeReveal * gs_reveal_bottom_sL,	0, 	unID
			unID = unID + 2
		else
			unID = unID + 4
		endif
		del 1

		hptsYL = -elevationOffset + gs_reveal_bottom_sR
		hptsYR = -elevationOffset + gs_reveal_bottom_sR

		add rightRevealPnts[idxSillEndRevealRight][1], 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot -gs_sidelight_WHole_width_right - not(bNegativeReveal) * revealDiffRight, hptsYM,										0, unID
		unID = unID + 2
		if gs_sidelight_WHole_width_right > EPS & gs_sidelight_parapet_hgt_right > EPS then
			hotspot -gs_sidelight_WHole_width_right - not(bNegativeReveal) * revealDiffRight, hptsYR + gs_sidelight_parapet_hgt_right - bNegativeReveal * gs_reveal_bottom_sR,	0, unID
			unID = unID + 2
			hotspot 0, hptsYR + gs_sidelight_parapet_hgt_right - bNegativeReveal * gs_reveal_bottom_sR,	0, unID
			unID = unID + 2
		else
			unID = unID + 4
		endif
		del 1

		hptsYL = -elevationOffset
		hptsYR = -elevationOffset

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot gs_sidelight_WHole_width_left, 	hptsYL,									0, 	unID
		unID = unID + 2
		if gs_sidelight_WHole_width_left > EPS & gs_sidelight_parapet_hgt_left > EPS then
			hotspot gs_sidelight_WHole_width_left,	hptsYL + gs_sidelight_parapet_hgt_left,	0, 	unID
			unID = unID + 2
			hotspot 0,								hptsYL + gs_sidelight_parapet_hgt_left,	0, 	unID
			unID = unID + 2
		else
			unID = unID + 4
		endif
		del 1

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot -gs_sidelight_WHole_width_right, hptsYR,										0, unID
		unID = unID + 2
		if gs_sidelight_WHole_width_right > EPS & gs_sidelight_parapet_hgt_right > EPS then
			hotspot -gs_sidelight_WHole_width_right,	hptsYR + gs_sidelight_parapet_hgt_right,	0, unID
			unID = unID + 2
			hotspot 0, 									hptsYR + gs_sidelight_parapet_hgt_right,	0, unID
			unID = unID + 2
		else
			unID = unID + 4
		endif
		del 1

	endif
endif

if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_T | iWindowShape = SHAPE_HALF_T_LEFT | iWindowShape = SHAPE_HALF_T_RIGHT then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, B + dyBLT - gs_reveal_double_innerTop * (iRevealType = REVEAL_DOUBLE) - overSizeLower + overSizeUpper,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, B + dyBRT - gs_reveal_double_innerTop * (iRevealType = REVEAL_DOUBLE) - overSizeLower + overSizeUpper,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | ((iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) & gs_mountingFrame) then
		if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
			hptsYL = B + overSizeUpper + (bSlantedOuterSide & not(gs_stack_top)) * ( -leftRevealPnts[idxSillStartRevealLeft][2]  - gs_reveal_outer_jamb_depth) * tan(gs_reveal_outerTop_angle)
			hptsYR = B + overSizeUpper + (bSlantedOuterSide & not(gs_stack_top)) * (-rightRevealPnts[idxSillStartRevealRight][2] - gs_reveal_outer_jamb_depth) * tan(gs_reveal_outerTop_angle)
		else
			hptsYL = gs_reveal_bottom + ac_reveal_height + overSizeLowerOriginal - elevationOffset + original_gs_reveal_bottom * not(bShowRevealSE)
			hptsYR = hptsYL
		endif

		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,hptsYL,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0,hptsYR,	0, unID+1
		del 1
		unID = unID + 2

![#COMPATIBILITY] - START
!		unID = unID + 8
![#COMPATIBILITY] - END
	else
		if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
			hptsY = B + overSizeUpper - gs_reveal_top
		else
			hptsY = gs_reveal_bottom + ac_reveal_height + overSizeLowerOriginal - elevationOffset
		endif

		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,hptsY,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0,hptsY,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillEndRevealLeft][1], 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,hptsY,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0,hptsY,	0, unID+1
		del 1
		unID = unID + 2

		if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
			hptsY = B + overSizeUpper
		else
			if ac_wallhole_height_original > EPS then
				hptsY = ac_wallhole_height_original + overSizeLowerOriginal - elevationOffset
			else
				hptsY = ac_wallhole_height + overSizeLowerOriginal - elevationOffset
			endif
		endif

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0,hptsY,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0,hptsY,	0, unID+1
		del 1
		unID = unID + 2
	endif
endif

if iWindowShape = SHAPE_ARCHED | iWindowShape = SHAPE_ARCHED_T | iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, openingHeight - archHeight + dyBLT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight - archHeight + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2
	else

		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2


		add leftRevealPnts[idxSillEndRevealLeft][1], 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2
	endif

	add 0, gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
	hotspot 0,ac_reveal_height + overSizeLowerOriginal - elevationOffset,	0, unID+1
	del 1
	unID = unID + 2

	add 0, gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
	hotspot 0,ac_reveal_height + overSizeLowerOriginal - elevationOffset,	0, unID+1
	del 1
	unID = unID + 2

	if bShowAddHotspotsForIS then

		add 0, gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2

		add 0, gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2
	endif

endif

if iWindowShape = SHAPE_EYEBROWS | iWindowShape = SHAPE_ELLIPSEARCH then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, openingHeight - archHeight + dyBLT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight - archHeight + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

![#COMPATIBILITY] - START
!		unID = unID + 8
![#COMPATIBILITY] - END
	else
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillEndRevealLeft][1], 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2
	endif

	add 0, 0, leftRevealPnts[idxSillStartRevealLeft][2]
	hotspot 0,ac_reveal_height + overSizeLowerOriginal - elevationOffset,	0, unID+1
	del 1
	unID = unID + 2

	add 0, 0, leftRevealPnts[idxSillEndRevealLeft][2]
	hotspot 0,ac_reveal_height + overSizeLowerOriginal - elevationOffset,	0, unID+1
	del 1
	unID = unID + 2

	if bShowAddHotspotsForIS then

		add 0, 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2
	else
![#COMPATIBILITY] - START
!		unID = unID + 4
![#COMPATIBILITY] - END
	endif

endif

if iWindowShape = SHAPE_TRIANGLE then
	_oleft = -leftJamb / sin(atn(tan_LeftSide))
	_oright = -rightJamb / sin(atn(tan_RightSide))
	_xTop = (ac_wallhole_width + _oleft + _oright) / (tan_LeftSide / tan_RightSide + 1)
	_yTop = _xTop * tan_LeftSide
	addx -ac_wallhole_width / 2 - _oleft + _xTop

	add 0, 0, leftRevealPnts[idxSillStartRevealLeft][2]
	hotspot 0, _yTop,	0, unID+1
	del 1
	unID = unID + 2

	add 0, 0, leftRevealPnts[idxSillEndRevealLeft][2]
	hotspot 0, _yTop,	0, unID+1
	del 1
	unID = unID + 2

	if bShowAddHotspotsForIS then

		add 0, 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2
	endif

	del 1
endif

if iWindowShape = SHAPE_HALFCIRCLE then

	add 0, 0, leftRevealPnts[idxSillStartRevealLeft][2]
	hotspot 0, ac_reveal_height + overSizeLowerOriginal - elevationOffset,	0, unID+1
	del 1
	unID = unID + 2

	add 0, 0, leftRevealPnts[idxSillEndRevealLeft][2]
	hotspot 0, ac_reveal_height + overSizeLowerOriginal - elevationOffset,	0, unID+1
	del 1
	unID = unID + 2

	if bShowAddHotspotsForIS then

		add 0, 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2
	endif

endif

if iWindowShape = SHAPE_HALFARCH then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, openingHeight - archHeight + CustRevealRightJamb + dyBLT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight + CustRevealRightJamb + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight,	0, unID+1
		del 1
		unID = unID + 2

		unID = unID + 8
	else
		add leftRevealPnts[idxSillStartRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, SillShouldy - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, SillTopy - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillEndRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, SillShouldy - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, SillTopy - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight,	0, unID+1
		del 1
		unID = unID + 2
	endif

endif

if iWindowShape = SHAPE_PENTAGON then

! Board Side Hotspots ----------------------------------------------------------

	_hCenter = B + overSizeUpper - (CustRevealTopJamb + thkPlasterAtBoardTop) / cos(atn(tan_topAngle))

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, _hCenter + leftRevealPnts[idxBoardEndRevealLeft][1] * tan_topAngle,	0, unID+1

	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, _hCenter - rightRevealPnts[idxBoardEndRevealRight][1] * tan_topAngle,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	_hCenter = B + overSizeUpper - (upperJamb + thkPlasterAtSillTop) / cos(atn(tan_topAngle))

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, _hCenter + leftRevealPnts[idxSillStartRevealLeft][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, _hCenter - rightRevealPnts[idxSillStartRevealRight][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, _hCenter,	0, unID+1
		del 1
		unID = unID + 2

	else
		add leftRevealPnts[idxSillStartRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, _hCenter + leftRevealPnts[idxSillStartRevealLeft][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, _hCenter - rightRevealPnts[idxSillStartRevealRight][1] * tan_topAngle, 0, unID+1
		del 1
		unID = unID + 2

		add 0, gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, _hCenter, 0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillEndRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, _hCenter + leftRevealPnts[idxSillEndRevealLeft][1] * tan_topAngle, 0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, _hCenter - rightRevealPnts[idxSillEndRevealRight][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add 0, gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, _hCenter, 0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight,	0, unID+1
		del 1
		unID = unID + 2
	endif

	add 0, 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight + CustRevealRightJamb + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

	if bShowAddHotspotsForIS then

		add 0, gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2

		add 0, gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2
	endif

endif

if iWindowShape = SHAPE_HALFROUND then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, openingHeight/2 + CustRevealRightJamb + dyBLT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight/2 + CustRevealRightJamb + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight + CustRevealRightJamb + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, CustRevealRightJamb + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight/2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight/2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, 0,	0, unID+1
		del 1
		unID = unID + 2

		unID = unID + 16
	else
		add leftRevealPnts[idxSillStartRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight/2 - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight/2 - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - sillArcoffs - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, sillArcoffs - lowerJamb, 0, unID+1
		del 1
		unID = unID + 2


		add leftRevealPnts[idxSillEndRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, openingHeight/2 - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight/2 - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight - sillArcoffs - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, sillArcoffs - lowerJamb, 0, unID+1
		del 1
		unID = unID + 2


		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, openingHeight/2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight/2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, 0,	0, unID+1
		del 1
		unID = unID + 2
	endif

endif

if iWindowShape = SHAPE_TRAPEZOID then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, B + dyBLT + not(bMirroredOpening) * (-archHeight + CustRevealRightJamb),	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, B + dyBRT + bMirroredOpening * (-archHeight + CustRevealRightJamb),	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	_hCenter = B + overSizeUpper - overSizeLower - archHeight / 2 - (upperJamb + thkPlasterAtSillTop) / cos(atn(tan_topAngle))
	_dirWin = not(bMirroredOpening) * 2 - 1		!mirrored: -1  nonmirrored: 1

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight - not(bMirroredOpening) * archHeight_reveal,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, _hCenter + _dirWin * rightRevealPnts[idxSillStartRevealRight][1] * tan_topAngle, 0, unID+1
		del 1
		unID = unID + 2
	else

		add leftRevealPnts[idxSillStartRevealLeft][1], overSizeLower, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, _hCenter + _dirWin * leftRevealPnts[idxSillStartRevealLeft][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], overSizeLower, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, _hCenter + _dirWin * rightRevealPnts[idxSillStartRevealRight][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillEndRevealLeft][1], overSizeLower , leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, _hCenter + _dirWin * leftRevealPnts[idxSillEndRevealLeft][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], overSizeLower , rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, _hCenter + _dirWin * rightRevealPnts[idxSillEndRevealRight][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		_hCenter = B + overSizeUpper - overSizeLower - archHeight / 2 - thkPlasterAtSillTop / cos(atn(tan_topAngle))

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, _hCenter + _dirWin * leftRevealPnts[idxFrameStartRevealLeft][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight - bMirroredOpening * archHeight,	0, unID+1
		del 1
		unID = unID + 2
	endif
endif

if iWindowShape = SHAPE_GOTHICARCH then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, openingHeight - archHeight + CustRevealRightJamb + dyBLT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight - archHeight + CustRevealRightJamb + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

	add 0, 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight + CustRevealRightJamb + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight,	0, unID+1
		del 1
		unID = unID + 2

		unID = unID + 12
	else
		add leftRevealPnts[idxSillStartRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight- archHeight - lowerJamb ,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - archHeight - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add 0, gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - centSillArcoffs - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillEndRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, openingHeight - archHeight - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight - archHeight - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add 0, gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight - centSillArcoffs - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight,	0, unID+1
		del 1
		unID = unID + 2
	endif

	if bShowAddHotspotsForIS then

		add 0, gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2

		add 0, gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2
	else
		unID = unID + 4
	endif

endif

if iWindowShape = SHAPE_ROMBUS then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, openingHeight / 2,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight / 2,	0, unID+1
	del 1
	unID = unID + 2

	add 0, 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, - overSizeLower + CustRevealBottJamb,	0, unID+1
	del 1
	unID = unID + 2

	add 0, 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight + oversizeUpper + CustRevealTopJamb,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, - overSizeLower,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight + oversizeUpper,	0, unID+1
		del 1
		unID = unID + 2

![#COMPATIBILITY] - START
!		unID = unID + 16
![#COMPATIBILITY] - END
	else
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, lowerJamb - overSizeLower,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - upperJamb + oversizeUpper,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillEndRevealLeft][1], 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, lowerJamb - overSizeLower,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight - upperJamb + oversizeUpper,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, - overSizeLower,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight + oversizeUpper,	0, unID+1
		del 1
		unID = unID + 2
	endif
endif

if iWindowShape = SHAPE_PARALLELOGRAM then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, archHeight - dyBLB,	0, unID
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, - dyBRB, 	0, unID
	del 1
	unID = unID + 2

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, B + dyBLT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, B - archHeight + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, archHeight_reveal - elevationOffset,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, - elevationOffset,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, B - elevationOffset,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, B - archHeight_reveal - elevationOffset,	0, unID+1
		del 1
		unID = unID + 2
	else
![#COMPATIBILITY] - START
!		unID = unID + 8
![#COMPATIBILITY] - END
	endif
endif

if iWindowShape = SHAPE_OCTAGONAL then
	addy openingHeight/2
	mulx openingWidth / openingHeight

	alpha_rotation = 22.5

	! Reveal Hotspots --------------------------------------------------------------
	for i = 1 to 8
		gosub 3000

		alpha_rotation = alpha_rotation + 45
	next i


	! Wallhole Hotspots ------------------------------------------------------------
	unID=11000

	for i = 1 to 8
		gosub 4000

		alpha_rotation = alpha_rotation + 45
	next i

	del 2
endif

if iWindowShape = SHAPE_MULTISIDE then
	addy normalRadius * cos (180 / gs_numOfSides)

	! Reveal Hotspots --------------------------------------------------------------
	alpha_rotation = 0
	if (gs_numOfSides mod 2) = 0 then
		alpha_rotation = 180 / gs_numOfSides
	endif

	unID = unID + 1

	for i = 1 to gs_numOfSides

		if (gs_numOfSides mod 2) <> 0 then

			if	i = 1 then
				gosub 3000
			endif
			if	i = int(gs_numOfSides / 2) + 1 or\
				i = int(gs_numOfSides / 2) + 2 then
				gosub 3000
			endif
			if i = int(gs_numOfSides / 2) + 1 then
				if bShowAddHotspotsForIS then
					gosub 3000
				endif
			endif

			if ((gs_numOfSides + 1) mod 4) <> 0 then
				if	i = (gs_numOfSides + 3) / 4 or\
					i = (gs_numOfSides + 3) / 4 + ((gs_numOfSides + 1) / 2) then
					gosub 3000
				endif
			else
				if	i = (gs_numOfSides + 5) / 4 or\
					i = (gs_numOfSides + 5) / 4 + ((gs_numOfSides - 1) / 2) then
					gosub 3000
				endif
			endif

		else

			if	i = 1 or\
				i = gs_numOfSides or\
				i = gs_numOfSides / 2 or\
				i = gs_numOfSides / 2 + 1 then
				gosub 3000
			endif

			if (gs_numOfSides mod 4) <> 0 then
				if	i = (gs_numOfSides + 2) / 4 or\
					i = (gs_numOfSides + 2) / 4 + gs_numOfSides / 2 then
					gosub 3000
				endif
			else
				if	i = gs_numOfSides / 4 or\
					i = gs_numOfSides / 4 + 1 or\
					i = gs_numOfSides / 4 + gs_numOfSides / 2 or\
					i = gs_numOfSides / 4 + gs_numOfSides / 2 + 1 then
					gosub 3000
				endif
			endif

		endif

		alpha_rotation = alpha_rotation + 360 / gs_numOfSides
	next i


	! Wallhole Hotspots ------------------------------------------------------------
	unID = 11000

	alpha_rotation = 0
	if (gs_numOfSides mod 2) = 0 then
		alpha_rotation = 180 / gs_numOfSides
	endif

	for i = 1 to gs_numOfSides

		if (gs_numOfSides mod 2) <> 0 then

			if	i = 1 then
				gosub 4000
			endif
			if	i = int(gs_numOfSides / 2) + 1 or\
				i = int(gs_numOfSides / 2) + 2 then
				gosub 4000
			endif
			if i = int(gs_numOfSides / 2) + 1 then
				if bShowAddHotspotsForIS then
					gosub 4000
				endif
			endif

			if ((gs_numOfSides + 1) mod 4) <> 0 then
				if	i = (gs_numOfSides + 3) / 4 or\
					i = (gs_numOfSides + 3) / 4 + ((gs_numOfSides + 1) / 2) then
					gosub 4000
				endif
			else
				if	i = (gs_numOfSides + 5) / 4 or\
					i = (gs_numOfSides + 5) / 4 + ((gs_numOfSides - 1) / 2) then
					gosub 4000
				endif
			endif

		else

			if	i = 1 or\
				i = gs_numOfSides or\
				i = gs_numOfSides / 2 or\
				i = gs_numOfSides / 2 + 1 then
				gosub 4000
			endif

			if (gs_numOfSides mod 4) <> 0 then
				if	i = (gs_numOfSides + 2) / 4 or\
					i = (gs_numOfSides + 2) / 4 + gs_numOfSides / 2 then
					gosub 4000
				endif
			else
				if	i = gs_numOfSides / 4 or\
					i = gs_numOfSides / 4 + 1 or\
					i = gs_numOfSides / 4 + gs_numOfSides / 2 or\
					i = gs_numOfSides / 4 + gs_numOfSides / 2 + 1 then
					gosub 4000
				endif
			endif

		endif

		alpha_rotation = alpha_rotation + 360 / gs_numOfSides
	next i

	del 1
endif

if iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then

	addy openingHeight / 2
	muly openingHeight / openingWidth

	! Reveal Hotspots --------------------------------------------------------------
	if iRevealType > REVEAL_NO then
		hotspot 0,  openingWidth/2 - rightJamb, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 1
		hotspot 0, -openingWidth/2 + rightJamb, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 2
		hotspot  openingWidth/2 - rightJamb, 0, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 3
		hotspot -openingWidth/2 + rightJamb, 0, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 4
		unID = unID + 4

		hotspot 0,  openingWidth/2 - rightJamb, leftRevealPnts[idxSillEndRevealLeft][2],	unID + 1
		hotspot 0, -openingWidth/2 + rightJamb, leftRevealPnts[idxSillEndRevealLeft][2],	unID + 2
		hotspot  openingWidth/2 - rightJamb, 0, leftRevealPnts[idxSillEndRevealLeft][2],	unID + 3
		hotspot -openingWidth/2 + rightJamb, 0, leftRevealPnts[idxSillEndRevealLeft][2],	unID + 4
		unID = unID + 4
	endif


	! Wallhole Hotspots ------------------------------------------------------------
	unID=11000

	! Board Side Hotspots ----------------------------------------------------------
	hotspot 0,  openingWidth/2, leftRevealPnts[idxBoardEndRevealLeft][2],	unID + 1
	hotspot 0, -openingWidth/2, leftRevealPnts[idxBoardEndRevealLeft][2],	unID + 2
	hotspot  openingWidth/2, 0, leftRevealPnts[idxBoardEndRevealLeft][2],	unID + 3
	hotspot -openingWidth/2, 0, leftRevealPnts[idxBoardEndRevealLeft][2],	unID + 4
	unID = unID + 4

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		hotspot 0,  openingWidth/2, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 1
		hotspot 0, -openingWidth/2, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 2
		hotspot  openingWidth/2, 0, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 3
		hotspot -openingWidth/2, 0, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 4
		unID = unID + 4
	else
		hotspot 0,  openingWidth/2, leftRevealPnts[idxFrameStartRevealLeft][2],	unID + 1
		hotspot 0, -openingWidth/2, leftRevealPnts[idxFrameStartRevealLeft][2],	unID + 2
		hotspot  openingWidth/2, 0, leftRevealPnts[idxFrameStartRevealLeft][2],	unID + 3
		hotspot -openingWidth/2, 0, leftRevealPnts[idxFrameStartRevealLeft][2],	unID + 4
		unID = unID + 4
	endif

	del 2
endif


if bSillIsHorizontal & \
	( iRevealType = REVEAL_SLANTED	| \
	  iRevealType = REVEAL_SPLAYED	| \
	  iRevealType = REVEAL_HISTORIC	| \
	 (iRevealType = REVEAL_DOUBLE & abs(gs_reveal_double_innerBottom) > EPS) ) then

! Board Side Hotspots ----------------------------------------------------------

	if bSlantedInnerSide & not(gs_stack_bottom) & isWindow then
		dyBLB =  ((leftRevealPnts[idxBoardEndRevealLeft - 1][2]  - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_bottom_angle)) - (iRevealType <> REVEAL_SLANTED) * gs_reveal_splayed_innerBottom	! Bottom Left
		dyBRB = ((rightRevealPnts[idxBoardEndRevealRight - 1][2] - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_bottom_angle)) - (iRevealType <> REVEAL_SLANTED) * gs_reveal_splayed_innerBottom	! Bottom Right
	else
		dyBLB = -(iRevealType = REVEAL_DOUBLE) * gs_reveal_double_innerBottom
		dyBRB = -(iRevealType = REVEAL_DOUBLE) * gs_reveal_double_innerBottom
	endif

	add leftRevealPnts[idxBoardEndRevealLeft - 1][1], 0, leftRevealPnts[idxBoardEndRevealLeft - 1][2]
	hotspot 0,-dyBLB,						0, unID
	del 1
	unID = unID + 1

	add rightRevealPnts[idxBoardEndRevealRight - 1][1], 0, rightRevealPnts[idxBoardEndRevealRight - 1][2]
	hotspot 0,-dyBRB,						0, unID
	del 1
	unID = unID + 1
endif

if iWindowShape = SHAPE_RECTANGULAR & \
	( iRevealType = REVEAL_SLANTED	| \
	  iRevealType = REVEAL_SPLAYED	| \
	  iRevealType = REVEAL_HISTORIC	| \
	 (iRevealType = REVEAL_DOUBLE & abs(gs_reveal_double_innerTop) > EPS) ) then

	if bSlantedInnerSide & not(gs_stack_top) then
		dyBLT =  ((leftRevealPnts[idxBoardEndRevealLeft - 1][2]  - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_top_angle) - (iRevealType <> REVEAL_SLANTED) * gs_reveal_splayed_InnerTop)	! Top Left
		dyBRT = ((rightRevealPnts[idxBoardEndRevealRight - 1][2] - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_top_angle) - (iRevealType <> REVEAL_SLANTED) * gs_reveal_splayed_InnerTop)	! Top Right
	else
		dyBLT = -(iRevealType = REVEAL_DOUBLE) * gs_reveal_double_innerTop
		dyBRT = -(iRevealType = REVEAL_DOUBLE) * gs_reveal_double_innerTop
	endif

	add leftRevealPnts[idxBoardEndRevealLeft - 1][1], 0, leftRevealPnts[idxBoardEndRevealLeft - 1][2]
	hotspot 0, B + dyBLT - overSizeLower + overSizeUpper,	0, unID
	del 1
	unID = unID + 1

	add rightRevealPnts[idxBoardEndRevealRight - 1][1], 0, rightRevealPnts[idxBoardEndRevealRight - 1][2]
	hotspot 0, B + dyBRT - overSizeLower + overSizeUpper,	0, unID
	del 1
	unID = unID + 1
endif


!! Horizontal editing -----------------------------------------------------------
!
!		add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
!		hotspot  0,0,					0, unID,   ac_wallhole_width, 1+256, ac_wallhole_width	! Base
!		hotspot -ac_wallhole_width,0,	0, unID+1, ac_wallhole_width, 2,		ac_wallhole_width	! Moving
!		hotspot  1,0,					0, unID+2, ac_wallhole_width, 3,		ac_wallhole_width	! Reference
!		del 1
!		unID = unID + 3
!
!		if abs(gs_wallhole_width_half) > EPS then
!			add dxBR, 0, rightRevealPnts[idxBoardEndRevealRight][2]
!			hotspot  0,0,						0, unID,   gs_wallhole_width_half, 1+128, ac_wallhole_width	! Base
!			hotspot  gs_wallhole_width_half,0,	0, unID+1, gs_wallhole_width_half, 2,		ac_wallhole_width	! Moving
!			hotspot -1,0,						0, unID+2, gs_wallhole_width_half, 3,		ac_wallhole_width	! Reference
!			del 1
!		endif
!		unID = unID + 3
!
!		if abs(gs_wallhole_width_half) > EPS then
!			add dxBL, 0, leftRevealPnts[idxBoardEndRevealLeft][2]
!			hotspot  0,0,						0, unID,   gs_wallhole_width_half, 1+128,	ac_wallhole_width	! Base
!			hotspot -gs_wallhole_width_half,0,	0, unID+1, gs_wallhole_width_half, 2,		ac_wallhole_width	! Moving
!			hotspot  1,0,						0, unID+2, gs_wallhole_width_half, 3,		ac_wallhole_width	! Reference
!			del 1
!		endif
!		unID = unID + 3
!
!		if abs(gs_wallhole_width_half) > EPS then
!			add dxBR, openingHeight, rightRevealPnts[idxBoardEndRevealRight][2]
!			hotspot  0,0,						0, unID,   gs_wallhole_width_half, 1+128, ac_wallhole_width	! Base
!			hotspot  gs_wallhole_width_half,0,	0, unID+1, gs_wallhole_width_half, 2,		ac_wallhole_width	! Moving
!			hotspot -1,0,						0, unID+2, gs_wallhole_width_half, 3,		ac_wallhole_width	! Reference
!			del 1
!		endif
!		unID = unID + 3
!
!		if abs(gs_wallhole_width_half) > EPS then
!			add dxBL, openingHeight, leftRevealPnts[idxBoardEndRevealLeft][2]
!			hotspot  0,0,						0, unID,   gs_wallhole_width_half, 1+128,	ac_wallhole_width	! Base
!			hotspot -gs_wallhole_width_half,0,	0, unID+1, gs_wallhole_width_half, 2,		ac_wallhole_width	! Moving
!			hotspot  1,0,						0, unID+2, gs_wallhole_width_half, 3,		ac_wallhole_width	! Reference
!			del 1
!		endif
!		unID = unID + 3
!
!		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
!		else
!			if abs(gs_reveal_width_half) > EPS then
!				add dxSR, gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
!				hotspot  0,0,					0, unID,   gs_reveal_width_half, 1+128, ac_reveal_width	! Base
!				hotspot  gs_reveal_width_half,0,0, unID+1, gs_reveal_width_half, 2,	  ac_reveal_width	! Moving
!				hotspot -1,0,					0, unID+2, gs_reveal_width_half, 3,	  ac_reveal_width	! Reference
!				del 1
!			endif
!			unID = unID + 3
!
!			if abs(gs_reveal_width_half) > EPS then
!				add dxSL, gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
!				hotspot  0,0,					0, unID,   gs_reveal_width_half, 1+128, ac_reveal_width	! Base
!				hotspot -gs_reveal_width_half,0,0, unID+1, gs_reveal_width_half, 2,	  ac_reveal_width	! Moving
!				hotspot  1,0,					0, unID+2, gs_reveal_width_half, 3,	  ac_reveal_width	! Reference
!				del 1
!			endif
!			unID = unID + 3
!
!			if abs(gs_reveal_width_half) > EPS then
!				add dxSR, openingHeight - gs_reveal_top, rightRevealPnts[idxSillStartRevealRight][2]
!				hotspot  0,0,					0, unID,   gs_reveal_width_half, 1+128, ac_reveal_width	! Base
!				hotspot  gs_reveal_width_half,0,0, unID+1, gs_reveal_width_half, 2,	  ac_reveal_width	! Moving
!				hotspot -1,0,					0, unID+2, gs_reveal_width_half, 3,	  ac_reveal_width	! Reference
!				del 1
!			endif
!			unID = unID + 3
!
!			if abs(gs_reveal_width_half) > EPS then
!				add dxSL, openingHeight - gs_reveal_top, leftRevealPnts[idxSillStartRevealLeft][2]
!				hotspot  0,0,					0, unID,   gs_reveal_width_half, 1+128, ac_reveal_width	! Base
!				hotspot -gs_reveal_width_half,0,0, unID+1, gs_reveal_width_half, 2,	  ac_reveal_width	! Moving
!				hotspot  1,0,					0, unID+2, gs_reveal_width_half, 3,	  ac_reveal_width	! Reference
!				del 1
!			endif
!			unID = unID + 3
!		endif
!
!! Vertical editing -------------------------------------------------------------
!
!		add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
!		hotspot 0,0,					0, unID,   ac_wallhole_height, 1	! Base
!		hotspot 0,ac_wallhole_height,	0, unID+1, ac_wallhole_height, 2	! Moving
!		hotspot 0,-1,					0, unID+2, ac_wallhole_height, 3	! Reference
!		del 1
!		unID = unID + 3
!
!		add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
!		hotspot 0,0,					0, unID,   ac_wallhole_height, 1	! Base
!		hotspot 0,ac_wallhole_height,	0, unID+1, ac_wallhole_height, 2	! Moving
!		hotspot 0,-1,					0, unID+2, ac_wallhole_height, 3	! Reference
!		del 1
!		unID = unID + 3
!
!		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
!			add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
!			hotspot 0,0,				0, unID,   ac_wallhole_height, 1	! Base
!			hotspot 0,ac_reveal_height,	0, unID+1, ac_wallhole_height, 2	! Moving
!			hotspot 0,-1,				0, unID+2, ac_wallhole_height, 3	! Reference
!			del 1
!			unID = unID + 3
!
!			add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
!			hotspot 0,0,				0, unID,   ac_wallhole_height, 1	! Base
!			hotspot 0,ac_reveal_height,	0, unID+1, ac_wallhole_height, 2	! Moving
!			hotspot 0,-1,				0, unID+2, ac_wallhole_height, 3	! Reference
!			del 1
!			unID = unID + 3
!		else
!			add leftRevealPnts[idxSillStartRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
!			hotspot 0,0,				0, unID,   ac_reveal_height, 1	! Base
!			hotspot 0,ac_reveal_height,	0, unID+1, ac_reveal_height, 2	! Moving
!			hotspot 0,-1,				0, unID+2, ac_reveal_height, 3	! Reference
!			del 1
!			unID = unID + 3
!
!			add rightRevealPnts[idxSillStartRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
!			hotspot 0,0,				0, unID,   ac_reveal_height, 1	! Base
!			hotspot 0,ac_reveal_height,	0, unID+1, ac_reveal_height, 2	! Moving
!			hotspot 0,-1,				0, unID+2, ac_reveal_height, 3	! Reference
!			del 1
!			unID = unID + 3
!		endif
!	endif

if WIDO_REVEAL_SIDE then
	del 2
endif

! ==============================================================================
! Cut Default Wallhole
! ==============================================================================

if not(curvedWall) | (curvedWall & bParalellInCurvedWalls) then

	if WIDO_REVEAL_SIDE then
		addz WIDO_SILL - WALL_THICKNESS + WIDO_FRAME_THICKNESS    ! Flip
	else
		addz -WIDO_SILL
	endif

	if WIDO_REVEAL_SIDE then
		mulz -1
		addz -WALL_THICKNESS
	endif

	if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
		MulRat = 1
	endif

! =============================================================================
! Outer Side Cut - Straight Wall
! =============================================================================

	if WIDO_SILL > EPS then
		material matRevealSide

		_bCustomMatNicheTop			= bCustomMatNicheTop
		_wallNicheSurfaceLeft		= matRevealSide
		_wallNicheSurfaceRight		= matRevealSide
		_wallNicheSurfaceBottom		= matRevealSide
		_wallNicheSurfaceTop		= matNicheTop

		cutMethod	= 1
		if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then
			cutStatus	= 2 + 16 + 256 * _bCustomMatNicheTop
		else
			cutStatus	= 2 + 16
		endif
		cutVectX	= 0
		cutVectY	= 0
		cutVectZ	= 1
		cutDepth	= WIDO_SILL

		sideRight	= rightWidth + overSizeRight
		sideLeft	= leftWidth  + overSizeLeft
		sideBottom	= overSizeLower
		sideTop		= B + overSizeUpper

		offLeft		= leftJamb  + thkPlasterAtSillLeft
		offRight	= rightJamb + thkPlasterAtSillRight
		offTop		= upperJamb + thkPlasterAtSillTop
		offBottom	= lowerJamb + thkPlasterAtSillBottom

		if iWindowShape = SHAPE_ELLIPSEARCH then
			smallRadiusEllips_offset	= smallRadiusEllips_reveal
			middleRadiusEllips_offset	= middleRadiusEllips_reveal
		endif

		if iWindowShape = SHAPE_GOTHICARCH then
			centArcoffs		= centSillArcoffs
		endif

		if iWindowShape = SHAPE_OGEECENTERED then
			centArcoffs		= centSillArcoffs
		endif

		if iWindowShape = SHAPE_SARACENIC then
			tangArcx		= SilltangArcx
			tangArcy		= SilltangArcy
			centArcoffs		= centSillArcoffs
		endif

		if iWindowShape = SHAPE_HORSESHOE then
			LowArcoffsy		= SillLowArcoffsy
			LowArcoffsx		= SillLowArcoffsx
			HighArcoffs		= SillHighArcoffs
		endif

		if iWindowShape = SHAPE_HALFARCH then
			Topx	= SillTopx
			Topy	= SillTopy
			Shouldx	= SillShouldx
			Shouldy	= SillShouldy
		endif

		if bTShapedOpening then
			offSlLeft			= gs_reveal_left_sL   + thkPlasterAtSillSLLeft
			offSlRight			= gs_reveal_right_sR  + thkPlasterAtSillSLRight
			offSlLeftBottom		= gs_reveal_bottom_sL + thkPlasterAtSillSlLeftBottom
			offSlRightBottom	= gs_reveal_bottom_sR + thkPlasterAtSillSlRightBottom
		endif

		addz -SillPlasterAtFrame
		gosub 2000
		del 1

	endif


! =============================================================================
! Plaster Layer Outer Side Cut - Straight Wall
! =============================================================================

	if WIDO_SILL > EPS & SillPlasterAtFrame > EPS then
		cutMethod	= 1
		cutStatus	= 2 + 16
		cutVectX	= 0
		cutVectY	= 0
		cutVectZ	= 1
		cutDepth	= WIDO_SILL

		sideRight	= rightWidth + overSizeRight
		sideLeft	= leftWidth  + overSizeLeft
		sideBottom	= overSizeLower - bSillIsHorizontal * bBoardElevUsa
		sideTop		= B + overSizeUpper

		offLeft		= thkPlasterAtSillLeft
		offRight	= thkPlasterAtSillRight
		offTop		= thkPlasterAtSillTop	 + (thkPlasterAtSillTop		< EPS) * gs_reveal_top
		offBottom	= thkPlasterAtSillBottom + (thkPlasterAtSillBottom	< EPS) * gs_reveal_bottom

		if iWindowShape = SHAPE_ELLIPSEARCH then
			smallRadiusEllips_offset	= smallRadiusEllips - offLeft
			middleRadiusEllips_offset	= middleRadiusEllips - offLeft
		endif

		if bTShapedOpening then
			offSlLeft			= thkPlasterAtSillSlLeft
			offSlRight			= thkPlasterAtSillSlRight
			offSlLeftBottom		= thkPlasterAtSillSlLeftBottom  + (thkPlasterAtSillSlLeftBottom	 < EPS) * gs_reveal_bottom
			offSlRightBottom	= thkPlasterAtSillSlRightBottom + (thkPlasterAtSillSlRightBottom < EPS) * gs_reveal_bottom
		endif

		gosub 2000
	endif


! =============================================================================
! Inner Side Cut - Straight Wall
! =============================================================================

	material matOppositeSide

	addz WALL_THICKNESS

	isParIns = 0

	if not(bSlantedInnerSide) then
		cutMethod	= 1
		cutStatus	= 2 + 8 * (WIDO_SILL < EPS) + 16
		cutVectX	= 0
		cutVectY	= 0
		cutVectZ	= -1
		cutDepth	= WALL_THICKNESS - WIDO_SILL - CustRevealOffsetDepth - BoardPlasterAtFrame

		sideRight	= rightWidth + overSizeRight
		sideLeft	= leftWidth  + overSizeLeft
		sideBottom	= overSizeLower
		sideTop		= B + overSizeUpper

		offLeft		= CustRevealLeftJamb  + thkPlasterAtBoardLeft
		offRight	= CustRevealRightJamb + thkPlasterAtBoardRight
		offTop		= CustRevealTopJamb   + thkPlasterAtBoardTop
		offBottom	= CustRevealBottJamb  + thkPlasterAtBoardBottom + bSillIsHorizontal * bBoardElevUsa

		if iWindowShape = SHAPE_ELLIPSEARCH then
			smallRadiusEllips_offset	= smallRadiusEllips_Innreveal
			middleRadiusEllips_offset	= middleRadiusEllips_Innreveal
		endif

		if iWindowShape = SHAPE_GOTHICARCH then
			centArcoffs		= centBoardArcoffs
		endif

		if iWindowShape = SHAPE_OGEECENTERED then
			centArcoffs		= centBoardArcoffs
		endif

		if iWindowShape = SHAPE_SARACENIC then
			tangArcx		= BoardtangArcx
			tangArcy		= BoardtangArcy
			centArcoffs		= centBoardArcoffs
		endif

		if iWindowShape = SHAPE_HORSESHOE then
			LowArcoffsy		= BoardLowArcoffsy
			LowArcoffsx		= BoardLowArcoffsx
			HighArcoffs		= BoardHighArcoffs
		endif

		if iWindowShape = SHAPE_HALFARCH then
			Topx	= BoardTopx
			Topy	= BoardTopy
			Shouldx	= BoardShouldx
			Shouldy	= BoardShouldy
		endif

		if bTShapedOpening then
			offSlLeft			= gs_reveal_double_innerLeft_sL   + thkPlasterAtBoardSlLeft
			offSlRight			= gs_reveal_double_innerRight_sR  + thkPlasterAtBoardSlRight
			offSlLeftBottom		= gs_reveal_double_innerBottom_sL + thkPlasterAtBoardSlLeftBottom
			offSlRightBottom	= gs_reveal_double_innerBottom_sR + thkPlasterAtBoardSlRightBottom
		endif

		gosub 2000
	endif


! =============================================================================
! Plaster Layer Inner Side Cut - Straight Wall
! =============================================================================

	if not(bSlantedInnerSide) & BoardPlasterAtFrame > EPS then
		cutMethod	= 1
		cutStatus	= 2 + 16
		cutVectX	= 0
		cutVectY	= 0
		cutVectZ	= -1
		cutDepth	= WALL_THICKNESS - WIDO_SILL - CustRevealOffsetDepth

		sideRight	= rightWidth + overSizeRight
		sideLeft	= leftWidth  + overSizeLeft
		sideBottom	= overSizeLower - bSillIsHorizontal * bBoardElevUsa
		sideTop		= B + overSizeUpper

		offLeft		= thkPlasterAtBoardLeft
		offRight	= thkPlasterAtBoardRight
		offTop		= thkPlasterAtBoardTop	  + (thkPlasterAtBoardTop	 < EPS) * (CustRevealTopJamb  + offsetInsideTop)
		offBottom	= thkPlasterAtBoardBottom + (thkPlasterAtBoardBottom < EPS) * (CustRevealBottJamb + offsetInsideBott)

		if iWindowShape = SHAPE_ELLIPSEARCH then
			smallRadiusEllips_offset	= smallRadiusEllips - offLeft
			middleRadiusEllips_offset	= middleRadiusEllips - offLeft
		endif

		if bTShapedOpening then
			offSlLeft			= thkPlasterAtBoardSlLeft
			offSlRight			= thkPlasterAtBoardSlRight
			offSlLeftBottom		= thkPlasterAtBoardSlLeftBottom  + (thkPlasterAtBoardSlLeftBottom  < EPS) * (CustRevealBottJamb + offsetInsideBott)
			offSlRightBottom	= thkPlasterAtBoardSlRightBottom + (thkPlasterAtBoardSlRightBottom < EPS) * (CustRevealBottJamb + offsetInsideBott)
		endif

		gosub 2000
	endif


! =============================================================================
! Slanted Inner Side Cut - Straight Wall
! =============================================================================

	if bSlantedInnerSide then
		if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then
			gs_slanted_left_angle		= gs_reveal_left_angle
			gs_slanted_right_angle		= gs_reveal_right_angle
			gs_slanted_bottom_angle		= gs_reveal_bottom_angle
			gs_slanted_top_angle		= gs_reveal_top_angle
			thkPlasterAtSlantedLeft		= thkPlasterAtBoardLeft
			thkPlasterAtSlantedRight	= thkPlasterAtBoardRight
			thkPlasterAtSlantedBottom	= thkPlasterAtBoardBottom
			thkPlasterAtSlantedTop		= thkPlasterAtBoardTop
			thkPlasterAtSlanted			= thkPlasterAtBoard
			HalfInfiniteCut				= 1
			slantedDepth		= (WALL_THICKNESS - WIDO_SILL - offsetInsideDepth - not(iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) * thkPlasterAtBoard)
			slantedDepthBottom	= slantedDepth
			slantedCutDepth		= slantedDepth
			offsetDepth		= offsetInsideDepth
			offsetRight		= offsetInsideRight
			offsetLeft		= offsetInsideLeft
			offsetTop		= offsetInsideTop
			offsetBott		= offsetInsideBott + bSillIsHorizontal * bBoardElevUsa
			bWallInsetCut	= 1

			gosub 1000	! Slanted Reveal cutting body
		endif
	endif


! =============================================================================
! Slanted Outer Side Cut - Straight Wall
! =============================================================================

	if bSlantedOuterSide then
		if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then

			gs_slanted_left_angle		= gs_reveal_outerLeft_angle
			gs_slanted_right_angle		= gs_reveal_outerRight_angle
			gs_slanted_bottom_angle		= gs_reveal_outerBottom_angle
			gs_slanted_top_angle		= gs_reveal_outerTop_angle
			thkPlasterAtSlantedLeft		= thkPlasterAtSillLeft
			thkPlasterAtSlantedRight	= thkPlasterAtSillRight
			thkPlasterAtSlantedBottom	= thkPlasterAtSillBottom
			thkPlasterAtSlantedTop		= thkPlasterAtSillTop
			thkPlasterAtSlanted			= 0
			HalfInfiniteCut				= 1
			slantedDepth		= WIDO_SILL - gs_reveal_outer_jamb_depth
			slantedDepthBottom	= WIDO_SILL - bHaveMountingFrame * (gs_mountingFrame_depth)
			slantedCutDepth		= slantedDepth
			offsetDepth		= offsetOutsideDepth
			offsetRight		= gs_reveal_right
			offsetLeft		= gs_reveal_left
			offsetTop		= gs_reveal_top
			offsetBott		= gs_reveal_bottom - (not(bHaveMountingFrame) * gs_reveal_outer_jamb_depth + bHaveMountingFrame * (gs_reveal_outer_jamb_depth - gs_mountingFrame_depth)) * tan(gs_reveal_outerBottom_angle)
			bWallInsetCut	= 0

			mulz -1
			addz WALL_THICKNESS
			gosub 1000	! Slanted Reveal cutting body
			del 2
		endif
	endif


! =============================================================================
! Middle cut at window range - Straight Wall
! =============================================================================

	if WIDO_FRAME_THICKNESS > EPS & bNeedMiddleCut then

		cutMethod	= 1
		cutStatus	= 2
		cutVectX	= 0
		cutVectY	= 0
		cutVectZ	= 1
		cutDepth	= WIDO_FRAME_THICKNESS

		sideRight	= rightWidth + overSizeRight
		sideLeft	= leftWidth  + overSizeLeft
		sideBottom	= overSizeLower
		sideTop		= B + overSizeUpper

		offLeft		= 0
		offRight	= 0
		offTop		= 0
		offBottom	= 0

		if iWindowShape = SHAPE_ELLIPSEARCH then
			smallRadiusEllips_offset	= smallRadiusEllips
			middleRadiusEllips_offset	= middleRadiusEllips
		endif

		if iWindowShape = SHAPE_GOTHICARCH then
			centArcoffs		= 0
		endif

		if iWindowShape = SHAPE_OGEECENTERED then
			centArcoffs		= sideTop
		endif

		if iWindowShape = SHAPE_SARACENIC then
			tangArcx		= FrametangArcx
			tangArcy		= FrametangArcy
			centArcoffs		= sideTop
		endif

		if iWindowShape = SHAPE_HORSESHOE then
			LowArcoffsy		= FrameLowArcoffsy
			LowArcoffsx		= FrameLowArcoffsx
			HighArcoffs		= FrameHighArcoffs
		endif

		if iWindowShape = SHAPE_HALFARCH then
			Topx	= FrameTopx
			Topy	= FrameTopy
			Shouldx	= FrameShouldx
			Shouldy	= FrameShouldy
		endif

		if bTShapedOpening then
			offSlLeft			= 0
			offSlRight			= 0
			offSlLeftBottom		= 0
			offSlRightBottom	= 0
		endif

		addz WIDO_SILL - WALL_THICKNESS

		if iRevealType = REVEAL_SLANTED then
			gs_slanted_left_angle		= gs_reveal_left_angle
			gs_slanted_right_angle		= gs_reveal_right_angle
			gs_slanted_bottom_angle		= gs_reveal_bottom_angle
			gs_slanted_top_angle		= gs_reveal_top_angle
			thkPlasterAtSlantedLeft		= 0
			thkPlasterAtSlantedRight	= 0
			thkPlasterAtSlantedBottom	= 0
			thkPlasterAtSlantedTop		= 0
			thkPlasterAtSlanted			= 0
			HalfInfiniteCut				= 0
			slantedDepth		= WIDO_FRAME_THICKNESS
			slantedDepthBottom	= slantedDepth
			slantedCutDepth		= slantedDepth
			offsetDepth		= offsetInsideDepth
			offsetRight		= offsetInsideRight
			offsetLeft		= offsetInsideLeft
			offsetTop		= offsetInsideTop
			offsetBott		= offsetInsideBott
			bWallInsetCut	= 0

			addz WIDO_FRAME_THICKNESS
			gosub 1000
			del 1
		else
			gosub 2000
		endif
		del 1

	endif

	if WIDO_FRAME_THICKNESS > EPS & abs(bBoardElevUsa) > EPS then
		addz WIDO_SILL - WALL_THICKNESS
		if	iWindowShape = SHAPE_RECTANGULAR | \
			iWindowShape = SHAPE_ELLIPSEARCH |\
			iWindowShape = SHAPE_HALFCIRCLE |\
			iWindowShape = SHAPE_PENTAGON |\
			iWindowShape = SHAPE_QUARTERROUND |\
			iWindowShape = SHAPE_TRAPEZOID |\
			iWindowShape = SHAPE_ARCHED then

			wallniche 4, 1, 2,
				0,0,1,	WIDO_FRAME_THICKNESS,
				 rightWidth + overSizeRight,	-overSizeLower + bBoardElevUsa,	31,
				 rightWidth + overSizeRight,	-overSizeLower,					31,
				-leftWidth  - overSizeLeft,		-overSizeLower,					31,
				-leftWidth  - overSizeLeft,		-overSizeLower + bBoardElevUsa,	31
		endif
		del 1
	endif

	del 2 + WIDO_REVEAL_SIDE * 2


! =============================================================================
! Cut Wall Inset - Straight Wall
! =============================================================================

	if bParapetWallInset & SYMB_POS_Y > overSizeLower & not(isParIns) & parapet_height > EPS & (SYMB_POS_Y - act_st_pos) > EPS then
		if not(curvedWall) then

			if WIDO_REVEAL_SIDE then
				addz WIDO_SILL - WALL_THICKNESS + WIDO_FRAME_THICKNESS    ! Flip
			else
				addz -WIDO_SILL
			endif
			if WIDO_REVEAL_SIDE then
				mulz -1
				addz -WALL_THICKNESS
			endif
			addz WALL_THICKNESS

			rotx 90
			addz SYMB_POS_Y - act_st_pos

			dx = parapetWallInsetDepth * sin(WALL_INCL)
			dy = parapetWallInsetDepth * cos(WALL_INCL)

			if gs_parapet_autodim then
				revSlantYRight	= revSlantYRight + gs_parapet_autodim * thkPlasterAtBoardRight * incV
				revSlantYLeft	= revSlantYLeft  - gs_parapet_autodim * thkPlasterAtBoardLeft  * incV
				wallniche 4, 1, 2,
					0,0,-1,	parapet_height + gs_parapet_autodim * thkPlasterAtBoardBottom,
					 rightWidth + overSizeRight + revYR - gs_parapet_autodim * thkPlasterAtBoardRight + parapetExtendRight * cos(WALL_INCL) + revSlantXRight,	-py1p - revSlantYRight,	31,
					 rightWidth + overSizeRight + revYR - gs_parapet_autodim * thkPlasterAtBoardRight + parapetExtendRight * cos(WALL_INCL),					-py1p + 1.0,			31,
					-leftWidth  - overSizeLeft  - revYL + gs_parapet_autodim * thkPlasterAtBoardLeft  - parapetExtendLeft  * cos(WALL_INCL),					-py2p + 1.0,			31,
					-leftWidth  - overSizeLeft  - revYL + gs_parapet_autodim * thkPlasterAtBoardLeft  - parapetExtendLeft  * cos(WALL_INCL) + revSlantXLeft,	-py2p - revSlantYLeft,	31
			else
				wallniche 4, 1, 2,
					0,0,-1,	parapet_height + gs_parapet_autodim * thkPlasterAtBoardBottom,
					 rightWidth + overSizeRight + revYR - gs_parapet_autodim * thkPlasterAtBoardRight + parapetExtendRight * cos(WALL_INCL) + dx*incFactor,	-py1p - dy,		31,
					 rightWidth + overSizeRight + revYR - gs_parapet_autodim * thkPlasterAtBoardRight + parapetExtendRight * cos(WALL_INCL),					-py1p + 1.0,	31,
					-leftWidth  - overSizeLeft  - revYL + gs_parapet_autodim * thkPlasterAtBoardLeft  - parapetExtendLeft  * cos(WALL_INCL),					-py2p + 1.0,	31,
					-leftWidth  - overSizeLeft  - revYL + gs_parapet_autodim * thkPlasterAtBoardLeft  - parapetExtendLeft  * cos(WALL_INCL) + dx*incFactor,	-py2p - dy,		31
			endif

			del 2
			del 2 + WIDO_REVEAL_SIDE * 2

		else			! if bParalellInCurvedWalls, curved walls

			if parapet_height > EPS & (SYMB_POS_Y - act_st_pos) > EPS then
				if wallIsLeft then

					dy = WOD - radBoard - parapetWallInsetDepth

					angd = asn( (parapet_width/2) / radBoard )
					dx2 = (radBoard + parapetWallInsetDepth) * tan(angd)

					dyrad = radBoard - sqr(radBoard^2 - (parapet_width/2)^2)
					dy2 = dyrad + parapetWallInsetDepth

					vyLeftIn =  dy
					vyRightIn =  dy

					vxLeft =  -parapet_width/2
					vyLeft =  dy + dy2
					vxRight =  parapet_width/2
					vyRight =  dy + dy2

					rotx 90
					addz SYMB_POS_Y - act_st_pos - parapet_height

					wallniche 6, 1, 2,
						0,0, 1,	parapet_height,
						 vxRight, vyRightIn,	31,
						 vxRight, vyLeft,	31,
						 vxRight, 1,	31,
						 vxLeft, 1,	31,
						 vxLeft, vyRight,	31,
						 vxLeft, vyLeftIn,	31

					del 2
				else

					angd = atn( (parapet_width/2) / radBoard )
					dy = radBoard + WOD

					vyLeftIn =  dy - parapetWallInsetDepth * cos(angd)
					vyRightIn =  dy - parapetWallInsetDepth * cos(angd)

					vxLeft = -parapet_width/2
					vyLeft =  dy
					vxRight =  parapet_width/2
					vyRight =  dy

					rotx 90
					addz SYMB_POS_Y - act_st_pos - parapet_height

					wallniche 6, 1, 2,
						0,0, 1,	parapet_height,
						 vxRight, vyRightIn,	31,
						 vxRight, vyLeft,	31,
						 vxRight, 1,	31,
						 vxLeft, 1,	31,
						 vxLeft, vyRight,	31,
						 vxLeft,	vyLeftIn,	31

					del 2
				endif
			endif
		endif
	endif
endif


! =============================================================================
! Curved Wall
! =============================================================================

if curvedWall & not(bParalellInCurvedWalls) then

	isParIns = 0

	bReveal = WIDO_REVEAL_ON | WIDO_SILL > EPS | not(gs_IsCurved)
	bUniformSideMats	= (matRevealSide = matOppositeSide)
	bOneCut				= (bUniformSideMats & WIDO_SILL < 0.005 & thkPlasterAtSill < EPS & thkPlasterAtBoard < EPS)	! Cut the hole with only one wallniche

	if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC then
		bOneCut = 0
	endif

	if SYMB_ROTANGLE > EPS then addz WIDO_FRAME_THICKNESS
	if WIDO_REVEAL_SIDE then mulz -1

	if wallIsLeft then

		material matRevealSide

		addz -WIDO_FRAME_THICKNESS

! =============================================================================
! Outer Side Cut - Curved Left Wall
! =============================================================================

		if (WIDO_SILL > EPS | not(gs_IsCurved)) & not(bOneCut) then

			leftJamb	= leftWidth  + WOD * tan(alfaLeftOs - alfaLeftJamb) + gs_left_oversize
			rightJamb	= rightWidth + WOD * tan(alfaRightOs - alfaRightJamb) + gs_right_oversize

			thkPlasterAtSillLeft_distx = thkPlasterAtSillLeft / cos(alfaLeftOs - alfaLeftJamb)
			thkPlasterAtSillRight_distx = thkPlasterAtSillRight / cos(alfaRightOs - alfaRightJamb)

			px1 =  leftWidth  - leftJamb  + overSizeLeft + thkPlasterAtSillLeft_distx - SillPlasterAtFrame * tan(alfaLeftOs - alfaLeftJamb)
			px2 = -rightWidth + rightJamb - overSizeRight - thkPlasterAtSillRight_distx + SillPlasterAtFrame * tan(alfaRightOs - alfaRightJamb)

			! Searching for new plaster offset centerpoint
			x11 = px1
			y11 = WOD + SillPlasterAtFrame
			x12 = thkPlasterAtSillLeft_distx
			y12 = 0

			x21 = px2
			y21 = WOD + SillPlasterAtFrame
			x22 = -thkPlasterAtSillRight_distx
			y22 = 0

			gosub 100			! Line - Line intersection

			_bCustomMatNicheTop			= bCustomMatNicheTop
			_wallNicheSurfaceLeft		= matRevealSide
			_wallNicheSurfaceRight		= matRevealSide
			_wallNicheSurfaceBottom		= matRevealSide
			_wallNicheSurfaceTop		= matNicheTop

			cutMethod	= 3
			if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then
				cutStatus	= 2 + 16 + 256 * _bCustomMatNicheTop
			else
				cutStatus	= 2 + 16
			endif
			cutVectX	= cx
			cutVectY	= 0
			cutVectZ	= WOD - cy + SillPlasterAtFrame
			cutDepth	= 0

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower
			sideTop		= B + overSizeUpper

			offLeft		= leftWidth  - WOD * tan(alfaLeftOs  - alfaLeftJamb)  + gs_left_oversize  + thkPlasterAtSillLeft_distx  - SillPlasterAtFrame * tan(alfaLeftOs - alfaLeftJamb)
			offRight	= rightWidth - WOD * tan(alfaRightOs - alfaRightJamb) + gs_right_oversize + thkPlasterAtSillRight_distx - SillPlasterAtFrame * tan(alfaRightOs - alfaRightJamb)
			offTop		= upperJamb + thkPlasterAtSillTop
			offBottom	= lowerJamb + thkPlasterAtSillBottom

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if iWindowShape = SHAPE_GOTHICARCH then
				centArcoffs		= centSillArcoffs
			endif

			if iWindowShape = SHAPE_OGEECENTERED then
				centArcoffs		= centSillArcoffs
			endif

			if iWindowShape = SHAPE_SARACENIC then
				tangArcx		= SilltangArcx
				tangArcy		= SilltangArcy
				centArcoffs		= centSillArcoffs
			endif

			if iWindowShape = SHAPE_HORSESHOE then
				LowArcoffsy		= SillLowArcoffsy
				LowArcoffsx		= SillLowArcoffsx
				HighArcoffs		= SillHighArcoffs
			endif

			if iWindowShape = SHAPE_HALFARCH then
				Topx	= SillTopx
				Topy	= SillTopy
				Shouldx	= SillShouldx
				Shouldy	= SillShouldy
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = 1
			endif

			if bTShapedOpening then
				offSlLeft			= gs_reveal_left_sL   + thkPlasterAtSillSLLeft
				offSlRight			= gs_reveal_right_sR  + thkPlasterAtSillSLRight
				offSlLeftBottom		= gs_reveal_bottom_sL + thkPlasterAtSillSlLeftBottom
				offSlRightBottom	= gs_reveal_bottom_sR + thkPlasterAtSillSlRightBottom
			endif

			addz -SillPlasterAtFrame
			gosub 2000
			del 1
		endif


! =============================================================================
! Plaster Layer Outer Side Cut - Curved Left Wall
! =============================================================================

		if SillPlasterAtFrame > EPS then
			cutMethod	= 1
			cutStatus	= 2 + 16
			cutVectX	= 0
			cutVectY	= 0
			cutVectZ	= 1
			cutDepth	= 0

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower !- bSillIsHorizontal * bBoardElevUsa
			sideTop		= B + overSizeUpper

			offLeft		= thkPlasterAtSillLeft  - (WIDO_FRAME_THICKNESS + (gs_stack_left  | bLeftCornerFunction)  * SillPlasterAtFrame) * tan(alfaLeftOs)
			offRight	= thkPlasterAtSillRight - (WIDO_FRAME_THICKNESS + (gs_stack_right | bRightCornerFunction) * SillPlasterAtFrame) * tan(alfaRightOs)
			offTop		= thkPlasterAtSillTop	  + (thkPlasterAtSillTop    < EPS) * gs_reveal_top
			offBottom	= thkPlasterAtSillBottom  + (thkPlasterAtSillBottom < EPS) * gs_reveal_bottom

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = 1
			endif

			if bTShapedOpening then
				offSlLeft			= thkPlasterAtSillSlLeft
				offSlRight			= thkPlasterAtSillSlRight
				offSlLeftBottom		= thkPlasterAtSillSlLeftBottom  + (thkPlasterAtSillSlLeftBottom	 < EPS) * gs_reveal_bottom
				offSlRightBottom	= thkPlasterAtSillSlRightBottom + (thkPlasterAtSillSlRightBottom < EPS) * gs_reveal_bottom
			endif

			gosub 2000
		endif


! =============================================================================
! Inner Side Cut - Curved Left Wall
! =============================================================================

		material matOppositeSide

		thkPlasterAtBoardLeft_distx	 = thkPlasterAtBoardLeft  / cos(alfaLeftInnJamb)
		thkPlasterAtBoardRight_distx = thkPlasterAtBoardRight / cos(alfaRightInnJamb)

		if not(bSlantedInnerSide) then
			if iRevealType = REVEAL_DOUBLE then
				dxL = 0
				dxR = 0
			else
				dxL = WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
				dxR = WIDO_FRAME_THICKNESS * tan(alfaRightOs)
			endif

			px1 =  rightWidth + overSizeRight - CustRevealRightJamb - thkPlasterAtBoardRight_distx - BoardPlasterAtFrame * tan(alfaRightInnJamb) + dxR
			px2 = -leftWidth  - overSizeLeft  + CustRevealLeftJamb  + thkPlasterAtBoardLeft_distx  + BoardPlasterAtFrame * tan(alfaLeftInnJamb)  - dxL

			! Searching for new plaster offset centerpoint
			x11 = px1
			y11 = tempWOD - BoardPlasterAtFrame + (WIDO_FRAME_THICKNESS * (iRevealType <> REVEAL_DOUBLE))
			x12 = -thkPlasterAtBoardRight_distx
			y12 = 0

			x21 = px2
			y21 = tempWOD - BoardPlasterAtFrame + (WIDO_FRAME_THICKNESS * (iRevealType <> REVEAL_DOUBLE))
			x22 = thkPlasterAtBoardLeft_distx
			y22 = 0

			gosub 100			! Line - Line intersection

			cutZ = WOD - (iRevealType = REVEAL_DOUBLE) * WIDO_FRAME_THICKNESS - cy - BoardPlasterAtFrame

			cutMethod	= 3
			cutStatus	= 2 + (8 + 16) * (not(bReveal) | bOneCut)
			cutVectX	= cx
			cutVectY	= 0
			cutVectZ	= cutZ
			cutDepth	= cutZ

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower - bSillIsHorizontal * bBoardElevUsa
			sideTop		= B + overSizeUpper

			offLeft		= CustRevealLeftJamb  + thkPlasterAtBoardLeft_distx  + BoardPlasterAtFrame * tan(alfaLeftInnJamb)  - dxL
			offRight	= CustRevealRightJamb + thkPlasterAtBoardRight_distx + BoardPlasterAtFrame * tan(alfaRightInnJamb) - dxR
			offTop		= CustRevealTopJamb   + thkPlasterAtBoardTop
			offBottom	= CustRevealBottJamb  + thkPlasterAtBoardBottom

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if iWindowShape = SHAPE_GOTHICARCH then
				centArcoffs		= centBoardArcoffs
			endif

			if iWindowShape = SHAPE_OGEECENTERED then
				centArcoffs		= centBoardArcoffs
			endif

			if iWindowShape = SHAPE_SARACENIC then
				tangArcx		= BoardtangArcx
				tangArcy		= BoardtangArcy
				centArcoffs		= centBoardArcoffs
			endif

			if iWindowShape = SHAPE_HORSESHOE then
				LowArcoffsy		= BoardLowArcoffsy
				LowArcoffsx		= BoardLowArcoffsx
				HighArcoffs		= BoardHighArcoffs
			endif

			if iWindowShape = SHAPE_HALFARCH then
				Topx	= BoardTopx
				Topy	= BoardTopy
				Shouldx	= BoardShouldx
				Shouldy	= BoardShouldy
			endif

			if bTShapedOpening then
				offSlLeft			= gs_reveal_double_innerLeft_sL   + thkPlasterAtBoardSlLeft
				offSlRight			= gs_reveal_double_innerRight_sR  + thkPlasterAtBoardSlRight
				offSlLeftBottom		= gs_reveal_double_innerBottom_sL + thkPlasterAtBoardSlLeftBottom
				offSlRightBottom	= gs_reveal_double_innerBottom_sR + thkPlasterAtBoardSlRightBottom
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = openingHeight / (openingHeight + (2 * WIDO_FRAME_THICKNESS * tan(alfaRightOs)))
			endif

			addz (iRevealType = REVEAL_DOUBLE) * WIDO_FRAME_THICKNESS + BoardPlasterAtFrame
			gosub 2000
			del 1
		endif


! =============================================================================
! Plaster Layer Inner Side Cut - Curved Left Wall
! =============================================================================

		if not(bSlantedInnerSide) & BoardPlasterAtFrame > EPS then
			cutMethod	= 1
			cutStatus	= 2	! Finite cut
			cutVectX	= 0
			cutVectY	= 0
			cutVectZ	= -1
			cutDepth	= -BoardPlasterAtFrame - EPS

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower - bSillIsHorizontal * bBoardElevUsa
			sideTop		= B + overSizeUpper

			offLeft		= thkPlasterAtBoardLeft
			offRight	= thkPlasterAtBoardRight
			offTop		= thkPlasterAtBoardTop	  + (thkPlasterAtBoardTop    < EPS) * (CustRevealTopJamb  + offsetInsideTop)
			offBottom	= thkPlasterAtBoardBottom + (thkPlasterAtBoardBottom < EPS) * (CustRevealBottJamb + offsetInsideBott)

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if bTShapedOpening then
				offSlLeft			= thkPlasterAtBoardSlLeft
				offSlRight			= thkPlasterAtBoardSlRight
				offSlLeftBottom		= thkPlasterAtBoardSlLeftBottom  + (thkPlasterAtBoardSlLeftBottom  < EPS) * (CustRevealBottJamb + offsetInsideBott)
				offSlRightBottom	= thkPlasterAtBoardSlRightBottom + (thkPlasterAtBoardSlRightBottom < EPS) * (CustRevealBottJamb + offsetInsideBott)
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = openingHeight / (openingHeight + (2 * WIDO_FRAME_THICKNESS * tan(alfaRightOs)))
			endif

			addz WIDO_FRAME_THICKNESS
			gosub 2000
			del 1
		endif


! =============================================================================
! Slanted Inner Side Cut - Curved Left Wall
! =============================================================================


		if bSlantedInnerSide then
			addz WALL_THICKNESS - WIDO_SILL

			if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then
				gs_slanted_left_angle		= gs_reveal_left_angle
				gs_slanted_right_angle		= gs_reveal_right_angle
				gs_slanted_bottom_angle		= gs_reveal_bottom_angle
				gs_slanted_top_angle		= gs_reveal_top_angle
				thkPlasterAtSlantedLeft		= thkPlasterAtBoardLeft
				thkPlasterAtSlantedRight	= thkPlasterAtBoardRight
				thkPlasterAtSlantedBottom	= thkPlasterAtBoardBottom
				thkPlasterAtSlantedTop		= thkPlasterAtBoardTop
				thkPlasterAtSlanted			= thkPlasterAtBoard
				HalfInfiniteCut				= 1
				slantedDepth		= (WALL_THICKNESS - WIDO_SILL - offsetInsideDepth - not(iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) * thkPlasterAtBoard)
				slantedDepthBottom	= slantedDepth
				slantedCutDepth		= slantedDepth
				offsetDepth	= offsetInsideDepth
				offsetRight	= offsetInsideRight
				offsetLeft	= offsetInsideLeft
				offsetTop	= offsetInsideTop
				offsetBott	= offsetInsideBott + bSillIsHorizontal * bBoardElevUsa
				bWallInsetCut	= 1

				gosub 1000	! Slanted Reveal cutting body
			endif

			del 1
		endif


! =============================================================================
! Slanted Outer Side Cut - Curved Left Wall
! =============================================================================

		if bSlantedOuterSide then
			if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then

				gs_slanted_left_angle		= gs_reveal_outerLeft_angle	 + alfaLeftOs  - alfaLeftJamb
				gs_slanted_right_angle		= gs_reveal_outerRight_angle + alfaRightOs - alfaRightJamb
				gs_slanted_bottom_angle		= gs_reveal_outerBottom_angle
				gs_slanted_top_angle		= gs_reveal_outerTop_angle
				thkPlasterAtSlantedLeft		= thkPlasterAtSillLeft
				thkPlasterAtSlantedRight	= thkPlasterAtSillRight
				thkPlasterAtSlantedBottom	= thkPlasterAtSillBottom
				thkPlasterAtSlantedTop		= thkPlasterAtSillTop
				thkPlasterAtSlanted			= 0
				HalfInfiniteCut				= 1
				slantedDepth		= WIDO_SILL - gs_reveal_outer_jamb_depth
				slantedDepthBottom	= WIDO_SILL - bHaveMountingFrame * (gs_mountingFrame_depth)
				slantedCutDepth		= slantedDepth
				offsetDepth		= offsetOutsideDepth
				offsetRight		= rightWidth - (abs(WOD) + gs_reveal_outer_jamb_depth) * tan(alfaRightOs - alfaRightJamb)
				offsetLeft		= leftWidth  - (abs(WOD) + gs_reveal_outer_jamb_depth) * tan(alfaLeftOs  - alfaLeftJamb)
				offsetTop		= gs_reveal_top
				offsetBott		= gs_reveal_bottom - (not(bHaveMountingFrame) * gs_reveal_outer_jamb_depth + bHaveMountingFrame * (gs_reveal_outer_jamb_depth - gs_mountingFrame_depth)) * tan(gs_reveal_outerBottom_angle)
				bWallInsetCut	= 0

				mulz -1
				addz WIDO_SILL
				gosub 1000	! Slanted Reveal cutting body
				del 2
			endif
		endif


! =============================================================================
! Middle cut at window range - Curved Left Wall
! =============================================================================

		if WIDO_FRAME_THICKNESS > EPS & bNeedMiddleCut then
			cutMethod	= 3
			cutStatus	= 2
			cutVectX	= 0
			cutVectY	= 0
			cutVectZ	= WOD
			cutDepth	= WIDO_FRAME_THICKNESS

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower
			sideTop		= B + overSizeUpper

			offLeft		= -WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
			offRight	= -WIDO_FRAME_THICKNESS * tan(alfaRightOs)
			offTop		= 0
			offBottom	= 0

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if iWindowShape = SHAPE_HALFARCH then
				Topx	= FrameTopx
				Topy	= FrameTopy
				Shouldx	= FrameShouldx
				Shouldy	= FrameShouldy
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = openingHeight / (openingHeight + (2 * WIDO_FRAME_THICKNESS * tan(alfaRightOs)))
			endif

			if iWindowShape = SHAPE_HORSESHOE then
				LowArcoffsy		= FrameLowArcoffsy
				LowArcoffsx		= FrameLowArcoffsx
				HighArcoffs		= FrameHighArcoffs
			endif

			if bTShapedOpening then
				offSlLeft			= 0
				offSlRight			= 0
				offSlLeftBottom		= 0
				offSlRightBottom	= 0
			endif

			if iRevealType = REVEAL_SLANTED then
				gs_slanted_left_angle		= gs_reveal_left_angle
				gs_slanted_right_angle		= gs_reveal_right_angle
				gs_slanted_bottom_angle		= gs_reveal_bottom_angle
				gs_slanted_top_angle		= gs_reveal_top_angle
				thkPlasterAtSlantedLeft		= 0
				thkPlasterAtSlantedRight	= 0
				thkPlasterAtSlantedBottom	= 0
				thkPlasterAtSlantedTop		= 0
				thkPlasterAtSlanted			= 0
				HalfInfiniteCut				= 0
				slantedDepth		= WIDO_FRAME_THICKNESS
				slantedDepthBottom	= slantedDepth
				slantedCutDepth		= slantedDepth
				offsetDepth		= offsetInsideDepth
				offsetRight		= offsetInsideRight
				offsetLeft		= offsetInsideLeft
				offsetTop		= offsetInsideTop
				offsetBott		= offsetInsideBott
				bWallInsetCut	= 0

				addz WIDO_FRAME_THICKNESS
				gosub 1000	! Slanted Reveal cutting body
				del 1
			else
				gosub 2000
			endif
		endif


! =============================================================================
! Cut Wall Inset - Curved Left Wall
! =============================================================================

		if bParapetWallInset & SYMB_POS_Y > overSizeLower & not(isParIns) & parapet_height > EPS & (SYMB_POS_Y - act_st_pos) > EPS then

			insetY = WOD - signWallIsLeft * radBoard - parapetWallInsetDepth

			if gs_parapet_autodim & thkPlasterAtBoardLeft > EPS then
				x1 = cx - opInner / 2 - parapetExtendLeft
				y1 = WOD - signWallIsLeft * sqr(radBoard^2 - x1^2) - thkPlasterAtBoardLeft * sin(alfaLeftInnJamb)
				x1 = x1 + thkPlasterAtBoardLeft * cos(alfaLeftInnJamb)
				x2 = x1 - thkPlasterAtBoardLeft * sin(alfaLeftInnJamb)
				y2 = y1 - thkPlasterAtBoardLeft * cos(alfaLeftInnJamb)
				xo = 0
				yo = WOD
				ro = radBoard

				gosub 101	! Circle - Line intersection

				if ya > yb then
					pxL1 = xa
					pyL1 = ya
				else
					pxL1 = xb
					pyL1 = yb
				endif

				alpha = alfaLeftInnJamb
			else
				pxL1 = cx - opInner / 2 - parapetExtendLeft
				pyL1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxL1^2)

				alpha = abs(asn(pxL1 / radBoard))
			endif
			pxL2 = pxL1 - signWallIsLeft * tan(alpha) * abs(pyL1 - insetY)
			pyL2 = insetY

			if gs_parapet_autodim & thkPlasterAtBoardRight > EPS then
				x1 = cx + opInner / 2 + parapetExtendRight
				y1 = WOD - signWallIsLeft * sqr(radBoard^2 - x1^2) - thkPlasterAtBoardRight * sin(alfaRightInnJamb)
				x1 = x1 - thkPlasterAtBoardRight * cos(alfaRightInnJamb)
				x2 = x1 + thkPlasterAtBoardRight * sin(alfaRightInnJamb)
				y2 = y1 - thkPlasterAtBoardRight * cos(alfaRightInnJamb)
				xo = 0
				yo = WOD
				ro = radBoard

				gosub 101	! Circle - Line intersection

				if ya > yb then
					pxR1 = xa
					pyR1 = ya
				else
					pxR1 = xb
					pyR1 = yb
				endif

				alpha = alfaRightInnJamb
			else
				pxR1 = cx + opInner / 2 + parapetExtendRight
				pyR1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxR1^2)

				alpha = abs(asn(pxR1 / radBoard))
			endif
			pxR2 = pxR1 + signWallIsLeft * tan(alpha) * abs(pyR1 - insetY)
			pyR2 = insetY

			rotx 90
			addz SYMB_POS_Y - act_st_pos - parapet_height - thkPlasterAtBoardBottom * gs_parapet_autodim

			wallniche 6, 1, 2,
				0,0, 1,	parapet_height + thkPlasterAtBoardBottom * gs_parapet_autodim,
				 pxR2, pyR2,	31,
				 pxR1, pyR1,	31,
				 pxR1, 1,		31,
				 pxL1, 1,		31,
				 pxL1, pyL1,	31,
				 pxL2, pyL2,	31
			del 2
		endif

		del 1
	endif

	if not(wallIsLeft) then

		material matRevealSide

! =============================================================================
! Outer Side Cut - Curved NonLeft Wall
! =============================================================================

		if (WIDO_SILL > EPS | not(gs_IsCurved)) & not(bOneCut) then

			leftJamb	= leftWidth  + WOD * tan(alfaLeftOs  - alfaLeftJamb)  + gs_left_oversize
			rightJamb	= rightWidth + WOD * tan(alfaRightOs - alfaRightJamb) + gs_right_oversize

			if gs_stack_left	then leftJamb	= 0
			if gs_stack_right	then rightJamb	= 0

			thkPlasterAtSillLeft_distx	= thkPlasterAtSillLeft  / cos(alfaLeftOs  - alfaLeftJamb)
			thkPlasterAtSillRight_distx	= thkPlasterAtSillRight / cos(alfaRightOs - alfaRightJamb)

			px1 =  leftWidth  - leftJamb  + overSizeLeft  + thkPlasterAtSillLeft_distx  - SillPlasterAtFrame * tan(alfaLeftOs  - alfaLeftJamb)
			px2 = -rightWidth + rightJamb - overSizeRight - thkPlasterAtSillRight_distx + SillPlasterAtFrame * tan(alfaRightOs - alfaRightJamb)

			! Searching for new plaster offset centerpoint
			x11 = px1
			y11 = WOD + SillPlasterAtFrame
			x12 = thkPlasterAtSillLeft_distx
			y12 = 0

			x21 = px2
			y21 = WOD + SillPlasterAtFrame
			x22 = -thkPlasterAtSillRight_distx
			y22 = 0

			gosub 100			! Line - Line intersection

			cutMethod	= 3

			_bCustomMatNicheTop			= bCustomMatNicheTop
			_wallNicheSurfaceLeft		= matRevealSide
			_wallNicheSurfaceRight		= matRevealSide
			_wallNicheSurfaceBottom		= matRevealSide
			_wallNicheSurfaceTop		= matNicheTop

			if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then
				cutStatus	= 2 + 256 * _bCustomMatNicheTop
			else
				cutStatus	= 2
			endif

			cutVectX	= cx
			cutVectY	= 0
			cutVectZ	= WOD + cy + SillPlasterAtFrame
			cutDepth	= abs(WOD)

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower
			sideTop		= B + overSizeUpper

			offLeft		= leftWidth  - abs(WOD) * tan(alfaLeftOs  - alfaLeftJamb)  + gs_left_oversize  + thkPlasterAtSillLeft_distx  + SillPlasterAtFrame * tan(alfaLeftOs  - alfaLeftJamb)
			offRight	= rightWidth - abs(WOD) * tan(alfaRightOs - alfaRightJamb) + gs_right_oversize + thkPlasterAtSillRight_distx + SillPlasterAtFrame * tan(alfaRightOs - alfaRightJamb)
			offTop		= upperJamb + thkPlasterAtSillTop
			offBottom	= lowerJamb + thkPlasterAtSillBottom

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if iWindowShape = SHAPE_GOTHICARCH then
				centArcoffs		= centSillArcoffs
			endif

			if iWindowShape = SHAPE_OGEECENTERED then
				centArcoffs		= centSillArcoffs
			endif

			if iWindowShape = SHAPE_SARACENIC then
				tangArcx		= SilltangArcx
				tangArcy		= SilltangArcy
				centArcoffs		= centSillArcoffs
			endif

			if iWindowShape = SHAPE_HORSESHOE then
				LowArcoffsy		= SillLowArcoffsy
				LowArcoffsx		= SillLowArcoffsx
				HighArcoffs		= SillHighArcoffs
			endif

			if iWindowShape = SHAPE_HALFARCH then
				Topx	= SillTopx
				Topy	= SillTopy
				Shouldx	= SillShouldx
				Shouldy	= SillShouldy
			endif

			if bTShapedOpening then
				offSlLeft			= gs_reveal_left_sL   + thkPlasterAtSillSLLeft
				offSlRight			= gs_reveal_right_sR  + thkPlasterAtSillSLRight
				offSlLeftBottom		= gs_reveal_bottom_sL + thkPlasterAtSillSlLeftBottom
				offSlRightBottom	= gs_reveal_bottom_sR + thkPlasterAtSillSlRightBottom
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = 1
			endif

			addz -SillPlasterAtFrame
			gosub 2000
			del 1
		endif


! =============================================================================
! Plaster Layer Outer Side Cut - Curved NonLeft Wall
! =============================================================================

		if SillPlasterAtFrame > EPS then
			cutMethod	= 1
			cutStatus	= 2	! Finite cut
			cutVectX	= 0
			cutVectY	= 0
			cutVectZ	= -1
			cutDepth	= SillPlasterAtFrame

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower						 !- bSillIsHorizontal * bBoardElevUsa
			sideTop		= B + overSizeUpper

			offLeft		= thkPlasterAtSillLeft  - ((gs_stack_left  | bLeftCornerFunction)  * SillPlasterAtFrame) * tan(alfaLeftOs)
			offRight	= thkPlasterAtSillRight - ((gs_stack_right | bRightCornerFunction) * SillPlasterAtFrame) * tan(alfaRightOs)
			offTop		= thkPlasterAtSillTop	  + (thkPlasterAtSillTop    < EPS) * gs_reveal_top
			offBottom	= thkPlasterAtSillBottom  + (thkPlasterAtSillBottom < EPS) * gs_reveal_bottom

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if bTShapedOpening then
				offSlLeft			= thkPlasterAtSillSlLeft
				offSlRight			= thkPlasterAtSillSlRight
				offSlLeftBottom		= thkPlasterAtSillSlLeftBottom  + (thkPlasterAtSillSlLeftBottom  < EPS) * gs_reveal_bottom
				offSlRightBottom	= thkPlasterAtSillSlRightBottom + (thkPlasterAtSillSlRightBottom < EPS) * gs_reveal_bottom
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = 1
			endif

			gosub 2000
		endif


! =============================================================================
! Inner Side Cut - Curved NonLeft Wall
! =============================================================================

		material matOppositeSide

		if not(bSlantedInnerSide) then
			thkPlasterAtBoardLeft_distx	 = thkPlasterAtBoardLeft  / cos(alfaLeftInnJamb)
			thkPlasterAtBoardRight_distx = thkPlasterAtBoardRight / cos(alfaRightInnJamb)

			if iRevealType = REVEAL_DOUBLE then
				dxL = WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
				dxR = WIDO_FRAME_THICKNESS * tan(alfaRightOs)
			else
				dxL = 0
				dxR = 0
			endif

			px1 =  rightWidth + overSizeRight - CustRevealRightJamb - thkPlasterAtBoardRight_distx - BoardPlasterAtFrame * tan(alfaRightInnJamb) + dxR
			px2 = -leftWidth  - overSizeLeft  + CustRevealLeftJamb  + thkPlasterAtBoardLeft_distx  + BoardPlasterAtFrame * tan(alfaLeftInnJamb)  - dxL

			! Searching for new plaster offset centerpoint
			x11 = px1
			y11 = tempWOD + BoardPlasterAtFrame + (WIDO_FRAME_THICKNESS * (iRevealType = REVEAL_DOUBLE))
			x12 = -thkPlasterAtBoardRight_distx
			y12 = 0

			x21 = px2
			y21 = tempWOD + BoardPlasterAtFrame + (WIDO_FRAME_THICKNESS * (iRevealType = REVEAL_DOUBLE))
			x22 = thkPlasterAtBoardLeft_distx
			y22 = 0

			gosub 100			! Line - Line intersection

			cutZ = WOD - (iRevealType = REVEAL_DOUBLE) * WIDO_FRAME_THICKNESS + cy - BoardPlasterAtFrame

			cutMethod	= 3
			cutStatus	= 2 + 8 * (not(bReveal) | bOneCut) + 16
			cutVectX	= cx
			cutVectY	= 0
			cutVectZ	= cutZ
			cutDepth	= 0

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower - bSillIsHorizontal * bBoardElevUsa
			sideTop		= B + overSizeUpper

			offLeft		= CustRevealLeftJamb  + thkPlasterAtBoardLeft_distx  - BoardPlasterAtFrame * tan(alfaLeftInnJamb)  - dxL
			offRight	= CustRevealRightJamb + thkPlasterAtBoardRight_distx - BoardPlasterAtFrame * tan(alfaRightInnJamb) - dxR
			offTop		= CustRevealTopJamb   + thkPlasterAtBoardTop
			offBottom	= CustRevealBottJamb  + thkPlasterAtBoardBottom

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if iWindowShape = SHAPE_GOTHICARCH then
				centArcoffs		= centBoardArcoffs
			endif

			if iWindowShape = SHAPE_OGEECENTERED then
				centArcoffs		= centBoardArcoffs
			endif

			if iWindowShape = SHAPE_SARACENIC then
				tangArcx		= BoardtangArcx
				tangArcy		= BoardtangArcy
				centArcoffs		= centBoardArcoffs
			endif

			if iWindowShape = SHAPE_HORSESHOE then
				LowArcoffsy		= BoardLowArcoffsy
				LowArcoffsx		= BoardLowArcoffsx
				HighArcoffs		= BoardHighArcoffs
			endif

			if iWindowShape = SHAPE_HALFARCH then
				Topx	= BoardTopx
				Topy	= BoardTopy
				Shouldx	= BoardShouldx
				Shouldy	= BoardShouldy
			endif

			if bTShapedOpening then
				offSlLeft			= gs_reveal_double_innerLeft_sL   + thkPlasterAtBoardSlLeft
				offSlRight			= gs_reveal_double_innerRight_sR  + thkPlasterAtBoardSlRight
				offSlLeftBottom		= gs_reveal_double_innerBottom_sL + thkPlasterAtBoardSlLeftBottom
				offSlRightBottom	= gs_reveal_double_innerBottom_sR + thkPlasterAtBoardSlRightBottom
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = openingHeight / (openingHeight + (2 * WIDO_FRAME_THICKNESS * tan(alfaRightOs)))
			endif

			addz (iRevealType = REVEAL_DOUBLE) * WIDO_FRAME_THICKNESS + BoardPlasterAtFrame
			gosub 2000
			del 1
		endif


! =============================================================================
! Plaster Layer Inner Side Cut - Curved NonLeft Wall
! =============================================================================

		if not(bSlantedInnerSide) & BoardPlasterAtFrame > EPS then

			if iRevealType = REVEAL_DOUBLE then
				dxL = WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
				dxR = WIDO_FRAME_THICKNESS * tan(alfaRightOs)
			else
				dxL = 0
				dxR = 0
			endif

			cutMethod	= 1
			cutStatus	= 2 + 16
			cutVectX	= 0
			cutVectY	= 0
			cutVectZ	= -1
			cutDepth	= -WIDO_FRAME_THICKNESS

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower - bSillIsHorizontal * bBoardElevUsa
			sideTop		= B + overSizeUpper

			offLeft		= thkPlasterAtBoardLeft  - dxL
			offRight	= thkPlasterAtBoardRight - dxR
			offTop		= thkPlasterAtBoardTop	  + (thkPlasterAtBoardTop    < EPS) * (CustRevealTopJamb  + offsetInsideTop)
			offBottom	= thkPlasterAtBoardBottom + (thkPlasterAtBoardBottom < EPS) * (CustRevealBottJamb + offsetInsideBott)

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if bTShapedOpening then
				offSlLeft			= thkPlasterAtBoardSlLeft
				offSlRight			= thkPlasterAtBoardSlRight
				offSlLeftBottom		= thkPlasterAtBoardSlLeftBottom  + (thkPlasterAtBoardSlLeftBottom  < EPS) * (CustRevealBottJamb + offsetInsideBott)
				offSlRightBottom	= thkPlasterAtBoardSlRightBottom + (thkPlasterAtBoardSlRightBottom < EPS) * (CustRevealBottJamb + offsetInsideBott)
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = openingHeight / (openingHeight + (2 * WIDO_FRAME_THICKNESS * tan(alfaRightOs)))
			endif

			gosub 2000
		endif


! =============================================================================
! Slanted Inner Side Cut - Curved NonLeft Wall
! =============================================================================

		if bSlantedInnerSide then
			addz WALL_THICKNESS - WIDO_SILL

			if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then
				gs_slanted_left_angle		= gs_reveal_left_angle
				gs_slanted_right_angle		= gs_reveal_right_angle
				gs_slanted_bottom_angle		= gs_reveal_bottom_angle
				gs_slanted_top_angle		= gs_reveal_top_angle
				thkPlasterAtSlantedLeft		= thkPlasterAtBoardLeft
				thkPlasterAtSlantedRight	= thkPlasterAtBoardRight
				thkPlasterAtSlantedBottom	= thkPlasterAtBoardBottom
				thkPlasterAtSlantedTop		= thkPlasterAtBoardTop
				thkPlasterAtSlanted			= thkPlasterAtBoard
				HalfInfiniteCut				= 1
				slantedDepth		= (WALL_THICKNESS - WIDO_SILL - offsetInsideDepth - not(iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) * thkPlasterAtBoard)
				slantedDepthBottom	= slantedDepth
				slantedCutDepth		= slantedDepth
				offsetDepth		= offsetInsideDepth
				offsetRight		= offsetInsideRight - (iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC) * WIDO_FRAME_THICKNESS * tan(alfaRightOs)
				offsetLeft		= offsetInsideLeft  - (iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC) * WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
				offsetTop		= offsetInsideTop
				offsetBott		= offsetInsideBott + bSillIsHorizontal * bBoardElevUsa
				bWallInsetCut	= 1

				gosub 1000	! Slanted Reveal cutting body
			endif

			del 1
		endif


! =============================================================================
! Slanted Outer Side Cut - Straight Wall
! =============================================================================

		if bSlantedOuterSide then
			if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then

				gs_slanted_left_angle		= gs_reveal_outerLeft_angle  - (alfaLeftOs  - alfaLeftJamb)
				gs_slanted_right_angle		= gs_reveal_outerRight_angle - (alfaRightOs - alfaRightJamb)
				gs_slanted_bottom_angle		= gs_reveal_outerBottom_angle
				gs_slanted_top_angle		= gs_reveal_outerTop_angle
				thkPlasterAtSlantedLeft		= thkPlasterAtSillLeft
				thkPlasterAtSlantedRight	= thkPlasterAtSillRight
				thkPlasterAtSlantedBottom	= thkPlasterAtSillBottom
				thkPlasterAtSlantedTop		= thkPlasterAtSillTop
				thkPlasterAtSlanted			= 0
				HalfInfiniteCut				= 1
				slantedDepth		= WIDO_SILL - gs_reveal_outer_jamb_depth
				slantedDepthBottom	= WIDO_SILL - bHaveMountingFrame * (gs_mountingFrame_depth)
				slantedCutDepth		= WIDO_SILL
				offsetDepth		= offsetOutsideDepth
				offsetRight		= rightWidth - (abs(WOD) - gs_reveal_outer_jamb_depth) * tan(alfaRightOs - alfaRightJamb)
				offsetLeft		= leftWidth  - (abs(WOD) - gs_reveal_outer_jamb_depth) * tan(alfaLeftOs  - alfaLeftJamb)
				offsetTop		= gs_reveal_top
				offsetBott		= gs_reveal_bottom - (not(bHaveMountingFrame) * gs_reveal_outer_jamb_depth + bHaveMountingFrame * (gs_reveal_outer_jamb_depth - gs_mountingFrame_depth)) * tan(gs_reveal_outerBottom_angle)
				bWallInsetCut	= 0

				mulz -1
				addz WIDO_SILL
				gosub 1000	! Slanted Reveal cutting body
				del 2
			endif
		endif


! =============================================================================
! Middle cut at window range - Curved NonLeft Wall
! =============================================================================

		if WIDO_FRAME_THICKNESS > EPS & bNeedMiddleCut then

			cutMethod	= 3
			cutStatus	= 2
			cutVectX	= 0
			cutVectY	= 0
			cutVectZ	= WOD - (iRevealType = REVEAL_SLANTED) * WIDO_FRAME_THICKNESS
			if iRevealType = REVEAL_SLANTED then
				cutDepth	= WIDO_FRAME_THICKNESS
			else
				cutDepth	= -WIDO_FRAME_THICKNESS
			endif

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower
			sideTop		= B + overSizeUpper

			offLeft		= -WIDO_FRAME_THICKNESS * tan(alfaLeftOs)  * (iRevealType = REVEAL_SLANTED)
			offRight	= -WIDO_FRAME_THICKNESS * tan(alfaRightOs) * (iRevealType = REVEAL_SLANTED)
			offTop		= 0
			offBottom	= 0

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if iWindowShape = SHAPE_HALFARCH then
				Topx	= FrameTopx
				Topy	= FrameTopy
				Shouldx	= FrameShouldx
				Shouldy	= FrameShouldy
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = openingHeight / (openingHeight + (2 * WIDO_FRAME_THICKNESS * tan(alfaRightOs)))
			endif

			if iWindowShape = SHAPE_HORSESHOE then
				LowArcoffsy		= FrameLowArcoffsy
				LowArcoffsx		= FrameLowArcoffsx
				HighArcoffs		= FrameHighArcoffs
			endif

			if bTShapedOpening then
				offSlLeft			= 0
				offSlRight			= 0
				offSlLeftBottom		= 0
				offSlRightBottom	= 0
			endif

			if iRevealType = REVEAL_SLANTED then
				gs_slanted_left_angle		= gs_reveal_left_angle
				gs_slanted_right_angle		= gs_reveal_right_angle
				gs_slanted_bottom_angle		= gs_reveal_bottom_angle
				gs_slanted_top_angle		= gs_reveal_top_angle
				thkPlasterAtSlantedLeft		= 0
				thkPlasterAtSlantedRight	= 0
				thkPlasterAtSlantedBottom	= 0
				thkPlasterAtSlantedTop		= 0
				thkPlasterAtSlanted			= 0
				HalfInfiniteCut				= 0
				slantedDepth		= WIDO_FRAME_THICKNESS
				slantedDepthBottom	= slantedDepth
				slantedCutDepth		= slantedDepth
				offsetDepth		= offsetInsideDepth
				offsetRight		= offsetInsideRight
				offsetLeft		= offsetInsideLeft
				offsetTop		= offsetInsideTop
				offsetBott		= offsetInsideBott
				bWallInsetCut	= 0

				addz WIDO_FRAME_THICKNESS
				gosub 1000	! Slanted Reveal cutting body
				del 1
			else
				gosub 2000
			endif
		endif


! =============================================================================
! Cut Wall Inset - Curved NonLeft Wall
! =============================================================================

		if bParapetWallInset & SYMB_POS_Y > overSizeLower & not(isParIns) & parapet_height > EPS & (SYMB_POS_Y - act_st_pos) > EPS then

			insetY = WOD - signWallIsLeft * radBoard - parapetWallInsetDepth

			if gs_parapet_autodim & thkPlasterAtBoardLeft > EPS then
				x1 = cx - opInner / 2 - parapetExtendLeft
				y1 = WOD - signWallIsLeft * sqr(radBoard^2 - x1^2) + thkPlasterAtBoardLeft * sin(alfaLeftInnJamb)
				x1 = x1 + thkPlasterAtBoardLeft * cos(alfaLeftInnJamb)
				x2 = x1 + thkPlasterAtBoardLeft * sin(alfaLeftInnJamb)
				y2 = y1 - thkPlasterAtBoardLeft * cos(alfaLeftInnJamb)
				xo = 0
				yo = WOD
				ro = radBoard

				gosub 101	! Circle - Line intersection

				if ya > yb then
					pxL1 = xa
					pyL1 = ya
				else
					pxL1 = xb
					pyL1 = yb
				endif

				alpha = alfaLeftInnJamb
			else
				pxL1 = cx - opInner / 2 - parapetExtendLeft
				pyL1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxL1^2)

				alpha = abs(asn(pxL1 / radBoard))
			endif
			pxL2 = pxL1 - signWallIsLeft * tan(alpha) * abs(pyL1 - insetY)
			pyL2 = insetY
			pxL1 = pxL1 - sin(alfaLeftInnJamb)
			pyL1 = pyL1 + cos(alfaLeftInnJamb)

			if gs_parapet_autodim & thkPlasterAtBoardRight > EPS then
				x1 = cx + opInner / 2 + parapetExtendRight
				y1 = WOD - signWallIsLeft * sqr(radBoard^2 - x1^2) + thkPlasterAtBoardRight * sin(alfaRightInnJamb)
				x1 = x1 - thkPlasterAtBoardRight * cos(alfaRightInnJamb)
				x2 = x1 - thkPlasterAtBoardRight * sin(alfaRightInnJamb)
				y2 = y1 - thkPlasterAtBoardRight * cos(alfaRightInnJamb)
				xo = 0
				yo = WOD
				ro = radBoard

				gosub 101	! Circle - Line intersection

				if ya > yb then
					pxR1 = xa
					pyR1 = ya
				else
					pxR1 = xb
					pyR1 = yb
				endif

				alpha = alfaRightInnJamb
			else
				pxR1 = cx + opInner / 2 + parapetExtendRight
				pyR1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxR1^2)

				alpha = abs(asn(pxR1 / radBoard))
			endif
			pxR2 = pxR1 + signWallIsLeft * tan(alpha) * abs(pyR1 - insetY)
			pyR2 = insetY
			pxR1 = pxR1 + sin(alfaRightInnJamb)
			pyR1 = pyR1 + cos(alfaRightInnJamb)

			rotx 90
			addz SYMB_POS_Y - act_st_pos - parapet_height - gs_parapet_autodim * thkPlasterAtBoardRight

			wallniche 6, 1, 2,
				0,0, 1,	parapet_height + gs_parapet_autodim * thkPlasterAtBoardRight,
				 pxR2, pyR2,	31,
				 pxR1, pyR1,	31,
				 pxR1, 1,		31,
				 pxL1, 1,		31,
				 pxL1, pyL1,	31,
				 pxL2, pyL2,	31
			del 2

		endif

	endif

	del (SYMB_ROTANGLE > EPS) + WIDO_REVEAL_SIDE
endif

del 1	! addz -SymbolMid_shiftDy


! ==============================================================================
! Mounting Frame
! ==============================================================================

if bHaveMountingFrame & lod3D_MountingFrame > 0 then
	if iWindowShape = SHAPE_ARCHED then
		gs_stack_left 	= 0
		gs_stack_right 	= 0
		gs_stack_bottom = 0
		gs_stack_top	= 0
	endif

	material gs_mountingFrame_mat
	pen gs_mountingFrame_pen_view
	sect_fill gs_mountingFrame_fill, gs_mountingFrame_pen_bg, gs_mountingFrame_pen_fg, gs_mountingFrame_pen_cont

	pxL1 = -leftWidth - (bLeftCornerFunction | gs_stack_left) * (lx * gs_mountingFrame_depth + 1.0)
	pxL2 = pxL1 + gs_mountingFrame_width_left
	pxR1 = rightWidth + (bRightCornerFunction | gs_stack_right) * (rx * gs_mountingFrame_depth + 1.0)
	pxR2 = pxR1- gs_mountingFrame_width_right

	pyB1 = -overSizeLower - (gs_stack_bottom * 1.0) + (ac_wallhole_height - ac_wallhole_height_original)*(ac_wallhole_height_original > EPS)
	pyB2 = pyB1 + gs_mountingFrame_width_bottom
	pyT1 = openingHeight + overSizeUpper + (gs_stack_top * 1.0)
	pyT2 = pyT1 - gs_mountingFrame_width_top

	if WIDO_REVEAL_SIDE then
		addz WIDO_FRAME_THICKNESS
	else
		mulz -1
	endif

	numCuts = 0

	if bRightCornerFunction then
		add rightRevealPnts[idxSillStartRevealRight][1], 0, -rightRevealPnts[idxSillStartRevealRight][2]
		roty -rightCornerAngle / 2
		cutplane 180
		numCuts = 1
		del 2
	endif

	if bLeftCornerFunction then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, -leftRevealPnts[idxSillStartRevealLeft][2]
		roty leftCornerAngle / 2
		cutplane 180
		numCuts = numCuts + 1
		del 2
	endif

	if gs_stack_left then
		cutpolya 4, 2, 0,
			-leftWidth, pyB1-0.01,	13,
			pxL1-0.01,  pyB1-0.01,	15,
			pxL1-0.01,	pyT1+0.01,	15,
			-leftWidth,	pyT1+0.01,	8
		numCuts = numCuts + 1
	endif

	if gs_stack_right then
		cutpolya 4, 2, 0,
			rightWidth, pyB1-0.01,	13,
			pxR1+0.01,  pyB1-0.01,	15,
			pxR1+0.01,	pyT1+0.01,	15,
			rightWidth,	pyT1+0.01,	8
		numCuts = numCuts + 1
	endif

	if gs_stack_bottom then
		cutpolya 4, 2, 0,
			pxL1-0.01,	-overSizeLower,	8,
			pxR1+0.01,  -overSizeLower,	13,
			pxR1+0.01,	pyB1-0.01,		15,
			pxL1-0.01,	pyB1-0.01,		15
		numCuts = numCuts + 1
	endif

	if gs_stack_top then
		cutpolya 4, 2, 0,
			pxL1-0.01,	openingHeight + overSizeUpper, 8,
			pxR1+0.01,	openingHeight + overSizeUpper, 13,
			pxR1+0.01,	pyT1+0.01,		15,
			pxL1-0.01,	pyT1+0.01,		15
		numCuts = numCuts + 1
	endif

	if iWindowShape = SHAPE_ARCHED then
		hs = openingHeight - archHeight
		rr = (archHeight^2 + (leftWidth)^2) / 2 / archHeight

		! Cut space for mounting frame in the turned plaster layer
		if thkPlasterAtSill > EPS | (curvedWall & not(wallIsLeft)) then
			wallniche 5, 1, 2,
				0,0, 1,	gs_mountingFrame_depth,
				 -leftWidth, 	0,					31,
				 -leftWidth, 	hs, 				31,
				 0, 			openingHeight-rr, 	931,
				 rightWidth,	hs, 				3031,
				 rightWidth,	0,					31
		endif

		archHeight2 = rr-(rr-gs_mountingFrame_width_left) * sin( acs( (leftWidth-gs_mountingFrame_width_left)/(rr-gs_mountingFrame_width_left)))

		if not(gs_stack_bottom) then
			hotspot pxL2, pyB2, 0, 11050
		endif
		if not(gs_stack_bottom) then
			hotspot pxR2, pyB2, 0, 11051
		endif

		hotspot pxL2, pyT1-archHeight2, 0, 11052
		hotspot pxR2, pyT1-archHeight2, 0, 11053
		hotspot 0, pyT2, 0, 11054

		if GLOB_CONTEXT = 4 then
			poly_ 13,
				pxL1,	pyB1, 1,
				pxL1,	pyT1-archHeight, 1,
				0, 	openingHeight-rr, 901,
				pxR1,	pyT1-archHeight, 3001,
				pxR1,	pyB1, 1,
				pxL1,	pyB1, -1,

				pxL2,	pyB2, 1,
				pxL2,	pyT1-archHeight2-EPS, 1,
				pxL2,	pyT1-archHeight2, 1,
				0, 	openingHeight-rr, 901,
				pxR2,	pyT1-archHeight2, 3001,
				pxR2,	pyB2, 1,
				pxL2,	pyB2, -1
		endif
		prism_ 13, gs_mountingFrame_depth,
			 pxL1,	pyB1, 15,
			 pxL1,	pyT1-archHeight, 79,
			 0, 	openingHeight-rr, 915,
			 pxR1,	pyT1-archHeight, 3015,
			 pxR1,	pyB1, 15,
			 pxL1,	pyB1, -1,

			 pxL2,	pyB2, 15,
			 pxL2,	pyT1-archHeight2-EPS, 13,
			 pxL2,	pyT1-archHeight2, 79,
			 0, 	openingHeight-rr, 915,
			 pxR2,	pyT1-archHeight2, 3015,
			 pxR2,	pyB2, 15,
			 pxL2,	pyB2, -1
	else
		! Cut space for mounting frame in the turned plaster layer
		if thkPlasterAtSill > EPS | (curvedWall & not(wallIsLeft)) then
			wallniche 4, 1, 2,
				0,0, 1,	gs_mountingFrame_depth,
				 -leftWidth, -overSizeLower,				 31,
				 -leftWidth,  openingHeight + overSizeUpper, 31,
				 rightWidth,  openingHeight + overSizeUpper, 31,
				 rightWidth, -overSizeLower,				 31
		endif

		if not(gs_stack_left | bLeftCornerFunction | gs_stack_bottom) then
			hotspot pxL2, pyB2, 0, 11050
		endif
		if not(gs_stack_right | bRightCornerFunction | gs_stack_bottom) then
			hotspot pxR2, pyB2, 0, 11051
		endif

		if not(gs_stack_left | bLeftCornerFunction | gs_stack_top) then
			hotspot pxL2, pyT2, 0, 11052
		endif
		if not(gs_stack_right | bRightCornerFunction | gs_stack_top) then
			hotspot pxR2, pyT2, 0, 11053
		endif

		if GLOB_CONTEXT = 4 then
			plane_ 10,
				 pxL1,	pyB1, 0, 1,
				 pxL1,	pyT1, 0, 1,
				 pxR1,	pyT1, 0, 1,
				 pxR1,	pyB1, 0, 1,
				 pxL1,	pyB1, 0, -1,

				 pxL2,	pyB2, 0, 1,
				 pxL2,	pyT2, 0, 1,
				 pxR2,	pyT2, 0, 1,
				 pxR2,	pyB2, 0, 1,
				 pxL2,	pyB2, 0, -1
		endif

		prism_ 10,gs_mountingFrame_depth,
			 pxL1,	pyB1, 15,
			 pxL1,	pyT1, 15,
			 pxR1,	pyT1, 15,
			 pxR1,	pyB1, 15,
			 pxL1,	pyB1, -1,

			 pxL2,	pyB2, 15,
			 pxL2,	pyT2, 15,
			 pxR2,	pyT2, 15,
			 pxR2,	pyB2, 15,
			 pxL2,	pyB2, -1
	endif

	del 1

	for i=1 to numCuts
		cutend
	next i
endif


! ==============================================================================
 end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
! ==============================================================================



1000:
! ==============================================================================
! Slanted Reveal cutting body
! ==============================================================================

! Similar as in MasonryArch macro

	if gs_stack_top		then gs_slanted_top_angle	 = 0
	if gs_stack_bottom	then gs_slanted_bottom_angle = 0

	! 3D turn plaster offsets
	if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED then
		offsetSlantedLeft	= offsetLeft  + not(bLeftCornerFunction  | gs_stack_left)  * (thkPlasterAtSlantedLeft  / cos(gs_slanted_left_angle))
		offsetSlantedRight	= offsetRight + not(bRightCornerFunction | gs_stack_right) * (thkPlasterAtSlantedRight / cos(gs_slanted_right_angle))
		offsetSlantedBott	= offsetBott  + not(gs_stack_bottom) * (thkPlasterAtSlantedBottom / cos(gs_slanted_bottom_angle))
		offsetSlantedTop	= offsetTop   + not(gs_stack_top)    * (thkPlasterAtSlantedTop    / cos(gs_slanted_top_angle))
	else
		offsetSlantedLeft	= offsetLeft  - not(bLeftCornerFunction  | gs_stack_left)  * (thkPlasterAtSlanted * tan(gs_slanted_left_angle)  - thkPlasterAtSlantedLeft  / cos(gs_slanted_left_angle))
		offsetSlantedRight	= offsetRight - not(bRightCornerFunction | gs_stack_right) * (thkPlasterAtSlanted * tan(gs_slanted_right_angle) - thkPlasterAtSlantedRight / cos(gs_slanted_right_angle))
		offsetSlantedBott	= offsetBott  - not(gs_stack_bottom) * (thkPlasterAtSlanted * tan(gs_slanted_bottom_angle) - thkPlasterAtSlantedBottom / cos(gs_slanted_bottom_angle))
		offsetSlantedTop	= offsetTop   - not(gs_stack_top)    * (thkPlasterAtSlanted * tan(gs_slanted_top_angle)    - thkPlasterAtSlantedTop    / cos(gs_slanted_top_angle))
	endif

	if abs(SYMB_POS_Y) < EPS then
		offsetSlantedBott = offsetSlantedBott - EPS
	endif

	dxl = (not(bLeftCornerFunction  | gs_stack_left)  | curvedWall) * slantedDepth * tan(gs_slanted_left_angle)		! --- Left
	dxr = (not(bRightCornerFunction | gs_stack_right) | curvedWall) * slantedDepth * tan(gs_slanted_right_angle)	! --- Right
	dxt = not(gs_stack_top)    * slantedDepth * tan(gs_slanted_top_angle)											! --- Top
	dxb = not(gs_stack_bottom) * slantedDepth * tan(gs_slanted_bottom_angle)										! --- Bottom

	if bLeftCornerFunction	then gs_slanted_left_angle	= 0
	if bRightCornerFunction	then gs_slanted_right_angle	= 0

	if iWindowShape = SHAPE_ARCHED then
		if bHalfCircle then
			arcRComponentY = 0
		else
			arcRComponentY = sqr(arcR^2 - rightWidth^2)
		endif
		if arcR + dxr - offsetSlantedRight > rightWidth + dxl - offsetSlantedRight then
			shm = sqr((arcR + dxr - offsetSlantedRight)^2 - (rightWidth + dxl - offsetSlantedRight)^2) - arcRComponentY
		else
			shm = 0
		endif
	endif

! Plaster Layer Cut ------------------------------------------------------------

	if not(iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) & thkPlasterAtSlanted > EPS then
		if iWindowShape = SHAPE_RECTANGULAR then
			if bLeftCornerFunction  then
				pxL = -leftWidth  - 10
			else
				pxL = -leftWidth  + thkPlasterAtSlantedLeft
			endif
			if bRightCornerFunction  then
				pxR = rightWidth + 10
			else
				pxR = rightWidth - thkPlasterAtSlantedRight
			endif
			wallniche 4, 1, 2 + 16,
				0,0,-slantedDepth-thkPlasterAtSlanted, slantedDepth + thkPlasterAtSlanted,
				pxR,	thkPlasterAtSlantedBottom + (thkPlasterAtSlantedBottom < EPS) * (CustRevealBottJamb + offsetInsideBott),	31,
				pxL,	thkPlasterAtSlantedBottom + (thkPlasterAtSlantedBottom < EPS) * (CustRevealBottJamb + offsetInsideBott),	31,
				pxL,	B - thkPlasterAtSlantedTop,	31,
				pxR,	B - thkPlasterAtSlantedTop,	31
		endif
		if iWindowShape = SHAPE_ARCHED then
			if bHalfCircle then
				wallniche 5, 1, 2 + 16,
					0,0,-slantedDepth-thkPlasterAtSlanted, slantedDepth + thkPlasterAtSlanted,
					 rightWidth - thkPlasterAtSlantedRight,	thkPlasterAtSlantedBottom,	31,
					 rightWidth - thkPlasterAtSlantedRight,	B - archHeight,				95,
					 0,								 		1,							895,
					-leftWidth  + thkPlasterAtSlantedLeft,	B - archHeight,				1095,
					-leftWidth  + thkPlasterAtSlantedLeft,	thkPlasterAtSlantedBottom,	31
			else
				wallniche 5, 1, 2 + 16,
					0,0,-slantedDepth-thkPlasterAtSlanted, slantedDepth + thkPlasterAtSlanted,
					(rightWidth - leftWidth) / 2,			B - arcR,					900,
					 rightWidth - thkPlasterAtSlantedRight,	thkPlasterAtSlantedBottom,	31,
					 rightWidth - thkPlasterAtSlantedRight,	B - archHeight,				95,
					-leftWidth  + thkPlasterAtSlantedLeft,	B - archHeight,				3095,
					-leftWidth  + thkPlasterAtSlantedLeft,	thkPlasterAtSlantedBottom,	31
			endif
		endif
	endif

! Cut type selection -----------------------------------------------------------

	slantedOpeningWidth	 = openingWidth  - offsetSlantedRight - offsetSlantedLeft	! Width at frame
	slantedOpeningHeight = openingHeight - offsetSlantedBott  - offsetSlantedTop	! Height at frame

	slantedOpeningWidthSide	 = slantedOpeningWidth  + dxr + dxl	! Width at wall side
	slantedOpeningHeightSide = slantedOpeningHeight + dxb + dxt	! Height at wall side

	magicRatioH = 0.95
	magicRatioV = 0.95

	wallBodyThkHorizontal = slantedDepth * (tan(gs_slanted_left_angle) + tan(gs_slanted_right_angle)) - slantedOpeningWidth
	wallBodyThkVertical   = slantedDepth * (tan(gs_slanted_top_angle) + tan(gs_slanted_bottom_angle)) - slantedOpeningHeight
	bCutEdgesOnly = ((wallBodyThkHorizontal < EPS & wallBodyThkVertical < EPS) & not(curvedWall))

! Horizontal Cutting Body ------------------------------------------------------

	if gs_slanted_left_angle > EPS | gs_slanted_right_angle > EPS then
		if gs_slanted_left_angle > EPS & gs_slanted_right_angle > EPS then
			m = ((tan(gs_slanted_right_angle) / tan(gs_slanted_left_angle)) * ((rightWidth + leftWidth) + dxr  + dxl - (offsetSlantedRight + offsetSlantedLeft))) / (1 + (tan(gs_slanted_right_angle) / tan(gs_slanted_left_angle)))
		else
			m = (rightWidth + leftWidth)/2 + dxr - offsetSlantedRight
		endif

		rxh = m - (rightWidth + leftWidth)/2 - dxr + offsetSlantedRight
		ryh = 0
		if gs_slanted_right_angle > EPS then
			rzh = -m / tan(gs_slanted_right_angle)
		else
			rzh = -m / tan(gs_slanted_left_angle)
		endif

!!!		dh = -sqr(rxh^2 + rzh^2) * slantedCutDepth / rzh	! for method = 2
		dh = slantedCutDepth								! for method = 3
		method = 3
	else
		rxh = 0
		ryh = 0
		rzh = -slantedDepth
		dh	=  slantedCutDepth

		method = 1
	endif

	if abs(rxh^2 + ryh^2 + rzh^2) > EPS then
		if iWindowShape = SHAPE_RECTANGULAR & not(bCutEdgesOnly) then
			addy B/2
			wallniche 4, method, 2 + HalfInfiniteCut * 16,
				-rxh,ryh,rzh, dh,
				 rightWidth + dxr - offsetSlantedRight,	-B/2 + offsetSlantedBott,	24,
				-leftWidth  - dxl + offsetSlantedLeft,	-B/2 + offsetSlantedBott,	31-2,
				-leftWidth  - dxl + offsetSlantedLeft,	 B/2 - offsetSlantedTop,	24,
				 rightWidth + dxr - offsetSlantedRight,	 B/2 - offsetSlantedTop,	31-2
			del 1
		endif
		if iWindowShape = SHAPE_ARCHED & slantedDepth > EPS then

			if gs_slanted_right_angle > EPS then
				method = 2
				shm2 = sqr((arcR - offsetSlantedRight)^2 - (rightWidth - offsetSlantedRight)^2) - arcRComponentY
				rxh = 0
				rzh = -(rightWidth + dxr - offsetSlantedRight) / tan(gs_slanted_right_angle)
				ryh = (shm - shm2) * (rzh / slantedDepth)

				dh	=  slantedCutDepth * ((sqr(ryh^2 + rzh^2))/abs(rzh))
			else
				method = 1
				rxh = 0
				ryh = 0
				rzh = -1
				dh	=  slantedCutDepth
			endif

			py = max(EPS, (B - archHeight - offsetSlantedBott) + XXshm)
			addy (B - archHeight)+shm
			wallniche 4, method, 2 + HalfInfiniteCut * 16,
				-rxh,ryh,rzh, dh,
				 rightWidth + dxr - offsetSlantedRight,	 -py,		31,
				-leftWidth  - dxl + offsetSlantedLeft,	 -py,		31,
				-leftWidth  - dxl + offsetSlantedLeft,	 0,	31,
				 rightWidth + dxr - offsetSlantedRight,	 0,	31
			del 1
		endif
	endif

! Vertical Cutting Body --------------------------------------------------------

	if gs_slanted_top_angle > EPS | gs_slanted_bottom_angle > EPS then
		if iWindowShape = SHAPE_RECTANGULAR then
			if gs_slanted_bottom_angle > EPS & gs_slanted_top_angle > EPS then
				m = ((tan(gs_slanted_top_angle) / tan(gs_slanted_bottom_angle)) * (B + dxt + dxb - (offsetSlantedTop + offsetSlantedBott))) / (1 + (tan(gs_slanted_top_angle) / tan(gs_slanted_bottom_angle)))
			else
				m = B/2 + dxt - offsetSlantedTop
			endif
			method = 1

			rxv = m - B/2 - dxt + offsetSlantedTop
			ryv = 0
			if gs_slanted_top_angle > EPS then
				rzv = -m / tan(gs_slanted_top_angle)
			else
				rzv = -m / tan(gs_slanted_bottom_angle)
			endif

			dv = -sqr(rxv^2 + rzv^2) * slantedCutDepth / rzv
		endif
		if iWindowShape = SHAPE_ARCHED then
			if gs_slanted_bottom_angle > EPS then m = (B - archHeight + dxb - offsetSlantedBott) / tan(gs_slanted_bottom_angle)

			rxv = (B - archHeight)
			ryv = 0
			rzv = -m
			dv = slantedCutDepth
		endif

		method = 2
	else
		rxv = 0
		ryv = 0
		rzv = -slantedDepth
		dv	=  slantedCutDepth

		method = 1
	endif

	if abs(rxh^2 + ryh^2 + rzh^2) > EPS then
		if iWindowShape = SHAPE_RECTANGULAR then
			addy B/2
			rotz 90
			xL =  leftWidth  - not(bLeftCornerFunction  | gs_stack_left)  * (offsetLeft  + thkPlasterAtSlantedLeft)  + bLeftCornerFunction  * overSizeLeft
			xR = -rightWidth + not(bRightCornerFunction | gs_stack_right) * (offsetRight + thkPlasterAtSlantedRight) - bRightCornerFunction * overSizeRight
			if slantedDepthBottom > slantedDepth & gs_slanted_bottom_angle > EPS then
				wallniche 4, method, 2 + HalfInfiniteCut * 16,
					-rxv,ryv,rzv, dv,
					 B/2+dxt - offsetSlantedTop,	xR,	24,
					 0,								xR,	31-2,
					 0,								xL,	24,
					 B/2+dxt - offsetSlantedTop,	xL,	31-2
				if not(curvedWall) | bParalellInCurvedWalls then
!					add -rxv,ryv,rzv
!					roty atn((B/2 + dxb - offsetSlantedBott - rxv) / rzv) + 180
!					wallniche 4, 1, 2 + HalfInfiniteCut * 16,
!						0,0,1, 0,
!						0,		xR,	31,
!						-0.1,	xR,	31,
!						-0.1,	xL,	31,
!						0,		xL,	31
!					del 2

					add -B/2-dxb + offsetSlantedBott, 0, 0
					wallniche 4, 1, 2 + 16,
						sin(gs_slanted_bottom_angle),0,-cos(gs_slanted_bottom_angle), slantedDepthBottom / cos(gs_slanted_bottom_angle),
						0,		xR,	31,
						gs_reveal_outer_jamb_depth * tan(gs_slanted_bottom_angle),	xR,	31,
						gs_reveal_outer_jamb_depth * tan(gs_slanted_bottom_angle),	xL,	31,
						0,		xL,	31
					del 1

!					wallniche 4, 3, 2 + HalfInfiniteCut * 16,
!						-rxv,ryv,rzv, slantedDepthBottom,
!						 0,								xR,	31,
!						-B/2-dxb + offsetSlantedBott,	xR,	31,
!						-B/2-dxb + offsetSlantedBott,	xL,	31,
!						 0,								xL,	31
				endif
			else
				if not(bCutEdgesOnly) & abs(xR - xL) > EPS  then
					wallniche 4, method, 2 + HalfInfiniteCut * 16,
						-rxv,ryv,rzv, dv,
						 B/2+dxt - offsetSlantedTop,	xR,	24,
						-B/2-dxb + offsetSlantedBott,	xR,	31-2,
						-B/2-dxb + offsetSlantedBott,	xL,	24,
						 B/2+dxt - offsetSlantedTop,	xL,	31-2
				endif
			endif
			del 2
		endif
		if iWindowShape = SHAPE_ARCHED & gs_slanted_bottom_angle > EPS then
			rotz 90
			method = 3
			xL =  leftWidth  - (offsetLeft  + thkPlasterAtSlantedLeft)
			xR = -rightWidth + (offsetRight + thkPlasterAtSlantedRight)
!			wallniche 4, method, 2 + HalfInfiniteCut * 16,
!				 rxv, ryv, rzv, dv,
!				 (B - archHeight),			 xL,		24,
!				 -dxb + offsetSlantedBott,	 xL,		31-2,
!				 -dxb + offsetSlantedBott,	 xR,	24,
!				 (B - archHeight),			 xR,	31-2

			if slantedDepthBottom > slantedDepth & gs_slanted_bottom_angle > EPS then
				add -dxb + offsetSlantedBott, 0, 0
				wallniche 4, 1, 2 + 16,
					sin(gs_slanted_bottom_angle),0,-cos(gs_slanted_bottom_angle), slantedDepthBottom / cos(gs_slanted_bottom_angle),
					0,		xR,	31,
					gs_reveal_outer_jamb_depth * tan(gs_slanted_bottom_angle),	xR,	31,
					gs_reveal_outer_jamb_depth * tan(gs_slanted_bottom_angle),	xL,	31,
					0,		xL,	31
				del 1
			endif
			del 1
		endif
	endif

! Top - Right Corner Cutting Body ----------------------------------------------

	if iWindowShape = SHAPE_RECTANGULAR then
		if abs(gs_slanted_top_angle) > EPS then
			ratioTL = tan(gs_slanted_right_angle) / tan(gs_slanted_top_angle)
			if openingWidth > B * ratioTL then
				rytl = 2 * B / 3
				rxtl = rytl * ratioTL
			else
				rxtl = 2 * openingWidth / 3
				rytl = rxtl / ratioTL
			endif

			if abs(gs_slanted_right_angle) > EPS then
				rztl = rxtl / tan(gs_slanted_right_angle)
			else
				rztl = rytl / tan(gs_slanted_top_angle)
			endif
		else
			if abs(gs_slanted_right_angle) > EPS then
				rxtl = 3 * openingWidth / 4
				rytl = 0
				rztl = rxtl / tan(gs_slanted_right_angle)
			else
				rxtl = 0
				rytl = 0
				rztl = 1
			endif
		endif

		vx = (slantedDepth) * tan(gs_slanted_right_angle)
		vy = (slantedDepth) * tan(gs_slanted_top_angle)
		vz = (slantedCutDepth)
		dtl = sqr(vx*vx + vy*vy + vz*vz)

		ratioV = max(1, dtl / sqr(rxtl^2 + rytl^2 + rztl^2) * 2)
		rxtl = rxtl * ratioV
		rytl = rytl * ratioV
		rztl = rztl * ratioV

		if bCutEdgesOnly then
			add rightWidth + gs_right_oversize - offsetSlantedRight, B + gs_upper_oversize - offsetSlantedTop, -slantedDepth
			if bRightCornerFunction then
				pxR = 10
			else
				pxR = 0
			endif
			wallniche 4, 1, 2 + HalfInfiniteCut * 16,
				-rxtl,-rytl,-rztl, -not(HalfInfiniteCut) * dtl,
				 pxR,					 0,						31,
				-slantedOpeningWidth,	 0,						31,
				-slantedOpeningWidth,	-slantedOpeningHeight,	31,
				 pxR,					-slantedOpeningHeight,	31
			del 1
		else
			add rightWidth + gs_right_oversize + dxr - offsetSlantedRight, B + gs_upper_oversize + dxt - offsetSlantedTop, 0
			wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
				-rxtl,-rytl,-rztl, dtl,
				leftDx,											 0,				31,
				magicRatioH * (-slantedOpeningWidthSide + dxl),	 0,				31,
				magicRatioH * (-slantedOpeningWidthSide + dxl),	magicRatioV * (-slantedOpeningHeightSide + dxb),	31,
				leftDx,											magicRatioV * (-slantedOpeningHeightSide + dxb),	31
			del 1
		endif

! Top - Left Corner Cutting Body -----------------------------------------------

		if abs(gs_slanted_top_angle) > EPS then
			ratioTR = tan(gs_slanted_left_angle) / tan(gs_slanted_top_angle)
			if openingWidth > B * ratioTR then
				rytr = 2 * B / 3
				rxtr = rytr * ratioTR
			else
				rxtr = 2 * openingWidth / 3
				rytr = rxtr / ratioTR
			endif

			if abs(gs_slanted_left_angle) > EPS then
				rztr = rxtr / tan(gs_slanted_left_angle)
			else
				rztr = rytr / tan(gs_slanted_top_angle)
			endif
		else
			if abs(gs_slanted_left_angle) > EPS then
				rxtr = 3 * openingWidth / 4
				rytr = 0
				rztr = rxtr / tan(gs_slanted_left_angle)
			else
				rxtr = 0
				rytr = 0
				rztr = 1
			endif
		endif

		vx = (slantedDepth) * tan(gs_slanted_left_angle)
		vy = (slantedDepth) * tan(gs_slanted_top_angle)
		vz = (slantedCutDepth)
		dtr = sqr(vx*vx + vy*vy + vz*vz)

		ratioV = max(1, dtr / sqr(rxtr^2 + rytr^2 + rztr^2) * 2)
		rxtr = rxtr * ratioV
		rytr = rytr * ratioV
		rztr = rztr * ratioV

		if bCutEdgesOnly then
			add -leftWidth - gs_left_oversize + offsetSlantedLeft, B + gs_upper_oversize - offsetSlantedTop, -slantedDepth
			if bLeftCornerFunction then
				pxL = -10
			else
				pxL = 0
			endif
			wallniche 4, 1, 2 + HalfInfiniteCut * 16,
				rxtr,-rytr,-rztr, -not(HalfInfiniteCut) * dtr,
				pxL,				 0,						31,
				slantedOpeningWidth, 0,						31,
				slantedOpeningWidth, -slantedOpeningHeight,	31,
				pxL,				 -slantedOpeningHeight,	31
			del 1
		else
			add -leftWidth - gs_left_oversize - dxl + offsetSlantedLeft, B + gs_upper_oversize + dxt - offsetSlantedTop, 0
			if bRightCornerFunction then
				wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
					rxtr,-rytr,-rztr, dtr,
					rightDx,			 0,				31,
					openingWidth + 10,	 0,				31,
					openingWidth + 10,	-3*B/4 - dxt,	31,
					rightDx,			-3*B/4 - dxt,	31
			else
				wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
					rxtr,-rytr,-rztr, dtr,
					rightDx,										 0,				31,
					magicRatioH * (slantedOpeningWidthSide - dxr),	 0,				31,
					magicRatioH * (slantedOpeningWidthSide - dxr),	magicRatioV * (-slantedOpeningHeightSide + dxb),	31,
					rightDx,										magicRatioV * (-slantedOpeningHeightSide + dxb),	31
			endif
			del 1
		endif
	endif

	if iWindowShape = SHAPE_ARCHED & slantedDepth > EPS then
		! --- Top Arched Cut ---

		if gs_slanted_right_angle > EPS then
			shm2 = sqr((arcR - offsetSlantedRight)^2 - (rightWidth - offsetSlantedRight)^2) - arcRComponentY
			rxh = 0
			rzh = -(rightWidth + dxr - offsetSlantedRight) / tan(gs_slanted_right_angle)
			ryh = (shm - shm2) * (rzh / slantedDepth)

			dh	=  slantedCutDepth * ((sqr(ryh^2 + rzh^2))/abs(rzh))

			x11 = 0
			y11 = 0
			x12 = rzh
			y12 = ryh
			x21 = 0
			y21 = archHeight - offsetSlantedTop + dxt - shm
			x22 = -cos(gs_slanted_right_angle)
			y22 = -sin(gs_slanted_right_angle) + y21
			gosub 100	! Line - Line intersection

!addy (B - archHeight) + shm
!roty -90
!lin_ x11,y11,0, x12,y12,0
!lin_ x21,y21,0, x22,y22,0
!del 2

			rxh2 = 0
			rzh2 = cx
			ryh2 = cy

			dh	=  slantedCutDepth * ((sqr(ryh2^2 + rzh2^2))/abs(rzh2))
			cutMethod = 2	! Pyramidal
		else
			rxh2 = 0
			ryh2 = 0
			rzh2 = -1

			dh	=  slantedCutDepth
			cutMethod = 1	! Prism shaped
		endif

		addy (B - archHeight) + shm
		wallniche 3, cutMethod, 2 + HalfInfiniteCut * 16,
			rxh2, ryh2, rzh2, dh,
			(-leftWidth - dxr + offsetSlantedLeft),		openingHeight - B,								95,
			0, 											openingHeight - arcR - ((B - archHeight) + shm),995,
			(rightWidth + dxl - offsetSlantedRight),	openingHeight - B,								3095
		del 1
	endif

	if abs(gs_slanted_bottom_angle) < EPS then	! Space for Board
		dxb = dxb + overSizeLower
	endif

! Bottom - Right Corner Cutting Body -------------------------------------------

	if abs(gs_slanted_bottom_angle) > EPS then
		ratioBL = tan(gs_slanted_right_angle) / tan(gs_slanted_bottom_angle)
		if openingWidth > B * ratioBL then
			rybl = 2 * B / 3
			rxbl = rybl * ratioBL
		else
			rxbl = 2 * openingWidth / 3
			rybl = rxbl / ratioBL
		endif

		if abs(gs_slanted_right_angle) > EPS then
			rzbl = rxbl / tan(gs_slanted_right_angle)
		else
			rzbl = rybl / tan(gs_slanted_bottom_angle)
		endif
	else
		if abs(gs_slanted_right_angle) > EPS then
			rxbl = 3 * openingWidth / 4
			rybl = 0
			rzbl = rxbl / tan(gs_slanted_right_angle)
		else
			rxbl = 0
			rybl = 0
			rzbl = 1
		endif
	endif

	vx = (slantedDepth) * tan(gs_slanted_right_angle)
	vy = (slantedDepth) * tan(gs_slanted_bottom_angle)
	vz = (slantedCutDepth)
	dbl = sqr(vx*vx + vy*vy + vz*vz)

	ratioV = max(1, dbl / sqr(rxbl^2 + rybl^2 + rzbl^2) * 2)
	rxbl = rxbl * ratioV
	rybl = rybl * ratioV
	rzbl = rzbl * ratioV

	if bCutEdgesOnly then
		add rightWidth + gs_right_oversize - offsetSlantedRight, -gs_lower_oversize + offsetSlantedBott, -slantedDepth
		if bRightCornerFunction then
			pxR = 10
		else
			pxR = 0
		endif
		py = max(EPS, slantedOpeningHeight - (iWindowShape = SHAPE_ARCHED) * (archHeight - offsetSlantedTop) - not(bWallInsetCut) * gs_reveal_outer_jamb_depth)	! not(bWallInsetCut) -> Outside
		wallniche 4, 1, 2 + HalfInfiniteCut * 16,
			-rxbl, rybl,-rzbl, -not(HalfInfiniteCut) * dbl,
			 pxR,				  0,	31,
			-slantedOpeningWidth, 0,	31,
			-slantedOpeningWidth, py,	31,
			 pxR,				  py,	31
		del 1
	else
		add rightWidth + gs_right_oversize + dxr - offsetSlantedRight, -dxb - gs_lower_oversize + offsetSlantedBott, 0
		wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
				-rxbl, rybl,-rzbl, dbl,
				leftDx,											0,																31,
				magicRatioH * (-slantedOpeningWidthSide + dxl), 0,																31,
				magicRatioH * (-slantedOpeningWidthSide + dxl), magicRatioV * (slantedOpeningHeightSide - dxt) - archHeight,	31,
				leftDx,											magicRatioV * (slantedOpeningHeightSide - dxt) - archHeight,	31
		del 1
	endif

! Wall Inset cutting body for Slanted Reveal - Right Side --------------

	if bWallInsetCut & bParapetWallInset & SYMB_POS_Y > overSizeLower & not(WALL_INCL > EPS) & gs_parapet_autodim & parapet_height > EPS then

		if curvedWall & wallIsLeft then
			dy = WOD - radBoard
		else
			dy = radBoard + WOD
		endif
		dd = (dy - (WALL_THICKNESS - WIDO_SILL)) * curvedWall
		vx = (parapetWallInsetDepth - dd) * tan(gs_slanted_right_angle)
		vy = (parapetWallInsetDepth - dd) * tan(gs_slanted_bottom_angle)
		vz = (parapetWallInsetDepth - dd)
		dbl = sqr(vx*vx + vy*vy + vz*vz)

		if abs(gs_slanted_right_angle) > EPS then
			rxbl = 3 * openingWidth / 4
			rzbl = rxbl / tan(gs_slanted_right_angle)
		else
			rxbl = 0
			rzbl = 1
		endif
		rybl = rzbl * tan(gs_slanted_bottom_angle)

		add rightWidth + gs_right_oversize + dxr - offsetSlantedRight, -dxb - gs_lower_oversize + offsetSlantedBott, 0
		wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
			-rxbl, rybl,-rzbl, dbl,
			 leftDx,					-parapet_height*3/4,	31,
			-3 * openingWidth/4 - dxl,	-parapet_height*3/4,	31,
			-3 * openingWidth/4 - dxl,	 0,						31,
			 leftDx,					 0,						31
		del 1

		db2 = sqr(vx*vx + vz*vz)

		add rightWidth + gs_right_oversize + dxr - offsetSlantedRight, -parapet_height, 0
		wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
			-rxbl, 0,-rzbl, db2,
			 leftDx,					 parapet_height*3/4,	31,
			-3 * openingWidth/4 - dxl,	 parapet_height*3/4,	31,
			-3 * openingWidth/4 - dxl,	 0,						31,
			 leftDx,					 0,						31
		del 1

		isParIns = 1

	endif

! Bottom - Left Corner Cutting Body --------------------------------------------

	if abs(gs_slanted_bottom_angle) > EPS then
		ratioBR = tan(gs_slanted_left_angle) / tan(gs_slanted_bottom_angle)
		if openingWidth > B * ratioBR then
			rybr = 2 * B / 3
			rxbr = rybr * ratioBR
		else
			rxbr = 2 * openingWidth / 3
			rybr = rxbr / ratioBR
		endif

		if abs(gs_slanted_left_angle) > EPS then
			rzbr = rxbr / tan(gs_slanted_left_angle)
		else
			rzbr = rybr / tan(gs_slanted_bottom_angle)
		endif
	else
		if abs(gs_slanted_left_angle) > EPS then
			rxbr = 3 * openingWidth / 4
			rybr = 0
			rzbr = rxbr / tan(gs_slanted_left_angle)
		else
			rxbr = 0
			rybr = 0
			rzbr = 1
		endif
	endif

	vx = (slantedDepth) * tan(gs_slanted_left_angle)
	vy = (slantedDepth) * tan(gs_slanted_bottom_angle)
	vz = (slantedCutDepth)
	dbr = sqr(vx*vx + vy*vy + vz*vz)

	ratioV = max(1, dbr / sqr(rxbr^2 + rybr^2 + rzbr^2) * 2)
	rxbr = rxbr * ratioV
	rybr = rybr * ratioV
	rzbr = rzbr * ratioV

	if bCutEdgesOnly then
		add -leftWidth - gs_left_oversize + offsetSlantedLeft, -gs_lower_oversize + offsetSlantedBott, -slantedDepth
		if bLeftCornerFunction then
			pxL = -10
		else
			pxL = 0
		endif
		py = max(EPS, slantedOpeningHeight - (iWindowShape = SHAPE_ARCHED) * (archHeight - offsetSlantedTop) - not(bWallInsetCut) * gs_reveal_outer_jamb_depth)	! not(bWallInsetCut) -> Outside
		wallniche 4, 1, 2 + HalfInfiniteCut * 16,
			rxbr, rybr,-rzbr, -not(HalfInfiniteCut) * dbr,
			pxL,				 0,		31,
			slantedOpeningWidth, 0,		31,
			slantedOpeningWidth, py,	31,
			pxL,				 py,	31
		del 1
	else
		add -leftWidth - gs_left_oversize - dxl + offsetSlantedLeft, -dxb - gs_lower_oversize + offsetSlantedBott, 0
		if bRightCornerFunction then
			wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
				 rxbr, rybr,-rzbr, dbr,
				 rightDx,			 0,								31,
				 openingWidth + 10,	 0,								31,
				 openingWidth + 10,	 3/4*(B - archHeight) + dxt,	31,
				 rightDx,			 3/4*(B - archHeight) + dxt,	31
		else
			wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
				 rxbr, rybr,-rzbr, dbr,
				 rightDx,										0,																31,
				 magicRatioH * (slantedOpeningWidthSide - dxr), 0,																31,
				 magicRatioH * (slantedOpeningWidthSide - dxr), magicRatioV * (slantedOpeningHeightSide - dxt) - archHeight,	31,
				 rightDx,										magicRatioV * (slantedOpeningHeightSide - dxt) - archHeight,	31
		endif
		del 1
	endif

! Wall Inset cutting body for Slanted Reveal - Left Side ---------------

	if bWallInsetCut & bParapetWallInset & SYMB_POS_Y > overSizeLower & not(WALL_INCL > EPS) & gs_parapet_autodim & parapet_height > EPS then

		if curvedWall & wallIsLeft then
			dy = WOD - radBoard
		else
			dy = radBoard + WOD
		endif
		dd = (dy - (WALL_THICKNESS - WIDO_SILL)) * curvedWall
		vx = (parapetWallInsetDepth - dd) * tan(gs_slanted_left_angle)
		vy = (parapetWallInsetDepth - dd) * tan(gs_slanted_bottom_angle)
		vz = (parapetWallInsetDepth - dd)
		dbl = sqr(vx*vx + vy*vy + vz*vz)

		if abs(gs_slanted_left_angle) > EPS then
			rxbr = 3 * openingWidth / 4
			rzbr = rxbr / tan(gs_slanted_left_angle)
		else
			rxtr = 0
			rztr = 1
		endif
		rybr = rzbr * tan(gs_slanted_bottom_angle)

		add -leftWidth - gs_left_oversize - dxl + offsetSlantedLeft, -dxb - gs_lower_oversize + offsetSlantedBott, 0
		wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
			 rxbr, rybr, -rzbr, dbl,
			 rightDx,					-parapet_height*3/4,	31,
			 3 * openingWidth/4 + dxl,	-parapet_height*3/4,	31,
			 3 * openingWidth/4 + dxl,	 0,						31,
			 rightDx,					 0,						31
		del 1

		db2 = sqr(vx*vx + vz*vz)

		add -leftWidth - gs_left_oversize - dxl + offsetSlantedLeft, -parapet_height, 0
		wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
			 rxbr, 0, -rzbr, db2,
			 rightDx,					 parapet_height*3/4,	31,
			 3 * openingWidth/4 + dxl,	 parapet_height*3/4,	31,
			 3 * openingWidth/4 + dxl,	 0,						31,
			 rightDx,					 0,						31
		del 1

	endif

return


2000:
! ==============================================================================
! Shape cut body with offset
! ------------------------------------------------------------------------------
! Input variables:
! Offsets:
!	offLeft:			offset left
!	offRight:			offset right
!	offTop:				offset top
!	offBottom:			offset bottom
! Cutting body parameters:
!	cutMethod:			method parameters of the wallniche
!	cutStatus:			status parameters of the wallniche
!	cutVectX:			x component of the cutting direction vector
!	cutVectY:			y component of the cutting direction vector
!	cutVectZ:			z component of the cutting direction vector
!	cutDepth:			depth of cut
! Shape geometrty:
!	sideRight:			right side
!	sideLeft:			left side
!	sideBottom:			bottom side
!	sideTop:			top side
!	archHeight:
!	arcR:
!	tan_topAngle:		SHAPE_TRAPEZOID upper side tan(angle)
! ==============================================================================

	if iWindowShape = SHAPE_RECTANGULAR then
		if _bCustomMatNicheTop then
			wallniche 4, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,	-sideBottom + offBottom,	31, _wallNicheSurfaceRight,
				 sideRight - offRight,	 sideTop    - offTop,		31, _wallNicheSurfaceTop,
				-sideLeft  + offLeft,	 sideTop    - offTop,		31, _wallNicheSurfaceLeft,
				-sideLeft  + offLeft,	-sideBottom + offBottom,	31, _wallNicheSurfaceBottom
		else
			wallniche 4, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,	-sideBottom + offBottom,	31,
				 sideRight - offRight,	 sideTop    - offTop,		31,
				-sideLeft  + offLeft,	 sideTop    - offTop,		31,
				-sideLeft  + offLeft,	-sideBottom + offBottom,	31
		endif
	endif

	if iWindowShape = SHAPE_ARCHED then
		if bHalfCircle then
			archDistortion = (archHeight - offTop) / ((sideRight - offRight + sideLeft - offLeft) / 2)

			addy sideTop - archHeight
			muly archDistortion
			if _bCustomMatNicheTop then
				wallniche 6, cutMethod, cutStatus,
					cutVectX,cutVectY,cutVectZ, cutDepth,
					 sideRight - offRight,	(-sideBottom + offBottom - sideTop + archHeight) / archDistortion,	31, _wallNicheSurfaceRight,
					 sideRight - offRight,	 0,		95, _wallNicheSurfaceTop,
					 0,							1,			 				895, _wallNicheSurfaceTop,
					 0,		(archHeight - offTop) / archDistortion,		1095, _wallNicheSurfaceTop,
					-sideLeft  + offLeft,	 0,		1095, _wallNicheSurfaceLeft,
					-sideLeft  + offLeft,	(-sideBottom + offBottom - sideTop + archHeight) / archDistortion,	31, _wallNicheSurfaceBottom
			else
				wallniche 6, cutMethod, cutStatus,
					cutVectX,cutVectY,cutVectZ, cutDepth,
					 sideRight - offRight,	(-sideBottom + offBottom - sideTop + archHeight) / archDistortion,	31,
					 sideRight - offRight,	 0,		95,
					 0,							1,			 				895,
					 0,		(archHeight - offTop) / archDistortion,		1095,
					-sideLeft  + offLeft,	 0,		1095,
					-sideLeft  + offLeft,	(-sideBottom + offBottom - sideTop + archHeight) / archDistortion,	31
			endif
			del 2
		else
			midOffset = (sideRight - offRight - sideLeft + offLeft) / 2
			if arcR - offTop > sideRight - offRight then
				shoulder_offset = sqr((arcR - offTop)^2 - (sideRight - offRight)^2)
			else
				shoulder_offset = 0
			endif

			if _bCustomMatNicheTop then
				wallniche 6, cutMethod, cutStatus,
					cutVectX,cutVectY,cutVectZ, cutDepth,
					 midOffset,				 sideTop - arcR,					900, _wallNicheSurfaceRight,
					 sideRight - offRight,	-sideBottom + offBottom,			31, _wallNicheSurfaceRight,
					 sideRight - offRight,	 sideTop - arcR + shoulder_offset,	95, _wallNicheSurfaceTop,
					0,	 sideTop - offTop,										3095, _wallNicheSurfaceTop,
					-sideLeft  + offLeft,	 sideTop - arcR + shoulder_offset,	1095, _wallNicheSurfaceLeft,
					-sideLeft  + offLeft,	-sideBottom + offBottom,			31, _wallNicheSurfaceBottom
			else
				wallniche 6, cutMethod, cutStatus,
					cutVectX,cutVectY,cutVectZ, cutDepth,
					 midOffset,				 sideTop - arcR,					900,
					 sideRight - offRight,	-sideBottom + offBottom,			31,
					 sideRight - offRight,	 sideTop - arcR + shoulder_offset,	95,
					0,	 sideTop - offTop,										3095,
					-sideLeft  + offLeft,	 sideTop - arcR + shoulder_offset,	1095,
					-sideLeft  + offLeft,	-sideBottom + offBottom,			31
			endif
		endif
	endif

	if iWindowShape = SHAPE_HALFARCH then

		if bRightCornerFunction then
			put -sideLeft + offLeft,-sideBottom + offBottom,			31,
				sideRight,		-sideBottom + offBottom,	31,
				sideRight,		Topy,	31,
				Topx,						Topy,						95,

				sideRight - overSizeRight, 		sideTop - Arcr,		900,
				Shouldx,		Shouldy,			3031 + bFullArc * 64
		else
			put -sideLeft + offLeft,-sideBottom + offBottom,			31,
				sideRight - offRight,		-sideBottom + offBottom,	31,
				Topx,						 Topy,						95,

				sideRight,		sideTop - Arcr,		900,
				Shouldx,		Shouldy,			3031 + bFullArc * 64
		endif

		wallniche nsp/3, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			get(nsp)
	endif

	if iWindowShape = SHAPE_ELLIPSEARCH then

		if curvedWall then
			ratio = (archHeight - offTop) / (archHeight - offLeft)
		else
			ratio = 1
		endif
		addy sideTop - archHeight
		muly ratio
		wallniche 7, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			 sideRight - offRight,			-sideBottom + offBottom + (archHeight - sideTop) / ratio,	31,
			 sideRight - offRight,			 0,		95,
			 smallRadiusEllips_offset,		 alphaSide,					2095,
			 middleRadiusEllips_offset,		 alphaMiddle/2,				2095,
			 middleRadiusEllips_offset,		 alphaMiddle/2,				2095,
			 smallRadiusEllips_offset,		 alphaSide,					2095,
			-sideLeft  + offLeft,			-sideBottom + offBottom + (archHeight - sideTop) / ratio,	31
		del 2
	endif

	if iWindowShape = SHAPE_PENTAGON then
		_hCenter = sideTop - offTop / cos(atn(tan_topAngle))
		wallniche 5, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			 sideRight - offRight,	-sideBottom + offBottom,	  							31,
			 sideRight - offRight,	 _hCenter - (sideRight - offRight) * tan_topAngle,		31,
			 0,						 _hCenter,												31,
			-sideLeft  + offLeft,	 _hCenter - (sideLeft - offLeft) * tan_topAngle,		31,
			-sideLeft  + offLeft,	-sideBottom + offBottom,	  							31
	endif

	if iWindowShape = SHAPE_TRAPEZOID then
		_dirWin = not(bMirroredOpening) * 2 - 1		!mirrored: -1  nonmirrored: 1
		_hCenter = sideTop - archHeight / 2 - offTop / cos(atn(tan_topAngle))
		py1 = _hCenter + _dirWin * (sideRight - offRight) * tan_topAngle
		py2 = _hCenter - _dirWin * (sideLeft - offLeft) * tan_topAngle

		wallniche 4, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,	-sideBottom + offBottom,	31,
				 sideRight - offRight,	py1,	31,
				-sideLeft  + offLeft,	py2,	31,
				-sideLeft  + offLeft,	-sideBottom + offBottom,	31
	endif

	if iWindowShape = SHAPE_TRIANGLE then
		_oleft = -offLeft / sin(atn(tan_LeftSide))
		_oright = -offRight / sin(atn(tan_RightSide))
		_xTop = (sideLeft + sideRight + _oleft + _oright) / (tan_LeftSide / tan_RightSide + 1)
		_yTop = _xTop * tan_LeftSide
		px1 = (sideLeft + sideRight) / 2 + _oright - (offBottom / tan_RightSide) * not(gs_stack_bottom)
		px2 = -(sideLeft + sideRight) / 2 - _oleft + (offBottom / tan_LeftSide) * not(gs_stack_bottom)

		wallniche 3, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			px1,	-sideBottom + offBottom,	31,
			-(sideLeft + sideRight) / 2 - _oleft + _xTop,						_yTop,						31,
			px2,	-sideBottom + offBottom,	31
	endif

	if iWindowShape = SHAPE_CORNER_TRIANGLE then
		if bRightCornerFunction then
			angleLeft	= atn((sideTop + sideBottom) / 2 / (sideLeft - (leftWidth - rightWidth) / 2))
			px2 = -sideLeft  + offBottom / tan(angleLeft)  + offLeft  / sin(angleLeft)
			CornerHeight = (sideRight - offRight - px2) * tan(angleLeft)

			wallniche 3, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				sideRight - offRight,	-sideBottom + offBottom,	31,
				sideRight - offRight,	 CornerHeight,				31,
				px2,					-sideBottom + offBottom,	31
		else
			angleLeft	= atn((sideTop + sideBottom) / 2 / sideLeft)
			px2 = -sideLeft  + offBottom / tan(angleLeft)  + offLeft  / sin(angleLeft)
			upperJambModify = 1 / tan((90-angleLeft)/2)

			wallniche 3, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				sideRight - offRight,	-sideBottom + offBottom,				31,
				sideRight - offRight,	 sideTop    - offTop * upperJambModify,	31,
				px2,					-sideBottom + offBottom,				31
		endif
	endif

	if iWindowShape = SHAPE_PARALLELOGRAM then
		if bMirroredOpening then
			wallniche 4, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,	-sideBottom + offBottom * upperJambModify + offRight * tan_topAngle,				31,
				 sideRight - offRight, 	 sideTop    - offTop * upperJambModify + offRight * tan_topAngle - archHeight,		31,
				-sideLeft  + offLeft,	 sideTop    - offTop * upperJambModify - offLeft  * tan_topAngle,							31,
				-sideLeft  + offLeft,	-sideBottom + offBottom * upperJambModify - offLeft * tan_topAngle + archHeight,	31
		else
			wallniche 4, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,	-sideBottom + offBottom * upperJambModify + offRight * tan_topAngle + archHeight,	31,
				 sideRight - offRight, 	 sideTop   - offTop * upperJambModify + offRight * tan_topAngle - archHeight,							31,
				-sideLeft  + offLeft,	 sideTop    - offTop * upperJambModify + offRight * tan_topAngle,		31,
				-sideLeft  + offLeft,	-sideBottom + offBottom * upperJambModify + offRight * tan_topAngle,				31
		endif
	endif


	if iWindowShape = SHAPE_GOTHICARCH then

		wallniche 7, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			 sideRight - offRight,					-sideBottom + offBottom,	  		31,
			 sideRight - offRight,					sideTop - archHeight,				95,
			 sideRight - arcR,						sideTop - archHeight,				900,
			(sideRight - sideLeft) / 2,				sideTop - centArcoffs,				3095,
			-sideLeft + arcR,						sideTop - archHeight,				900,
			-sideLeft  + offLeft,					sideTop - archHeight,				3095,
			-sideLeft  + offLeft,					-sideBottom + offBottom,	  		31

	endif

	if iWindowShape = SHAPE_HORSESHOE then

		wallniche 12, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
				sideRight - offRight,		-sideBottom,     		31,
				sideRight - offRight,		LowArcoffsy,			31,
				LowArcoffsx+EPS,			LowArcoffsy,			31,
				LowArcoffsx,				LowArcoffsy,			95,
				sideRight - RadArch,		sideTop - (ArchHeight - gs_lowerArchHeight), 900, 
				0,							HighArcoffs,			3000 +63,
				-EPS/2,						HighArcoffs,			95,
				-sideLeft + RadArch,		sideTop - (ArchHeight - gs_lowerArchHeight), 900,
				-LowArcoffsx,				LowArcoffsy,			3000 +31,
				-LowArcoffsx-EPS,			LowArcoffsy,			31,
				-sideLeft  + offLeft,		LowArcoffsy,			31,
				-sideLeft  + offLeft,		-sideBottom,			31
	endif

	if iWindowShape = SHAPE_OGEECENTERED then

		wallniche 11, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			sideRight - offRight,	-sideBottom,			31,
			sideRight - offRight,	sideTop - archHeight,	95,
			sideRight - RadArc,		sideTop - archHeight,	995,
			sideRight/2,			sideTop - archHeight/2,	3095,
			0 + RadArc,				sideTop,				995,
			0,						centArcoffs,			3095,
			0 - RadArc,				sideTop,				995,
			-sideLeft/2,			sideTop - archHeight/2,	3095,
			-sideLeft + RadArc,		sideTop - archHeight,	995,
			-sideLeft  + offLeft,	sideTop - archHeight,	3095,
			-sideLeft  + offLeft,	-sideBottom,			31
	endif


	if iWindowShape = SHAPE_SARACENIC then

		wallniche 10, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			sideRight - offRight,	-sideBottom,			31,
			sideRight - offRight,	sideTop - ArchHeight,	31+64,
			sideRight - RadArch,	sideTop - ArchHeight,	931+64,
			0,						60,						4031+64,
			0,						centArcoffs,			31,
			-tangArcx,				tangArcy,				31+64,
			-sideLeft + RadArch,	sideTop - ArchHeight,	931+64,
			0,						60,						4031+64,
			-sideLeft  + offLeft,	-sideBottom,			31,
			sideRight - offRight,	-sideBottom,			-1

	endif

	if iWindowShape = SHAPE_ROMBUS then
		addy openingHeight / 2
		wallniche 4, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			-openingWidth / 2 + offRight, 	 0, 							31,
			 0,								 openingHeight / 2 - offRight,	31,
			 openingWidth / 2 - offRight,	 0, 							31,
			 0,								-openingHeight / 2 + offRight,	31
!		wallniche 4, cutMethod, cutStatus,
!			cutVectX,cutVectY,cutVectZ, cutDepth,
!			-openingWidth / 2 + offRight * sideJambModify, 	 0, 												31,
!			 0,												 openingHeight / 2 - offRight * upperJambModify,	31,
!			 openingWidth / 2 - offRight * sideJambModify,	 0, 												31,
!			 0,												-openingHeight / 2 + offRight * upperJambModify,	31
		del 1
	endif

	if iWindowShape = SHAPE_OCTAGONAL then
		alpha_rotation	= 22.5
		offEdge			= (2 * offRight) / (2 * cos(22.5))
		cornerRadius	= openingHeight / (2 * cos(22.5))

		for i = 1 to 8
!!!			put (cornerRadius - offEdge / mulRatio) * sin(alpha_rotation), (cornerRadius - offEdge) * cos(alpha_rotation) * MulRat, 31
			put (cornerRadius - offEdge) * sin(alpha_rotation), (cornerRadius - offEdge) * cos(alpha_rotation) * MulRat, 31
			alpha_rotation = alpha_rotation + 45
		next i

		addy openingHeight/2
		wallniche nsp/3, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			get (nsp)
		del 1
	endif

	if iWindowShape = SHAPE_MULTISIDE then
		addy normalRadius * cos (180 / gs_numOfSides)

		alpha_rotation = 0
		if (gs_numOfSides mod 2) = 0 then
			alpha_rotation = 180 / gs_numOfSides
		endif

		cornerRadius = normalRadius - offRight / cos (180 / gs_numOfSides)

		for i = 1 to gs_numOfSides
			put cornerRadius * sin (alpha_rotation), cornerRadius * cos (alpha_rotation) * MulRat, 31 + (nArchResolution = 0) * 64
			alpha_rotation = alpha_rotation + 360 / gs_numOfSides
		next i

		wallniche nsp/3, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			get (nsp)
		del 1
	endif

	if iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
		addy openingHeight / 2
		muly openingHeight / openingWidth * MulRat
		wallniche 2, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			0, 0, 995,
			openingWidth/2 - offRight,	360, 4095
		del 2
	endif

	if iWindowShape = SHAPE_HALFCIRCLE then
		if sideTop - archHeight > -sideBottom + offBottom then
			archDistortion = (archHeight - offTop) / ((sideRight - offRight + sideLeft - offLeft) / 2)
			addy sideTop - archHeight
			muly archDistortion
			wallniche 6, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,	(-sideBottom + offBottom - sideTop + archHeight) / archDistortion,	31,
				 sideRight - offRight,	0,																	95,
				 0,						1, 																	895,
				 0,	 					(sideTop - offTop - sideTop + archHeight) / archDistortion,			1095,
				-sideLeft  + offLeft,	0,																	1095,
				-sideLeft  + offLeft,	(-sideBottom + offBottom - sideTop + archHeight) / archDistortion,	31
			del 2
		else
			pxR = sqr((sideRight - offRight)^2 - (-sideBottom + offBottom - (sideTop - archHeight))^2)
			pxL = sqr((sideLeft  - offLeft)^2  - (-sideBottom + offBottom - (sideTop - archHeight))^2)
			alpha = atn((-sideBottom + offBottom - (sideTop - archHeight)) / pxR)
			wallniche 5, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 pxR,			-sideBottom + offBottom,	95,
				 -sin(alpha),	 cos(alpha), 				895,
				 0,				 sideTop - offTop,			1031,
				-pxL,			-sideBottom + offBottom,	1031,
				 pxR,			-sideBottom + offBottom,	31
		endif
	endif

	if iWindowShape = SHAPE_HALFROUND then

		mulx -1
		add - openingWidth / 2, openingHeight / 2, 0

		diffx = (leftWidth - rightWidth) / 2
		ang_segm = 360 / nArchResolution
		kezd_veg = 0

		for kk= 0 to nArchResolution/2

			xa = openingWidth * cos(-90 + (kk) * ang_segm)
			ya = openingHeight / 2 * sin(-90 + (kk) * ang_segm)
			if ABS(ya) < EPS then
				ang_cent = -90
			else
				ang_cent = ATN(xa/ya)
			endif

			xa_el = openingWidth * cos(-90 + (kk-1) * ang_segm)
			ya_el = openingHeight / 2 * sin(-90 + (kk-1) * ang_segm)
			if ABS(ya_el) < EPS then
				ang_cent_el = -90
			else
				ang_cent_el = ATN(xa_el/ya_el)
			endif

			xa_ut = openingWidth * cos(-90 + (kk+1) * ang_segm)
			ya_ut = openingHeight / 2 * sin(-90 + (kk+1) * ang_segm)
			if ABS(ya_ut) < EPS then
				ang_cent_ut = -90
			else
				ang_cent_ut = ATN(xa_ut/ya_ut)
			endif

			bFirstPoint	= (kk = 0)
			bLastPoint	= (kk = nArchResolution / 2)

			if bFirstPoint & not(bRightCornerFunction) & offLeft < -EPS then
				put diffx + offLeft, -openingHeight / 2 + offLeft, 31
			endif

			if xa - abs(offLeft * sin(ang_cent)) >= offLeft then
				! between points
				if (bFirstPoint | bLastPoint) & not(bRightCornerFunction) & offLeft > -EPS then
					mask = 31
				else
					mask = 95
				endif
				if kk>nArchResolution/4 then
					put diffx + xa - (offLeft * sin(ang_cent)), ya - (offLeft * cos(ang_cent)), mask
				else
					put diffx + xa + (offLeft * sin(ang_cent)), ya + (offLeft * cos(ang_cent)), mask
				endif
			else
				if not(bRightCornerFunction) then
					mask = 31
				else
					mask = 95
				endif

				! first point
				if kezd_veg = 0 & xa_ut - ABS( offLeft * sin(ang_cent_ut)) > offLeft then
					x11 = offLeft
					y11 = -openingHeight
					x12 = offLeft
					y12 = openingHeight
					x21 = xa 	- ABS( offLeft * sin(ang_cent))
					y21 = ya 	+ ( offLeft * cos(ang_cent))
					x22 = xa_ut - ABS( offLeft * sin(ang_cent_ut))
					y22 = ya_ut + ( offLeft * cos(ang_cent_ut))
					GOSUB 100

					put diffx + cx, cy, mask

					kezd_veg = 1
				endif

				! last point
				if kezd_veg = 1  & xa_el - ABS( offLeft * sin(ang_cent_el)) > offLeft then
					x11 = offLeft
					y11 = -openingHeight
					x12 = offLeft
					y12 = openingHeight
					x21 = xa 	- ABS( offLeft * sin(ang_cent))
					y21 = ya 	- ( offLeft * cos(ang_cent))
					x22 = xa_el - ABS( offLeft * sin(ang_cent_el))
					y22 = ya_el - ( offLeft * cos(ang_cent_el))
					GOSUB 100

					put diffx + cx, cy, mask

					kezd_veg = 2
				endif
			endif

			if bLastPoint & not(bRightCornerFunction) & offLeft < -EPS then
				put diffx + offLeft, openingHeight / 2 - offLeft, 31
			endif


		next kk

		if bRightCornerFunction then
			wallniche 2+nsp/3, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-1,		-openingHeight/2 + offLeft,	95,
				get(nsp),
				-1,		openingHeight/2 - offLeft,	95
		else
			wallniche nsp/3, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				get(nsp)
		endif

		del 2
	endif

	if iWindowShape = SHAPE_T then
		if curvedWall then
			midleLine = (-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left + sideRight - offSlRight - gs_sidelight_WHole_width_right) / 2
			wallniche 6, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
				 sideRight - offRight,	 sideTop    - offTop,												31,
				-sideLeft  + offLeft,	 sideTop    - offTop,												31,
				-sideLeft  + offLeft,	-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				 midleLine,				-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				 midleLine,				-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31
			cutHeight = (sideTop - offTop) + (-sideBottom + max(gs_sidelight_parapet_hgt_left + offSlLeftBottom, gs_sidelight_parapet_hgt_right + offSlRightBottom) - sideTop + offTop) / 2
			wallniche 4, 1, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	 cutHeight,					31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	 cutHeight,					31
		else
			wallniche 9, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,										-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
				 sideRight - offRight,										 sideTop    - offTop,												31,
				-sideLeft  + offLeft,										 sideTop    - offTop,												31,
				-sideLeft  + offLeft,										-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offBottom,											31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offBottom,											31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
				 sideRight - offRight,										-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	-1
		endif
	endif

	if iWindowShape = SHAPE_HALF_T_LEFT then
		if curvedWall then
			midleLine = (-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left + sideRight - offRight) / 2
			cutHeight = (sideTop - offTop) + (-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left - sideTop + offTop) / 2
			wallniche 4, 1, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	 cutHeight,					31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offBottom,	31,
				 midleLine + 0.1,											-sideBottom + offBottom,	31,
				 midleLine + 0.1,											 cutHeight,					31
		else
			midleLine = -sideLeft  + offSlLeft + gs_sidelight_WHole_width_left
		endif
		wallniche 7, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			 sideRight - offRight,	-sideBottom + offBottom,										31,
			 sideRight - offRight,	 sideTop    - offTop,											31,
			-sideLeft  + offLeft,	 sideTop    - offTop,											31,
			-sideLeft  + offLeft,	-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,	31,
			 midleLine,				-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,	31,
			 midleLine,				-sideBottom + offBottom,										31,
			sideRight - offRight,	-sideBottom + offBottom,										-1
	endif

	if iWindowShape = SHAPE_HALF_T_RIGHT then
		if curvedWall then
			midleLine = (-sideLeft  + offLeft + sideRight - offSlRight - gs_sidelight_WHole_width_right) / 2
			cutHeight = (sideTop - offTop) + (-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right - sideTop + offTop) / 2
			wallniche 4, 1, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 midleLine - 0.1,											 cutHeight,					31,
				 midleLine - 0.1,											-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	 cutHeight,					31
		else
			midleLine = sideRight - offSlRight - gs_sidelight_WHole_width_right
		endif
		wallniche 7, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			 sideRight - offRight,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
			 sideRight - offRight,	 sideTop    - offTop,												31,
			-sideLeft  + offLeft,	 sideTop    - offTop,												31,
			-sideLeft  + offLeft,	-sideBottom + offBottom,											31,
			 midleLine,				-sideBottom + offBottom,											31,
			 midleLine,				-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
			 sideRight - offRight,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	-1
	endif

	if iWindowShape = SHAPE_ARCHED_T then
		if arcR - offTop > sideRight - offRight then
			shoulder_offset = sqr((arcR - offTop)^2 - (sideRight - offRight)^2)
			mask = 0
		else
			shoulder_offset = 0
			mask = 64
		endif

		if curvedWall then
			midleLine = (-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left + sideRight - offSlRight - gs_sidelight_WHole_width_right) / 2
			wallniche 11, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				(sideRight - offRight - sideLeft + offLeft) / 2,	 sideTop - arcR,						900,
				 sideRight - offRight,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
				 sideRight - offRight,	 sideTop    - arcR + shoulder_offset - EPS,							31+mask,
				 sideRight - offRight,	 sideTop    - arcR + shoulder_offset,								95,
				 0,	 					 sideTop - offTop,													3031+mask,
				-sideLeft  + offLeft,	 sideTop    - arcR + shoulder_offset,								3031+mask,
				-sideLeft  + offLeft,	 sideTop    - arcR + shoulder_offset - EPS,							31+mask,
				-sideLeft  + offLeft,	-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				midleLine,				-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				midleLine,				-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
				 sideRight - offRight,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	-1
			cutHeight = (sideTop - offTop) + (-sideBottom + max(gs_sidelight_parapet_hgt_left + offSlLeftBottom, gs_sidelight_parapet_hgt_right + offSlRightBottom) - sideTop + offTop) / 2
			wallniche 4, 1, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	 cutHeight,					31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	 cutHeight,					31
		else
			wallniche 13, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				(sideRight - offRight - sideLeft + offLeft) / 2,			 sideTop 	- arcR,				 									900,
				 sideRight - offRight,										-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
				 sideRight - offRight,										 sideTop    - arcR + shoulder_offset - EPS,							31+mask,
				 sideRight - offRight,										 sideTop    - arcR + shoulder_offset,								95,
				 0,															 sideTop - offTop,													3031+mask,
				-sideLeft  + offLeft,										 sideTop    - arcR + shoulder_offset,								3031+mask,
				-sideLeft  + offLeft,										 sideTop    - arcR + shoulder_offset - EPS,							31+mask,
				-sideLeft  + offLeft,										-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offBottom,											31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offBottom,											31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
				 sideRight - offRight,										-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	-1
		endif
	endif

	if iWindowShape = SHAPE_ARCHED_HALF_T_LEFT then
		if arcR - offTop > sideRight - offRight then
			shoulder_offset = sqr((arcR - offTop)^2 - (sideRight - offRight)^2)
			mask = 0
		else
			shoulder_offset = 0
			mask = 64
		endif

		if curvedWall then
			midleLine = (-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left + sideRight - offRight) / 2
			cutHeight = (sideTop - offTop) + (-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left - sideTop + offTop) / 2
			wallniche 4, 1, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	 cutHeight,					31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offBottom,	31,
				 midleLine + 0.1,											-sideBottom + offBottom,	31,
				 midleLine + 0.1,											 cutHeight,					31
		else
			midleLine = -sideLeft  + offSlLeft + gs_sidelight_WHole_width_left
		endif
		wallniche 11, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			(sideRight - offRight - sideLeft + offLeft) / 2,	sideTop - arcR,						900,
			 sideRight - offRight,	-sideBottom + offBottom,										31,
			 sideRight - offRight,	 sideTop    - arcR + shoulder_offset - EPS,						31+mask,
			 sideRight - offRight,	 sideTop    - arcR + shoulder_offset,							95,
			 0,						 sideTop - offTop,												3031+mask,
			-sideLeft  + offLeft,	 sideTop    - arcR + shoulder_offset,							3031+mask,
			-sideLeft  + offLeft,	 sideTop    - arcR + shoulder_offset - EPS,						31+mask,
			-sideLeft  + offLeft,	-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,	31,
			 midleLine,				-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,	31,
			 midleLine,				-sideBottom + offBottom,										31,
			 sideRight - offRight,	-sideBottom + offBottom,										-1
	endif

	if iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then
		if arcR - offTop > sideRight - offRight then
			shoulder_offset = sqr((arcR - offTop)^2 - (sideRight - offRight)^2)
			mask = 0
		else
			shoulder_offset = 0
			mask = 64
		endif

		if curvedWall then
			midleLine = (-sideLeft  + offLeft + sideRight - offSlRight - gs_sidelight_WHole_width_right) / 2
			cutHeight = (sideTop - offTop) + (-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right - sideTop + offTop) / 2
			wallniche 4, 1, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 midleLine - 0.1,											 cutHeight,					31,
				 midleLine - 0.1,											-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	 cutHeight,					31
		else
			midleLine = sideRight - offSlRight - gs_sidelight_WHole_width_right
		endif
		wallniche 11, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			(sideRight - offRight - sideLeft + offLeft) / 2,	sideTop - arcR,							900,
			 sideRight - offRight,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
			 sideRight - offRight,	 sideTop    - arcR + shoulder_offset - EPS,							31+mask,
			 sideRight - offRight,	 sideTop    - arcR + shoulder_offset,								95,
			 0,						 sideTop - offTop,													3031+mask,
			-sideLeft  + offLeft,	 sideTop    - arcR + shoulder_offset,								3031+mask,
			-sideLeft  + offLeft,	 sideTop    - arcR + shoulder_offset - EPS,							31+mask,
			-sideLeft  + offLeft,	-sideBottom + offBottom,											31,
			 midleLine,				-sideBottom + offBottom,											31,
			 midleLine,				-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
			 sideRight - offRight,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	-1
	endif

	if iWindowShape = SHAPE_QUARTERROUND then
		if offLeft > holeSideOffset | offBottom > holeBottomOffset then
			px = sqr((openingWidth - offRight)^2 - (offBottom - holeBottomOffset)^2)
			py = sqr((openingHeight - offTop)^2 - (offLeft - holeSideOffset)^2)
			wallniche 6, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-openingWidth / 2 + offLeft,		offBottom,					31,
				-openingWidth / 2 + px,				offBottom,					95,
				-openingWidth / 2 + holeSideOffset,	holeBottomOffset,			900,
				-openingWidth / 2 + offLeft,		py,							3031,
				-openingWidth / 2 + offLeft,		py - EPS,					31,
				-openingWidth / 2 + offLeft,		offBottom,					-1
		else
			wallniche 7, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-openingWidth / 2 + offLeft,		offBottom,					31,
				 openingWidth / 2 - offRight,		offBottom,					95,
				 openingWidth / 2 - offRight,		holeBottomOffset,			95,
				 0,									1,							800,
				-openingWidth / 2 + holeSideOffset,	openingHeight - offTop,		1031,
				-openingWidth / 2 + offLeft,		openingHeight - offTop,		31,
				-openingWidth / 2 + offLeft,		offBottom,					-1
		endif
	endif

	if iWindowShape = SHAPE_QUARTERROUND_NOFRAME then
		if bMirroredOpening then
			openingHeight = openingWidth
			px = sqr((openingWidth - offLeft)^2 - offBottom^2)
			py = sqr((openingHeight - offTop)^2 - offLeft^2)

			if bRightCornerFunction then
				diffx = -(leftWidth - rightWidth) / 2
				wallniche 6, cutMethod, cutStatus,
					cutVectX,cutVectY,cutVectZ, cutDepth,
					 diffx + openingWidth / 2 + 1.0,	offBottom,				31,
					 diffx + openingWidth / 2 - px,		offBottom,				95,
					 diffx + openingWidth / 2,			0,						900,
					 diffx + openingWidth / 2,			openingHeight - offTop,	3095,
					 diffx + openingWidth / 2 + 1.0,	openingHeight - offTop, 31,
					 diffx + openingWidth / 2 + 1.0,	offBottom,				-1
			else
				if px > py then
					wallniche 6, cutMethod, cutStatus,
						cutVectX,cutVectY,cutVectZ, cutDepth,
						 openingWidth / 2 - offRight,	offBottom,	31,
						 openingWidth / 2 - px,			offBottom,	95,
						 openingWidth / 2,				0,			900,
						 openingWidth / 2 - offRight,	py,			3031,
						 openingWidth / 2 - offRight,	py - EPS,	31,
						 openingWidth / 2 - offRight,	offBottom,	-1
				else
					wallniche 6, cutMethod, cutStatus,
						cutVectX,cutVectY,cutVectZ, cutDepth,
						 openingWidth / 2 - offRight,	offBottom,	31,
						 openingWidth / 2 - px,			offBottom,	95,
						 openingWidth / 2,				0,			900,
						 openingWidth / 2,				px,			3095,
						 openingWidth / 2 - offRight,	px - EPS,	31,
						 openingWidth / 2 - offRight,	offBottom,	-1
				endif
			endif
		else
			px = sqr((openingWidth - offRight)^2 - offBottom^2)
			py = sqr((openingHeight - offTop)^2 - offLeft^2)

			wallniche 6, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-openingWidth / 2 + offLeft,	offBottom,	31,
				-openingWidth / 2 + px,			offBottom,	95,
				-openingWidth / 2,				0,			900,
				-openingWidth / 2 + offLeft,	py,			3031,
				-openingWidth / 2 + offLeft,	py - EPS,	31,
				-openingWidth / 2 + offLeft,	offBottom,	-1
		endif
	endif

	_bCustomMatNicheTop		= 0
return


! ==============================================================================
! Line - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12	line #1
!	x21,y21, x22,y22	line #2
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = valid intersection point
!	cx, cy:				intersection point
! ==============================================================================

100:
	lliDiv = (x11-x12) * (y21-y22) - (y11-y12) * (x21-x22)

	if abs(lliDiv) > EPS then
		! Intersection

		temp1 = x11 * y12 - y11 * x12
		temp2 = x21 * y22 - y21 * x22

		tempx = temp1 * (x21-x22) - (x11-x12) * temp2
		tempy = temp1 * (y21-y22) - (y11-y12) * temp2

		state = 1
		cx = (tempx / lliDiv)
		cy = (tempy / lliDiv)
	else
		! No Intersection
		state = 0
		cx = 0
		cy = 0
	endif
return



! ==============================================================================
! Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	xo,yo,ro:			circle
!	x1,y1, x2,y2		line
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = one intersection point (tangential line)
!						2 = two intersection points
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
! ==============================================================================

101:
	tempX1 = x1 - xo: tempY1 = y1 - yo
	tempX2 = x2 - xo: tempY2 = y2 - yo

	if abs(tempX2 - tempX1) < EPS then
		if abs(ro - abs(tempX1)) < EPS then
			state = 1
			xa = tempX1
			ya = 0
			xb = tempX1
			yb = 0
		else
			if abs(ro) - abs(tempX1) < 0 then
				state = 0: xa = 0: ya = 0: xb = 0: yb = 0
			else
				state = 2
				xa = tempX1
				ya = sqr(ro^2 - tempX1^2)
				xb = tempX1
				yb = -ya
			endif
		endif
	else
		kf = (tempY2 - tempY1) / (tempX2 - tempX1)
		ad = 1 + kf^2
		bd = 2 * tempY1 * kf - 2 * tempX1 * kf^2
		cd = tempY1^2 - 2 * tempX1 * tempY1 * kf + tempX1^2 * kf^2 - ro^2

		if bd^2 - 4 * ad * cd < 0 then
			state = 0: xa = 0: ya = 0: xb = 0: yb = 0
		else
			xa = (-bd + sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			ya = tempY1 + (xa - tempX1) * kf
			xb = (-bd - sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			yb = tempY1 + (xb - tempX1) * kf

			if abs(xa - xb) < EPS then state = 1 else state = 2
		endif
	endif

	if state = 2 then
		da = sqr((tempX1 - xa)^2 + (tempY1 - ya)^2)
		db = sqr((tempX1 - xb)^2 + (tempY1 - yb)^2)

		if db < da then
			xxo = xa: yyo = ya
			xa = xb:  ya = yb
			xb = xxo: yb = yyo
		endif
	endif

	xa = xa + xo: ya = ya + yo
	xb = xb + xo: yb = yb + yo
return

205:

!!! ***** Direction Angle of Vector


IF vx=0 AND vy=0 THEN PRINT "Error: Null Vector !"

IF vx=0 THEN
	IF vy>0 THEN
		anglex = 90
	ELSE
		anglex = 270
	ENDIF
ELSE

	anglex = ATN (vy/vx)

	IF vx>=0 THEN
		IF anglex>=0 THEN
			anglex = anglex
		ELSE
			anglex = 360 + anglex
		ENDIF

	ELSE

		IF anglex>0 THEN
			anglex = 180 + anglex
		ELSE
			anglex = 180 + anglex
		ENDIF
	ENDIF
ENDIF

RETURN


209:

!!! ***** Circle - Circle Intersection

vx =	x2-x1
vy =	y2-y1
GOSUB 205

angle = anglex


d = SQR( (vx)^2+(vy)^2 )

IF d>(r1+r2) OR ABS(d)<EPS THEN ! No Intersection
	state = 0
	RETURN
ENDIF

IF ABS(d-(r1+r2))<EPS THEN ! One Intersection

	state =  1
	ccx1 = x1 + ((x2-x1)*r1)/(r1+r2)
	ccy1 = y1 + ((y2-y1)*r1)/(r1+r2)

	ccx2 = ccx1
	ccy2 = ccy1
	RETURN
ENDIF


! Check if one circle inside the another !!!!!!!!!!!!!!!!!!!!!!!!!!!

x = (d^2 - r2^2 + r1^2) / (2*d)
y = SQR(4*d^2*r1^2-(d^2-r2^2+r1^2)^2)/(d*2)
ccx1 = x1 + y*SIN(-angle) + x*COS(-angle)
ccy1 = y1 + y*COS(-angle) - x*SIN(-angle)
ccx2 = x1 - y*SIN(-angle) + x*COS(-angle)
ccy2 = y1 - y*COS(-angle) - x*SIN(-angle)

state =	2


RETURN



3000:
! ==============================================================================
! --- Reveal Hotspots ---
! ==============================================================================
if iRevealType > REVEAL_NO then
	hotspot revealRadius * sin (alpha_rotation), revealRadius * cos (alpha_rotation), leftRevealPnts[idxSillStartRevealLeft][2],	unID : unID = unID + 1
	hotspot revealRadius * sin (alpha_rotation), revealRadius * cos (alpha_rotation), leftRevealPnts[idxSillEndRevealLeft][2],	unID : unID = unID + 1
endif
return



4000:
! ==============================================================================
! --- Wallhole Hotspots ---
! ==============================================================================

! Board Side Hotspots ----------------------------------------------------------
hotspot normalRadius * sin (alpha_rotation), normalRadius * cos (alpha_rotation), leftRevealPnts[idxBoardEndRevealLeft][2],	unID : unID = unID + 1

! Sill Side Hotspots ----------------------------------------------------------
if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
	hotspot normalRadius * sin (alpha_rotation), normalRadius * cos (alpha_rotation), leftRevealPnts[idxSillStartRevealLeft][2],	unID : unID = unID + 1
else
	hotspot normalRadius * sin (alpha_rotation), normalRadius * cos (alpha_rotation), leftRevealPnts[idxFrameStartRevealLeft][2],	unID : unID = unID + 1
endif

return



