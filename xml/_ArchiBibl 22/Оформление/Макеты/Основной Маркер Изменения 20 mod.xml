<?xml version="1.0" encoding="UTF-8"?>
<Symbol IsArchivable="false" IsPlaceable="true" MainGUID="536B104F-01A6-4D4A-A741-863BD645005E" MigrationValue="Normal" Owner="1196638531" Signature="1196644685" Version="43">
<Ancestry SectVersion="1" SectionFlags="0" SubIdent="0" Template="false">
	<MainGUID>F938E33A-329D-4A36-BE3E-85E126820996</MainGUID>
	<MainGUID>B176ABF1-5813-478F-926B-28EE7C5DC1F7</MainGUID>
	<MainGUID>4FD10D67-2F29-4844-A65A-6597589B0CB5</MainGUID>
	<MainGUID>B3A106BF-6277-456E-8657-65B5C2D1C315</MainGUID>
	<MainGUID>0629A4D6-7484-4223-BCEA-4670DD3F516C</MainGUID>
</Ancestry>

<CalledMacros SectVersion="2" SectionFlags="0" SubIdent="0">
</CalledMacros>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_3D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_3D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_2D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! ==============================================================================
! Oriented View
! ==============================================================================

_angleViewRot = 0
rrr = REQUEST ("View_Rotangle", "", _angleViewRot)
_totalRotate = 0
if GLOB_CONTEXT <> 5 then
	_totalRotate = (SYMB_ROTANGLE + _angleViewRot) MOD 360
endif

! ==============================================================================
! Set dimensions and used angle
! ==============================================================================
! set scale dependent parameter values
! replace PM scripts, because its not running at changing scale
! paper size parameters
define style "markertext_oneRow" AC_TextFont_1, AC_TextSize_1, 5, AC_TextStyle_1
define style "markertext_1stRow" AC_TextFont_1, AC_TextSize_1, 8, AC_TextStyle_1
define style "markertext_2ndRow" AC_TextFont_1, AC_TextSize_1, 2, AC_TextStyle_1
nnn = request("Height_of_style", "markertext_oneRow", text_height)


PAPER_TO_MODEL = GLOB_SCALE / 1000	! Convert paper size to model size

AC_Markersize = text_height

AC_Markersize 			= AC_Markersize * PAPER_TO_MODEL
widthHead_model 		= widthHead_mm * PAPER_TO_MODEL
widthHeadHalf_model		= widthHeadHalf_mm * PAPER_TO_MODEL
distanceHead_model		= distanceHead_mm * PAPER_TO_MODEL 
radiusCloud_model 		= radiusCloud_mm * PAPER_TO_MODEL
minradiusCloud_model 	= minradiusCloud_mm * PAPER_TO_MODEL
maxradiusCloud_model 	= maxradiusCloud_mm * PAPER_TO_MODEL
if abs(sin(_anglebyMaxRadius)) > EPS then
	lengthRounded_model 	= min ( (radiusCloud_mm * PAPER_TO_MODEL)/sin(_anglebyMaxRadius) - (radiusCloud_mm * PAPER_TO_MODEL),
									(_maxUsableRadius/sin(_anglebyMaxRadius) - _maxUsableRadius) )
endif

dim _widthHalfHead[14][3]
! Head Size from Origo to the External Line
! _widthHalfHead[][1] - half head size on the side
! _widthHalfHead[][2] - half head size on the top
! _widthHalfHead[][3] - half head size on the bottom
gosub "set_array_widthHalfHead"

unID = 1
vx = 0
vy = 0

bFeedBackInput = 0

! ==============================================================================
! Preview
! ==============================================================================

if GLOB_CONTEXT = 5 then

	distanceHead_model = AC_Markersize/2

	if _hasPolygon then
		AC_PolygonNodes = 5

		_widthPreviewPolygon = AC_Markersize/2
		_heightPreviewPolygon = AC_Markersize
		_posPreviewPolygon = 2*AC_Markersize/3

		AC_PolygonCoords[1][1] = _posPreviewPolygon
		AC_PolygonCoords[1][2] = -_heightPreviewPolygon/2
		AC_PolygonCoords[2][1] = _posPreviewPolygon + _widthPreviewPolygon
		AC_PolygonCoords[2][2] = -_heightPreviewPolygon/2
		AC_PolygonCoords[3][1] = _posPreviewPolygon + _widthPreviewPolygon
		AC_PolygonCoords[3][2] = _heightPreviewPolygon/2
		AC_PolygonCoords[4][1] = _posPreviewPolygon
		AC_PolygonCoords[4][2] = _heightPreviewPolygon/2
		AC_PolygonCoords[5][1] = _posPreviewPolygon
		AC_PolygonCoords[5][2] = -_heightPreviewPolygon/2

		_lengthVector[1] = _widthPreviewPolygon
		_lengthVector[2] = _heightPreviewPolygon
		_lengthVector[3] = _widthPreviewPolygon
		_lengthVector[4] = _heightPreviewPolygon

		_angleVector[1] = 0
		_angleVector[2] = 90
		_angleVector[3] = 180
		_angleVector[4] = 270

		if iTypeCloud = CLOUD_ROUNDED then
			_maxDistTangentPoint[1] = min(_lengthVector[1], _lengthVector[4])/2
			_maxDistTangentPoint[2] = min(_lengthVector[2], _lengthVector[1])/2
			_maxDistTangentPoint[3] = min(_lengthVector[3], _lengthVector[2])/2
			_maxDistTangentPoint[4] = min(_lengthVector[4], _lengthVector[3])/2
	
			_angVectorSide[1] = 90
			_angVectorSide[2] = 90
			_angVectorSide[3] = 90
			_angVectorSide[4] = 90
		endif

	else
		AC_RefCoord[1] = 0.5
		AC_RefCoord[2] = 0.5
	endif
endif

! ===================================================================
! Cloud
! ===================================================================

dim _radCloud[][]
dim _numCloud[]

dim _filletRadius[]
dim _filletCenterPoint[][]

if _hasPolygon then
	pen SYMB_VIEW_PEN
	fill typeFillCloud

	for i = 1 to AC_PolygonNodes - 1
		if iTypeCloud = CLOUD_POLYGON then
			line_type lineTypeCloud
			put AC_PolygonCoords[i][1], AC_PolygonCoords[i][2], 1
		endif

		if iTypeCloud = CLOUD_ROUNDED then
			line_type lineTypeCloud

			if i = 1 then
				xcoordLast = AC_PolygonCoords[AC_PolygonNodes - 1][1]
				ycoordLast = AC_PolygonCoords[AC_PolygonNodes - 1][2]
			else
				xcoordLast = AC_PolygonCoords[i-1][1]
				ycoordLast = AC_PolygonCoords[i-1][2]
			endif

			! defining dimensions of rounded peaks :
			! 1. radius of rounding arc
			! 2. distance of center of rounding arc from the peak
			! 3. suspended angle of rounding arc
			! 4. absolute coords of rounding arc center
			! 5. absolute coords of targentical points
			! -------------------------------------------------------

			! 1.1 calculate the angle of vector before the current peak
			! -------------------------------------------------------
			vx = AC_PolygonCoords[i][1] - xcoordLast
			vy = AC_PolygonCoords[i][2] - ycoordLast
			gosub "check_vector_direction_angle"
			_angleVectorBefore = angle

			! 1.2 the angle between two vector
			! -------------------------------------------------------
			_angleVectorSide = _angVectorSide[i]
			_usedalpha = _angleVectorSide/2
	
			! 1.3 calculate the used cloud circle radius
			! -------------------------------------------------------
			_maxUsableLocalRadius = tan(_usedalpha) * _maxDistTangentPoint[i]	! by design
			if radiusCloud_model > _maxUsableLocalRadius then
				_usedRadiusCloud = _maxUsableLocalRadius
			else
				_usedRadiusCloud = radiusCloud_model
			endif
	
			! 2. calculate distance from circle center point to peak
			! -------------------------------------------------------
			_lengthCircleCenter = _usedRadiusCloud/sin(_usedalpha)
	
			! 3.1 calculate status of angle - convex or concave (0/1)
			! -------------------------------------------------------
			_statusAngleConcave = 1
			if ((_angleVectorBefore - _angleVector[i] + 360) MOD 360 ) > 180 then
				_statusAngleConcave = 0
			endif

			! 3.2 calculate the subtended angle of rounded arc
			! -------------------------------------------------------
			_angleArc = (180 - _angleVectorSide)
			_usedVectorAngle = _angleVector[i]
			if _statusAngleConcave = 1 then
				_angleArc = -_angleArc
			endif

			! 4. calculate circle center coordinates
			! -------------------------------------------------------
			if not(_statusAngleConcave) then
				cx = AC_PolygonCoords[i][1] + _lengthCircleCenter * cos(_angleVectorSide/2 + _angleVector[i])
				cy = AC_PolygonCoords[i][2] + _lengthCircleCenter * sin(_angleVectorSide/2 + _angleVector[i])
			else
				cx = AC_PolygonCoords[i][1] - _lengthCircleCenter * cos(  (_angleVectorSide/2 + _angleVectorBefore))
				cy = AC_PolygonCoords[i][2] - _lengthCircleCenter * sin(  (_angleVectorSide/2 + _angleVectorBefore))
			endif

			! 5. calculate targentical point coordinates
			! -------------------------------------------------------
			x1 = xcoordLast
			y1 = ycoordLast
			x2 = AC_PolygonCoords[i][1]
			y2 = AC_PolygonCoords[i][2]
			px = cx
			py = cy
			gosub "segment_point_projection"	! returned px,py

			! fill stack with the correct coordinates
			! -------------------------------------------------------
			put px, py, 1
			put cx, cy, 900
			put 0, _angleArc, 4001	! Arc using centerpoint and angle

			! one editable hotspot in the peak where the maximum radius could be
			if _placeMaxRadius = i and GLOB_CONTEXT <> 5 then
				! find the vector angle between circle center and peak
				vx = AC_PolygonCoords[i][1] - cx
				vy = AC_PolygonCoords[i][2] - cy
				gosub "check_vector_direction_angle"	! returned angle

				add2 AC_PolygonCoords[i][1], AC_PolygonCoords[i][2]
				rot2 angle + 180

				hotspot2  0,					0,	unID, lengthRounded_m, 1+1024+128,	radiusCloud_mm : unID = unID + 1
				hotspot2 -1,					0,	unID, lengthRounded_m, 3+1024,		radiusCloud_mm : unID = unID + 1
				hotspot2  lengthRounded_model,	0,	unID, lengthRounded_m, 2+1024,		radiusCloud_mm : unID = unID + 1

				del 2
			endif

			_filletRadius[i] = _usedRadiusCloud
			_filletCenterPoint[i][1] = cx
			_filletCenterPoint[i][2] = cy

		endif
		if iTypeCloud = CLOUD_BISCUIT then
			line_type 1
			gosub "standard_cloudy"
		endif
		if iTypeCloud = CLOUD_PERIODIC then
			line_type 1
			gosub "standard_cloudy"
		endif
		if iTypeCloud = CLOUD_RANDOM then
			line_type 1
			gosub "standard_cloudy"
		endif
	next i
	poly2_b	nsp/3, 1 + 2*bFillCloud + 4, penFillCloud, backpenFillCloud,
		get(nsp)
endif



! ==============================================================================
! Marker Line
! ==============================================================================

! iLineKind:
LINEKIND_NO				= 0
LINEKIND_TO_CIRCLE		= 1
LINEKIND_TO_LINE		= 2
LINEKIND_TO_RECTANGLE	= 3
LINEKIND_TO_POLYGON		= 4
LINEKIND_TO_POINT		= 5

iLineKind = LINEKIND_NO

pen penContourHead
line_type 1

! old refcoord
	pntX = 0
	pntY = 0
! old pos_x pos_Y
	posX = 0	! last click positions
	posY = 0
_angleExternalLine = 0
drawindex 10
if bConnectionLine then
	! -----------------------------------------------------------------------------
	! defining status of head position compared to cloud polygon
	!
	!	if Component: Cloud and Marker Head or Cloud Only
	!	- inside			iLineKind = LINEKIND_NO
	!	- outside			iLineKind = LINEKIND_POLYGON
	!
	!	if Component: Cloud and Marker Head or Cloud Only
	!	- alwasy inside		iLineKind = LINEKIND_TO_POINT
	! -----------------------------------------------------------------------------
	if _hasPolygon then
		ret = 0		! Error
		pipEnd = 0
		pipIntersection = 0
	
		pipX0 = AC_PolygonCoords[AC_PolygonNodes - 1][1] + pntX
		pipY0 = AC_PolygonCoords[AC_PolygonNodes - 1][2] + pntY
		pipX1 = AC_PolygonCoords[1][1] + pntX
		pipY1 = AC_PolygonCoords[1][2] + pntY
	
		for pipI = 1 to AC_PolygonNodes - 1
	
			! Point on polygon vertex test
			if abs(pipX1 - posX) < EPS & abs(pipY1 - posY) < EPS then
				ret		= 4					! OnPoint
				pipI	= AC_PolygonNodes - 1	! Force end loop
				pipEnd	= 1
			endif
	
			! Point on edge test
			pipSegLength = sqr((pipX0 - pipX1)^2 + (pipY0 - pipY1)^2)
			if pipSegLength > EPS & not(pipEnd) then
				x1 = pipX0
				y1 = pipY0
				x2 = pipX1
				y2 = pipY1
				px = posX
				py = posY

				gosub "segment_point_projection"		! returned px,py

				if abs(px - posX) < EPS & abs(py - posY) < EPS then
					ret		= 3					! OnEdge
					pipEnd	= 1
				endif
			endif
	
			pipX2 = AC_PolygonCoords[pipI + 1][1] + pntX
			pipY2 = AC_PolygonCoords[pipI + 1][2] + pntY
	
			line1X1 = pipX1
			line1Y1 = pipY1
			line1X2 = pipX2
			line1Y2 = pipY2
	
			line2X1 = posX
			line2Y1 = posY
			line2X2 = posX + 1000
			line2Y2 = posY + 1

			gosub "segment_segment_intersection"
			! Result: state, cx,cy
	
			if state = 3 then
				if abs(line1X2 - cx) > EPS | abs(line1Y2 - cy) > EPS then
					if abs(line1X1 - cx) < EPS & abs(line1Y1 - cy) < EPS then
						if sgn(pipY0 - pntY) <> sgn(pipY2 - pntY) then
							pipIntersection = pipIntersection + 1
						endif
					else
						pipIntersection = pipIntersection + 1
					endif
				endif
			endif
	
			pipX0 = pipX1
			pipY0 = pipY1
	
			pipX1 = pipX2
			pipY1 = pipY2
		next pipI
	
		if (pipIntersection % 2 = 0) & ret <> 3 & ret <> 4 then	! Outside, On Edge, On Line
			iLineKind = LINEKIND_TO_POLYGON
		else
			iLineKind = LINEKIND_NO
		endif
	else
		iLineKind = LINEKIND_TO_POINT
	endif

	nearestPx = 0 : nearestPy = 0
	! -----------------------------------------------------------------------------
	! LINEKIND_TO_POLYGON
	!	-	calculate the nearest coordinates of cloud polygon from the head
	!		nearestPx, nearestPy
	! -----------------------------------------------------------------------------
	if iLineKind = LINEKIND_TO_POLYGON then
		nearestDist = 999999
	
		for i = 1 to AC_PolygonNodes - 1
	
			x1 = AC_PolygonCoords[i][1] + pntX
			y1 = AC_PolygonCoords[i][2] + pntY
	
			x2 = AC_PolygonCoords[i + 1][1] + pntX
			y2 = AC_PolygonCoords[i + 1][2] + pntX
	
			px = posX
			py = posY
			gosub "segment_point_projection"
	
			if state <> 0 then
				dist = (posX - px)^2 + (posY - py)^2
	
				if dist < nearestDist then
					nearestPx = px
					nearestPy = py
					nearestDist = dist

					_usedSegment = i
					nearestEdgex = AC_PolygonCoords[_usedSegment][1]
					nearestEdgey = AC_PolygonCoords[_usedSegment][2]
				endif
			endif
		next i

		if (iTypeCloud = CLOUD_ROUNDED) then

			! -------------------------------------------------------------------
			! searching for non-filleted part of used edge
			! -------------------------------------------------------------------

			! calculate control distance from tangential point to start corner
			! -------------------------------------------------------------------
			xs = AC_PolygonCoords[_usedSegment][1]
			ys = AC_PolygonCoords[_usedSegment][2]
			xe = AC_PolygonCoords[_usedSegment+1][1]
			ye = AC_PolygonCoords[_usedSegment+1][2]
			_nearestPx = nearestPx - AC_RefCoord[1]
			_nearestPy = nearestPy - AC_RefCoord[2]

			x1 = AC_PolygonCoords[_usedSegment][1]
			y1 = AC_PolygonCoords[_usedSegment][2]
			x2 = AC_PolygonCoords[_usedSegment+1][1]
			y2 = AC_PolygonCoords[_usedSegment+1][2]
			px = _filletCenterPoint[_usedSegment][1]
			py = _filletCenterPoint[_usedSegment][2]

			gosub "segment_point_projection"	! returned px, py tangential point coordinates

			controlDistS = (px - xs)^2 + (py - ys)^2

			! calculate control distance from tangential point to end corner
			! -------------------------------------------------------------------
			x1 = AC_PolygonCoords[_usedSegment][1]
			y1 = AC_PolygonCoords[_usedSegment][2]
			x2 = AC_PolygonCoords[_usedSegment + 1][1]
			y2 = AC_PolygonCoords[_usedSegment + 1][2]
			if _usedSegment + 1 > AC_PolygonNodes - 1 then		! if there is no more filletCenterPoint then go back to start
				px = _filletCenterPoint[1][1]
				py = _filletCenterPoint[1][2]
			else
				px = _filletCenterPoint[_usedSegment + 1][1]
				py = _filletCenterPoint[_usedSegment + 1][2]
			endif

			gosub "segment_point_projection"	! returned px,py

			controlDistE = (px - xe)^2 + (py - ye)^2

			! calculate distance from tangential point to start corner
			! -------------------------------------------------------------------
			distS = (_nearestPx - xs)^2 + (_nearestPy - ys)^2

			! calculate distance from tangential point to end corner
			! -------------------------------------------------------------------
			distE = (_nearestPx - xe)^2 + (_nearestPy - ye)^2


			! change nearest point if it is on the filleted part
			! -------------------------------------------------------------------
			if distS < controlDistS | distE < controlDistE then

				! searching for nearest corner point to marker head position 
				! -------------------------------------------------------------------
				_nearestDist = 999999
				_nearestCornerPointID = 0

				for i = 1 to AC_PolygonNodes - 1
					x1 = AC_PolygonCoords[i][1] + AC_RefCoord[1]
					y1 = AC_PolygonCoords[i][2] + AC_RefCoord[2]

					dist = (posX - x1)^2 + (posY - y1)^2

					if dist < _nearestDist then
						_nearestDist = dist
						_nearestCornerPointID = i
					endif
				next i

				if _nearestCornerPointID then
					xo = _filletCenterPoint[_nearestCornerPointID][1]
					yo = _filletCenterPoint[_nearestCornerPointID][2]
					ro = _filletRadius[_nearestCornerPointID]
					x1 = xo
					y1 = yo
					x2 = posX - AC_RefCoord[1]
					y2 = posY - AC_RefCoord[2]

					gosub "circle_line_intersection"

					! searching for nearest intersection point to corner
					! -------------------------------------------------------------------
					x1 = AC_PolygonCoords[_nearestCornerPointID][1]
					y1 = AC_PolygonCoords[_nearestCornerPointID][2]
			
					distA = (x1 - xa)^2 + (y1 - ya)^2
					distB = (x1 - xb)^2 + (y1 - yb)^2
			
					if distA < distB then
						_nearestPx = xa
						_nearestPy = ya
					else
						_nearestPx = xb
						_nearestPy = yb
					endif

					nearestPx = _nearestPx + AC_RefCoord[1]
					nearestPy = _nearestPy + AC_RefCoord[2]
				endif
			endif
		endif

		! calculation cloud circle chord on the nearest point
		if (iTypeCloud = CLOUD_BISCUIT | iTypeCloud = CLOUD_PERIODIC | iTypeCloud = CLOUD_RANDOM) then
			_dist = 0
			_rad = 0
			! Distance from act edge to the sectioned circle
			_distCircle = SQR(( nearestPx - nearestEdgex )^2 + ( nearestPy - nearestEdgey)^2)

			for iCC = 1 to _numCloud[_usedSegment]
				_dist = _dist + _radCloud[_usedSegment][iCC]*2
				if _dist > _distCircle then
					_rad = _radCloud[_usedSegment][iCC]
					iCC = _numCloud[_usedSegment]
				endif
			next iCC
		
			xC = abs(_dist - _distCircle)
			if xC > EPS & _rad > EPS then
				if xC > _rad then
					xC = xC -_rad
				else
					xC = _rad - xC
				endif
				_lengthChord = SQR(abs(_rad^2 - xC^2))
				nearestPx = nearestPx  - cos((_angleVector[_usedSegment] + 90) MOD 360) * _lengthChord
				nearestPy = nearestPy  - sin((_angleVector[_usedSegment] + 90) MOD 360) * _lengthChord
			endif
		endif
	endif

	! -----------------------------------------------------------------------------
	! LINEKIND_TO_POINT - Component: Marker Head Only
	!	- 	calculate the nearest coordinates of point from the head
	!		nearestPx, nearestPy
	! -----------------------------------------------------------------------------
	if iLineKind = LINEKIND_TO_POINT then
		nearestPx = AC_RefCoord[1]
		nearestPy = AC_RefCoord[2]
	endif

	if iLineKind <> LINEKIND_NO then
	nearestHx = 0 : nearestHy = 0
	! -----------------------------------------------------------------------------
	! LINEKIND_TO_x
	!	- 	calculate the nearest coordinates of head from the cloud polygon
	!		nearestHx, nearestHy
	! -----------------------------------------------------------------------------
		vx = posX - nearestPx
		vy = posY - nearestPy
		gosub "check_vector_direction_angle"	! returned angle
		gosub "set_connection_line_direction_angle"	! returned _angleExternalLine

		if iConnectionLine =  LINE_STRAIGHT then
			distanceHead_model = 0
			_angleExternalLine = angle
		endif

		if 	iShapeHead <> MARKER_HEAD_NONE &\
			iShapeHead <> MARKER_HEAD_CIRCLE &\
			iShapeHead <> MARKER_HEAD_LINE & iShapeHead <> MARKER_HEAD_GOST then
 
			!----------------------------------------------------------------------
			! Head origo
			!----------------------------------------------------------------------

			centerX = distanceHead_model * cos(_angleExternalLine - _totalRotate)
			centerY = distanceHead_model * sin(_angleExternalLine - _totalRotate)
			gosub "calculate_point_headform"

			if bFeedBackInput then
				poly2_b	nsp/3, 1 + 2*bFillHead + 4, penFillHead, backpenFillHead,
				use(nsp)
			endif

			buffer		= nsp/3
			nearestDist = 999999	
			line1X1 = get (1):	line1Y1 = get (1):	dummy = get (1)

			for iHead = 1 to buffer-1
	
				line1X2 = get (1):	line1Y2 = get (1):	dummy = get (1)

				if iConnectionLine =  LINE_BREAKPOINT then	
					line2X1 = posX
					line2Y1 = posY
				else
					line2X1 = nearestPx
					line2Y1 = nearestPy
				endif

				line2X2 = centerX
				line2Y2 = centerY
	
				gosub "segment_segment_intersection"
				! Result: state, cx,cy
	
				if state = 3 then
					dist = (posX - cx)^2 + (posY - cy)^2
					if dist < nearestDist then
						nearestHx = cx
						nearestHy = cy
						nearestDist = dist
					endif
				endif
	
				line1X1 = line1X2
				line1Y1 = line1Y2
			next iHead
		else
			if iShapeHead = MARKER_HEAD_LINE or iShapeHead = MARKER_HEAD_GOST then
				nearestHx = (distanceHead_model) * cos(_angleExternalLine - _totalRotate)
				nearestHy = (distanceHead_model) * sin(_angleExternalLine - _totalRotate)
			else	! Circle or None
				nearestHx = (distanceHead_model - AC_MarkerSize/2) * cos(_angleExternalLine - _totalRotate)
				nearestHy = (distanceHead_model - AC_MarkerSize/2) * sin(_angleExternalLine - _totalRotate)
			endif
		endif

	! -----------------------------------------------------------------------------
	! drawing the marker line
	! -----------------------------------------------------------------------------
		if iConnectionLine =  LINE_BREAKPOINT then
			! Marker Line from Origo to the Cloud
			! ---------------------------------------------------------------
			line2 posX, posY, nearestPx, nearestPy

			! Marker Line from Origo to the Head
			! ---------------------------------------------------------------
			line2 posX, posY, nearestHx, nearestHy
		else
			! Marker Line from Cloud Polygon to the Head
			! ---------------------------------------------------------------
			line2 nearestPx, nearestPy, nearestHx, nearestHy
		endif
	endif
endif

! ===================================================================
! Text Calculations
! ===================================================================

pen penMarkerText
style "markertext_oneRow"
text_length = max (stw(contentFirstRow), stw(contentSecondRow) * bDivisionLine)

text_length = text_length * PAPER_TO_MODEL
text_height = text_height * (1 + bDivisionLine) * PAPER_TO_MODEL

! ===================================================================
! Marker Head
! ===================================================================

pen penContourHead
fill typeFillHead
drawindex 20

nTrans = 0
usePut = 0

if _hasHead then
	! Place of Heads Origo ----------------------------------------------
	add2 posX, posY
	nTrans = nTrans + 1
	if iLineKind <> LINEKIND_NO and iConnectionLine = LINE_BREAKPOINT then

		! Custom Frame Hotspot
		if (iShapeHead = MARKER_HEAD_RECTANGLE |\
			iShapeHead = MARKER_HEAD_DIAMOND or iShapeHead = MARKER_HEAD_GOST ) then
			rot2 -_totalRotate
			add2 distanceHead_model * cos(_angleExternalLine), distanceHead_model * sin(_angleExternalLine)
			rot2 bVerticalTextPosition * 90
			hotspot2  0,					0,	unID, widthHeadHalf_m, 1+1024+128,	widthHead_mm : unID = unID + 1
			hotspot2  -1,					0,	unID, widthHeadHalf_m, 3+1024,		widthHead_mm : unID = unID + 1
			hotspot2  widthHeadHalf_model,	0,	unID, widthHeadHalf_m, 2+1024,		widthHead_mm : unID = unID + 1
	
			hotspot2  0,					0,	unID, widthHeadHalf_m, 1+1024+128,	widthHead_mm : unID = unID + 1
			hotspot2  1,					0,	unID, widthHeadHalf_m, 3+1024,		widthHead_mm : unID = unID + 1
			hotspot2  -widthHeadHalf_model,	0,	unID, widthHeadHalf_m, 2+1024,		widthHead_mm : unID = unID + 1
			del 3
		endif

		! Origo Hotspot
		rot2 _angleExternalLine - _totalRotate
		hotspot2 0,						0,	unID, distanceHead_m, 1+1024+128,	distanceHead_mm : unID = unID + 1
		hotspot2 -1,					0,	unID, distanceHead_m, 3+1024,		distanceHead_mm : unID = unID + 1
		hotspot2 distanceHead_model ,	0,	unID, distanceHead_m, 2+1024,		distanceHead_mm : unID = unID + 1
		del 1

		centerX = distanceHead_model * cos(_angleExternalLine - _totalRotate)
		centerY = distanceHead_model * sin(_angleExternalLine - _totalRotate)

		if iShapeHead = MARKER_HEAD_LINE then
			posAngle = 0
			if ((_angleExternalLine = 90 | _angleExternalLine = 270) and not(bVerticalTextPosition)) |\
				((_angleExternalLine = 0 | _angleExternalLine = 180) and bVerticalTextPosition) then
				posAngle = 90
			endif
			centerX = centerX + _widthHalfHead[iShapeHead][HEAD_SIZE_SIDE] * cos(_angleExternalLine - _totalRotate - posAngle)
			centerY = centerY + _widthHalfHead[iShapeHead][HEAD_SIZE_SIDE] * sin(_angleExternalLine - _totalRotate - posAngle)
		endif
	else
		centerX = 0
		centerY = 0
	endif

	! Draw the poligon of head from zero (last click) ----------------------------------------------
	if iShapeHead <> MARKER_HEAD_NONE & iShapeHead <> MARKER_HEAD_CIRCLE & iShapeHead <> MARKER_HEAD_LINE then

		! input centerX, centerY
		gosub "calculate_point_headform"
		if NSP>0 then
			poly2_b	nsp/3, 1 + 2*bFillHead + 4, penFillHead, backpenFillHead,
				get(nsp)
		endif

	else
		if iShapeHead = MARKER_HEAD_CIRCLE then
			poly2_b	2, 1 + 2*bFillHead + 4, penFillHead, backpenFillHead,
				centerX, centerY,		901,
				_widthHalfHead[MARKER_HEAD_CIRCLE][HEAD_SIZE_SIDE], 360, 	4001
		endif
	endif

	! Draw division line from origo ----------------------------------------------
	add2 centerX, centerY
	rot2 -_totalRotate
	nTrans = nTrans + 2

	if bDivisionLine then
		pen penDivisionLine
		if bVerticalTextPosition then
			line2 0, -_widthHalfHead[iShapeHead][HEAD_SIZE_DOWN], 0, _widthHalfHead[iShapeHead][HEAD_SIZE_UP]
		else
			line2 -_widthHalfHead[iShapeHead][HEAD_SIZE_SIDE], 0, _widthHalfHead[iShapeHead][HEAD_SIZE_SIDE], 0
		endif
	endif
	


	! ===================================================================
	! Text
	! ===================================================================

	if bVerticalTextPosition then
		rot2 90
		nTrans = nTrans + 1
	endif

	
	if not(bDivisionLine) then
		pen penMarkerText
		style "markertext_oneRow"
		if iShapeHead = MARKER_HEAD_GOST then
			add2 0, _widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_UP]
			nTrans = nTrans + 1
		endif
		text2 0,0,contentFirstRow
	else
		pen penMarkerText
		style "markertext_1stRow"
		text2 0,0,contentFirstRow

		pen penMarkerSecondText
		style "markertext_2ndRow"
		text2 0,0,contentSecondRow
	endif
	del nTrans

endif



END


! ==============================================================================
! Segment - Point Projection
! ------------------------------------------------------------------------------
! Input variables:
!	x1,y1, x2,y2:	Line Segment
!	px,py:			Point
!
! Returned variables:
!	state:			0 = no intersection point
!					1 = valid intersection point
!	px, py:			Projected Point
! ==============================================================================

"segment_point_projection":

	x21 = px
	y21 = py
	x22 = px + (y1 - y2)
	y22 = py - (x1 - x2)

	lliDiv = (x1-x2) * (y21-y22) - (y1-y2) * (x21-x22)

	segLength = ((x1 - x2)^2 + (y1 - y2)^2)

	if abs(lliDiv) > EPS then
		! Intersection

		temp1 = x1  * y2  - y1  * x2
		temp2 = x21 * y22 - y21 * x22

		tempx = temp1 * (x21-x22) - (x1-x2) * temp2
		tempy = temp1 * (y21-y22) - (y1-y2) * temp2

		state = 1
		px = (tempx / lliDiv)
		py = (tempy / lliDiv)

		endDist1 = ((px - x1)^2 + (py - y1)^2)
		endDist2 = ((px - x2)^2 + (py - y2)^2)
		if endDist1 > segLength | endDist2 > segLength then
			if endDist1 < endDist2 then
				px = x1
				py = y1
			else
				px = x2
				py = y2
			endif
		endif
	else
		! No Intersection
		state = 0
		px = 0
		py = 0
	endif

return

! ==============================================================================
! Segment - Segment intersection
! ==============================================================================
! Input:
!	line1X1:		line1 startpoint X
!	line1Y1:		line1 startpoint Y
!	line1X2:		line1 endpoint X
!	line1Y2:		line1 endpoint Y
!	line2X1:		line2 startpoint X
!	line2Y1:		line2 startpoint Y
!	line2X2:		line2 endpoint X
!	line2Y2:		line2 endpoint Y
!
! Output:
!	ret:			output status
!						-1: no intersection, segments is not paralel
!						 0: no intersection, parallel segments
!						 1: intersection point lies on S1 segment, but not lies on S2
!						 2: intersection point lies on S2 segment, but not lies on S1
!						 3: intersection point lies on both segments
!	cx:				intersection point X
!	cy:				intersection point Y
! ==============================================================================

"segment_segment_intersection":
	gosub "line_line_intersection"	! Intersection of Line - Line

	if state then
		state = 0

		if abs(line1X1 - line1X2) < EPS then
			if (line1Y1-EPS <= cy & cy <= line1Y2+EPS) | (line1Y1+EPS >= cy & cy >= line1Y2-EPS) then state = 1
		else
			if (line1X1-EPS <= cx & cx <= line1X2+EPS) | (line1X1+EPS >= cx & cx >= line1X2-EPS) then state = 1
		endif
		if abs(line2X1 - line2X2) < EPS then
			if (line2Y1-EPS <= cy & cy <= line2Y2+EPS) | (line2Y1+EPS >= cy & cy >= line2Y2-EPS) then state = state + 2
		else
			if (line2X1-EPS <= cx & cx <= line2X2+EPS) | (line2X1+EPS >= cx & cx >= line2X2-EPS) then state = state + 2
		endif

		if state = 0 then state = -1
	endif
return

! ==============================================================================
! Line - Line intersection
! ==============================================================================
! Input:
!	line1X1:		line1 startpoint X
!	line1Y1:		line1 startpoint Y
!	line1X2:		line1 endpoint X
!	line1Y2:		line1 endpoint Y
!	line2X1:		line2 startpoint X
!	line2Y1:		line2 startpoint Y
!	line2X2:		line2 endpoint X
!	line2Y2:		line2 endpoint Y
!
! Output:
!	state:			output status
!						 0: no intersection, parallel lines
!						 1: lines are intersects
!	cx:				intersection point X
!	cy:				intersection point Y
! ==============================================================================

"line_line_intersection":

	lliDiv = (line1X1-line1X2) * (line2Y1-line2Y2) - (line1Y1-line1Y2) * (line2X1-line2X2)

	if abs(lliDiv) > EPS then
		! Intersection

		temp1 = line1X1 * line1Y2 - line1Y1 * line1X2
		temp2 = line2X1 * line2Y2 - line2Y1 * line2X2

		tempx = temp1 * (line2X1-line2X2) - (line1X1-line1X2) * temp2
		tempy = temp1 * (line2Y1-line2Y2) - (line1Y1-line1Y2) * temp2

		state = 1
		cx = (tempx / lliDiv)
		cy = (tempy / lliDiv)
	else
		! No Intersection
		state = 0
		cx = 0
		cy = 0
	endif

return

! ==============================================================================
! Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	xo,yo,ro:			circle
!	x1,y1, x2,y2		line
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = one intersection point (tangential line)
!						2 = two intersection points
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
! ==============================================================================

"circle_line_intersection":
	tempX1 = x1 - xo: tempY1 = y1 - yo
	tempX2 = x2 - xo: tempY2 = y2 - yo

	if abs(tempX2 - tempX1) < EPS then
		if abs(ro - tempX1) < EPS then
			state = 1
			xa = tempX1
			ya = 0
			xb = tempX1
			yb = 0
		else
			state = 2
			xa = tempX1
			ya = sqr(ro^2 - tempX1^2)
			xb = tempX1
			yb = -sqr(ro^2 - tempX1^2)
		endif
	else
		kf = (tempY2 - tempY1) / (tempX2 - tempX1)
		ad = 1 + kf^2
		bd = 2 * tempY1 * kf - 2 * tempX1 * kf^2
		cd = tempY1^2 - 2 * tempX1 * tempY1 * kf + tempX1^2 * kf^2 - ro^2

		if bd^2 - 4 * ad * cd < 0 then
			state = 0: xa = 0: ya = 0: xb = 0: yb = 0
		else
			xa = (-bd + sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			ya = tempY1 + (xa - tempX1) * kf
			xb = (-bd - sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			yb = tempY1 + (xb - tempX1) * kf

			if abs(xa - xb) < EPS then state = 1 else state = 2
		endif
	endif

	if state = 2 then
		da = sqr((tempX1 - xa)^2 + (tempY1 - ya)^2)
		db = sqr((tempX1 - xb)^2 + (tempY1 - yb)^2)

		if db < da then
			xxo = xa: yyo = ya
			xa = xb:  ya = yb
			xb = xxo: yb = yyo
		endif
	endif

	xa = xa + xo: ya = ya + yo
	xb = xb + xo: yb = yb + yo
return

! ==============================================================================
! Segment - Point intersection
! ==============================================================================
! Input:
!	x1:		line1 startpoint X
!	y1:		line1 startpoint Y
!	x2:		line1 endpoint X
!	y2:		line1 endpoint Y
!	cx
!	cy
!
! Output:
!	status:			output status
!						-1: no intersection, segments is not paralel
!						 0: no intersection, parallel segments
!						 1: intersection point lies on S1 segment
! ==============================================================================

"segment_point_status":
	if state > 0 then
		state = 0

		if abs(x1 - x2) < EPS then
			if (y1-EPS <= cy & cy <= y2+EPS) | (y1+EPS >= cy & cy >= y2-EPS) then state = 1
		else
			if (x1-EPS <= cx & cx <= x2+EPS) | (x1+EPS >= cx & cx >= x2-EPS) then state = 1
		endif
		if state = 0 then state = -1
	endif
return


! ==============================================================================
! Marker Line Direction Angle
! ------------------------------------------------------------------------------
! Input variables:
!	angle:				angle of vector
!	_totalRotate		angle of oriented view
! Input parameter:
!	iRotateHead			HEAD_HORIZONTAL - always horizontal
!						HEAD_ROTATED - automatic calculating could be horizontal and vertical
! Returned variables:
!	_angleExternalLine:		marker line direction
! ==============================================================================

"set_connection_line_direction_angle":

	angle = angle + _totalRotate
	if angle < -eps then
		angle = angle + 360
	else
		angle = angle MOD 360
	endif

	if iRotateHead = HEAD_HORIZONTAL then
		if angle > 270 - EPS | angle <= 90  + EPS then _angleExternalLine = 0
		if angle > 90 - EPS & angle <= 270 + EPS then _angleExternalLine = 180
	else
		if angle > 315 - EPS | angle <= 45  + EPS then _angleExternalLine = 0
		if angle > 45  + EPS & angle <= 135 - EPS then _angleExternalLine = 90
		if angle > 135 - EPS & angle <= 225 + EPS then _angleExternalLine = 180
		if angle > 225 + EPS & angle <= 315 - EPS then _angleExternalLine = 270
	endif

return

! ==============================================================================
! Cloud polygon
! ------------------------------------------------------------------------------
! Input variables:
!	AC_PolygonCoords[i][1], AC_PolygonCoords[i][2] :	polygon coords
!	_lengthVector
!	radiusCloud_model
!	numRatioCloud
!
! Returned variables:
!	stack
! ==============================================================================

"standard_cloudy":

	put AC_PolygonCoords[i][1], AC_PolygonCoords[i][2], 1

	if iTypeCloud = CLOUD_BISCUIT then
		_numCloud[i] = max(1, INT(_lengthVector[i] / (radiusCloud_model*2)))
		for j = 1 to _numCloud[i]
			_radCloud[i][j] = _lengthVector[i] / _numCloud[i] /2
		next j
	endif

	if iTypeCloud = CLOUD_PERIODIC then
		_numCloud[i] = 2
		_perCloud = (numRatioCloud + 1) / min(1, numRatioCloud)
		_radCloud[i][1] = (_lengthVector[i] / _perCloud) * (1 / min(1, numRatioCloud)) /2
		_radCloud[i][2] = (_lengthVector[i] -_radCloud[i][1] * 2) /2
	endif

	if iTypeCloud = CLOUD_RANDOM then
		! inicialization
		_numCloud[i] 		= 1
		_radCloud[i][1] 	= 1

		! every vector has a own sample depending the distance from origo to draw the random cirlces
		if i = (AC_PolygonNodes - 1) then
			seed = _distancePointfromOrigo[1]
		else
			seed = _distancePointfromOrigo[i + 1]
		endif
		seed = seed + _distancePointfromOrigo[i]

		_length = _lengthVector[i]
		_minDivison = (minradiusCloud_model + maxradiusCloud_model) * 2
		_minDiameter = (min(minradiusCloud_model,maxradiusCloud_model)*2)
		_maxDiameter = (max(minradiusCloud_model,maxradiusCloud_model)*2)

		inum = 1
		while _length > EPS do
			! schema for dummy random sample
			seed = (seed * 214013 + 2531011) MOD (2^32)

			_numCloud[i] = inum

			! manual settings for the last circles
			if _length < _minDivison + EPS then
				if _length > _maxDiameter then
					_radCloud[i][inum] = min(minradiusCloud_model,maxradiusCloud_model)
					_restDiv = (_length - _radCloud[i][inum] * 2)
				else
					_radCloud[i][inum] = _length/2
					_restDiv = -1
				endif
			else
				! manual settings if the minimum and maximum range are the same
				if abs(_minDiameter - _maxDiameter) < EPS then
					_radCloud[i][inum] = _minDiameter/2
				else
				! calculating radius with random schema
					_radCloud[i][inum] = ((seed / 65536) MOD (maxradiusCloud_model - minradiusCloud_model)) + _minDiameter/2
				endif
				_restDiv = (_length - _radCloud[i][inum] * 2)
			endif
			_length = _restDiv

			inum = inum + 1
		endwhile
	endif

	bx = AC_PolygonCoords[i][1]
	by = AC_PolygonCoords[i][2]
	dim _radius[]
	for j = 1 to _numCloud[i]
		if j = 1 then
			_radius[i] = _radCloud[i][j]
		else
			_radius[i] = (_radCloud[i][j-1] + _radCloud[i][j])
		endif
		bx = bx + _radius[i] * cos(_angleVector[i])
		by = by + _radius[i] * sin(_angleVector[i])
		put bx, by, 900
		put 0, 180, 4001
	next j


return

! ==============================================================================================
"calculate_point_headform" :
! ----------------------------------------------------------------------------------------------
! input : 	
! 	centerX			Head Origo coord x
! 	centerY			Head Origo coord y
! 	_totalRotate		angle of oriented view
! 	AC_MarkerSize		height of the marker head
!
! output:
!	stack filled with head polygon relative coords (from head center)
! ==============================================================================================

	! Shape Type --------------------------------------------------------
	if iShapeHead = MARKER_HEAD_CIRCLE then

	endif

	if iShapeHead = MARKER_HEAD_TRIANGLE_UP then
		numPeak = 3
		alfa = 90 - _totalRotate
		usePut = 1
	endif

	if iShapeHead = MARKER_HEAD_TRIANGLE_DOWN then
		numPeak = 3
		alfa = 30 - _totalRotate
		usePut = 1
	endif

	if iShapeHead = MARKER_HEAD_RECTANGLE then
		_vectorRect = SQR(_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_SIDE]^2 + _widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_UP]^2)
		_alphaRect = ATN (_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_UP]/_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_SIDE])
		alfa1 = _alphaRect - _totalRotate
		alfa2 = 180 - _alphaRect - _totalRotate
		alfa3 = 180 + _alphaRect - _totalRotate
		alfa4 = 360 - _alphaRect - _totalRotate
		put	_vectorRect * cos(alfa1) + centerX,	_vectorRect * sin(alfa1) + centerY,	 1
		put _vectorRect * cos(alfa2) + centerX,	_vectorRect * sin(alfa2) + centerY,	 1
		put _vectorRect * cos(alfa3) + centerX,	_vectorRect * sin(alfa3) + centerY,	 1
		put _vectorRect * cos(alfa4) + centerX,	_vectorRect * sin(alfa4) + centerY,	 1
		put	_vectorRect * cos(alfa1) + centerX,	_vectorRect * sin(alfa1) + centerY,	 1
	endif

	if iShapeHead = MARKER_HEAD_PENTAGON_UP then
		numPeak = 5
		alfa = 90- _totalRotate
		usePut = 1
	endif

	if iShapeHead = MARKER_HEAD_PENTAGON_DOWN then
		numPeak = 5
		alfa = 54- _totalRotate
		usePut = 1
	endif

	if iShapeHead = MARKER_HEAD_HEXAGON then
		numPeak = 6
		alfa = 90 - _totalRotate
		usePut = 1
	endif

	if iShapeHead = MARKER_HEAD_HEXAGON_ROTATED then
		numPeak = 6
		alfa = 60 - _totalRotate
		usePut = 1
	endif

	if iShapeHead = MARKER_HEAD_OCTOGON then
		numPeak = 8
		alfa = 67.5 - _totalRotate
		usePut = 1
	endif

	if iShapeHead = MARKER_HEAD_OCTOGON_ROTATED then
		numPeak = 8
		alfa = 0 - _totalRotate
		usePut = 1
	endif

	if iShapeHead = MARKER_HEAD_DIAMOND then
		alfa = -_totalRotate
		put	_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_SIDE] * cos(alfa) + centerX,	_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_SIDE]  * sin(alfa) + centerY,		 1
		put _widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_UP] * cos(alfa+90) + centerX,	_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_UP] * sin(alfa+90) + centerY,			 1
		put _widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_SIDE] * cos(alfa+180) + centerX, _widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_SIDE] * sin(alfa+180) + centerY,		 1
		put _widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_DOWN] * cos(alfa+270) + centerX,_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_DOWN] * sin((alfa+270)) + centerY,	 1
		put	_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_SIDE] * cos(alfa) + centerX,	_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_SIDE]  * sin(alfa) + centerY,		 1
	endif
	if iShapeHead = MARKER_HEAD_GOST then
		put	-_widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_SIDE] + _widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_DOWN] + centerX, _widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_UP]*2 + centerY, 1
		put	_widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_SIDE] + centerX, _widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_UP]*2 + centerY, 1
		put	_widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_SIDE] - _widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_DOWN] + centerX, centerY, 1
		put	-_widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_SIDE] + centerX, centerY, 1
	endif
	if usePut then
		for i = 1 to numPeak + 1
			put AC_MarkerSize/2 * cos(alfa) + centerX, AC_MarkerSize/2 * sin(alfa) + centerY, 1
			alfa = alfa + 360 / numPeak
		next i

	endif

!		poly2_b	nsp/3, 1 + 2*bFillHead + 4, penFillHead, backpenFillHead,
!			get(nsp)

return

! ==============================================================================================
"set_array_widthHalfHead":
! ----------------------------------------------------------------------------------------------
! input : 	
! 	widthHead_model
! 	AC_MarkerSize		height of the marker head
!
! output:
!	_widthHalfHead temporary array
! ==============================================================================================

	if _hasHead then
		_widthHalfHead[MARKER_HEAD_CIRCLE][HEAD_SIZE_SIDE] 	= AC_Markersize/2
		_widthHalfHead[MARKER_HEAD_CIRCLE][HEAD_SIZE_UP] 	= AC_Markersize/2
		_widthHalfHead[MARKER_HEAD_CIRCLE][HEAD_SIZE_DOWN] 	= AC_Markersize/2
	
		_widthHalfHead[MARKER_HEAD_TRIANGLE_UP][HEAD_SIZE_SIDE] 	= AC_Markersize/2 * tan(30)
		_widthHalfHead[MARKER_HEAD_TRIANGLE_UP][HEAD_SIZE_UP] 		= AC_Markersize/2
		_widthHalfHead[MARKER_HEAD_TRIANGLE_UP][HEAD_SIZE_DOWN] 	= AC_Markersize/2 * sin(30)
	
		_widthHalfHead[MARKER_HEAD_TRIANGLE_DOWN][HEAD_SIZE_SIDE] 	= AC_Markersize/2 * tan(30)
		_widthHalfHead[MARKER_HEAD_TRIANGLE_DOWN][HEAD_SIZE_UP] 	= AC_Markersize/2 * sin(30)
		_widthHalfHead[MARKER_HEAD_TRIANGLE_DOWN][HEAD_SIZE_DOWN] 	= AC_Markersize/2
	
		if not(bVerticalTextPosition) then
			_widthHalfHead[MARKER_HEAD_RECTANGLE][HEAD_SIZE_SIDE] 		= widthHead_model/2
			_widthHalfHead[MARKER_HEAD_RECTANGLE][HEAD_SIZE_UP] 		= AC_Markersize/2
			_widthHalfHead[MARKER_HEAD_RECTANGLE][HEAD_SIZE_DOWN] 		= AC_Markersize/2
		else
			_widthHalfHead[MARKER_HEAD_RECTANGLE][HEAD_SIZE_SIDE] 		= AC_Markersize/2
			_widthHalfHead[MARKER_HEAD_RECTANGLE][HEAD_SIZE_UP] 		= widthHead_model/2
			_widthHalfHead[MARKER_HEAD_RECTANGLE][HEAD_SIZE_DOWN] 		= widthHead_model/2
		endif
	
		_widthHalfHead[MARKER_HEAD_PENTAGON_UP][HEAD_SIZE_SIDE] 	= AC_Markersize/2 * sin(36) + AC_Markersize/2 * cos(36) * tan(18)
		_widthHalfHead[MARKER_HEAD_PENTAGON_UP][HEAD_SIZE_UP] 		= AC_Markersize/2
		_widthHalfHead[MARKER_HEAD_PENTAGON_UP][HEAD_SIZE_DOWN] 	= AC_Markersize/2 * cos(36)
	
		_widthHalfHead[MARKER_HEAD_PENTAGON_DOWN][HEAD_SIZE_SIDE] 	= AC_Markersize/2 * sin(36) + AC_Markersize/2 * cos(36) * tan(18)
		_widthHalfHead[MARKER_HEAD_PENTAGON_DOWN][HEAD_SIZE_UP] 	= AC_Markersize/2 * cos(36)
		_widthHalfHead[MARKER_HEAD_PENTAGON_DOWN][HEAD_SIZE_DOWN] 	= AC_Markersize/2
	
		_widthHalfHead[MARKER_HEAD_HEXAGON][HEAD_SIZE_SIDE]			= AC_Markersize/2 * cos(30)
		_widthHalfHead[MARKER_HEAD_HEXAGON][HEAD_SIZE_UP] 			= AC_Markersize/2
		_widthHalfHead[MARKER_HEAD_HEXAGON][HEAD_SIZE_DOWN] 		= AC_Markersize/2
	
		_widthHalfHead[MARKER_HEAD_HEXAGON_ROTATED][HEAD_SIZE_SIDE] = AC_Markersize/2
		_widthHalfHead[MARKER_HEAD_HEXAGON_ROTATED][HEAD_SIZE_UP] 	= AC_Markersize/2 * cos(30)
		_widthHalfHead[MARKER_HEAD_HEXAGON_ROTATED][HEAD_SIZE_DOWN] = AC_Markersize/2 * cos(30)
	
		_widthHalfHead[MARKER_HEAD_OCTOGON][HEAD_SIZE_SIDE] 	= AC_Markersize/2 * cos(22.5)
		_widthHalfHead[MARKER_HEAD_OCTOGON][HEAD_SIZE_UP] 		= AC_Markersize/2 * cos(22.5)
		_widthHalfHead[MARKER_HEAD_OCTOGON][HEAD_SIZE_DOWN] 	= AC_Markersize/2 * cos(22.5)
	
		_widthHalfHead[MARKER_HEAD_OCTOGON_ROTATED][HEAD_SIZE_SIDE] 	= AC_Markersize/2
		_widthHalfHead[MARKER_HEAD_OCTOGON_ROTATED][HEAD_SIZE_UP] 		= AC_Markersize/2
		_widthHalfHead[MARKER_HEAD_OCTOGON_ROTATED][HEAD_SIZE_DOWN] 	= AC_Markersize/2
	
		if not(bVerticalTextPosition) then
			_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_SIDE] 	= widthHead_model/2
			_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_UP] 		= AC_Markersize/2
			_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_DOWN] 	= AC_Markersize/2
		else
			_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_SIDE] 	= AC_Markersize/2
			_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_UP] 		= widthHead_model/2
			_widthHalfHead[MARKER_HEAD_DIAMOND][HEAD_SIZE_DOWN] 	= widthHead_model/2
		endif
	
		_widthHalfHead[MARKER_HEAD_LINE][HEAD_SIZE_SIDE] 	= widthHead_model/2
		_widthHalfHead[MARKER_HEAD_LINE][HEAD_SIZE_UP] 		= widthHead_model/2
		_widthHalfHead[MARKER_HEAD_LINE][HEAD_SIZE_DOWN] 	= widthHead_model/2

		_widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_SIDE] 	= widthHead_model/2
		_widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_UP] 	= AC_Markersize/2
		_widthHalfHead[MARKER_HEAD_GOST][HEAD_SIZE_DOWN] 	= TAN(30)*AC_Markersize
	
		if not(bVerticalTextPosition) then
			_widthHalfHead[MARKER_HEAD_NONE][HEAD_SIZE_SIDE] 	= widthHead_model/2
			_widthHalfHead[MARKER_HEAD_NONE][HEAD_SIZE_UP] 		= widthHead_model/2
			_widthHalfHead[MARKER_HEAD_NONE][HEAD_SIZE_DOWN] 	= widthHead_model/2
		else
			_widthHalfHead[MARKER_HEAD_NONE][HEAD_SIZE_SIDE] 	= widthHead_model/2
			_widthHalfHead[MARKER_HEAD_NONE][HEAD_SIZE_UP] 		= widthHead_model/2
			_widthHalfHead[MARKER_HEAD_NONE][HEAD_SIZE_DOWN] 	= widthHead_model/2
		endif
	endif
return

! ===================================================================
! Drawing Hidden Easter Egg
! ===================================================================
"draw_easteregg":

	dim _nodeposPerpendicular[][2]
	_posPerpendicularX = 0 : _posPerpendicularY = 0

	lowY = 9999999
	highY = -9999999
	numLowY = 0  : numHighY = 0

	for iEgg = 1 to AC_PolygonNodes - 1 
		highY =	max(highY, AC_PolygonCoords[iEgg][2])
		lowY =	min(lowY, AC_PolygonCoords[iEgg][2])
	next iEgg

	for iEgg = 1 to AC_PolygonNodes - 1
		if abs(AC_PolygonCoords[iEgg][2] - highY) < EPS then
			numHighY = numHighY + 1
			_nodeposPerpendicular[numHighY][1] = AC_PolygonCoords[iEgg][1]
			_nodeposPerpendicular[numHighY][2] = AC_PolygonCoords[iEgg][2]

			! calculate the length of vector
			! --------------------------------------
			vx2 = _nodeposPerpendicular[numHighY][1]
			vy2 = _nodeposPerpendicular[numHighY][2]
			vx1 = 0
			vy1 = 0
			gosub "calculation_vector_length"

			if lengthfromHead < _templengthVector then
				_posPerpendicularX = _nodeposPerpendicular[numHighY][1]
				_posPerpendicularY = _nodeposPerpendicular[numHighY][2]
			endif
			lengthfromHead = _templengthVector
		endif

		if abs(AC_PolygonCoords[iEgg][2] - lowY) < EPS then numLowY = numLowY + 1
	next iEgg

	if numHighY = 2 and numLowY = 4 then
		add2 _posPerpendicularX, _posPerpendicularY

		! calculate the length of vector
		! --------------------------------------
		vx2 = _nodeposPerpendicular[1][1]
		vy2 = _nodeposPerpendicular[1][2]
		vx1 = _nodeposPerpendicular[2][1]
		vy1 = _nodeposPerpendicular[2][2]
		gosub "calculation_vector_length"	! returned  _templengthVector

		mul2  1/2 *  _templengthVector / 6.652 , 1/2 *  _templengthVector / 5.875 !  6.652376 , 5.874670 ! A/6.652 , B/5.875

		gosub "draw_sheephead"

		del 2
	endif

return

"draw_sheephead":
! A 6652, B 5875
spline2a      5,      2, 
        -1.462806924883, 1.213729460734,            0,            0,            0, 
        -3.001647523691, 1.882617670684, 184.8102224932, 0.8626380456399, 0.0515818108589, 
        -3.13867381209, 1.831273775225, 229.7698826915, 0.05070509770323, 0.08781228901577, 
        -3.081631522984, 1.59904754631, 307.82439341, 0.0930796662307, 0.5839367853911, 
        -1.637418434888, 0.6367522972408, 327.6145022132, 0.2325225849634,            0
spline2a      7,      2, 
        -1.462806924883, 1.213729460734,            0,            0,            0, 
        -1.612335632903, 1.418704817114, 129.7979168026, 0.1269382928864, 0.4612915196699, 
        -2.804047941567, 2.03938687603, 171.0653255825, 0.4633194391976, 0.2023064883303, 
        -3.329274104522, 1.916157727706, 237.6787871728, 0.1943545284217, 0.2125275766289, 
        -3.158040479736, 1.358798846914, 311.0192943517, 0.2228287264787, 0.4891018044228, 
        -1.919815400265, 0.6552776641342, 350.4944163365, 0.4887816500814, 0.09775161573636, 
        -1.637418434888, 0.6367522972408, 22.38088320968, 0.04015839495368,            0
spline2a      8,      2, 
        1.722265191958, 1.369425847384,            0,            0,            0, 
        1.772877223843, 1.56554747094, 69.47932593457, 0.1014211631169, 0.2581979362188, 
        2.30430355864, 2.096973805737, 28.18197548157, 0.2601691556868, 0.2591603726132, 
        3.038178020978, 2.242483397407, 346.3910084264, 0.2568983783142, 0.07697563030885, 
        3.231867304149, 2.132125925733, 307.0513830919, 0.07637706672501, 0.09306752020001, 
        3.271529993102, 1.866691007352, 259.5445485484, 0.09405714999007, 0.3346072195229, 
        2.615105057213, 1.176384708828, 203.848444684, 0.3395434115233, 0.3147891255886, 
        2.013284375299, 0.9961621122291,            0, 7.105427357601E-015,            0
spline2a      8,      2, 
        2.013284375299, 0.9961621122291,            0,            0,            0, 
        2.404770739631, 1.203575222151, 26.07852548748, 0.2215383871443, 0.2937273502758, 
        3.076137044892, 1.71105706261, 67.39793564261, 0.2882599578557, 0.05407258710112, 
        3.115203980908, 1.867481341418, 83.87209497783, 0.05410556869236, 0.05629746960895, 
        3.088790052863, 2.027382261894, 126.2192339222, 0.05561401919644, 0.08111844943962, 
        2.866272219466, 2.078497471847, 187.0140885906, 0.0839077464514, 0.4050897281606, 
        1.8361422637, 1.514935439054, 229.5966643091, 0.4052754199074, 0.0924039229305, 
        1.722265191958, 1.369425847384,            0, 7.105427357601E-015,            0
spline2a      4,      2, 
        -1.379723809596, 1.741134354981,            0,            0,            0, 
        -1.340183159686, 1.973984848898, 72.49830727357, 0.1184108098141, 0.2049584642244, 
        -0.932400012622, 2.386236852627, 16.90251314034, 0.2045361730063, 0.2053697138371, 
        -0.35967911409, 2.296047578186, 322.0202488149, 0.1760747338875,            0
spline2a      3,      2, 
        -0.35967911409, 2.296047578186,            0,            0,            0, 
        -0.08646445317309, 2.68076403407, 20.05181226743, 0.2476894135188, 0.2132905342232, 
        0.4231928713952, 2.447537015161, 295.2293132341, 0.1961142458859,            0
spline2a      3,      2, 
        0.4231928713952, 2.447537015161,            0,            0,            0, 
        0.871470356042, 2.553161395537, 322.8134851513, 0.2513029466391, 0.1447182430718, 
        1.002673185834, 2.195239932784, 246.4968398284, 0.0906601381834,            0
spline2a      3,      2, 
        1.002673185834, 2.195239932784,            0,            0,            0, 
        1.467107106668, 2.313848509553, 342.2668515446, 0.2489648604894, 0.1595020210346, 
        1.744842890519, 2.012709639241, 262.1073692591, 0.09926621420051,            0
spline2a      4,      2, 
        -1.379723809596, 1.741134354981,            0,            0,            0, 
        -1.36311471613, 2.368909970971, 63.61140790301, 0.3221938759708, 0.2876131833683, 
        -0.6543418995372, 2.70241768449, 350.1334032134, 0.2891491091376, 0.08714508055951, 
        -0.4322841242566, 2.574093294925, 317.3311055119, 0.1336129526413,            0
spline2a      3,      2, 
        -0.4322841242566, 2.574093294925,            0,            0,            0, 
        0.03690511833423, 2.95344410964, 354.8618519507, 0.3233041240605, 0.2220732586325, 
        0.4799484349887, 2.620886399069, 268.2019743013, 0.09361378424401,            0
spline2a      3,      2, 
        0.4799484349887, 2.620886399069,            0,            0,            0, 
        0.8766375116287, 2.768424827525, 344.5008819924, 0.2236981041455, 0.2614074319109, 
        1.086238400283, 2.320377459749, 207.9940161522, 0.05352803085541,            0
spline2a      3,      2, 
        1.086238400283, 2.320377459749,            0,            0,            0, 
        1.421756612049, 2.445898796373, 357.1451933258, 0.1830663794467, 0.291108287041, 
        1.744842890519, 2.012709639241, 218.6483937178, 0.08646458840327,            0
spline2a     13,      2, 
        -0.3492675208874, 0.3480909543309,            0,            0,            0, 
        -0.4151686040715, 0.5545810149745, 122.184736672, 0.1092790656682, 0.07807505365693, 
        -0.5799213120318, 0.7193337229348, 140.2598012672, 0.07833677360249, 0.04448992302389, 
        -0.6889073564975, 0.7947057326781, 156.0968897808, 0.04437702244609, 0.06645898328059, 
        -0.8845959260162, 0.8241325852373, 177.670186255, 0.0667659230677, 0.0265285543391, 
        -0.9640484279261, 0.8241325852373, 184.3967110049, 0.02651204751805, 0.03585770625781, 
        -1.068513754511, 0.80059110319, 201.0998582704, 0.03584716189063, 0.02290195641854, 
        -1.122953431746, 0.762336194863, 236.2720644515, 0.02271654069879, 0.04272226829705, 
        -1.11265403335, 0.6416860993702, 296.4266452917, 0.04375831031234, 0.03190873567135, 
        -1.058214356116, 0.5637049400883, 313.5078220918, 0.03190658421672, 0.03659519810091, 
        -0.9699337984379, 0.500437207086, 337.3584350973, 0.03654220291765, 0.034200928461, 
        -0.8698824997366, 0.4827810955505, 0.4621314646031, 0.03425204272695, 0.06863601214457, 
        -0.7345189779643, 0.503379892342,            0, 7.105427357601E-015,            0
spline2a      7,      2, 
        -0.7345189779643, 0.503379892342,            0,            0,            0, 
        -0.8046769245933, 0.5476322914999, 40.9050585617, 0.06087902687429, 0.03684809561535, 
        -0.7208921360567, 0.6068947029038, 72.78623562349, 0.03553889724661, 0.02493040144651, 
        -0.7198055516847, 0.6799410076972, 72.60928895197, 0.02487842182899, 0.03618090710834, 
        -0.6418243924028, 0.6416860993702, 318.2076773922, 0.04672095785418, 0.04565532593227, 
        -0.5314736953057, 0.5607622548324, 322.7551392627, 0.04569378015496, 0.1408306813806, 
        -0.3492675208874, 0.3480909543309,            0, 1.42108547152E-014,            0
spline2a      8,      2, 
        1.698653586865, 0.5518836160612,            0,            0,            0, 
        1.677296754352, 0.7013814436548, 90.87275755326, 0.07563862333675, 0.05027285458087, 
        1.710857491159, 0.8447773191017, 58.66773028017, 0.05008136500822, 0.0533703388269, 
        1.835947510166, 0.9332556252285, 8.523429528622, 0.05323619169316, 0.02941137151117, 
        1.915272888072, 0.9118987927151, 314.1520822121, 0.02910783246571, 0.03972277643335, 
        1.939680696659, 0.7990126780016, 269.3707170047, 0.04049228920013, 0.06781705260279, 
        1.893916055559, 0.612903137528, 221.1222441339, 0.06624434850959, 0.06956915486971, 
        1.762724084405, 0.5854443528679,            0, 7.105427357601E-015,            0
spline2a      7,      2, 
        1.762724084405, 0.5854443528679,            0,            0,            0, 
        1.78637385727, 0.6250623130055, 63.73489684855, 0.02309078623536, 0.02689166388849, 
        1.78637385727, 0.6927440738917, 146.9127839513, 0.02522902410744, 0.004750285572484, 
        1.773131773619, 0.6971581017756, 176.7118302327, 0.004748237126632, 0.023335653554, 
        1.737819550547, 0.6456611097969, 261.0217576359, 0.02505173403573, 0.01967150907063, 
        1.726048809524, 0.5882787473065, 246.1293301898, 0.01960193244568, 0.02293210229109, 
        1.698653586865, 0.5518836160612,            0,            0,            0
spline2a     10,      2, 
        1.85209729385, 0.5191382598017,            0,            0,            0, 
        1.663530022651, 0.1250538503287, 264.7445107396, 0.2218827833399, 0.2581415135197, 
        1.908887099017, -0.5976739549383, 288.3800979239, 0.2619783430727, 0.1995306871972, 
        1.963635601906, -1.189240185647, 267.5148567779, 0.200092622767, 0.2214530129647, 
        1.734562104184, -1.649238455453, 174.6991818167, 0.197945846735, 0.1312746289144, 
        1.539457000074, -1.386409025423, 77.99311084049, 0.1311298596677, 0.01424855557069, 
        1.555474620054, -1.347465851734, 53.81854956254, 0.01419901517035, 0.02002193733518, 
        1.602625945155, -1.311061511738, 30.15535364876, 0.02009748334256, 0.08484956069598, 
        1.806544526089, -1.164195413995, 52.22661493143, 0.08441414854323, 0.1352635612244, 
        1.877522094462, -0.9088880411916,            0, 7.105427357601E-015,            0
spline2a      3,      2, 
        1.877522094462, -0.9088880411916, 302.5688681914,            0, 0.03241207153661, 
        1.646642609092, -1.16107385967, 207.7344102802, 0.1538799540827, 0.2773253917361, 
        0.9356203785141, -0.9135700085829, 130.1165851185, 0.2854867860723,            0
spline2a      9,      2, 
        0.9356203785141, -0.9135700085829,            0,            0,            0, 
        1.123421616065, -1.226288717302, 326.6574578597, 0.1871472044248, 0.1025053351851, 
        1.409694241568, -1.335281014993, 338.3654866464, 0.1028783708849, 0.01792736386313, 
        1.45394402401, -1.363582640602, 306.237637375, 0.01778177926879, 0.01027335470722, 
        1.465626969456, -1.391785425128, 284.738512047, 0.01030672763901, 0.07114066041973, 
        1.460648768883, -1.597419200883, 243.9207311994, 0.07042207181014, 0.110060981726, 
        1.17747693875, -1.721272809049, 181.8111814165, 0.1133430919991, 0.1670023287165, 
        0.6969482071991, -1.614488646483, 153.0355827173, 0.1667838228729, 0.3715298962693, 
        0.1661451765521, -1.104315067374,            0, 7.105427357601E-015,            0
spline2a      3,      2, 
        0.1661451765521, -1.104315067374,            0,            0,            0, 
        0.7392795446311, -1.786296581156, 340.8752573466, 0.4613447005756, 0.3112014209948, 
        1.522770200265, -1.698428470244, 60.6961991209, 0.134072438539,            0
spline2a      6,      2, 
        1.522770200265, -1.698428470244,            0,            0,            0, 
        1.733697916702, -1.768822824028, 359.1686621766, 0.1127870129052, 0.2323273201029, 
        2.065570908353, -1.240515027762, 82.86510982704, 0.2493257968945, 0.2342763442875, 
        2.01941758012, -0.5495527157643, 108.1131143172, 0.2337843394782, 0.2275455794198, 
        1.793419352465, 0.0878329106681, 95.8495954853, 0.2264846518464, 0.2191967582349, 
        1.85209729385, 0.5191382598017,            0,            0,            0
spline2a      3,      2, 
        1.659111595562, -1.846284603013, 245.8022479588,            0, 0.4154026746653, 
        1.005772125174, -2.325165807484, 168.1065757329, 0.2991658918216, 0.4578815221622, 
        0.09066581578031, -1.534352809274, 94.12794021754, 0.1278205667251,            0
spline2a      8,      2, 
        2.261707868316, 0.5878410004667,            0,            0,            0, 
        2.36714960141, 0.329508754385, 269.9494788511, 0.1423768721878, 0.1107138753987, 
        2.240619521697, 0.02899981506542, 235.405648031, 0.1117231711186, 0.139748229039, 
        2.0771848354, -0.3400462507656, 274.7901878133, 0.1376371838163, 0.04997612812519, 
        2.140449875257, -0.4665763304791, 325.8482941459, 0.04963556753858, 0.06033300943826, 
        2.314428734863, -0.508753023717, 347.0165349905, 0.0609958800174, 0.1084226363436, 
        2.52794824438, -0.7222725332335, 284.1202668145, 0.1080932874659, 0.2730893989271, 
        2.230075348388, -1.120315075666,            0,            0,            0
spline2a      3,      2, 
        2.230075348388, -1.120315075666,            0,            0,            0, 
        2.536598684163, -1.426838411441, 275.1757665394, 0.2301251007225, 0.230378417543, 
        2.289552921192, -1.783719313052,            0,            0,            0
spline2a      3,      2, 
        2.289552921192, -1.783719313052,            0,            0,            0, 
        2.289552921192, -2.187912623248, 245.2288399738, 0.2070110186265, 0.2364559827507, 
        1.92050685536, -2.460303767076,            0, 7.105427357601E-015,            0
spline2a     15,      2, 
        2.261707868316, 0.5878410004667,            0,            0,            0, 
        2.472631835826, 0.1477076366503, 260.6903639936, 0.2551920174168, 0.1432453692033, 
        2.35265767717, -0.2539075304786, 276.8198466324, 0.141794275516, 0.01599879861789, 
        2.365610433285, -0.299589804256, 298.0809612031, 0.01598686956473, 0.02202836946961, 
        2.40873540074, -0.3490621430933, 319.9060487978, 0.02209368139087, 0.1768103408176, 
        2.803193625628, -0.6475475234681, 287.9762861618, 0.1707830087821, 0.1746682590772, 
        2.56737761856, -1.083106525195, 230.2974625812, 0.1831823973165, 0.01997745607762, 
        2.550133466201, -1.132579495703, 299.6874949658, 0.01897816402658, 0.01705082773007, 
        2.595541770808, -1.150659530437, 352.4928300992, 0.01764467878078, 0.1458979123052, 
        2.855914492175, -1.438360521677, 273.5162297978, 0.1456889610811, 0.1624154609793, 
        2.597887379294, -1.800085902429, 202.8010024649, 0.164048263762, 0.03856227113464, 
        2.509983977065, -1.862592642723, 253.668904974, 0.03748310048423, 0.02318899505334, 
        2.516299228438, -1.930687321245, 284.0582546976, 0.02350636816659, 0.1429743362133, 
        2.403564611255, -2.316564274631, 225.0296526793, 0.1428257651745, 0.2595363358401, 
        1.92050685536, -2.460303767076,            0,            0,            0
spline2a      3,      2, 
        -2.463192176862, 0.3697392414947,            0,            0,            0, 
        -2.577069248604, -0.009850997645785, 290.7341805886, 0.2094230060943, 0.2278414241208, 
        -2.197479009463, -0.2072379219988,            0, 1.42108547152E-014,            0
spline2a      3,      2, 
        -2.197479009463, -0.2072379219988,            0,            0,            0, 
        -2.478375786427, -0.9967856194111, 288.8430010977, 0.4440001689429, 0.4766580721193, 
        -1.696419893798, -1.429518492031,            0,            0,            0
spline2a      3,      2, 
        -1.696419893798, -1.429518492031,            0,            0,            0, 
        -1.772337941626, -1.968536631611, 301.9664947799, 0.2912283510079, 0.3058414152866, 
        -1.218136192481, -2.12796453205,            0, 3.552713678801E-015,            0
spline2a      3,      2, 
        -1.218136192481, -2.12796453205,            0,            0,            0, 
        -1.322101866613, -2.417854661793, 264.1709807134, 0.1554246597788, 0.5186006674954, 
        -0.5272819572453, -2.742900719457,            0, 7.105427357601E-015,            0
spline2a     16,      2, 
        -2.463192176862, 0.3697392414947,            0,            0,            0, 
        -2.799177057576, 0.08177168249833, 250.0189039416, 0.2286363914103, 0.181018841162, 
        -2.61465402466, -0.318028222152, 349.5003540849, 0.176196712432, 0.02774486228019, 
        -2.53911022469, -0.3438904080894, 313.3946636475, 0.02724355544337, 0.04713763189859, 
        -2.588293591386, -0.4586171996113, 228.1217412126, 0.05256044965151, 0.2230095335269, 
        -2.715702352209, -1.073693975996, 286.4055353831, 0.2237829492624, 0.258947746482, 
        -2.18410028119, -1.556968586013, 349.2467645992, 0.2587934562604, 0.02935114246422, 
        -2.10637735207, -1.58894639247, 309.42010941, 0.02882955093759, 0.05459199146608, 
        -2.174703595115, -1.718007073778, 229.3402586734, 0.06119181380412, 0.1921288709838, 
        -2.039416063975, -2.192369842239, 323.9347351689, 0.2015179342656, 0.1674490897074, 
        -1.56735921249, -2.287392432489, 10.59510647834, 0.1679264641093, 0.03067242015671, 
        -1.483849359879, -2.294984237272, 315.6735843359, 0.02956771989296, 0.04339506655164, 
        -1.539055987948, -2.39373426308, 224.6574626898, 0.04977522979756, 0.106727838709, 
        -1.618381365854, -2.680526013974, 285.9803897437, 0.1064765535871, 0.1696310125378, 
        -1.216218167009, -2.917936504859, 356.3771743017, 0.1749248309752, 0.3597179778417, 
        -0.5272819572453, -2.742900719457,            0,            0,            0
spline2a      3,      2, 
        0.09066581578031, -1.534352809274, 302.9577501077,            0, 0.2262061797239, 
        1.082228339477, -2.168585062674, 1.093944490369, 0.4155084915194, 0.3414303360316, 
        1.659111595562, -1.846284603013,            0, 7.105427357601E-015,            0



return

]]>
</Script_2D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_1D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
EPS = 0.00001	! minimum epsilon for Layout View (Scale=1:1)

! AC_Component values
HEAD_ONLY		= 0
CLOUD_ONLY		= 1
HEAD_AND_CLOUD	= 2

_hasHead = 0
if AC_Component = HEAD_ONLY | AC_Component = HEAD_AND_CLOUD then
	_hasHead = 1
endif

_hasPolygon = 0
if AC_Component = CLOUD_ONLY | AC_Component = HEAD_AND_CLOUD then
	_hasPolygon = 1
endif

if not(_hasHead) then
	bConnectionLine = 0
	lock "bConnectionLine"
	hideparameter "bConnectionLine"
endif

! Rounded poligon initialization
_anglebyMaxRadius = 90
_maxUsableRadius = 9999

! ==============================================================================
! Localization
! ==============================================================================

dim strTypeCloud[5]
	strTypeCloud[1] = `Многоугольник`
	strTypeCloud[2] = `Скругленный Многоугольник`
	strTypeCloud[3] = `Одинаковый Радиус`
	strTypeCloud[4] = `Одинаковое Соотношение`
	strTypeCloud[5] = `Случайный Радиус`

CLOUD_POLYGON 	= 1
CLOUD_ROUNDED 	= 2
CLOUD_BISCUIT 	= 3
CLOUD_PERIODIC 	= 4
CLOUD_RANDOM 	= 5

dim _stShapeHead[14]
	_stShapeHead[1] = `Без Символа`
	_stShapeHead[2] = `Окружность`
	_stShapeHead[3] = `Треугольник Вверх`
	_stShapeHead[4] = `Треугольник Вниз`
	_stShapeHead[5] = `Прямоугольник`
	_stShapeHead[6] = `Пятиугольник Вверх`
	_stShapeHead[7] = `Пятиугольник Вниз`
	_stShapeHead[8] = `Шестиугольник`
	_stShapeHead[9] = `Шестиугольник Повернутый`
	_stShapeHead[10] = `Восьмиугольник`
	_stShapeHead[11] = `Восьмиугольник Повернутый`
	_stShapeHead[12] = `Ромб`
	_stShapeHead[13] = `Линия`
	_stShapeHead[14] = `ГОСТ`

MARKER_HEAD_NONE 			= 1
MARKER_HEAD_CIRCLE 			= 2
MARKER_HEAD_TRIANGLE_UP 	= 3
MARKER_HEAD_TRIANGLE_DOWN 	= 4
MARKER_HEAD_RECTANGLE 		= 5
MARKER_HEAD_PENTAGON_UP 	= 6
MARKER_HEAD_PENTAGON_DOWN 	= 7
MARKER_HEAD_HEXAGON 		= 8
MARKER_HEAD_HEXAGON_ROTATED = 9
MARKER_HEAD_OCTOGON 		= 10
MARKER_HEAD_OCTOGON_ROTATED = 11
MARKER_HEAD_DIAMOND 		= 12
MARKER_HEAD_LINE 			= 13
MARKER_HEAD_GOST 			= 14

dim _stRotateHead[2]
	_stRotateHead[1] = `С Поворотом`
	_stRotateHead[2] = `Всегда Горизонтально`

! iRotateHead
HEAD_ROTATED 	= 1
HEAD_HORIZONTAL = 2


dim _stHeadLineType[2]
	_stHeadLineType[1] = `Разрыв`
	_stHeadLineType[2] = `Прямой`

LINE_BREAKPOINT = 1
LINE_STRAIGHT 	= 2

HEAD_SIZE_SIDE = 1
HEAD_SIZE_UP = 2
HEAD_SIZE_DOWN = 3


if iShapeHead = MARKER_HEAD_LINE then
	bDivisionLine = 1
	iConnectionLine = LINE_BREAKPOINT
endif


! ==============================================================================
! Autotext descript and value
! ==============================================================================

AUTOTEXT_DESC = 1
AUTOTEXT_KEY = 2

dim _sAutotextMenu[7][2]
_sAutotextMenu[1][AUTOTEXT_DESC] = `ID Изменения`
_sAutotextMenu[1][AUTOTEXT_KEY] = "<CHANGEID>"

_sAutotextMenu[2][AUTOTEXT_DESC] = `Имя Изменения`
_sAutotextMenu[2][AUTOTEXT_KEY] = "<CHANGEDESCRIPTION>"

_sAutotextMenu[3][AUTOTEXT_DESC] = `ID Редакции`
_sAutotextMenu[3][AUTOTEXT_KEY] = "<REVISIONID>"

_sAutotextMenu[4][AUTOTEXT_DESC] = `ID Выпуска`
_sAutotextMenu[4][AUTOTEXT_KEY] = "<ISSUEID>"

_sAutotextMenu[5][AUTOTEXT_DESC] = `Имя Выпуска`
_sAutotextMenu[5][AUTOTEXT_KEY] = "<ISSUEDESCRIPTION>"
	
_sAutotextMenu[6][AUTOTEXT_DESC] = `Дата Выпуска`
_sAutotextMenu[6][AUTOTEXT_KEY] = "<ISSUEDATE>"

_sAutotextMenu[7][AUTOTEXT_DESC] = `Выпустил`
_sAutotextMenu[7][AUTOTEXT_KEY] = "<ISSUEDBY>"

_numAutotextMenu = vardim1(_sAutotextMenu)

dim _contentText[8]
	_contentText[1] = `Добавить Автотекст`
dim _icontentText[8]
	_icontentText[1] = 1

	for iDim = 1 to _numAutotextMenu
		_contentText[1+iDim] = _sAutotextMenu[iDim][AUTOTEXT_DESC]
		_icontentText[1+iDim] = 1 + iDim
	next iDim


! =========================================================================
! Calculations
! =========================================================================

dim _lengthVector[]
dim _angleVector[]
dim _angVectorSide[]
dim _maxDistTangentPoint[]
dim _distancePointfromOrigo[]

if _hasPolygon then

	! Polygon vectors length and angle 
	! =========================================================================

	for k = 1 to AC_PolygonNodes - 1
		vx2 = AC_PolygonCoords[k+1][1]
		vy2 = AC_PolygonCoords[k+1][2]

		vx1 = AC_PolygonCoords[k][1]
		vy1 = AC_PolygonCoords[k][2]

		! calculate the length of vector
		! --------------------------------------
		gosub "calculation_vector_length"
		_lengthVector[k] = _templengthVector

		! calculate the angle of vector
		! --------------------------------------
		vx = AC_PolygonCoords[k+1][1] - AC_PolygonCoords[k][1]
		vy = AC_PolygonCoords[k+1][2] - AC_PolygonCoords[k][2]
		gosub "check_vector_direction_angle"
		_angleVector[k] = angle

	next k


! Rounded Polygons first cloud radius calculations for hotspot
! =========================================================================

	if iTypeCloud = CLOUD_ROUNDED then

		_maxTangent = 0
		_placeMaxRadius = 1

		! -----------------------------------------------------
		! find the maximum Cloud radius
		! calculate the distance from peak to the tangent point
		! calculate the angle from peak between two nearby vector
		! -----------------------------------------------------

		for iCalcPoint = 1 to AC_PolygonNodes - 1

			if iCalcPoint = 1 then
				xcoordLast 	= AC_PolygonCoords[AC_PolygonNodes - 1][1]
				ycoordLast 	= AC_PolygonCoords[AC_PolygonNodes - 1][2]
				lvectorLast = _lengthVector[AC_PolygonNodes - 1]
			else
				xcoordLast 	= AC_PolygonCoords[iCalcPoint-1][1]
				ycoordLast 	= AC_PolygonCoords[iCalcPoint-1][2]
				lvectorLast = _lengthVector[iCalcPoint - 1]
			endif

			! calculate the distance from peak to the tangent point
			! -----------------------------------------------------
			_maxDistTangentPoint[iCalcPoint] = min(_lengthVector[iCalcPoint], lvectorLast)/2
			if _maxTangent < _maxDistTangentPoint[iCalcPoint] then
				_maxTangent = _maxDistTangentPoint[iCalcPoint]
				_placeMaxRadius = iCalcPoint
			endif

			! calculate the angle between two vector
			! --------------------------------------
			vx1 = xcoordLast - AC_PolygonCoords[iCalcPoint][1]
			vy1 = ycoordLast - AC_PolygonCoords[iCalcPoint][2]
			vx2 = AC_PolygonCoords[iCalcPoint+1][1] - AC_PolygonCoords[iCalcPoint][1]
			vy2 = AC_PolygonCoords[iCalcPoint+1][2] - AC_PolygonCoords[iCalcPoint][2]
			vl1 = lvectorLast
			vl2 = _lengthVector[iCalcPoint]
			gosub "two_vector_side_angle"
			_angVectorSide[iCalcPoint] = angle

		next iCalcPoint

		! set Radius maximum if available
		_anglebyMaxRadius 	= _angVectorSide[_placeMaxRadius]/2
		_maxUsableRadius = tan(_angVectorSide[_placeMaxRadius]/2) * _maxDistTangentPoint[_placeMaxRadius]

	endif

	if iTypeCloud = CLOUD_RANDOM then

		! Polygon vector's beginning point distance from origo 
		! =========================================================================

		for k = 1 to AC_PolygonNodes - 1
			vx2 = 0
			vy2 = 0

			vx1 = AC_PolygonCoords[k][1]
			vy1 = AC_PolygonCoords[k][2]

			! calculate the length of vector
			! --------------------------------------
			gosub "calculation_vector_length"
			_distancePointfromOrigo[k] = _templengthVector
		next k

	endif

endif


goto "MasterEnd"

! ==============================================================================
! Vector length
! ------------------------------------------------------------------------------
! Input variables:
!	vx, vy:				vector
!
! Returned variables:
!	_lengthVector:	length of vector
! ==============================================================================
"calculation_vector_length" :

	_templengthVector = SQR((vx2 - vx1)^2 + (vy2 - vy1)^2)


return

! ==============================================================================
! Direction Angle
! ------------------------------------------------------------------------------
! Input variables:
!	vx, vy:				vector
!
! Returned variables:
!	angle:				selected intersection point
! ==============================================================================

"check_vector_direction_angle":

	if abs(vx) < EPS & abs(vy) < EPS then
		angle = 0
		return
	endif
	
	if abs(vx) < EPS then
		if vy > 0 then
			angle = 90
		else
			angle = 270
		endif
	else
		angle = atn(vy / vx)
		if vx >= 0 then
			if angle < 0 then
				angle = angle + 360
			endif
		else
			angle = 180 + angle
		endif
	endif

return

! ==============================================================================
! Angle between two vectors
! ------------------------------------------------------------------------------
! Input variables:
!	vx1, vy1:				vector 1
!	vx2, vy2:				vector 2
!	vl1:					length of vector 1
!	vl2:					length of vector 2
!
! Returned variables:
!	angle:				selected intersection point
! ==============================================================================
"two_vector_side_angle":

	scalarproduct = (vx1 * vx2) + (vy1 * vy2)

	if abs(scalarproduct) > EPS then
		angleRange = scalarproduct  /(vl2 * vl1)

		angle = ACS(angleRange)
	else
		angle = 90
	endif

return

"MasterEnd":
]]>
</Script_1D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_PR SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_PR>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_UI SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! ==============================================================================
! Standard Detail Marker
! ==============================================================================

uiDialogTitle	= `Символ и Текст Маркера`


uiCloudStyle		= `Облако`
uiHeadStyle			= `Маркер`
uiTextStyle			= `Текст Маркера`
uiVerticalText		= `Вертикальный Текст`
uiSecondLine		= `Вторая Строка`
uiRadius			= `Радиус:`
uiRatio				= `Соотношение:`

dim uitooltip[]
	uitooltip[1] = `Стиль Облака`
	uitooltip[2] = `Радиус (мм)`
	uitooltip[3] = `Отношение 1`
	uitooltip[4] = `Отношение 2`
	uitooltip[5] = `Максимальный Радиус (мм)`
	uitooltip[6] = `Минимальный Радиус (мм)`
	uitooltip[7] = `Добавить Автотекст в Текст Маркера`
	uitooltip[8] = `Добавить Автотекст во Вторую Строку`
	uitooltip[9] = `Текст Маркера`
	uitooltip[10] = `Вторая Строка Текста Маркера`

! ==============================================================================

ui_dialog uiDialogTitle, 444,266

ui_page 1

dy = 27


y = 2
sepx = 222
rowy = 19
liney = 27 ! standard 29, max 31
filly = 25 ! standard 25, max 27
penx = 33
peny = 19
buttx = 30

descx1 = sepx - 2*3
descx2 = 123

pictx = descx1
picty = 36

penpictx = 32
penpicty = 15
radpictx = 16

x11 = 3				! begin
x12 = 38			! fill begins
x13 = 113						! pen pict
x14 = x13 + penpictx + 4		! pen input
x15 = x14 + penx + 4			! pen block

x21 = sepx + 4						! begin
x22 = sepx + 38						! fill begins
x23 = sepx + 113					! pen pict
x24 = sepx + x13 + penpictx + 4		! pen input
x25 = sepx + x14 + penx + 4			! pen block

ui_separator sepx, 2, sepx, 178
ui_separator x11, 180, 442, 180

! ==============================================================================
! Marker Cloud
! ==============================================================================

ui_style 2,1
ui_outfield uiCloudStyle, x11, y, descx1, rowy
ui_style 2,0
y = y + 27

cell_x = 0
cell_y = 0
image_x = 225/5
image_y = 30
ui_infield{3} "iTypeCloud",	x11,	y, pictx,	picty,
		2, 1, 5, 1,			! ui_cloud_types.png
		cell_x,cell_y,image_x,image_y,
		1, strTypeCloud[1], 1,
		2, strTypeCloud[2], 2,
		3, strTypeCloud[3], 3,
		5, strTypeCloud[4], 4,
		4, strTypeCloud[5], 5	ui_tooltip uitooltip[1]

y = 73
if iTypeCloud = CLOUD_BISCUIT then

	ui_outfield uiRadius,	x11, y+2, descx2, rowy
	ui_pict 8, sepx-3-45-radpictx-5, y+2, radpictx, radpictx, 1	! ui_radius_max
	ui_infield "radiusCloud_mm",	sepx-3-45,	y, 45, rowy	ui_tooltip uitooltip[2]

else

	if iTypeCloud = CLOUD_PERIODIC then

		beginx = 116
		ui_outfield uiRatio,	x11, y+2, beginx - x11 - 1, rowy
		ui_infield "iRatioCloud_1",	beginx,	y, 45, rowy ui_tooltip uitooltip[3]
		ui_outfield ":",	beginx + 1 + 45,	y, 10, rowy, 2
		ui_infield "iRatioCloud_2",	beginx + 1 + 45 + 10 + 1,	y, 45, rowy	ui_tooltip uitooltip[4]
	
	else

		if iTypeCloud = CLOUD_RANDOM then
	
			beginx = 91
			ui_outfield uiRadius,	x11, y+2, beginx - x11 - 1, rowy
			ui_pict 9, beginx, y + 2, radpictx, radpictx, 1	! ui_radius_min
			ui_infield "minradiusCloud_mm",	beginx + radpictx + 2,	y, 45, rowy	ui_tooltip uitooltip[6]
			ui_pict 8, beginx + radpictx + 2*2 + 45, y + 2, radpictx, radpictx, 1	! ui_radius_max
			ui_infield "maxradiusCloud_mm", beginx + radpictx*2 + 2*3 + 45,	y, 45, rowy	ui_tooltip uitooltip[5]

		else

			y = 71
			ui_infield "lineTypeCloud",	x12, y, descx1-x12+x11, liney

		endif
	endif
endif

y = 102
cell_x = buttx
cell_y = filly
image_x = 24
image_y = 19
ui_infield{3} "bFillCloud",	x11,	y, buttx, filly,
		6,10,1,1,
		cell_x,cell_y,image_x,image_y,
		1,"", 0,
		1,"", 1
ui_infield "typeFillCloud",	x12,	y, descx1-x12+x11, filly
y = y + filly + 3

ui_style 0,0
ui_pict 5,	x13,	y + 2, penpictx, 15, 1		! ui_list_fillPen_flat(1).png
ui_infield "ipenFillCloud",	x14,	y, penx, peny
ui_infield "penFillCloud",	x15,	y, penx, peny
y = y + dy-rowy + peny

ui_pict 6,	x13,	y + 2, penpictx, 15, 1		! ui_list_fillBgPen_flat(1).png
ui_infield "ibackpenFillCloud",	x14, y, penx, peny
ui_infield "backpenFillCloud",	x15, y, penx, peny
ui_style 2,0

! ==============================================================================
! Marker Head
! ==============================================================================
y = 2

ui_style 2,1
ui_outfield uiHeadStyle, x21, y, descx1, rowy
ui_style 2,0
y = y + 27

cell_x = 71
cell_y = 48
image_x = 50
image_y = 30

if not(bDivisionLine) then
	ui_infield{3} "iShapeHead",	x21,	y, pictx,	picty,
			2, 2, 12, 1,			! ui_head_type_no_line.png
			cell_x,cell_y,image_x,image_y,
			0, _stShapeHead[1], 1,
			1, _stShapeHead[2], 2,
			2, _stShapeHead[3], 3,
			3, _stShapeHead[4], 4,
			4, _stShapeHead[5], 5,
			6, _stShapeHead[6], 6,
			7, _stShapeHead[7], 7,
			8, _stShapeHead[8], 8,
			9, _stShapeHead[9], 9,
			10, _stShapeHead[10], 10,
			11, _stShapeHead[11], 11,
			5, _stShapeHead[12], 12,
			12, _stShapeHead[13], 13, 0, _stShapeHead[14], 14
else
	if bVerticalTextPosition then
		ui_infield{3} "iShapeHead",	x21,	y, pictx,	picty,
				2, 4, 12, 1,			! ui_head_type_vertical_line.png
				cell_x,cell_y,image_x,image_y,
				0, _stShapeHead[1], 1,
				1, _stShapeHead[2], 2,
				2, _stShapeHead[3], 3,
				3, _stShapeHead[4], 4,
				4, _stShapeHead[5], 5,
				6, _stShapeHead[6], 6,
				7, _stShapeHead[7], 7,
				8, _stShapeHead[8], 8,
				9, _stShapeHead[9], 9,
				10, _stShapeHead[10], 10,
				11, _stShapeHead[11], 11,
				5, _stShapeHead[12], 12,
				12, _stShapeHead[13], 13, 0, _stShapeHead[14], 14
	else
		ui_infield{3} "iShapeHead",	x21,	y, pictx,	picty,
			2, 3, 12, 1,			! ui_head_type_single_line.png
			cell_x,cell_y,image_x,image_y,
			0, _stShapeHead[1], 1,
			1, _stShapeHead[2], 2,
			2, _stShapeHead[3], 3,
			3, _stShapeHead[4], 4,
			4, _stShapeHead[5], 5,
			6, _stShapeHead[6], 6,
			7, _stShapeHead[7], 7,
			8, _stShapeHead[8], 8,
			9, _stShapeHead[9], 9,
			10, _stShapeHead[10], 10,
			11, _stShapeHead[11], 11,
			5, _stShapeHead[12], 12,
			12, _stShapeHead[13], 13, 0, _stShapeHead[14], 14
	endif

endif

y = 73
ui_infield{3} "bVerticalTextPosition",	x21,	y, descx1, rowy,
		7,"",2,1,
		0,0,0,0,
		1,uiVerticalText, 0,
		2,uiVerticalText, 1


y = 102
cell_x = buttx
cell_y = filly
image_x = 24
image_y = 19
ui_infield{3} "bFillHead",	x21,	y, buttx, filly,
		6,10,1,1,
		cell_x,cell_y,image_x,image_y,
		1,"", 0,
		1,"", 1

ui_infield "typeFillHead",	x22,	y, descx1-x22+x21, filly
y = y + filly + 3

ui_style 0,0
ui_pict 5,	x23,	y + 2, penpictx, 15, 1		! ui_fill_pen.png
ui_infield "ipenFillHead",	x24,	y, penx, peny
ui_infield "penFillHead",	x25,	y, penx, peny
y = y + dy-rowy + peny

ui_pict 6,	x23,	y + 2, penpictx, 15, 1		! ui_fill_bgpen.png
ui_infield "ibackpenFillHead",	x24, y, penx, peny
ui_infield "backpenFillHead",	x25, y, penx, peny
ui_style 2,0


! ==============================================================================
! Marker Text
! ==============================================================================
y = 185
dy = 29

x32 = 133 

ui_style 2,1
ui_outfield uiTextStyle, x11, y, x32-x11-5, rowy
ui_style 2,0

ui_infield{3} "bDivisionLine",	x32,	y, x23-x32, rowy,
		7,"",2,1,
		0,0,0,0,
		1,uiSecondLine, 0,
		2,uiSecondLine, 1
y = y + dy

_posfirstRow = y
ui_infield{3} "iChangeFirstRow", x11,  y, x32-x11-5, rowy,
		8, "", 8, 1, 0, 0, 0, 0,
		"", _contentText[1], _icontentText[1],
		"", _contentText[2], _icontentText[2],
		"", _contentText[3], _icontentText[3],
		"", _contentText[4], _icontentText[4],
		"", _contentText[5], _icontentText[5],
		"", _contentText[6], _icontentText[6],
		"", _contentText[7], _icontentText[7],
		"", _contentText[8], _icontentText[8]	ui_tooltip uitooltip[7]

ui_infield "contentFirstRow",	x32,	y, x23-x32-10, rowy	ui_tooltip uitooltip[9]
y = y + dy

ui_infield{3} "iChangeSecondRow", x11,  y, x32-x11-5, rowy,
		8, "", 8, 1, 0, 0, 0, 0,
		"", _contentText[1], _icontentText[1],
		"", _contentText[2], _icontentText[2],
		"", _contentText[3], _icontentText[3],
		"", _contentText[4], _icontentText[4],
		"", _contentText[5], _icontentText[5],
		"", _contentText[6], _icontentText[6],
		"", _contentText[7], _icontentText[7],
		"", _contentText[8], _icontentText[8]	ui_tooltip uitooltip[7]

ui_infield "contentSecondRow",	x32,	y, x23-x32-10, rowy	ui_tooltip uitooltip[10]
y = y + dy

y = _posfirstRow

textx = 24
texty = 17

ui_style 0,0
ui_pict 7,	x23,	y, textx, texty, 1	! ui_text_pen_flat(1).png
ui_infield "ipenMarkerText",	x24,	y, penx, peny
ui_infield "penMarkerText",		x25,	y, penx, peny
y = y + dy-rowy + peny

ui_pict 7,	x23,	y, textx, texty, 1	! ui_text_pen_flat(1).png
ui_infield "ipenMarkerSecondText",	x24,	y, penx, peny
ui_infield "penMarkerSecondText",	x25,	y, penx, peny
y = y + dy-rowy + peny

]]>
</Script_UI>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_VL SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! ===================================================================
! Pens
! ===================================================================
maxPenNumber = 255
dim iPenNumber[255]
for i = 1 to maxPenNumber
	iPenNumber[i] = i
next i

values "penContourHead"			iPenNumber
values "penMarkerText"			iPenNumber
values "penMarkerSecondText"	iPenNumber
values "penDivisionLine"		iPenNumber
values "penFillCloud"			iPenNumber
values "penFillHead"			iPenNumber

! ===================================================================
! Marker Cloud
! ===================================================================

values{2} "iTypeCloud" CLOUD_POLYGON,	strTypeCloud[1],
					   CLOUD_ROUNDED,	strTypeCloud[2],
					   CLOUD_BISCUIT,	strTypeCloud[3],
					   CLOUD_PERIODIC,	strTypeCloud[4],
					   CLOUD_RANDOM,	strTypeCloud[5]

if not(_hasPolygon) then
	hideparameter "title_changeMarker_Cloud"
	gosub "cloudparameters"
	gosub "cloudradiusparameters"
	gosub "cloudperioticparameters"
	gosub "cloudrandomparameters"
	gosub "cloudattributes"
else

	if not(bFillCloud) then
		gosub "cloudattributes"
	endif
	
	! Cloud radius is scale independent
	if iTypeCloud <> CLOUD_ROUNDED then
		if iTypeCloud <> CLOUD_BISCUIT then gosub "cloudradiusparameters"
	else
		! maximum usable radius for editable hotspot
		! except Settings dialog where the polygon is sample
		values "lengthRounded_m" range (0, _maxUsableRadius/sin(_anglebyMaxRadius) - _maxUsableRadius)
	
		values "radiusCloud_m"	 	range (0, )
		values "radiusCloud_mm" 	range (0, )
	
		if GLOB_MODPAR_NAME = "lengthRounded_m" then
			! for editable hotspots
			radiusCloud_m	= ( sin(_anglebyMaxRadius) * lengthRounded_m ) / (1 - sin(_anglebyMaxRadius))
			radiusCloud_mm	= ( sin(_anglebyMaxRadius) * lengthRounded_m ) / (1 - sin(_anglebyMaxRadius)) * 1000
			parameters 	radiusCloud_m	 	= radiusCloud_m,
						radiusCloud_mm 		= radiusCloud_mm
		else
			if GLOB_MODPAR_NAME = "radiusCloud_m" then
				! maximum usable radius range
				if radiusCloud_m > (_maxUsableRadius + EPS) then
					radiusCloud_m = _maxUsableRadius
					parameters radiusCloud_m = radiusCloud_m
				endif
		
				radiusCloud_mm	= radiusCloud_m / 1000
				lengthRounded_m	= radiusCloud_m / sin(_anglebyMaxRadius) - radiusCloud_m
				parameters	radiusCloud_mm	= radiusCloud_mm,
							lengthRounded_m	= lengthRounded_m
			else
				! maximum usable radius range
				if radiusCloud_mm > (_maxUsableRadius * 1000 + EPS) then
					radiusCloud_mm = _maxUsableRadius * 1000
					parameters radiusCloud_mm = radiusCloud_mm
				endif
		
				radiusCloud_m	= radiusCloud_mm / 1000
				lengthRounded_m	= (radiusCloud_mm / 1000) / sin(_anglebyMaxRadius) - (radiusCloud_mm / 1000)

				parameters	radiusCloud_m	= radiusCloud_m,
							lengthRounded_m	= lengthRounded_m
			endif
		endif
		lock			"radiusCloud_m", "lengthRounded_m"
		hideparameter	"radiusCloud_m", "lengthRounded_m"
	endif

	! Cloud radius is scale independent
	if iTypeCloud <> CLOUD_BISCUIT then
		if iTypeCloud <> CLOUD_ROUNDED then gosub "cloudradiusparameters"
	else
		if GLOB_MODPAR_NAME = "radiusCloud_m" then
			! Range without arrow on UI
			if radiusCloud_m < EPS then
				radiusCloud_m = 0.00001
				parameters radiusCloud_m = radiusCloud_m
			endif
	
			radiusCloud_mm = radiusCloud_m * 1000
			parameters radiusCloud_mm = radiusCloud_mm
		else
			! Range without arrow on UI
			if radiusCloud_mm < EPS then
				radiusCloud_mm = 0.01
				parameters radiusCloud_mm = radiusCloud_mm
			endif
	
			radiusCloud_m = radiusCloud_mm / 1000
			parameters radiusCloud_m = radiusCloud_m
		endif
		lock			"radiusCloud_m", "lengthRounded_m"
		hideparameter	"radiusCloud_m", "lengthRounded_m"
	endif
	
	if iTypeCloud <> CLOUD_PERIODIC then
		gosub "cloudperioticparameters"
	else

		values "numRatioCloud" range (0,)

		if GLOB_MODPAR_NAME = "numRatioCloud" then
			iRatioCloud_1 = numRatioCloud * 100
			iRatioCloud_2 = 100

			_divided = max(iRatioCloud_1, iRatioCloud_2)
			_divider = min(iRatioCloud_1, iRatioCloud_2)
	
			if FRA(_divided / _divider) < EPS then
				_maindiv = min(iRatioCloud_1, iRatioCloud_2)
			else
				_maindiv = 1
				DO
					_quotient = INT(_divided / _divider)
					_left = INT(_divided - (_divider * _quotient))
					if _left > 0 then _maindiv = _left
		
					_divided = _divider
					_divider = _left
				WHILE _left > 0
	
			endif
	
			iRatioCloud_1 = iRatioCloud_1/_maindiv
			iRatioCloud_2 = iRatioCloud_2/_maindiv
	
			parameters iRatioCloud_1 = iRatioCloud_1,
						iRatioCloud_2 = iRatioCloud_2
		else
			! Range without arrow on UI
			if iRatioCloud_1 <= EPS then
				iRatioCloud_1 = 1
				parameters iRatioCloud_1 = iRatioCloud_1
			endif
			if iRatioCloud_2 <= EPS then
				iRatioCloud_2 = 1
				parameters iRatioCloud_2 = iRatioCloud_2
			endif
	
			numRatioCloud = iRatioCloud_1 / iRatioCloud_2
			parameters numRatioCloud = numRatioCloud
		endif


		! display only on UI
		hideparameter "iRatioCloud_1", "iRatioCloud_2"
	endif

	if iTypeCloud <> CLOUD_RANDOM then
		gosub "cloudrandomparameters"
	else
		if GLOB_MODPAR_NAME = "minradiusCloud_m" then
			! Range without arrow on UI
			if minradiusCloud_m < EPS then
				minradiusCloud_m = 0.00001
				parameters minradiusCloud_m = minradiusCloud_m
			endif
	
			minradiusCloud_mm = minradiusCloud_m * 1000
			parameters minradiusCloud_mm = minradiusCloud_mm
		else
			! Range without arrow on UI
			if minradiusCloud_mm < EPS then
				minradiusCloud_mm = 0.01
				parameters minradiusCloud_mm = minradiusCloud_mm
			endif
	
			minradiusCloud_m = minradiusCloud_mm / 1000
			parameters minradiusCloud_m = minradiusCloud_m
		endif
		
		if GLOB_MODPAR_NAME = "maxradiusCloud_m" then
			! Range without arrow on UI
			if maxradiusCloud_m< EPS then
				maxradiusCloud_m = 0.00001
				parameters maxradiusCloud_m = maxradiusCloud_m
			endif
	
			maxradiusCloud_mm = maxradiusCloud_m * 1000
			parameters maxradiusCloud_mm = maxradiusCloud_mm
		else
			! Range without arrow on UI
			if maxradiusCloud_mm < EPS then
				maxradiusCloud_mm = 0.01
				parameters maxradiusCloud_mm = maxradiusCloud_mm
			endif
	
			maxradiusCloud_m = maxradiusCloud_mm / 1000
			parameters maxradiusCloud_m = maxradiusCloud_m
		endif
		lock			"maxradiusCloud_m", "minradiusCloud_m"
		hideparameter	"maxradiusCloud_m", "minradiusCloud_m"
	endif
endif

! ===================================================================
! Marker Head
! ===================================================================

values{2} "iShapeHead"	MARKER_HEAD_CIRCLE 			,_stShapeHead[2],
						MARKER_HEAD_TRIANGLE_UP 	,_stShapeHead[3],
						MARKER_HEAD_TRIANGLE_DOWN 	,_stShapeHead[4],
						MARKER_HEAD_RECTANGLE 		,_stShapeHead[5],
						MARKER_HEAD_PENTAGON_UP 	,_stShapeHead[6],
						MARKER_HEAD_PENTAGON_DOWN 	,_stShapeHead[7],
						MARKER_HEAD_HEXAGON 		,_stShapeHead[8],
						MARKER_HEAD_HEXAGON_ROTATED ,_stShapeHead[9],
						MARKER_HEAD_OCTOGON 		,_stShapeHead[10],
						MARKER_HEAD_OCTOGON_ROTATED ,_stShapeHead[11],
						MARKER_HEAD_DIAMOND 		,_stShapeHead[12],
						MARKER_HEAD_LINE 			,_stShapeHead[13],
						MARKER_HEAD_GOST 			,_stShapeHead[14],
						MARKER_HEAD_NONE			,_stShapeHead[1]

values{2} "iChangeFirstRow" _icontentText, _contentText
values{2} "iChangeSecondRow" _icontentText, _contentText

if not(_hasHead) then
	hideparameter "title_changeMarker_Head"
	hideparameter "title_changeMarker_Text"
	gosub "headparameters"
	gosub "headattributes"
	gosub "headtextparameters"
	gosub "headsecondtextparameters"
else

	if not(bFillHead) then
		gosub "headattributes"
	endif
	
	if iShapeHead <> MARKER_HEAD_RECTANGLE &\
		iShapeHead <> MARKER_HEAD_DIAMOND &\ 
		iShapeHead <> MARKER_HEAD_LINE then

		lock			"widthHead_m", "widthHead_mm"
		hideparameter	"widthHead_m", "widthHead_mm"
	endif
	
	values{2} "iRotateHead" 	HEAD_HORIZONTAL, 	_stRotateHead[2],
								HEAD_ROTATED, 		_stRotateHead[1]
	
	if iShapeHead = MARKER_HEAD_NONE then	! has no fill
		lock "bFillHead"
		hideparameter "bFillHead"
		gosub "headattributes"
	endif

! ===================================================================
! Marker Text
! ===================================================================

	if not(bDivisionLine) then
		gosub "headsecondtextparameters"
	endif
	
	
	isFirstRun = 0
	if GLOB_MODPAR_NAME = "iChangeFirstRow" |\
		GLOB_MODPAR_NAME = "iChangeSecondRow" then
		
		n = APPLICATION_QUERY ("parameter_script", "firstoccasion_in_progress", isFirstRun)
	endif
	
	if GLOB_MODPAR_NAME = "iChangeFirstRow" then
		if n and isFirstRun and iChangeFirstRow <> 1 then
			contentFirstRow = contentFirstRow + _sAutotextMenu[iChangeFirstRow-1][AUTOTEXT_KEY]
			parameters contentFirstRow = contentFirstRow
		else
			iChangeFirstRow = _icontentText[1]
			parameters iChangeFirstRow = iChangeFirstRow
		endif
	endif
	
	if GLOB_MODPAR_NAME = "iChangeSecondRow" then
		if n and isFirstRun and iChangeSecondRow <> 1 then
			contentSecondRow = contentSecondRow + _sAutotextMenu[iChangeSecondRow-1][AUTOTEXT_KEY]
			parameters contentSecondRow = contentSecondRow 
		else
			iChangeSecondRow = _icontentText[1]
			parameters iChangeSecondRow = iChangeSecondRow
		endif
	endif
	
	
	! ===================================================================
	! Marker Line
	! ===================================================================
	
	if not(bConnectionLine) | iShapeHead = MARKER_HEAD_LINE then
		lock "iConnectionLine"
		hideparameter "iConnectionLine"
	endif
	
	values{2} "iConnectionLine" LINE_BREAKPOINT, 	_stHeadLineType[1],
								LINE_STRAIGHT, 		_stHeadLineType[2]
	
	if iConnectionLine = LINE_STRAIGHT then
		lock			"iRotateHead", "distanceHead_m", "distanceHead_mm"
		hideparameter	"iRotateHead", "distanceHead_m", "distanceHead_mm"
	endif
	
	values "widthHead_m" range[0,]
	values "widthHead_mm" range[0,]
	lock "widthHead_m"
	hideparameter "widthHead_m"
	
	values "widthHeadHalf_m" range[0,]
	values "widthHeadHalf_mm" range[0,]
	
	if GLOB_MODPAR_NAME = "widthHeadHalf_m" then
		widthHead_mm		= widthHeadHalf_m * 1000 * 2
		widthHead_m			= widthHeadHalf_m * 2
		widthHeadHalf_mm	= widthHeadHalf_m * 1000

		parameters	widthHead_mm		= widthHead_mm,
					widthHead_m			= widthHead_m,
					widthHeadHalf_mm	= widthHeadHalf_mm
	else
		if GLOB_MODPAR_NAME = "widthHead_m" then
			widthHead_mm		= widthHead_m * 1000
			widthHeadHalf_mm	= widthHead_m * 1000 / 2
			widthHeadHalf_m		= widthHead_m / 2
	
			parameters	widthHead_mm		= widthHead_mm,
						widthHeadHalf_mm	= widthHeadHalf_mm,
						widthHeadHalf_m		= widthHeadHalf_m
		else
			widthHead_m			= widthHead_mm / 1000
			widthHeadHalf_m		= widthHead_mm / 1000 / 2
			widthHeadHalf_mm	= widthHead_mm / 2

			parameters	widthHead_m			= widthHead_m,
						widthHeadHalf_m		= widthHeadHalf_m,
						widthHeadHalf_mm	= widthHeadHalf_mm
		endif
	endif

	lock			"widthHeadHalf_m", "widthHeadHalf_mm"
	hideparameter	"widthHeadHalf_m", "widthHeadHalf_mm"
	
	if iShapeHead = MARKER_HEAD_RECTANGLE | iShapeHead = MARKER_HEAD_DIAMOND then
		values "distanceHead_m"		range[0,]
		values "distanceHead_mm"	range[0,]
	else
		! AC_MarkerSize is paper size
		values "distanceHead_m"		range(0,]
		values "distanceHead_mm"	range(0,]
	endif
	
	if GLOB_MODPAR_NAME = "distanceHead_m" then
		distanceHead_mm = distanceHead_m * 1000
		parameters distanceHead_mm = distanceHead_mm
	else
		distanceHead_m = distanceHead_mm / 1000
		parameters distanceHead_m = distanceHead_m
	endif
	
	lock			"distanceHead_m"
	hideparameter	"distanceHead_m"
endif

! ===================================================================
! 2D Attributes
! ===================================================================

if GLOB_MODPAR_NAME = "ipenFillCloud" then
	penFillCloud = ipenFillCloud
	parameters penFillCloud = penFillCloud
else
	ipenFillCloud = penFillCloud
	parameters ipenFillCloud = ipenFillCloud
endif

if GLOB_MODPAR_NAME = "ibackpenFillCloud" then
	backpenFillCloud = ibackpenFillCloud
	parameters backpenFillCloud = backpenFillCloud
else
	ibackpenFillCloud = backpenFillCloud
	parameters ibackpenFillCloud = ibackpenFillCloud
endif

if GLOB_MODPAR_NAME = "ipenFillHead" then
	penFillHead = ipenFillHead
	parameters penFillHead = penFillHead
else
	ipenFillHead = penFillHead
	parameters ipenFillHead = ipenFillHead
endif

if GLOB_MODPAR_NAME = "ibackpenFillHead" then
	backpenFillHead = ibackpenFillHead
	parameters backpenFillHead = backpenFillHead
else
	ibackpenFillHead = backpenFillHead
	parameters ibackpenFillHead = ibackpenFillHead
endif

if GLOB_MODPAR_NAME = "ipenMarkerText" then
	penMarkerText = ipenMarkerText
	parameters penMarkerText = penMarkerText
else
	ipenMarkerText = penMarkerText
	parameters ipenMarkerText = ipenMarkerText
endif

if GLOB_MODPAR_NAME = "ipenMarkerSecondText" then
	penMarkerSecondText = ipenMarkerSecondText
	parameters penMarkerSecondText = penMarkerSecondText
else
	ipenMarkerSecondText = penMarkerSecondText
	parameters ipenMarkerSecondText = ipenMarkerSecondText
endif

end

"cloudparameters":

	lock 	"iTypeCloud",
			"lineTypeCloud",
			"bFillCloud",
			"AC_ArcDivParam"
	hideparameter 	"iTypeCloud",
					"lineTypeCloud",
					"bFillCloud",
					"AC_ArcDivParam"
return

"cloudradiusparameters":

	lock 	"radiusCloud_m",
			"radiusCloud_mm",
			"lengthRounded_m"
	hideparameter 	"radiusCloud_m",
					"radiusCloud_mm",
					"lengthRounded_m"

return


"cloudperioticparameters":

	lock 	"iRatioCloud_1",
			"iRatioCloud_2",
			"numRatioCloud"
	hideparameter 	"iRatioCloud_1",
					"iRatioCloud_2",
					"numRatioCloud"

return

"cloudrandomparameters":

	lock 	"maxradiusCloud_m",
			"maxradiusCloud_mm",
			"minradiusCloud_m",
			"minradiusCloud_mm"
	hideparameter	"maxradiusCloud_m",
					"maxradiusCloud_mm",
					"minradiusCloud_m",
					"minradiusCloud_mm"

return


"cloudattributes":
	lock 	"typeFillCloud",
			"penFillCloud",
			"ipenFillCloud",
			"backpenFillCloud",
			"ibackpenFillCloud"
	hideparameter 	"typeFillCloud",
					"penFillCloud",
					"ipenFillCloud",
					"backpenFillCloud",
					"ibackpenFillCloud"
return

"headparameters":

	lock 	"iShapeHead",
			"bConnectionLine",
			"iConnectionLine",
			"widthHead_m",
			"widthHead_mm",
			"distanceHead_m",
			"distanceHead_mm",
			"widthHeadHalf_m",
			"widthHeadHalf_mm",
			"bVerticalTextPosition",
			"rotateHead",
			"iRotateHead",
			"bFillHead",
			"penContourHead"

	hideparameter 	"iShapeHead",
					"bConnectionLine",
					"iConnectionLine",
					"widthHead_m",
					"widthHead_mm",
					"distanceHead_m",
					"distanceHead_mm",
					"widthHeadHalf_m",
					"widthHeadHalf_mm",
					"bVerticalTextPosition",
					"rotateHead",
					"iRotateHead",
					"bFillHead",
					"penContourHead"
return

"headattributes":

	lock 	"typeFillHead",
			"penFillHead",
			"ipenFillHead",
			"backpenFillHead",
			"ibackpenFillHead"

	hideparameter 	"typeFillHead",
					"penFillHead",
					"ipenFillHead",
					"backpenFillHead",
					"ibackpenFillHead"

return

"headtextparameters":

	lock 	"penMarkerText",
			"ipenMarkerText",
			"contentFirstRow",
			"iChangeFirstRow",
			"bDivisionLine",
			"penDivisionLine"

	hideparameter 	"penMarkerText",
					"ipenMarkerText",
					"contentFirstRow",
					"iChangeFirstRow",
					"bDivisionLine",
					"penDivisionLine"

return

"headsecondtextparameters":
	lock 	"penMarkerSecondText",
			"ipenMarkerSecondText",
			"contentSecondRow",
			"iChangeSecondRow",
			"penDivisionLine"
			

	hideparameter	"penMarkerSecondText",
					"ipenMarkerSecondText",
					"contentSecondRow",
					"iChangeSecondRow",
					"penDivisionLine"
return
]]>
</Script_VL>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_FWM SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_FWM>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_BWM SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_BWM>

<ParamSection SectVersion="22" SectionFlags="0" SubIdent="0">
	<ParamSectHeader>
		<AutoHotspots>false</AutoHotspots>
		<StatBits>
			<STBit_FixSize/>
		</StatBits>
		<WDLeftFrame>0</WDLeftFrame>
		<WDRightFrame>0</WDRightFrame>
		<WDTopFrame>0</WDTopFrame>
		<WDBotFrame>0</WDBotFrame>
		<LayFlags>65535</LayFlags>
		<WDMirrorThickness>0</WDMirrorThickness>
		<WDWallInset>0</WDWallInset>
	</ParamSectHeader>
	<Parameters>
		<Length Name="A">
			<Description><![CDATA["Размер 1"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Length Name="B">
			<Description><![CDATA["Размер 2"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<String Name="AC_TextFont_1">
			<Description><![CDATA["Тип Текста Маркера 1 (по умолчанию)"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA["Arial"]]></Value>
		</String>
		<RealNum Name="AC_TextSize_1">
			<Description><![CDATA["Размер Текста Маркера 1 (по умолчанию)"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>2</Value>
		</RealNum>
		<Integer Name="AC_TextStyle_1">
			<Description><![CDATA["Стиль Текста Маркера 1 (по умолчанию)"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<PenColor Name="AC_TextPen_1">
			<Description><![CDATA["Перо Текста Маркера 1 (по умолчанию)"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>6</Value>
		</PenColor>
		<RealNum Name="AC_MarkerSize">
			<Description><![CDATA["Размер Маркера"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>15</Value>
		</RealNum>
		<Integer Name="AC_Component">
			<Description><![CDATA[""]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Integer Name="AC_PolygonNodes">
			<Description><![CDATA["Количество Вершин Многоугольника"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>4</Value>
		</Integer>
		<Length Name="AC_PolygonCoords">
			<Description><![CDATA["Координаты Многоугольника"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="4" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="AC_RefCoord">
			<Description><![CDATA["Координаты Базовой Точки"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
			</ArrayValues>
		</Length>

		<!-- title_changeMarker_Head: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="title_changeMarker_Head">
			<Description><![CDATA["Маркер"]]></Description>
		</Title>
		<Integer Name="iShapeHead">
			<Description><![CDATA["Стиль Маркера"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>14</Value>
		</Integer>
		<Boolean Name="bConnectionLine">
			<Description><![CDATA["Линия Маркера"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Integer Name="iConnectionLine">
			<Description><![CDATA["Стиль Линии Заголовка Маркера"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<RealNum Name="widthHead_mm">
			<Description><![CDATA["Ширина Маркера (мм)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>15</Value>
		</RealNum>
		<RealNum Name="widthHead_m">
			<Description><![CDATA["Ширина Маркера"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.015</Value>
		</RealNum>
		<RealNum Name="widthHeadHalf_mm">
			<Description><![CDATA["Половина Ширины Маркера (мм)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>7.5</Value>
		</RealNum>
		<RealNum Name="widthHeadHalf_m">
			<Description><![CDATA["Половина Ширины Маркера"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.0075</Value>
		</RealNum>
		<RealNum Name="distanceHead_mm">
			<Description><![CDATA["Длина Выноски Маркера (мм)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>7.5</Value>
		</RealNum>
		<RealNum Name="distanceHead_m">
			<Description><![CDATA["Расстояние до Маркера"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.0075</Value>
		</RealNum>
		<Integer Name="iRotateHead">
			<Description><![CDATA["Поворот Маркера"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Boolean Name="bVerticalTextPosition">
			<Description><![CDATA["Вертикальный Текст"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- title_changeMarker_Cloud: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="title_changeMarker_Cloud">
			<Description><![CDATA["Облако"]]></Description>
		</Title>
		<Integer Name="iTypeCloud">
			<Description><![CDATA["Стиль Облака"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<RealNum Name="lengthRounded_m">
			<Description><![CDATA["Округленная Длина"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</RealNum>
		<RealNum Name="radiusCloud_m">
			<Description><![CDATA["Радиус"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.001</Value>
		</RealNum>
		<RealNum Name="radiusCloud_mm">
			<Description><![CDATA["Радиус (мм)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>3</Value>
		</RealNum>
		<Integer Name="iRatioCloud_1">
			<Description><![CDATA["Соотношение"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<Integer Name="iRatioCloud_2">
			<Description><![CDATA["Соотношение"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</Integer>
		<RealNum Name="numRatioCloud">
			<Description><![CDATA["Соотношение"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.75</Value>
		</RealNum>
		<RealNum Name="maxradiusCloud_m">
			<Description><![CDATA["Максимальный Радиус"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.003</Value>
		</RealNum>
		<RealNum Name="maxradiusCloud_mm">
			<Description><![CDATA["Максимальный Радиус (мм)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>3</Value>
		</RealNum>
		<RealNum Name="minradiusCloud_m">
			<Description><![CDATA["Минимальный Радиус"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.0015</Value>
		</RealNum>
		<RealNum Name="minradiusCloud_mm">
			<Description><![CDATA["Минимальный Радиус (мм)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1.5</Value>
		</RealNum>

		<!-- title_changeMarker_Text: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="title_changeMarker_Text">
			<Description><![CDATA["Текст Маркера"]]></Description>
		</Title>
		<String Name="contentFirstRow">
			<Description><![CDATA["Текст Маркера"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["<CHANGEID>"]]></Value>
		</String>
		<Integer Name="iChangeFirstRow">
			<Description><![CDATA["Добавить Автотекст в Текст Маркера"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Boolean Name="bDivisionLine">
			<Description><![CDATA["Вторая Строка"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<String Name="contentSecondRow">
			<Description><![CDATA["Вторая Строка Текста Маркера"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="iChangeSecondRow">
			<Description><![CDATA["Добавить Автотекст во Вторую Строку"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>

		<!-- title_changeMarker_Attributes: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="title_changeMarker_Attributes">
			<Description><![CDATA["2D-отображение"]]></Description>
		</Title>
		<PenColor Name="penContourHead">
			<Description><![CDATA["Перо Маркера"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>25</Value>
		</PenColor>
		<PenColor Name="penMarkerText">
			<Description><![CDATA["Перо Текста Маркера"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>25</Value>
		</PenColor>
		<Integer Name="ipenMarkerText">
			<Description><![CDATA["Перо Текста Маркера"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>25</Value>
		</Integer>
		<PenColor Name="penMarkerSecondText">
			<Description><![CDATA["Перо Текста Второй Строки"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>25</Value>
		</PenColor>
		<Integer Name="ipenMarkerSecondText">
			<Description><![CDATA["Перо Текста Второй Строки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>25</Value>
		</Integer>
		<PenColor Name="penDivisionLine">
			<Description><![CDATA["Перо Линии Разделения Маркера"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>25</Value>
		</PenColor>
		<LineType Name="lineTypeCloud">
			<Description><![CDATA["Тип Линии Облака"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</LineType>
		<Boolean Name="bFillCloud">
			<Description><![CDATA["Штриховка Облака"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<FillPattern Name="typeFillCloud">
			<Description><![CDATA["Тип Штриховки Фона Облака"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>24</Value>
		</FillPattern>
		<PenColor Name="penFillCloud">
			<Description><![CDATA["Перо Штриховки Облака"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>105</Value>
		</PenColor>
		<Integer Name="ipenFillCloud">
			<Description><![CDATA["Перо Штриховки Облака"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>105</Value>
		</Integer>
		<PenColor Name="backpenFillCloud">
			<Description><![CDATA["Перо Фона Штриховки Облака"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<Integer Name="ibackpenFillCloud">
			<Description><![CDATA["Перо Фона Штриховки Облака"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="AC_ArcDivParam">
			<Description><![CDATA["Отклонение Облака от Кривых"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>40</Value>
		</Integer>
		<Boolean Name="bFillHead">
			<Description><![CDATA["Штриховка Маркера"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<FillPattern Name="typeFillHead">
			<Description><![CDATA["Образец Штриховки Маркера"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>65</Value>
		</FillPattern>
		<PenColor Name="penFillHead">
			<Description><![CDATA["Перо Штриховки Маркера"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>105</Value>
		</PenColor>
		<Integer Name="ipenFillHead">
			<Description><![CDATA["Перо Штриховки Маркера"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>105</Value>
		</Integer>
		<PenColor Name="backpenFillHead">
			<Description><![CDATA["Перо Фона Маркера"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>-1</Value>
		</PenColor>
		<Integer Name="ibackpenFillHead">
			<Description><![CDATA["Перо Фона Маркера"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>-1</Value>
		</Integer>
	</Parameters>
</ParamSection>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="1" length_in_bytes="1413" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000E10000
	001E0806000000DA7779B60000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313147F34237000004F749444154785E
	ED9AB152E4480C8609AEEAC2ABA2C808A8BDE81E800408A18A88988897E10178
	4A9E8194F3DF2DCDAADBB2AD6E77CB9EC55FD5C7D8B25AFA871936DA8BEFEFEF
	C3C3C30207F0E364FEBC54B57878F8D39DFA23A3FB84BCA754B57858A786D677
	B86FE3C7F61BBA1FD525DC53A35A946E8596C5EA9ED0F2FD74F16B61F3675B28
	F350A611537509F59CE65A558B520BCFCFCFFF3C3D3DFD57EBE3E3E3158D3AA1
	65B16AA147660D2DDF4F13BF86F8AB88D712596771EF25ED3B91DF335375097A
	58DC5A558BD2251E1E1E7E0D2F49804A13B42C56971832CB5E9961563E23CE2E
	929F596B1C195F6BAF3DA59D01792DC9EB5E39A7F2B4A0E43DA845E91CFC07B8
	16CC08030528D73A0732534FD85B8238B3B887E1DEB562541C176EC22BA8BCC6
	8F6E12C9DE52C4F964764BD7E4B360CDAF16A553DCDFDF37F9030498F3F6F616
	E63228D73A0567866BA0F31779660DF4AD358E6903CD4AE6B7F65CF2B6CCA961
	CDAE16A51A2DFF000166DDDCDC84D90CCAB56AB4FE47032F79660DF4AD358E59
	0FE6D0AC647E2BC5FC66F4C8DB23A78635BB5A94E60C5FE67F8797E1513B30EF
	F2F232CC6750AE35C72BB3065A6BC5F138A22D3433D9B5D61E399996797BE6CC
	B1E6568B52498F2F3383B961098152AD12CFCC1A68AB311EED03CD4EF6ADB167
	56A645668F9C0C7649519A522D4A999E5F6680D961118152AD8C77660DB4D518
	8FB607736976B2AFD65E39735A64F6CAAA31975F2D4A41EF2F33C0FCF7F7F7B0
	0FA0542BD822B306DA0A0D73E3D17ED07CB9B7D8DE19991659C9EEBFD739A6DE
	C7A8907B7777D7FDCB0CB0E3F6F6767889A054EB9039BCC631FDC07C9959036D
	05F207D51DDA237717EB951534C8EBF6BB9D437B1FC98DA65770ECB9BAFAFD9F
	50505A631CD117EC909935D06635B6F7077B6857B2BF44AFAC923599B7C8ABA1
	BD87E446D32BFCD7D7570888856028AD328EE80FF660D91468311A667942FB64
	06B3DE5999DACC5BE5CDD1F227379A9EE1B10B0B016E6B8DC77DC02E2C9C022D
	1663AB2FB433C951E23965DE22AB86963FB9D1F40C8F5D5808705B6B3CEE0376
	61E11468B11ADB7DC02EDA9764B0EA99955993176E9139477B0FC98DA66770EC
	7A7979C1CE518E12E3711FB08B336BA0C5626CF587F626592C7AE7CDF625592C
	7AE79D8272A4D9F242AE6778ECBABEBEC6CE518E12E3711FB08B336BA0C5626C
	F587F626592C6E91B7362BDC226FCE54FE5121D733FCE7E767084A4BABF5CC4C
	BBB05305CFACC6763FB08F762639AC7AE705E7969799CBAD16A5DEC1B18F96AE
	D22B37EDC13E153CB3185BB781762779963CB7BC6C8BDCA53396F2AA45698BD0
	25601F2DAD96182EFB437BE246053CB3185BB781762779963CB7BC6C8BDCA533
	96F2AA45698BD02560DFC7C7C75FB8AC9542879778D91E313BEC42662CCCE1E7
	16637B64836BFC2852CE98636A2FC3B5A979CA79FCA8726A470998619D63C9AB
	16A5BCD0D3D7D7D7BFB52C5625749FCC6FA1DC079179A88FC8FB96C49178CCF7
	BA563A1F90D712DE43CF8797D119AE25CF00EE51A4D7505A2BCDA98233586770
	FF9C6A51BA155A16AB7B42CBF7A789B719DF6ABC96703D17F5A567F279288A9E
	35D2DC2AE8EC69CED42CF12CF4CEA916A55BA165B1BA27B47C7FBA78DB6CFE6C
	2F52B622A6DE0FEAB979CF9C6A51BA155A16AB7B42CB77B80FE3C763837A93F3
	AD548BD2ADD0B258DD135ABEC3FD888F287E4C3AE27972AEA56A51BA155A16AB
	7B42CB77B83FF1516912A3FE767E5FFC0F18DE3335AF2552490000000049454E
	44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="2" length_in_bytes="7708" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000002580000
	001E0806000000F0F860840000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313147F3423700001D8E49444154785E
	ED9D097C8D57FAC7CB48820469442289044D22B1242191C51225A1516B534B49
	99182ADAD88A2229419522FC85880AA31D2A929929D57FEDB514D532AAB66947
	295AB4124B114B23B6F7FFFCEE3C77E636FFF7C6BDB9E7BCF7F6F2FD7CCE27C9
	9B7BDF73DEE59CF37BCE73CE739E5214C5E4640AB9B9B98E1D3A74E8161C1CFC
	AE9797D73E7777F7CB9E9E9E4A9D3A7514FA594CC7BE0E080858DEBE7DFB7E79
	797935F96B360F95F50FDEDEDE7B9B346992C987AC426868E8D46AD5AA29D5AB
	57B76AF2F7F73F535252C2A5AA388D1A359AA8F5F520BF679E79663817C16AFC
	F0C30F95626363DFA1BA71B15FBF7ECDF8F0EF8EA953A7D6A3F7613BD58F93BD
	7AF50AE7C336C5B265CBBCA82D2A557B1F2A92FCFCFCCED1F3ABCCA7D7948484
	84F81A356ADC572B97A9097580EADE86D3A74F57E2D3DA14A3478FAE1E191939
	C7C3C3A384DADC051919194FF3BF6C926BD7AE3DD5A3478F34BAAFF7D4EEB7B1
	54AB56AD0BD40604F3696C92254B96B84445450DAE5FBFFE316AAB2E858585CD
	4E4D4DF5E37F3F76A869236349F5A0B1541EF3E7CF77A30A31BD76EDDA4554F9
	95EEDDBB2BB367CF56D6AD5BA7ECDEBD5B97D6AF5FAFD0E794975E7A49A1CF29
	AEAEAE37A8619E3B74E8D0BA7C1A9BA55DBB76431D1D1D5129EE51E5B75A6738
	60C080682AC77DDCDBBD7BF76A9EB66FDFAEB8B9B929CD9A35CBE2225944BD7A
	F532A98151CD4B56A2C6022FF3987F97C03A405C75ECD871AE8B8B8B423F95A7
	9F7EFA22D58B10FEF7EF06EAECBB50D98B5AB56AA5F4EFDF5F717676BE43CFF3
	0D125D36D5715399527D7C7C54DF0773D3D6AD5B15B40503070E6CCFA7D78C03
	070E3892917A24292949B56CA6A68F3EFA48A95AB5AAD28DE053DB04172F5EAC
	42CF6A2089E19FC90852E6CE9DAB90C042FDB84286FBC8ACACAC3FF0476D0A32
	2CDE8460CACECE56BDDFC6D2CB2FBFAC501BF0B32D8AAC61C386059308CFA2F6
	FE3A0648C68F1FAF2C5AB44821235F7172722AA5E7F309B55D9DCE9D3B5785BF
	F258A0A68D8C25D583C69231E826F786158E0A416A57B97EFD3A7DBC7C7EFDF5
	57A5A0A04069DEBC39547C71EBD6AD53F974360789999AE84466CE9CA93CF7DC
	734A6060E016FE97552071B3323C3C5CB977EF1EDF4DED408347CFFA9769D3A6
	B972712C0202EB85175EE0B36B039E21656D5581D5A953A7B92446940D1B36E8
	9E231A5A88ACDFCB481609A82A2454B3A993BE9F9696A69496962A0F1F3E5456
	AC5881FAAC0405056D494F4FF7E08F5B9DBA75EB6E183E7C38BF0196131717A7
	848484E4F0E935233A3AFA557A4F94C2C2422E49C5193972A442F7E53B122D36
	D141521D68EDE7E7B71F06FADB6FBFADDCBE7D5B57CE3B77EE285446D40FC5DB
	DBFB0819EF71FC159B00E2AA5AB56A0F3FF8E0035D79CD01759F84BA4E643DFB
	ECB3417C4AAB515454E444FD792219235B60C8C7C4C4282B57AE546EDDBAC525
	5694070F1EE8064CA8ADD28D84D233394DFDF858EA1BDCF834760DDD029393EA
	4163A92CFFFCE73F1D4818E55223FB903A5CA5A4A4843E661EF7EFDF57DE7DF7
	5D0595AA71E3C66BC83AACC5A7B7195AB66CB930202040270ABFF9E61B9DE5D7
	B367CFEEFC6FCD9933678E3755C86B4B972EE5BBA80D68D4D1799225294C0C3F
	6E020B235724AE3261ED6EDCB8914BF4EF8676C08001E8442EF5EFDFDFA645D6
	90214382EAD7AF7F841A5665DBB66D7C05FFE5C489130AD519BC2B3FF5EEDDFB
	79FE9AD52031E84AF5A574E7CE9D5C42CB59BC78B1429DD04F57AE5C71E06CA4
	939393E35EBB76EDABF3E6CDE35258C62FBFFCA2B8BBBB2BEDDAB54BE32CACC2
	D8B163EB51FBBA02220586C6F9F3E7B984BFE5E2C58BCAB061C3D0FE3E2401FF
	F1A851A302F81456016E41FDC85545C4951E039175819E855544D6942953BCC3
	C2C2A6D0FB7596CAA1501D570E1E3CA8339ACA037DC28C1933146A0F50DFEFF8
	FBFBBF9F9494D4F2F8F1E336E97A16015DB6C949F5A0B16408090D8788888835
	A8A0BB76EDA27F5B06840B46C0A8E2ECDBBC79B3CD882CB2F29A50C52FC190BA
	1E587E1E1E1EFFCACBCB73E28F690E59B21330B7EDEAD5AB5C2AF9A0D291203A
	BC6EDD3A61C3F48F93C062B760A67EE4AA2C06220BEE429B1459090909AF5087
	72BD5BB76EBA0ECF18187518376E1C3AC37BD44E64AE5DBBD6914FA1396DDAB4
	1944F555777F45F1F3CF3F2B0E0E0E4A972E5D349B73161212B288DA47DDBD15
	0584A2ABABEBF58913277A72369AF1F1C71FBB4446464EAA59B3E62D6ACF942F
	BEF8824B553E870E1D8291074152D2AC59B3194B962CB14A7F017185BA6C89B8
	D2633892A5B5BB3034347412D5D35F83838375238510DEE672F7EE5D859EA742
	ED03DC878A9797D7165B75E75A0A5DAEC949F5A0B164485454D442CCA33A72E4
	08FD4B0CB05C4801C3E7FE494949894D0C5B5379D6C7C7C7FF46C95FBE7C5967
	F9514518CF1FD39C55AB5655C5D02C597F5C2AB97CF5D557BA91BBBE7DFB76E0
	2208E171125818B98275A826AEF4A0A1657761912D892C6A2C5DA973CF2371F5
	108D30469E4D01A37475EBD685857B802CDB867C3A4DA13ABCF195575EE11289
	A36DDBB6982E308BB3914ABF7EFD1A53677E0FF35845828E11736AA8735DC659
	49870C8DA7A80EF622D17B06A3A0702B9BFA3EE9819BEAEF7FFFBBD2B06143CC
	E7FD890457726161A1661DBA8891ABB2188A2CAD46B256AF5EED4C7DD9ED050B
	1698FD0C8C71ECD831CCC584972791B3B12BE8124D4EAA078D253DF472F5C270
	EE679F7D4687C572FCF871852C1A252626C6AA736440FFFEFD7B6038FAE8D1A3
	5CBAFF929393834EB0F89D77DED1DCF2D3438FA10F7CE0B86732416346151EAB
	8ED672D6C2781C041677283AB76079E24A8F81C8BA48EF60533E8DD5A086328A
	3AC3D3B070BFFEFA6B2EA5E95CB8704177CFA95E1793C81C9096A69D47AAA0A0
	A076AD5AB54A366FDECCA5110716EC787A7A9EA0FA277535E1D5AB572B93B8DD
	DEB973E747BA6C2A02DCBCD4213E4C494989E42CA5414237BC4183063B511730
	77AFB8B8984B5131304F0BF3B530C58444FC57898989D1A86FB230700B5668CE
	D5A33014595ACCC9A2763D150610A6BF88243939192B6D3791E8E59CEC07BA3C
	9393EA4163094C9E3CD9A54E9D3AE7E9271D92C37BEFBD870A7373DCB87156B1
	78C19A356B1CA8F3FF2E3535954BF55BF4965FE3C68D97F257AC0259705BBB76
	EDCAA59203162350E778871AE0069CAD30EC5D6019BA050DE75C3D0A439165AD
	912CEA002BC7C6C662026FE9E0C183959B376F72E9CC07223D333353B7341D8B
	343232325C381BA950DD48C6487B45E6873E8A3367CEE856130E1B36AC056727
	85EEDDBBF78421F5EDB7DF72CEE22161A290F0D943F7499A58A4E73E84AEE33E
	EAFBA953A7386731C0FB81FA82F7AB458B16D2143CC49528B7A0310C45964C77
	219E3589AB43E9E9E99CB338F6EFDFAF7B16A413AC3E715F3474792627D583C6
	12A04A329E94E97F5678C8008D31967D6B396C5D96B66DDBBE8E86F9D2A54B5C
	AAFF0F2C3F7A891E50E314CA5FD39CD75E7B2DAC6AD5AAA59B366DE2528905AB
	47308131323272366729147B1658B0A4F56EC18AB8760C4496E6EE427AAFBCFC
	FDFDB751DE4A7E7E3E97C872FEF18F7FC0AD8695A8C7E9DAA2383B69F8F8F814
	FCF18F7FE4DCC582D124AA17E8D0DFE1EC8443C64D15BA8653A3478FE65CE500
	C1830E312121E125CE5A386E6E6E9908DF239341830661E46415672914329452
	718F648A2B3DA8FB988F4962EEE7962D5BFA73118442F5AF1D0C046AA7385771
	E8EB46D3A64DFF87B3B31BE8F24C4EAA078DA5DCDCDC2A18BD5AB87021FD2917
	7448183559BC78B13B5F97666467677BD6A851E332FCD28FA267CF9E989C0FCB
	CF6A13FAA881CF45AC1891935FF56075A8A7A767E1983163AA737642B16781A5
	770B5A326F0623A58879A4A5BB909E47777777F72B58A22D7AA401208C0B3A0F
	4CACA54E4BDA68C39A356BAA531B7203936F65316BD62C8CFC7CCF590A879EC1
	1BD4E65668E2B1B9C065E7E5E5756EF2E4C95216EF90C19AD9A74F1FCE4D0EAF
	BEFA2A9E87148145ACC02A46AD80C8C21C3532740670FE422143A740A6E08527
	AA56AD5A17F3F2F2A4F41DD6822ECDE4A47AD058224BB00B3A8C2B57AED09F72
	41C7429D2FDC7083F9BA34232C2C6C19296F5D191EC5F7DF7FAFB3FCA833EDCB
	5FD79C8C8C0C376A848B31F9582467CF9EC5303556EC48A9E0C01E0516DC826A
	A1182A8AA1BB50669CAC79F3E6394545452D7272727A00B78129EFBF2520BE0E
	E65B0605056D9D3E7DBA37174318F1F1F12F22AC88610C1FD12024055613FEE9
	4F7F121E3260D2A44975E999DF406C412DB871E386AE438F8E8E9EC645108A3D
	08AC37DE788373D206ACAC27E35978FBFBF6DB6F7B393B3B4B999BA8075E2E04
	A58E8B8B7B85B3B50BE8D24C4EAA078DA566CD9ACD258B937ED586A14387C29D
	F0BF7C5D9A909292124E96F5DD2D5BB670291ECDC48913B152EAEC5B6FBD65B5
	B00DAD5BB71E8197B9BCA5F3E682407208FC277345A7BD092CFD9CAB8ABA058D
	A185BBB071E3C6B9182DF9F4D34F3957F940A090410363EA0817431801010105
	74AF382779A0FCC1C1C1E99CAD30A8BD7D1FE7C6B3D70AACE87375752D494D4D
	ADC7C510C61381653EB2041619521970D5CB7EB7B0CA9D443BFA10AB6C2B2503
	BA2C9393EA41638944C4A753A64CA15FB50195DDD3D353DE92903214161656A2
	177A07864DCD59AD0397072CBF888888C97C2ACD59BE7C79155F5FDF7FA18111
	C19E3D7B742373C9C9C96D380B29D89BC0A273CFC12458D1CBE9011A43761716
	91F815EE2EA4F73715CBDE452DD73695BE7DFB42A01470318470F4E8D1EAD4A1
	176329BF6CC8B042FDFF9AB316023DE708AA7F0F76ECD8C1B968039E3D625291
	D8CEE7A208E389C0321F19022B3737B7325CC1D895433630A010176BD0A041D1
	9CFDEF1EBA2C9393EA4163893A8EE3AB56ADA25FB561DFBE7D584D789FAF4B3A
	F1F1F12F40547CF7DD775C02D3F9CB5FFE027FF3ED3163C6F8F0E934A777EFDE
	09885565696C3234B288C44D16CE0A2C4B9689BD082C8C5C415CE1FD31251443
	453174178A9E93959E9EEE4D8DE1DD03070E706EF2811B016EC2CE9D3B0B8D99
	43A22D1142176E2FD92048B28383C383B4B4B440CEDE220A0A0A10BBEB8B5EBD
	7A710EDA82809F084F3370E0C0B65C24213C1158E6234360515DEB81BA51DE02
	2E9120F8685050D00ACEFE770F5D92C949F5A0B1E4E7E7775766E75116C477AA
	5CB9F2436AC0EAF0B549832CC56AA4EA7FAC68058228C126C264F9ADE6535A05
	6A983F469463ACC4AC28CB972F8758BC49F742B89BA02CF622B048904E44A3A5
	45FDD04F7C7775752D6AD3A64D7D2E82103C3D3D77C1E5AD15D80C9EAEA378C1
	8205D5B80842A0F76AA996EF156284D13B2064C27EDBB66D7BE15D3A7DFA349F
	5D7BB00801AE1D2E92109E082CF39121B0A86E6C429C2AADC02213171797DB33
	66CC10B6600D8BCAA8BFC6EADDF95A267A1E6FD125A9EA23B5A47AD058F2F5F5
	BD2B62D2AEA9E805D6C99327854F802D4BAB56AD2621E0DAB56BD73877F3C1EE
	E8B0FCC87A6ECDA7D59C214386F8D7A851E3EE9A356BB854E6017727BDB80893
	31854F29157B11586161611908762823F86E5920E611978ADEB522327A840A2C
	EADCD3B0EFA656A023A77740A83B8A1A7447B851B51C6D7FF3CD37D1190A7113
	9250EB87397C5864622DB02D16B58742DD9E4F0496F9C810581E1E1E9B64EC6C
	600C68866AD5AADD1E3162845081151A1ABA92EECD262D534C4CCC72BA24557D
	A496540F1A4BD5AB573FBE7AF56AFA551BE022244B4EBA8B303D3DDD871AB4EB
	7FFEF39F39E78A8391056C0BB263C70EAB856DA0CE7E2E2A6645A2F38E1F3F1E
	FB2C9ED9BA75AB268120ED45606DDEBCB9526464E41CD9220BE20A9D1F89AB8B
	212121C2E761CD9A352BD0D1D1F181C82DB08C81B0222484B04AB51F672F846E
	DDBA7544604E2DF7E944847B6A1F1F8E1B37CE978B51618E1D3B56B961C3865F
	A12DB106FA6DB128FF8E5C24213C1158E623436075EEDCB90FDA292D427F00EC
	5B2A7A8EA535A14B3239A91E34967C7D7D77232E925620A09BBBBBBBF449EEF0
	0F474444E83A2F4B81D5899737212161089F5E73E819D5A853A7CE45EC726E0E
	9890888EA94B972EBDF854D2B11781A507220B738A76EEDCC9B989C3405C15C9
	10577AFCFCFCBED662310B82E392C02AFDE4934F846ED6DBA851A35C7A873917
	6DC0B3C1C85FD3A64D53B91816D1B76FDF5654171F7CFEF9E79C8336186C8BB5
	868B228C2702CB7C6408AC3367CE38D1B338A7453C4BB8B931C93D3939B91D67
	FFBB872ECBE4A47AD058F2F7F79F8B096B5A816D6AC892931AA661D0A041ADA9
	C3BABF7BF76ECED572A64F9F8ED58F97E6CF9FEFCCD9684EC78E1D8742E8FDF4
	D34F5CAAF2C1AA49044DA567BCEBC0810395F834D2B137818591AC962D5B6622
	FE92C8912C4371D58CE0ECA4101616968E387032F6BD3304D743A2643D672B0C
	32040F366FDE5CD3394C88504FEF32C29ABCCFC5B098C68D1BE7211AB625F329
	CD05DB62B9B8B8948C1A35EA192E86309E082CF39121B0407878F8743AAF9041
	85F2C07C4E1F1F9F438585854FC2343C2A75EDDAB50B265F6A31F48ED5525451
	94D8D8D8D17C5DC2D9B66D5B25CA639FE85839086C88B247444448D95EC614B2
	B2B22A6124027B5A99C2D6AD5B317A758F3ABD703E8526D89BC0027A910581BB
	6BD72ECEB5E2A011C49C09760B4ADF3267ECD8B101D84243E6DE77A5A5A53042
	50BF93395B61A4A4A4789370FB0CEEC7BFFEF5AF9CA31C207EB0DC1D23BF244A
	3FC8C9C971E56258CC942953EA93D8B98115CA5AA0DF168BDAAD595C04A13C11
	58E6234B604D9830C187DA93129961404A4A4A30DD0453008673B676015D9AC9
	49F5A0B144D68D23DDB0A2C58B17D39F72418459127377323232A46D95939090
	301082F1C71F7FE45CC581F83BD4E8DE1E3E7CB8F008CFA692989888D139E5CB
	2FBFE452A983556918B1208B79097F5533EC5160E9898C8CCC84BBD092912C83
	912B2973AE8C41E2E790B92E6673D8BE7DBBAE7E2F5BB6EC69CE5228D4B83B44
	474763635E180D166D546D8C0B172EE896A063C56DF7EEDD0771D64221B13309
	8B4EB0F8443653A74E45E4ED734B972EADC9D90BC51E0496B1CDFF6580BA8F51
	D1C0C040E1020BD079D7BEF8E28B9C9B7830C5878C9CEBD48E3CD92AC79404A2
	A2A2A64355439DCA02AE09CC03F0F3F393B6D9735656963355F8B3685464A0BF
	06B23E3EE12C35879E11DC0C7FC3C6D9E50D05676767A393F865DAB4691EFC55
	CDB06781454602568455D85D6820AEA4BB05CB42626E5A7878B83437213A2A1F
	1F9F0D9C9D349E7FFEF928320A4F533D500E1D3AC4B95B0EE68F61D531899F2F
	E95A1A7176C2A1F7C6D9DDDDFDB4ECD0193032B172312E2E6E20672D1C6CF62C
	BBAEA3BED4AF5F5F8AC0A2BAACDBEC598BE0B5A8FBD8C984EED9ADF8F8782986
	5552525227CC8F3A7FFE3CE72A96D6AD5B2BD46CE5707676035D9AC949F5A0B1
	04162C58E046C2C4EC09D4E680958A64F9978E1A352A4897A904222323679280
	93BA4F19561651E7F8805EE4E7385BCD9930614243EAE04B8CED007FF9F2652C
	24406518CB5FD1147B165840EF2EC4489639EE4234B05ABA05CB327EFCF81670
	1362AF4DD1C0FD4FE20A8DAF70F7A01A8B162D72C32A26748E98D86BC99C26AC
	7C1C376E9C6EC52009D04C125A55391B6960D51746DA4F9E3CC9A5100FB6C522
	61B25FE65C196A6F87C2958AD01CA6CE0D351504CDC4E81546EC1B3468206D03
	F10E1D3ABC295B64E1FD84B8A27EF6D68811233A70D6C2C1B32603E11B19830C
	DCF7A10D93D6875B0BBA3C9393EA4163494FA74E9D92F0923DCAF55411CE9C39
	A3DB20923AFCA99C9D703081B3468D1A25F9F9F99CAB3C505148441CA3BCAC36
	C92F343434031D9A5A54EBE1C387A37C27A923B5CA3E8AF62EB00046B2CC7117
	9611579AB9050D292A2AAA4CEFCC0919DB6960651C5C77CB972F971EC8560F5D
	4F25EA1C8750BB558CADB02A12C51AAB6C492C2B75EAD4B9144FF0A9A54375B3
	726060E0E7588422036C8B45C2E7E1E0C18385466E2F0B46D41313136348687D
	85F98930D22B124AC610CCE523A35FD767F8FAFA7EDBBB77EFE7B2B2B23847F1
	1C3E7C5827B270BF3EFCF0432E8538F42357105723478E6CCFD94A233636760C
	FA06180E22C1359060DFB16FDF3ECEC97EA0CB3339A91E34960CA10EE37D0C91
	2318A828A811C43C20CC07FAEC871F7E90B2C1302A794040C0DFDAB66DABC9EA
	1CB21274B17E28BFD7B8089A939797E7429DC28F088668C8D1A3477593731308
	FEA8E63C0E024B8F29EE426BBA05CB42F570564C4C0C974C1CAFBFFE3A26EFEE
	E16C3465E0C081C1D4F01FA5F74E370FCC14E0265DB97225DCE858D5BC61CC98
	319E7C3ACDE8DBB76F18BD13F7446FC48DD14488466C8BC55949070288F4E960
	CCE7C57413044536B72DC633819B162BE1488C5CA5F6754441418166B107E3E2
	E2848F64951157D246AE0C993973A6B3ABABEBED65CB96099B0E70EAD4295DA8
	A21E3D7ABCC4D9D81574892627D583C69221EBD6AD73A0CAB106133045EC5D86
	870271E5EDEDBD2F3B3B5B685C1C43929292E2202AB4DC6F6DDEBC7970C3FD42
	0D4B6D2E86E674EDDAF5653408FAA5EBA84C1D3B764447B701FBE8F1C734E771
	125870174644441875171A8E5C595B5C81FEFDFB873B383828E7CE9DE3125A0E
	DE3BAC548B8E8E1EC9D9680EB52F8E2D5AB45808B71B8C0E2CF230467171B182
	95B8D461DC6DD5AAD5583228AD164098C4C4D290909072CB6B2ED8168BEEC3F5
	499326F971369A919696E6D2BC79F3D9746F4B49B028870F1FE652950FF68A45
	F04A17179707C1C1C10B274C98E0C6A7D41491EE42ADDC826A848585CD767272
	BA87589008B65D910521283F0C16EC9F09D720F52B87F2F3F31D390BBB822ED7
	E4A47AD0582A4B5E5E9E033D9CF7F192414454A4E2E3C1604B0B8CF2346AD468
	EBA2458BA489ABAB57AF3AFAFAFA1EC636235A82E1D7A0A02025343474211745
	730A0B0B2BD14BFFA57E0359EC0147CF0DF3DCACDA913F4E020B4064E9DD8586
	22CB405C5DB2C69C2B35F6EDDB57890C83EFB1084214306C3012336DDA34CDDC
	836A60243B3E3EBE0BB53B973019175313CA82B2060606C225787CC0800151FC
	55AB416DA337BD3757E92797D032B032115E08ADB6C532464A4A8A3FB54D6BD1
	31631E9531F72DCA8BF96F70CFD173D9919C9C6CD57AA27717A2FFB3C45D88BA
	4FF7C02AE24A0FDDF767C8A69B4BF5FD2ADCADA3478F36C93B85ADE530AF1183
	23F45CEE346CD8F0C3C4C4C40E3B77EEB49BB85765A1CB3639A91E34968CD1AE
	5DBB4154F1AF60A93F26536387FC470131B67EFD7ADD4A037A416F51254FA787
	25C52DA887CA9982617E2CAFD61A6C024C2F6029BDC8566B14FAF5EB17416578
	80B220EA747878B8D5049F9EC74D60E9219135573F27CB70E4CA56C4951EAAD3
	59CF3EFB2CDF39CBC16A386F6F6FABB807D580D06BD0A0C136187808B2891136
	3C0FCC3D43C7499DCE4A6AD3A4197DE6426DD81B589482C5299682984E5E5E5E
	3F923810BAD17645E9D3A7CF739847850E1EF3AA30BF0AC08D899115C44DF3F0
	F038D1B973E79EFC159B00EE4288BE8A882C4371A5955BB03CF2F3F39DA86D7A
	999EC37E2C72819763EDDAB5FF791600750493D831E2065720BD8FE7A99D989A
	999929745F545B856E81C949F5A0B1541EE9E9E91EC1C1C17348C05C4303807D
	B4102F6BDBB66DCAC18307754BA4D199A0A260040913EB9C9D9D6F0505052DA7
	CE4578D4E0B2501E35A95C97D091A12C5A27BC90882E4D8DF9A63D7BF658CD25
	D7A44913DD882375EE17962E5D6A3597A51E08ACF6EDDBABDE335909612B286B
	AB0A2C7617CE85E0EFD1A387DE2D18C2FFB619525353DBA3A1C5689BDABD3437
	41D893B53B8A4F6F139C3871A24A9B366D26C10247DB441D3846D46F76E8D021
	A9B0B0903F651B6CDCB8D18984C6BF504EB5FB6B6AE2C0C230365EE453DB041F
	7DF4519598989854AA171731BF2A37375737478CDAABEBF48CDECCCECEB6CA62
	9C47A11FC982CB55ED7E1B4BE88F20AE860F1F1EC7A7B219A80F8FA0FEF97D12
	5137B1E21E3B9420E82D0645A8BD7A486DF77612607DE819491D18B135D4B491
	B1A47AD0583285D5AB57BB9095D59F1EC87B75EBD6FD8644CD1D5464C4DBA086
	E121FD7D9CD4713E757243737272A405112D4B6C6C6C62A54A957011564DF462
	DEDDB4699317FD6E1566CC98518F2CC46B6475596DD2BD21FEFEFE19F443F55E
	C94CF41E5A3DBA3044567878F85CAA1F36E3162CCBB56BD7B094FB1CFDAA7A1F
	CD4D24D64AE7CF9F1F48BFDB1CBD7AF58AA136EBACB7B7F7FE949414AB05087E
	14DDBA75EB0ED14BBF5A9402030377EFDDBBD76AC65E79646464B89141FA2E89
	9692468D1ABD979696E6CDFFB249E02E24437152952A5554EFB5B1446DF1ED11
	2346D89CB83264F6ECD96E246EC763F4D0C5C5E52A3D8F85A3478FB63963502B
	D4B4917A529EFA3F7AE962F9C8EBEF280000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="3" length_in_bytes="7800" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000002580000
	001E0806000000F0F860840000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313147F3423700001DEA49444154785E
	ED9D09784DD7DAC71B450C41103289A1995B844406212A42A3C6A6868A72E36A
	451B53512425A852844F08DA70B5B7DAE0DE5BCA57636A28AAE5AA9A6E7B558B
	16AD986A6869C4B4BFFFFF749D7B4FF3ED1327C95AFB9C86DFF3AC27C9CE39FB
	5D7B586BFDDFF5AEE1214DD36C4EB6909D9D5D313636B64B5050D01B9E9E9EBB
	DDDCDC2EB8BBBB6B75EAD4D1F0F32A8E7DE1E7E7B7A46DDBB67D727272AA8BAF
	393CC8EBC35E5E5EBB1E7DF4D10C71C82E346DDA7452E5CA95B52A55AAD835F9
	FAFA9EC8CFCF17B92A39010101E38CBE1EDA7BE4914786882CD88DEFBEFBCE29
	2626E675948D737DFAF4692C0EFFE1983469523DBC0F5B503EBEE9D1A347A838
	EC502C5EBCD813755181DEFB509254BF7EFD53787EE5C4E90D253E3E3EAE5AB5
	6AB7F5F2656B621940D95B77FCF87127715A8762C4881155C2C3C367D6AD5B37
	1F75EEDCF4F4F49AE25F0EC9E5CB971FEAD6AD5B2AEEEB2DBDFB6D2DD5A851E3
	0CEA8020711A87E4CD37DF7489888818D8A04183C3A8ABCE878484CC484949A9
	2FFE7DDFA1A78DAC25DD83D65251CC9933A7160AC494DAB56B9F45E1D7BA76ED
	AACD9831435BBD7AB5B663C70E535ABB76AD86CF69CF3CF38C86CF69AEAEAE3F
	A3629E3568D0200F711A87A54D9B36832A56ACC842710B85DF6E8D61BF7EFD22
	918FDBBCB7BB76ED323C6DD9B245AB55AB96D6B871E34C91A55251AF5EBD0C54
	30BAB6542554167C9947FE9603FB4071D5BE7DFB592E2E2E1A7E6A356BD63C87
	72D144FCFB0F031AFB4EC8FBD9962D5B6A8989895AD5AA556FE079BE0CD1E550
	0D37F294E2EDEDADFB3E1437E5E6E66AAC0BFAF7EFDF569CDE30F6EEDD5B114E
	EAC1BE7DFBEAE6CDD6F4C1071F68952A55D2BA00716A87E0DCB973E5F1ACFA43
	0CFF0827489B356B960681C5F271118EFBB0CCCCCC87C5471D0A3816AF503065
	6565E9DE6F6BE9D9679FD55007FCE888226BF0E0C14110E199A8EFAFB08364CC
	9831DAFCF9F33538F99AB3B373019ECF87A8BB3A9C3A75AABCF8CA7D819E36B2
	96740F5A4BD6C04DEE492F9C05026A57BB72E50A3E5E34BFFEFAABB662C50AAD
	59B36654F157A3A3A353C4E91C0E8899EA6C44A64D9BA63DF1C4139ABFBFFF26
	F12FBB0071B334343454BB75EB96B89BC6C10A0FCFFAA7C99327BB8AEC940A0A
	ACA79E7A4A9CDD18F80C61DAAE02AB43870EB32046B475EBD6999E232B5A8AAC
	3F4A4F1604547908D52C34D2B7535353B5828202EDEEDDBBDA3BEFBCC3F2AC05
	06066E4A4B4BAB2B3E6E773C3C3CD60D193244BC01A5A75DBB765A93264D1688
	D31B466464E40B784FB4BCBC3C919392336CD8300DF7E56B88168768205106A2
	EBD7AFBF870EFA6BAFBDA65DBF7EDD94CF1B376E68C823CB87E6E5E57510CE7B
	3BF1158780E2AA72E5CA77DF7DF75D537E8B03CB3E84BA49643DFEF8E381E294
	76E3ECD9B3CE68CF13E08C6CA2231F1515A52D5DBA54BB76ED9AC8B1A6DDB973
	C7D46182BACAD4138A67721CEDF828B40DB5C469CA34B8053627DD83D65261FE
	F5AF7F558030CA46257B170DAE969F9F8F8F158FDBB76F6B6FBCF186C642151C
	1CBC12DE610D717A87A1458B16F3FCFCFC4CA2F0CB2FBF34797EDDBB77EF2AFE
	6D383367CEF44281BCBC68D12271178D81953A1B4F7892D2C4F0FD26B0D87305
	7195416F77FDFAF52247BF55B4FDFAF56323723E3131D1A145D673CF3D17D8A0
	418383A858B5CD9B378B2BF82F478F1ED55066F8AEFCD0B367CF27C5D7EC06C4
	A02BCA4BC1B66DDB440E4BCFC2850B3534423F5CBC78B18230A39C050B16B8D5
	AE5DFBD2ECD9B3452E4AC74F3FFDA4B9B9B9696DDAB4491526ECC2A851A3EAA1
	7E7D8722858EC6E9D3A7450E7FCFB973E7B4C18307B3FEBD0B01BF66F8F0E17E
	E2147681614173CF5549C495190B917506CFC22E226BE2C4895E21212113F17E
	9D443E3494716DDFBE7D26A7A928D8264C9D3A55437DC0F27EC3D7D7F7EDBE7D
	FBB63872E48843869E6580CBB639E91EB4962C81D0A8101616B6920574FBF6ED
	F877E9A070610F180ACEEE8D1B373A8CC88297F7280A7E3EBBD4CDD0F3AB5BB7
	EEBF7372729CC5C70C079EEC588E6DBB74E992C8957A58E820880EAC5EBD5A5A
	37FDFD24B0445830C3DC7355180B91C570A1438AACF8F8F8E7D1A05CE9D2A58B
	A9C1B3067B1D468F1ECDC6F016EA898C55AB565514A7309C56AD5A0D407935DD
	5F59FCF8E38F5A850A15B44E9D3A1936E6AC499326F3513F9AEEAD2C28145D5D
	5DAF8C1B37CE5D98318C356BD6B88487878FAF5EBDFA35D467DAA79F7E2A7255
	34FBF7EFA793474192DFB871E3A96FBEF9A65DDA0B8A2B96E5D2882B33963D59
	46870B9B366D3A1EE5F4D7A0A020534F21857771B979F3A686E7A9A17E60F850
	F3F4F4DCE4A8E1DCD282CBB539E91EB4962C89888898C77154070F1EC4BFE440
	CF050A9831F70FF3F3F31DA2DB1AF9591B1717F73B257FE1C20593E787823046
	7CCC70DE7BEFBD4AEC9A85F72772A596CF3FFFDCD473D7BB77EF58910529DC4F
	028B3D57F40EF5C4951956B4225C78D69144162A4B5734EE391057775909B3E7
	D916D84BE7E1E1410F772F3CDB46E274868232BCFEF9E79F17399247EBD6AD39
	5C60BA30A3943E7DFA04A331BFC571AC3261C3C83135685C170B53CA81A3F110
	CA600F88DE13EC056558D9D6F7C90CC354FFF8C73FB4468D1A713CEF0F105C49
	7979798635E8327AAE0A6329B28CEAC95AB66C5955B465D7E7CE9D5BEC67608D
	C3870F732C26A33C09C24C9902976873D23D682D99C1CBD583DDB91F7FFC310E
	CBE5C891231A3C1A2D2A2ACAAE6364486262623776471F3A7448E4EEBF2C58B0
	808DE0D5D75F7FDD70CFCF0C1E432FC6C079CF54C2CA0C059EB38E5609D3D2B8
	1F049668504C61C1A2C495190B91750EEFE063E23476031565041AC3E3F470BF
	F8E20B914BDB3973E68CE99EA35C5F85C8EC979A6A5C446AC58A15B56BD4A891
	BF71E346911B7970C28EBBBBFB51943FA5B3092F5DBA540EE2764BC78E1DEF19
	B229090CF3A241BC9B9C9C1C2E4C2A034237B461C386DB58163876EFEAD5AB22
	172583E3B4385E8B434C20E23F4F484888647953854558B04463AEEE85A5C832
	624C16EAF5143A401CFE2293A4A424CEB4DD00D12B2C951D70793627DD83D612
	993061824B9D3A754EE3270EA9E1ADB7DE6281F965F4E8D176F178C9CA952B2B
	A0F1FF3A252545E4EAF7983DBFE0E0E045E22B76011E5C6EE7CE9D45AED4C0C9
	08681C6FA0026E28CC4AA3AC0B2CCBB0A0E598AB7B6129B2ECD5938506B05C4C
	4C0C07F0160C1C3850FBE5975F44EE8A0F457A464686696A3A2769A4A7A7BB08
	334A41D948624F7B49C687DE8B13274E9866130E1E3CB8B930A784AE5DBB76A7
	23F5D5575F09CBF28130D1207C76E23E29138B78EECFE13A6EB3BC1F3B764C58
	9603A31F2C2F7CBF9A376FAE4CC1535CC90A0B5AC35264A90C17F259435CED4F
	4B4B1396E5B167CF1ED3B3804EB0FBC07DD9E0F26C4EBA07AD2582423206CAF4
	3F333C54C0CA98D3BE8DECB62E4CEBD6AD5F62C57CFEFC7991ABFF0F3D3FBC44
	77503935155F339C175F7C31A452A54A051B366C10B9920B678F7000637878F8
	0C61522A655960D1933687054B12DAB1105986870BF15E79FAFAFA6E866D6DF9
	F2E52247A5E79FFFFC27C36A9C897A04D71621CC29C3DBDB7BC59FFEF427615D
	2EEC4D42B96083FEBA30271D3837E5710DC7468C1821ACAA8182870D627C7CFC
	33C2B4746AD5AA95C1E57B543260C000F69CBC274C4A058E520AEF914A716586
	659FE33121E67E6CD1A285AFC8825450FEDAD041403D25ACCAC35C361E7BECB1
	FF11E6CA0CB83C9B93EE416B293B3BDB89BD57F3E6CDC39F6A6183C45E93850B
	17BA89EB328CACAC2CF76AD5AA5D605CFA5E74EFDE9D83F3E9F9D96D401F2AF8
	6CAE152373F0AB19CE0E757777CF1B39726415614E2A65596099C382A51937C3
	9E52AE796464B810CFA3AB9B9BDB454ED196DDD340B88C0B1B0F0EAC45A3A5AC
	B761E5CA95555087FCCCC1B7AA983E7D3A7B7EBE1526A58367F032EADC120D3C
	2E2E0CD9797A7A9E9A30618292C93B7058337AF5EA25ACA9E185175EE0F35022
	B0C03B9CC5681414591CA30647A79FB02F15383A2B540A5E46A26AD4A8712E27
	274749DB612F70693627DD83D6123C41B41755B48B172FE24FB5B06141E3CB30
	DC40715D86111212B218CADB94877BF1EDB7DF9A3C3F34A6BDC5D70D273D3DBD
	162AE1AB1C7C2C9393274FB29B9A337694147052160516C3827A4B319414CB70
	A1CA75B266CF9EED1C111131DFD9D9F90EC306B6BCFFA581EBEB70BC65606060
	EE942953BC4436A4111717F7349715B15CC347365C9282B309FFFCE73F4B5F32
	60FCF8F11E78E63F736D4123F8F9E79F4D0D7A6464E4649105A9940581F5F2CB
	2F0B4BC6C099F5709EA5D7BFAFBDF69A67D5AA55958C4D34C3281717A56ED7AE
	DDF3C26C9900976673D23D682D356EDC78163C4EFC6A0C83060D6238E17FC575
	1942727272283CEB9B9B366D12B9B837E3C68DE34CA993AFBEFAAADD966D888E
	8E1ECA97B9A8A9F3C5850BC971E13F95333ACB9AC0328FB92A6958D01A46840B
	838383B3D95BF2D1471F09ABEAA14081434367EAA0C88634FCFCFC56E05E094B
	EA60FE838282D2845969A0BE7D9BE7E6B3370ACEE8737575CD4F4949A927B221
	8D0702ABF8A8125870A4D219AA57FD6E71963B443BDB10BB6C2BA5025C96CD49
	F7A0B50411F1D1C48913F1AB31B0B0BBBBBBAB9B125288BCBC3C27BCD05BD96D
	5A9CD93A0C79D0F30B0B0B9B204E65384B962C29EFE3E3F36F563032D8B973A7
	A9672E2929A99530A184B226B070EE991C042B7B3A3D616528C28567217EA587
	0BF1FEA670DABBACE9DAB6D2BB776F0A9415221B523874E8501534E85739955F
	3570AC58FEBF10A6A580E71C86F27767EBD6ADC28A31F0D9734D2A88EDE5222B
	D27820B08A8F0A81959D9D5D8EA160EECAA11A3A505C176BC0800191C2FC1F1E
	5C96CD49F7A0B58486E3C87BEFBD875F8D61F7EEDD9C4D785B5C9772E2E2E29E
	A2A8F8FAEBAF450E6CE7AF7FFD2BE3CDD7478E1CE92D4E67383D7BF68CE75A55
	A55D9B8C952C57E28687F30EA725ABA4AC082CF65C515CF1FDB1652986926219
	2E943D262B2D2DCD0B95E1CDBD7BF70A6BEA61188161C28E1D3B4A5D3307A22D
	814297612FD57091E40A152ADC494D4DF517E64BC58A152BB876D7A73D7AF410
	168C850B7E72799AFEFDFBB7165992C20381557C54082C94B56E2C1B454DE092
	09171F0D0C0C7C4798FFC3834BB239E91EB496D018DEE4A06E8808431267FF94
	2B57EEEEBE7DFBEA886B53466E6E6E657777F7EFE9C1EBE5E55E89B37CA8D403
	0202968953DA0554CC6B1856D0CBA3AD89A14188C55F5099480F1314069E7F06
	F2AC9B0F5589B322615AAAC08A8E8E4E7FF8E187D98BA96B5366E24E02AC205D
	5D5DCF366EDCB881C882145006B63FFEF8E3BA765524F1AE5D9D3B776E659105
	29C0435F84A46B534562D96FD6AC999401FB9191913D9C9C9C34384CBAB68C48
	5CF9DEC3C3638FC89214F0BE66A07ED4B5272B71E91C1F1F1F65028B8EA79E5D
	55896308E1E84A1558DEDEDE1B708F74EDA94862D57D763E489BB0C6496528DF
	9CBD3BC7C804C1FBAA9E36B296740F5A4B14585CEC8E33298C480C1D50601D3E
	7C58FA00D8C2B46CD9723CC79FE8E5C3D6C429C2F4FC90EF68715AC3816D5FBC
	CC375911E8E5F15E29313191E283536C27FE7646B5A09064C0E3D4CD8BAA84F7
	58BAC00A0E0E4EC7BB6A12587A366526AE4A4E818546FD2C1A2DA9022B2A2A2A
	9583B6F5ECAA48A8ECD9904B0D47AD59B3A622C527B7F3D1B3A922B56AD58AAB
	8A4B0913C241EA831F5AB76EDD746D199120B4B99486D4B02705167B64F4ECC9
	4A9C4D8DF2AD4C60D179D5B3AB2AB177D7CFCF4FAAC0727373DBC03A50CF9E8A
	141313C376F13ADA26A9020B627A299EF7062313EAC7257ADAC85AD23D682D55
	A952E5C8B265CBF0AB3130448886447988302D2DCD1BA2E4CA5FFEF21761B9E4
	708C0CB705D9BA75ABDD966D4025308B15594956E71D33660CBDD713B9B9B986
	2C0489825E2642841B376E7482289DC915A555EC706086E15BEE09890AEB5C93
	264DA48FC39A3E7DBA7FC58A15EFC8DC02CB1A5C56A466CD9AF4702928A40161
	D59E0B731AB94F2757B847FD7877F4E8D13E221B25060E653988B5CF5997D803
	F3B658B0DF5E64490A0F4284C5475188B017EB292396FE207474648FB1B427B8
	249B93EE416BC9C7C76707D745320A2EE806B5AD7C903BE3C3EC799031B8974B
	1BF0E58D8F8F7F4E9CDE70F08CAAC1FB3CC75DCE8B030724B261EAD4A9530F71
	2AE59415816586228B5EE7B66DDB8435795888ABB32AC49599FAF5EB7F61C464
	162E8E0B8155F0E1871F4ADDAC372020201BEFB0B0620C7C367E7E7E5C583145
	64A354C0DB6F89B278E7934F3E11168CC1625BAC95222BD27820B08A8F0A8175
	E2C409673C8B5346AC6779FCF87153F83C2929A98D30FF8707976573D23D682D
	F9FAFACEE28035A3E03635F0E4942ED33060C080683458B777ECD821AC969E29
	53A6B08BFDFC9C3973AA0A3386D3BE7DFB41147A3FFCF083C855D170D624C7D7
	E1196FDFBB77AF93388D72CA9AC0624F568B162D32387642664F96A5B86A0C84
	3925848484A4711D3815FBDE59C2EB8128592BCC4A038EE0BE66CD9A992A77A3
	E00AF50CBB409CBE2DB2516A82838373B81A36458F51705B2C171797FCE1C387
	3F22B2218D0702ABF8A81058243434740ACE2BA553A128B88491B7B7F7FEBCBC
	BC07CB34DC2B75EEDCB91EC77E18D1F5CED9521C9B13131333425C9774366FDE
	EC041BBB65AF95C3850D99F7B0B03025DBCBD8426666A6137B22B8A7952DE4E6
	E6B2F7EA161ABD50710A43286B028B98451605EEF6EDDB85D592C34A90E3AE44
	5850F99639A3468DF2E3161A2AF7BE2B2828308DF341F94E1266A5919C9CEC05
	E1F631C38F7FFBDBDF84453550FC70BA3B7B7E214ADF5DB06081ABC846A99938
	716203889D9F3943D908CCDB62A1DE9A2EB220950702ABF8A8125863C78EF546
	7D92AF721990FCFC7CD36489D8D8D821C26C9900976673D23D682DC1BB791837
	ECECC2850BF1A75AB8C22CC4DC8DF4F474655BE5C4C7C7F7A760FCFEFBEF8555
	7970FD1D54BAD7870C19227D85675B49484860EF9CF6D9679F895CE9C315BBD9
	63018FF94DF155C3288B02CB4C78787806C385A5E9C9B2E8B95232E6CA1A103F
	FB8B1B622E0E5BB66C3195EFC58B17D71426A582CABD4264642437E6A5D350AA
	8DAAAD71E6CC19D31474CEB8EDDAB5EB00615A2A103BE3391B926BEDA966D2A4
	495C79FBD4A2458BAA0BF352290B02CBDAE6FF2A60D967AFA8EC59846670DE55
	4F3FFDB4B0261F0EF181937305F5C883AD726C49242222620A5535D5A92A189A
	E03880FAF5EB2BDBEC393333B32A0AFC49562A2A305F03BC8F0F8549C3C13362
	98E1EFDC38BBA8AEE0ACAC2C36123F4D9E3CB9AEF8AA619465810527E1A1D284
	0B2DC495F2B0606120E6268786862A0B13B2A1F2F6F65E27CC29E3C9279F8C80
	53781CE540DBBF7FBFB05E7A387ECCC3C3837BF77D866B0910E6A483F7A6AA9B
	9BDB71865A544227D3C5C585DB9AF417A6A5C3CD9E5597759697060D1A281158
	28CBA6CD9E8D58BC96659F3B99E09E5D8B8B8B53E258F5EDDBB703C7479D3E7D
	5A58954B7474B4866A6B81305766C0A5D99C740F5A4B64EEDCB9B5204C8A3D80
	BA3870A6223CFF82E1C387079A8C2A203C3C7C1A049CD27DCA38B3088DE31DBC
	C84F08B3863376ECD84668E0F3ADED007FE1C2054E2460611825BE6228655960
	1173B8903D59C50917B28235322C58983163C6346798907B6DCA86E17F2ECF80
	CA577A78508FF9F3E7D7E22C26368E1CD85B9A314D9CF9387AF468D38C4108D0
	0C08AD4AC28C3238EB8B3DEDDF7CF38DC8857CB81E1984C91E95636550DF0E62
	28951B7DDB3A36D456B868267BAFD863DFB06143651B88C7C6C6BEA25A64F1FD
	A4B8423B7B6DE8D0A1B1C2B474F8ACE1207CA9A29341B47DACC394B5E1F60297
	6773D23D682D99E9D0A1435FBE64F70A3D958413274E98368844833F4998930E
	077056AB562D7FF9F2E5C2AA3A585020220EC396DD06F9356DDA349D0D9ADEAA
	D643860C61FEBE41436A977D14CBBAC022ECC92A4EB8B090B8322C2C68C9D9B3
	67CBE19D39AA623B0DCE8C63E86EC99225CA17B23583EB7142E3F81CEAADABDC
	0AAB24AB5873962DC432D7873A1F07C4A99583B259CEDFDFFF134E425101B7C5
	82F0B93B70E040A92BB717863DEA09090951105A9F737C229DF4922C256309C7
	F2C1E937B5193E3E3E5FF5ECD9F389CCCC4C61513E070E1C30892CDEAFF7DF7F
	5FE4421EE69E2B8AAB61C386B515669511131333926D031D0799F01A20D8B7EE
	DEBD5B582A3BE0F26C4EBA07AD254BD060BCCD2EF223478EE05F724025C87140
	1C0FF4F177DF7DA764836116723F3FBFBFB76EDDDA90D939F0124C6BFDC0DE8B
	220B86939393E38246E1FB575E7945E4EA370E1D3A641A9C1B0FC4470DE77E10
	58666C0917DA332C581894C3E95151512267F278E9A597387877A7306328FDFB
	F70F42C57F08EF9D691C982D304CBA74E952D3AADA8D1A355A3772E44877713A
	C3E8DDBB7708DE895BB237E2666F224523B7C512A6944301047D3A90E37939DC
	64E5CA95C5AE8BF94C18A6E54C3888914BA85F87728CB030A19C76EDDA49EFC9
	2A24AE94F55C59326DDAB4AAAEAEAED7172F5E2C6D38C0B163C74C4B1575EBD6
	ED1961A64C814BB439E91EB4962C59BD7A7505148E951C802963EF323E148A2B
	2F2FAFDD59595952D7C5B1A46FDFBEED282A8CDC6F6DF6ECD90CC3FD848AA5B6
	C886E174EEDCF9595608E6A9EB2C4CEDDBB76743B78EFBE8898F19CEFD24B018
	2E0C0B0BB31A2EB4ECB9B2B7B822898989A15CD5FDD4A9532287A587EF1D67AA
	4546460E13660C07F54BC5E6CD9BCF63D88D4E07277958E3EAD5AB1A67E2A2C1
	B8D9B265CB517028EDB68030C4C4A2264D9A1499DFE2B264C912F6265E193F7E
	7C7D61C6305253535D9A356B3603F7B60082453B70E080C855D170AF582E5EE9
	E2E27227282868DED8B1636B89531A8ACC70A15161413D42424266383B3BDFE2
	5A905C6CBB241342987F3A2CDC3F93A141B42BFB972F5F5E51982853E0726D4E
	BA07ADA5C2E4E4E454C0C3799B2F194544490A3E1F0C3790662F4F404040EEFC
	F9F39589AB4B972E55F4F1F1393070E04061DD18D8FD1A1818C87DB2E689AC18
	4E5E5E9E135EFACFCC1BC84220731C09C7B9D9B521BF9F0416A1C832870B2D45
	9685B83A6F8F31577AECDEBDDB098EC1B79C04210B3A36EC89993C79B261E141
	3DD8931D1717D709F5CE790EC6E5D084C230AFFEFEFE0C091EE9D7AF5F84F8AA
	DD40DDE885F7E6127E8A1C960ECE4C641402C2D1906DB1AC919C9CEC8BBA6915
	1B668EA3B216BE657E39FE8DE1393C97AD494949762D27E67021DBBFD2840B59
	F6710FEC22AECCE0BE3F029F6E16CAFB25865BB9B7AE2DD1A9CB972F9BC635B2
	7304CFE546A3468DDE4F484888DDB66D5B9959F7AA30B86C9B93EE416BC91A6D
	DAB41980827F9153FD39989A3BE4DF0B8AB1B56BD79A661AE005BD86429E8687
	A5242C6806F94C66373FA7571BCDBA75EBF80216E045B65BA5D0A74F9F30E4E1
	0EF3C255A7434343ED26F8CCDC6F02CB0C44D62CF3982CCB9E2B4711576650A6
	33B9F9B32C381BCECBCBCB2EE1413D28F41A366CB8990E1E17D9640F1B9F07C7
	9EB1E144A3B314759A32A7AFB8A00E7B9993523839A5B4704D274F4FCFEF210E
	A46EB45D527AF5EAF504C751B181E7B82A8EAF220C63B26785EBA6D5AD5BF768
	C78E1DBB8BAF38040C1752F4954464598A2BA3C28245B17CF97267D44DCFE239
	ECE12417463956AD5AF59F6741584638889D3D6E0C05E27D3C8D7A6252464686
	D47D511D15DC029B93EE416BA928D2D2D2EA060505CD8480B9CC0A80FB6871BD
	ACCD9B376BFBF6ED334D916663C282C21E240EACAB5AB5EAB5C0C0C025685CA4
	AF1A5C18D8A88E7C9D6743C6BC189DF84272756954E61B76EEDC69B790DCA38F
	3E6AEA7144E37E66D1A245760B599AA1C06ADBB6ADEE3D5395B86C054CDB5560
	8970E12C0A7E6EEA4B7185C6BC89F8B7C3909292D296152D7BDBF4EE65711385
	3DBCDDE1E2F40EC1D1A347CBB76AD56A3C3D70D64DDCD01E82EB97D8D8D8BE79
	7979E2538EC1FAF5EB9D2134FECD7CEADD5F5B93585898CEC6D3E2D40EC1071F
	7C503E2A2A2A05E5E21CC7576567679BC688A1BEBA8267F44A5656965D26E3DC
	0B734F1643AE7AF7DB5A627B44713564C89076E2540E03DAF030B4CF6F4344FD
	C219F7DCA1848BDEB25304F5D55DD4DD5B20C07AE11929ED187134F4B491B5A4
	7BD05AB28565CB96B9C0CB4AC40379CBC3C3E34B889A1B2CC85C6F0315C35DFC
	7D04EA78391AB9410B162C50B6886861626262129C9C9C7811764D78316F6ED8
	B0C113BFDB85A953A7D6838778195E97DD06DD5BE2EBEB9B8E1FBAF74A65C27B
	68F7D58529B242434367A17C384C58B030972F5FE654EE53F855F73E163741AC
	15CC9933C71FBF3B1C3D7AF488429D75D2CBCB6B4F7272B2DD1608BE175DBA74
	E94AD18B5F4B95FCFDFD77ECDAB5CB6ECE5E51A4A7A7D78243FA06444B7E4040
	C05BA9A9A95EE25F0E09C3857014C7972F5F5EF75E5B4BA88BAF0F1D3AD4E1C4
	95253366CCA805713B86BD872E2E2E97F03CE68D1831C2E19C41A3D0D346FA49
	7BE8FF00E4DCA96F302143D20000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="4" length_in_bytes="8237" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000002580000
	001E0806000000F0F860840000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313147F3423700001F9F49444154785E
	ED9D09581555FFC7734305657179D934C41004E2BA808ACA453151B444855C41
	45134C4C5C32AB5745CD5C83DC52DCF5B57CC94C2853D137374CB3CC32CBA5CD
	DDFE986B2EB9CBFC7FDFE14C5D71EE9D853BF78EE8E779E611EF32E7DC99B37C
	CE6FCE9C798AE338599B1C3233332BC4C6C676AC53A74EA6BBBBFB172E2E2E27
	3D3C3CB89A356B72AEAEAE05F4F7D7BEBEBE0B5BB66CD96DC9922555D8D774CF
	F1E3C7CBD6AD5B7787C16058C45EB20BE1E1E1C3DCDCDCB81A356AA8DEE83C70
	D5AB57177D4FEE46E7F30F96A512F1F4D34FC7ABFD3DF81D62AF4B6DD5AA55E3
	EAD5AB378765C1AEF4EEDD3BCDC9C9E96283060D22D94B8F1C59595955020202
	16D3713D1F1515F5027B5957DCBC79B32C9DF35FA5CA3DDE97591E6F77EEDCD9
	8BEDDEA64C9932859A518F0B2279FA7BC36F4039177B4FD8681F27172F5EECC6
	76AB2BF2F2F2CA366FDEBCD7BFFEF5AFB3D4EE7EFED24B2F3DCBDED22D5487EB
	517F775AEC589B6BABE8F57BB56AD54A64BBD0257BF6EC29F3FCF3CF47F8FBFB
	7F4CF9BD417D7B765C5C5CABECECEC32EC238F144D9A34090D0E0E3E27E6385A
	6CA22F8A6D9618356A942355849154B1CF383A3A72313131DC5B6FBDC5AD5EBD
	9AA34E84A38697FBF8E38FB919336670F1F1F17C81737676BE4C276B5A525252
	4DB61BDD121919F962D9B265390707873B0909098DD9CB3627393939B072E5CA
	37DF78E30DEE8B2FBE50B5D179E2CF8DD87B525B7E7E3E4752C45187FA21CB52
	49E9171818289A96D456AE5C396EC58A15A2EF59DAA863C46FF880A56F37FAF4
	E99346E7B290FEE42A55AA742D3434D458F4CEA343CF9E3D1B7879791DA1DF81
	BAC1E15F6ABC66515DAFC43EA20B860D1BD6BC42850ADCBA75EB44CB84B0A5A6
	A672D4B18BBE276C3B77EEE4FCFCFC382AB7C3D8EE6D0A7574F3434242F87C88
	E50FDB0B2FBCC0D1B9117D0F1BEA31DA81468D1ABDC376AB1B121313C3493A76
	57A9528517456F6F6F8EFA943BD4E6CC7CE79D77AAB18FE98A860D1BFA51D93F
	8D635EFCBCE058E377CC9B37EF81D7B1CD9E3D9BAB58B1E23DEA0713D8AE74C3
	CA952B5D1A376EFC32D5EF1F298F5CBB76ED2001FCBFF83FC9EF7E9295C10B17
	2EAC5AF48D470623E4B6B8DF68B589BE28B699A36DDBB6711869F8F8F87073E6
	CCE12E5DBA441FFF87B163C7F29265CA8D1B37B855AB5671068301B2758D046C
	38A2446C97BA222727A78ABBBBFB2974E8E5CB97E7A881FB92BD6517E89865A0
	81A751393B9ACA78F6D967B98F3EFA88FD4F1954E9386AF8AE4D9C38F119969D
	92D2AF69D3A66CEFCAC0B9F8E1871FD8FFE4F3F2CB2FDB5DB020574E4E4EDCC8
	9123F9C66AE8D0A1BC645183F64844B2A64E9D5A86EAEC08EAF86EA25379FFFD
	F7B9679E7986DBB66D1B57BB766D748A3FF4E8D1A33EFBB8DD21999828A79C51
	07CED1689DFDCF3C6FBEF926E7E9E9B98BEDDE660C1C3830943AF27B9F7FFE39
	CB89382FBDF412F7EAABAFB2FF8983012FCE1FD5073FB67BBB4272EB45D2FA3E
	D583FBBD7AF5E24E9E3CC9B56CD9925BB46811B77EFD7A082DFA8A0B46A3F195
	2D5BB638B0AFD91D44AE2057E8E3EEDCB9C38EEE3FDCBB770F32C20B9518FFF9
	CF7F04C9B27B248BFA94A75252521A525F3EDBD9D9F92AC915DF7FE35C9C3B77
	8E17ACF3E7CFF3FFC7EB78BF6AD5AA7F0605052D484848D07D9491F168085676
	76765932D89954B80A71B0FFFAEB2FFAD8C3880996C0DDBB77B9F9F3E7239AC5
	D1A86C1DFDEDC876AF1BE8374EA01115D7BE7D7BAE6FDFBE6894B84E9D3AF564
	6FDB1C9258372A20E7A64D9BC68EA232D40AD6D5AB57391C071AF5A6B3AC5883
	C74EB0985C156244FBEBAFBFF28285638BA824932C5D47B2D2D3D36BD4AF5F7F
	3D35ACDC92254BB8C2C242EEB3CF3EE3050BA0214694907E23064E29972F5F66
	DFB40F478E1C29431DDC4139F545AE607DF3CD37386F77C78C19539B25A33905
	0505657D7D7D7774E9D285E5C23C72040BE7AD4D9B361CCE254BC22E904055A4
	36E54D2A2F7F868585F111200108D6E2C58BF9BF6FDDBAC5656666F2D120EAD8
	7F88898969C376613784C81584107D991852820510896792659748161DF38A54
	167AD3C06807B5415C646424F7E1871F3E308837152C01BC8FCFE1F368C7A85D
	DD191E1EDE2D2F2FAF42D19E7589FE050B724596BB10D7F9316AB58425C11238
	74E8101FB2F6F0F0D84A8D9C6E246BF8F0E14F53C5BF8AC8CD8B2FBEC85F5AC3
	E8952ACC71121DBBE5934671035D5C5CB8DF7FFF9D1D41F9A815AC7FFFFBDF98
	A372ECD34F3FB5E6DCB9C74AB048AE8609720504C1BA76ED1ADFE1A16CE93992
	4575209A3AB853943F8EC485FF0DC054B0007ECBDCB9732159B89C969D919151
	9DEDC2E624272707E3F2E02FBFFCC272671EB98285DF479D21474290C692D11C
	EA00E331B8439991428E6081EFBFFF1EE50D6D5B07968CCDC8CDCD2D4392F422
	B5F9273C3D3DB9A54B97F232628AA96009FCF1C71F5C4A4A0AEA4D2195B94FE8
	FCD663BBB42952912B01398205EC15C9A2BADCC8D5D5F5FF306D0797C87FFCF1
	4796A30711132C53D016E3FBD80FF513676363639B16A5A03BF42F58885C41AE
	BEFBEE3B7ACB3272040B9C397306938F7109EEB3EDDBB7EBE272617070F04764
	E4DCFDFBF7FF162C441B101AA551D758F6319BB366CD9A72B56BD7FE2E292989
	1D3DF9A811ACA3478FF29D65870E1D7AB12C588BC746B08ACB1530152CA057C9
	DAB76F5F459289C994D7BBC3860D7BE8F27471C11240074E7508137A8F77EEDC
	B905DB9D4D090909994075953FB652C8152C80CBBBD4197EC192D19475EBD639
	92889C4294530E72050BA03E90E01C2C2828B059D4A16FDFBE0DA9BCE493A070
	A3478FE6FEFCF34F969B0711132C01F43DAD5BB746BB748B6467C6AA55AB6C36
	3FCB54AECC45AE04E40A16B08764517FBB165767CC9D030129C112C07EDAB66D
	8BBE7C75510ABA43DF82D5A953A7385C16DCB2650BBD2C8D5CC1021865C2805B
	B56A65CDCB50AAA03C47524757B867CF1E3E6F82600154041717174C367F9A7D
	DCE6F4E8D1A33555C6FB5F7FFD359F27B9A8112CDC98E0E7E7B79B4637D616DF
	C742B0C4E40A14172C001140B4502F92D5AF5F3F1F6AF0BF4227019112C39C60
	81EBD7AFF311074747C7BBB814B476EDDA726CD73681062207274D9AC4726319
	2582B57BF76ECC472C5CB06081374B4A339A356B361E93BDAF5CB9C252B78C12
	C1424408774F523D1CC292D38CB4B4B4EA4141410BA9CCDFC16564A9A8A225C1
	0218F8A22DF3F5F5C55D93FF67341A076CDAB449D3F225377225A044B0802D25
	EBB5D75EF3A4327C476A4E1F902B5880CE01EAFBAD091326B817A5A42BF42B58
	E9E9E918499D953B92024A040BE0721C9D9CBF860C1962AD89D48AA1D15CB95A
	B56A7D83395702A682854A83C85660606036FB8A5D080E0EFE188D101A1AB928
	15ACAD5BB7E2EEB0FB24748D58B2D6A4D40B962057986B581C31C1027A8964B5
	69D3A6879B9BDB95E8E8688B97A32D099600CA1CA2DED4716C4B4D4DD55C4AC0
	F8F1E3831D1C1C0A0F1E3CC8726119258285C80526F4D3F94966C9690295031F
	2A3F57304F472E4A040BCC9A350B739B2E6666666AD62186848404A02CA1FDD9
	BC79334BD93252822580F9BF9068CC0BAC5BB7EE5696A4D55112B912502A58C0
	44B2FAB0A43581CEC5D8FAF5EBF37994428960E1D8F8FBFBE312BADD032522E8
	57B0A8437F1523A9E21D8225940A166481462288982CE713B5032D5AB448C2C4
	7B5CB61430152C80C81635DEF7BA75EB16C1BE6673468F1EED4B327AED830F3E
	60B992468960A1A2346CD81022B99825696D4AB56059922B604EB0803D2359CB
	962DAB4AE77D0522D553A74E956C80E508163871E2045FB75D5C5CCE2112CE92
	D30C83C1F066505090ACCB83408960011A04E2F2DA46969C26503BB81275444E
	2728A054B01089C15D7A74BCB258B25A1009019213F511902B58029870EDEAEA
	5AC0D2B32A515151FC8476B9912B0135820504C9AA57AF9E2613DF8F1F3FEEE0
	EEEE7E66E6CC992C45CB28112C801B1270597BFDFAF5E58B52D40DFA142C3A50
	157042DE7DF75DFAAF7C940A16C8CBCB43F8FD0E35783619E99AB260C102DCA5
	7776CA94292C374514172C401D28EEACDBBB70E142BB2DBA469DEF448CA4E54A
	AF12C1CACACAC21D9E97A8B268751E4AAD6049C915B02458A09864B562BBD614
	AAAB8DA943380C61FAEAABAF584E2C2357B0003AA7F4F47444450B6984BB70E2
	C4899AAD9945EDD51EB43F72512A58B8C187DAA9DB24A19A4CE24F4C4C8CA0E3
	C45F8E548252C1026873A99CDD494A4A0A61C95B9B484CFF508252C1FAE4934F
	3413AC366DDAA451BB213B7225A056B0C0E0C1831109D22422D7AE5DBB3808EF
	C58B17596A96512A58D82FB57F580333B62845DDA04FC1EADAB56B343A03B907
	58408D60218A8575B56814ADF9BC80E250479681CE026B7599222658A74F9FE6
	979868DFBEFD40F6759B430D901355E0D3E3C68D63B9B28C5CC1420541C3D0A4
	49935759525A502A058BE46AB8945C0129C102B68A641D3C7810AB67A79130DC
	4A4848E02E5FBECC72208D12C112D8BE7D3B7F890D73A44808ACDEA9A7A5A5F9
	D0B12DDCBF7F3F4B511AA5820559441D89888818C092B51A870E1D2A47E5742F
	CE8552D40816CA59A74E9D503736D33163B9B02A8FB460454747A7050404B094
	E45312C17AFDF5D7B18C86268245F5751BCA895C940A16E8DFBF3FA6047C5E50
	A0C929518B3E05CB603064928DD29FCA50235800E1776A7C3F6307C526D088C1
	9F468C37D7AE5DCB72F10F628205264F9E8C49A205191919CE6C373687CE4B0F
	8C168E1D3BC672651EB98285BBC5A86138B265CB162D57E52E7582C52257FCFA
	6E52C8112C602A598D1A35D2249245E76118ED9F5F9347296A040B5CB870815F
	75DCCDCDED1AC98D551F9D151616360AF34094CC4F542A5820393919F37EF258
	B256C368342621C280419C52D40816F8F9E79FF9D5F8E99CBCC8B2614D9E0896
	42B412AC01030604607ACBBE7DFB584AD2A811ACBD7BF7F2E5292525C52E4B69
	98419F82E5EDEDBD75CC9831F4A732D40A16E61555AB56ED148DE46C72F90DA3
	36B2EDDCE79E7B4E74CE8639C142A40B6B7891B84C65BBB2391B376E2C4379DF
	D5AD5B37962BF3C8112CAC4B868A4123DA4E2C09AD28358285559011B9727474
	948C5C09C8152CA075248B1ADDF66A22D440AD60015C8AA781D4113A7E56ADE7
	BEBEBE5F63090025A8112C5C5A737676BE95939363B5CB842B57AE74AE59B3E6
	59B9773F1647AD60017CCFDDDDFDB71D3B765466D9B1164F044B215A09565050
	D0AC66CD9A89F673E6502358D83FD231180CBA78F62B439F8245A3A99F962F5F
	4E7F2A43AD60C17E3182A34ECB26EBB3C4C7C77780541C387080E5E041CC0916
	C0632728AF775F79E5157FB63B9B43C7A92975907771E9C51272040BCF92A4D1
	FFFF0A0A0AB496DB522358ECB2203F6F4D2E4A040BA0C1C220478B48D67FFFFB
	DFF2D4B19E5753C74B2258A1A1A1582B6B22CB865520C1AD437559F112266A04
	0B2B8C639903A3D168B5C9C824D0EF60D066EEE918529444B07069D8C3C303EB
	FCBDCEB2632D9E089642B410AC050B1654A6F27A0593E895A046B00022E22E2E
	2EE7D7AC59A3976716EA53B0BCBCBC6EE061A94A512B58E87CCA9429835B7A35
	7F1C05898403FDBE439854680E4B8285CB10ECB11336BDA4591CEAA856605145
	4B1331A5040B9DA5A3A3E39DC4C4C440B65B2D291582151111D103912B257205
	940A16308D6485848484B32C58053F3FBFC59887A314B58285056C2B54A85098
	9C9C6CD53958540F06D5A95387EFDC94A046B0009673A1F6C32A0B2BC6C5C541
	0E6FC8B98C6F8E92081680D4D080F1CAA44993ACD9F63E112C85682158515151
	836AD6ACA958DED50A16D2C100A455AB56294539B03B4F040BFCF6DB6FFC09DD
	B06183E682459DFC50140214227358122C8055ABA9B32CECD2A54B3BB65B9B33
	63C60C2F2727A74B344A61B97A184B828515BAD188D06766B25D6A4DA9102CFA
	0D7D48780AF1D06325A8112C80A513AA54A972CF6834B66559B00A313131ED10
	C5955AD5B9386A052B2323039DCF6196BCD5A0B6EAF3E1C387B354E4A356B03E
	FDF45308C9B579F3E639B12CA826363616CB01DCC23ED55252C11216521E3A74
	E813C1629416C1A2B66A90BBBBFB43377149A156B0D0A740E8C2C2C29E0896A5
	0D9708B108A852D40A161EA88A4B2E242C9A5E22C4E27A58646FF6ECD92C6571
	A4040BA0F3A6C6FDC7F9F3E7DB74B56A53C2C3C347A3429BBB0BCC9260A1C3A3
	86F58FE5CB97D760BBD39A527389F0B9E79EC3FC2B4E8964A911ACE9D3A7F372
	959090D097256D35366DDAE48035AA56AD5AC55293875AC16AD1A205EE327A8B
	256F15264F9EEC4E82725B4D87A656B0304AA7E38651BA5526871B0C86D998A0
	5FFC914472298960090F750F090919C7B2632D9E089642B410ACDCDC5C673A46
	5794D671B582C5E6525FA141FF934B8496360F0F8FAD7297023045AD60656767
	C37C0B8E1E3DAAE93C206ACC160407074B2E1E2747B05008B15A75EBD6AD47B0
	DDDB1C1A7D56F4F4F4FCD5DC08DE9C609D3D7B96EF24DAB66DFB0ADB952D2835
	82859B242059D4B9CB8E6429152C21729548B064AD0E75AE4BE2E2E2588AF250
	2358A74E9DC2E5412E2D2DAD394BDA2A346BD62C058B212BBD3C08D40A16E8D9
	B3279EBFB68665A344503B8B49EE9767CC98C1F6AE8C9208162E3F93109CC25C
	1D961D6BF144B014A2D524F7BA75EBCEC2B1B5C524770CA2E8B83D99E42EB5D1
	882A930A19FDA90CB582450D2F9E31B5991D144D484E4E3650877817CF4E9242
	8E6001F6D8894BD3A74FB75514E821E2E3E3BBE252CFE1C38759AEFEC19C600D
	1C3810D1B7EF76EDDA65B387BE12A546B00448B286C98D642911AC69D3A60991
	2B4D1F9F4165279ED2E123197251235873E7CE45793BF1F3CF3F5B35DAEBE7E7
	B70093B4952ECE09D40A169EF8D0BC7973447E8EB16C94188822063C0505052C
	15F9A8152C2CF382AB06EDDAB5EBCDB2614D9E089642B412ACA1438736C0922C
	98D622173582850772239DD4D4D4E0A29475813E058BDADDE7D1695FBA7489FE
	2B1F358205F345834D15CCDA77B2FCCDFEFDFBCB5047FBBFD8D85859262F57B0
	6EDFBE8DBBA2F0E889B92C29BB40A394CD1D3B767CE8B78909162EC7A222C4C5
	C5B5665FB715A54EB080DC48965CC132895C692A5760E7CE9D4ED5AA55BBB666
	CD1A96BA346A04AB55AB56A827569FEBB768D12247AA7BF320B958E640C9CADB
	6A040B73A530C784CAD42E1AB0F9B06C94989C9C9C72B56BD7FE7EC080012C25
	F9A8152C6AE3711E77E7E6E6B25C58952782A510AD040B4BCA50D9DA3668D020
	9692346A040B6BC4F9FAFAE61F3972A428617DA04FC17AEFBDF72AB8B9B99DC1
	C853096A040B8FA0A00EEA0E35129A3D2A078BE94118A59EE82E2057B000D6C6
	A18EF33675885A3D7642929494941092A6DB1B366C60B92AA2B86041C0F07C38
	AAC8B9765871B7540A166091AC424BF316E50896AD2257A65027BBBA57AF5E2C
	07D228152C4465F0BBA95D68C992B43A515151712E2E2E177177AFDCC53A9508
	1626090F1D3A1477DCDE0F0D0D9DF4E5975F3AB0A4AD46F7EEDDDB60E0830190
	12D408161EEA4EE704770F87B2E4ADCD232D58549FD37067AA92856B4149040B
	E54BC347E5F4C45348E43EB141A96061BF888453FDD362D1DA92A04FC1E27366
	344E25235574078252C142878F46D1DBDB7B059FA806506352D9C3C3E3D86BAF
	BDC65295468960E137E07677AA1CDB599276C16030CC2571E2D7EA11282E5878
	402A55841B34DAF0655FB325A556B000240B912C739225255842E4CA96720522
	2323E3D1F8CAADE74A050B77B95223778A46B69ACEAF1C3162449D5AB56AED40
	84099DAF1472050B0BF13668D0805F08392E2EAE0D4B4E13A8FEE644444428EA
	D8950A162400BF27282868294B560B2251A690965C940A16A2AE5A09160D381A
	E0890388FA28F90D6A052B272707F28E48EF489605AB820141F5EAD565074C94
	0A166E1AA3DFFD7B7E7EBE964F0251837E052B3333D3994ECAD9891327D24BF2
	502A58E8FCA953B99B949414C027AA016161616F7A7A7A2A7ADE9A12C1023FFD
	F493F0D8893896ACCD9933674E8DAA55AB9EC593CD054C05EBFAF5EBB88B0BCF
	7C7C9B7DC5D6946AC1029622599604CB5E7205A89C3B52B9B92A77A900A58285
	B99CB56BD7CE64C969CA8103072A3469D264221DE7DB78FC96A5F57FA4040B03
	A7458B16F10B20070606AE9B3469524D968C660C1E3CB82E959FBF70D38F5C94
	0A5656561664F1DAF0E1C3DD59B256C7CBCB2BC0C9C9E90AEAFBAE5DBB58CA96
	912B5898963173E64CFE062312EA2F589256A77FFFFE918264C9155E35828547
	B5B1B970565D80B738D4174CC2741639BF458960E13793AC634B2F4A4957E857
	B0405454544F8CCAE54E22552258274E9CC0C816A329CD4E0C3522582BEAF2D2
	A54B59AAF2502A5860D4A85178ECC4AFEFBEFB6E4596BCCD311A8DA9D428F077
	090253C19A3061023F0AA7D1BD0BFBB8AD29F58205CC499639C1825C51276E17
	B912F0F1F1C9E9D7AF1FCB91659408161A68FC66EAACA2595236A163C78E46EA
	E8CE180C06EEE0C1832C370F6249B030F7B47BF7EE782CCEEDE6CD9BA71E3D7A
	B42CDBB5E68486864EC6C3EF3120928312C1121EEA1E1111A1D97C57812953A6
	F8F8FBFBAFAC54A9D27D2ADBFC9DA49690122C08EFC68D1BF9CEDCD5D5F502FD
	86B4C993276BBA448EA964C9896429152C217205B93A7EFC384B551BA86FF6C1
	541CA9A77F002582B565CB16D4F15BD48E69BE86A50AF42D58800AF47C2C5676
	E4C8117ACB3272050B27109D3F8D6C378F1F3F5EB3C68B8CFD83B0B0305995C3
	14358285051B719CA8A118CB92B73934F22D4FA3BA1F535252F83C098275F2E4
	49FE1A794C4C4C12FBA83D782C040B885D2E14132C9309ED9A2DC520076AE0FB
	61F15D396B312911AC65CB96E1512CE77373736D79B72A4F5A5A9A2BE61AA2DC
	E332253A6853CC0916222E88F47A79791D8E8B8B7B96EDCE6664646438D2313B
	4BED22CB91659408161EEAEEE9E9F94B5E5E9ECDCE47E7CE9D9BD2B1DC8D4820
	DA5473E26849B0D0F7E05CD160F95EBD7AF566513F538DED5E73060C186024C9
	BA8A36552AFAA344B04C22571358529A43E2BE160F5C979A0E2057B0B01FDC5C
	45EDC1DAA2147487FE05EBC08103156954B519B7434B3DEF4B8E6091A9F31D3F
	5594C33366CC7065C9581DEAB3C2317ADAB973274B593E6A040BA081A0D1D575
	6A1CBD58366C4E8F1E3DDAD1EF2EFCF6DB6FFF162C4C6226F1DABD7FFF7EBB2D
	8A4A3C3682058A47B28A0B96C96541BBCA1558BD7AB51B7580B7E52C61A244B0
	D098FBFBFB2F66C9D89C8B172F960D0F0F1F44E7E13AEA34223802C5050B7720
	E24E4488714848C822AA37CE6C3736272222A217C410517E29E40A169671C124
	FAD8D8D8CE2C199B919F9F5F2E3A3A3A89DAC65390572A6F0F09AF9860615AC7
	C89123F97342656E4B9F3E7DEC722351FFFEFD79C9928A64C9152C93C8D504AD
	2357A674E8D0C148E5EA22F28887A3E3F15562480916BE87EF633FB4BF0B54CF
	35BB81A584E85FB00055CECA341A5C840E030D13AE838B6149B060FF58E91523
	655F5FDF4DD3A64DD3EC52158D78CA422894DC1D658A5AC142238D8859404080
	6693F6E5E0E7E7B716B7C6239C8EBB53D040917835656FDB8BC74AB00049569A
	10C912040B6B4E4D99324517912B53A8E3DB805BADA5902B58E81CE9B7E30610
	BB3D4E4A803AC8101A20FE804B6FC280CB54B070F92A2A2A0A976A2FD088BC3B
	FB9ADDC8CBCB2B4BE5F64BAAB37CFE2C2147B02033D4B96250FB3F96845DA0F6
	DF85067D939C9C9C6EA07DC22050C054B0D08E2E5CB890BF22E0EDED7D8C4424
	96EDC26ED07186645DB314C9922358885C41AEDAB76F6FB3C89529D9D9D955E8
	58A7787A7AEE437B843AB07EFDFA07963811132CBC8FCFE1F3F81E7DFF1BA3D1
	3868C58A158E457BD6258F866009D0C8AA2F15B24B8181811C3A8DE2A14631C1
	C28941A38C0A440DEEF566CD9A8D9D3973A6A6731AA8F0F6C3081097C6D4A056
	B0001A70070787BBDDBB77B79BD0D0A8AF1E55E21B583D9BF28249BA2BD95BF6
	E4B1132C00C942839A9E9ECE374C63C68CD14DE4CA143A3749B8034FEA72BA5C
	C1C2E339A8AD38A7C592066A78FBEDB72B1B0C862C4477311F114B62A0B3C01D
	87F8DD3428F92A3535B50EFBB8DDE9DBB76F38B597F7F3F3F3D91115478E60E1
	9C51D9BB3570E0C020B67BBB327AF4687F92BD1C9C0B483DE68C0A82B563C70E
	AE71E3C678D2C4D5F0F0F0376830A28BF2035824CBECC47729C1B257E44A0C92
	F8A7A8FC37A572FF3EB547B750A751272057A68285BFF13ADE2731BE49EDE9F2
	6EDDBA35BF79F3A6CDE6259680474BB0C0B871E36A0404044CC1BA33AEAEAE1C
	465973E6CCE1D7834A4A4A8299F313DF3002A10289B90C383137A8422D193264
	88E6CB03646565E1D113BF6362E5BE7DFB546DD429F29DB3D87B723634165420
	BF993BD77EEB8F52233595FEE19F943F7DFA74AB2D8A5802FAE192A5D8F192DA
	CA952BC72F3121F69EA50D8B29DA5BB000248B44B790FEE4E5AA4F9F3E0945EF
	E807AAD7D5A9F1BFB57CF972D163296C787A41AD5AB544DF33DD626262381F1F
	9F256CF7BA813A95786AB72E624E100661243177A9BE4E9E3A75AAEE3A8CE0E0
	E095900DB1E32B6C5DBA74E112131345DFC38675B5B068664848C86CB65BDDD0
	A953A7D6EEEEEEDFA21F414758B76E5D9C8FFBD4E92FA68188667739960412DA
	0848169E8651FC58EFDDBB97BFBB71C992250FBD871BAD58E46A3CDB956E20E1
	ADD6A851A3D7490E8F22EADCB56B575EB0F02FFEEFE9E9799CDAEE51245A767B
	62894A1E3DC11278EFBDF79C5AB76EDD8B2AC5B2EAD5ABEFA793731B0508A374
	CCD7A21F7698E46A15355E8332333335BFC559801AA436C803F2A276C3F751B0
	C4DE93BBA1F11E3E7CB83DD69BE221C175A67352408DEBABEC25BB42E5A497DA
	F382289CD8EB521BE69C787B7BEBE2D958515151693428B9D7BB776F5D45AE4C
	A186F4131C33B16369BAC9391FA83F616161516CD7BA820682DE75EAD4D9459D
	E1E9D8D8D856EC65DD3162C4082FEACCFF143BBEC286F32575CEA83DBE347EFC
	7837B65B5DB161C3860AD48F0CA17C9E2521DF43F5A3097B4BB7209285A52E8A
	1F676CE6EA06EA831E225796D8B66D5B7992AA581A40ADA33CDFA5367B637474
	74073A47F69CBBAB1A6A7F9AD16FC0C44B51CFB1EEC63DF5FF28B3163C3DE110
	950000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="5" length_in_bytes="386" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000200000
	000F08060000008580CD1700000006624B474400FF00FF00FFA0BDA793000001
	2D49444154388D6360186C40C3C4C241C3C8E22AB17C7C40DDC8E23E21711664
	09352333DBFFFF18563230FC8B24864F04502024CE842CCAC4C03483918921FC
	E6B953FBD48CCC6C191998D63030FC8BC4C6272524F0019410B871EE84360303
	C4A7F82C2723247002267401622C47E653D501F4B61CC301C3310DFCD6D676E0
	B97AF5C0179880AEAE8DE02F863F3FB13A8058CB898F06C6897FD87F7C5237B2
	608489FCFAFFFB1FC37FC67A189F9976963330BC7DFE64B7A8A40C3F2323C3F1
	9BE74E58894ACAF03332319EB879EE440D4C0DCDD30033F3DFAEFFFF1812B44D
	4D0DFEFF6788FFFF8FB917258CB069A27648681859F4313030D83130321CBC71
	F64431B21C461A808504031343F88D33A70E10C387016819AF806E1E23E3FF82
	7FFF99745898FEF810722CDD010020F20F1A0FA67EC80000000049454E44AE42
	6082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="6" length_in_bytes="322" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000200000
	000F08060000008580CD1700000006624B474400FF00FF00FFA0BDA793000000
	ED49444154388D63601860C088CC993C7DD6670646461EA275FFFFFF2537338D
	1797B4BA91C5FD9BE74E28E2136742750E099613A75E819038130E057403A30E
	187500AD1DF05B5BDB0125A7E8EADA08323030FC84F159686B3FE3C43FEC3F3E
	A91B59C0CB9B5FFF7FFF63F8CF580FE3D334046E9E3B5ECAC8C030819191A1EF
	E6B9138C8C0C0CFD8C4C8C136E9E3FD1025343E31060606066FEDBF5E70FF355
	6D53D3C57FFE30C433FC67D64596A77922BC7AFAF40B464686857FFF32CF6164
	625870F3FCD167C8F2A821F0FFFF1752EB0264AEBA91C57D062CC52F23E3FF82
	7FFF99745898FEF890E278BA000016E246D3BBD2DC4A0000000049454E44AE42
	6082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="7" length_in_bytes="543" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000180000
	00110806000000C7786C3000000006624B474400FF00FF00FFA0BDA793000001
	CA49444154388DD594B16B535114C67FE7BDD038A89B74D328D5F74296FA9EFA
	9EA943061D441107F72805410B0E5AF03F7008A420142982621041E82EE26C48
	A4254240F0E1A083889B506C239A7B8F436868D3BE084D16CF74EF77CFFD7EE7
	1BEE85FFA1BC20FE9CA63B6362E4D2F4CC2EA2E305F13C8826AD4615B0A39077
	24F082A88C7205F4AA1744E551CC01061308701F9759002C4F806780EE15B02D
	811F4617103AC96AB39EAC36EB203FF3A7A2F37B35DF01509539ACB3D8DF0B4B
	569DB9B1000AE1B9C340316BD65F6E6A1B13F202D5A23F1DE74606186B6EA952
	6BB7DBEB9BDAD746A323C2732B7A7324C0D4D4C5AC456F38D63E1E6CE8E23C12
	91D95CA9B46F88CF9F42A1B47FABE0CDCC1C007E6700E4E08F798149759DC40B
	E2ED57B5F70C26D636EE020F76F79787DDECAF352F88A52F758C82547BB493F1
	BBE3E1994B69E3F9C1D9CB7E10378724C00FE2053F8CAB836B271FC601C2E4A7
	63475EA75DFED86ABC52E4D089E9E2E9B41ED73515B55CCF8771A04A59ADDB03
	18CB1D115D6479D90C19D0024B38F6765AC3879595EF22D4ACF246845AF2BEFE
	0D20234284ABF786C507908C794AD7790BFDDF33B7E5F84BD26A1E755D53E91A
	F79AEB9ACABFFCC6567F016B99954F8EDB48FC0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="8" length_in_bytes="258" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000100000
	001008060000001FF3FF61000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313147
	F342370000006749444154384FA58C4B0AC030084473FF4BDB2A8CB5838A4916
	0F747E4B44AEC8C557663803FE4F13AEBCEF288A0CE75291511FE0778F850ACD
	2017F31EE8488BD02054C45264345095957640CDAEAC94036E9C0E98382CDB8D
	6387AB8158B63F3E27A4E21C590F6A0BB3695B02F7660000000049454E44AE42
	6082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="9" length_in_bytes="261" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000100000
	001008060000001FF3FF61000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313147
	F342370000006A49444154384FA58C510AC03008437BFF4BBB4E481B256E957E
	3C30CFE830B32BA4EC2065072DA766F29E89A138A8FCCB1E8A02A33A7B50CBE9
	0032762004053F40C6EC994306653EE2D9338725A7CE45F0FB00855C04D9AF21
	C8C36377597C71FD4021650729CFB1F1008EA5C15B759257AA0000000049454E
	44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="10" length_in_bytes="320" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000180000
	001308060000008AB0CD3B000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313147
	F34237000000A549444154484BB58D0B0EC330084373FF4B7706D919232D4351
	FA242BE6E78C8A2BC1F6199869A12EFA33781A301BCAB31FD843EBF8E004CCFB
	F9C007BB7802516D4F1A39B1973D748F162256DFF544F6D03361291ECCDAA83C
	54C35D2D4F89CA433D78A3A31914468B87FAF0CEB132B59670BE7DE26126F6B3
	87DAF0AC0E14F2787BF83608B6EDA1FF6859EC78A884AB7BE1C23CB4C2793B44
	541EFAA2A638E9A13719E303A373B76544A842BA0000000049454E44AE426082
	]]>
</GDLPict>

<Copyright SectVersion="1" SectionFlags="0" SubIdent="0">
	<Author>GRAPHISOFT</Author>
	<License>
		<Type>CC BY-ND</Type>
		<Version>3.0</Version>
	</License>
</Copyright>

<Keywords SectVersion="1" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Keywords>

<Comment SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Comment>

</Symbol>
