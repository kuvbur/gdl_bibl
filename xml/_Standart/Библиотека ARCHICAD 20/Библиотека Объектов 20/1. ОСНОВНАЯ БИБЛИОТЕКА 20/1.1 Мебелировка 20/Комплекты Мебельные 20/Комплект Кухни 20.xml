<?xml version="1.0" encoding="UTF-8"?>
<Symbol IsArchivable="false" IsPlaceable="true" MainGUID="99EC7C33-79D8-4288-BC4A-431867BFA2E5" MigrationValue="Normal" Owner="1196638531" Signature="1196644685" Version="43">
<Ancestry SectVersion="1" SectionFlags="0" SubIdent="0" Template="false">
	<MainGUID>F938E33A-329D-4A36-BE3E-85E126820996</MainGUID>
	<MainGUID>103E8D2C-8230-42E1-9597-46F84CCE28C0</MainGUID>
	<MainGUID>C76BC373-89AE-4368-A490-BB2485825242</MainGUID>
	<MainGUID>16E04743-086F-40A9-9958-B638E2C5E56D</MainGUID>
</Ancestry>

<CalledMacros SectVersion="2" SectionFlags="0" SubIdent="0">
	<Macro>
		<MName><![CDATA["fa_minimalspace"]]></MName>
		<MainGUID>948022D5-BA0C-4407-8518-A3B5922DF84C</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["fa_sinktyp"]]></MName>
		<MainGUID>24C1C441-D579-4DAE-9326-AEE228CB6CDE</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["fa_CooktopType"]]></MName>
		<MainGUID>15A9ACFE-9137-4590-9A87-3ABFD24BF9DD</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["fa_MicOvenDoor"]]></MName>
		<MainGUID>E54F28E1-DE0F-4BD5-963C-BB48C2E14E91</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["ui_object_Representation"]]></MName>
		<MainGUID>A6E015E8-F078-4756-9A38-A5A6418680E0</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["ui_object_SymbolText"]]></MName>
		<MainGUID>C88FE4AB-EE02-44B8-98E8-E782F6DB19E4</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["ui_object_listing"]]></MName>
		<MainGUID>5E5E7258-404A-491C-940D-0DA037D87125</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["FM_types"]]></MName>
		<MainGUID>2759D2DF-AA8E-44D1-AD1D-261581266B34</MainGUID>
	</Macro>
</CalledMacros>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_3D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
pen gs_cont_pen
if not(gs_shadow) then shadow off


! ------------------------------------------------------------------------------
! Definitions
! ------------------------------------------------------------------------------
washerBack		= 0.02
washerDist		= 0.01
washerPanelH	= 0.11
toeBack			= 0.05
cutMask			= 15
cutMask2		= 23
gs_resol		= 16
sinkDepth		= 0.2

refriDoorThk	= 0.08
refriDoorW		= 0.9/0.5
refriFreezeH	= 0.5
if iRefrigeratorType = ACC_REFRI_COMPACT then
	refrigeratorHeigth	= counterHeigth - counterThickness
	refrigeratorDepth	= refriDefaults[ACC_REFRI_COMPACT]
	bRefriWallCabinet	= 0
endif

ovenBack		= 0.02
ovenThk			= 0.02
ovenCutDepth	= counterDepth*0.6
noTallOvenHeigth = max(counterHeigth - counterThickness -ovenH - 0.13, toeHeigth)
for i = 1 to nofOvens
	if not(bOvenInTall[i]) then
		ovenHeigth[i] = noTallOvenHeigth
	endif
next i

resol gs_resol


! ==============================================================================
!
! Hotspots
!
! ==============================================================================

! ------------------------------------------------------------------------------
! Reference Line
! ------------------------------------------------------------------------------
unID = 100
for i = 1 to nRefPoints[1] - (iLayoutType = LAYOUT_ISLAND)*2
	hotspot  0,						refLinePoints_1[i][2],	0, unID, refLinePoints_1[i][1], 1+128		: unID = unID + 1
	hotspot -1, 					refLinePoints_1[i][2],	0, unID, refLinePoints_1[i][1], 3			: unID = unID + 1
	hotspot refLinePoints_1[i][1],	refLinePoints_1[i][2],	0, unID, refLinePoints_1[i][1], 2			: unID = unID + 1

	hotspot refLinePoints_1[i][1],	0,					 	0, unID, refLinePoints_1[i][2], 1+128		: unID = unID + 1
	hotspot refLinePoints_1[i][1], -1,						0, unID, refLinePoints_1[i][2], 3			: unID = unID + 1
	hotspot refLinePoints_1[i][1],	refLinePoints_1[i][2],	0, unID, refLinePoints_1[i][2], 2			: unID = unID + 1

	hotspot  0,						refLinePoints_1[i][2],	counterHeigth, unID, refLinePoints_1[i][1], 1+128		: unID = unID + 1
	hotspot -1, 					refLinePoints_1[i][2],	counterHeigth, unID, refLinePoints_1[i][1], 3			: unID = unID + 1
	hotspot refLinePoints_1[i][1],	refLinePoints_1[i][2],	counterHeigth, unID, refLinePoints_1[i][1], 2			: unID = unID + 1

	hotspot refLinePoints_1[i][1],	0,					 	counterHeigth, unID, refLinePoints_1[i][2], 1+128		: unID = unID + 1
	hotspot refLinePoints_1[i][1], -1,						counterHeigth, unID, refLinePoints_1[i][2], 3			: unID = unID + 1
	hotspot refLinePoints_1[i][1],	refLinePoints_1[i][2],	counterHeigth, unID, refLinePoints_1[i][2], 2			: unID = unID + 1
next i

for i = 1 to nRefPoints[2]
	hotspot  0,						refLinePoints_2[i][2],	0, unID, refLinePoints_2[i][1], 1+128		: unID = unID + 1
	hotspot -1, 					refLinePoints_2[i][2],	0, unID, refLinePoints_2[i][1], 3			: unID = unID + 1
	hotspot refLinePoints_2[i][1],	refLinePoints_2[i][2],	0, unID, refLinePoints_2[i][1], 2			: unID = unID + 1

	hotspot refLinePoints_2[i][1],	0,					 	0, unID, refLinePoints_2[i][2], 1+128		: unID = unID + 1
	hotspot refLinePoints_2[i][1], -1,						0, unID, refLinePoints_2[i][2], 3			: unID = unID + 1
	hotspot refLinePoints_2[i][1],	refLinePoints_2[i][2],	0, unID, refLinePoints_2[i][2], 2			: unID = unID + 1

	hotspot  0,						refLinePoints_2[i][2],	counterHeigth, unID, refLinePoints_2[i][1], 1+128		: unID = unID + 1
	hotspot -1, 					refLinePoints_2[i][2],	counterHeigth, unID, refLinePoints_2[i][1], 3			: unID = unID + 1
	hotspot refLinePoints_2[i][1],	refLinePoints_2[i][2],	counterHeigth, unID, refLinePoints_2[i][1], 2			: unID = unID + 1

	hotspot refLinePoints_2[i][1],	0,					 	counterHeigth, unID, refLinePoints_2[i][2], 1+128		: unID = unID + 1
	hotspot refLinePoints_2[i][1], -1,						counterHeigth, unID, refLinePoints_2[i][2], 3			: unID = unID + 1
	hotspot refLinePoints_2[i][1],	refLinePoints_2[i][2],	counterHeigth, unID, refLinePoints_2[i][2], 2			: unID = unID + 1
next i

for i = 1 to nRefPoints[3]
	hotspot  0,						refLinePoints_3[i][2],	0, unID, refLinePoints_3[i][1], 1+128		: unID = unID + 1
	hotspot -1, 					refLinePoints_3[i][2],	0, unID, refLinePoints_3[i][1], 3			: unID = unID + 1
	hotspot refLinePoints_3[i][1],	refLinePoints_3[i][2],	0, unID, refLinePoints_3[i][1], 2			: unID = unID + 1

	hotspot refLinePoints_3[i][1],	0,					 	0, unID, refLinePoints_3[i][2], 1+128		: unID = unID + 1
	hotspot refLinePoints_3[i][1], -1,						0, unID, refLinePoints_3[i][2], 3			: unID = unID + 1
	hotspot refLinePoints_3[i][1],	refLinePoints_3[i][2],	0, unID, refLinePoints_3[i][2], 2			: unID = unID + 1

	hotspot  0,						refLinePoints_3[i][2],	counterHeigth, unID, refLinePoints_3[i][1], 1+128		: unID = unID + 1
	hotspot -1, 					refLinePoints_3[i][2],	counterHeigth, unID, refLinePoints_3[i][1], 3			: unID = unID + 1
	hotspot refLinePoints_3[i][1],	refLinePoints_3[i][2],	counterHeigth, unID, refLinePoints_3[i][1], 2			: unID = unID + 1

	hotspot refLinePoints_3[i][1],	0,					 	counterHeigth, unID, refLinePoints_3[i][2], 1+128		: unID = unID + 1
	hotspot refLinePoints_3[i][1], -1,						counterHeigth, unID, refLinePoints_3[i][2], 3			: unID = unID + 1
	hotspot refLinePoints_3[i][1],	refLinePoints_3[i][2],	counterHeigth, unID, refLinePoints_3[i][2], 2			: unID = unID + 1
next i


! ------------------------------------------------------------------------------
! Other Contour Points
! ------------------------------------------------------------------------------
unID = 1500
for i = 1 to vardim1(oppsidePoints)
	hotspot oppsidePoints[i][1], oppsidePoints[i][2], 0, 				unID		: unID = unID + 1
next i


! ------------------------------------------------------------------------------
! Elements Moveable Hotspots
! ------------------------------------------------------------------------------
for i = 1 to nElement
	n = elementTypes[i][2]
	unID = 2000 + (elementTypes[i][1]-1) * 1000  +  (n-1) * 100

	if elementTypes[i][1] = SYMBTYPE_TALL then
		hotspot  0,					tallCabPos[n][2], ZZYZX,	unID, tallCabPos[n][1], 1+128	: unID = unID + 1
		hotspot -1,					tallCabPos[n][2], ZZYZX,	unID, tallCabPos[n][1], 3		: unID = unID + 1
		hotspot tallCabPos[n][1],	tallCabPos[n][2], ZZYZX,	unID, tallCabPos[n][1], 2		: unID = unID + 1

		hotspot tallCabPos[n][1],	 0,				  ZZYZX,	unID, tallCabPos[n][2], 1+128	: unID = unID + 1
		hotspot tallCabPos[n][1],	-1,				  ZZYZX,	unID, tallCabPos[n][2], 3		: unID = unID + 1
		hotspot tallCabPos[n][1],	tallCabPos[n][2], ZZYZX,	unID, tallCabPos[n][2], 2		: unID = unID + 1
	endif

	if elementTypes[i][1] = SYMBTYPE_SINK then
		hotspot  0,				sinkPos[n][2],	counterHeigth, unID, sinkPos[n][1], 1+128		: unID = unID + 1
		hotspot -1,				sinkPos[n][2],	counterHeigth, unID, sinkPos[n][1], 3			: unID = unID + 1
		hotspot sinkPos[n][1],	sinkPos[n][2],	counterHeigth, unID, sinkPos[n][1], 2			: unID = unID + 1

		hotspot sinkPos[n][1],	 0,				counterHeigth, unID, sinkPos[n][2], 1+128		: unID = unID + 1
		hotspot sinkPos[n][1],	-1,				counterHeigth, unID, sinkPos[n][2], 3			: unID = unID + 1
		hotspot sinkPos[n][1],	sinkPos[n][2],	counterHeigth, unID, sinkPos[n][2], 2			: unID = unID + 1
	endif

	if elementTypes[i][1] = SYMBTYPE_COOKTOP then
		hotspot  0,					cooktopPos[n][2],	counterHeigth, unID, cooktopPos[n][1], 1+128		: unID = unID + 1
		hotspot -1,					cooktopPos[n][2],	counterHeigth, unID, cooktopPos[n][1], 3			: unID = unID + 1
		hotspot cooktopPos[n][1],	cooktopPos[n][2],	counterHeigth, unID, cooktopPos[n][1], 2			: unID = unID + 1

		hotspot cooktopPos[n][1],	 0,					counterHeigth, unID, cooktopPos[n][2], 1+128		: unID = unID + 1
		hotspot cooktopPos[n][1],	-1,					counterHeigth, unID, cooktopPos[n][2], 3			: unID = unID + 1
		hotspot cooktopPos[n][1],	cooktopPos[n][2],	counterHeigth, unID, cooktopPos[n][2], 2			: unID = unID + 1
	endif

	if elementTypes[i][1] = SYMBTYPE_OVEN then
		hotspot  0,				ovenPos[n][2],	counterHeigth, unID, ovenPos[n][1], 1+128		: unID = unID + 1
		hotspot -1,				ovenPos[n][2],	counterHeigth, unID, ovenPos[n][1], 3			: unID = unID + 1
		hotspot ovenPos[n][1],	ovenPos[n][2],	counterHeigth, unID, ovenPos[n][1], 2			: unID = unID + 1

		hotspot ovenPos[n][1],	 0,				counterHeigth, unID, ovenPos[n][2], 1+128		: unID = unID + 1
		hotspot ovenPos[n][1],	-1,				counterHeigth, unID, ovenPos[n][2], 3			: unID = unID + 1
		hotspot ovenPos[n][1],	ovenPos[n][2],	counterHeigth, unID, ovenPos[n][2], 2			: unID = unID + 1
	endif

	if elementTypes[i][1] = SYMBTYPE_REFRI then
		hotspot  0,						refrigeratorPos[n][2],	refrigeratorHeigth, unID, refrigeratorPos[n][1], 1+128		: unID = unID + 1
		hotspot -1,						refrigeratorPos[n][2],	refrigeratorHeigth, unID, refrigeratorPos[n][1], 3			: unID = unID + 1
		hotspot refrigeratorPos[n][1],	refrigeratorPos[n][2],	refrigeratorHeigth, unID, refrigeratorPos[n][1], 2			: unID = unID + 1

		hotspot refrigeratorPos[n][1],	 0,						refrigeratorHeigth, unID, refrigeratorPos[n][2], 1+128		: unID = unID + 1
		hotspot refrigeratorPos[n][1],	-1,						refrigeratorHeigth, unID, refrigeratorPos[n][2], 3			: unID = unID + 1
		hotspot refrigeratorPos[n][1],	refrigeratorPos[n][2],	refrigeratorHeigth, unID, refrigeratorPos[n][2], 2			: unID = unID + 1
	endif

	if elementTypes[i][1] = SYMBTYPE_DISHWASH then
		hotspot  0,						dishwasherPos[n][2],	counterHeigth, unID, dishwasherPos[n][1], 1+128	: unID = unID + 1
		hotspot -1,						dishwasherPos[n][2],	counterHeigth, unID, dishwasherPos[n][1], 3		: unID = unID + 1
		hotspot dishwasherPos[n][1],	dishwasherPos[n][2],	counterHeigth, unID, dishwasherPos[n][1], 2		: unID = unID + 1

		hotspot dishwasherPos[n][1],	 0,						counterHeigth, unID, dishwasherPos[n][2], 1+128	: unID = unID + 1
		hotspot dishwasherPos[n][1],	-1,						counterHeigth, unID, dishwasherPos[n][2], 3		: unID = unID + 1
		hotspot dishwasherPos[n][1],	dishwasherPos[n][2],	counterHeigth, unID, dishwasherPos[n][2], 2		: unID = unID + 1
	endif

	if elementTypes[i][1] = SYMBTYPE_WASH then
		hotspot  0,					washerPos[n][2],	counterHeigth, unID, washerPos[n][1], 1+128	: unID = unID + 1
		hotspot -1,					washerPos[n][2],	counterHeigth, unID, washerPos[n][1], 3		: unID = unID + 1
		hotspot washerPos[n][1],	washerPos[n][2],	counterHeigth, unID, washerPos[n][1], 2		: unID = unID + 1

		hotspot washerPos[n][1],	 0,					counterHeigth, unID, washerPos[n][2], 1+128	: unID = unID + 1
		hotspot washerPos[n][1],	-1,					counterHeigth, unID, washerPos[n][2], 3		: unID = unID + 1
		hotspot washerPos[n][1],	washerPos[n][2],	counterHeigth, unID, washerPos[n][2], 2		: unID = unID + 1
	endif
next i


! ------------------------------------------------------------------------------
! Elements Width Hotspots
! ------------------------------------------------------------------------------

for i = 1 to nElement
	n = elementTypes[i][2]
	unID = 2000 + (elementTypes[i][1]-1) * 1000  +  (n-1) * 100 + 20

	if elementTypes[i][1] = SYMBTYPE_TALL then
		hotspot elementWidth[i][1],							elementWidth[i][2],						ZZYZX, unID, tallCabinetWidth2[n], 1+128	: unID = unID + 1
		hotspot elementWidth[i][1]+cos(elementAngle[i]),	elementWidth[i][2]+sin(elementAngle[i]),ZZYZX, unID, tallCabinetWidth2[n], 3	: unID = unID + 1
		hotspot elementWidth[i][3],							elementWidth[i][4],						ZZYZX, unID, tallCabinetWidth2[n], 2	: unID = unID + 1

		hotspot elementWidth[i][3],							elementWidth[i][4],						ZZYZX, unID, tallCabinetWidth[n], 1+128	: unID = unID + 1
		hotspot elementWidth[i][3]-cos(elementAngle[i]),	elementWidth[i][4]-sin(elementAngle[i]),ZZYZX, unID, tallCabinetWidth[n], 3		: unID = unID + 1
		hotspot elementWidth[i][1],							elementWidth[i][2],						ZZYZX, unID, tallCabinetWidth[n], 2		: unID = unID + 1

		unID = unID + 6
	endif

	if elementTypes[i][1] = SYMBTYPE_SINK then
		if iSinkType <> ACC_SINK_ROUND then
			hotspot elementWidth[i][1],						elementWidth[i][2],						counterHeigth, unID, sinkWidth2[n], 1+128	: unID = unID + 1
			hotspot elementWidth[i][1]+cos(elementAngle[i]),elementWidth[i][2]+sin(elementAngle[i]),counterHeigth, unID, sinkWidth2[n], 3		: unID = unID + 1
			hotspot elementWidth[i][3],						elementWidth[i][4],						counterHeigth, unID, sinkWidth2[n], 2		: unID = unID + 1

			hotspot elementWidth[i][3],						elementWidth[i][4],						counterHeigth, unID, sinkWidth[n], 1+128	: unID = unID + 1
			hotspot elementWidth[i][3]-cos(elementAngle[i]),elementWidth[i][4]-sin(elementAngle[i]),counterHeigth, unID, sinkWidth[n], 3		: unID = unID + 1
			hotspot elementWidth[i][1],						elementWidth[i][2],						counterHeigth, unID, sinkWidth[n], 2		: unID = unID + 1

			unID = unID + 6
		else
			hotspot elementPos[i][1],						elementPos[i][2],						counterHeigth, unID, sinkWidthHalf, 1+128			: unID = unID + 1
			hotspot elementPos[i][1]+cos(elementAngle[i]),	elementPos[i][2]+sin(elementAngle[i]),	counterHeigth, unID, sinkWidthHalf, 3				: unID = unID + 1
			hotspot elementWidth[i][3],						elementWidth[i][4],						counterHeigth, unID, sinkWidthHalf, 2, sinkWidth[n]	: unID = unID + 1

			hotspot elementPos[i][1],						elementPos[i][2],						counterHeigth, unID, sinkWidthHalf, 1+128			: unID = unID + 1
			hotspot elementPos[i][1]-cos(elementAngle[i]),	elementPos[i][2]-sin(elementAngle[i]),	counterHeigth, unID, sinkWidthHalf, 3				: unID = unID + 1
			hotspot elementWidth[i][1],						elementWidth[i][2],						counterHeigth, unID, sinkWidthHalf, 2, sinkWidth[n]	: unID = unID + 1

			unID = unID + 6
		endif
	endif

	if elementTypes[i][1] = SYMBTYPE_COOKTOP then
		hotspot elementWidth[i][1],						elementWidth[i][2],						counterHeigth, unID, cooktopWidth2[n], 1+128	: unID = unID + 1
		hotspot elementWidth[i][1]+cos(elementAngle[i]),elementWidth[i][2]+sin(elementAngle[i]),counterHeigth, unID, cooktopWidth2[n], 3		: unID = unID + 1
		hotspot elementWidth[i][3],						elementWidth[i][4],						counterHeigth, unID, cooktopWidth2[n], 2		: unID = unID + 1

		hotspot elementWidth[i][3],						elementWidth[i][4],						counterHeigth, unID, cooktopWidth[n], 1+128	: unID = unID + 1
		hotspot elementWidth[i][3]-cos(elementAngle[i]),elementWidth[i][4]-sin(elementAngle[i]),counterHeigth, unID, cooktopWidth[n], 3		: unID = unID + 1
		hotspot elementWidth[i][1],						elementWidth[i][2],						counterHeigth, unID, cooktopWidth[n], 2		: unID = unID + 1

		if bHood then
			hotspot hoodWidthPos[n][1],						hoodWidthPos[n][2],						counterHeigth+wallCabinetClearence, unID, hoodWidth2[n], 1+128			: unID = unID + 1
			hotspot hoodWidthPos[n][1]-cos(elementAngle[i]),hoodWidthPos[n][2]-sin(elementAngle[i]),counterHeigth+wallCabinetClearence, unID, hoodWidth2[n], 3			: unID = unID + 1
			hotspot hoodWidthPos[n][3],						hoodWidthPos[n][4],						counterHeigth+wallCabinetClearence, unID, hoodWidth2[n], 2, hoodWidth[n]	: unID = unID + 1

			hotspot hoodWidthPos[n][1],						hoodWidthPos[n][2],						counterHeigth+wallCabinetClearence, unID, hoodWidth2[n], 1+128			: unID = unID + 1
			hotspot hoodWidthPos[n][1]+cos(elementAngle[i]),hoodWidthPos[n][2]+sin(elementAngle[i]),counterHeigth+wallCabinetClearence, unID, hoodWidth2[n], 3			: unID = unID + 1
			hotspot hoodWidthPos[n][5],						hoodWidthPos[n][6],						counterHeigth+wallCabinetClearence, unID, hoodWidth2[n], 2, hoodWidth[n]	: unID = unID + 1
		else
			unID = unID + 6
		endif
	endif

	if elementTypes[i][1] = SYMBTYPE_OVEN then
		hpH = ovenHeigth[n] + ovenH
		add sin(elementAngle[i]) * counterDepth/2, -cos(elementAngle[i]) * counterDepth/2, 0

		hotspot elementWidth[i][1],						elementWidth[i][2],						hpH, unID, ovenWidth2[n], 1+128		: unID = unID + 1
		hotspot elementWidth[i][1]+cos(elementAngle[i]),elementWidth[i][2]+sin(elementAngle[i]),hpH, unID, ovenWidth2[n], 3			: unID = unID + 1
		hotspot elementWidth[i][3],						elementWidth[i][4],						hpH, unID, ovenWidth2[n], 2			: unID = unID + 1

		hotspot elementWidth[i][3],						elementWidth[i][4],						hpH, unID, ovenWidth[n], 1+128		: unID = unID + 1
		hotspot elementWidth[i][3]-cos(elementAngle[i]),elementWidth[i][4]-sin(elementAngle[i]),hpH, unID, ovenWidth[n], 3			: unID = unID + 1
		hotspot elementWidth[i][1],						elementWidth[i][2],						hpH, unID, ovenWidth[n], 2			: unID = unID + 1

		if bOvenInTall[n] then
			hotspot ovenPos[n][1],	ovenPos[n][2],	0, 				unID, ovenHeigth[n], 1+128		: unID = unID + 1
			hotspot ovenPos[n][1],	ovenPos[n][2],	-1, 			unID, ovenHeigth[n], 3			: unID = unID + 1
			hotspot ovenPos[n][1],	ovenPos[n][2],	ovenHeigth[n],	unID, ovenHeigth[n], 2			: unID = unID + 1
		else
			unID = unID + 3
		endif

		unID = unID + 3

		del 1
	endif

	if elementTypes[i][1] = SYMBTYPE_REFRI then
		tx1 = sin(elementAngle[i]) * (refrigeratorDepth-counterDepth/2)
		ty1 = cos(elementAngle[i]) * (refrigeratorDepth-counterDepth/2)

		tx2 = sin(elementAngle[i]) * refrigeratorDepth
		ty2 = cos(elementAngle[i]) * refrigeratorDepth

		tx3 = sin(elementAngle[i]) * (counterDepth/2)
		ty3 = cos(elementAngle[i]) * (counterDepth/2)

		hotspot elementWidth[i][1]+tx1,						elementWidth[i][2]-ty1,						refrigeratorHeigth, unID, refrigeratorWidth2[n], 1+128	: unID = unID + 1
		hotspot elementWidth[i][1]+tx1+cos(elementAngle[i]),elementWidth[i][2]-ty1+sin(elementAngle[i]),refrigeratorHeigth, unID, refrigeratorWidth2[n], 3	: unID = unID + 1
		hotspot elementWidth[i][3]+tx1,						elementWidth[i][4]-ty1,						refrigeratorHeigth, unID, refrigeratorWidth2[n], 2	: unID = unID + 1

		hotspot elementWidth[i][3]+tx1,						elementWidth[i][4]-ty1,						refrigeratorHeigth, unID, refrigeratorWidth[n], 1+128	: unID = unID + 1
		hotspot elementWidth[i][3]+tx1-cos(elementAngle[i]),elementWidth[i][4]-ty1-sin(elementAngle[i]),refrigeratorHeigth, unID, refrigeratorWidth[n], 3		: unID = unID + 1
		hotspot elementWidth[i][1]+tx1,						elementWidth[i][2]-ty1,						refrigeratorHeigth, unID, refrigeratorWidth[n], 2		: unID = unID + 1

		hotspot elementWidth[i][1]-tx3,						elementWidth[i][2]+ty3,						refrigeratorHeigth, unID, refrigeratorDepth, 1+128	: unID = unID + 1
		hotspot elementWidth[i][1]-tx3,						elementWidth[i][2]+ty3,						refrigeratorHeigth, unID, refrigeratorDepth, 3		: unID = unID + 1
		hotspot elementWidth[i][1]-tx3+tx2,					elementWidth[i][2]+ty3-ty2,					refrigeratorHeigth, unID, refrigeratorDepth, 2		: unID = unID + 1

		hotspot elementWidth[i][3]-tx3,						elementWidth[i][4]+ty3,						refrigeratorHeigth, unID, refrigeratorDepth, 1+128	: unID = unID + 1
		hotspot elementWidth[i][3]-tx3,						elementWidth[i][4]+ty3,						refrigeratorHeigth, unID, refrigeratorDepth, 3		: unID = unID + 1
		hotspot elementWidth[i][3]-tx3+tx2,					elementWidth[i][4]+ty3-ty2,					refrigeratorHeigth, unID, refrigeratorDepth, 2		: unID = unID + 1

	endif

	if elementTypes[i][1] = SYMBTYPE_DISHWASH then
		add sin(elementAngle[i]) * counterDepth/2, -cos(elementAngle[i]) * counterDepth/2, 0

		hotspot elementWidth[i][1],						elementWidth[i][2],						counterHeigth, unID, dishwasherWidth2[n], 1+128		: unID = unID + 1
		hotspot elementWidth[i][1]+cos(elementAngle[i]),elementWidth[i][2]+sin(elementAngle[i]),counterHeigth, unID, dishwasherWidth2[n], 3		: unID = unID + 1
		hotspot elementWidth[i][3],						elementWidth[i][4],						counterHeigth, unID, dishwasherWidth2[n], 2		: unID = unID + 1

		hotspot elementWidth[i][3],						elementWidth[i][4],						counterHeigth, unID, dishwasherWidth[n], 1+128		: unID = unID + 1
		hotspot elementWidth[i][3]-cos(elementAngle[i]),elementWidth[i][4]-sin(elementAngle[i]),counterHeigth, unID, dishwasherWidth[n], 3		: unID = unID + 1
		hotspot elementWidth[i][1],						elementWidth[i][2],						counterHeigth, unID, dishwasherWidth[n], 2		: unID = unID + 1

		unID = unID + 6

		del 1
	endif

	if elementTypes[i][1] = SYMBTYPE_WASH then
		add sin(elementAngle[i]) * counterDepth/2, -cos(elementAngle[i]) * counterDepth/2, 0

		hotspot elementWidth[i][1],						elementWidth[i][2],						counterHeigth, unID, washerWidth2[n], 1+128	: unID = unID + 1
		hotspot elementWidth[i][1]+cos(elementAngle[i]),elementWidth[i][2]+sin(elementAngle[i]),counterHeigth, unID, washerWidth2[n], 3		: unID = unID + 1
		hotspot elementWidth[i][3],						elementWidth[i][4],						counterHeigth, unID, washerWidth2[n], 2		: unID = unID + 1

		hotspot elementWidth[i][3],						elementWidth[i][4],						counterHeigth, unID, washerWidth[n], 1+128	: unID = unID + 1
		hotspot elementWidth[i][3]-cos(elementAngle[i]),elementWidth[i][4]-sin(elementAngle[i]),counterHeigth, unID, washerWidth[n], 3		: unID = unID + 1
		hotspot elementWidth[i][1],						elementWidth[i][2],						counterHeigth, unID, washerWidth[n], 2		: unID = unID + 1

		unID = unID + 6

		del 1
	endif

next i


! ==============================================================================
!
! Body
!
! ==============================================================================

nCut	= 0
nToeCut	= 0
nWallCut= 0

! ------------------------------------------------------------------------------
! Cutting Toe
! ------------------------------------------------------------------------------
for i = 1 to nElement
	if elementTypes[i][1] = SYMBTYPE_TALL | elementTypes[i][1] = SYMBTYPE_REFRI | elementTypes[i][1] = SYMBTYPE_DISHWASH | elementTypes[i][1] = SYMBTYPE_WASH then
		add elementXY[i][1], elementXY[i][2], 0
		rotz elementAngle[i]

		widthSymbol		= counterDepth + EPS
		lengthSymbol	= elementSizes[i]

		cutpolya 4, 1, 0,
			-lengthSymbol/2, -widthSymbol/2, cutMask,
			-lengthSymbol/2,  widthSymbol/2, cutMask,
			 lengthSymbol/2,  widthSymbol/2, cutMask,
			 lengthSymbol/2, -widthSymbol/2, cutMask

		nToeCut = nToeCut + 1

		del 2
	endif
next i


! ------------------------------------------------------------------------------
! Toe Body
! ------------------------------------------------------------------------------
if toeHeigth > EPS then
	dim tempOffset[][2]
	offsetSize = counterDepth - toeBack
	gosub "polyLineOffset"
	dim toePoints[][2]
	toePoints = tempOffset

	for i = 1 to nTotalRefPoint-1
		if bIsLine[i] then
			startMask	= 10 + 5 * not(bIsSect[i])
			endMask		= 10 + 5 * not(bIsSect[i+1])

			material gs_base_mat
			prism_ 5, toeHeigth,
				refLinePoints[i  ][1], refLinePoints[i  ][2], 15,
				refLinePoints[i+1][1], refLinePoints[i+1][2], endMask,
				toePoints[i+1][1],	toePoints[i+1][2], 15,
				toePoints[i][1],	toePoints[i  ][2], startMask,
				refLinePoints[i  ][1], refLinePoints[i  ][2], -1

			rotz refAngle[i]
			gosub "textureCube"
			del 1
		endif
	next i
endif


! ------------------------------------------------------------------------------
! Cutend
! ------------------------------------------------------------------------------
for i =1 to nToeCut
	cutend
next i


! ------------------------------------------------------------------------------
! Cutting Counter
! ------------------------------------------------------------------------------
for i = 1 to nElement
	if elementTypes[i][1] = SYMBTYPE_SINK then
		add elementXY[i][1], elementXY[i][2], 0
		rotz elementAngle[i]

		widthSymbol		= counterDepth
		lengthSymbol	= elementSizes[i]

		if elementTypes[i][1] = SYMBTYPE_SINK then
			if iSinkType = ACC_SINK_ROUND then
				cutpolya 2, 1, 0,
					0, 0, 979,
					sinkWidthHalf-0.01, 360, 4079
			else
				if counterDepth < minSinkCounter then
					sinkOffsetY	= 0
					sinkMinusY	= 0.02
					sinkMinusX	= 0.02
				else
					sinkOffsetY = 0.02
					sinkMinusY	= 0.15
					sinkMinusX	= 0.05
				endif

				addy sinkOffsetY

				widthSymbol = widthSymbol - sinkMinusY
				lengthSymbol = lengthSymbol - sinkMinusX
				cutpolya 4, 1, 0,
					-lengthSymbol/2, -widthSymbol/2, cutMask,
					-lengthSymbol/2,  widthSymbol/2, cutMask,
					 lengthSymbol/2,  widthSymbol/2, cutMask,
					 lengthSymbol/2, -widthSymbol/2, cutMask
				del 1
			endif

			nCut = nCut + 1

		endif

		del 2
	endif

	if elementTypes[i][1] = SYMBTYPE_TALL then
		add elementXY[i][1], elementXY[i][2], 0
		rotz elementAngle[i]

		widthSymbol		= counterDepth + EPS
		lengthSymbol	= elementSizes[i]

		cutpolya 4, 1, 0,
			-lengthSymbol/2, -widthSymbol/2, cutMask,
			-lengthSymbol/2,  widthSymbol/2, cutMask,
			 lengthSymbol/2,  widthSymbol/2, cutMask,
			 lengthSymbol/2, -widthSymbol/2, cutMask

		nCut = nCut + 1

		del 2
	endif

	if elementTypes[i][1] = SYMBTYPE_REFRI & (refrigeratorHeigth > counterHeigth-EPS | bRefriWallCabinet) then
		add elementXY[i][1], elementXY[i][2], 0
		rotz elementAngle[i]

		widthSymbol		= counterDepth + EPS
		lengthSymbol	= elementSizes[i]

		cutpolya 4, 1, 0,
			-lengthSymbol/2, -widthSymbol/2, cutMask,
			-lengthSymbol/2,  widthSymbol/2, cutMask,
			 lengthSymbol/2,  widthSymbol/2, cutMask,
			 lengthSymbol/2, -widthSymbol/2, cutMask

		nCut = nCut + 1

		del 2
	endif

next i


! ------------------------------------------------------------------------------
! Counter Body
! ------------------------------------------------------------------------------
for i = 1 to nTotalRefPoint-1
	if bIsLine[i] then
		startMask	= 10 + 5 * not(bIsSect[i])
		endMask		= 10 + 5 * not(bIsSect[i+1])

		material count_mat
		addz counterHeigth-counterThickness
		prism_ 5, counterThickness,
			refLinePoints[i  ][1], refLinePoints[i  ][2], 15,
			refLinePoints[i+1][1], refLinePoints[i+1][2], endMask,
			oppsidePoints[i+1][1], oppsidePoints[i+1][2], 15,
			oppsidePoints[i  ][1], oppsidePoints[i  ][2], startMask,
			refLinePoints[i  ][1], refLinePoints[i  ][2], -1

		rotz refAngle[i]
		gosub "textureCube"
		del 2
	endif
next i


! ------------------------------------------------------------------------------
! Cutting Cabinet
! ------------------------------------------------------------------------------
for i = 1 to nElement
	if (elementTypes[i][1] = SYMBTYPE_REFRI & (refrigeratorHeigth < counterHeigth+EPS | not(bRefriWallCabinet))) | elementTypes[i][1] = SYMBTYPE_DISHWASH | elementTypes[i][1] = SYMBTYPE_WASH then
		add elementXY[i][1], elementXY[i][2], 0
		rotz elementAngle[i]

		widthSymbol		= counterDepth + EPS
		lengthSymbol	= elementSizes[i]

		cutpolya 4, 1, 0,
			-lengthSymbol/2, -widthSymbol/2, cutMask,
			-lengthSymbol/2,  widthSymbol/2, cutMask,
			 lengthSymbol/2,  widthSymbol/2, cutMask,
			 lengthSymbol/2, -widthSymbol/2, cutMask

		nCut = nCut + 1

		del 2
	endif
next i


! ------------------------------------------------------------------------------
! Cabinet Body
! ------------------------------------------------------------------------------
for i = 1 to nTotalRefPoint-1
	if bIsLine[i] then
		nOvenCut = 0
		for k = 1 to nofOvens
			if nSegmentOven[k] = i then
				add ovenPos[k][1], ovenPos[k][2], 0
				rotz refAngle[nSegmentOven[k]]
				rotx 90
				add 0, ovenHeigth[k], -counterDepth

				material oven_mat
				cutpolya 4, 2, ovenCutDepth,
					-ovenWidth[k]/2+ovenBack, ovenBack,			cutMask2,
					-ovenWidth[k]/2+ovenBack, ovenH-ovenBack,	cutMask2,
					 ovenWidth[k]/2-ovenBack, ovenH-ovenBack,	cutMask2,
					 ovenWidth[k]/2-ovenBack, ovenBack,			cutMask2,
					 0, 0, ovenCutDepth

				nOvenCut = nOvenCut + 1

				addz (counterDepth-ovenThk*2)*1.5+ovenThk
				cutpolya 4, 2, ovenThk,
					-ovenWidth[k]/2, 0,		cutMask2,
					-ovenWidth[k]/2, ovenH,	cutMask2,
					 ovenWidth[k]/2, ovenH,	cutMask2,
					 ovenWidth[k]/2, 0,		cutMask2,
					 0, 0, ovenThk

				nOvenCut = nOvenCut + 1

				del 5
			endif
		next k

		startMask	= 10 + 5 * not(bIsSect[i])
		endMask		= 10 + 5 * not(bIsSect[i+1])

		material gs_cabinet_mat
		addz toeHeigth
		prism_ 5, counterHeigth-toeHeigth-counterThickness,
			refLinePoints[i  ][1], refLinePoints[i  ][2], 15,
			refLinePoints[i+1][1], refLinePoints[i+1][2], endMask,
			oppsidePoints[i+1][1], oppsidePoints[i+1][2], 15,
			oppsidePoints[i  ][1], oppsidePoints[i  ][2], startMask,
			refLinePoints[i  ][1], refLinePoints[i  ][2], -1

		rotz refAngle[i]
		gosub "textureCube"
		del 2

		for k = 1 to nOvenCut
			cutend
		next k
	endif
next i


! ------------------------------------------------------------------------------
! Cutend
! ------------------------------------------------------------------------------
for i =1 to nCut
	cutend
next i


! ------------------------------------------------------------------------------
! Cutting Wall Cabinet
! ------------------------------------------------------------------------------
for i = 1 to nElement
	if elementTypes[i][1] = SYMBTYPE_TALL | elementTypes[i][1] = SYMBTYPE_REFRI | elementTypes[i][1] = SYMBTYPE_COOKTOP then
		add elementXY[i][1], elementXY[i][2], 0
		rotz elementAngle[i]

		widthSymbol		= counterDepth + EPS
		lengthSymbol	= elementSizes[i]

		if elementTypes[i][1] = SYMBTYPE_TALL | (elementTypes[i][1] = SYMBTYPE_REFRI & bRefriWallCabinet) then
			cutpolya 4, 1, 0,
				-lengthSymbol/2, -widthSymbol/2, cutMask,
				-lengthSymbol/2,  widthSymbol/2, cutMask,
				 lengthSymbol/2,  widthSymbol/2, cutMask,
				 lengthSymbol/2, -widthSymbol/2, cutMask

			nWallCut = nWallCut + 1
		else
			if elementTypes[i][1] = SYMBTYPE_REFRI & refrigeratorHeigth > counterHeigth + wallCabinetClearence then
				cutpolya 4, 1, 0,
					-lengthSymbol/2, -widthSymbol/2, cutMask,
					-lengthSymbol/2,  widthSymbol/2, cutMask,
					 lengthSymbol/2,  widthSymbol/2, cutMask,
					 lengthSymbol/2, -widthSymbol/2, cutMask

				nWallCut = nWallCut + 1
			endif

			if elementTypes[i][1] = SYMBTYPE_COOKTOP & bHood then
				hoodSizeX = hoodWidth[elementTypes[i][2]]/2

				if iHoodType = ACC_HOOD_BUILTIN then
					addz counterHeigth + wallCabinetClearence
					cutpolya 4, 1, -0.2,
						-hoodSizeX, -widthSymbol/2, cutMask,
						-hoodSizeX,  widthSymbol/2, cutMask,
						 hoodSizeX,  widthSymbol/2, cutMask,
						 hoodSizeX, -widthSymbol/2, cutMask,
						 0, 0, -0.2
					del 1

					nWallCut = nWallCut + 1
				else
					cutpolya 4, 1, 0,
						-hoodSizeX, -widthSymbol/2, cutMask,
						-hoodSizeX,  widthSymbol/2, cutMask,
						 hoodSizeX,  widthSymbol/2, cutMask,
						 hoodSizeX, -widthSymbol/2, cutMask

					nWallCut = nWallCut + 1
				endif
			endif
		endif

		del 2
	endif
next i


! ------------------------------------------------------------------------------
! Wall Cabinet
! ------------------------------------------------------------------------------
wallCabBottomH	= counterHeigth + wallCabinetClearence
wallCabTopH		= counterHeigth + wallCabinetClearence + wallCabinetHeigth
material wallcab_mat

for i = 1 to nWallCabinet
	unID = 15000 + (i-1) * 100

	hotspot  0,							wallCabinetPos_1[i][2],	wallCabBottomH, unID, wallCabinetPos_1[i][1], 1+128	: unID = unID + 1
	hotspot -1,							wallCabinetPos_1[i][2],	wallCabBottomH, unID, wallCabinetPos_1[i][1], 3		: unID = unID + 1
	hotspot  wallCabinetPos_1[i][1],	wallCabinetPos_1[i][2],	wallCabBottomH, unID, wallCabinetPos_1[i][1], 2		: unID = unID + 1

	hotspot  wallCabinetPos_1[i][1],	0,						wallCabBottomH, unID, wallCabinetPos_1[i][2], 1+128	: unID = unID + 1
	hotspot  wallCabinetPos_1[i][1],	-1,						wallCabBottomH, unID, wallCabinetPos_1[i][2], 3		: unID = unID + 1
	hotspot  wallCabinetPos_1[i][1],	wallCabinetPos_1[i][2],	wallCabBottomH, unID, wallCabinetPos_1[i][2], 2		: unID = unID + 1

	hotspot  0,							wallCabinetPos_2[i][2],	wallCabBottomH, unID, wallCabinetPos_2[i][1], 1+128	: unID = unID + 1
	hotspot -1,							wallCabinetPos_2[i][2],	wallCabBottomH, unID, wallCabinetPos_2[i][1], 3		: unID = unID + 1
	hotspot  wallCabinetPos_2[i][1],	wallCabinetPos_2[i][2],	wallCabBottomH, unID, wallCabinetPos_2[i][1], 2		: unID = unID + 1

	hotspot  wallCabinetPos_2[i][1],	0,						wallCabBottomH, unID, wallCabinetPos_2[i][2], 1+128	: unID = unID + 1
	hotspot  wallCabinetPos_2[i][1],	-1,						wallCabBottomH, unID, wallCabinetPos_2[i][2], 3		: unID = unID + 1
	hotspot  wallCabinetPos_2[i][1],	wallCabinetPos_2[i][2],	wallCabBottomH, unID, wallCabinetPos_2[i][2], 2		: unID = unID + 1


	hotspot  0,							wallCabinetPos_1[i][2],	wallCabTopH, unID, wallCabinetPos_1[i][1], 1+128	: unID = unID + 1
	hotspot -1,							wallCabinetPos_1[i][2],	wallCabTopH, unID, wallCabinetPos_1[i][1], 3		: unID = unID + 1
	hotspot  wallCabinetPos_1[i][1],	wallCabinetPos_1[i][2],	wallCabTopH, unID, wallCabinetPos_1[i][1], 2		: unID = unID + 1

	hotspot  wallCabinetPos_1[i][1],	0,						wallCabTopH, unID, wallCabinetPos_1[i][2], 1+128	: unID = unID + 1
	hotspot  wallCabinetPos_1[i][1],	-1,						wallCabTopH, unID, wallCabinetPos_1[i][2], 3		: unID = unID + 1
	hotspot  wallCabinetPos_1[i][1], 	wallCabinetPos_1[i][2],	wallCabTopH, unID, wallCabinetPos_1[i][2], 2		: unID = unID + 1

	hotspot  0,							wallCabinetPos_2[i][2],	wallCabTopH, unID, wallCabinetPos_2[i][1], 1+128	: unID = unID + 1
	hotspot -1,							wallCabinetPos_2[i][2],	wallCabTopH, unID, wallCabinetPos_2[i][1], 3		: unID = unID + 1
	hotspot  wallCabinetPos_2[i][1],	wallCabinetPos_2[i][2],	wallCabTopH, unID, wallCabinetPos_2[i][1], 2		: unID = unID + 1

	hotspot  wallCabinetPos_2[i][1],	0,						wallCabTopH, unID, wallCabinetPos_2[i][2], 1+128	: unID = unID + 1
	hotspot  wallCabinetPos_2[i][1],	-1,						wallCabTopH, unID, wallCabinetPos_2[i][2], 3		: unID = unID + 1
	hotspot  wallCabinetPos_2[i][1],	wallCabinetPos_2[i][2],	wallCabTopH, unID, wallCabinetPos_2[i][2], 2		: unID = unID + 1


	addz wallCabBottomH
	for j = 1 to nWallContour[i] - 1
		startMask	= 10 + 5 * (j = 1)
		endMask		= 10 + 5 * (j = nWallContour[i] - 1)

		prism_ 5, wallCabinetHeigth,
			wallCoords1[i][j*2-1], wallCoords1[i][j*2], 15,
			wallCoords1[i][j*2+1], wallCoords1[i][j*2+2], endMask,
			wallCoords2[i][j*2+1], wallCoords2[i][j*2+2], 15,
			wallCoords2[i][j*2-1], wallCoords2[i][j*2], startMask,
			wallCoords1[i][j*2-1], wallCoords1[i][j*2], -1

		rotz refAngle[nWallSegment[i][1 + (nWallSegment[i][1] > nWallSegment[i][2])]+j-1]
		gosub "textureCube"
		del 1
	next j
	del 1
next i

! ------------------------------------------------------------------------------
! Cutend
! ------------------------------------------------------------------------------
for i =1 to nWallCut
	cutend
next i


! ------------------------------------------------------------------------------
! Symbols
! ------------------------------------------------------------------------------
for i = 1 to nElement
	add elementXY[i][1], elementXY[i][2], 0
	rotz elementAngle[i]
	widthSymbol		= counterDepth
	lengthSymbol	= elementSizes[i]
	symbolType		= elementTypes[i][1]
	nSymbol			= elementTypes[i][2]
	unID			= 2000 + (elementTypes[i][1]-1) * 1000  +  (elementTypes[i][2]-1) * 100 + 70

	if symbolType = SYMBTYPE_TALL		then gosub "symbolTallCabinet"
	if symbolType = SYMBTYPE_SINK		then gosub "symbolSink"
	if symbolType = SYMBTYPE_COOKTOP	then gosub "symbolCookTop"
	if symbolType = SYMBTYPE_OVEN		then gosub "symbolOven"
	if symbolType = SYMBTYPE_REFRI		then gosub "symbolRefrigerator"
	if symbolType = SYMBTYPE_DISHWASH	then gosub "symbolDishwasher"
	if symbolType = SYMBTYPE_WASH		then gosub "symbolWasher"

	del 2
next i


! ==============================================================================
!
end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
!
! ==============================================================================


! ------------------------------------------------------------------------------
! Draw Symbol
! ------------------------------------------------------------------------------


! ------------------------------------------------------------------------------
"symbolTallCabinet":
! ------------------------------------------------------------------------------

	nOvenCut = 0
	del 2
	for k = 1 to nofOvens
		if nSegmentOven[k] = nSegmentTall[nSymbol] then
			add ovenPos[k][1], ovenPos[k][2], 0
			rotz refAngle[nSegmentOven[k]]
			rotx 90
			add 0, ovenHeigth[k], -counterDepth

			material oven_mat
			cutpolya 4, 2, ovenCutDepth,
				-ovenWidth[k]/2+ovenBack, ovenBack,			cutMask2,
				-ovenWidth[k]/2+ovenBack, ovenH-ovenBack,	cutMask2,
				 ovenWidth[k]/2-ovenBack, ovenH-ovenBack,	cutMask2,
				 ovenWidth[k]/2-ovenBack, ovenBack,			cutMask2,
				 0, 0, ovenCutDepth

			nOvenCut = nOvenCut + 1

			addz (counterDepth-ovenThk*2)*1.5+ovenThk
			cutpolya 4, 2, ovenThk,
				-ovenWidth[k]/2, 0,		cutMask2,
				-ovenWidth[k]/2, ovenH,	cutMask2,
				 ovenWidth[k]/2, ovenH,	cutMask2,
				 ovenWidth[k]/2, 0,		cutMask2,
				 0, 0, ovenThk

			nOvenCut = nOvenCut + 1

			del 5
		endif
	next k

	add elementXY[i][1], elementXY[i][2], 0
	rotz elementAngle[i]

	material gs_base_mat
	prism_ 5, toeHeigth,
		-lengthSymbol/2, -widthSymbol/2+toeBack, 15,
		-lengthSymbol/2,  widthSymbol/2, 15,
		 lengthSymbol/2,  widthSymbol/2, 15,
		 lengthSymbol/2, -widthSymbol/2+toeBack, 15,
		-lengthSymbol/2, -widthSymbol/2+toeBack, -1
	gosub "textureCube"

	material gs_cabinet_mat
	addz toeHeigth
	prism_ 5, counterHeigth+wallCabinetHeigth+wallCabinetClearence-toeHeigth,
		-lengthSymbol/2, -widthSymbol/2, 15,
		-lengthSymbol/2,  widthSymbol/2, 15,
		 lengthSymbol/2,  widthSymbol/2, 15,
		 lengthSymbol/2, -widthSymbol/2, 15,
		-lengthSymbol/2, -widthSymbol/2, -1

	gosub "textureCube"
	del 1

	for k =1 to nOvenCut
		cutend
	next k
return


! ------------------------------------------------------------------------------
"symbolSink":
! ------------------------------------------------------------------------------

	if iSinkType = ACC_SINK_ROUND then
		lengthSymbol = min (lengthSymbol, widthSymbol)
		add -lengthSymbol/2*(1-2*bMirroredSink), -widthSymbol/2, counterHeigth-sinkDepth
		sinkMinus = 0
	else
		if counterDepth < minSinkCounter then
			sinkOffsetY	= 0
			sinkMinus	= 0
		else
			sinkOffsetY = 0.07
			sinkMinus	= 0.1
		endif
		add -lengthSymbol/2*(1-2*bMirroredSink), -widthSymbol/2 + sinkOffsetY, counterHeigth-sinkDepth
	endif
	mulx 1-2*bMirroredSink
	call "fa_sinktyp"  parameters	a	= lengthSymbol,
									b	= widthSymbol-sinkMinus,
								zzyzx	= sinkDepth,
					gs_sink_type_m		= gs_sink_type_m,
					SinkSymbol_m		= 1,
					sunder				= 0,
					TapSymbol_m			= 0,
					gs_cont_pen			= gs_cont_pen,
					gs_detlevel_3D_m	= 2,
					gs_sink_mat			= sink_mat,
					gs_shadow			= gs_shadow,
					gs_resol			= gs_resol,
					gs_tap_type_m		= 0,
					tapOffset			= 0,
					bShowHotspots		= 0
	del 2
return


! ------------------------------------------------------------------------------
"symbolCookTop":
! ------------------------------------------------------------------------------

	add 0, widthSymbol/2, counterHeigth
	call "fa_CooktopType" parameters	a	= lengthSymbol,
										aa	= lengthSymbol,
										b	= widthSymbol,
										bb	= widthSymbol - 0.1,
						CooktopType_m		= CooktopType_m,
						gs_hotspotUnIdBegin = unID,
						gs_cont_pen			= gs_cont_pen,
						gs_detlevel_3D_m	= 1,
						gs_shadow			= gs_shadow,
						gs_resol			= gs_resol,
						matarc				= hotplate_mat,
						bmat				= cooktop_mat,
						bShowHotspots		= 0
	del 1

	if bHood then gosub "symbolHood"
return


! ------------------------------------------------------------------------------
"symbolHood":
! ------------------------------------------------------------------------------

	hoodSizeX = hoodWidth[nSymbol]/2
	hoodSizeY = 0.85 * counterDepth
	hoodSizeZ = hoodHeigth - counterHeigth - wallCabinetClearence
	hoodChimneyX	= 0.14
	hoodChimneyY1	= counterDepth/2 - 0.15
	hoodChimneyY2	= counterDepth/2
	hoodOffsetY		= 0.05

	if iHoodType = ACC_HOOD_WALL then
		hotspot 0,	widthSymbol/2,	 0,			unID, hoodHeigth, 1+128		: unID = unID + 1
		hotspot 0,	widthSymbol/2,	-1,			unID, hoodHeigth, 3			: unID = unID + 1
		hotspot 0,	widthSymbol/2,	hoodHeigth, unID, hoodHeigth, 2			: unID = unID + 1
	endif

	if iHoodType = ACC_HOOD_HANGING then
		hotspot 0,	hoodOffsetY,	 0,			unID, hoodHeigth, 1+128		: unID = unID + 1
		hotspot 0,	hoodOffsetY,	-1,			unID, hoodHeigth, 3			: unID = unID + 1
		hotspot 0,	hoodOffsetY,	hoodHeigth, unID, hoodHeigth, 2			: unID = unID + 1
	endif

	material hood_mat
	addz counterHeigth + wallCabinetClearence

	if iHoodType = ACC_HOOD_WALL then
		addz 0.04
		ruled 4 , 2+4+14+32,
			 hoodSizeX-0.04,	counterDepth/2 - hoodSizeY + 0.04,	0,
			-hoodSizeX+0.04,	counterDepth/2 - hoodSizeY + 0.04,	0,
			-hoodSizeX+0.04,	hoodChimneyY2,	0,
			 hoodSizeX-0.04,	hoodChimneyY2,	0,

			 hoodChimneyX,		hoodChimneyY1,	0.24,
			-hoodChimneyX,		hoodChimneyY1,	0.24,
			-hoodChimneyX,		hoodChimneyY2,	0.24,
			 hoodChimneyX,		hoodChimneyY2,	0.24
		gosub "textureCube"

		addz 0.24
		prism_      5,  hoodSizeZ-0.28,
			-hoodChimneyX,	hoodChimneyY1,	15,
			 hoodChimneyX,	hoodChimneyY1,	15,
			 hoodChimneyX,	hoodChimneyY2,	15,
			-hoodChimneyX,	hoodChimneyY2,	15,
			-hoodChimneyX,	hoodChimneyY1,	-1
		gosub "textureCube"
		del 2

		prism_      5,      0.04,
			 hoodSizeX,	counterDepth/2 - hoodSizeY,		15,
			 hoodSizeX,	counterDepth/2,  				15,
			-hoodSizeX,	counterDepth/2,  				15,
			-hoodSizeX,	counterDepth/2 - hoodSizeY,		15,
			 hoodSizeX,	counterDepth/2 - hoodSizeY,		-1
		gosub "textureCube"
	endif

	if iHoodType = ACC_HOOD_HANGING then
		addz 0.04
		prism_      5,  hoodSizeZ-0.04,
			-hoodChimneyX,	-0.125+hoodOffsetY,	15,
			 hoodChimneyX,	-0.125+hoodOffsetY,	15,
			 hoodChimneyX,	 0.125+hoodOffsetY,	15,
			-hoodChimneyX,	 0.125+hoodOffsetY,	15,
			-hoodChimneyX,	-0.125+hoodOffsetY,	-1
		gosub "textureCube"
		del 1

		prism_      5,      0.04,
			 hoodSizeX,	counterDepth/2 - hoodSizeY,		15,
			 hoodSizeX,	counterDepth/2,  				15,
			-hoodSizeX,	counterDepth/2,  				15,
			-hoodSizeX,	counterDepth/2 - hoodSizeY,		15,
			 hoodSizeX,	counterDepth/2 - hoodSizeY,		-1
		gosub "textureCube"
	endif

	if iHoodType = ACC_HOOD_BUILTIN then
		rotx 90
		roty 90
		addz -hoodSizeX
		prism_ 7, hoodSizeX*2,
			counterDepth/2 - hoodSizeY, 0.0675, 15,
			counterDepth/2 - hoodSizeY, 0.2-0.0675, 15,
			counterDepth/2 - hoodSizeY + 0.15, 0.2, 15,
			counterDepth/2, 0.2, 15,
			counterDepth/2, 0, 15,
			counterDepth/2 - hoodSizeY + 0.15, 0, 15,
			counterDepth/2 - hoodSizeY, 0.0675, -1
		del 3

		gosub "textureCube"
	endif

	del 1
return


! ------------------------------------------------------------------------------
"symbolOven":
! ------------------------------------------------------------------------------

	add -lengthSymbol/2,-counterDepth/2, ovenHeigth[nSymbol]
	call "fa_MicOvenDoor" parameters	A		= lengthSymbol,
										B		= ovenThk,
										ZZYZX	= ovenH,
							ApplType_m			= 2,
							ApplStyle_m			= 1,
							gs_detlevel_3D_m	= 1,
							gs_shadow			= gs_shadow,
							PanelMat			= oven_mat,
							BaseMat				= oven_mat,
							HandleMat			= oven_mat,
							SwitchMat			= oven_mat,
							GlassMat			= glass_mat

	material  oven_mat
	addz ovenBack
	prism_ 5, ovenH-2*ovenBack,
		ovenBack, 				ovenThk,							7,
		lengthSymbol-ovenBack,	ovenThk,							15,
		lengthSymbol-ovenBack,	ovenCutDepth+counterDepth/2*0.6,	15,
		ovenBack,				ovenCutDepth+counterDepth/2*0.6,	15,
		ovenBack,				ovenThk,							-1

	del 2
return


! ------------------------------------------------------------------------------
"symbolRefrigerator":
! ------------------------------------------------------------------------------

	widthSymbol = refrigeratorDepth
	add 0, -widthSymbol/2 + counterDepth/2, 0

	if iRefrigeratorType <> ACC_REFRI_COMPACT then
		hotspot -lengthSymbol/2,	-widthSymbol/2,	 0,					unID, refrigeratorHeigth, 1+128		: unID = unID + 1
		hotspot -lengthSymbol/2,	-widthSymbol/2,	-1,					unID, refrigeratorHeigth, 3			: unID = unID + 1
		hotspot -lengthSymbol/2,	-widthSymbol/2,	refrigeratorHeigth, unID, refrigeratorHeigth, 2			: unID = unID + 1

		hotspot  lengthSymbol/2,	-widthSymbol/2,	 0,					unID, refrigeratorHeigth, 1+128		: unID = unID + 1
		hotspot  lengthSymbol/2,	-widthSymbol/2,	-1,					unID, refrigeratorHeigth, 3			: unID = unID + 1
		hotspot  lengthSymbol/2,	-widthSymbol/2,	refrigeratorHeigth, unID, refrigeratorHeigth, 2			: unID = unID + 1
	endif

	! Toe
	material gs_base_mat
	prism_ 5, toeHeigth,
		-lengthSymbol/2, -widthSymbol/2+refriDoorThk, 15,
		-lengthSymbol/2, -widthSymbol/2+toeBack, 15,
		 lengthSymbol/2, -widthSymbol/2+toeBack, 15,
		 lengthSymbol/2, -widthSymbol/2+refriDoorThk, 15,
		-lengthSymbol/2, -widthSymbol/2+refriDoorThk, -1
	gosub "textureCube"

	!Base
	material refrigerator_mat
	prism_ 5, refrigeratorHeigth,
		-lengthSymbol/2, -widthSymbol/2+refriDoorThk, 15,
		-lengthSymbol/2,  widthSymbol/2, 15,
		 lengthSymbol/2,  widthSymbol/2, 15,
		 lengthSymbol/2, -widthSymbol/2+refriDoorThk, 15,
		-lengthSymbol/2, -widthSymbol/2+refriDoorThk, -1
	gosub "textureCube"

	if refrigeratorHeigth < refriFreezeH *2 then refriFreezeH = 0

	!Doors
	if iRefrigeratorType = ACC_REFRI_TOP then
		addz toeHeigth

		prism_ 5, refrigeratorHeigth-toeHeigth-refriFreezeH-0.0025*(refrigeratorHeigth > EPS),
			-lengthSymbol/2,	-widthSymbol/2+refriDoorThk+EPS, 15,
			-lengthSymbol/2,	-widthSymbol/2, 15,
			 lengthSymbol/2,	-widthSymbol/2, 15,
			 lengthSymbol/2,	-widthSymbol/2+refriDoorThk+EPS, 15,
			-lengthSymbol/2,	-widthSymbol/2+refriDoorThk+EPS, -1
		gosub "textureCube"

		if refriFreezeH > EPS then
			addz refrigeratorHeigth-toeHeigth-refriFreezeH+0.0025
			prism_ 5, refriFreezeH-0.0025,
				-lengthSymbol/2,	-widthSymbol/2+refriDoorThk+EPS, 15,
				-lengthSymbol/2,	-widthSymbol/2, 15,
				 lengthSymbol/2,	-widthSymbol/2, 15,
				 lengthSymbol/2,	-widthSymbol/2+refriDoorThk+EPS, 15,
				-lengthSymbol/2,	-widthSymbol/2+refriDoorThk+EPS, -1
			gosub "textureCube"
			del 1
		endif

		del 1
	endif

	if iRefrigeratorType = ACC_REFRI_BOTTOM then
		addz toeHeigth

		addz refriFreezeH + 0.0025*(refrigeratorHeigth > EPS)
		prism_ 5, refrigeratorHeigth-toeHeigth-refriFreezeH-0.0025*(refrigeratorHeigth > EPS),
			-lengthSymbol/2,	-widthSymbol/2+refriDoorThk+EPS, 15,
			-lengthSymbol/2,	-widthSymbol/2, 15,
			 lengthSymbol/2,	-widthSymbol/2, 15,
			 lengthSymbol/2,	-widthSymbol/2+refriDoorThk+EPS, 15,
			-lengthSymbol/2,	-widthSymbol/2+refriDoorThk+EPS, -1
		gosub "textureCube"
		del 1

		if refriFreezeH > EPS then
			prism_ 5, refriFreezeH-0.0025,
				-lengthSymbol/2,	-widthSymbol/2+refriDoorThk+EPS, 15,
				-lengthSymbol/2,	-widthSymbol/2, 15,
				 lengthSymbol/2,	-widthSymbol/2, 15,
				 lengthSymbol/2,	-widthSymbol/2+refriDoorThk+EPS, 15,
				-lengthSymbol/2,	-widthSymbol/2+refriDoorThk+EPS, -1
			gosub "textureCube"
		endif

		del 1
	endif

	if iRefrigeratorType = ACC_REFRI_SIDE then
		addz toeHeigth
		doorW = lengthSymbol / refriDoorW

		prism_ 5, refrigeratorHeigth-toeHeigth,
			-lengthSymbol/2,				-widthSymbol/2+refriDoorThk+EPS, 15,
			-lengthSymbol/2,				-widthSymbol/2, 15,
			-lengthSymbol/2+doorW-0.0025,	-widthSymbol/2, 15,
			-lengthSymbol/2+doorW-0.0025,	-widthSymbol/2+refriDoorThk+EPS, 15,
			-lengthSymbol/2,				-widthSymbol/2+refriDoorThk+EPS, -1
		gosub "textureCube"

		prism_ 5, refrigeratorHeigth-toeHeigth,
			 lengthSymbol/2,								-widthSymbol/2+refriDoorThk+EPS, 15,
			 lengthSymbol/2,								-widthSymbol/2, 15,
			 lengthSymbol/2-(lengthSymbol-doorW-0.0025),	-widthSymbol/2, 15,
			 lengthSymbol/2-(lengthSymbol-doorW-0.0025),	-widthSymbol/2+refriDoorThk+EPS, 15,
			 lengthSymbol/2,								-widthSymbol/2+refriDoorThk+EPS, -1
		gosub "textureCube"

		del 1
	endif

	if iRefrigeratorType = ACC_REFRI_FRENCH then
		addz toeHeigth

		addz refriFreezeH + 0.0025*(refrigeratorHeigth > EPS)

		prism_ 5, refrigeratorHeigth-toeHeigth-refriFreezeH-0.0025*(refrigeratorHeigth > EPS),
			-lengthSymbol/2,	-widthSymbol/2+refriDoorThk+EPS, 15,
			-lengthSymbol/2,	-widthSymbol/2, 15,
			-0.0025,			-widthSymbol/2, 15,
			-0.0025,			-widthSymbol/2+refriDoorThk+EPS, 15,
			-lengthSymbol/2,	-widthSymbol/2+refriDoorThk+EPS, -1
		gosub "textureCube"

		prism_ 5, refrigeratorHeigth-toeHeigth-refriFreezeH-0.0025*(refrigeratorHeigth > EPS),
			 lengthSymbol/2,	-widthSymbol/2+refriDoorThk+EPS, 15,
			 lengthSymbol/2,	-widthSymbol/2, 15,
			 0.0025,			-widthSymbol/2, 15,
			 0.0025,			-widthSymbol/2+refriDoorThk+EPS, 15,
			 lengthSymbol/2,	-widthSymbol/2+refriDoorThk+EPS, -1
		gosub "textureCube"

		del 1

		if refrigeratorHeigth > EPS then
			prism_ 5, refriFreezeH-0.0025,
				-lengthSymbol/2,	-widthSymbol/2+refriDoorThk+EPS, 15,
				-lengthSymbol/2,	-widthSymbol/2, 15,
				 lengthSymbol/2,	-widthSymbol/2, 15,
				 lengthSymbol/2,	-widthSymbol/2+refriDoorThk+EPS, 15,
				-lengthSymbol/2,	-widthSymbol/2+refriDoorThk+EPS, -1
			gosub "textureCube"
		endif

		del 1
	endif

	if iRefrigeratorType = ACC_REFRI_COMPACT then
		addz toeHeigth
		prism_ 5, refrigeratorHeigth-toeHeigth,
			-lengthSymbol/2,	-widthSymbol/2+refriDoorThk+EPS, 15,
			-lengthSymbol/2,	-widthSymbol/2, 15,
			 lengthSymbol/2,	-widthSymbol/2, 15,
			 lengthSymbol/2,	-widthSymbol/2+refriDoorThk+EPS, 15,
			-lengthSymbol/2,	-widthSymbol/2+refriDoorThk+EPS, -1
		gosub "textureCube"
		del 1
	endif

	del 1

	if bRefriWallCabinet then
		if counterHeigth+wallCabinetHeigth+wallCabinetClearence-refrigeratorHeigth > EPS then
			addz refrigeratorHeigth
			material gs_cabinet_mat
			prism_ 5, counterHeigth+wallCabinetHeigth+wallCabinetClearence-refrigeratorHeigth,
				-lengthSymbol/2, -counterDepth/2, 15,
				-lengthSymbol/2,  counterDepth/2, 15,
				 lengthSymbol/2,  counterDepth/2, 15,
				 lengthSymbol/2, -counterDepth/2, 15,
				-lengthSymbol/2, -counterDepth/2, -1
			gosub "textureCube"
			del 1
		endif
	endif
return


! ------------------------------------------------------------------------------
"symbolDishwasher":
! ------------------------------------------------------------------------------

	material gs_base_mat
	prism_ 5, toeHeigth,
		-lengthSymbol/2, -widthSymbol/2+toeBack, 15,
		-lengthSymbol/2,  widthSymbol/2, 15,
		 lengthSymbol/2,  widthSymbol/2, 15,
		 lengthSymbol/2, -widthSymbol/2+toeBack, 15,
		-lengthSymbol/2, -widthSymbol/2+toeBack, -1
	gosub "textureCube"

	material dishwasher_mat
	addz toeHeigth
	prism_ 5, counterHeigth-toeHeigth-counterThickness,
		-lengthSymbol/2, -widthSymbol/2, 15,
		-lengthSymbol/2,  widthSymbol/2, 15,
		 lengthSymbol/2,  widthSymbol/2, 15,
		 lengthSymbol/2, -widthSymbol/2, 15,
		-lengthSymbol/2, -widthSymbol/2, -1

	gosub "textureCube"
	del 1
return


! ------------------------------------------------------------------------------
"symbolWasher":
! ------------------------------------------------------------------------------

	material washer_mat
	prism_ 5, toeHeigth,
		-lengthSymbol/2, -widthSymbol/2+toeBack, 15,
		-lengthSymbol/2,  widthSymbol/2, 15,
		 lengthSymbol/2,  widthSymbol/2, 15,
		 lengthSymbol/2, -widthSymbol/2+toeBack, 15,
		-lengthSymbol/2, -widthSymbol/2+toeBack, -1
	gosub "textureCube"

	material washer_mat
	addz toeHeigth
	prism_ 5, counterHeigth-toeHeigth-counterThickness,
		-lengthSymbol/2, -widthSymbol/2+washerBack, 15,
		-lengthSymbol/2,  widthSymbol/2, 15,
		 lengthSymbol/2,  widthSymbol/2, 15,
		 lengthSymbol/2, -widthSymbol/2+washerBack, 15,
		-lengthSymbol/2, -widthSymbol/2+washerBack, -1

	gosub "textureCube"
	del 1

	rotx 90
	addz counterDepth/2 - washerBack

	prism_ 5, washerBack,
		-lengthSymbol/2, counterHeigth-counterThickness-washerDist, 15,
		 lengthSymbol/2, counterHeigth-counterThickness-washerDist, 15,
		 lengthSymbol/2, counterHeigth-counterThickness-washerDist-washerPanelH, 15,
		-lengthSymbol/2, counterHeigth-counterThickness-washerDist-washerPanelH, 15,
		-lengthSymbol/2, counterHeigth-counterThickness-washerDist, -1

	gosub "textureCube"

	cutpolya 2, 1, 0,
		0, (counterHeigth-counterThickness-2*washerDist-washerPanelH - toeHeigth) / 2 + toeHeigth, 979,
		0.17, 360, 4079

	prism_ 5, washerBack,
		-lengthSymbol/2, toeHeigth, 15,
		 lengthSymbol/2, toeHeigth, 15,
		 lengthSymbol/2, counterHeigth-counterThickness-2*washerDist-washerPanelH, 15,
		-lengthSymbol/2, counterHeigth-counterThickness-2*washerDist-washerPanelH, 15,
		-lengthSymbol/2, toeHeigth, -1

	gosub "textureCube"

	cutend

	del 2
return


! ------------------------------------------------------------------------------
! Textures
! ------------------------------------------------------------------------------
"textureCube":
	roty 90

	base
	vert 0, 0, 0
	vert 1, 0, 0
	vert 0, 1, 0
	vert 0, 0, 1
	coor 2 + 256, -1, -2, -3, -4
	body -1

	del 1
return
]]>
</Script_3D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_2D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
pen gs_cont_pen
fill gs_fill_type
drawindex 7
angleViewRot = 0
if displayText then
	rrr = REQUEST ("View_Rotangle", "", angleViewRot)
	define style textstyle	fontType, fontSize * 1000 / GLOB_SCALE, 5, gs_text_style_bold + 2 * gs_text_style_italic + 4 * gs_text_style_underline + 128 * gs_text_style_strike
	style textstyle
endif


! ------------------------------------------------------------------------------
! Definitions
! ------------------------------------------------------------------------------
refriSymbSize = 0.1
if iRefrigeratorType = ACC_REFRI_COMPACT then
	refrigeratorDepth	= refriDefaults[ACC_REFRI_COMPACT]
	bRefriWallCabinet	= 0
endif
bPolyOperations = 0
if nofRefrigerators > 0 & refrigeratorDepth > counterDepth then bPolyOperations = 1


! ------------------------------------------------------------------------------
! Reference Line
! ------------------------------------------------------------------------------
unID = 100
for i = 1 to nRefPoints[1] - (iLayoutType = LAYOUT_ISLAND)*2
	hotspot2  0,					refLinePoints_1[i][2],	unID, refLinePoints_1[i][1], 1+128		: unID = unID + 1
	hotspot2 -1, 					refLinePoints_1[i][2],	unID, refLinePoints_1[i][1], 3			: unID = unID + 1
	hotspot2 refLinePoints_1[i][1],	refLinePoints_1[i][2],	unID, refLinePoints_1[i][1], 2			: unID = unID + 1

	hotspot2 refLinePoints_1[i][1],	0,					 	unID, refLinePoints_1[i][2], 1+128		: unID = unID + 1
	hotspot2 refLinePoints_1[i][1], -1,						unID, refLinePoints_1[i][2], 3			: unID = unID + 1
	hotspot2 refLinePoints_1[i][1],	refLinePoints_1[i][2],	unID, refLinePoints_1[i][2], 2			: unID = unID + 1
next i

for i = 1 to nRefPoints[2]
	hotspot2  0,					refLinePoints_2[i][2],	unID, refLinePoints_2[i][1], 1+128		: unID = unID + 1
	hotspot2 -1, 					refLinePoints_2[i][2],	unID, refLinePoints_2[i][1], 3			: unID = unID + 1
	hotspot2 refLinePoints_2[i][1],	refLinePoints_2[i][2],	unID, refLinePoints_2[i][1], 2			: unID = unID + 1

	hotspot2 refLinePoints_2[i][1],	0,					 	unID, refLinePoints_2[i][2], 1+128		: unID = unID + 1
	hotspot2 refLinePoints_2[i][1], -1,						unID, refLinePoints_2[i][2], 3			: unID = unID + 1
	hotspot2 refLinePoints_2[i][1],	refLinePoints_2[i][2],	unID, refLinePoints_2[i][2], 2			: unID = unID + 1
next i

for i = 1 to nRefPoints[3]
	hotspot2  0,					refLinePoints_3[i][2],	unID, refLinePoints_3[i][1], 1+128		: unID = unID + 1
	hotspot2 -1, 					refLinePoints_3[i][2],	unID, refLinePoints_3[i][1], 3			: unID = unID + 1
	hotspot2 refLinePoints_3[i][1],	refLinePoints_3[i][2],	unID, refLinePoints_3[i][1], 2			: unID = unID + 1

	hotspot2 refLinePoints_3[i][1],	0,					 	unID, refLinePoints_3[i][2], 1+128		: unID = unID + 1
	hotspot2 refLinePoints_3[i][1], -1,						unID, refLinePoints_3[i][2], 3			: unID = unID + 1
	hotspot2 refLinePoints_3[i][1],	refLinePoints_3[i][2],	unID, refLinePoints_3[i][2], 2			: unID = unID + 1
next i


! ------------------------------------------------------------------------------
! Other Contour Points
! ------------------------------------------------------------------------------
unID = 1500
for i = 1 to vardim1(oppsidePoints)
	hotspot2 oppsidePoints[i][1], oppsidePoints[i][2], unID		: unID = unID + 1
next i


! ------------------------------------------------------------------------------
! Counter Fills
! ------------------------------------------------------------------------------
if bPolyOperations then
	ch = INITADDONSCOPE ("PolyOperations", "", "")

	nDestContainer = 1
	prevSourceContainer	= "mySourceContainer"
	lastDestContainer	= "myDestinationContainer" + STR(nDestContainer,1,0)

	PREPAREFUNCTION ch, "CreateContainer", prevSourceContainer, ""
	PREPAREFUNCTION ch, "CreateContainer", lastDestContainer, ""

	PREPAREFUNCTION ch, "SetSourceContainer",		prevSourceContainer, ""
	PREPAREFUNCTION ch, "SetDestinationContainer",	lastDestContainer, ""

	! Contours
	for i = 1 to nPoly

		hotline2 contourPoints[i][nContour[i]*2-1], contourPoints[i][nContour[i]*2], contourPoints[i][1], contourPoints[i][2]

		dim vertArr[][]
		dim contArr[]

		nVertices	= nContour[i]
		contArr[1]	= nContour[i] + 1
		nCont		= 1

		for j = nContour[i] to 1 step -1
			if j < nContour[i] then hotline2 contourPoints[i][j*2-1], contourPoints[i][j*2], contourPoints[i][j*2+1], contourPoints[i][j*2+2]

			vertArr[j][3] = 0.0
			vertArr[j][1] = contourPoints[i][j*2-1]
			vertArr[j][2] = contourPoints[i][j*2]
		next j

		PREPAREFUNCTION ch, "Store", "segmentPoly", nVertices, nCont, vertArr, contArr

		! Refrigerator
		for r = 1 to nofRefrigerators
			dim contourNames[]
			numContour = CALLFUNCTION (ch, "GetSourcePolygons", "", contourNames)

			dim vertArr[4][3]
			dim contArr[]

			nVertices	= 4
			contArr[1]	= 5
			nCont		= 1

			tx1 = cos(elementAngle[isRefri[r]]) * refrigeratorWidth[r]/2
			ty1 = sin(elementAngle[isRefri[r]]) * refrigeratorWidth[r]/2

			tx2 = sin(elementAngle[isRefri[r]]) * (refrigeratorDepth-counterDepth/2)
			ty2 = cos(elementAngle[isRefri[r]]) * (refrigeratorDepth-counterDepth/2)

			tx3 = sin(elementAngle[isRefri[r]]) * (-counterDepth/2)
			ty3 = cos(elementAngle[isRefri[r]]) * (-counterDepth/2)

			vertArr[1][1] = refrigeratorPos[r][1] + tx1 + tx2
			vertArr[1][2] = refrigeratorPos[r][2] + ty1 - ty2
			vertArr[1][3] = 0.0
			vertArr[2][1] = refrigeratorPos[r][1] - tx1 + tx2
			vertArr[2][2] = refrigeratorPos[r][2] - ty1 - ty2
			vertArr[2][3] = 0.0
			vertArr[3][1] = refrigeratorPos[r][1] - tx1 + tx3
			vertArr[3][2] = refrigeratorPos[r][2] - ty1 - ty3
			vertArr[3][3] = 0.0
			vertArr[4][1] = refrigeratorPos[r][1] + tx1 + tx3
			vertArr[4][2] = refrigeratorPos[r][2] + ty1 - ty3
			vertArr[4][3] = 0.0

			holeName = "refri"+STR(r,1,0)

			PREPAREFUNCTION ch, "Store", holeName, nVertices, nCont, vertArr, contArr

			dim tempResPolyIDArr[]
			for nC = 1 TO numContour
				tempNumPoly = CALLFUNCTION(ch, contourNames[nC] + " - " + holeName, "", tempResPolyIDArr)
			next nC

			if r < nofRefrigerators then
				if prevSourceContainer <> "" then
					PREPAREFUNCTION ch, "DeleteContainer",		prevSourceContainer, ""
				endif
				PREPAREFUNCTION ch, "SetSourceContainer",		lastDestContainer, ""
				prevSourceContainer	= lastDestContainer
				nDestContainer = nDestContainer + 1
				lastDestContainer = "myDestinationContainer" + STR(nDestContainer,1,0)
				PREPAREFUNCTION ch, "CreateContainer",			lastDestContainer, ""
				PREPAREFUNCTION ch, "SetDestinationContainer",	lastDestContainer, ""
			endif

		next r

		dim resPolyIDArr[]
		numPoly = CALLFUNCTION(ch, "GetDestinationPolygons", "", resPolyIDArr)
		for cP = 1 to numPoly
			polygonID = resPolyIDArr[cP]
			mask = 1
			gosub "getGDLpolygonFromAPI"
			if nsp > 11 then
				poly2_b nsp/3, 1+2+4+64, gs_fill_pen, gs_back_pen, get(nsp)
			else
				for k = 1 to nsp
					temp = get(1)
				next k
			endif
		next cP

		PREPAREFUNCTION ch, "EmptyContainer",		prevSourceContainer, ""
		PREPAREFUNCTION ch, "EmptyContainer",		lastDestContainer, ""

	next i

else

	for i = 1 to nPoly
		hotline2 contourPoints[i][nContour[i]*2-1], contourPoints[i][nContour[i]*2], contourPoints[i][1], contourPoints[i][2]
		for j = 1 to nContour[i]
			put contourPoints[i][j*2-1], contourPoints[i][j*2], 1
			if j < nContour[i] then hotline2 contourPoints[i][j*2-1], contourPoints[i][j*2], contourPoints[i][j*2+1], contourPoints[i][j*2+2]
		next j
		poly2_b nsp/3, 1+2+4+64, gs_fill_pen, gs_back_pen, get(nsp)
	next i

endif


! ------------------------------------------------------------------------------
! Elements Moveable Hotspots
! ------------------------------------------------------------------------------
for i = 1 to nElement
	n = elementTypes[i][2]
	unID = 2000 + (elementTypes[i][1]-1) * 1000  +  (n-1) * 100

	if elementTypes[i][1] = SYMBTYPE_TALL then
		hotspot2  0,				tallCabPos[n][2],	unID, tallCabPos[n][1], 1+128	: unID = unID + 1
		hotspot2 -1,				tallCabPos[n][2],	unID, tallCabPos[n][1], 3		: unID = unID + 1
		hotspot2 tallCabPos[n][1],	tallCabPos[n][2],	unID, tallCabPos[n][1], 2		: unID = unID + 1

		hotspot2 tallCabPos[n][1],	 0,					unID, tallCabPos[n][2], 1+128	: unID = unID + 1
		hotspot2 tallCabPos[n][1],	-1,					unID, tallCabPos[n][2], 3		: unID = unID + 1
		hotspot2 tallCabPos[n][1],	tallCabPos[n][2],	unID, tallCabPos[n][2], 2		: unID = unID + 1
	endif

	if elementTypes[i][1] = SYMBTYPE_SINK then
		hotspot2  0,			sinkPos[n][2],	unID, sinkPos[n][1], 1+128		: unID = unID + 1
		hotspot2 -1,			sinkPos[n][2],	unID, sinkPos[n][1], 3			: unID = unID + 1
		hotspot2 sinkPos[n][1],	sinkPos[n][2],	unID, sinkPos[n][1], 2			: unID = unID + 1

		hotspot2 sinkPos[n][1],	 0,				unID, sinkPos[n][2], 1+128		: unID = unID + 1
		hotspot2 sinkPos[n][1],	-1,				unID, sinkPos[n][2], 3			: unID = unID + 1
		hotspot2 sinkPos[n][1],	sinkPos[n][2],	unID, sinkPos[n][2], 2			: unID = unID + 1
	endif

	if elementTypes[i][1] = SYMBTYPE_COOKTOP then
		hotspot2  0,				cooktopPos[n][2],	unID, cooktopPos[n][1], 1+128		: unID = unID + 1
		hotspot2 -1,				cooktopPos[n][2],	unID, cooktopPos[n][1], 3			: unID = unID + 1
		hotspot2 cooktopPos[n][1],	cooktopPos[n][2],	unID, cooktopPos[n][1], 2			: unID = unID + 1

		hotspot2 cooktopPos[n][1],	 0,					unID, cooktopPos[n][2], 1+128		: unID = unID + 1
		hotspot2 cooktopPos[n][1],	-1,					unID, cooktopPos[n][2], 3			: unID = unID + 1
		hotspot2 cooktopPos[n][1],	cooktopPos[n][2],	unID, cooktopPos[n][2], 2			: unID = unID + 1
	endif

	if elementTypes[i][1] = SYMBTYPE_OVEN then
		hotspot2  0,			ovenPos[n][2],	unID, ovenPos[n][1], 1+128		: unID = unID + 1
		hotspot2 -1,			ovenPos[n][2],	unID, ovenPos[n][1], 3			: unID = unID + 1
		hotspot2 ovenPos[n][1],	ovenPos[n][2],	unID, ovenPos[n][1], 2			: unID = unID + 1

		hotspot2 ovenPos[n][1],	 0,				unID, ovenPos[n][2], 1+128		: unID = unID + 1
		hotspot2 ovenPos[n][1],	-1,				unID, ovenPos[n][2], 3			: unID = unID + 1
		hotspot2 ovenPos[n][1],	ovenPos[n][2],	unID, ovenPos[n][2], 2			: unID = unID + 1
	endif

	if elementTypes[i][1] = SYMBTYPE_REFRI then
		hotspot2  0,					refrigeratorPos[n][2],	unID, refrigeratorPos[n][1], 1+128		: unID = unID + 1
		hotspot2 -1,					refrigeratorPos[n][2],	unID, refrigeratorPos[n][1], 3			: unID = unID + 1
		hotspot2 refrigeratorPos[n][1],	refrigeratorPos[n][2],	unID, refrigeratorPos[n][1], 2			: unID = unID + 1

		hotspot2 refrigeratorPos[n][1],	 0,						unID, refrigeratorPos[n][2], 1+128		: unID = unID + 1
		hotspot2 refrigeratorPos[n][1],	-1,						unID, refrigeratorPos[n][2], 3			: unID = unID + 1
		hotspot2 refrigeratorPos[n][1],	refrigeratorPos[n][2],	unID, refrigeratorPos[n][2], 2			: unID = unID + 1
	endif

	if elementTypes[i][1] = SYMBTYPE_DISHWASH then
		hotspot2  0,					dishwasherPos[n][2],	unID, dishwasherPos[n][1], 1+128	: unID = unID + 1
		hotspot2 -1,					dishwasherPos[n][2],	unID, dishwasherPos[n][1], 3		: unID = unID + 1
		hotspot2 dishwasherPos[n][1],	dishwasherPos[n][2],	unID, dishwasherPos[n][1], 2		: unID = unID + 1

		hotspot2 dishwasherPos[n][1],	 0,						unID, dishwasherPos[n][2], 1+128	: unID = unID + 1
		hotspot2 dishwasherPos[n][1],	-1,						unID, dishwasherPos[n][2], 3		: unID = unID + 1
		hotspot2 dishwasherPos[n][1],	dishwasherPos[n][2],	unID, dishwasherPos[n][2], 2		: unID = unID + 1
	endif

	if elementTypes[i][1] = SYMBTYPE_WASH then
		hotspot2  0,				washerPos[n][2],	unID, washerPos[n][1], 1+128	: unID = unID + 1
		hotspot2 -1,				washerPos[n][2],	unID, washerPos[n][1], 3		: unID = unID + 1
		hotspot2 washerPos[n][1],	washerPos[n][2],	unID, washerPos[n][1], 2		: unID = unID + 1

		hotspot2 washerPos[n][1],	 0,					unID, washerPos[n][2], 1+128	: unID = unID + 1
		hotspot2 washerPos[n][1],	-1,					unID, washerPos[n][2], 3		: unID = unID + 1
		hotspot2 washerPos[n][1],	washerPos[n][2],	unID, washerPos[n][2], 2		: unID = unID + 1
	endif
next i


! ------------------------------------------------------------------------------
! Elements Width Hotspots
! ------------------------------------------------------------------------------

for i = 1 to nElement
	n = elementTypes[i][2]
	unID = 2000 + (elementTypes[i][1]-1) * 1000  +  (n-1) * 100 + 20

	if elementTypes[i][1] = SYMBTYPE_TALL then
		hotspot2 elementWidth[i][1],						elementWidth[i][2],						unID, tallCabinetWidth2[n], 1+128	: unID = unID + 1
		hotspot2 elementWidth[i][1]+cos(elementAngle[i]),	elementWidth[i][2]+sin(elementAngle[i]),unID, tallCabinetWidth2[n], 3		: unID = unID + 1
		hotspot2 elementWidth[i][3],						elementWidth[i][4],						unID, tallCabinetWidth2[n], 2		: unID = unID + 1

		hotspot2 elementWidth[i][3],						elementWidth[i][4],						unID, tallCabinetWidth[n], 1+128	: unID = unID + 1
		hotspot2 elementWidth[i][3]-cos(elementAngle[i]),	elementWidth[i][4]-sin(elementAngle[i]),unID, tallCabinetWidth[n], 3		: unID = unID + 1
		hotspot2 elementWidth[i][1],						elementWidth[i][2],						unID, tallCabinetWidth[n], 2		: unID = unID + 1

		unID = unID + 6
	endif

	if elementTypes[i][1] = SYMBTYPE_SINK then
		if iSinkType <> ACC_SINK_ROUND then
			hotspot2 elementWidth[i][1],						elementWidth[i][2],						unID, sinkWidth2[n], 1+128	: unID = unID + 1
			hotspot2 elementWidth[i][1]+cos(elementAngle[i]),	elementWidth[i][2]+sin(elementAngle[i]),unID, sinkWidth2[n], 3		: unID = unID + 1
			hotspot2 elementWidth[i][3],						elementWidth[i][4],						unID, sinkWidth2[n], 2		: unID = unID + 1

			hotspot2 elementWidth[i][3],						elementWidth[i][4],						unID, sinkWidth[n], 1+128	: unID = unID + 1
			hotspot2 elementWidth[i][3]-cos(elementAngle[i]),	elementWidth[i][4]-sin(elementAngle[i]),unID, sinkWidth[n], 3		: unID = unID + 1
			hotspot2 elementWidth[i][1],						elementWidth[i][2],						unID, sinkWidth[n], 2		: unID = unID + 1

			unID = unID + 6
		else
			hotspot2 elementPos[i][1],							elementPos[i][2],						unID, sinkWidthHalf, 1+128			: unID = unID + 1
			hotspot2 elementPos[i][1]+cos(elementAngle[i]),		elementPos[i][2]+sin(elementAngle[i]),	unID, sinkWidthHalf, 3				: unID = unID + 1
			hotspot2 elementWidth[i][3],						elementWidth[i][4],						unID, sinkWidthHalf, 2, sinkWidth[n]	: unID = unID + 1

			hotspot2 elementPos[i][1],							elementPos[i][2],						unID, sinkWidthHalf, 1+128			: unID = unID + 1
			hotspot2 elementPos[i][1]-cos(elementAngle[i]),		elementPos[i][2]-sin(elementAngle[i]),	unID, sinkWidthHalf, 3				: unID = unID + 1
			hotspot2 elementWidth[i][1],						elementWidth[i][2],						unID, sinkWidthHalf, 2, sinkWidth[n]	: unID = unID + 1

			unID = unID + 6
		endif
	endif

	if elementTypes[i][1] = SYMBTYPE_COOKTOP then
		hotspot2 elementWidth[i][1],						elementWidth[i][2],						unID, cooktopWidth2[n], 1+128	: unID = unID + 1
		hotspot2 elementWidth[i][1]+cos(elementAngle[i]),	elementWidth[i][2]+sin(elementAngle[i]),unID, cooktopWidth2[n], 3		: unID = unID + 1
		hotspot2 elementWidth[i][3],						elementWidth[i][4],						unID, cooktopWidth2[n], 2		: unID = unID + 1

		hotspot2 elementWidth[i][3],						elementWidth[i][4],						unID, cooktopWidth[n], 1+128	: unID = unID + 1
		hotspot2 elementWidth[i][3]-cos(elementAngle[i]),	elementWidth[i][4]-sin(elementAngle[i]),unID, cooktopWidth[n], 3		: unID = unID + 1
		hotspot2 elementWidth[i][1],						elementWidth[i][2],						unID, cooktopWidth[n], 2		: unID = unID + 1

		if bHood & bShowOverhead then
			hotspot2 hoodWidthPos[n][1],						hoodWidthPos[n][2],						unID, hoodWidth2[n], 1+128			: unID = unID + 1
			hotspot2 hoodWidthPos[n][1]-cos(elementAngle[i]),	hoodWidthPos[n][2]-sin(elementAngle[i]),unID, hoodWidth2[n], 3				: unID = unID + 1
			hotspot2 hoodWidthPos[n][3],						hoodWidthPos[n][4],						unID, hoodWidth2[n], 2, hoodWidth[n]	: unID = unID + 1

			hotspot2 hoodWidthPos[n][1],						hoodWidthPos[n][2],						unID, hoodWidth2[n], 1+128			: unID = unID + 1
			hotspot2 hoodWidthPos[n][1]+cos(elementAngle[i]),	hoodWidthPos[n][2]+sin(elementAngle[i]),unID, hoodWidth2[n], 3				: unID = unID + 1
			hotspot2 hoodWidthPos[n][5],						hoodWidthPos[n][6],						unID, hoodWidth2[n], 2, hoodWidth[n]	: unID = unID + 1
		else
			unID = unID + 6
		endif
	endif

	if elementTypes[i][1] = SYMBTYPE_OVEN then
		hotspot2 elementWidth[i][1],						elementWidth[i][2],						unID, ovenWidth2[n], 1+128	: unID = unID + 1
		hotspot2 elementWidth[i][1]+cos(elementAngle[i]),	elementWidth[i][2]+sin(elementAngle[i]),unID, ovenWidth2[n], 3		: unID = unID + 1
		hotspot2 elementWidth[i][3],						elementWidth[i][4],						unID, ovenWidth2[n], 2		: unID = unID + 1

		hotspot2 elementWidth[i][3],						elementWidth[i][4],						unID, ovenWidth[n], 1+128	: unID = unID + 1
		hotspot2 elementWidth[i][3]-cos(elementAngle[i]),	elementWidth[i][4]-sin(elementAngle[i]),unID, ovenWidth[n], 3		: unID = unID + 1
		hotspot2 elementWidth[i][1],						elementWidth[i][2],						unID, ovenWidth[n], 2		: unID = unID + 1

		unID = unID + 6
	endif

	if elementTypes[i][1] = SYMBTYPE_REFRI then
		tx1 = sin(elementAngle[i]) * (refrigeratorDepth-counterDepth/2)
		ty1 = cos(elementAngle[i]) * (refrigeratorDepth-counterDepth/2)

		tx2 = sin(elementAngle[i]) * refrigeratorDepth
		ty2 = cos(elementAngle[i]) * refrigeratorDepth

		tx3 = sin(elementAngle[i]) * (counterDepth/2)
		ty3 = cos(elementAngle[i]) * (counterDepth/2)

		hotspot2 elementWidth[i][1]+tx1,						elementWidth[i][2]-ty1,						unID, refrigeratorWidth2[n], 1+128	: unID = unID + 1
		hotspot2 elementWidth[i][1]+tx1+cos(elementAngle[i]),	elementWidth[i][2]-ty1+sin(elementAngle[i]),unID, refrigeratorWidth2[n], 3	: unID = unID + 1
		hotspot2 elementWidth[i][3]+tx1,						elementWidth[i][4]-ty1,						unID, refrigeratorWidth2[n], 2	: unID = unID + 1

		hotspot2 elementWidth[i][3]+tx1,						elementWidth[i][4]-ty1,						unID, refrigeratorWidth[n], 1+128	: unID = unID + 1
		hotspot2 elementWidth[i][3]+tx1-cos(elementAngle[i]),	elementWidth[i][4]-ty1-sin(elementAngle[i]),unID, refrigeratorWidth[n], 3		: unID = unID + 1
		hotspot2 elementWidth[i][1]+tx1,						elementWidth[i][2]-ty1,						unID, refrigeratorWidth[n], 2		: unID = unID + 1

		hotspot2 elementWidth[i][1]-tx3,						elementWidth[i][2]+ty3,						unID, refrigeratorDepth, 1+128	: unID = unID + 1
		hotspot2 elementWidth[i][1]-tx3,						elementWidth[i][2]+ty3,						unID, refrigeratorDepth, 3		: unID = unID + 1
		hotspot2 elementWidth[i][1]-tx3+tx2,					elementWidth[i][2]+ty3-ty2,					unID, refrigeratorDepth, 2		: unID = unID + 1

		hotspot2 elementWidth[i][3]-tx3,						elementWidth[i][4]+ty3,						unID, refrigeratorDepth, 1+128	: unID = unID + 1
		hotspot2 elementWidth[i][3]-tx3,						elementWidth[i][4]+ty3,						unID, refrigeratorDepth, 3		: unID = unID + 1
		hotspot2 elementWidth[i][3]-tx3+tx2,					elementWidth[i][4]+ty3-ty2,					unID, refrigeratorDepth, 2		: unID = unID + 1
	endif

	if elementTypes[i][1] = SYMBTYPE_DISHWASH then
		hotspot2 elementWidth[i][1],						elementWidth[i][2],						unID, dishwasherWidth2[n], 1+128	: unID = unID + 1
		hotspot2 elementWidth[i][1]+cos(elementAngle[i]),	elementWidth[i][2]+sin(elementAngle[i]),unID, dishwasherWidth2[n], 3		: unID = unID + 1
		hotspot2 elementWidth[i][3],						elementWidth[i][4],						unID, dishwasherWidth2[n], 2		: unID = unID + 1

		hotspot2 elementWidth[i][3],						elementWidth[i][4],						unID, dishwasherWidth[n], 1+128	: unID = unID + 1
		hotspot2 elementWidth[i][3]-cos(elementAngle[i]),	elementWidth[i][4]-sin(elementAngle[i]),unID, dishwasherWidth[n], 3			: unID = unID + 1
		hotspot2 elementWidth[i][1],						elementWidth[i][2],						unID, dishwasherWidth[n], 2			: unID = unID + 1

		unID = unID + 6
	endif

	if elementTypes[i][1] = SYMBTYPE_WASH then
		hotspot2 elementWidth[i][1],						elementWidth[i][2],						unID, washerWidth2[n], 1+128	: unID = unID + 1
		hotspot2 elementWidth[i][1]+cos(elementAngle[i]),	elementWidth[i][2]+sin(elementAngle[i]),unID, washerWidth2[n], 3		: unID = unID + 1
		hotspot2 elementWidth[i][3],						elementWidth[i][4],						unID, washerWidth2[n], 2		: unID = unID + 1

		hotspot2 elementWidth[i][3],						elementWidth[i][4],						unID, washerWidth[n], 1+128		: unID = unID + 1
		hotspot2 elementWidth[i][3]-cos(elementAngle[i]),	elementWidth[i][4]-sin(elementAngle[i]),unID, washerWidth[n], 3			: unID = unID + 1
		hotspot2 elementWidth[i][1],						elementWidth[i][2],						unID, washerWidth[n], 2			: unID = unID + 1

		unID = unID + 6
	endif
next i


! ------------------------------------------------------------------------------
! Symbols
! ------------------------------------------------------------------------------
for i = 1 to nElement
	add2 elementXY[i][1], elementXY[i][2]
	rot2 elementAngle[i]
	widthSymbol		= counterDepth
	lengthSymbol	= elementSizes[i]
	symbolType		= elementTypes[i][1]
	nSymbol			= elementTypes[i][2]
	unID			= 2000 + (elementTypes[i][1]-1) * 1000  +  (elementTypes[i][2]-1) * 100 + 70
	gosub "drawSymbol"
	del 2
next i


! ------------------------------------------------------------------------------
! Wall Cabinet
! ------------------------------------------------------------------------------
if bShowOverhead then
	line_type overheadLine

	for i = 1 to nWallCabinet
		unID = 15000 + (i-1) * 100

		hotspot2  0,						wallCabinetPos_1[i][2],	unID, wallCabinetPos_1[i][1], 1+128	: unID = unID + 1
		hotspot2 -1,						wallCabinetPos_1[i][2],	unID, wallCabinetPos_1[i][1], 3		: unID = unID + 1
		hotspot2  wallCabinetPos_1[i][1],	wallCabinetPos_1[i][2],	unID, wallCabinetPos_1[i][1], 2		: unID = unID + 1

		hotspot2  wallCabinetPos_1[i][1], 	0,						unID, wallCabinetPos_1[i][2], 1+128	: unID = unID + 1
		hotspot2  wallCabinetPos_1[i][1],	-1,						unID, wallCabinetPos_1[i][2], 3		: unID = unID + 1
		hotspot2  wallCabinetPos_1[i][1], 	wallCabinetPos_1[i][2],	unID, wallCabinetPos_1[i][2], 2		: unID = unID + 1

		hotspot2  0,						wallCabinetPos_2[i][2],	unID, wallCabinetPos_2[i][1], 1+128	: unID = unID + 1
		hotspot2 -1,					 	wallCabinetPos_2[i][2],	unID, wallCabinetPos_2[i][1], 3		: unID = unID + 1
		hotspot2  wallCabinetPos_2[i][1],	wallCabinetPos_2[i][2],	unID, wallCabinetPos_2[i][1], 2		: unID = unID + 1

		hotspot2  wallCabinetPos_2[i][1], 	0,						unID, wallCabinetPos_2[i][2], 1+128	: unID = unID + 1
		hotspot2  wallCabinetPos_2[i][1],	-1,						unID, wallCabinetPos_2[i][2], 3		: unID = unID + 1
		hotspot2  wallCabinetPos_2[i][1],	wallCabinetPos_2[i][2],	unID, wallCabinetPos_2[i][2], 2		: unID = unID + 1

		for j = 1 to nWallContour[i] - 1
			hotline2 wallCoords1[i][j*2-1], wallCoords1[i][j*2], wallCoords1[i][j*2+1], wallCoords1[i][j*2+2]
			hotline2 wallCoords2[i][j*2-1], wallCoords2[i][j*2], wallCoords2[i][j*2+1], wallCoords2[i][j*2+2]
		next j
	next i


	if nofCooktops > 0 | nofRefrigerators > 0 | nTallCabinet > 0 then
		if not(bPolyOperations) then
			ch = INITADDONSCOPE ("PolyOperations", "", "")

			nDestContainer = 1
			prevSourceContainer	= "mySourceContainer"
			lastDestContainer	= "myDestinationContainer" + STR(nDestContainer,1,0)

			PREPAREFUNCTION ch, "CreateContainer", prevSourceContainer, ""
			PREPAREFUNCTION ch, "CreateContainer", lastDestContainer, ""

			PREPAREFUNCTION ch, "SetSourceContainer",		prevSourceContainer, ""
			PREPAREFUNCTION ch, "SetDestinationContainer",	lastDestContainer, ""

			bPolyOperations = 1
		endif

		!!Wall Cabinet Contours
		for i = 1 to nWallCabinet
			for j = 1 to nWallContour[i] - 1
				put wallCoords1[i][j*2-1], wallCoords1[i][j*2]
			next j

			put wallCoords1[i][nWallContour[i]*2-1], wallCoords1[i][nWallContour[i]*2]

			for j = nWallContour[i] to 1 step -1
				put wallCoords2[i][j*2-1], wallCoords2[i][j*2]
			next j

			dim vertArr[][]
			dim contArr[]

			nVertices	= nsp/2
			contArr[1]	= nsp/2 + 1
			nCont		= 1

			for j = nVertices to 1 step -1
				vertArr[j][3] = 0.0
				vertArr[j][1] = get(1)
				vertArr[j][2] = get(1)
			next j

			PREPAREFUNCTION ch, "Store", "wallcabPoly"+STR(i,1,0), nVertices, nCont, vertArr, contArr
		next i


		!!Element Holes
		nHole = 0
		for r = 1 to nElement
			if	elementTypes[r][1] = SYMBTYPE_TALL | \
				(elementTypes[r][1] = SYMBTYPE_COOKTOP & bHood & iHoodType <> ACC_HOOD_BUILTIN ) | \
				(elementTypes[r][1] = SYMBTYPE_REFRI & refrigeratorHeigth > (counterHeigth + wallCabinetClearence )) then

				dim contourNames[]
				numContour = CALLFUNCTION (ch, "GetSourcePolygons", "", contourNames)

				dim vertArr[4][3]
				dim contArr[]

				nVertices	= 4
				contArr[1]	= 5
				nCont		= 1

				widthSymbol		= counterDepth/2
				if elementTypes[r][1] = SYMBTYPE_COOKTOP & bHood then
					lengthSymbol	= hoodWidth[elementTypes[r][2]]/ 2
				else
					lengthSymbol	= elementSizes[r] / 2
				endif

				tx1 = cos(elementAngle[r]) * lengthSymbol
				ty1 = sin(elementAngle[r]) * lengthSymbol

				tx2 = sin(elementAngle[r]) * (widthSymbol+EPS)
				ty2 = cos(elementAngle[r]) * (widthSymbol+EPS)

				tx3 = sin(elementAngle[r]) * (-widthSymbol-EPS)
				ty3 = cos(elementAngle[r]) * (-widthSymbol-EPS)

				vertArr[1][1] = elementXY[r][1] + tx1 + tx2
				vertArr[1][2] = elementXY[r][2] + ty1 - ty2
				vertArr[1][3] = 0.0
				vertArr[2][1] = elementXY[r][1] - tx1 + tx2
				vertArr[2][2] = elementXY[r][2] - ty1 - ty2
				vertArr[2][3] = 0.0
				vertArr[3][1] = elementXY[r][1] - tx1 + tx3
				vertArr[3][2] = elementXY[r][2] - ty1 - ty3
				vertArr[3][3] = 0.0
				vertArr[4][1] = elementXY[r][1] + tx1 + tx3
				vertArr[4][2] = elementXY[r][2] + ty1 - ty3
				vertArr[4][3] = 0.0

				nHole = nHole + 1
				holeName = "holes"+STR(nHole,1,0)

				PREPAREFUNCTION ch, "Store", holeName, nVertices, nCont, vertArr, contArr

				dim tempResPolyIDArr[]
				for nC = 1 TO numContour
					tempNumPoly = CALLFUNCTION(ch, contourNames[nC] + " - " + holeName, "", tempResPolyIDArr)
				next nC

				if prevSourceContainer <> "" then
					PREPAREFUNCTION ch, "DeleteContainer",		prevSourceContainer, ""
				endif
				PREPAREFUNCTION ch, "SetSourceContainer",		lastDestContainer, ""
				prevSourceContainer	= lastDestContainer
				nDestContainer = nDestContainer + 1
				lastDestContainer = "myDestinationContainer" + STR(nDestContainer,1,0)
				PREPAREFUNCTION ch, "CreateContainer",			lastDestContainer, ""
				PREPAREFUNCTION ch, "SetDestinationContainer",	lastDestContainer, ""
			endif
		next r

		PREPAREFUNCTION ch, "DeleteContainer",			lastDestContainer, ""
		PREPAREFUNCTION ch, "SetDestinationContainer",	prevSourceContainer, ""
		lastDestContainer	= prevSourceContainer
		prevSourceContainer	= "wallCabinets"
		PREPAREFUNCTION ch, "CreateContainer",			prevSourceContainer, ""
		PREPAREFUNCTION ch, "SetSourceContainer",		prevSourceContainer, ""

		dim resPolyIDArr[]
		numPoly = CALLFUNCTION(ch, "GetDestinationPolygons", "", resPolyIDArr)
		for cP = 1 to numPoly
			polygonID = resPolyIDArr[cP]
			mask = 1
			gosub "getGDLpolygonFromAPI"
			if nsp > 11 then
				poly2_b nsp/3, 1+4, gs_fill_pen, gs_back_pen, get(nsp)
			else
				for k = 1 to nsp
					temp = get(1)
				next k
			endif
		next cP

	else
		for i = 1 to nWallCabinet
			for j = 1 to nWallContour[i] - 1
				put wallCoords1[i][j*2-1], wallCoords1[i][j*2], 1
			next j

			put wallCoords1[i][nWallContour[i]*2-1], wallCoords1[i][nWallContour[i]*2], 1

			for j = nWallContour[i] to 1 step -1
				put wallCoords2[i][j*2-1], wallCoords2[i][j*2], 1
			next j

			poly2_b nsp/3, 1+4, gs_fill_pen, gs_back_pen, get(nsp)
		next i
	endif
endif



! ------------------------------------------------------------------------------
! Minimal Space
! ------------------------------------------------------------------------------
reqBMinSpace = 0
call "fa_minimalspace" parameters all MSType = 0, unID = 10000,
						returned_parameters reqBMinSpace,
											MSFillType,
											MSFillPen,
											MSFillBackPen,
											MSContLineType,
											MSContLinePen

if reqBMinSpace <> 0 then
	if not(bPolyOperations) then
		ch = INITADDONSCOPE ("PolyOperations", "", "")

		nDestContainer = 1
		prevSourceContainer	= "mySourceContainer"
		lastDestContainer	= "myDestinationContainer" + STR(nDestContainer,1,0)

		PREPAREFUNCTION ch, "CreateContainer", prevSourceContainer, ""
		PREPAREFUNCTION ch, "CreateContainer", lastDestContainer, ""

		PREPAREFUNCTION ch, "SetSourceContainer",		prevSourceContainer, ""
		PREPAREFUNCTION ch, "SetDestinationContainer",	lastDestContainer, ""

		bPolyOperations = 1
	endif

	PREPAREFUNCTION ch, "EmptyContainer", prevSourceContainer, ""
	PREPAREFUNCTION ch, "EmptyContainer", lastDestContainer, ""

	drawindex 1
	fill MSFillType
	pen MSContLinePen
	line_type MSContLineType

	dim tempOffset[][2]
	offsetSize = counterDepth + MSFront
	gosub "polyLineOffset"
	dim MSPoints[][2]
	MSPoints = tempOffset

	unID = 10000
	gosub "fillMinSpace"
endif


if bPolyOperations then CLOSEADDONSCOPE ch

! ==============================================================================
!
end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
!
! ==============================================================================

! ------------------------------------------------------------------------------
! Draw Symbol
! ------------------------------------------------------------------------------
"drawSymbol":
! ------------------------------------------------------------------------------

	drawindex 10

	if symbolType = SYMBTYPE_TALL then
		gosub "drawFill"
		line2 -lengthSymbol/2, -widthSymbol/2,  lengthSymbol/2,  widthSymbol/2
		line2  lengthSymbol/2, -widthSymbol/2, -lengthSymbol/2,  widthSymbol/2
	endif

	if symbolType = SYMBTYPE_SINK then
		hotline2 -lengthSymbol/2, -widthSymbol/2, -lengthSymbol/2, widthSymbol/2
		hotline2  lengthSymbol/2, -widthSymbol/2,  lengthSymbol/2, widthSymbol/2
		if iSinkType = ACC_SINK_ROUND then
			lengthSymbol = min (lengthSymbol, widthSymbol)
			add2 -lengthSymbol/2*(1-2*bMirroredSink), -widthSymbol/2
			sinkMinus = 0
		else
			if counterDepth < minSinkCounter then
				sinkOffsetY	= 0
				sinkMinus	= 0
			else
				sinkOffsetY = 0.07
				sinkMinus	= 0.1
			endif
			add2 -lengthSymbol/2*(1-2*bMirroredSink), -widthSymbol/2 + sinkOffsetY
		endif
		mul2 1-2*bMirroredSink, 1
		call "fa_sinktyp"  parameters	a	= lengthSymbol,
										b	= widthSymbol-sinkMinus,
						gs_sink_type_m		= gs_sink_type_m,
						SinkSymbol_m		= 1,
						bMovableDrain		= 0,
						sunder				= 0,
						TapSymbol_m			= 0,
						gs_cont_pen			= gs_cont_pen,
						gs_fill_type		= gs_fill_type,
						gs_fill_pen			= gs_fill_pen,
						gs_back_pen			= gs_back_pen,
						gs_tap_type_m		= 0,
						tapOffset			= 0,
						bShowHotspots		= 0
		del 2
	endif

	if symbolType = SYMBTYPE_COOKTOP then
		hotline2 -lengthSymbol/2, -widthSymbol/2, -lengthSymbol/2, widthSymbol/2
		hotline2  lengthSymbol/2, -widthSymbol/2,  lengthSymbol/2, widthSymbol/2
		add2 0, widthSymbol/2
		call "fa_CooktopType" parameters	a	= lengthSymbol,
											aa	= lengthSymbol,
											b	= widthSymbol,
											bb	= widthSymbol - 0.1,
							gs_symbol_type_m	= 1,
							CooktopType_m		= CooktopType_m,
							gs_hotspotUnIdBegin = unID,
							b2DSymbol			= 0,
							gs_cont_pen			= gs_cont_pen,
							gs_fill_type		= gs_fill_type,
							gs_fill_pen			= gs_fill_pen,
							gs_back_pen			= gs_back_pen,
							bShowHotspots		= 0
		del 1

		if bShowOverhead & bHood then
			line_type overheadLine
			hoodSizeX = hoodWidth[nSymbol]/2
			hoodSizeY = 0.85 * counterDepth
			hoodChimneyX	= 0.14
			hoodChimneyY1	= counterDepth/2 - 0.15
			hoodChimneyY2	= counterDepth/2
			hoodOffsetY		= 0.05

			if iHoodType = ACC_HOOD_WALL |  iHoodType = ACC_HOOD_HANGING then
				line2  hoodSizeX,	counterDepth/2 - hoodSizeY,	 hoodSizeX,	counterDepth/2
				line2  hoodSizeX,	counterDepth/2 - hoodSizeY,	-hoodSizeX,	counterDepth/2 - hoodSizeY
				line2 -hoodSizeX,	counterDepth/2 - hoodSizeY,	-hoodSizeX,	counterDepth/2

				hotline2  hoodSizeX,	counterDepth/2 - hoodSizeY,	 hoodSizeX,	counterDepth/2
				hotline2  hoodSizeX,	counterDepth/2 - hoodSizeY,	-hoodSizeX,	counterDepth/2 - hoodSizeY
				hotline2 -hoodSizeX,	counterDepth/2 - hoodSizeY,	-hoodSizeX,	counterDepth/2

				if iHoodType = ACC_HOOD_HANGING then
					rect2 -hoodChimneyX,	-0.125+hoodOffsetY, hoodChimneyX,	 0.125+hoodOffsetY
				else
					line2  hoodChimneyX,	hoodChimneyY1,	 hoodChimneyX,	hoodChimneyY2
					line2  hoodChimneyX,	hoodChimneyY1,	-hoodChimneyX,	hoodChimneyY1
					line2 -hoodChimneyX,	hoodChimneyY1,	-hoodChimneyX,	hoodChimneyY2

					line2  hoodSizeX,	counterDepth/2 - hoodSizeY,  hoodChimneyX,	hoodChimneyY1
					line2 -hoodSizeX,	counterDepth/2 - hoodSizeY, -hoodChimneyX,	hoodChimneyY1
				endif
			else
				rect2 -hoodSizeX, counterDepth/2, hoodSizeX, counterDepth/2 - hoodSizeY
				line2 -hoodSizeX, counterDepth/2 - wallCabinetDepth, hoodSizeX, counterDepth/2 - wallCabinetDepth
			endif

			line_type SYMB_LINETYPE
		endif
	endif

	if symbolType = SYMBTYPE_OVEN then
		gosub "drawFill"
		if iOvenSymbType = SYMBTYPE_TEXT then
			symbolText = ovenText
			gosub "drawText"
		else
			if LibraryLangCode = "GER" then		!different german symbol
				circle2 0, widthSymbol * 0.1, refriSymbSize/2
				line2 -lengthSymbol/2, -widthSymbol * 0.3, lengthSymbol/2, -widthSymbol * 0.3
			else
				add2 -lengthSymbol/2, -widthSymbol/2
				line2 lengthSymbol, 0, 2/5*lengthSymbol, widthSymbol/2
				line2 2/5*lengthSymbol, widthSymbol/2, 3/5*lengthSymbol, widthSymbol/2
				line2 3/5*lengthSymbol, widthSymbol/2, 0, widthSymbol
				del 1
			endif
		endif
	endif

	if symbolType = SYMBTYPE_REFRI then
		if bRefriWallCabinet & bShowOverhead then
			line_type overheadLine
			widthSymbol = counterDepth
			poly2_b 4, 1+4, gs_fill_pen, gs_back_pen,
				-lengthSymbol/2, -widthSymbol/2, 1,
				 lengthSymbol/2, -widthSymbol/2, 1,
				 lengthSymbol/2,  widthSymbol/2, 1,
				-lengthSymbol/2,  widthSymbol/2, 1

			line_type SYMB_LINETYPE
		endif

		widthSymbol = refrigeratorDepth
		add2 0, -widthSymbol/2 + counterDepth/2
		hotline2 -lengthSymbol/2, -widthSymbol/2, -lengthSymbol/2,  widthSymbol/2
		hotline2  lengthSymbol/2, -widthSymbol/2,  lengthSymbol/2,  widthSymbol/2
		hotline2 -lengthSymbol/2, -widthSymbol/2,  lengthSymbol/2, -widthSymbol/2
		hotline2 -lengthSymbol/2,  widthSymbol/2,  lengthSymbol/2,  widthSymbol/2

		drawindex 8
		poly2_b 4, 1+2+4+64, gs_fill_pen, gs_back_pen,
			-lengthSymbol/2, -widthSymbol/2, 1,
			 lengthSymbol/2, -widthSymbol/2, 1,
			 lengthSymbol/2,  widthSymbol/2, 1,
			-lengthSymbol/2,  widthSymbol/2, 1

		if iRefriSymbType = SYMBTYPE_TEXT then
			symbolText = refriText
			gosub "drawText"
		else
			if iRefrigeratorType <> ACC_REFRI_COMPACT then
				for k = 1 to 4
					rot2 (k-1)* 45
					line2 -refriSymbSize, 0, refriSymbSize, 0
					del 1
				next k
			endif
		endif

		del 1
	endif

	if symbolType = SYMBTYPE_DISHWASH then
		gosub "drawFill"
		if iDishwasherSymbType = SYMBTYPE_TEXT then
			symbolText = dishwasherText
			gosub "drawText"
		else
			aorb = min(lengthSymbol, widthSymbol)

			circle2 0, 0, aorb/2.7
			line2 aorb/2.7*1.414213/2, aorb/2.7*1.414213/2, lengthSymbol/2, widthSymbol/2
			line2 -aorb/2.7*1.414213/2, aorb/2.7*1.414213/2, -lengthSymbol/2, widthSymbol/2
			line2 aorb/2.7*1.414213/2, -aorb/2.7*1.414213/2, lengthSymbol/2, -widthSymbol/2
			line2 -aorb/2.7*1.414213/2, -aorb/2.7*1.414213/2, -lengthSymbol/2, -widthSymbol/2
		endif
	endif

	if symbolType = SYMBTYPE_WASH then
		gosub "drawFill"
		if iWasherSymbType = SYMBTYPE_TEXT then
			symbolText = washerText
			gosub "drawText"
		else
			aorb = min(lengthSymbol, widthSymbol)

			circle2 0, 0, aorb/2.7
		endif
	endif
return


! ------------------------------------------------------------------------------
"drawFill":
! ------------------------------------------------------------------------------

	hotline2 -lengthSymbol/2, -widthSymbol/2, -lengthSymbol/2, widthSymbol/2
	hotline2  lengthSymbol/2, -widthSymbol/2,  lengthSymbol/2, widthSymbol/2

	drawindex 8
	poly2_b 4, 1+2+4+64, gs_fill_pen, gs_back_pen,
		-lengthSymbol/2, -widthSymbol/2, 1,
		 lengthSymbol/2, -widthSymbol/2, 1,
		 lengthSymbol/2,  widthSymbol/2, 1,
		-lengthSymbol/2,  widthSymbol/2, 1

	drawindex 10
return


! ------------------------------------------------------------------------------
"drawText":
! ------------------------------------------------------------------------------

	pen penText
	nTrans = 0
	totalRotate = (SYMB_ROTANGLE + angleViewRot + elementAngle[i]) MOD 360
	if typeTextRotation_m = 2 then				! Readable
		rot2 180 * (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps))	! 1/0
		nTrans = nTrans + 1
	else
		if typeTextRotation_m = 1 then							! Horizontal
			totalRotate = (SYMB_ROTANGLE + angleViewRot) MOD 360
			rot2 totalRotate * (SYMB_MIRRORED - not(SYMB_MIRRORED))	- elementAngle[i]	! 1/-1
			nTrans = nTrans + 1
		endif
	endif
	text2 0, 0, symbolText
	del nTrans
	pen gs_cont_pen
return


! ==============================================================================
! Fill Minimal Space Polygon Contour
! ------------------------------------------------------------------------------
! Input variables:
!	startRef:		actual start point number
! Returned variable:
!	stack:
! ==============================================================================
"fillMinSpace":

	nMinSpace = 0
	for i = 1 to nTotalRefPoint -1
		if bIsLine[i] then

			dim contourNames[]
			numContour = CALLFUNCTION (ch, "GetSourcePolygons", "", contourNames)

			dim inhEdgeInfos[4]
			dim vertArr[4][3]
			dim contArr[]

			defaultInhEdgeInfo	= 0
			nVertices			= 4
			contArr[1]			= 5
			nCont				= 1

			vertArr[1][1] = oppsidePoints[i][1]
			vertArr[1][2] = oppsidePoints[i][2]
			vertArr[1][3] = 0.0
			vertArr[2][1] = oppsidePoints[i+1][1]
			vertArr[2][2] = oppsidePoints[i+1][2]
			vertArr[2][3] = 0.0
			vertArr[3][1] = MSPoints[i+1][1]
			vertArr[3][2] = MSPoints[i+1][2]
			vertArr[3][3] = 0.0
			vertArr[4][1] = MSPoints[i][1]
			vertArr[4][2] = MSPoints[i][2]
			vertArr[4][3] = 0.0

			inhEdgeInfos[1] = 0
			inhEdgeInfos[2] = 0
			inhEdgeInfos[3] = 0
			inhEdgeInfos[4] = 1

			nMinSpace = nMinSpace + 1
			minSpaceName = "minSpace"+STR(nMinSpace,1,0)

			PREPAREFUNCTION ch, "Store", minSpaceName, nVertices, nCont, vertArr, contArr, defaultInhEdgeInfo, inhEdgeInfos

			if numContour > 0 then
			dim tempResPolyIDArr[]
				for nC = 1 TO numContour
					tempNumPoly = CALLFUNCTION(ch, contourNames[nC] + " + " + minSpaceName, "", tempResPolyIDArr)
					if tempNumPoly > 1 & nC < numContour then
						PREPAREFUNCTION ch, "Dispose", tempResPolyIDArr[tempNumPoly], lastDestContainer
					endif
				next nC

				if prevSourceContainer <> "" then
					PREPAREFUNCTION ch, "DeleteContainer",		prevSourceContainer, ""
				endif
				PREPAREFUNCTION ch, "SetSourceContainer",		lastDestContainer, ""
				prevSourceContainer	= lastDestContainer
				nDestContainer = nDestContainer + 1
				lastDestContainer = "myDestinationContainer" + STR(nDestContainer,1,0)
				PREPAREFUNCTION ch, "CreateContainer",			lastDestContainer, ""
				PREPAREFUNCTION ch, "SetDestinationContainer",	lastDestContainer, ""
			endif
		endif
	next i

	PREPAREFUNCTION ch, "DeleteContainer",			lastDestContainer, ""
	PREPAREFUNCTION ch, "SetDestinationContainer",	prevSourceContainer, ""
	lastDestContainer	= prevSourceContainer
	prevSourceContainer	= "minSpaceces"
	PREPAREFUNCTION ch, "CreateContainer",			prevSourceContainer, ""
	PREPAREFUNCTION ch, "SetSourceContainer",		prevSourceContainer, ""

	dim resPolyIDArr[]
	numPoly = CALLFUNCTION(ch, "GetDestinationPolygons", "", resPolyIDArr)
	for cP = 1 to numPoly
		polygonID = resPolyIDArr[cP]
		mask = 1
		gosub "getGDLpolygonFromAPI"
		if nsp > 8 then
			poly2_b nsp/3, 1+2+4+64, MSFillPen, MSFillBackPen, use(nsp)

			nspNum = nsp
			for k = 1 to nspNum / 3
				hpX = get(1)
				hpY = get(1)
				hpS = get(1)
				hotspot2 hpX,hpY, unID	: unID = unID + 1
			next k
			for k = 1 to nsp
				temp = get(1)
			next k
		else
			for k = 1 to nsp
				temp = get(1)
			next k
		endif
	next cP

return


]]>
</Script_2D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_1D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
EPS				= 0.0001
minSize			= 0.20
minHood			= 0.40
newEdgeLength	= 2.00
minSinkCounter	= 0.3

! ------------------------------------------------------------------------------
! Maximum Elements
! ------------------------------------------------------------------------------
nMaxAccessory		= 8
nMaxSegment			= 20
newElementDistance	= 0.1
ovenH				= 0.5

! ------------------------------------------------------------------------------
! Definitions
! ------------------------------------------------------------------------------
dim stLayoutType[6]
	stLayoutType[1] = `Прямая`
	stLayoutType[2] = `L-образная`
	stLayoutType[3] = `U-образная`
	stLayoutType[4] = `Камбуз`
	stLayoutType[5] = `Остров`
	stLayoutType[6] = `Специальная`

LAYOUT_STRAIGHT		= 1
LAYOUT_L_SHAPE		= 2
LAYOUT_U_SHAPE		= 3
LAYOUT_GALLEY		= 4
LAYOUT_ISLAND		= 5
LAYOUT_CUSTOM		= 6

SYMBTYPE_TALL		= 1
SYMBTYPE_SINK		= 2
SYMBTYPE_COOKTOP	= 3
SYMBTYPE_OVEN		= 4
SYMBTYPE_REFRI		= 5
SYMBTYPE_DISHWASH	= 6
SYMBTYPE_WASH		= 7

dim stSinkType[6]
	stSinkType[1] = `Круглая`
	stSinkType[2] = `Односпальная`
	stSinkType[3] = `Одна Чаша с Крылом`
	stSinkType[4] = `Двуспальная`
	stSinkType[5] = `Две Чаши с Крылом`
	stSinkType[6] = `Три Чаши`

ACC_SINK_ROUND			= 1
ACC_SINK_SINGLE			= 2
ACC_SINK_SINGLE_DRAIN	= 3
ACC_SINK_DOUBLE			= 4
ACC_SINK_DOUBLE_DRAIN	= 5
ACC_SINK_TRIPLE			= 6

dim stCooktopType[3]
	stCooktopType[1] = `2 конфорки`
	stCooktopType[2] = `4 конфорки`
	stCooktopType[3] = `5 конфорок`

ACC_COOKTOP_2	= 1
ACC_COOKTOP_4	= 2
ACC_COOKTOP_5	= 3

dim stHoodType[3]
	stHoodType[1] = `Настенная`
	stHoodType[2] = `Подвесная`
	stHoodType[3] = `Встроенная`

ACC_HOOD_WALL		= 1
ACC_HOOD_HANGING	= 2
ACC_HOOD_BUILTIN	= 3

dim stRefrigeratorType[5]
	stRefrigeratorType[1] = `Морозильная Камера Вверху`
	stRefrigeratorType[2] = `Морозильная Камера Внизу`
	stRefrigeratorType[3] = `Морозильная Камера Сбоку`
	stRefrigeratorType[4] = `Французская Дверь`
	stRefrigeratorType[5] = `Компактный`

ACC_REFRI_TOP		= 1
ACC_REFRI_BOTTOM	= 2
ACC_REFRI_SIDE		= 3
ACC_REFRI_FRENCH	= 4
ACC_REFRI_COMPACT	= 5

dim	stTextRot[3]
	stTextRot[1] = `Читаемый`
	stTextRot[2] = `Всегда Горизонтально`
	stTextRot[3] = `Выровнять по Символу`

dim stSymbType[2]
	stSymbType[1] = `Символический`
	stSymbType[2] = `Текст`

SYMBTYPE_SYMBOL		= 1
SYMBTYPE_TEXT		= 2


! ==============================================================================
!
! Default Change (only debug)
!
! ==============================================================================
if bChangeDefault then
	!Reference Line
	dim tempRefLinePoints_1[][2]
	dim tempRefLinePoints_2[][2]
	dim tempRefLinePoints_3[][2]
	tempRefLinePoints_1 = refLinePoints_1	: parameters tempRefLinePoints_1 = tempRefLinePoints_1
	tempRefLinePoints_2 = refLinePoints_2	: parameters tempRefLinePoints_2 = tempRefLinePoints_2
	tempRefLinePoints_3 = refLinePoints_3	: parameters tempRefLinePoints_3 = tempRefLinePoints_3

	!Wall Cabinet
	dim wallCabinetPos2_1[][2]
	dim wallCabinetPos2_2[][2]
	wallCabinetPos2_1 = wallCabinetPos_1	: parameters wallCabinetPos2_1	= wallCabinetPos2_1
	wallCabinetPos2_2 = wallCabinetPos_2	: parameters wallCabinetPos2_2	= wallCabinetPos2_2

	!Tall Cabinet
	dim tallCabinetWidth2[]
	dim tallCabPos2[][2]
	tallCabinetWidth2 = tallCabinetWidth	: parameters tallCabinetWidth2	= tallCabinetWidth2
	tallCabPos2 = tallCabPos				: parameters tallCabPos2		= tallCabPos2

	!Sink
	dim sinkWidth2[]
	dim sinkPos2[][2]
	sinkWidth2 = sinkWidth					: parameters sinkWidth2	= sinkWidth2
	sinkPos2 = sinkPos						: parameters sinkPos2	= sinkPos2

	!Cooktop
	dim cooktopWidth2[]
	dim cooktopPos2[][2]
	cooktopWidth2 = cooktopWidth			: parameters cooktopWidth2	= cooktopWidth2
	cooktopPos2 = cooktopPos				: parameters cooktopPos2	= cooktopPos2

	!Oven
	dim ovenWidth2[]
	dim ovenPos2[][2]
	ovenWidth2 = ovenWidth					: parameters ovenWidth2	= ovenWidth2
	ovenPos2 = ovenPos						: parameters ovenPos2	= ovenPos2

	!Refigerator
	dim refrigeratorWidth2[]
	dim refrigeratorPos2[][2]
	refrigeratorWidth2 = refrigeratorWidth	: parameters refrigeratorWidth2	= refrigeratorWidth2
	refrigeratorPos2 = refrigeratorPos		: parameters refrigeratorPos2	= refrigeratorPos2

	!DishWasher
	dim dishwasherWidth2[]
	dim dishwasherPos2[][2]
	dishwasherWidth2 = dishwasherWidth		: parameters dishwasherWidth2	= dishwasherWidth2
	dishwasherPos2 = dishwasherPos			: parameters dishwasherPos2		= dishwasherPos2

	!Washer
	dim washerWidth2[]
	dim washerPos2[][2]
	washerWidth2 = washerWidth				: parameters washerWidth2	= washerWidth2
	washerPos2 = washerPos					: parameters washerPos2		= washerPos2

endif


! ==============================================================================
!
! Geometry
!
! ==============================================================================

values "layoutType" stLayoutType
values "iLayoutType" LAYOUT_STRAIGHT, LAYOUT_L_SHAPE, LAYOUT_U_SHAPE, LAYOUT_GALLEY, LAYOUT_ISLAND, LAYOUT_CUSTOM
if GLOB_MODPAR_NAME = "layoutType" then
	iLayoutType = 1
	for i = 1 to vardim1(stLayoutType)
		if layoutType = stLayoutType[i] then
			iLayoutType = i
			i = vardim1(stLayoutType)
		endif
	next i
	parameters iLayoutType = iLayoutType
else
	iLayoutType = max(min(iLayoutType,vardim1(stLayoutType)),1)
	parameters layoutType = stLayoutType[iLayoutType]
endif

! ------------------------------------------------------------------------------
! Change Geometry
! ------------------------------------------------------------------------------
bGeometryChanged = 0
if	GLOB_MODPAR_NAME = "layoutType"			| \
	GLOB_MODPAR_NAME = "iLayoutType"		| \
	GLOB_MODPAR_NAME = "nChains"			| \
	GLOB_MODPAR_NAME = "nChains"			| \
	GLOB_MODPAR_NAME = "nChainSegment_1"	| \
	GLOB_MODPAR_NAME = "nChainSegment_2"	| \
	GLOB_MODPAR_NAME = "nChainSegment_3"	| \
	GLOB_MODPAR_NAME = "refLinePoints_1"	| \
	GLOB_MODPAR_NAME = "refLinePoints_2"	| \
	GLOB_MODPAR_NAME = "refLinePoints_3"	then
	bGeometryChanged = 1
endif

if GLOB_SCRIPT_TYPE = 2 | GLOB_SCRIPT_TYPE = 3 then
	if GLOB_CONTEXT = 1 | GLOB_CONTEXT = 5 then bGeometryChanged = 1	!! Always recalculate
endif

! ------------------------------------------------------------------------------
! References Line
! ------------------------------------------------------------------------------
dim bChains[3]
	bChains[1] = 1
	bChains[2] = (iLayoutType = LAYOUT_CUSTOM) * (nChains > 1)
	bChains[3] = (iLayoutType = LAYOUT_CUSTOM) * (nChains > 2)


dim	nRefPoint[6]
	nRefPoint[LAYOUT_STRAIGHT]	= 2
	nRefPoint[LAYOUT_L_SHAPE]	= 3
	nRefPoint[LAYOUT_U_SHAPE]	= 4
	nRefPoint[LAYOUT_GALLEY]	= 4
	nRefPoint[LAYOUT_ISLAND]	= 4
	nRefPoint[LAYOUT_CUSTOM]	= (nChainSegment_1 + 1) + bChains[2] * (nChainSegment_2 + 1) + bChains[3] * (nChainSegment_3 + 1)

nTotalRefPoint = nRefPoint[iLayoutType]

dim nRefPoints[3]
dim	bIsLine[]
dim refLinePoints[][2]

if iLayoutType <> LAYOUT_CUSTOM then
	for i = nTotalRefPoint to 1 step -1
		if i > 1 then bIsLine[i-1]	= 1
		refLinePoints[i][1]	= refLinePoints_1[i][1]
		refLinePoints[i][2]	= refLinePoints_1[i][2]
	next i
	nRefPoints[1] = nTotalRefPoint
	nRefPoints[2] = 0
	nRefPoints[3] = 0
else
	n = nTotalRefPoint

	! ------- Chain 3 --------
	if bChains[3] then
		nRefPoints[3] = nChainSegment_3 + 1

		! Check Segment Array
		if vardim1(refLinePoints_3) < nRefPoints[3] then
			nDimRefPoints = vardim1(refLinePoints_3)
			if nDimRefPoints >= 2 then
				tempDeltaX = refLinePoints_3[nDimRefPoints][1] - refLinePoints_3[nDimRefPoints-1][1]
				tempDeltaY = refLinePoints_3[nDimRefPoints][2] - refLinePoints_3[nDimRefPoints-1][2]

				if abs(tempDeltaX) < eps then
					if tempDeltaY > 0 then
						lastAngle = 270
					else
						lastAngle = 90
					endif
				else
					lastAngle = atn( tempDeltaY / tempDeltaX)
					if tempDeltaX > 0 then lastAngle = lastAngle + 180
				endif
			else
				lastAngle = 0
			endif

			dim tempRefLinePoints[][2]
			for i = nRefPoints[3] to nDimRefPoints+1 step -1
				tempRefLinePoints[i][1] = refLinePoints_3[nDimRefPoints][1] - (i-nDimRefPoints) * newEdgeLength * cos(lastAngle)
				tempRefLinePoints[i][2] = refLinePoints_3[nDimRefPoints][2] - (i-nDimRefPoints) * newEdgeLength * sin(lastAngle)
			next i
			for i = nDimRefPoints to 1 step -1
				tempRefLinePoints[i][1] = refLinePoints_3[i][1]
				tempRefLinePoints[i][2] = refLinePoints_3[i][2]
			next i
			dim refLinePoints_3[][2]
			refLinePoints_3 = tempRefLinePoints
			parameters refLinePoints_3 = refLinePoints_3
		endif

		! Calculate RefLinePoints
		for i = nRefPoints[3] to 1 step -1
			if i = 1 then
				bIsLine[n-1]	= 0
			else
				bIsLine[n-1]	= 1
			endif
			refLinePoints[n][1]	= refLinePoints_3[i][1]
			refLinePoints[n][2]	= refLinePoints_3[i][2]
			n = n - 1
		next i
	else
		nRefPoints[3] = 0
	endif

	! ------- Chain 2 --------
	if bChains[2] then
		nRefPoints[2] = nChainSegment_2 + 1

		! Check Segment Array
		if vardim1(refLinePoints_2) < nRefPoints[2] then
			nDimRefPoints = vardim1(refLinePoints_2)
			if nDimRefPoints >= 2 then
				tempDeltaX = refLinePoints_2[nDimRefPoints][1] - refLinePoints_2[nDimRefPoints-1][1]
				tempDeltaY = refLinePoints_2[nDimRefPoints][2] - refLinePoints_2[nDimRefPoints-1][2]
				if abs(tempDeltaX) < eps then
					if tempDeltaY > 0 then
						lastAngle = 270
					else
						lastAngle = 90
					endif
				else
					lastAngle = atn( tempDeltaY / tempDeltaX)
					if tempDeltaX > 0 then lastAngle = lastAngle + 180
				endif
			else
				lastAngle = 0
			endif

			dim tempRefLinePoints[][2]
			for i = nRefPoints[2] to nDimRefPoints+1 step -1
				tempRefLinePoints[i][1] = refLinePoints_2[nDimRefPoints][1] - (i-nDimRefPoints) * newEdgeLength * cos(lastAngle)
				tempRefLinePoints[i][2] = refLinePoints_2[nDimRefPoints][2] - (i-nDimRefPoints) * newEdgeLength * sin(lastAngle)
			next i
			for i = nDimRefPoints to 1 step -1
				tempRefLinePoints[i][1] = refLinePoints_2[i][1]
				tempRefLinePoints[i][2] = refLinePoints_2[i][2]
			next i
			dim refLinePoints_2[][2]
			refLinePoints_2 = tempRefLinePoints
			parameters refLinePoints_2 = refLinePoints_2
		endif

		! Calculate RefLinePoints
		for i = nRefPoints[2] to 1 step -1
			if i = 1 then
				bIsLine[n-1]	= 0
			else
				bIsLine[n-1]	= 1
			endif
			refLinePoints[n][1]	= refLinePoints_2[i][1]
			refLinePoints[n][2]	= refLinePoints_2[i][2]
			n = n - 1
		next i
	else
		nRefPoints[2] = 0
	endif

	! ------- Chain 1 --------
	nRefPoints[1] = nChainSegment_1 + 1

	! Check Segment Array
	if vardim1(refLinePoints_1) < nRefPoints[1] then
		nDimRefPoints = vardim1(refLinePoints_1)
		if nDimRefPoints >= 2 then
			tempDeltaX = refLinePoints_1[nDimRefPoints][1] - refLinePoints_1[nDimRefPoints-1][1]
			tempDeltaY = refLinePoints_1[nDimRefPoints][2] - refLinePoints_1[nDimRefPoints-1][2]
			if abs(tempDeltaX) < eps then
				if tempDeltaY > 0 then
					lastAngle = 270
				else
					lastAngle = 90
				endif
			else
				lastAngle = atn( tempDeltaY / tempDeltaX)
				if tempDeltaX > 0 then lastAngle = lastAngle + 180
			endif
		else
			lastAngle = 0
		endif

		dim tempRefLinePoints[][2]
		for i = nRefPoints[1] to nDimRefPoints+1 step -1
			tempRefLinePoints[i][1] = refLinePoints_1[nDimRefPoints][1] - (i-nDimRefPoints) * newEdgeLength * cos(lastAngle)
			tempRefLinePoints[i][2] = refLinePoints_1[nDimRefPoints][2] - (i-nDimRefPoints) * newEdgeLength * sin(lastAngle)
		next i
		for i = nDimRefPoints to 1 step -1
			tempRefLinePoints[i][1] = refLinePoints_1[i][1]
			tempRefLinePoints[i][2] = refLinePoints_1[i][2]
		next i
		dim refLinePoints_1[][2]
		refLinePoints_1 = tempRefLinePoints
		parameters refLinePoints_1 = refLinePoints_1
	endif

	! Calculate RefLinePoints
	for i = nRefPoints[1] to 1 step -1
		if i > 1 then bIsLine[n-1]	= 1
		refLinePoints[n][1]	= refLinePoints_1[i][1]
		refLinePoints[n][2]	= refLinePoints_1[i][2]
		n = n - 1
	next i
endif


if iLayoutType = LAYOUT_GALLEY | iLayoutType = LAYOUT_ISLAND then bIsLine[2] = 0
if iLayoutType = LAYOUT_ISLAND then
	nWallCabinet = 0
	refLinePoints[3][1] = refLinePoints[2][1]
	refLinePoints[3][2] = refLinePoints[2][2]
	refLinePoints[4][1] = refLinePoints[1][1]
	refLinePoints[4][2] = refLinePoints[1][2]
endif


! ------------------------------------------------------------------------------
! Calculate Contour Points
! ------------------------------------------------------------------------------
dim	oppsidePoints[][2]
dim contourPoints[][]
dim nContour[]
dim	refAngle[]
dim bIsSect[]
nPoly = 1

for i = nTotalRefPoint to 1 step -1
	if i = nTotalRefPoint | i = 1 then
		bIsSect[i] = 0
	else
		if bIsLine[i] & bIsLine[i-1] then
			bIsSect[i] = 1
		else
			bIsSect[i] = 0
		endif
	endif

	if i < nTotalRefPoint then
		tempDeltaX = refLinePoints[i+1][1] - refLinePoints[i][1]
		tempDeltaY = refLinePoints[i+1][2] - refLinePoints[i][2]

		if abs(tempDeltaX) < eps then
			if tempDeltaY > 0 then
				refAngle[i] = 270
			else
				refAngle[i] = 90
			endif
		else
			refAngle[i] = atn( tempDeltaY / tempDeltaX)
			if tempDeltaX > 0 then refAngle[i] = refAngle[i] + 180
		endif
	endif
next i

dim tempOffset[][2]
offsetSize = counterDepth
gosub "polyLineOffset"
oppsidePoints = tempOffset

startRef		= 1
nCurrentPoly	= 0
for i = 2 to min(nTotalRefPoint-1, vardim1(bIsLine))
	if not(bIsLine[i]) & bIsLine[i-1] then nPoly = nPoly + 1
next i

for i = 1 to nPoly
	nCurrentPoly = nCurrentPoly + 1
	gosub "fillContour"
	startRef = cur
next i


! ------------------------------------------------------------------------------
! Calculate Axis Points
! ------------------------------------------------------------------------------
dim	axisPoints[][2]
dim tempOffset[][2]
offsetSize = counterDepth / 2
gosub "polyLineOffset"
axisPoints = tempOffset



! ==============================================================================
!
! Elements
!
! ==============================================================================

! ------------------------------------------------------------------------------
! Accessory number
! ------------------------------------------------------------------------------
nofSink 			= bSink			* nSink
nofCooktops			= bCooktop		* nCooktops
nofOvens			= bOven			* nOvens
nofRefrigerators	= bRefrigerator	* nRefrigerators
nofDishwasher		= bDishwasher	* nDishwasher
nofWasher			= bWasher		* nWasher


! ------------------------------------------------------------------------------
! Accessory Elements Arrays
! ------------------------------------------------------------------------------
dim bElemPosChanged[]
dim bNewElementPos[]
dim elementPos[][2]
dim elementSizes[]
dim elementTypes[][2]
dim nIsSegment[]
nElement 	= nTallCabinet + nofSink + nofCooktops + nofOvens + nofRefrigerators + nofDishwasher + nofWasher
nE = nElement

dim	isTall[]
bChange = (GLOB_MODPAR_NAME = "nTallCabinet" | bGeometryChanged)
for i = nTallCabinet to 1 step -1
	elementPos[nE][1]	= tallCabPos[i][1]
	elementPos[nE][2]	= tallCabPos[i][2]
	bElemPosChanged[nE]	= (abs(tallCabPos[i][1] - tallCabPos2[i][1]) > EPS | abs(tallCabPos[i][2] - tallCabPos2[i][2]) > EPS | bChange | nSegmentTall[i] = 0)
	bNewElementPos[nE]	= (i > nPrevTallCabinet)
	nIsSegment[nE]		= nSegmentTall[i]
	elementSizes[nE]	= tallCabinetWidth[i]
	elementTypes[nE][1]	= SYMBTYPE_TALL
	elementTypes[nE][2]	= i
	isTall[i]			= nE
	nE = nE - 1
next i

dim	isSink[]
bChange = (GLOB_MODPAR_NAME = "bSink" | GLOB_MODPAR_NAME = "nSink" | bGeometryChanged)
for i = nofSink to 1 step -1
	elementPos[nE][1]	= sinkPos[i][1]
	elementPos[nE][2]	= sinkPos[i][2]
	bElemPosChanged[nE]	= (abs(sinkPos[i][1] - sinkPos2[i][1]) > EPS | abs(sinkPos[i][2] - sinkPos2[i][2]) > EPS | bChange | nSegmentSink[i] = 0)
	bNewElementPos[nE]	= (i > nPrevSink)
	nIsSegment[nE]		= nSegmentSink[i]
	elementSizes[nE]	= sinkWidth[i]
	elementTypes[nE][1]	= SYMBTYPE_SINK
	elementTypes[nE][2]	= i
	isSink[i]			= nE
	nE = nE - 1
next i

dim	isCooktop[]
bChange = (GLOB_MODPAR_NAME = "bCooktoop" | GLOB_MODPAR_NAME = "nCooktops" | bGeometryChanged)
for i = nofCooktops to 1 step -1
	elementPos[nE][1]	= cooktopPos[i][1]
	elementPos[nE][2]	= cooktopPos[i][2]
	bElemPosChanged[nE]	= (abs(cooktopPos[i][1] - cooktopPos2[i][1]) > EPS | abs(cooktopPos[i][2] - cooktopPos2[i][2]) > EPS | bChange | nSegmentCooktop[i] = 0)
	bNewElementPos[nE]	= (i > nPrevCooktops)
	nIsSegment[nE]		= nSegmentCooktop[i]
	elementSizes[nE]	= cooktopWidth[i]
	elementTypes[nE][1]	= SYMBTYPE_COOKTOP
	elementTypes[nE][2]	= i
	isCooktop[i]		= nE
	nE = nE - 1
next i

dim	isOven[]
bChange = (GLOB_MODPAR_NAME = "bOven" | GLOB_MODPAR_NAME = "nOvens" | bGeometryChanged)
for i = nofOvens to 1 step -1
	elementPos[nE][1]	= ovenPos[i][1]
	elementPos[nE][2]	= ovenPos[i][2]
	bElemPosChanged[nE]	= (abs(ovenPos[i][1] - ovenPos2[i][1]) > EPS | abs(ovenPos[i][2] - ovenPos2[i][2]) > EPS | bChange | nSegmentOven[i] = 0)
	bNewElementPos[nE]	= (i > nPrevOvens)
	nIsSegment[nE]		= nSegmentOven[i]
	elementSizes[nE]	= ovenWidth[i]
	elementTypes[nE][1]	= SYMBTYPE_OVEN
	elementTypes[nE][2]	= i
	isOven[i]			= nE
	nE = nE - 1
next i

dim	isRefri[]
bChange = (GLOB_MODPAR_NAME = "bRefrigerator" | GLOB_MODPAR_NAME = "nRefrigerators" | bGeometryChanged)
for i = nofRefrigerators to 1 step -1
	elementPos[nE][1]	= refrigeratorPos[i][1]
	elementPos[nE][2]	= refrigeratorPos[i][2]
	bElemPosChanged[nE]	= (abs(refrigeratorPos[i][1] - refrigeratorPos2[i][1]) > EPS | abs(refrigeratorPos[i][2] - refrigeratorPos2[i][2]) > EPS | bChange | nSegmentRefri[i] = 0)
	bNewElementPos[nE]	= (i > nPrevRefri)
	nIsSegment[nE]		= nSegmentRefri[i]
	elementSizes[nE]	= refrigeratorWidth[i]
	elementTypes[nE][1]	= SYMBTYPE_REFRI
	elementTypes[nE][2]	= i
	isRefri[i]			= nE
	nE = nE - 1
next i

dim	isDishwash[]
bChange = (GLOB_MODPAR_NAME = "bDishwasher" | GLOB_MODPAR_NAME = "nDishwasher" | bGeometryChanged)
for i = nofDishwasher to 1 step -1
	elementPos[nE][1]	= dishwasherPos[i][1]
	elementPos[nE][2]	= dishwasherPos[i][2]
	bElemPosChanged[nE]	= (abs(dishwasherPos[i][1] - dishwasherPos2[i][1]) > EPS | abs(dishwasherPos[i][2] - dishwasherPos2[i][2]) > EPS | bChange | nSegmentDishwasher[i] = 0)
	bNewElementPos[nE]	= (i > nPrevDishwasher)
	nIsSegment[nE]		= nSegmentDishwasher[i]
	elementSizes[nE]	= dishwasherWidth[i]
	elementTypes[nE][1]	= SYMBTYPE_DISHWASH
	elementTypes[nE][2]	= i
	isDishwash[i]		= nE
	nE = nE - 1
next i

dim	isWasher[]
bChange = (GLOB_MODPAR_NAME = "bWasher" | GLOB_MODPAR_NAME = "nWasher" | bGeometryChanged)
for i = nofWasher to 1 step -1
	elementPos[nE][1]	= washerPos[i][1]
	elementPos[nE][2]	= washerPos[i][2]
	bElemPosChanged[nE]	= (abs(washerPos[i][1] - washerPos2[i][1]) > EPS | abs(washerPos[i][2] - washerPos2[i][2]) > EPS | bChange | nSegmentWasher[i] = 0)
	bNewElementPos[nE]	= (i > nPrevWasher)
	nIsSegment[nE]		= nSegmentWasher[i]
	elementSizes[nE]	= washerWidth[i]
	elementTypes[nE][1]	= SYMBTYPE_WASH
	elementTypes[nE][2]	= i
	isWasher[i]			= nE
	nE = nE - 1
next i


! ------------------------------------------------------------------------------
! Elements Position
! ------------------------------------------------------------------------------
dim elementXY[][2]
dim elementAngle[]
dim elementWidth[][4]

for i = nElement to 1 step -1
	if bNewElementPos[i] then		!New accessory, place out the contour
		nIsSegment[i] = 1
		elementAngle[i] = refAngle[1]
		elementXY[i][1] = refLinePoints[1][1]+cos(elementAngle[i])*(elementSizes[i]/2 + lastPointLength + newElementDistance) + cos(90-elementAngle[i]) * counterDepth / 2
		elementXY[i][2] = refLinePoints[1][2]+sin(elementAngle[i])*(elementSizes[i]/2 + lastPointLength + newElementDistance) - sin(90-elementAngle[i]) * counterDepth / 2
		lastPointLength = lastPointLength + newElementDistance + elementSizes[i]
		bElemPosChanged[i] = 1
	else
		if bElemPosChanged[i] then
			!Point Distances
			dim axisDistance[][3]	!(1) distance, (2,3) projection points x,y
			dim srcPolygon[5][2]
			xp = elementPos[i][1]
			yp = elementPos[i][2]

			bFound = 0
			for j = nTotalRefPoint-1 to 1 step -1
				if bIsLine[j] then
					x11 = axisPoints[j][1]
					y11 = axisPoints[j][2]
					x12 = axisPoints[j+1][1]
					y12 = axisPoints[j+1][2]
					gosub "pointLineDistance"
					axisDistance[j][1] = dist
					axisDistance[j][2] = xx
					axisDistance[j][3] = yy

					srcPolygon[1][1] = refLinePoints[j][1]
					srcPolygon[1][2] = refLinePoints[j][2]
					srcPolygon[2][1] = refLinePoints[j+1][1]
					srcPolygon[2][2] = refLinePoints[j+1][2]
					srcPolygon[3][1] = oppsidePoints[j+1][1]
					srcPolygon[3][2] = oppsidePoints[j+1][2]
					srcPolygon[4][1] = oppsidePoints[j][1]
					srcPolygon[4][2] = oppsidePoints[j][2]
					srcPolygon[5][1] = refLinePoints[j][1]
					srcPolygon[5][2] = refLinePoints[j][2]
					pntX = xp
					pntY = yp
					gosub "pointInsidePolygon"
					if ret = 1 then
						axisDistance[j][1] = axisDistance[j][1] - counterDepth / 2
						bFound = 1
						nIsSegment[i] = j
						j = 1
					endif
				endif
			next j

			!Segment Definitions
			if not(bFound) then
				nIsSegment[i] = 1
				distMin = 9999999
				for j = 1 to nTotalRefPoint-1
					if bIsLine[j] then
						if axisDistance[j][1] < distMin then
							distMin = axisDistance[j][1]
							nIsSegment[i] = j
						endif
					endif
				next j
			endif

			elementXY[i][1] = axisDistance[nIsSegment[i]][2]
			elementXY[i][2] = axisDistance[nIsSegment[i]][3]
			elementAngle[i] = refAngle[nIsSegment[i]]
		else
			elementXY[i][1] = elementPos[i][1]
			elementXY[i][2] = elementPos[i][2]
			elementAngle[i] = refAngle[nIsSegment[i]]
		endif
	endif

	!Position
	elementWidth[i][1] = elementXY[i][1]+cos(elementAngle[i])*elementSizes[i] / 2
	elementWidth[i][2] = elementXY[i][2]+sin(elementAngle[i])*elementSizes[i] / 2
	elementWidth[i][3] = elementXY[i][1]-cos(elementAngle[i])*elementSizes[i] / 2
	elementWidth[i][4] = elementXY[i][2]-sin(elementAngle[i])*elementSizes[i] / 2

	n = elementTypes[i][2]
	if n > 0 & n <= nMaxAccessory & bElemPosChanged[i] then

		if elementTypes[i][1] = SYMBTYPE_TALL & GLOB_MODPAR_NAME <> "tallCabinetWidth" & GLOB_MODPAR_NAME <> "tallCabinetWidth2" then
			tallCabPos[n][1]	= elementXY[i][1]
			tallCabPos[n][2]	= elementXY[i][2]
			tallCabPos2[n][1]	= elementXY[i][1]
			tallCabPos2[n][2]	= elementXY[i][2]
			nSegmentTall[n]		= nIsSegment[i]
			parameters	tallCabPos[n][1] 	= tallCabPos[n][1],
						tallCabPos[n][2] 	= tallCabPos[n][2],
						tallCabPos2[n][1]	= tallCabPos2[n][1],
						tallCabPos2[n][2]	= tallCabPos2[n][2],
						nSegmentTall[n]		= nSegmentTall[n]
		endif

		if elementTypes[i][1] = SYMBTYPE_SINK & GLOB_MODPAR_NAME <> "sinkWidth" & GLOB_MODPAR_NAME <> "sinkWidth2" & GLOB_MODPAR_NAME <> "sinkWidthHalf" then
			sinkPos[n][1]	= elementXY[i][1]
			sinkPos[n][2]	= elementXY[i][2]
			sinkPos2[n][1]	= elementXY[i][1]
			sinkPos2[n][2]	= elementXY[i][2]
			nSegmentSink[n]	= nIsSegment[i]
			parameters	sinkPos[n][1] 	= sinkPos[n][1],
						sinkPos[n][2] 	= sinkPos[n][2],
				 		sinkPos2[n][1]	= sinkPos2[n][1],
						sinkPos2[n][2]	= sinkPos2[n][2],
						nSegmentSink[n]	= nSegmentSink[n]
		endif

		if elementTypes[i][1] = SYMBTYPE_COOKTOP & GLOB_MODPAR_NAME <> "cooktopWidth" & GLOB_MODPAR_NAME <> "cooktopWidth2" then
			cooktopPos[n][1]	= elementXY[i][1]
			cooktopPos[n][2]	= elementXY[i][2]
			cooktopPos2[n][1]	= elementXY[i][1]
			cooktopPos2[n][2]	= elementXY[i][2]
			nSegmentCooktop[n]	= nIsSegment[i]
			parameters	cooktopPos[n][1]	= cooktopPos[n][1],
						cooktopPos[n][2]	= cooktopPos[n][2],
						sinkPos2[n][1]		= sinkPos2[n][1],
						sinkPos2[n][2]		= sinkPos2[n][2],
						nSegmentSink[n]		= nSegmentSink[n]
		endif

		if elementTypes[i][1] = SYMBTYPE_OVEN & GLOB_MODPAR_NAME <> "ovenWidth" & GLOB_MODPAR_NAME <> "ovenWidth2" then
			ovenPos[n][1]	= elementXY[i][1]
			ovenPos[n][2]	= elementXY[i][2]
			ovenPos2[n][1]	= elementXY[i][1]
			ovenPos2[n][2]	= elementXY[i][2]
			nSegmentOven[n]	= nIsSegment[i]
			parameters	ovenPos[n][1]	= ovenPos[n][1],
						ovenPos[n][2]	= ovenPos[n][2],
						ovenPos2[n][1]	= ovenPos2[n][1],
						ovenPos2[n][2]	= ovenPos2[n][2],
						nSegmentOven[n]	= nSegmentOven[n]
		endif

		if elementTypes[i][1] = SYMBTYPE_REFRI & GLOB_MODPAR_NAME <> "refrigeratorWidth" & GLOB_MODPAR_NAME <> "refrigeratorWidth2" then
			refrigeratorPos[n][1]	= elementXY[i][1]
			refrigeratorPos[n][2]	= elementXY[i][2]
			refrigeratorPos2[n][1]	= elementXY[i][1]
			refrigeratorPos2[n][2]	= elementXY[i][2]
			nSegmentRefri[n]		= nIsSegment[i]
			parameters	refrigeratorPos[n][1]	= refrigeratorPos[n][1],
						refrigeratorPos[n][2]	= refrigeratorPos[n][2],
						refrigeratorPos2[n][1]	= refrigeratorPos2[n][1],
						refrigeratorPos2[n][2]	= refrigeratorPos2[n][2],
						nSegmentRefri[n]		= nSegmentRefri[n]
		endif

		if elementTypes[i][1] = SYMBTYPE_DISHWASH & GLOB_MODPAR_NAME <> "dishwasherWidth" & GLOB_MODPAR_NAME <> "dishwasherWidth2" then
			dishwasherPos[n][1]		= elementXY[i][1]
			dishwasherPos[n][2]		= elementXY[i][2]
			dishwasherPos2[n][1]	= elementXY[i][1]
			dishwasherPos2[n][2]	= elementXY[i][2]
			nSegmentDishwasher[n]	= nIsSegment[i]
			parameters	dishwasherPos[n][1] = dishwasherPos[n][1],
						dishwasherPos[n][2] = dishwasherPos[n][2],
						dishwasherPos2[n][1]	= dishwasherPos2[n][1],
						dishwasherPos2[n][2]	= dishwasherPos2[n][2],
						nSegmentDishwasher[n]	= nSegmentDishwasher[n]
		endif

		if elementTypes[i][1] = SYMBTYPE_WASH & GLOB_MODPAR_NAME <> "washerWidth" & GLOB_MODPAR_NAME <> "washerWidth2" then
			washerPos[n][1]		= elementXY[i][1]
			washerPos[n][2]		= elementXY[i][2]
			washerPos2[n][1]	= elementXY[i][1]
			washerPos2[n][2]	= elementXY[i][2]
			nSegmentWasher[n]	= nIsSegment[i]
			parameters	washerPos[n][1] = washerPos[n][1],
						washerPos[n][2] = washerPos[n][2],
						washerPos2[n][1]	= washerPos2[n][1],
						washerPos2[n][2]	= washerPos2[n][2],
						nSegmentWasher[n]	= nSegmentWasher[n]
		endif
	endif

next i

dim bOvenInTall[]
for i = nofOvens to 1 step -1
	bOvenInTall[i] = 0
	for j = 1 to nTallCabinet
		if nSegmentOven[i] = nSegmentTall[j] then
			tx1 = cos(refAngle[nSegmentTall[j]]) * (tallCabinetWidth[j]/2-EPS)
			ty1 = sin(refAngle[nSegmentTall[j]]) * (tallCabinetWidth[j]/2-EPS)

			tx2 = sin(refAngle[nSegmentTall[j]]) * (counterDepth/2-EPS)
			ty2 = cos(refAngle[nSegmentTall[j]]) * (counterDepth/2-EPS)

			tx3 = sin(refAngle[nSegmentTall[j]]) * (-counterDepth/2+EPS)
			ty3 = cos(refAngle[nSegmentTall[j]]) * (-counterDepth/2+EPS)

			dim tallPolygon[5][2]
			srcPolygon[1][1] = tallCabPos[j][1] + tx1 + tx2
			srcPolygon[1][2] = tallCabPos[j][2] + ty1 - ty2
			srcPolygon[2][1] = tallCabPos[j][1] - tx1 + tx2
			srcPolygon[2][2] = tallCabPos[j][2] - ty1 - ty2
			srcPolygon[3][1] = tallCabPos[j][1] - tx1 + tx3
			srcPolygon[3][2] = tallCabPos[j][2] - ty1 - ty3
			srcPolygon[4][1] = tallCabPos[j][1] + tx1 + tx3
			srcPolygon[4][2] = tallCabPos[j][2] + ty1 - ty3
			srcPolygon[5][1] = tallCabPos[j][1] + tx1 + tx2
			srcPolygon[5][2] = tallCabPos[j][2] + ty1 - ty2
			pntX = ovenPos[i][1]
			pntY = ovenPos[i][2]

			gosub "pointInsidePolygon"

			if ret = 1 then
				bOvenInTall[i] = 1
			else
				bOvenInTall[i] = 0
			endif
		endif
	next j
next i


! ==============================================================================
!
! Wall Cabinet
!
! ==============================================================================

if nWallCabinet > 0 then
	bChange = (GLOB_MODPAR_NAME = "nWallCabinet" | bGeometryChanged)
	bWallChangeNum = bChange
	dim bWallCabChange[]
	if not(bChange) then
		for i = nWallCabinet to 1 step -1
			bWallCabChange[i]	= ( abs(wallCabinetPos_1[i][1] - wallCabinetPos2_1[i][1]) > EPS | \
									abs(wallCabinetPos_1[i][2] - wallCabinetPos2_1[i][2]) > EPS | \
									abs(wallCabinetPos_2[i][1] - wallCabinetPos2_2[i][1]) > EPS | \
									abs(wallCabinetPos_2[i][2] - wallCabinetPos2_2[i][2]) > EPS | \
									nWallSegment[i][1] = 0 | nWallSegment[i][2] = 0)
			if bWallCabChange[i] then bWallChangeNum = bWallChangeNum + 1
		next i
	else
		for i = nWallCabinet to 1 step -1
			bWallCabChange[i] = bChange
		next i
	endif

	if bWallChangeNum > 0 then

		! Calculate Wall Cabinet Axis Points
		dim	wallAxisPoints[][2]
		dim tempOffset[][2]
		offsetSize = wallCabinetDepth / 2
		gosub "polyLineOffset"
		wallAxisPoints = tempOffset

		dim wallOppside[][2]
		dim tempOffset[][2]
		offsetSize = wallCabinetDepth
		gosub "polyLineOffset"
		wallOppside = tempOffset

		dim bisectAngle[]
		dim axisSectDist[]

		for i = nTotalRefPoint - 1 to 2 step -1
			bisectAngle[i-1]	= (refAngle[i] - refAngle[i-1]) / 2
			axisSectDist[i-1]	= tan(bisectAngle[i-1]) * (wallCabinetDepth / 2)
		next i


		for i = nWallCabinet to 1 step -1
			if bWallCabChange[i] then
				dim wallElementXY[4]
				dim wallAxisDistance[][6]	!(1) distance, (2,3) projection points x,y
				dim srcPolygon[5][2]

				for j = nTotalRefPoint-1 to 1 step -1
					if bIsLine[j] then
						srcPolygon[1][1] = refLinePoints[j][1]
						srcPolygon[1][2] = refLinePoints[j][2]
						srcPolygon[2][1] = refLinePoints[j+1][1]
						srcPolygon[2][2] = refLinePoints[j+1][2]
						srcPolygon[3][1] = oppsidePoints[j+1][1]
						srcPolygon[3][2] = oppsidePoints[j+1][2]
						srcPolygon[4][1] = oppsidePoints[j][1]
						srcPolygon[4][2] = oppsidePoints[j][2]
						srcPolygon[5][1] = refLinePoints[j][1]
						srcPolygon[5][2] = refLinePoints[j][2]

						for h = 2 to 1 step -1
							if h = 1 then
								xp = wallCabinetPos_1[i][1]
								yp = wallCabinetPos_1[i][2]
							else
								xp = wallCabinetPos_2[i][1]
								yp = wallCabinetPos_2[i][2]
							endif

							x11 = wallAxisPoints[j][1]
							y11 = wallAxisPoints[j][2]
							x12 = wallAxisPoints[j+1][1]
							y12 = wallAxisPoints[j+1][2]

							bStartSegment	= 0
							bEndSegment		= 0
							if j = 1 then
								bStartSegment	= 1
							else
								if not(bIsLine[j-1]) then bStartSegment	= 1
							endif
							if j = nTotalRefPoint-1 then
								bEndSegment = 1
							else
								if not(bIsLine[j+1]) then bEndSegment = 1
							endif

							if bStartSegment & bEndSegment then
								gosub "pointLineDistance"
							else
								gosub "pointSegmentDistance"

								if state = 1 & bStartSegment then
									gosub "pointLineDistance"
								else
									if state = 2 & bEndSegment then
										gosub "pointLineDistance"
									endif
								endif
							endif

							wallAxisDistance[j][(h-1)*3+1] = dist
							wallAxisDistance[j][(h-1)*3+2] = xx
							wallAxisDistance[j][(h-1)*3+3] = yy

							pntX = xp
							pntY = yp
							gosub "pointInsidePolygon"
							if ret = 1 then wallAxisDistance[j][(h-1)*3+1] = wallAxisDistance[j][(h-1)*3+1] - counterDepth / 2
						next h
					endif
				next j


				!Segment Definitions
				nWallSegment[i][1] = 1
				nWallSegment[i][2] = 1
				distMin1 = 9999999
				distMin2 = 9999999
				for j = 1 to nTotalRefPoint-1
					if bIsLine[j] then
						if wallAxisDistance[j][1] < distMin1 then
							distMin1 = wallAxisDistance[j][1]
							nWallSegment[i][1] = j
						endif
						if wallAxisDistance[j][4] < distMin2 then
							distMin2 = wallAxisDistance[j][4]
							nWallSegment[i][2] = j
						endif
					endif
				next j

				wallElementXY[4] = wallAxisDistance[nWallSegment[i][2]][6]
				wallElementXY[3] = wallAxisDistance[nWallSegment[i][2]][5]
				wallElementXY[2] = wallAxisDistance[nWallSegment[i][1]][3]
				wallElementXY[1] = wallAxisDistance[nWallSegment[i][1]][2]

				wallCabinetPos_2[i][2]	= wallElementXY[4]
				wallCabinetPos_2[i][1]	= wallElementXY[3]
				wallCabinetPos_1[i][2]	= wallElementXY[2]
				wallCabinetPos_1[i][1]	= wallElementXY[1]

				parameters	wallCabinetPos_1[i][1]	= wallCabinetPos_1[i][1],
							wallCabinetPos_1[i][2]	= wallCabinetPos_1[i][2],
							wallCabinetPos_2[i][1]	= wallCabinetPos_2[i][1],
							wallCabinetPos_2[i][2]	= wallCabinetPos_2[i][2]

				parameters	wallCabinetPos2_1[i][1]	= wallCabinetPos_1[i][1],
							wallCabinetPos2_1[i][2]	= wallCabinetPos_1[i][2],
							wallCabinetPos2_2[i][1]	= wallCabinetPos_2[i][1],
							wallCabinetPos2_2[i][2]	= wallCabinetPos_2[i][2]


				! Continuous
				if nWallSegment[i][1] <= nWallSegment[i][2] then
					bWallReverse = 0
					tempSegment1 = nWallSegment[i][1]
					tempSegment2 = nWallSegment[i][2]
					tempXY1 = 1
					tempXY2 = 3
				else
					bWallReverse = 1
					tempSegment1 = nWallSegment[i][2]
					tempSegment2 = nWallSegment[i][1]
					tempXY1 = 3
					tempXY2 = 1
				endif

				isWallContinuous[i] = 1
				for j = tempSegment1 to tempSegment2
					if not(bIsLine[j]) then
						isWallContinuous[i] = 0
						j = tempSegment2
					endif
				next j
				parameters isWallContinuous[i] = isWallContinuous[i]


				! ----- Turning -----
				if isWallContinuous[i] & iLayoutType<>LAYOUT_STRAIGHT & iLayoutType<>LAYOUT_GALLEY & iLayoutType<>LAYOUT_ISLAND then
					bTurnEnd	= 0
					bTurnStart	= 0
					dim sectPoints[2][4]

					distStart1	= sqr( (wallAxisPoints[tempSegment1  ][1]-wallElementXY[tempXY1])^2 + (wallAxisPoints[tempSegment1  ][2]-wallElementXY[tempXY1+1])^2 )
					distStart2	= sqr( (wallAxisPoints[tempSegment1+1][1]-wallElementXY[tempXY1])^2 + (wallAxisPoints[tempSegment1+1][2]-wallElementXY[tempXY1+1])^2 )
					distEnd1	= sqr( (wallAxisPoints[tempSegment2  ][1]-wallElementXY[tempXY2])^2 + (wallAxisPoints[tempSegment2  ][2]-wallElementXY[tempXY2+1])^2 )
					distEnd2	= sqr( (wallAxisPoints[tempSegment2+1][1]-wallElementXY[tempXY2])^2 + (wallAxisPoints[tempSegment2+1][2]-wallElementXY[tempXY2+1])^2 )

					bStartSegment1	= 0
					bEndSegment1	= 0
					bStartSegment2	= 0
					bEndSegment2	= 0
					if tempSegment1 = 1 then
						bStartSegment1	= 1
					else
						if not(bIsLine[tempSegment1-1]) then bStartSegment1	= 1
					endif
					if tempSegment1 = nTotalRefPoint-1 then
						bEndSegment1 = 1
					else
						if not(bIsLine[tempSegment1+1]) then bEndSegment1 = 1
					endif

					if tempSegment2 = 1 then
						bStartSegment2	= 1
					else
						if not(bIsLine[tempSegment2-1]) then bStartSegment2	= 1
					endif
					if tempSegment2 = nTotalRefPoint-1 then
						bEndSegment2 = 1
					else
						if not(bIsLine[tempSegment2+1]) then bEndSegment2 = 1
					endif


					if bStartSegment1 then
						if distStart2 < abs(axisSectDist[tempSegment1])-EPS then

							x11 = refLinePoints[tempSegment1][1]
							y11 = refLinePoints[tempSegment1][2]
							x12 = refLinePoints[tempSegment1+1][1]
							y12 = refLinePoints[tempSegment1+1][2]

							x21 = wallOppside[tempSegment1+1][1]
							y21 = wallOppside[tempSegment1+1][2]
							x22 = wallOppside[tempSegment1+2][1]
							y22 = wallOppside[tempSegment1+2][2]

							gosub "intersection_Segment_Segment"

							if state = 1 then
								bTurnStart			= 1
								sectPoints[1][1]	= cx
								sectPoints[1][2]	= cy
								sectPoints[1][3]	= refLinePoints[tempSegment1+1][1]
								sectPoints[1][4]	= refLinePoints[tempSegment1+1][2]
								tempSegment1		= tempSegment1 + 1
							else
								if state = 2 then
									bTurnStart			= 1
									sectPoints[1][1]	= refLinePoints[tempSegment1+1][1] + cos(90-refAngle[tempSegment1]) * wallCabinetDepth
									sectPoints[1][2]	= refLinePoints[tempSegment1+1][2] - sin(90-refAngle[tempSegment1]) * wallCabinetDepth
									sectPoints[1][3]	= refLinePoints[tempSegment1+1][1]
									sectPoints[1][4]	= refLinePoints[tempSegment1+1][2]
								endif
							endif
						endif
					else
						if distStart1 < abs(axisSectDist[tempSegment1-1])-EPS then

							x11 = refLinePoints[tempSegment1-1][1]
							y11 = refLinePoints[tempSegment1-1][2]
							x12 = refLinePoints[tempSegment1][1]
							y12 = refLinePoints[tempSegment1][2]

							x21 = wallOppside[tempSegment1][1]
							y21 = wallOppside[tempSegment1][2]
							x22 = wallOppside[tempSegment1+1][1]
							y22 = wallOppside[tempSegment1+1][2]

							gosub "intersection_Segment_Segment"

							if state = 1 then
								bTurnStart			= 1
								sectPoints[1][1]	= cx
								sectPoints[1][2]	= cy
								sectPoints[1][3]	= refLinePoints[tempSegment1][1]
								sectPoints[1][4]	= refLinePoints[tempSegment1][2]
							else
								if state = 2 then
									bTurnStart			= 1
									sectPoints[1][1]	= refLinePoints[tempSegment1][1] + cos(90-refAngle[tempSegment1-1]) * wallCabinetDepth
									sectPoints[1][2]	= refLinePoints[tempSegment1][2] - sin(90-refAngle[tempSegment1-1]) * wallCabinetDepth
									sectPoints[1][3]	= refLinePoints[tempSegment1][1]
									sectPoints[1][4]	= refLinePoints[tempSegment1][2]
									tempSegment1		= tempSegment1 - 1
								endif
							endif
						else
							if not(bEndSegment1) then
								if distStart2 < abs(axisSectDist[tempSegment1])-EPS then

									x11 = refLinePoints[tempSegment1][1]
									y11 = refLinePoints[tempSegment1][2]
									x12 = refLinePoints[tempSegment1+1][1]
									y12 = refLinePoints[tempSegment1+1][2]

									x21 = wallOppside[tempSegment1+1][1]
									y21 = wallOppside[tempSegment1+1][2]
									x22 = wallOppside[tempSegment1+2][1]
									y22 = wallOppside[tempSegment1+2][2]

									gosub "intersection_Segment_Segment"

									if state = 1 then
										bTurnStart			= 1
										sectPoints[1][1]	= cx
										sectPoints[1][2]	= cy
										sectPoints[1][3]	= refLinePoints[tempSegment1+1][1]
										sectPoints[1][4]	= refLinePoints[tempSegment1+1][2]
										tempSegment1		= tempSegment1 + 1
									else
										if state = 2 then
											bTurnStart			= 1
											sectPoints[1][1]	= refLinePoints[tempSegment1+1][1] + cos(90-refAngle[tempSegment1]) * wallCabinetDepth
											sectPoints[1][2]	= refLinePoints[tempSegment1+1][2] - sin(90-refAngle[tempSegment1]) * wallCabinetDepth
											sectPoints[1][3]	= refLinePoints[tempSegment1+1][1]
											sectPoints[1][4]	= refLinePoints[tempSegment1+1][2]
											tempSegment1		= tempSegment1 - 1
										endif
									endif
								endif
							endif
						endif
					endif


					if bEndSegment2 & tempSegment2-1 > 0 then
						if distEnd1 < abs(axisSectDist[tempSegment2-1])-EPS then

							x11 = refLinePoints[tempSegment2][1]
							y11 = refLinePoints[tempSegment2][2]
							x12 = refLinePoints[tempSegment2+1][1]
							y12 = refLinePoints[tempSegment2+1][2]

							x21 = wallOppside[tempSegment2-1][1]
							y21 = wallOppside[tempSegment2-1][2]
							x22 = wallOppside[tempSegment2][1]
							y22 = wallOppside[tempSegment2][2]

							gosub "intersection_Segment_Segment"

							if state = 1 then
								if not(tempSegment1 = tempSegment2) then
									bTurnEnd			= 1
									sectPoints[2][1]	= cx
									sectPoints[2][2]	= cy
									sectPoints[2][3]	= refLinePoints[tempSegment2][1]
									sectPoints[2][4]	= refLinePoints[tempSegment2][2]
									tempSegment2		= tempSegment2 - 1
								endif
							else
								if state = 2 then
									bTurnEnd			= 1
									sectPoints[2][1]	= refLinePoints[tempSegment2][1] + cos(90-refAngle[tempSegment2]) * wallCabinetDepth
									sectPoints[2][2]	= refLinePoints[tempSegment2][2] - sin(90-refAngle[tempSegment2]) * wallCabinetDepth
									sectPoints[2][3]	= refLinePoints[tempSegment2][1]
									sectPoints[2][4]	= refLinePoints[tempSegment2][2]
								endif
							endif
						endif
					else
						if distEnd2 < abs(axisSectDist[tempSegment2])-EPS then

							x11 = refLinePoints[tempSegment2+1][1]
							y11 = refLinePoints[tempSegment2+1][2]
							x12 = refLinePoints[tempSegment2+2][1]
							y12 = refLinePoints[tempSegment2+2][2]

							x21 = wallOppside[tempSegment2][1]
							y21 = wallOppside[tempSegment2][2]
							x22 = wallOppside[tempSegment2+1][1]
							y22 = wallOppside[tempSegment2+1][2]

							gosub "intersection_Segment_Segment"

							if state = 1 then
								bTurnEnd			= 1
								sectPoints[2][1]	= cx
								sectPoints[2][2]	= cy
								sectPoints[2][3]	= refLinePoints[tempSegment2+1][1]
								sectPoints[2][4]	= refLinePoints[tempSegment2+1][2]
							else
								if state = 2 then
									bTurnEnd			= 1
									sectPoints[2][1]	= refLinePoints[tempSegment2+1][1] + cos(90-refAngle[tempSegment2+1]) * wallCabinetDepth
									sectPoints[2][2]	= refLinePoints[tempSegment2+1][2] - sin(90-refAngle[tempSegment2+1]) * wallCabinetDepth
									sectPoints[2][3]	= refLinePoints[tempSegment2+1][1]
									sectPoints[2][4]	= refLinePoints[tempSegment2+1][2]
									tempSegment2		= tempSegment2 + 1
								endif
							endif
						else
							if not(bStartSegment2) then
								if distEnd1 < abs(axisSectDist[tempSegment2-1])-EPS then

									x11 = refLinePoints[tempSegment2][1]
									y11 = refLinePoints[tempSegment2][2]
									x12 = refLinePoints[tempSegment2+1][1]
									y12 = refLinePoints[tempSegment2+1][2]

									x21 = wallOppside[tempSegment2-1][1]
									y21 = wallOppside[tempSegment2-1][2]
									x22 = wallOppside[tempSegment2][1]
									y22 = wallOppside[tempSegment2][2]

									gosub "intersection_Segment_Segment"

									if state = 1 then
										if not(tempSegment1 = tempSegment2) then
											bTurnEnd			= 1
											sectPoints[2][1]	= cx
											sectPoints[2][2]	= cy
											sectPoints[2][3]	= refLinePoints[tempSegment2][1]
											sectPoints[2][4]	= refLinePoints[tempSegment2][2]
										endif
									else
										if state = 2 then
											bTurnEnd			= 1
											sectPoints[2][1]	= refLinePoints[tempSegment2][1] + cos(90-refAngle[tempSegment2]) * wallCabinetDepth
											sectPoints[2][2]	= refLinePoints[tempSegment2][2] - sin(90-refAngle[tempSegment2]) * wallCabinetDepth
											sectPoints[2][3]	= refLinePoints[tempSegment2][1]
											sectPoints[2][4]	= refLinePoints[tempSegment2][2]
										endif
									endif
								endif
							else
								if distStart2 < abs(axisSectDist[tempSegment2])-EPS then

									x11 = refLinePoints[tempSegment2+1][1]
									y11 = refLinePoints[tempSegment2+1][2]
									x12 = refLinePoints[tempSegment2+2][1]
									y12 = refLinePoints[tempSegment2+2][2]

									x21 = wallOppside[tempSegment2][1]
									y21 = wallOppside[tempSegment2][2]
									x22 = wallOppside[tempSegment2+1][1]
									y22 = wallOppside[tempSegment2+1][2]

									gosub "intersection_Segment_Segment"

									if state = 1 then

										bTurnStart			= 1
										sectPoints[1][1]	= cx
										sectPoints[1][2]	= cy
										sectPoints[1][3]	= refLinePoints[tempSegment2+1][1]
										sectPoints[1][4]	= refLinePoints[tempSegment2+1][2]
									else
										if state = 2 then
											bTurnStart			= 1
											sectPoints[1][1]	= refLinePoints[tempSegment2+1][1] + cos(90-refAngle[tempSegment2+1]) * wallCabinetDepth
											sectPoints[1][2]	= refLinePoints[tempSegment2+1][2] - sin(90-refAngle[tempSegment2+1]) * wallCabinetDepth
											sectPoints[1][3]	= refLinePoints[tempSegment2+1][1]
											sectPoints[1][4]	= refLinePoints[tempSegment2+1][2]
											tempSegment2		= tempSegment2 + 1
										endif
									endif
								endif
							endif
						endif
					endif
				endif

				if bWallReverse then
					nWallSegment[i][2]	= tempSegment1
					nWallSegment[i][1]	= tempSegment2
				else
					nWallSegment[i][1]	= tempSegment1
					nWallSegment[i][2]	= tempSegment2
				endif
				parameters	nWallSegment[i][1] = nWallSegment[i][1],
							nWallSegment[i][2] = nWallSegment[i][2]


				! ----- Route ----
				if isWallContinuous[i] then
					nWallContour[i]				= max(0, tempSegment2 - tempSegment1) + 2
					nCol						= nWallContour[i] * 2

					if bTurnEnd then
						wallCoords1[i][nCol]	= sectPoints[2][4]	: nCol = nCol - 1
						wallCoords1[i][nCol]	= sectPoints[2][3]	: nCol = nCol - 1
					else
						wallCoords1[i][nCol]	= wallElementXY[tempXY2+1] + sin(90-refAngle[tempSegment2]) * wallCabinetDepth / 2	: nCol = nCol - 1
						wallCoords1[i][nCol]	= wallElementXY[tempXY2  ] - cos(90-refAngle[tempSegment2]) * wallCabinetDepth / 2	: nCol = nCol - 1
					endif

					for j = tempSegment2 to tempSegment1+1 step -1
						wallCoords1[i][nCol]	= refLinePoints[j][2]	: nCol = nCol - 1
						wallCoords1[i][nCol]	= refLinePoints[j][1]	: nCol = nCol - 1
					next j

					if bTurnStart then
						wallCoords1[i][nCol]	= sectPoints[1][4]	: nCol = nCol - 1
						wallCoords1[i][nCol]	= sectPoints[1][3]	: nCol = nCol - 1
					else
						wallCoords1[i][nCol]	= wallElementXY[tempXY1+1] + sin(90-refAngle[tempSegment1]) * wallCabinetDepth / 2	: nCol = nCol - 1
						wallCoords1[i][nCol]	= wallElementXY[tempXY1  ] - cos(90-refAngle[tempSegment1]) * wallCabinetDepth / 2	: nCol = nCol - 1
					endif


					nCol						= nWallContour[i] * 2
					if bTurnEnd then
						wallCoords2[i][nCol]	= sectPoints[2][2]	: nCol = nCol - 1
						wallCoords2[i][nCol]	= sectPoints[2][1]	: nCol = nCol - 1
					else
						wallCoords2[i][nCol]	= wallElementXY[tempXY2+1] - sin(90-refAngle[tempSegment2]) * wallCabinetDepth / 2	: nCol = nCol - 1
						wallCoords2[i][nCol]	= wallElementXY[tempXY2  ] + cos(90-refAngle[tempSegment2]) * wallCabinetDepth / 2	: nCol = nCol - 1
					endif

					for j = tempSegment2 to tempSegment1+1 step -1
						wallCoords2[i][nCol]	= wallOppside[j][2]	: nCol = nCol - 1
						wallCoords2[i][nCol]	= wallOppside[j][1]	: nCol = nCol - 1
					next j

					if bTurnStart then
						wallCoords2[i][nCol]	= sectPoints[1][2]	: nCol = nCol - 1
						wallCoords2[i][nCol]	= sectPoints[1][1]	: nCol = nCol - 1
					else
						wallCoords2[i][nCol]	= wallElementXY[tempXY1+1] - sin(90-refAngle[tempSegment1]) * wallCabinetDepth / 2	: nCol = nCol - 1
						wallCoords2[i][nCol]	= wallElementXY[tempXY1  ] + cos(90-refAngle[tempSegment1]) * wallCabinetDepth / 2	: nCol = nCol - 1
					endif

				else

					dx = wallElementXY[tempXY2  ] - wallElementXY[tempXY1]
					dy = wallElementXY[tempXY2+1] - wallElementXY[tempXY1+1]
					if abs(dx) < EPS then
						if dy > 0 then
							wallAngle = 90
						else
							wallAngle = 270
						endif
					else
						wallAngle = atn(dy/dx)
						if dx > 0 then wallAngle = wallAngle + 180
					endif

					nWallContour[i]		= 2
					wallCoords1[i][4]	= wallElementXY[tempXY2+1] - sin(90-wallAngle) * wallCabinetDepth / 2
					wallCoords1[i][3]	= wallElementXY[tempXY2  ] + cos(90-wallAngle) * wallCabinetDepth / 2
					wallCoords1[i][2]	= wallElementXY[tempXY1+1] - sin(90-wallAngle) * wallCabinetDepth / 2
					wallCoords1[i][1]	= wallElementXY[tempXY1  ] + cos(90-wallAngle) * wallCabinetDepth / 2

					wallCoords2[i][4]	= wallElementXY[tempXY2+1] + sin(90-wallAngle) * wallCabinetDepth / 2
					wallCoords2[i][3]	= wallElementXY[tempXY2  ] - cos(90-wallAngle) * wallCabinetDepth / 2
					wallCoords2[i][2]	= wallElementXY[tempXY1+1] + sin(90-wallAngle) * wallCabinetDepth / 2
					wallCoords2[i][1]	= wallElementXY[tempXY1  ] - cos(90-wallAngle) * wallCabinetDepth / 2

				endif

				parameters nWallContour[i] = nWallContour[i]
				for j = 1 to nWallContour[i]
					parameters	wallCoords1[i][j*2-1]	= wallCoords1[i][j*2-1],
								wallCoords1[i][j*2]		= wallCoords1[i][j*2],
								wallCoords2[i][j*2-1]	= wallCoords2[i][j*2-1],
								wallCoords2[i][j*2]		= wallCoords2[i][j*2]
				next j

			endif
		next i
	endif
endif


! ------------------------------------------------------------------------------
! Accessories
! ------------------------------------------------------------------------------
if nofSink > 0 then
	gs_sink_type_m = 1
	!if iSinkType = ACC_SINK_ROUND			then gs_sink_type_m = 1
	if iSinkType = ACC_SINK_SINGLE			then gs_sink_type_m = 2
	if iSinkType = ACC_SINK_SINGLE_DRAIN	then gs_sink_type_m = 4
	if iSinkType = ACC_SINK_DOUBLE			then gs_sink_type_m = 3
	if iSinkType = ACC_SINK_DOUBLE_DRAIN	then gs_sink_type_m = 9
	if iSinkType = ACC_SINK_TRIPLE			then gs_sink_type_m = 8
endif

if nofCooktops > 0 then
	CooktopType_m = 2
	!if iCooktopType = ACC_COOKTOP_2	then CooktopType_m = 2
	if iCooktopType = ACC_COOKTOP_4		then CooktopType_m = 6
	if iCooktopType = ACC_COOKTOP_5		then CooktopType_m = 11

	if bHood then
		dim hoodWidthPos[][6]
		for i = nofCooktops to 1 step -1
			tx = sin(elementAngle[isCooktop[i]]) * counterDepth/2
			ty = cos(elementAngle[isCooktop[i]]) * counterDepth/2

			hoodWidthPos[i][1] = cooktopPos[i][1]-tx
			hoodWidthPos[i][2] = cooktopPos[i][2]+ty
			hoodWidthPos[i][3] = hoodWidthPos[i][1]+cos(elementAngle[isCooktop[i]])*hoodWidth[i] / 2
			hoodWidthPos[i][4] = hoodWidthPos[i][2]+sin(elementAngle[isCooktop[i]])*hoodWidth[i] / 2
			hoodWidthPos[i][5] = hoodWidthPos[i][1]-cos(elementAngle[isCooktop[i]])*hoodWidth[i] / 2
			hoodWidthPos[i][6] = hoodWidthPos[i][2]-sin(elementAngle[isCooktop[i]])*hoodWidth[i] / 2
		next i
	endif
endif

displayText =	nofOvens *			(iOvenSymbType		 = SYMBTYPE_TEXT) + \
				nofRefrigerators *	(iRefriSymbType		 = SYMBTYPE_TEXT) + \
				nofDishwasher *		(iDishwasherSymbType = SYMBTYPE_TEXT) + \
				nofWasher *			(iWasherSymbType	 = SYMBTYPE_TEXT)


! ==============================================================================
!
! End of Master Script
!
! ==============================================================================

goto "endMasterSript"

! ==============================================================================
! PolyLineOffset
! ------------------------------------------------------------------------------
! Input variables:
!	offsetSize:
!	refLinePoints[][2]:
!	bIsLine[]:
!	refAngle[]:
!	bIsSect[]:
! Returned variable:
!	tempOffset[][2]
! ==============================================================================
"polyLineOffset":
	dim tempPoints[][2]

	for i = nTotalRefPoint-1 to 1 step -1
		cx1 = refLinePoints[i][1] + cos(90-refAngle[i]) * offsetSize
		cy1 = refLinePoints[i][2] - sin(90-refAngle[i]) * offsetSize

		cx2 = refLinePoints[i+1][1] + cos(90-refAngle[i]) * offsetSize
		cy2 = refLinePoints[i+1][2] - sin(90-refAngle[i]) * offsetSize

		tempPoints[i*2-1][1]	= cx1
		tempPoints[i*2-1][2]	= cy1
		tempPoints[i*2][1]		= cx2
		tempPoints[i*2][2]		= cy2
	next i

	for i = nTotalRefPoint to 1 step -1
		if bIsSect[i] then
			x11 = tempPoints[i*2][1]
			y11 = tempPoints[i*2][2]
			x12 = tempPoints[i*2-1][1]
			y12 = tempPoints[i*2-1][2]

			x21 = tempPoints[(i-1)*2-1][1]
			y21 = tempPoints[(i-1)*2-1][2]
			x22 = tempPoints[(i-1)*2][1]
			y22 = tempPoints[(i-1)*2][2]

			gosub "intersection_Line_Line"
			if state = 1 then
				tempOffset[i][1] = cx
				tempOffset[i][2] = cy
			else
				tempOffset[i][1] = tempPoints[i*2-1][1]
				tempOffset[i][2] = tempPoints[i*2-1][2]
			endif
		else
			if i = 1 then
				tempOffset[i][1] = tempPoints[1][1]
				tempOffset[i][2] = tempPoints[1][2]
			else
				if i = nTotalRefPoint then
					tempOffset[i][1] = tempPoints[(i-1)*2][1]
					tempOffset[i][2] = tempPoints[(i-1)*2][2]
				else
					if bIsLine[i] & not(bIsLine[i-1]) then
						tempOffset[i][1] = tempPoints[i*2-1][1]
						tempOffset[i][2] = tempPoints[i*2-1][2]
					else
						if not(bIsLine[i]) & bIsLine[i-1] then
							tempOffset[i][1] = tempPoints[(i-1)*2][1]
							tempOffset[i][2] = tempPoints[(i-1)*2][2]
						else
							!Nothing
							tempOffset[i][1] = 0
							tempOffset[i][2] = 0
						endif
					endif
				endif
			endif
		endif
	next i
return


! ==============================================================================
! Fill Polygon Contour
! ------------------------------------------------------------------------------
! Input variables:
!	nCurrentPoly:	current polygon number
!	startRef:		actual start point number
! Returned variable:
!	contourPoints:
!	nContour:
! ==============================================================================
"fillContour":
	cur = startRef

	if not(bIsLine[startRef]) then
		for k = startRef to nTotalRefPoint-1
			if bIsLine[k] then
				startRef = k
				cur = startRef
				k = nTotalRefPoint - 1
			endif
		next k
	endif

	for k = startRef to nTotalRefPoint
		put refLinePoints[cur][1], refLinePoints[cur][2]

		if k < nTotalRefPoint then
			if not(bIsLine[cur]) then
				k = nTotalRefPoint
			endif
		endif

		cur = cur + 1
	next k

	if (cur-1) > startRef then
		for k = (cur-1) to startRef step -1
			put oppsidePoints[k][1], oppsidePoints[k][2]
		next k
	endif

	if nsp > 7 then
		nContour[nCurrentPoly] = nsp/2
		pnum = nsp
		for k = 1 to pnum
			contourPoints[nCurrentPoly][k] = get(1)
		next k
	else
		print "Error in fill poly", nsp, cur
		for k = 1 to nsp
			temp = get(1)
		next k
	endif
return


! ==============================================================================
! Direction Angle
! ------------------------------------------------------------------------------
! Input variables:
!	vx, vy:		vector
!
! Returned variable:
!	angle:		direction angle of the vector
! ==============================================================================

"directionAngle":
	if abs(vx) < EPS & abs(vy) < EPS then
		angle = 0
		return
	endif

	if abs(vx) < EPS then
		if vy > 0 then
			angle = 90
		else
			angle = 270
		endif
	else
		angle = atn(vy / vx)
		if vx >= 0 then
			if angle < 0 then
				angle = angle + 360
			endif
		else
			angle = 180 + angle
		endif
	endif
return


! ==============================================================================
! Line - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12	line #1
!	x21,y21, x22,y22	line #2
!
! Returned variables:
!	state:			   -1 = no intersection point, coincident lines
!						0 = no intersection point, parallel lines
!						1 = valid intersection point
!	cx, cy:				intersection point
! ==============================================================================

"intersection_Line_Line":
	v1x = x11-x12
	v2x = x21-x22
	v1y = y11-y12
	v2y = y21-y22

	lliDiv = v1x * v2y - v1y * v2x

	temp1 = x11 * y12 - y11 * x12
	temp2 = x21 * y22 - y21 * x22

	if abs(lliDiv) > EPS then
		! Intersection

		tempx = temp1 * v2x - v1x * temp2
		tempy = temp1 * v2y - v1y * temp2

		state = 1
		cx = (tempx / lliDiv)
		cy = (tempy / lliDiv)
	else
		! No Intersection
		cx = 0
		cy = 0
		if abs(abs(temp1) - abs(temp2)) < EPS then
			state = -1			! Coincident lines
		else
			state = 0			! Paralel
		endif

	endif

return


! ==============================================================================
! Segment - Segment intersection
! ==============================================================================
! Input:
!	EPS:				epsylon
!	x11,y11, x12,y12	line #1
!	x21,y21, x22,y22	line #2
!
! Output:
!	ret:			output status
!						-1: no intersection, segments is not parallel
!						 0: no intersection, parallel segments
!						 1: intersection point lies on S1 segment, but not lies on S2
!						 2: intersection point lies on S2 segment, but not lies on S1
!						 3: intersection point lies on both segments
!	cx:				intersection point X
!	cy:				intersection point Y
! ==============================================================================

"intersection_Segment_Segment":
	gosub "intersection_Line_Line"

	if state then
		state = 0

		if abs(x11 - x12) < EPS then
			if (y11-EPS <= cy & cy <= y12+EPS) | (y11+EPS >= cy & cy >= y12-EPS) then state = 1
		else
			if (x11-EPS <= cx & cx <= x12+EPS) | (x11+EPS >= cx & cx >= x12-EPS) then state = 1
		endif
		if abs(x21 - x22) < EPS then
			if (y21-EPS <= cy & cy <= y22+EPS) | (y21+EPS >= cy & cy >= y22-EPS) then state = state + 2
		else
			if (x21-EPS <= cx & cx <= x22+EPS) | (x21+EPS >= cx & cx >= x22-EPS) then state = state + 2
		endif

		if state = 0 then state = -1
	endif
return


! ==============================================================================
! Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	xo,yo,ro:			circle
!	x1,y1, x2,y2		line
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = one intersection point (tangential line)
!						2 = two intersection points
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
! ==============================================================================

"intersection_Circle_Line":
	tempX1 = x1 - xo: tempY1 = y1 - yo
	tempX2 = x2 - xo: tempY2 = y2 - yo

	if abs(tempX2 - tempX1) < EPS then				!!Függöleges
		if abs(ro - tempX1) < EPS then				!!Függöleges érintő
			state = 1
			xa = tempX1
			ya = 0
			xb = tempX1
			yb = 0
		else
			if -ro < tempX1 & ro > tempX1 then		!! Vonal függölegesen kétponton metszi kört
				state = 2
				xa = tempX1
				ya = sqr(abs(ro^2 - tempX1^2))
				xb = tempX1
				yb = -sqr(abs(ro^2 - tempX1^2))

			else
				state = 0: xa = 0: ya = 0: xb = 0: yb = 0
			endif
		endif
	else
		kf = (tempY2 - tempY1) / (tempX2 - tempX1)
		ad = 1 + kf^2
		bd = 2 * tempY1 * kf - 2 * tempX1 * kf^2
		cd = tempY1^2 - 2 * tempX1 * tempY1 * kf + tempX1^2 * kf^2 - ro^2

		if bd^2 - 4 * ad * cd < 0 then
			state = 0: xa = 0: ya = 0: xb = 0: yb = 0
		else
			xa = (-bd + sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			ya = tempY1 + (xa - tempX1) * kf
			xb = (-bd - sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			yb = tempY1 + (xb - tempX1) * kf

			if abs(xa - xb) < EPS then state = 1 else state = 2
		endif
	endif

	if state = 2 then
		da = sqr((tempX1 - xa)^2 + (tempY1 - ya)^2)
		db = sqr((tempX1 - xb)^2 + (tempY1 - yb)^2)

		if db < da then
			xxo = xa: yyo = ya
			xa = xb:  ya = yb
			xb = xxo: yb = yyo
		endif
	endif

	xa = xa + xo: ya = ya + yo
	xb = xb + xo: yb = yb + yo
return


! ==============================================================================
! Circle - Circle Intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x1,y1,r1			circle #1
!	x2,y2,r2			circle #2
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = one intersection point (tangential line)
!						2 = two intersection points
!	xa, ya:				intersection point #1
!	ya, yb:				intersection point #2
! ==============================================================================

"intersection_Circle_Circle":
	vx =	x2-x1
	vy =	y2-y1
	gosub "directionAngle"


	d = sqr( (vx)^2+(vy)^2 )

	if d>(r1+r2) or abs(d)<EPS then 	! No Intersection
		state = 0
		return
	endif

	if abs(d-(r1+r2))<EPS then 			! One Intersection

		state =  1
		xa = x1 + ((x2-x1)*r1)/(r1+r2)
		ya = y1 + ((y2-y1)*r1)/(r1+r2)

		xb = xa
		yb = ya
		return
	endif


	! Check if one circle inside the another

	x = (d^2 - r2^2 + r1^2) / (2*d)
	y = sqr(abs(4*d^2*r1^2-(d^2-r2^2+r1^2)^2))/(d*2)
	xa = x1 + y*sin(-angle) + x*cos(-angle)
	ya = y1 + y*cos(-angle) - x*sin(-angle)
	xb = x1 - y*sin(-angle) + x*cos(-angle)
	yb = y1 - y*cos(-angle) - x*sin(-angle)

	state =	2
return


! ==============================================================================
! Segment - Point Distance 2D
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12	line
!	xp, yp				point
!
! Returned variables:
!	state:				0 = projections
!						1 = beyond the 'x11,y11' end of segment
!						2 = beyond the 'x12,y12' end of segment
!	dist				distance
!	xx,yy				projection points
! ==============================================================================

"pointSegmentDistance":
	tempA = xp - x11
	tempB = yp - y11
	tempC = x12 - x11
	tempD = y12 - y11

	tempDot = tempA * tempC + tempB * tempD
	tempLengthSq = tempC * tempC + tempD * tempD
	if abs(tempLengthSq) < EPS then
		tempPar = -1
	else
		tempPar	= tempDot / tempLengthSq
	endif

	if (tempPar < 0) then
		xx = x11
		yy = y12
		state = 1
	else
		if (tempPar > 1) then
			xx = x12
			yy = y12
			state = 2
		else
			xx = x11 + tempPar * tempC
			yy = y11 + tempPar * tempD
			state = 0
		endif
	endif

	dist = sqr((xp-xx)^2 + (yp-yy)^2)
return


! ==============================================================================
! Segment - Point Distance 2D
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12	line
!	xp, yp				point
!
! Returned variables:
!	dist				distance
!	xx,yy				projection points
! ==============================================================================

"pointLineDistance":
	tempA = xp - x11
	tempB = yp - y11
	tempC = x12 - x11
	tempD = y12 - y11

	tempDot = tempA * tempC + tempB * tempD
	tempLengthSq = tempC * tempC + tempD * tempD
	if abs(tempLengthSq) < EPS then
		tempPar	= tempDot
	else
		tempPar	= tempDot / tempLengthSq
	endif

	xx = x11 + tempPar * tempC
	yy = y11 + tempPar * tempD

	dist = sqr((xp-xx)^2 + (yp-yy)^2)
return


! ==============================================================================
! Point inside polygon check
! ==============================================================================
! Input:
!	srcPolygon:		input source of polygon
!	pntX:			point X
!	pntY:			point Y
! Output:
!	ret:			output status
!						0: Error
!						1: Inside
!						2: Outside
!						3: On Edge
!						4: On Point
! ==============================================================================
! Remarks:
!	The polygon can be convex or concave too
!	It works with polygons containing straight segments only
!	The polygon can't contains holes
!	The input polygon from polygon must be closed
! ==============================================================================
"pointInsidePolygon":
	pipNumPnts = vardim1(srcPolygon)
	if pipNumPnts = 0 then return	! Error

	ret = 0		! Error
	pipEnd = 0
	pipIntersection = 0

	pipX0 = srcPolygon[pipNumPnts - 1][1]
	pipY0 = srcPolygon[pipNumPnts - 1][2]
	pipX1 = srcPolygon[1][1]
	pipY1 = srcPolygon[1][2]

	for pipI=1 to pipNumPnts - 1

		! Point on polygon vertex test
		if abs(pipX1 - pntX) < EPS & abs(pipY1 - pntY) < EPS then
			ret		= 4					! OnPoint
			pipI	= pipNumPnts - 1	! Force end loop
			pipEnd	= 1
		endif

		! Point on edge test
		pipSegLength = sqr((pipX0 - pipX1)^2 + (pipY0 - pipY1)^2)
		if pipSegLength > EPS & not(pipEnd) then
			if abs(abs((pipY0 - pipY1) * (pntX - pipX1) - (pipX0 - pipX1) * (pntY - pipY1)) / pipSegLength) < EPS then
				ret		= 3					! OnEdge
				pipI	= pipNumPnts - 1	! Force end loop
				pipEnd	= 1
			endif
		endif

		pipX2 = srcPolygon[pipI + 1][1]
		pipY2 = srcPolygon[pipI + 1][2]

		x11 = pipX1
		y11 = pipY1
		x12 = pipX2
		y12 = pipY2
		x21 = pntX
		y21 = pntY
		x22 = pntX + 1000
		y22 = pntY

		gosub "intersection_Segment_Segment"		! Result: state, cx,cy

		if state = 3 then
			if abs(x12 - cx) > EPS | abs(y12 - cy) > EPS then
				if abs(x11 - cx) < EPS & abs(y11 - cy) < EPS then
					if sgn(pipY0 - pntY) <> sgn(pipY2 - pntY) then
						pipIntersection = pipIntersection + 1
					endif
				else
					pipIntersection = pipIntersection + 1
				endif
			endif
		endif

		pipX0 = pipX1
		pipY0 = pipY1

		pipX1 = pipX2
		pipY1 = pipY2
	next pipI

	if pipEnd then return	! Already have valid result

	if (pipIntersection % 2 = 0) then	! Outside
		ret = 2
	else	! Inside
		ret = 1
	endif
return


! ==============================================================================
! GET GDL Polygon
! ------------------------------------------------------------------------------
! Input variables:
!	ch:				Channel ID
!	polygonID:		Polygon ID
!	mask:
!
! Returned variables:
!	GDL stack:			GDL polygon
! ==============================================================================

"getGDLpolygonFromAPI":
	dim resVertices[]
	numVertices = CALLFUNCTION (ch, "GetVertices", polygonID, resVertices)
	numVertices = numVertices / 3

	dim contArr[]
	numContours = CALLFUNCTION (ch, "GetContourEnds", polygonID, contArr)

	!dim inhEdgeInfos[]
	!numEdges = CALLFUNCTION (ch, "GetInhEdgeInfos", polygonID, inhEdgeInfos)

	for contIndex = 1 to numContours
		if contIndex = 1 then
			begIdx = 0
		else
			begIdx = endIdx +1
		endif
		if contIndex = numContours then
			endIdx = numVertices - 1
		else
			endIdx = contArr[contIndex + 1] - 2 -(contIndex - 1)
		endif

		bClosed = 0
		bStartWithLast = 0

		index = endIdx * 3
		lastVertX = resVertices[index + 1]
		lastVertY = resVertices[index + 2]
		lastVertA = resVertices[index + 3]
		!edgeInfo  = inhEdgeInfos[endIdx + 1]

		if abs(lastVertA) > EPS then
			put lastVertX, lastVertY, mask
			bStartWithLast = 1
		endif

		for vertIndex = begIdx to endIdx
			index = vertIndex * 3
			actVertX = resVertices[index + 1]
			actVertY = resVertices[index + 2]
			actVertA = resVertices[index + 3]

			! ------------------------------------------------------------------------------
			! Show inherited edge information number
			! ------------------------------------------------------------------------------
			!
			!			text2	(lastVertX + actVertX) / 2,
			!					(lastVertY + actVertY) / 2,
			!					edgeInfo
			! ------------------------------------------------------------------------------

			if vertIndex = begIdx then
				if bStartWithLast then
					ac2gdl_spx = lastVertX
					ac2gdl_spy = lastVertY
				else
					ac2gdl_spx = actVertX
					ac2gdl_spy = actVertY
				endif
			endif

			!if abs(lastVertA) > EPS then
			!	ac2gdl_mx = (actVertX + lastVertX) / 2
			!	ac2gdl_my = (actVertY + lastVertY) / 2
			!	ac2gdl_ratio = 1 / 2 / tan (lastVertA / 2)
			!
			!	ac2gdl_cx = ac2gdl_mx - ac2gdl_ratio * (actVertY - lastVertY)	! Arc center
			!	ac2gdl_cy = ac2gdl_my + ac2gdl_ratio * (actVertX - lastVertX)
			!
			!	put ac2gdl_cx,	ac2gdl_cy,	900+mask,
			!		0,			lastVertA,	4000+mask
			!else
			!	if edgeInfo then
			!		line2 lastVertX, lastVertY, actVertX, actVertY
			!	endif
			!endif

			bPointMatch = 0
			if vertIndex = endIdx then
				if abs(ac2gdl_spx - actVertX) < EPS & abs(ac2gdl_spy - actVertY) < EPS then
					put actVertX, actVertY, -1
					bClosed		= 1
					bPointMatch = 1
				endif
			endif
			if not(bPointMatch) then
				if vertIndex < endIdx | not(bStartWithLast) then
					if abs(lastVertX - actVertX) > EPS | abs(lastVertY - actVertY) > EPS then
						!edgeInfo  = inhEdgeInfos[vertIndex + 1]
						put actVertX, actVertY, mask
					endif
				endif
			endif

			lastVertX = actVertX
			lastVertY = actVertY
			lastVertA = actVertA

		next vertIndex

		if not(bClosed) then	! Close the polygon if it has holes
			put ac2gdl_spx, ac2gdl_spy, -1
		endif

	next contIndex
return


! ==============================================================================
!
! End of Macros Script
!
! ==============================================================================

"endMasterSript":


]]>
</Script_1D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_PR SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_PR>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_UI SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! =============================================================================
! Tabpage Structure Definition
! =============================================================================
TABID_Root 				= - 1
_idxTab = 1
TABID_Layout					= _idxTab  : _idxTab = _idxTab + 1
TABID_Accessories				= _idxTab  : _idxTab = _idxTab + 1
TABID_RepresentationAndSurfaces	= _idxTab  : _idxTab = _idxTab + 1
TABID_SymbolText				= _idxTab  : _idxTab = _idxTab + 1
TABID_Descriptions				= _idxTab  : _idxTab = _idxTab + 1

! =============================================================================
! Display actual tabpages
! =============================================================================
ui_dialog `Параметры Кухни`
ui_current_page gs_ui_current_page

ui_page TABID_Layout, TABID_Root, `Планировка, Размеры и Минимальное Пространство`, "uiTab_Dimension_flat(1)"
	gosub "layoutPage"

ui_page TABID_Accessories, TABID_Root, `Аксессуары`, "uiTab_Cooktops_flat(1)"
	gosub "accessoriesPage"

ui_page TABID_RepresentationAndSurfaces, TABID_Root, `Отображение и Покрытия`, "uiTab_2DRepr_flat(1)"
	gosub "representationpage"

ui_page TABID_SymbolText, TABID_Root, `Текст Символа`, "uiTab_Text_flat(1)"
	gosub "symboltextpage"

ui_page TABID_Descriptions, TABID_Root, `Характеристики`, "uiTab_Descriptions_flat(1)"
	gosub "Descriptionspage"

! --------------------------------------------------------------------------------
! Image links for archive
! --------------------------------------------------------------------------------
file_dependence "uiTab_Dimension_flat(1)"
file_dependence "uiTab_Cooktops_flat(1)"
file_dependence "uiTab_2DRepr_flat(1)"
file_dependence "uiTab_Text_flat(1)"
file_dependence "uiTab_Descriptions_flat(1)"

! ==============================================================================
end
! ==============================================================================


! ==============================================================================
!Subroutines
! ==============================================================================

! ------------------------------------------------------------------------------
"layoutPage":
! ------------------------------------------------------------------------------

	pageStartY 	= 0
	_yOffset 	= 4
	x1			= 5
	xEndLevel	= 439
	yStart		= pageStartY + _yOffset
	lineSpace	= 24
	hRow		= 15
	yInfield	= 19

	xHalfLevel 	= 148
	xMargin1	= 6
	x2			= xHalfLevel + xMargin1 + 1
	x3			= 348
	x4			= 296
	wInteger	= 50
	wLength		= 90

	lineSpace	= 28

	! ------ 1. Column - Layout -------

	ui_style 0, 1
	ui_outfield `Планировка`,	x1,		yStart,	xHalfLevel-x1-xMargin1,	hRow					! Layout
	ui_style 0, 0
	y1 = pageStartY+22

	ui_infield{3} "layoutType", x1, y1, 138, 95,
		2, 15,
		6, 1,
		59, 69, 55, 65,
		1, stLayoutType[1], stLayoutType[1],
		2, stLayoutType[2], stLayoutType[2],
		3, stLayoutType[3], stLayoutType[3],
		4, stLayoutType[4], stLayoutType[4],
		5, stLayoutType[5], stLayoutType[5],
		6, stLayoutType[6], stLayoutType[6]
	y1 = pageStartY+22 + 109

	iFlag = (iLayoutType <> LAYOUT_CUSTOM) * 4
	ui_outfield `Столешницы`,	x1,	y1,	xHalfLevel-x1-xMargin1-wInteger, hRow, iFlag			! Counters
	if iLayoutType = LAYOUT_CUSTOM then
		ui_infield "nChains",	xHalfLevel-xMargin1-wInteger+2, y1-4, wInteger, yInfield
	else
		ui_infield "nCounterForUI",	xHalfLevel-xMargin1-wInteger+2, y1-4, wInteger, yInfield
	endif
	y1 = y1 + lineSpace

	ui_outfield `Сегменты (1)`,	x1,	y1,	xHalfLevel-x1-xMargin1-wInteger, hRow, iFlag			! Segments(1)
	if iLayoutType = LAYOUT_CUSTOM then
		ui_infield "nChainSegment_1",	xHalfLevel-xMargin1-wInteger+2, y1-4, wInteger, yInfield
	else
		ui_infield "nSegmentForUI_1",	xHalfLevel-xMargin1-wInteger+2, y1-4, wInteger, yInfield
	endif
	y1 = y1 + lineSpace

	iFlag = not(bChains[2]) * 4
	ui_outfield `Сегменты (2)`,	x1,	y1,	xHalfLevel-x1-xMargin1-wInteger, hRow, iFlag			! Segments(2)
	if iLayoutType = LAYOUT_CUSTOM then
		ui_infield "nChainSegment_2",	xHalfLevel-xMargin1-wInteger+2, y1-4, wInteger, yInfield
	else
		ui_infield "nSegmentForUI_2",	xHalfLevel-xMargin1-wInteger+2, y1-4, wInteger, yInfield
	endif
	y1 = y1 + lineSpace

	iFlag = not(bChains[3]) * 4
	ui_outfield `Сегменты (3)`,	x1,	y1,	xHalfLevel-x1-xMargin1-wInteger, hRow, iFlag			! Segments(3)
	if iLayoutType = LAYOUT_CUSTOM then
		ui_infield "nChainSegment_3",	xHalfLevel-xMargin1-wInteger+2, y1-4, wInteger, yInfield
	else
		ui_infield "nSegmentForUI_3",	xHalfLevel-xMargin1-wInteger+2, y1-4, wInteger, yInfield
	endif
	y1 = y1 + lineSpace


	! ------ Separator -------
	ui_separator xHalfLevel, pageStartY-3, xHalfLevel, 265


	! ------ 2. Column - Dimensions -------
	ui_style 0,1
	ui_outfield `Размеры`, x2, yStart, xEndLevel-x2,	hRow				! Dimensions
	ui_style 0,0
	y1 = pageStartY+22

	ui_pict 10, 251, pageStartY+25, 91, 104, 1			!ui_KitchenLayoutView_1(1).png
	ui_pict 11, 229, pageStartY+129, 113, 51, 1		!ui_KitchenLayoutView_2(1).png

	ui_infield "wallCabinetDepth",	x2, y1,		wLength, yInfield		ui_tooltip `Глубина Навесного Шкафа`
	ui_infield "counterDepth",		x2, y1+45,	wLength, yInfield		ui_tooltip `Глубина Столешницы`
	ui_infield "counterThickness",	x2, y1+75,	wLength, yInfield		ui_tooltip `Толщина Столешницы`
	ui_infield "toeHeigth",			x2, y1+105, wLength, yInfield		ui_tooltip `Высота Цоколя`

	ui_infield "wallCabinetHeigth",		x3, y1+39,	wLength, yInfield		ui_tooltip `Высота Навесного Шкафа`
	ui_infield "wallCabinetClearence",	x3, y1+69,	wLength, yInfield		ui_tooltip `Зазор Навесного Шкафа`
	ui_infield "counterHeigth",			x3, y1+99,	wLength, yInfield		ui_tooltip `Высота Столешницы`
	ui_infield "MSFront",				x3, y1+129,	wLength, yInfield		ui_tooltip `Минимальное Пространство Спереди`

	y1 = pageStartY+22 + 39 + 3*30 + 36

	ui_outfield `Высокие Шкафы`, x2, y1, x4-x2-2,hRow							! Tall Cabinets
	ui_infield "nTallCabinet", x4, y1-4, wInteger, yInfield
	y1 = y1 + lineSpace

	iFlag = (iLayoutType = LAYOUT_ISLAND) * 4
	ui_outfield `Навесные Шкафы`, x2, y1, x4-x2-2, hRow, iFlag					! Wall Cabinets
	ui_infield "nWallCabinet", x4, y1-4, wInteger, yInfield

return

! ------------------------------------------------------------------------------
"accessoriesPage":
! ------------------------------------------------------------------------------
	pageStartY 	= 0
	_infHeight	= 19
	_outfHeight = 15
	_yOffset 	= 4
	_outfFlag 	= 0

	dy 			= 24
	x1			= 0
	x2			= x1 + 20
	x3			= 170
	x4			= 273
	wPopup		= 96
	hPopup		= 67

	ui_style 0,1
	_yCurr = pageStartY
	ui_infield{3} "bCooktop", x1, _yCurr, x3-x1-2, _infHeight,
		7, "",
		2, 1,
		20, 20, 20, 20,
		0, `Варочные Панели`, 0,
		1, `Варочные Панели`, 1
	ui_style 0,0
	ui_infield "nCooktops", x3, _yCurr, 54, _infHeight
	ui_infield{3} "cooktopType", x4, _yCurr, wPopup, hPopup,
		2, 12, 3, 1,			! ui_cooktop_type.png
		82, 61, 82, 61,
		1, stCooktopType[1], stCooktopType[1],
		2, stCooktopType[2], stCooktopType[2],
		3, stCooktopType[3], stCooktopType[3]

	_yCurr = _yCurr + dy
	ui_infield{3} "bHood", x2, _yCurr, x3-x2-2, _infHeight,
		7, "",
		2, 1,
		20, 20, 20, 20,
		0, `Вытяжка `, 0,
		1, `Вытяжка `, 1
	ui_infield{3} "hoodType", x3, _yCurr, 97, _infHeight,
		8, "", 0, 0,
		0, 0, 0, 0,
		0, stHoodType[1], stHoodType[1],
		0, stHoodType[2], stHoodType[2],
		0, stHoodType[3], stHoodType[3]

	_yCurr = _yCurr + dy
	ui_infield "hoodHeigth", x3, _yCurr, 97, _infHeight ui_tooltip `Высота Верха Вытяжки`

	if not(bHood) then _outfFlag = 4

	_yCurr = _yCurr + _yOffset
	ui_outfield `Высота Верха Вытяжки`, x2, _yCurr, x3-x2-2, _outfHeight, _outfFlag

	_outfFlag = 0

	_yCurr = _yCurr - _yOffset + dy
	ui_style 0, 1
	ui_infield{3} "bRefrigerator", x1, _yCurr, x3-x1-2, _infHeight,
		7, "",
		2, 1,
		20, 20, 20, 20,
		0, `Холодильники`, 0,
		1, `Холодильники`, 1
	ui_style 0, 0

	ui_infield "nRefrigerators", x3, _yCurr, 54, _infHeight

	ui_infield{3} "iRefrigeratorType", x4, _yCurr, wPopup, hPopup,
		2, 13, 8, 2,
		77, 64, 82, 61,
		1, stRefrigeratorType[1], ACC_REFRI_TOP,
		2, stRefrigeratorType[2], ACC_REFRI_BOTTOM,
		3, stRefrigeratorType[3], ACC_REFRI_SIDE,
		4, stRefrigeratorType[4], ACC_REFRI_FRENCH,
		5, stRefrigeratorType[5], ACC_REFRI_COMPACT

	if not(bRefrigerator) then _outfFlag = 4

	_yCurr = _yCurr + dy + _yOffset
	ui_outfield `Высота`, x2, _yCurr, x3-x2-2, _outfHeight, _outfFlag

	_outfFlag = 0

	_yCurr = _yCurr - _yOffset
	ui_infield "refrigeratorHeigth", x3, _yCurr, 97, _infHeight

	_yCurr = _yCurr + dy
	ui_infield{3} "bRefriWallCabinet", x2, _yCurr, x4-x2-2, _infHeight,
		7, "",
		2, 1,
		20, 20, 20, 20,
		0, `Навесной Шкаф`, 0,
		1, `Навесной Шкаф`, 1

	_yCurr = _yCurr + dy
	ui_style 0,1
	ui_infield{3} "bSink", x1, _yCurr, x3-x1-2, _infHeight,
		7, "",
		2, 1,
		20, 20, 20, 20,
		0, `Мойки`, 0,
		1, `Мойки`, 1
	ui_style 0,0
	ui_infield "nSink", x3, _yCurr, 54, _infHeight
	ui_infield{3} "sinkType", x4, _yCurr, wPopup, hPopup,
		2, 14, 16, 4,			! ui_sink_type.png
		82, 61, 82, 61,
		1,  stSinkType[1], stSinkType[1],
		2,  stSinkType[2], stSinkType[2],
		4,  stSinkType[3], stSinkType[3],
		3,  stSinkType[4], stSinkType[4],
		9,  stSinkType[5], stSinkType[5],
		8,  stSinkType[6], stSinkType[6]

	_yCurr = _yCurr + dy
	ui_infield{3} "bMirroredSink", x2, _yCurr, x4-x2-2, _infHeight,
		7, "",
		2, 1,
		20, 20, 20, 20,
		0, `Зеркально`, 0,
		1, `Зеркально`, 1

	_yCurr = _yCurr + dy
	ui_style 0, 1
	ui_infield{3} "bDishwasher", x1, _yCurr, x3-x1-2, _infHeight,
		7, "",
		2, 1,
		20, 20, 20, 20,
		0, `Посудомоечные Машины`, 0,
		1, `Посудомоечные Машины`, 1
	ui_style 0, 0

	ui_infield "nDishwasher", x3, _yCurr, 54, _infHeight

	_yCurr = _yCurr + dy

	ui_style 0, 1
	ui_infield{3} "bWasher", x1, _yCurr, x3-x1-2, _infHeight,
		7, "",
		2, 1,
		20, 20, 20, 20,
		0, `Стиральные Машины`, 0,
		1, `Стиральные Машины`, 1
	ui_style 0, 0

	ui_infield "nWasher", x3, _yCurr, 54, _infHeight

	_yCurr = _yCurr + dy
	ui_style 0, 1
	ui_infield{3} "bOven", x1, _yCurr, x3-x1-2, _infHeight,
		7, "",
		2, 1,
		20, 20, 20, 20,
		0, `Духовые Шкафы`, 0,
		1, `Духовые Шкафы`, 1
	ui_style 0, 0

	ui_infield "nOvens", x3, _yCurr, 54, _infHeight
    
return

! ------------------------------------------------------------------------------
"representationpage":
! ------------------------------------------------------------------------------
	_idx = 1
	dim paramNameReprArray[]
	dim childFlagReprArray[]
	dim iconNameReprArray[]

		paramNameReprArray 	[_idx] = "gs_2D_representation"
		childFlagReprArray 	[_idx] = 0
		iconNameReprArray 	[_idx] = ""

		_idx = _idx + 1
		paramNameReprArray 	[_idx] = "gs_cont_pen"
		childFlagReprArray 	[_idx] = 1
		iconNameReprArray 	[_idx] = "ui_list_contourPen_flat(1)"

		_idx = _idx + 1
		paramNameReprArray 	[_idx] = "gs_fill_type"
		childFlagReprArray 	[_idx] = 1
		iconNameReprArray 	[_idx] = "ui_list_fillType_flat(1)"

		_idx = _idx + 1
		paramNameReprArray 	[_idx] = "gs_fill_pen"
		childFlagReprArray 	[_idx] = 1
		iconNameReprArray 	[_idx] = "ui_list_fillPen_flat(1)"

		_idx = _idx + 1
		paramNameReprArray 	[_idx] = "gs_back_pen"
		childFlagReprArray 	[_idx] = 1
		iconNameReprArray 	[_idx] = "ui_list_fillBgPen_flat(1)"

		_idx = _idx + 1
		paramNameReprArray 	[_idx] = "gs_3D_representation"
		childFlagReprArray 	[_idx] = 0
		iconNameReprArray 	[_idx] = ""

		_idx = _idx + 1
		paramNameReprArray 	[_idx] = "gs_shadow"
		childFlagReprArray 	[_idx] = 1
		iconNameReprArray 	[_idx] = "ui_list_shadow_flat(1)"

		_idx = _idx + 1
		paramNameReprArray 	[_idx] = "gs_material"
		childFlagReprArray 	[_idx] = 0
		iconNameReprArray 	[_idx] = ""

		_idx = _idx + 1
		paramNameReprArray 	[_idx] = "gs_cabinet_mat"
		childFlagReprArray 	[_idx] = 1
		iconNameReprArray 	[_idx] = "ui_list_surface_flat(1)"

		if nWallCabinet > 0 then
			_idx = _idx + 1
			paramNameReprArray 	[_idx] = "wallcab_mat"
			childFlagReprArray 	[_idx] = 1
			iconNameReprArray 	[_idx] = "ui_list_surface_flat(1)"
		endif

		_idx = _idx + 1
		paramNameReprArray 	[_idx] = "gs_base_mat"
		childFlagReprArray 	[_idx] = 1
		iconNameReprArray 	[_idx] = "ui_list_surface_flat(1)"

        if bDishwasher then
            _idx = _idx + 1
            paramNameReprArray 	[_idx] = "dishwasher_mat"
            childFlagReprArray 	[_idx] = 1
            iconNameReprArray 	[_idx] = "ui_list_surface_flat(1)"
        endif

		_idx = _idx + 1
		paramNameReprArray 	[_idx] = "count_mat"
		childFlagReprArray 	[_idx] = 1
		iconNameReprArray 	[_idx] = "ui_list_surface_flat(1)"

		if bRefrigerator then
			_idx = _idx + 1
			paramNameReprArray 	[_idx] = "refrigerator_mat"
			childFlagReprArray 	[_idx] = 1
			iconNameReprArray 	[_idx] = "ui_list_surface_flat(1)"
		endif

		if bSink then
			_idx = _idx + 1
			paramNameReprArray 	[_idx] = "sink_mat"
			childFlagReprArray 	[_idx] = 1
			iconNameReprArray 	[_idx] = "ui_list_surface_flat(1)"
		endif

		if bWasher then
			_idx = _idx + 1
			paramNameReprArray 	[_idx] = "washer_mat"
			childFlagReprArray 	[_idx] = 1
			iconNameReprArray 	[_idx] = "ui_list_surface_flat(1)"
		endif

		if bOven then
			_idx = _idx + 1
			paramNameReprArray 	[_idx] = "oven_mat"
			childFlagReprArray 	[_idx] = 1
			iconNameReprArray 	[_idx] = "ui_list_surface_flat(1)"
		endif

		if bCooktop and bHood then
			_idx = _idx + 1
			paramNameReprArray 	[_idx] = "hood_mat"
			childFlagReprArray 	[_idx] = 1
			iconNameReprArray 	[_idx] = "ui_list_surface_flat(1)"
		endif

		if bOven then
			_idx = _idx + 1
			paramNameReprArray 	[_idx] = "glass_mat"
			childFlagReprArray 	[_idx] = 1
			iconNameReprArray 	[_idx] = "ui_list_surface_flat(1)"
		endif

		if bCooktop then
			_idx = _idx + 1
			paramNameReprArray 	[_idx] = "cooktop_mat"
			childFlagReprArray 	[_idx] = 1
			iconNameReprArray 	[_idx] = "ui_list_surface_flat(1)"
	
			if bHood then
				_idx = _idx + 1
				paramNameReprArray 	[_idx] = "hotplate_mat"
				childFlagReprArray 	[_idx] = 1
				iconNameReprArray 	[_idx] = "ui_list_surface_flat(1)"
			endif
		endif

	file_dependence "ui_list_contourPen_flat(1)"
	file_dependence "ui_list_fillType_flat(1)"
	file_dependence "ui_list_fillPen_flat(1)"
	file_dependence "ui_list_fillBgPen_flat(1)"
	file_dependence "ui_list_shadow_flat(1)"
	file_dependence "ui_list_surface_flat(1)"
	
	call "ui_object_Representation" parameters all	listFieldID  	= TABID_RepresentationAndSurfaces,
													paramNameArray 	= paramNameReprArray,
													childFlagArray	= childFlagReprArray,
													iconNameArray	= iconNameReprArray

return

! ------------------------------------------------------------------------------
"symboltextpage":
! ------------------------------------------------------------------------------
	pageStartY 	= 0
	_infHeight	= 19
	_outfHeight = 15
	_yOffset 	= 4
	_outfFlag 	= 0

	dy 			= 24
	x1			= 0
	x2			= 170
	x3			= 273
	x4			= 374

	_yCurr = pageStartY + _yOffset
	if not(bRefrigerator) then _outfFlag = 4
	ui_outfield `Холодильник`, x1, _yCurr, x2 - 2, _outfHeight, _outfFlag
	_outfFlag = 0

	_yCurr = _yCurr - _yOffset
	ui_radiobutton "iRefriSymbType", 1, `2D-символ`, 	x2, _yCurr, 96, _infHeight
	ui_radiobutton "iRefriSymbType", 2, `Текст`, 		x3, _yCurr, 96, _infHeight
	ui_infield "refriText", x4, _yCurr, 70, _infHeight

	_yCurr = _yCurr + dy + _yOffset
	if not(bOven) then _outfFlag = 4
	ui_outfield `Духовой Шкаф`, x1, _yCurr, x2 - 2, _outfHeight, _outfFlag
	_outfFlag = 0

	_yCurr = _yCurr - _yOffset
	ui_radiobutton "iOvenSymbType", 1, `2D-символ`, 	x2, _yCurr, 96, _infHeight
	ui_radiobutton "iOvenSymbType", 2, `Текст`, 		x3, _yCurr, 96, _infHeight
	ui_infield "ovenText", x4, _yCurr, 70, _infHeight

	_yCurr = _yCurr + dy + _yOffset
	if not(bDishwasher) then _outfFlag = 4
	ui_outfield `Посудомоечная Машина`, x1, _yCurr, x2 - 2, _outfHeight, _outfFlag
	_outfFlag = 0

	_yCurr = _yCurr - _yOffset
	ui_radiobutton "iDishwasherSymbType", 1, `2D-символ`, 	x2, _yCurr, 96, _infHeight
	ui_radiobutton "iDishwasherSymbType", 2, `Текст`, 		x3, _yCurr, 96, _infHeight
	ui_infield "dishwasherText", x4, _yCurr, 70, _infHeight

	_yCurr = _yCurr + dy + _yOffset
	if not(bWasher) then _outfFlag = 4
	ui_outfield `Стиральная Машина`, x1, _yCurr, x2 - 2, _outfHeight, _outfFlag
	_outfFlag = 0

	_yCurr = _yCurr - _yOffset
	ui_radiobutton "iWasherSymbType", 1, `2D-символ`, 	x2, _yCurr, 96, _infHeight
	ui_radiobutton "iWasherSymbType", 2, `Текст`, 		x3, _yCurr, 96, _infHeight
	ui_infield "washerText", x4, _yCurr, 70, _infHeight

	_yCurr = _yCurr + dy
	ui_separator x1, _yCurr, 444, _yCurr


	call "ui_object_SymbolText" parameters	dt 						= displayText,
											bIsTextDisplay 			= 0,
											bParName_stDisplayText	= 0,
											fontType				= fontType,
											fontSize				= fontSize,
											bParName_FontSize		= 1,
											gs_text_style_bold		= gs_text_style_bold,
											gs_text_style_italic	= gs_text_style_italic,
											gs_text_style_underline	= gs_text_style_underline,
											bStrikeText				= 1,
											gs_text_style_strike	= gs_text_style_strike,
											bParName_PenText		= 1,
											penText					= penText,
											bOrientationShortName	= 1,
											typeTextRotation_m		= typeTextRotation_m,
											bTextPos 				= 0,
											biTextPen				= 1,
											iTextPen				= iTextPen,
											pageStartY				= 106


return

! ------------------------------------------------------------------------------
"Descriptionspage":
! ------------------------------------------------------------------------------
	dim stParamNames[16]
		stParamNames[1] = "gs_list_cost"
		stParamNames[2] = "gs_list_manufacturer"
		stParamNames[3] = "gs_list_note"
		stParamNames[4] = "gs_list_location"
		stParamNames[5] = "gs_list_accessories"
		stParamNames[6] = "FM_Type"
		stParamNames[7] = "FM_InventoryNumber"
		stParamNames[8] = "FM_SerialNumber"
		stParamNames[9] = "FM_ProductionYear"
		stParamNames[10] = "FM_ObjectWeight"
		stParamNames[11] = "FM_ObjectWeightUnit"
		stParamNames[12] = "gs_list_custom1"
		stParamNames[13] = "gs_list_custom2"
		stParamNames[14] = "gs_list_custom3"
		stParamNames[15] = "gs_list_custom4"
		stParamNames[16] = "gs_list_custom5"

	call "ui_object_listing" parameters all listfieldID = TABID_Descriptions,
										listFieldPosY = 0,
										listFieldHeight = 265,
										stDescHeader = "",
										stValueHeader = "",
										stParamNames = stParamNames

return
]]>
</Script_UI>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_VL SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
call "FM_types" parameters all

!Hide all parameters from UI
hideparameter all  "A", "B", "ZZYZX"

! ------------------------------------------------------------------------------
! Minimum Sizes
! ------------------------------------------------------------------------------
minRefPointDist			= counterDepth * 1.5
minRefPointDistSquare	= minRefPointDist * minRefPointDist
minWallPointDist		= wallCabinetDepth * 1.5
minWallPointDistSquare	= minWallPointDist * minWallPointDist

! ------------------------------------------------------------------------------
! Layout Type
! ------------------------------------------------------------------------------
if GLOB_MODPAR_NAME = "layoutType" then
	gosub "moveRefLinePoints_1"
	if bChains[2] then gosub "moveRefLinePoints_2"
	if bChains[3] then gosub "moveRefLinePoints_3"
endif

if iLayoutType = LAYOUT_ISLAND then
	hideparameter	"nWallCabinet", "wallCabinetDepth"
	lock			"nWallCabinet", "wallCabinetDepth"
endif

if iLayoutType = LAYOUT_CUSTOM then
	values "nChains" 1, 2, 3
	if nChains = 1 then
		values "nChainSegment_1" range [1, nMaxSegment]
		values "nChainSegment_2" range [1, nMaxSegment]
		values "nChainSegment_3" range [1, nMaxSegment]
		hideparameter	"nChainSegment_2", "nChainSegment_3"
		lock			"nChainSegment_2", "nChainSegment_3"
	else
		if nChains = 2 then
			values "nChainSegment_1" range [1, nMaxSegment-nChainSegment_2]
			values "nChainSegment_2" range [1, nMaxSegment-nChainSegment_1]
			values "nChainSegment_3" range [1, nMaxSegment]
			hideparameter	"nChainSegment_3"
			lock			"nChainSegment_3"
		else
			values "nChainSegment_1" range [1, nMaxSegment-nChainSegment_2-nChainSegment_3]
			values "nChainSegment_2" range [1, nMaxSegment-nChainSegment_1-nChainSegment_3]
			values "nChainSegment_3" range [1, nMaxSegment-nChainSegment_1-nChainSegment_2]
		endif
	endif
else
	hideparameter	"nChains", "nChainSegment_1", "nChainSegment_2", "nChainSegment_3"
	lock			"nChains", "nChainSegment_1", "nChainSegment_2", "nChainSegment_3"

	nCounterForUI	= 1
	nSegmentForUI_1	= nTotalRefPoint - 1
	nSegmentForUI_2	= 0
	nSegmentForUI_3	= 0
	if iLayoutType = LAYOUT_GALLEY | iLayoutType = LAYOUT_ISLAND then
		nCounterForUI	= 2
		nSegmentForUI_1	= 1
		nSegmentForUI_2	= 1
	endif
	parameters	nCounterForUI	= nCounterForUI,
				nSegmentForUI_1	= nSegmentForUI_1,
				nSegmentForUI_2	= nSegmentForUI_2,
				nSegmentForUI_3	= nSegmentForUI_3

	values "nCounterForUI"	range [1, ]
	values "nSegmentForUI_1"	range [1, ]
	values "nSegmentForUI_2"	range [0, ]
	values "nSegmentForUI_3"	range [0, ]
endif

lock "nCounterForUI", "nSegmentForUI_1", "nSegmentForUI_2", "nSegmentForUI_3"


! ------------------------------------------------------------------------------
! Dimensions
! ------------------------------------------------------------------------------
values "counterDepth"			range [0.2, ]
values "counterHeigth"			range [toeHeigth+minSize, ]
values "counterThickness"		range (0, ]
values "wallCabinetHeigth"		range [minSize, ]
values "wallCabinetDepth"		range [minSize, counterDepth]
values "wallCabinetClearence"	range [minSize, ]
values "toeHeigth"				range (0, ]

!Bounding box
for i = 1 to vardim1(refLinePoints)
	put refLinePoints[i][1]
	put oppsidePoints[i][1]
next i
minBoundingX = min(use(nsp))
maxBoundingX = max(get(nsp))

for i = 1 to vardim1(refLinePoints)
	put refLinePoints[i][2]
	put oppsidePoints[i][2]
next i
minBoundingY = min(use(nsp))
maxBoundingY = max(get(nsp))

A = maxBoundingX - minBoundingX
B = maxBoundingY - minBoundingY

ZZYZX = counterHeigth + wallCabinetClearence + wallCabinetHeigth
parameters A=A, B=B, ZZYZX = ZZYZX
lock "A", "B", "ZZYZX"

if GLOB_MODPAR_NAME = "toeHeigth" then
	for i = 1 to vardim1(ovenHeigth)
		if ovenHeigth[i] < toeHeigth then
			ovenHeigth[i] = toeHeigth
			parameters ovenHeigth[i] = ovenHeigth[i]
		endif
	next i
endif


! ------------------------------------------------------------------------------
! Move References Line Point
! ------------------------------------------------------------------------------
if GLOB_MODPAR_NAME = "refLinePoints_1" then
	gosub "moveRefLinePoints_1"
	dim tempRefLinePoints_1[][2]
	parameters tempRefLinePoints_1 = refLinePoints_1
else
	dim tempRefLinePoints_1[][2]
	parameters tempRefLinePoints_1 = refLinePoints_1
endif

if bChains[2] then
	if GLOB_MODPAR_NAME = "refLinePoints_2" then
		gosub "moveRefLinePoints_2"
		dim tempRefLinePoints_2[][2]
		parameters tempRefLinePoints_2 = refLinePoints_2
	else
		dim tempRefLinePoints_2[][2]
		parameters tempRefLinePoints_2 = refLinePoints_2
	endif
endif

if bChains[3] then
	if GLOB_MODPAR_NAME = "refLinePoints_3" then
		gosub "moveRefLinePoints_3"
		dim tempRefLinePoints_3[][2]
		parameters tempRefLinePoints_3 = refLinePoints_3
	else
		dim tempRefLinePoints_3[][2]
		parameters tempRefLinePoints_3 = refLinePoints_3
	endif
endif


! ------------------------------------------------------------------------------
! 2D Representation
! ------------------------------------------------------------------------------
if gs_cont_pen < 1 then parameters gs_cont_pen = 4
if gs_fill_pen < 1 then parameters gs_fill_pen = 19
if not(bShowOverhead) then
	hideparameter	"overheadLine"
	lock			"overheadLine"
endif

Dot_in_mm = 25.4 / 72

values "fontSize" range (0,]

values "typeTextRotation" stTextRot
values "typeTextRotation_m" 2, 1, 0
if GLOB_MODPAR_NAME = "typeTextRotation" then
	typeTextRotation_m = 0
	for i = 1 to vardim1(stTextRot)
		if typeTextRotation = stTextRot[i] then
			typeTextRotation_m = 3 - i
			i = vardim1(stTextRot)
		endif
	next i
	parameters typeTextRotation_m = typeTextRotation_m
else
	typeTextRotation_m = max(min(typeTextRotation_m,2),0)
	parameters typeTextRotation = stTextRot[3-typeTextRotation_m]
endif

if not(displayText) then
	hideparameter	"penText",
					"iTextPen",
					"fontType",
					"fontSize",
					"typeTextRotation",
					"typeTextRotation_m",
					"gs_text_style_bold",
					"gs_text_style_italic",
					"gs_text_style_underline",
					"gs_text_style_strike",
					"gs_readable_angle"

	lock			"penText",
					"iTextPen",
					"fontType",
					"fontSize",
					"typeTextRotation",
					"typeTextRotation_m",
					"gs_text_style_bold",
					"gs_text_style_italic",
					"gs_text_style_underline",
					"gs_text_style_strike",
					"gs_readable_angle"

else
	if GLOB_MODPAR_NAME = "penText" then
		if penText< 1 then
			penText= 1
			parameters penText= penText
		endif
		iTextPen = penText
		parameters iTextPen = iTextPen
	else
		if iTextPen < 1 then
			iTextPen = 1
			parameters iTextPen = iTextPen
		endif

		if iTextPen > 255 then
			iTextPen = 255
			parameters iTextPen = iTextPen
		endif

		textPen = iTextPen
		parameters penText= penText
	endif
endif


! ==============================================================================
!
! Accessories
!
! ==============================================================================

! ------------------------------------------------------------------------------
! Enlarge Accessories Number
! ------------------------------------------------------------------------------
parameters lastPointLength = 0
parameters	nPrevTallCabinet	= nTallCabinet,
			nPrevSink			= nofSink,
			nPrevCooktops		= nofCooktops,
			nPrevOvens			= nofOvens,
			nPrevRefri			= nofRefrigerators,
			nPrevDishwasher		= nofDishwasher,
			nPrevWasher			= nofWasher


! ------------------------------------------------------------------------------
! Wall Cabinet
! ------------------------------------------------------------------------------
values "nWallCabinet" range [0, nMaxAccessory]
if nWallCabinet > 0 then
	if GLOB_MODPAR_NAME = "wallCabinetPos_1" | GLOB_MODPAR_NAME = "wallCabinetPos_2" then
		if GLOB_MODPAR_NAME = "wallCabinetPos_1" then
			moved = 1
			gosub "moveWallLinePoints"
		else
			moved = 2
			gosub "moveWallLinePoints"
		endif
	else
		if GLOB_MODPAR_NAME = "nWallCabinet" | bGeometryChanged then
			moved = 1
			gosub "moveWallLinePoints"
		endif
	endif
else
	hideparameter	"wallCabinetPos_1",
					"wallCabinetPos_2",
					"wallCabinetPos2_1",
					"wallCabinetPos2_2",
					"nWallSegment",
					"isWallContinuous",
					"nWallContour",
					"wallCoords1",
					"wallCoords2",
					"wallcab_mat"

	lock			"wallCabinetPos_1",
					"wallCabinetPos_2",
					"wallCabinetPos2_1",
					"wallCabinetPos2_2",
					"nWallSegment",
					"isWallContinuous",
					"nWallContour",
					"wallCoords1",
					"wallCoords2",
					"wallcab_mat"
endif


! ------------------------------------------------------------------------------
! Tall Cabinet
! ------------------------------------------------------------------------------
values "nTallCabinet" range [0, nMaxAccessory]
if nTallCabinet > 0 then
	values "tallCabinetWidth"	range [minSize, ]
	values "tallCabinetWidth2"	range [minSize, ]
	if GLOB_MODPAR_NAME = "tallCabinetWidth" | GLOB_MODPAR_NAME = "tallCabinetWidth2" then
		if GLOB_MODPAR_NAME = "tallCabinetWidth" then
			for i = 1 to nTallCabinet
				if tallCabinetWidth[i] < minSize then
					tallCabinetWidth[i] = minSize
					parameters tallCabinetWidth[i] = tallCabinetWidth[i]
				endif
				tallCabWidthPos[i][1] = tallCabWidthPos[i][3] + cos(elementAngle[isTall[i]]) * tallCabinetWidth[i]
				tallCabWidthPos[i][2] = tallCabWidthPos[i][4] + sin(elementAngle[isTall[i]]) * tallCabinetWidth[i]

				tallCabPos[i][1] = (tallCabWidthPos[i][3] - tallCabWidthPos[i][1]) / 2 + tallCabWidthPos[i][1]
				tallCabPos[i][2] = (tallCabWidthPos[i][4] - tallCabWidthPos[i][2]) / 2 + tallCabWidthPos[i][2]
			next i
			tallCabinetWidth2 = tallCabinetWidth
			parameters tallCabWidthPos = tallCabWidthPos, tallCabinetWidth2 = tallCabinetWidth2
		else
			for i = 1 to nTallCabinet
				if tallCabinetWidth2[i] < minSize then
					tallCabinetWidth2[i] = minSize
					parameters tallCabinetWidth2[i] = tallCabinetWidth2[i]
				endif
				tallCabWidthPos[i][3] = tallCabWidthPos[i][1] - cos(elementAngle[isTall[i]]) * tallCabinetWidth2[i]
				tallCabWidthPos[i][4] = tallCabWidthPos[i][2] - sin(elementAngle[isTall[i]]) * tallCabinetWidth2[i]

				tallCabPos[i][1] = (tallCabWidthPos[i][3] - tallCabWidthPos[i][1]) / 2 + tallCabWidthPos[i][1]
				tallCabPos[i][2] = (tallCabWidthPos[i][4] - tallCabWidthPos[i][2]) / 2 + tallCabWidthPos[i][2]
			next i
			tallCabinetWidth = tallCabinetWidth2
			parameters tallCabWidthPos = tallCabWidthPos, tallCabinetWidth = tallCabinetWidth
		endif
		parameters tallCabPos = tallCabPos
	else
		tallCabinetWidth2 = tallCabinetWidth
		for i = 1 to nTallCabinet
			tallCabWidthPos[i][1] = elementWidth[isTall[i]][1]
			tallCabWidthPos[i][2] = elementWidth[isTall[i]][2]
			tallCabWidthPos[i][3] = elementWidth[isTall[i]][3]
			tallCabWidthPos[i][4] = elementWidth[isTall[i]][4]
		next i
		parameters tallCabWidthPos = tallCabWidthPos, tallCabinetWidth2 = tallCabinetWidth2
	endif
else
	hideparameter	"nPrevTallCabinet",
					"tallCabinetWidth",
					"tallCabinetWidth2",
					"tallCabPos",
					"tallCabPos2",
					"nSegmentTall",
					"tallCabWidthPos"

	lock			"nPrevTallCabinet",
					"tallCabinetWidth",
					"tallCabinetWidth2",
					"tallCabPos",
					"tallCabPos2",
					"nSegmentTall",
					"tallCabWidthPos"
endif


! ------------------------------------------------------------------------------
! Sink
! ------------------------------------------------------------------------------
values "sinkType" stSinkType
values "iSinkType" ACC_SINK_ROUND, ACC_SINK_SINGLE, ACC_SINK_SINGLE_DRAIN, ACC_SINK_DOUBLE, ACC_SINK_DOUBLE_DRAIN, ACC_SINK_TRIPLE
if GLOB_MODPAR_NAME = "sinkType" then
	iSinkType = 1
	for i = 1 to vardim1(stSinkType)
		if sinkType = stSinkType[i] then
			iSinkType = i
			i = vardim1(stSinkType)
		endif
	next i
	parameters iSinkType = iSinkType
else
	iSinkType = max(min(iSinkType,vardim1(stSinkType)),1)
	parameters sinkType = stSinkType[iSinkType]
endif

if tempSinkType <> iSinkType then
	for i = 1 to nMaxAccessory
		sinkWidth[i]	= sinkDefaults[iSinkType]
		sinkWidth2[i]	= sinkDefaults[iSinkType]
	next i
	sinkWidthHalf = sinkDefaults[iSinkType] / 2

	if iSinkType = ACC_SINK_ROUND & sinkWidthHalf > counterDepth/2 then
		sinkWidthHalf = counterDepth/2 - EPS
		for i = 1 to nMaxAccessory
			sinkWidth[i]	= sinkWidthHalf * 2
			sinkWidth2[i]	= sinkWidthHalf * 2
		next i
	endif

	parameters tempSinkType = iSinkType, sinkWidth = sinkWidth, sinkWidth2 = sinkWidth2, sinkWidthHalf = sinkWidthHalf
endif

values "nSink" range [1, nMaxAccessory]
if nofSink > 0 then
	dim sinkMinWidth[6]
		sinkMinWidth[1]	= 0.20
		sinkMinWidth[2]	= 0.20
		sinkMinWidth[3]	= 0.40
		sinkMinWidth[4]	= 0.40
		sinkMinWidth[5]	= 0.66
		sinkMinWidth[6]	= 0.66

	values "sinkWidth"		range [sinkMinWidth[iSinkType], ]
	values "sinkWidth2"		range [sinkMinWidth[iSinkType], ]
	values "sinkWidthHalf"	range [sinkMinWidth[iSinkType]/2, counterDepth/2 - EPS]

	if GLOB_MODPAR_NAME = "sinkWidthHalf" then
		if sinkWidthHalf < sinkMinWidth[iSinkType]/2 then
			sinkWidthHalf = sinkMinWidth[iSinkType]/2
			parameters sinkWidthHalf = sinkWidthHalf
		endif
		if sinkWidthHalf > counterDepth/2 - EPS then
			sinkWidthHalf = counterDepth/2 - EPS
			parameters sinkWidthHalf = sinkWidthHalf
		endif
		for i = 1 to nMaxAccessory
			sinkWidth[i]	= sinkWidthHalf * 2
			sinkWidth2[i]	= sinkWidthHalf * 2
		next i
		parameters sinkWidth = sinkWidth, sinkWidth2 = sinkWidth2
	endif
	if GLOB_MODPAR_NAME = "sinkWidth" | GLOB_MODPAR_NAME = "sinkWidth2" then
		nElementChanged = 1
		for i = 2 to nMaxAccessory				! Width Connection
			if abs(sinkWidth[i] - sinkWidth2[i]) > EPS then
				nElementChanged = i
				i = nMaxAccessory
			endif
		next i
		if GLOB_MODPAR_NAME = "sinkWidth" then
			for i = 1 to nMaxAccessory
				if nElementChanged <> i then		!Width Connection
					sinkWidth[i] = sinkWidth[nElementChanged]
					parameters sinkWidth[i] = sinkWidth[i]
				endif
				if sinkWidth[i] < sinkMinWidth[iSinkType] then
					sinkWidth[i] = sinkMinWidth[iSinkType]
					parameters sinkWidth[i] = sinkWidth[i]
				endif
				if i < nofSink + 1 then
					sinkWidthPos[i][1] = sinkWidthPos[i][3] + cos(elementAngle[isSink[i]]) * sinkWidth[i]
					sinkWidthPos[i][2] = sinkWidthPos[i][4] + sin(elementAngle[isSink[i]]) * sinkWidth[i]

					sinkPos[i][1] = (sinkWidthPos[i][3] - sinkWidthPos[i][1]) / 2 + sinkWidthPos[i][1]
					sinkPos[i][2] = (sinkWidthPos[i][4] - sinkWidthPos[i][2]) / 2 + sinkWidthPos[i][2]
				endif
			next i
			sinkWidth2 = sinkWidth
			parameters sinkWidthPos = sinkWidthPos, sinkWidth2 = sinkWidth2
		else
			for i = 1 to nMaxAccessory
				if nElementChanged <> i then		!Width Connection
					sinkWidth2[i] = sinkWidth2[nElementChanged]
					parameters sinkWidth2[i] = sinkWidth2[i]
				endif
				if sinkWidth2[i] < sinkMinWidth[iSinkType] then
					sinkWidth2[i] = sinkMinWidth[iSinkType]
					parameters sinkWidth2[i] = sinkWidth2[i]
				endif
				if i < nofSink + 1 then
					sinkWidthPos[i][3] = sinkWidthPos[i][1] - cos(elementAngle[isSink[i]]) * sinkWidth2[i]
					sinkWidthPos[i][4] = sinkWidthPos[i][2] - sin(elementAngle[isSink[i]]) * sinkWidth2[i]

					sinkPos[i][1] = (sinkWidthPos[i][3] - sinkWidthPos[i][1]) / 2 + sinkWidthPos[i][1]
					sinkPos[i][2] = (sinkWidthPos[i][4] - sinkWidthPos[i][2]) / 2 + sinkWidthPos[i][2]
				endif
			next i
			sinkWidth = sinkWidth2
			parameters sinkWidthPos = sinkWidthPos, sinkWidth = sinkWidth
		endif
		sinkWidthHalf = sinkWidth[1] / 2
		parameters sinkPos = sinkPos, sinkWidthHalf = sinkWidthHalf
	else
		sinkWidth2 = sinkWidth
		for i = 1 to nofSink
			sinkWidthPos[i][1] = elementWidth[isSink[i]][1]
			sinkWidthPos[i][2] = elementWidth[isSink[i]][2]
			sinkWidthPos[i][3] = elementWidth[isSink[i]][3]
			sinkWidthPos[i][4] = elementWidth[isSink[i]][4]
		next i
		sinkWidthHalf = sinkWidth[1] / 2
		parameters sinkWidthPos = sinkWidthPos, sinkWidth2 = sinkWidth2, sinkWidthHalf = sinkWidthHalf
	endif

	if	iSinkType = ACC_SINK_ROUND	| \
		iSinkType = ACC_SINK_SINGLE	| \
		iSinkType = ACC_SINK_DOUBLE	| \
		iSinkType = ACC_SINK_TRIPLE	then

		hideparameter	"bMirroredSink"
		lock			"bMirroredSink"
	endif

	if iSinkType = ACC_SINK_ROUND then
		hideparameter	"sinkWidth", "sinkWidth2"
		lock			"sinkWidth", "sinkWidth2"
	else
		hideparameter	"sinkWidthHalf"
		lock			"sinkWidthHalf"
	endif

else
	hideparameter	"sink_mat",
					"nSink",
					"nPrevSink",
					"sinkType",
					"iSinkType",
					"tempSinkType",
					"bMirroredSink",
					"sinkWidth",
					"sinkWidth2",
					"sinkWidthHalf",
					"sinkPos",
					"sinkPos2",
					"nSegmentSink",
					"sinkWidthPos",
					"sinkDefaults"

	lock			"sink_mat",
					"nSink",
					"nPrevSink",
					"sinkType",
					"iSinkType",
					"tempSinkType",
					"bMirroredSink",
					"sinkWidth",
					"sinkWidth2",
					"sinkWidthHalf",
					"sinkPos",
					"sinkPos2",
					"nSegmentSink",
					"sinkWidthPos",
					"sinkDefaults"
endif


! ------------------------------------------------------------------------------
! Cooktop
! ------------------------------------------------------------------------------
values "nCooktops" range [1, nMaxAccessory]
values "hoodHeigth"	range [minSize, ]

values "cooktopType" stCooktopType
values "iCooktopType" ACC_COOKTOP_2, ACC_COOKTOP_4, ACC_COOKTOP_5
if GLOB_MODPAR_NAME = "cooktopType" then
	iCooktopType = 1
	for i = 1 to vardim1(stCooktopType)
		if cooktopType = stCooktopType[i] then
			iCooktopType = i
			i = vardim1(stCooktopType)
		endif
	next i
	parameters iCooktopType = iCooktopType
else
	iCooktopType = max(min(iCooktopType,vardim1(stCooktopType)),1)
	parameters cooktopType = stCooktopType[iCooktopType]
endif

if iLayoutType = LAYOUT_ISLAND then
	values "hoodType" stHoodType[2]
	values "iHoodType" ACC_HOOD_HANGING
else
	values "hoodType" stHoodType
	values "iHoodType" ACC_HOOD_WALL, ACC_HOOD_HANGING, ACC_HOOD_BUILTIN
endif
if GLOB_MODPAR_NAME = "hoodType" then
	iHoodType = 1
	for i = 1 to vardim1(stHoodType)
		if hoodType = stHoodType[i] then
			iHoodType = i
			i = vardim1(stHoodType)
		endif
	next i
	parameters iHoodType = iHoodType
else
	iHoodType = max(min(iHoodType,vardim1(stHoodType)),1)
	parameters hoodType = stHoodType[iHoodType]
endif

if tempCooktopType <> iCooktopType then
	for i = 1 to vardim1(cooktopWidth)
		cooktopWidth[i]		= cooktopDefaults[iCooktopType]
		cooktopWidth2[i]	= cooktopDefaults[iCooktopType]
		hoodWidth[i]		= cooktopDefaults[iCooktopType]
		if hoodWidth[i] < minHood then hoodWidth[i] = minHood
		hoodWidth2[i]		= hoodWidth[i] / 2
	next i
	parameters cooktopWidth = cooktopWidth, cooktopWidth2 = cooktopWidth2 , hoodWidth = hoodWidth, hoodWidth2 = hoodWidth2
	parameters tempCooktopType = iCooktopType
endif

if nofCooktops > 0 then
	values "cooktopWidth"	range [minSize, ]
	values "cooktopWidth2"	range [minSize, ]
	values "hoodWidth"		range [minHood, ]
	values "hoodWidth2"		range [minHood/2, ]


	if GLOB_MODPAR_NAME = "hoodWidth" | GLOB_MODPAR_NAME = "hoodWidth2" then
		nElementChanged = 1
		for i = 2 to nMaxAccessory				! Width Connection
			if abs(hoodWidth[i]/2 - hoodWidth2[i]) > EPS then
				nElementChanged = i
				i = nMaxAccessory
			endif
		next i
		if GLOB_MODPAR_NAME = "hoodWidth" then
			for i = nMaxAccessory to 1 step -1
				if nElementChanged <> i then		!Width Connection
					hoodWidth[i] = hoodWidth[nElementChanged]
					parameters hoodWidth[i] = hoodWidth[i]
				endif
				if hoodWidth[i] < minHood then
					hoodWidth[i] = minHood
					parameters hoodWidth[i] = hoodWidth[i]
				endif
				hoodWidth2[i] = hoodWidth[i] / 2
			next i
			parameters hoodWidth2 = hoodWidth2
		else
			for i = nMaxAccessory to 1 step -1
				if nElementChanged <> i then		!Width Connection
					hoodWidth2[i] = hoodWidth2[nElementChanged]
					parameters hoodWidth2[i] = hoodWidth2[i]
				endif
				if hoodWidth2[i] < minHood/2 then
					hoodWidth2[i] = minHood/2
					parameters hoodWidth2[i] = hoodWidth2[i]
				endif
				hoodWidth[i] = hoodWidth2[i] * 2
			next i
			parameters hoodWidth = hoodWidth
		endif
	else
		for i = 1 to nMaxAccessory
			hoodWidth2[i] = hoodWidth[i] /2
		next i
		parameters hoodWidth2 = hoodWidth2
	endif

	if GLOB_MODPAR_NAME = "cooktopWidth" | GLOB_MODPAR_NAME = "cooktopWidth2" then
		nElementChanged = 1
		for i = 2 to nMaxAccessory				! Width Connection
			if abs(cooktopWidth[i] - cooktopWidth2[i]) > EPS then
				nElementChanged = i
				i = nMaxAccessory
			endif
		next i
		dim deltaCooktopWidth[]
		if GLOB_MODPAR_NAME = "cooktopWidth" then
			for i = nMaxAccessory to 1 step -1
				if nElementChanged <> i then		!Width Connection
					cooktopWidth[i] = cooktopWidth[nElementChanged]
					parameters cooktopWidth[i] = cooktopWidth[i]
				endif
				if cooktopWidth[i] < minSize then
					cooktopWidth[i] = minSize
					parameters cooktopWidth[i] = cooktopWidth[i]
				endif

				deltaCooktopWidth[i] = cooktopWidth2[i] - cooktopWidth[i]

				if i < nofCooktops + 1 then
					cooktopWidthPos[i][1] = cooktopWidthPos[i][3] + cos(elementAngle[isCooktop[i]]) * cooktopWidth[i]
					cooktopWidthPos[i][2] = cooktopWidthPos[i][4] + sin(elementAngle[isCooktop[i]]) * cooktopWidth[i]

					cooktopPos[i][1] = (cooktopWidthPos[i][3] - cooktopWidthPos[i][1]) / 2 + cooktopWidthPos[i][1]
					cooktopPos[i][2] = (cooktopWidthPos[i][4] - cooktopWidthPos[i][2]) / 2 + cooktopWidthPos[i][2]
				endif
			next i
			cooktopWidth2 = cooktopWidth
			parameters cooktopWidthPos = cooktopWidthPos, cooktopWidth2 = cooktopWidth2
		else
			for i = nMaxAccessory to 1 step -1
				if nElementChanged <> i then		!Width Connection
					cooktopWidth2[i] = cooktopWidth2[nElementChanged]
					parameters cooktopWidth2[i] = cooktopWidth2[i]
				endif
				if cooktopWidth2[i] < minSize then
					cooktopWidth2[i] = minSize
					parameters cooktopWidth2[i] = cooktopWidth2[i]
				endif

				deltaCooktopWidth[i] = cooktopWidth[i] - cooktopWidth2[i]

				if i < nofCooktops + 1 then
					cooktopWidthPos[i][3] = cooktopWidthPos[i][1] - cos(elementAngle[isCooktop[i]]) * cooktopWidth2[i]
					cooktopWidthPos[i][4] = cooktopWidthPos[i][2] - sin(elementAngle[isCooktop[i]]) * cooktopWidth2[i]

					cooktopPos[i][1] = (cooktopWidthPos[i][3] - cooktopWidthPos[i][1]) / 2 + cooktopWidthPos[i][1]
					cooktopPos[i][2] = (cooktopWidthPos[i][4] - cooktopWidthPos[i][2]) / 2 + cooktopWidthPos[i][2]
				endif
			next i
			cooktopWidth = cooktopWidth2
			parameters cooktopWidthPos = cooktopWidthPos, cooktopWidth = cooktopWidth
		endif
		parameters cooktopPos = cooktopPos

		for i = nMaxAccessory to 1 step -1
			hoodWidth[i]	= hoodWidth[i] - deltaCooktopWidth[i]
			if hoodWidth[i] < minHood then
				hoodWidth[i] = minHood
			endif
			hoodWidth2[i]	= hoodWidth[i] / 2
		next i
		parameters hoodWidth = hoodWidth, hoodWidth2 = hoodWidth2

	else
		cooktopWidth2 = cooktopWidth
		for i = 1 to nofCooktops
			cooktopWidthPos[i][1] = elementWidth[isCooktop[i]][1]
			cooktopWidthPos[i][2] = elementWidth[isCooktop[i]][2]
			cooktopWidthPos[i][3] = elementWidth[isCooktop[i]][3]
			cooktopWidthPos[i][4] = elementWidth[isCooktop[i]][4]
		next i
		parameters cooktopWidthPos = cooktopWidthPos, cooktopWidth2 = cooktopWidth2
	endif

	if not(bHood) then
		hideparameter	"hoodType", "iHoodType", "hoodHeigth"
		lock			"hoodType", "iHoodType", "hoodHeigth"
	else
		if iHoodType = ACC_HOOD_BUILTIN then
			hideparameter	"hoodHeigth"
			lock			"hoodHeigth"
		endif
	endif

else
	hideparameter	"cooktop_mat",
					"hotplate_mat",
					"hood_mat",
					"nCooktops",
					"nPrevCooktops",
					"cooktopType",
					"iCooktopType",
					"tempCooktopType",
					"cooktopWidth",
					"cooktopWidth2",
					"cooktopPos",
					"cooktopPos2",
					"nSegmentCooktop",
					"cooktopWidthPos",
					"bHood",
					"hoodType",
					"iHoodType",
					"hoodHeigth",
					"cooktopDefaults",
					"hoodWidth",
					"hoodWidth2"

	lock			"cooktop_mat",
					"hotplate_mat",
					"hood_mat",
					"nCooktops",
					"nPrevCooktops",
					"cooktopType",
					"iCooktopType",
					"tempCooktopType",
					"cooktopWidth",
					"cooktopWidth2",
					"cooktopPos",
					"cooktopPos2",
					"nSegmentCooktop",
					"cooktopWidthPos",
					"bHood",
					"hoodType",
					"iHoodType",
					"hoodHeigth",
					"cooktopDefaults",
					"hoodWidth",
					"hoodWidth2"
endif


! ------------------------------------------------------------------------------
! Oven
! ------------------------------------------------------------------------------
ovenHeigthMin = toeHeigth
ovenHeigthMax = counterHeigth+wallCabinetHeigth+wallCabinetClearence - ovenH
values "ovenHeigth" range [ovenHeigthMin, ovenHeigthMax]

values "ovenSymbType" stSymbType
values "iOvenSymbType" SYMBTYPE_SYMBOL, SYMBTYPE_TEXT
if GLOB_MODPAR_NAME = "ovenSymbType" then
	iOvenSymbType = 1
	for i = 2 to vardim1(stSymbType)
		if ovenSymbType = stSymbType[i] then iOvenSymbType = i
	next i
	parameters iOvenSymbType = iOvenSymbType
else
	iOvenSymbType = max(min(iOvenSymbType,vardim1(stSymbType)),1)
	parameters ovenSymbType = stSymbType[iOvenSymbType]
endif

values "nOvens" range [1, nMaxAccessory]
if nofOvens > 0 then
	if iOvenSymbType = SYMBTYPE_SYMBOL then
		hideparameter "ovenText"
		lock "ovenText"
	endif

	values "ovenWidth"	range [minSize, ]
	values "ovenWidth2"	range [minSize, ]
	if GLOB_MODPAR_NAME = "ovenWidth" | GLOB_MODPAR_NAME = "ovenWidth2" then
		nElementChanged =1
		for i = 2 to nMaxAccessory				! Width Connection
			if abs(ovenWidth[i] - ovenWidth2[i]) > EPS then
				nElementChanged = i
				i = nMaxAccessory
			endif
		next i
		if GLOB_MODPAR_NAME = "ovenWidth" then
			for i = 1 to nMaxAccessory
				if nElementChanged <> i then		!Width Connection
					ovenWidth[i] = ovenWidth[nElementChanged]
					parameters ovenWidth[i] = ovenWidth[i]
				endif
				if ovenWidth[i] < minSize then
					ovenWidth[i] = minSize
					parameters ovenWidth[i] = ovenWidth[i]
				endif
				if i < nofOvens + 1 then
					ovenWidthPos[i][1] = ovenWidthPos[i][3] + cos(elementAngle[isOven[i]]) * ovenWidth[i]
					ovenWidthPos[i][2] = ovenWidthPos[i][4] + sin(elementAngle[isOven[i]]) * ovenWidth[i]

					ovenPos[i][1] = (ovenWidthPos[i][3] - ovenWidthPos[i][1]) / 2 + ovenWidthPos[i][1]
					ovenPos[i][2] = (ovenWidthPos[i][4] - ovenWidthPos[i][2]) / 2 + ovenWidthPos[i][2]
				endif
			next i
			ovenWidth2 = ovenWidth
			parameters ovenWidthPos = ovenWidthPos, ovenWidth2 = ovenWidth2
		else
			for i = 1 to nMaxAccessory
				if nElementChanged <> i then		!Width Connection
					ovenWidth2[i] = ovenWidth2[nElementChanged]
					parameters ovenWidth2[i] = ovenWidth2[i]
				endif
				if ovenWidth2[i] < minSize then
					ovenWidth2[i] = minSize
					parameters ovenWidth2[i] = ovenWidth2[i]
				endif
				if i < nofOvens + 1 then
					ovenWidthPos[i][3] = ovenWidthPos[i][1] - cos(elementAngle[isOven[i]]) * ovenWidth2[i]
					ovenWidthPos[i][4] = ovenWidthPos[i][2] - sin(elementAngle[isOven[i]]) * ovenWidth2[i]

					ovenPos[i][1] = (ovenWidthPos[i][3] - ovenWidthPos[i][1]) / 2 + ovenWidthPos[i][1]
					ovenPos[i][2] = (ovenWidthPos[i][4] - ovenWidthPos[i][2]) / 2 + ovenWidthPos[i][2]
				endif
			next i
			ovenWidth = ovenWidth2
			parameters ovenWidthPos = ovenWidthPos, ovenWidth = ovenWidth
		endif
		parameters ovenPos = ovenPos
	else
		ovenWidth2 = ovenWidth
		for i = 1 to nofOvens
			ovenWidthPos[i][1] = elementWidth[isOven[i]][1]
			ovenWidthPos[i][2] = elementWidth[isOven[i]][2]
			ovenWidthPos[i][3] = elementWidth[isOven[i]][3]
			ovenWidthPos[i][4] = elementWidth[isOven[i]][4]
		next i
		parameters ovenWidthPos = ovenWidthPos, ovenWidth2 = ovenWidth2

		if GLOB_MODPAR_NAME = "ovenHeigth" then
			for i =1 to nofOvens
				if ovenHeigth[i] < ovenHeigthMin then
					ovenHeigth[i] = ovenHeigthMin
					parameters ovenHeigth[i] = ovenHeigth[i]
				else
					if ovenHeigth[i] > ovenHeigthMax then
						ovenHeigth[i] = ovenHeigthMax
						parameters ovenHeigth[i] = ovenHeigth[i]
					endif
				endif
			next i
		endif
	endif
else
	hideparameter	"oven_mat",
					"glass_mat",
					"nOvens",
					"nPrevOvens",
					"ovenWidth",
					"ovenWidth2",
					"ovenPos",
					"ovenPos2",
					"nSegmentOven",
					"ovenWidthPos",
					"ovenVerticalPos",
					"ovenHeigth",
					"ovenSymbType",
					"iOvenSymbType",
					"ovenText"

	lock			"oven_mat",
					"glass_mat",
					"nOvens",
					"nPrevOvens",
					"ovenWidth",
					"ovenWidth2",
					"ovenPos",
					"ovenPos2",
					"nSegmentOven",
					"ovenWidthPos",
					"ovenVerticalPos",
					"ovenHeigth",
					"ovenSymbType",
					"iOvenSymbType",
					"ovenText"
endif


! ------------------------------------------------------------------------------
! Refrigerators
! ------------------------------------------------------------------------------
values "refrigeratorDepth"	range [counterDepth, ]
values "refrigeratorHeigth"	range [counterHeigth-counterThickness, ]

values "refrigeratorType" stRefrigeratorType
values "iRefrigeratorType" ACC_REFRI_TOP, ACC_REFRI_BOTTOM, ACC_REFRI_SIDE, ACC_REFRI_FRENCH, ACC_REFRI_COMPACT
if GLOB_MODPAR_NAME = "refrigeratorType" then
	iRefrigeratorType = 1
	for i = 1 to vardim1(stRefrigeratorType)
		if refrigeratorType = stRefrigeratorType[i] then
			iRefrigeratorType = i
			i = vardim1(stRefrigeratorType)
		endif
	next i
	parameters iRefrigeratorType = iRefrigeratorType
else
	iRefrigeratorType = max(min(iRefrigeratorType,vardim1(stRefrigeratorType)),1)
	parameters refrigeratorType = stRefrigeratorType[iRefrigeratorType]
endif


if tempRefrigeratorType <> iRefrigeratorType then
	if tempRefrigeratorType <> ACC_REFRI_SIDE & iRefrigeratorType = ACC_REFRI_SIDE then
		for i = 1 to vardim1(refrigeratorWidth)
			refrigeratorWidth[i]	= refriDefaults[ACC_REFRI_SIDE]
			refrigeratorWidth2[i]	= refriDefaults[ACC_REFRI_SIDE]
		next i
		parameters refrigeratorWidth = refrigeratorWidth, refrigeratorWidth2 = refrigeratorWidth2
	else
		if tempRefrigeratorType = ACC_REFRI_SIDE & iRefrigeratorType <> ACC_REFRI_SIDE then
			for i = 1 to vardim1(refrigeratorWidth)
				refrigeratorWidth[i]	= refriDefaults[iRefrigeratorType]
				refrigeratorWidth2[i]	= refriDefaults[iRefrigeratorType]
			next i
			parameters refrigeratorWidth = refrigeratorWidth, refrigeratorWidth2 = refrigeratorWidth2
		endif
	endif
	parameters tempRefrigeratorType = iRefrigeratorType
endif

values "refriSymbType" stSymbType
values "iRefriSymbType" SYMBTYPE_SYMBOL, SYMBTYPE_TEXT
if GLOB_MODPAR_NAME = "refriSymbType" then
	iRefriSymbType = 1
	for i = 2 to vardim1(stSymbType)
		if refriSymbType = stSymbType[i] then iRefriSymbType = i
	next i
	parameters iRefriSymbType = iRefriSymbType
else
	iRefriSymbType = max(min(iRefriSymbType,vardim1(stSymbType)),1)
	parameters refriSymbType = stSymbType[iRefriSymbType]
endif


values "nRefrigerators" range [1, nMaxAccessory]
if nofRefrigerators > 0 then
	if iRefriSymbType = SYMBTYPE_SYMBOL then
		hideparameter "refriText"
		lock "refriText"
	endif

	values "refrigeratorWidth"	range [minSize, ]
	values "refrigeratorWidth2"	range [minSize, ]
	if GLOB_MODPAR_NAME = "refrigeratorWidth" | GLOB_MODPAR_NAME = "refrigeratorWidth2" then
		nElementChanged = 1
		for i = 2 to nMaxAccessory				! Width Connection
			if abs(refrigeratorWidth[i] - refrigeratorWidth2[i]) > EPS then
				nElementChanged = i
				i = nMaxAccessory
			endif
		next i
		if GLOB_MODPAR_NAME = "refrigeratorWidth" then
			for i = 1 to nMaxAccessory
				if nElementChanged <> i then		!Width Connection
					refrigeratorWidth[i] = refrigeratorWidth[nElementChanged]
					parameters refrigeratorWidth[i] = refrigeratorWidth[i]
				endif
				if refrigeratorWidth[i] < minSize then
					refrigeratorWidth[i] = minSize
					parameters refrigeratorWidth[i] = refrigeratorWidth[i]
				endif
				if i < nofRefrigerators + 1 then
					refrigeratorWidthPos[i][1] = refrigeratorWidthPos[i][3] + cos(elementAngle[isRefri[i]]) * refrigeratorWidth[i]
					refrigeratorWidthPos[i][2] = refrigeratorWidthPos[i][4] + sin(elementAngle[isRefri[i]]) * refrigeratorWidth[i]

					refrigeratorPos[i][1] = (refrigeratorWidthPos[i][3] - refrigeratorWidthPos[i][1]) / 2 + refrigeratorWidthPos[i][1]
					refrigeratorPos[i][2] = (refrigeratorWidthPos[i][4] - refrigeratorWidthPos[i][2]) / 2 + refrigeratorWidthPos[i][2]
				endif
			next i
			refrigeratorWidth2 = refrigeratorWidth
			parameters refrigeratorWidthPos = refrigeratorWidthPos, refrigeratorWidth2 = refrigeratorWidth2
		else
			for i = 1 to nMaxAccessory
				if nElementChanged <> i then		!Width Connection
					refrigeratorWidth2[i] = refrigeratorWidth2[nElementChanged]
					parameters refrigeratorWidth2[i] = refrigeratorWidth2[i]
				endif
				if refrigeratorWidth2[i] < minSize then
					refrigeratorWidth2[i] = minSize
					parameters refrigeratorWidth2[i] = refrigeratorWidth2[i]
				endif
				if i < nofRefrigerators + 1 then
					refrigeratorWidthPos[i][3] = refrigeratorWidthPos[i][1] - cos(elementAngle[isRefri[i]]) * refrigeratorWidth2[i]
					refrigeratorWidthPos[i][4] = refrigeratorWidthPos[i][2] - sin(elementAngle[isRefri[i]]) * refrigeratorWidth2[i]

					refrigeratorPos[i][1] = (refrigeratorWidthPos[i][3] - refrigeratorWidthPos[i][1]) / 2 + refrigeratorWidthPos[i][1]
					refrigeratorPos[i][2] = (refrigeratorWidthPos[i][4] - refrigeratorWidthPos[i][2]) / 2 + refrigeratorWidthPos[i][2]
				endif
			next i
			refrigeratorWidth = refrigeratorWidth2
			parameters refrigeratorWidthPos = refrigeratorWidthPos, refrigeratorWidth = refrigeratorWidth
		endif
		parameters refrigeratorPos = refrigeratorPos
	else
		refrigeratorWidth2 = refrigeratorWidth
		for i = 1 to nofRefrigerators
			refrigeratorWidthPos[i][1] = elementWidth[isRefri[i]][1]
			refrigeratorWidthPos[i][2] = elementWidth[isRefri[i]][2]
			refrigeratorWidthPos[i][3] = elementWidth[isRefri[i]][3]
			refrigeratorWidthPos[i][4] = elementWidth[isRefri[i]][4]
		next i
		parameters refrigeratorWidthPos = refrigeratorWidthPos, refrigeratorWidth2 = refrigeratorWidth2
	endif

	if iRefrigeratorType = ACC_REFRI_COMPACT then
		hideparameter	"refrigeratorHeigth", "refrigeratorDepth", "bRefriWallCabinet"
		lock			"refrigeratorHeigth", "refrigeratorDepth", "bRefriWallCabinet"
	endif

else
	hideparameter	"refrigerator_mat",
					"nRefrigerators",
					"nPrevRefri",
					"refrigeratorType",
					"iRefrigeratorType",
					"tempRefrigeratorType",
					"refrigeratorHeigth",
					"refrigeratorDepth",
					"bRefriWallCabinet",
					"refrigeratorWidth",
					"refrigeratorWidth2",
					"refrigeratorPos",
					"refrigeratorPos2",
					"nSegmentRefri",
					"refrigeratorWidthPos",
					"refriDefaults",
					"refriSymbType",
					"iRefriSymbType",
					"refriText"

	lock			"refrigerator_mat",
					"nRefrigerators",
					"nPrevRefri",
					"refrigeratorType",
					"iRefrigeratorType",
					"tempRefrigeratorType",
					"refrigeratorHeigth",
					"refrigeratorDepth",
					"bRefriWallCabinet",
					"refrigeratorWidth",
					"refrigeratorWidth2",
					"refrigeratorPos",
					"refrigeratorPos2",
					"nSegmentRefri",
					"refrigeratorWidthPos",
					"refriDefaults",
					"refriSymbType",
					"iRefriSymbType",
					"refriText"
endif


! ------------------------------------------------------------------------------
! Dishwasher
! ------------------------------------------------------------------------------
values "nDishwasher" range [1, nMaxAccessory]

values "dishwasherSymbType" stSymbType
values "iDishwasherSymbType" SYMBTYPE_SYMBOL, SYMBTYPE_TEXT
if GLOB_MODPAR_NAME = "dishwasherSymbType" then
	iDishwasherSymbType = 1
	for i = 2 to vardim1(stSymbType)
		if dishwasherSymbType = stSymbType[i] then iDishwasherSymbType = i
	next i
	parameters iDishwasherSymbType = iDishwasherSymbType
else
	iDishwasherSymbType = max(min(iDishwasherSymbType,vardim1(stSymbType)),1)
	parameters dishwasherSymbType = stSymbType[iDishwasherSymbType]
endif

if nofDishwasher > 0 then
	if iDishwasherSymbType = SYMBTYPE_SYMBOL then
		hideparameter "dishwasherText"
		lock "dishwasherText"
	endif

	values "dishwasherWidth"	range [minSize, ]
	values "dishwasherWidth2"	range [minSize, ]
	if GLOB_MODPAR_NAME = "dishwasherWidth" | GLOB_MODPAR_NAME = "dishwasherWidth2" then
		nElementChanged = 1
		for i = 2 to nMaxAccessory				! Width Connection
			if abs(dishwasherWidth[i] - dishwasherWidth2[i]) > EPS then
				nElementChanged = i
				i = nMaxAccessory
			endif
		next i
		if GLOB_MODPAR_NAME = "dishwasherWidth" then
			for i = 1 to nMaxAccessory
				if nElementChanged <> i then		!Width Connection
					dishwasherWidth[i] = dishwasherWidth[nElementChanged]
					parameters dishwasherWidth[i] = dishwasherWidth[i]
				endif
				if dishwasherWidth[i] < minSize then
					dishwasherWidth[i] = minSize
					parameters dishwasherWidth[i] = dishwasherWidth[i]
				endif
				if i < nofDishwasher + 1 then
					dishwasherWidthPos[i][1] = dishwasherWidthPos[i][3] + cos(elementAngle[isDishwash[i]]) * dishwasherWidth[i]
					dishwasherWidthPos[i][2] = dishwasherWidthPos[i][4] + sin(elementAngle[isDishwash[i]]) * dishwasherWidth[i]

					dishwasherPos[i][1] = (dishwasherWidthPos[i][3] - dishwasherWidthPos[i][1]) / 2 + dishwasherWidthPos[i][1]
					dishwasherPos[i][2] = (dishwasherWidthPos[i][4] - dishwasherWidthPos[i][2]) / 2 + dishwasherWidthPos[i][2]
				endif
			next i
			dishwasherWidth2 = dishwasherWidth
			parameters dishwasherWidthPos = dishwasherWidthPos, dishwasherWidth2 = dishwasherWidth2
		else
			for i = 1 to nMaxAccessory
				if nElementChanged <> i then		!Width Connection
					dishwasherWidth2[i] = dishwasherWidth2[nElementChanged]
					parameters dishwasherWidth2[i] = dishwasherWidth2[i]
				endif
				if dishwasherWidth2[i] < minSize then
					dishwasherWidth2[i] = minSize
					parameters dishwasherWidth2[i] = dishwasherWidth2[i]
				endif
				if i < nofDishwasher + 1 then
					dishwasherWidthPos[i][3] = dishwasherWidthPos[i][1] - cos(elementAngle[isDishwash[i]]) * dishwasherWidth2[i]
					dishwasherWidthPos[i][4] = dishwasherWidthPos[i][2] - sin(elementAngle[isDishwash[i]]) * dishwasherWidth2[i]

					dishwasherPos[i][1] = (dishwasherWidthPos[i][3] - dishwasherWidthPos[i][1]) / 2 + dishwasherWidthPos[i][1]
					dishwasherPos[i][2] = (dishwasherWidthPos[i][4] - dishwasherWidthPos[i][2]) / 2 + dishwasherWidthPos[i][2]
				endif
			next i
			dishwasherWidth = dishwasherWidth2
			parameters dishwasherWidthPos = dishwasherWidthPos, dishwasherWidth = dishwasherWidth
		endif
		parameters dishwasherPos = dishwasherPos
	else
		dishwasherWidth2 = dishwasherWidth
		for i = 1 to nofDishwasher
			dishwasherWidthPos[i][1] = elementWidth[isDishwash[i]][1]
			dishwasherWidthPos[i][2] = elementWidth[isDishwash[i]][2]
			dishwasherWidthPos[i][3] = elementWidth[isDishwash[i]][3]
			dishwasherWidthPos[i][4] = elementWidth[isDishwash[i]][4]
		next i
		parameters dishwasherWidthPos = dishwasherWidthPos, dishwasherWidth2 = dishwasherWidth2
	endif
else
	hideparameter	"dishwasher_mat",
					"nDishwasher",
					"nPrevDishwasher",
					"dishwasherWidth",
					"dishwasherWidth2",
					"dishwasherPos",
					"dishwasherPos2",
					"nSegmentDishwasher",
					"dishwasherWidthPos",
					"dishwasherSymbType",
					"iDishwasherSymbType",
					"dishwasherText"

	lock			"dishwasher_mat",
					"nDishwasher",
					"nPrevDishwasher",
					"dishwasherWidth",
					"dishwasherWidth2",
					"dishwasherPos",
					"dishwasherPos2",
					"nSegmentDishwasher",
					"dishwasherWidthPos",
					"dishwasherSymbType",
					"iDishwasherSymbType",
					"dishwasherText"
endif


! ------------------------------------------------------------------------------
! Washer
! ------------------------------------------------------------------------------
values "nWasher" range [1, nMaxAccessory]

values "washerSymbType" stSymbType
values "iWasherSymbType" SYMBTYPE_SYMBOL, SYMBTYPE_TEXT
if GLOB_MODPAR_NAME = "washerSymbType" then
	iWasherSymbType = 1
	for i = 2 to vardim1(stSymbType)
		if washerSymbType = stSymbType[i] then iWasherSymbType = i
	next i
	parameters iWasherSymbType = iWasherSymbType
else
	iWasherSymbType = max(min(iWasherSymbType,vardim1(stSymbType)),1)
	parameters washerSymbType = stSymbType[iWasherSymbType]
endif

if nofWasher > 0 then
	if iWasherSymbType = SYMBTYPE_SYMBOL then
		hideparameter "washerText"
		lock "washerText"
	endif

	values "washerWidth"	range [minSize, ]
	values "washerWidth2"	range [minSize, ]
	if GLOB_MODPAR_NAME = "washerWidth" | GLOB_MODPAR_NAME = "washerWidth2" then
		nElementChanged = 1
		for i = 2 to nMaxAccessory				! Width Connection
			if abs(washerWidth[i] - washerWidth2[i]) > EPS then
				nElementChanged = i
				i = nMaxAccessory
			endif
		next i
		if GLOB_MODPAR_NAME = "washerWidth" then
			for i = 1 to nMaxAccessory
				if nElementChanged <> i then		!Width Connection
					washerWidth[i] = washerWidth[nElementChanged]
					parameters washerWidth[i] = washerWidth[i]
				endif
				if washerWidth[i] < minSize then
					washerWidth[i] = minSize
					parameters washerWidth[i] = washerWidth[i]
				endif
				if i < nofWasher + 1 then
					washerWidthPos[i][1] = washerWidthPos[i][3] + cos(elementAngle[isWasher[i]]) * washerWidth[i]
					washerWidthPos[i][2] = washerWidthPos[i][4] + sin(elementAngle[isWasher[i]]) * washerWidth[i]

					washerPos[i][1] = (washerWidthPos[i][3] - washerWidthPos[i][1]) / 2 + washerWidthPos[i][1]
					washerPos[i][2] = (washerWidthPos[i][4] - washerWidthPos[i][2]) / 2 + washerWidthPos[i][2]
				endif
			next i
			washerWidth2 = washerWidth
			parameters washerWidthPos = washerWidthPos, washerWidth2 = washerWidth2
		else
			for i = 1 to nMaxAccessory
				if nElementChanged <> i then	!Width Connection
					washerWidth2[i] = washerWidth2[nElementChanged]
					parameters washerWidth2[i] = washerWidth2[i]
				endif
				if washerWidth2[i] < minSize then
					washerWidth2[i] = minSize
					parameters washerWidth2[i] = washerWidth2[i]
				endif
				if i < nofWasher + 1 then
					washerWidthPos[i][3] = washerWidthPos[i][1] - cos(elementAngle[isWasher[i]]) * washerWidth2[i]
					washerWidthPos[i][4] = washerWidthPos[i][2] - sin(elementAngle[isWasher[i]]) * washerWidth2[i]

					washerPos[i][1] = (washerWidthPos[i][3] - washerWidthPos[i][1]) / 2 + washerWidthPos[i][1]
					washerPos[i][2] = (washerWidthPos[i][4] - washerWidthPos[i][2]) / 2 + washerWidthPos[i][2]
				endif
			next i
			washerWidth = washerWidth2
			parameters washerWidthPos = washerWidthPos, washerWidth = washerWidth
		endif
		parameters washerPos = washerPos
	else
		washerWidth2 = washerWidth
		for i = 1 to nofWasher
			washerWidthPos[i][1] = elementWidth[isWasher[i]][1]
			washerWidthPos[i][2] = elementWidth[isWasher[i]][2]
			washerWidthPos[i][3] = elementWidth[isWasher[i]][3]
			washerWidthPos[i][4] = elementWidth[isWasher[i]][4]
		next i
		parameters washerWidthPos = washerWidthPos, washerWidth2 = washerWidth2
	endif
else
	hideparameter	"washer_mat",
					"nWasher",
					"nPrevWasher",
					"washerWidth",
					"washerWidth2",
					"washerPos",
					"washerPos2",
					"nSegmentWasher",
					"washerWidthPos",
					"washerSymbType",
					"iWasherSymbType",
					"washerText"

	lock			"washer_mat",
					"nWasher",
					"nPrevWasher",
					"washerWidth",
					"washerWidth2",
					"washerPos",
					"washerPos2",
					"nSegmentWasher",
					"washerWidthPos",
					"washerSymbType",
					"iWasherSymbType",
					"washerText"
endif


! ------------------------------------------------------------------------------
! Minimal Space
! ------------------------------------------------------------------------------
values "MSFront" range [0, ]


! ==============================================================================
!
end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
!
! ==============================================================================

! ------------------------------------------------------------------------------
! Move References Line Point
! ------------------------------------------------------------------------------
"moveRefLinePoints_1":
! ------------------------------------------------------------------------------

	movedPoint = 0
	for i = 1 to nRefPoints[1] - (iLayoutType = LAYOUT_ISLAND)*2
		if abs(refLinePoints_1[i][1] - tempRefLinePoints_1[i][1]) > EPS | abs(refLinePoints_1[i][2] - tempRefLinePoints_1[i][2]) > EPS then	!moved points
			movedPoint = i
		endif
	next i

	if movedPoint > 0 & movedPoint <= nRefPoints[1] then
		for i = 1 to nRefPoints[1] - (iLayoutType = LAYOUT_ISLAND)*2
			if i <> movedPoint then
				refPointDistance = (refLinePoints_1[i][1] - refLinePoints_1[movedPoint][1])^2 + (refLinePoints_1[i][2] - refLinePoints_1[movedPoint][2])^2
				if refPointDistance < minRefPointDistSquare then
					xo = refLinePoints_1[i][1]
					yo = refLinePoints_1[i][2]
					ro = minRefPointDist

					if movedPoint = nRefPoints[1] then
						s  = movedPoint - 1
						s2 = movedPoint
					else
						s  = movedPoint
						s2 = movedPoint + 1
					endif

					x1 = refLinePoints_1[s][1]
					y1 = refLinePoints_1[s][2]
					x2 = refLinePoints_1[s2][1]
					y2 = refLinePoints_1[s2][2]

					gosub "intersection_Circle_Line"

					!Select Good Intersection Circle Line
					cx = 0
					cy = 0
					if state then
						cx = xa
						cy = ya

						refLinePoints_1[movedPoint][1] = cx
						refLinePoints_1[movedPoint][2] = cy
						parameters	refLinePoints_1[movedPoint][1] = refLinePoints_1[movedPoint][1],
									refLinePoints_1[movedPoint][2] = refLinePoints_1[movedPoint][2]
					endif
				endif
			endif
		next i
	endif
return


! ------------------------------------------------------------------------------
"moveRefLinePoints_2":
! ------------------------------------------------------------------------------

	movedPoint = 0
	for i = 1 to nRefPoints[2]
		if abs(refLinePoints_2[i][1] - tempRefLinePoints_2[i][1]) > EPS | abs(refLinePoints_2[i][2] - tempRefLinePoints_2[i][2]) > EPS then	!moved points
			movedPoint = i
		endif
	next i

	if movedPoint > 0 & movedPoint <= nRefPoints[2] then
		for i = 1 to nRefPoints[2]
			if i <> movedPoint then
				refPointDistance = (refLinePoints_2[i][1] - refLinePoints_2[movedPoint][1])^2 + (refLinePoints_2[i][2] - refLinePoints_2[movedPoint][2])^2
				if refPointDistance < minRefPointDistSquare then
					xo = refLinePoints_2[i][1]
					yo = refLinePoints_2[i][2]
					ro = minRefPointDist

					if movedPoint = nRefPoints[2] then
						s  = movedPoint - 1
						s2 = movedPoint
					else
						s  = movedPoint
						s2 = movedPoint + 1
					endif

					x1 = refLinePoints_2[s][1]
					y1 = refLinePoints_2[s][2]
					x2 = refLinePoints_2[s2][1]
					y2 = refLinePoints_2[s2][2]

					gosub "intersection_Circle_Line"

					!Select Good Intersection Circle Line
					cx = 0
					cy = 0
					if state then
						cx = xa
						cy = ya

						refLinePoints_2[movedPoint][1] = cx
						refLinePoints_2[movedPoint][2] = cy
						parameters	refLinePoints_2[movedPoint][1] = refLinePoints_2[movedPoint][1],
									refLinePoints_2[movedPoint][2] = refLinePoints_2[movedPoint][2]
					endif
				endif
			endif
		next i
	endif
return


! ------------------------------------------------------------------------------
"moveRefLinePoints_3":
! ------------------------------------------------------------------------------

	movedPoint = 0
	for i = 1 to nRefPoints[3]
		if abs(refLinePoints_3[i][1] - tempRefLinePoints_3[i][1]) > EPS | abs(refLinePoints_3[i][2] - tempRefLinePoints_3[i][2]) > EPS then	!moved points
			movedPoint = i
		endif
	next i

	if movedPoint > 0 & movedPoint <= nRefPoints[3] then
		for i = 1 to nRefPoints[2]
			if i <> movedPoint then
				refPointDistance = (refLinePoints_3[i][1] - refLinePoints_3[movedPoint][1])^2 + (refLinePoints_3[i][2] - refLinePoints_3[movedPoint][2])^2
				if refPointDistance < minRefPointDistSquare then
					xo = refLinePoints_3[i][1]
					yo = refLinePoints_3[i][2]
					ro = minRefPointDist

					if movedPoint = nRefPoints[3] then
						s  = movedPoint - 1
						s2 = movedPoint
					else
						s  = movedPoint
						s2 = movedPoint + 1
					endif

					x1 = refLinePoints_3[s][1]
					y1 = refLinePoints_3[s][2]
					x2 = refLinePoints_3[s2][1]
					y2 = refLinePoints_3[s2][2]

					gosub "intersection_Circle_Line"

					!Select Good Intersection Circle Line
					cx = 0
					cy = 0
					if state then
						cx = xa
						cy = ya

						refLinePoints_3[movedPoint][1] = cx
						refLinePoints_3[movedPoint][2] = cy
						parameters	refLinePoints_3[movedPoint][1] = refLinePoints_3[movedPoint][1],
									refLinePoints_3[movedPoint][2] = refLinePoints_3[movedPoint][2]
					endif
				endif
			endif
		next i
	endif
return


! ------------------------------------------------------------------------------
! Move Wall Line Point
! ------------------------------------------------------------------------------
"moveWallLinePoints":
! ------------------------------------------------------------------------------

	for i = 1 to nWallCabinet
		dx = wallCabinetPos_2[i][1] - wallCabinetPos_1[i][1]
		dy = wallCabinetPos_2[i][2] - wallCabinetPos_1[i][2]
		wallDistance = dx^2 + dy^2
		if wallDistance < minWallPointDistSquare then
			if abs(dx) < EPS then
				if dy > 0 then
					wallAngle = 90
				else
					wallAngle = 270
				endif
			else
				wallAngle = atn(dy/dx)
				if dx > 0 then wallAngle = wallAngle + 180
			endif

			if moved = 1 then
				wallCabinetPos_1[i][1] = wallCabinetPos_2[i][1] + cos(wallAngle) * minWallPointDist
				wallCabinetPos_1[i][2] = wallCabinetPos_2[i][2] + sin(wallAngle) * minWallPointDist
				parameters	wallCabinetPos_1[i][1] = wallCabinetPos_1[i][1],
							wallCabinetPos_1[i][2] = wallCabinetPos_1[i][2]
			else
				wallCabinetPos_2[i][1] = wallCabinetPos_1[i][1] - cos(wallAngle) * minWallPointDist
				wallCabinetPos_2[i][2] = wallCabinetPos_1[i][2] - sin(wallAngle) * minWallPointDist
				parameters	wallCabinetPos_2[i][1] = wallCabinetPos_2[i][1],
							wallCabinetPos_2[i][2] = wallCabinetPos_2[i][2]
			endif
		endif
	next i
return
]]>
</Script_VL>

<Comment SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Comment>

<ParamSection SectVersion="22" SectionFlags="0" SubIdent="0">
	<ParamSectHeader>
		<AutoHotspots>false</AutoHotspots>
		<StatBits>
			<STBit_UIDefault/>
			<STBit_FixSize/>
			<STBit_UIUseHierarchicalPages/>
		</StatBits>
		<WDLeftFrame>0</WDLeftFrame>
		<WDRightFrame>0</WDRightFrame>
		<WDTopFrame>0</WDTopFrame>
		<WDBotFrame>0</WDBotFrame>
		<LayFlags>65535</LayFlags>
		<WDMirrorThickness>0</WDMirrorThickness>
		<WDWallInset>0</WDWallInset>
	</ParamSectHeader>
	<Parameters>
		<Length Name="A">
			<Description><![CDATA["Размер 1"]]></Description>
			<Fix/>
			<Value>3</Value>
		</Length>
		<Length Name="B">
			<Description><![CDATA["Размер 2"]]></Description>
			<Fix/>
			<Value>3</Value>
		</Length>
		<Length Name="ZZYZX">
			<Description><![CDATA["Высота"]]></Description>
			<Fix/>
			<Value>2.25</Value>
		</Length>
		<String Name="LibraryLangCode">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA["RUS"]]></Value>
		</String>
		<Boolean Name="AC_show2DHotspotsIn3D">
			<Description><![CDATA["Показ Узловых 2D Точек в 3D"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="ac_bottomlevel">
			<Description><![CDATA["Отметка Низа"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="ac_toplevel">
			<Description><![CDATA["Отметка Верха"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="lastPointLength">
			<Description><![CDATA["Последняя Точка"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>5.38</Value>
		</Length>
		<Boolean Name="bChangeDefault">
			<Description><![CDATA["Изменение Значений по Умолчанию (Отладка)"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- gs_LayoutSettings: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_LayoutSettings">
			<Description><![CDATA["Планировка"]]></Description>
		</Title>
		<String Name="layoutType">
			<Description><![CDATA["Тип Планировки"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["U-образная"]]></Value>
		</String>
		<Integer Name="iLayoutType">
			<Description><![CDATA["Тип Планировки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<Integer Name="nChains">
			<Description><![CDATA["Количество Столешниц"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Integer Name="nChainSegment_1">
			<Description><![CDATA["Количество Сегментов (Столешница 1)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</Integer>
		<Integer Name="nChainSegment_2">
			<Description><![CDATA["Количество Сегментов (Столешница 2)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="nChainSegment_3">
			<Description><![CDATA["Количество Сегментов (Столешница 3)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="nCounterForUI">
			<Description><![CDATA["Количество Столешниц"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="nSegmentForUI_1">
			<Description><![CDATA["Количество Сегментов (Столешница 1)"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<Integer Name="nSegmentForUI_2">
			<Description><![CDATA["Количество Сегментов (Столешница 2)"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="nSegmentForUI_3">
			<Description><![CDATA["Количество Сегментов (Столешница 3)"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="refLinePoints_1">
			<Description><![CDATA["Точки Линии Привязки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="4" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="1" Row="2">3</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="1" Row="3">3</AVal>
				<AVal Column="2" Row="3">3</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">3</AVal>
			</ArrayValues>
		</Length>
		<Length Name="tempRefLinePoints_1">
			<Description><![CDATA["Точки Линии Привязки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="4" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="1" Row="2">3</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="1" Row="3">3</AVal>
				<AVal Column="2" Row="3">3</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">3</AVal>
			</ArrayValues>
		</Length>
		<Length Name="refLinePoints_2">
			<Description><![CDATA["Точки Линии Привязки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="2">
				<AVal Column="1" Row="1">5</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="1" Row="2">5</AVal>
				<AVal Column="2" Row="2">1</AVal>
			</ArrayValues>
		</Length>
		<Length Name="tempRefLinePoints_2">
			<Description><![CDATA["Точки Линии Привязки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="2">
				<AVal Column="1" Row="1">5</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="1" Row="2">5</AVal>
				<AVal Column="2" Row="2">1</AVal>
			</ArrayValues>
		</Length>
		<Length Name="refLinePoints_3">
			<Description><![CDATA["Точки Линии Привязки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="2">
				<AVal Column="1" Row="1">8</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="1" Row="2">8</AVal>
				<AVal Column="2" Row="2">2</AVal>
			</ArrayValues>
		</Length>
		<Length Name="tempRefLinePoints_3">
			<Description><![CDATA["Точки Линии Привязки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="2">
				<AVal Column="1" Row="1">8</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="1" Row="2">8</AVal>
				<AVal Column="2" Row="2">2</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="nTallCabinet">
			<Description><![CDATA["Количество Высоких Шкафов"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="nPrevTallCabinet">
			<Description><![CDATA["Предыдущее Количество Высоких Шкафов"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Length Name="tallCabinetWidth">
			<Description><![CDATA["Ширина Высокого Шкафа"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0.6</AVal>
				<AVal Row="2">0.6</AVal>
				<AVal Row="3">0.6</AVal>
				<AVal Row="4">0.6</AVal>
				<AVal Row="5">0.6</AVal>
				<AVal Row="6">0.6</AVal>
				<AVal Row="7">0.6</AVal>
				<AVal Row="8">0.6</AVal>
			</ArrayValues>
		</Length>
		<Length Name="tallCabinetWidth2">
			<Description><![CDATA["Ширина Высокого Шкафа"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0.6</AVal>
				<AVal Row="2">0.6</AVal>
				<AVal Row="3">0.6</AVal>
				<AVal Row="4">0.6</AVal>
				<AVal Row="5">0.6</AVal>
				<AVal Row="6">0.6</AVal>
				<AVal Row="7">0.6</AVal>
				<AVal Row="8">0.6</AVal>
			</ArrayValues>
		</Length>
		<Length Name="tallCabPos">
			<Description><![CDATA["Расположение Высокого Шкафа"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="2">
				<AVal Column="1" Row="1">-0.4</AVal>
				<AVal Column="2" Row="1">0.3</AVal>
				<AVal Column="1" Row="2">-4.6</AVal>
				<AVal Column="2" Row="2">0.3</AVal>
				<AVal Column="1" Row="3">-3.9</AVal>
				<AVal Column="2" Row="3">0.3</AVal>
				<AVal Column="1" Row="4">-3.2</AVal>
				<AVal Column="2" Row="4">0.3</AVal>
				<AVal Column="1" Row="5">-2.5</AVal>
				<AVal Column="2" Row="5">0.3</AVal>
				<AVal Column="1" Row="6">-1.8</AVal>
				<AVal Column="2" Row="6">0.3</AVal>
				<AVal Column="1" Row="7">-1.1</AVal>
				<AVal Column="2" Row="7">0.3</AVal>
				<AVal Column="1" Row="8">-0.4</AVal>
				<AVal Column="2" Row="8">0.3</AVal>
			</ArrayValues>
		</Length>
		<Length Name="tallCabPos2">
			<Description><![CDATA["Расположение Высокого Шкафа"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="2">
				<AVal Column="1" Row="1">-0.4</AVal>
				<AVal Column="2" Row="1">0.3</AVal>
				<AVal Column="1" Row="2">-4.6</AVal>
				<AVal Column="2" Row="2">0.3</AVal>
				<AVal Column="1" Row="3">-3.9</AVal>
				<AVal Column="2" Row="3">0.3</AVal>
				<AVal Column="1" Row="4">-3.2</AVal>
				<AVal Column="2" Row="4">0.3</AVal>
				<AVal Column="1" Row="5">-2.5</AVal>
				<AVal Column="2" Row="5">0.3</AVal>
				<AVal Column="1" Row="6">-1.8</AVal>
				<AVal Column="2" Row="6">0.3</AVal>
				<AVal Column="1" Row="7">-1.1</AVal>
				<AVal Column="2" Row="7">0.3</AVal>
				<AVal Column="1" Row="8">-0.4</AVal>
				<AVal Column="2" Row="8">0.3</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="nSegmentTall">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="tallCabWidthPos">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="4">
				<AVal Column="1" Row="1">-0.7</AVal>
				<AVal Column="2" Row="1">0.3</AVal>
				<AVal Column="3" Row="1">-0.1</AVal>
				<AVal Column="4" Row="1">0.3</AVal>
				<AVal Column="1" Row="2">-4.9</AVal>
				<AVal Column="2" Row="2">0.3</AVal>
				<AVal Column="3" Row="2">-4.3</AVal>
				<AVal Column="4" Row="2">0.3</AVal>
				<AVal Column="1" Row="3">-4.2</AVal>
				<AVal Column="2" Row="3">0.3</AVal>
				<AVal Column="3" Row="3">-3.6</AVal>
				<AVal Column="4" Row="3">0.3</AVal>
				<AVal Column="1" Row="4">-3.5</AVal>
				<AVal Column="2" Row="4">0.3</AVal>
				<AVal Column="3" Row="4">-2.9</AVal>
				<AVal Column="4" Row="4">0.3</AVal>
				<AVal Column="1" Row="5">-2.8</AVal>
				<AVal Column="2" Row="5">0.3</AVal>
				<AVal Column="3" Row="5">-2.2</AVal>
				<AVal Column="4" Row="5">0.3</AVal>
				<AVal Column="1" Row="6">-2.1</AVal>
				<AVal Column="2" Row="6">0.3</AVal>
				<AVal Column="3" Row="6">-1.5</AVal>
				<AVal Column="4" Row="6">0.3</AVal>
				<AVal Column="1" Row="7">-1.4</AVal>
				<AVal Column="2" Row="7">0.3</AVal>
				<AVal Column="3" Row="7">-0.8</AVal>
				<AVal Column="4" Row="7">0.3</AVal>
				<AVal Column="1" Row="8">-0.7</AVal>
				<AVal Column="2" Row="8">0.3</AVal>
				<AVal Column="3" Row="8">-0.1</AVal>
				<AVal Column="4" Row="8">0.3</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="nWallCabinet">
			<Description><![CDATA["Количество Навесных Шкафов"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Length Name="wallCabinetPos_1">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0.15</AVal>
				<AVal Column="1" Row="2">-0.1</AVal>
				<AVal Column="2" Row="2">0.15</AVal>
				<AVal Column="1" Row="3">-1.2</AVal>
				<AVal Column="2" Row="3">0.15</AVal>
				<AVal Column="1" Row="4">-2.3</AVal>
				<AVal Column="2" Row="4">0.15</AVal>
				<AVal Column="1" Row="5">-3.4</AVal>
				<AVal Column="2" Row="5">0.15</AVal>
				<AVal Column="1" Row="6">-4.5</AVal>
				<AVal Column="2" Row="6">0.15</AVal>
				<AVal Column="1" Row="7">-5.6</AVal>
				<AVal Column="2" Row="7">0.15</AVal>
				<AVal Column="1" Row="8">-6.7</AVal>
				<AVal Column="2" Row="8">0.15</AVal>
			</ArrayValues>
		</Length>
		<Length Name="wallCabinetPos_2">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="2">
				<AVal Column="1" Row="1">1</AVal>
				<AVal Column="2" Row="1">0.15</AVal>
				<AVal Column="1" Row="2">-1.1</AVal>
				<AVal Column="2" Row="2">0.15</AVal>
				<AVal Column="1" Row="3">-2.2</AVal>
				<AVal Column="2" Row="3">0.15</AVal>
				<AVal Column="1" Row="4">-3.3</AVal>
				<AVal Column="2" Row="4">0.15</AVal>
				<AVal Column="1" Row="5">-4.4</AVal>
				<AVal Column="2" Row="5">0.15</AVal>
				<AVal Column="1" Row="6">-5.5</AVal>
				<AVal Column="2" Row="6">0.15</AVal>
				<AVal Column="1" Row="7">-6.6</AVal>
				<AVal Column="2" Row="7">0.15</AVal>
				<AVal Column="1" Row="8">-7.7</AVal>
				<AVal Column="2" Row="8">0.15</AVal>
			</ArrayValues>
		</Length>
		<Length Name="wallCabinetPos2_1">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0.15</AVal>
				<AVal Column="1" Row="2">-0.1</AVal>
				<AVal Column="2" Row="2">0.15</AVal>
				<AVal Column="1" Row="3">-1.2</AVal>
				<AVal Column="2" Row="3">0.15</AVal>
				<AVal Column="1" Row="4">-2.3</AVal>
				<AVal Column="2" Row="4">0.15</AVal>
				<AVal Column="1" Row="5">-3.4</AVal>
				<AVal Column="2" Row="5">0.15</AVal>
				<AVal Column="1" Row="6">-4.5</AVal>
				<AVal Column="2" Row="6">0.15</AVal>
				<AVal Column="1" Row="7">-5.6</AVal>
				<AVal Column="2" Row="7">0.15</AVal>
				<AVal Column="1" Row="8">-6.7</AVal>
				<AVal Column="2" Row="8">0.15</AVal>
			</ArrayValues>
		</Length>
		<Length Name="wallCabinetPos2_2">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="2">
				<AVal Column="1" Row="1">1</AVal>
				<AVal Column="2" Row="1">0.15</AVal>
				<AVal Column="1" Row="2">-1.1</AVal>
				<AVal Column="2" Row="2">0.15</AVal>
				<AVal Column="1" Row="3">-2.2</AVal>
				<AVal Column="2" Row="3">0.15</AVal>
				<AVal Column="1" Row="4">-3.3</AVal>
				<AVal Column="2" Row="4">0.15</AVal>
				<AVal Column="1" Row="5">-4.4</AVal>
				<AVal Column="2" Row="5">0.15</AVal>
				<AVal Column="1" Row="6">-5.5</AVal>
				<AVal Column="2" Row="6">0.15</AVal>
				<AVal Column="1" Row="7">-6.6</AVal>
				<AVal Column="2" Row="7">0.15</AVal>
				<AVal Column="1" Row="8">-7.7</AVal>
				<AVal Column="2" Row="8">0.15</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="nWallSegment">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="2">
				<AVal Column="1" Row="1">1</AVal>
				<AVal Column="2" Row="1">1</AVal>
				<AVal Column="1" Row="2">1</AVal>
				<AVal Column="2" Row="2">1</AVal>
				<AVal Column="1" Row="3">1</AVal>
				<AVal Column="2" Row="3">1</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0</AVal>
				<AVal Column="1" Row="8">0</AVal>
				<AVal Column="2" Row="8">0</AVal>
			</ArrayValues>
		</Integer>
		<Boolean Name="isWallContinuous">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">1</AVal>
				<AVal Row="2">1</AVal>
				<AVal Row="3">1</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
			</ArrayValues>
		</Boolean>
		<Integer Name="nWallContour">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">2</AVal>
				<AVal Row="2">2</AVal>
				<AVal Row="3">2</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="wallCoords1">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="4">
				<AVal Column="1" Row="1">-9.18485099361e-18</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">1</AVal>
				<AVal Column="4" Row="1">0</AVal>
				<AVal Column="1" Row="2">-9.18485099361e-18</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="3" Row="2">1</AVal>
				<AVal Column="4" Row="2">0</AVal>
				<AVal Column="1" Row="3">-9.18485099361e-18</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="3" Row="3">1</AVal>
				<AVal Column="4" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="3" Row="4">0</AVal>
				<AVal Column="4" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="3" Row="5">0</AVal>
				<AVal Column="4" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="3" Row="6">0</AVal>
				<AVal Column="4" Row="6">0</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0</AVal>
				<AVal Column="3" Row="7">0</AVal>
				<AVal Column="4" Row="7">0</AVal>
				<AVal Column="1" Row="8">0</AVal>
				<AVal Column="2" Row="8">0</AVal>
				<AVal Column="3" Row="8">0</AVal>
				<AVal Column="4" Row="8">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="wallCoords2">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="4">
				<AVal Column="1" Row="1">9.18485099361e-18</AVal>
				<AVal Column="2" Row="1">0.3</AVal>
				<AVal Column="3" Row="1">1</AVal>
				<AVal Column="4" Row="1">0.3</AVal>
				<AVal Column="1" Row="2">9.18485099361e-18</AVal>
				<AVal Column="2" Row="2">0.3</AVal>
				<AVal Column="3" Row="2">1</AVal>
				<AVal Column="4" Row="2">0.3</AVal>
				<AVal Column="1" Row="3">9.18485099361e-18</AVal>
				<AVal Column="2" Row="3">0.3</AVal>
				<AVal Column="3" Row="3">1</AVal>
				<AVal Column="4" Row="3">0.3</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="3" Row="4">0</AVal>
				<AVal Column="4" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="3" Row="5">0</AVal>
				<AVal Column="4" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="3" Row="6">0</AVal>
				<AVal Column="4" Row="6">0</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0</AVal>
				<AVal Column="3" Row="7">0</AVal>
				<AVal Column="4" Row="7">0</AVal>
				<AVal Column="1" Row="8">0</AVal>
				<AVal Column="2" Row="8">0</AVal>
				<AVal Column="3" Row="8">0</AVal>
				<AVal Column="4" Row="8">0</AVal>
			</ArrayValues>
		</Length>

		<!-- gs_DimensionSettings: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_DimensionSettings">
			<Description><![CDATA["Размеры"]]></Description>
		</Title>
		<Length Name="counterDepth">
			<Description><![CDATA["Глубина Столешницы"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.6</Value>
		</Length>
		<Length Name="counterHeigth">
			<Description><![CDATA["Высота Столешницы"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.9</Value>
		</Length>
		<Length Name="counterThickness">
			<Description><![CDATA["Толщина Столешницы"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.05</Value>
		</Length>
		<Length Name="wallCabinetHeigth">
			<Description><![CDATA["Высота Навесного Шкафа"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.75</Value>
		</Length>
		<Length Name="wallCabinetDepth">
			<Description><![CDATA["Глубина Навесного Шкафа"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.3</Value>
		</Length>
		<Length Name="wallCabinetClearence">
			<Description><![CDATA["Зазор Навесного Шкафа"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.6</Value>
		</Length>
		<Length Name="toeHeigth">
			<Description><![CDATA["Высота Цоколя"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.1</Value>
		</Length>

		<!-- gs_Accessory: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_Accessory">
			<Description><![CDATA["Аксессуары"]]></Description>
		</Title>
		<Boolean Name="bSink">
			<Description><![CDATA["Мойки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_BoldName/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Integer Name="nSink">
			<Description><![CDATA["Количество Моек"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="nPrevSink">
			<Description><![CDATA["Предыдущее Количество Моек"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="sinkType">
			<Description><![CDATA["Тип Мойки"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Одна Чаша с Крылом"]]></Value>
		</String>
		<Integer Name="iSinkType">
			<Description><![CDATA["Тип Мойки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<Integer Name="tempSinkType">
			<Description><![CDATA["Тип Мойки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<Boolean Name="bMirroredSink">
			<Description><![CDATA["Зеркально"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="sinkWidth">
			<Description><![CDATA["Ширина Моек"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0.8</AVal>
				<AVal Row="2">0.8</AVal>
				<AVal Row="3">0.8</AVal>
				<AVal Row="4">0.8</AVal>
				<AVal Row="5">0.8</AVal>
				<AVal Row="6">0.8</AVal>
				<AVal Row="7">0.8</AVal>
				<AVal Row="8">0.8</AVal>
			</ArrayValues>
		</Length>
		<Length Name="sinkWidth2">
			<Description><![CDATA["Ширина Моек"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0.8</AVal>
				<AVal Row="2">0.8</AVal>
				<AVal Row="3">0.8</AVal>
				<AVal Row="4">0.8</AVal>
				<AVal Row="5">0.8</AVal>
				<AVal Row="6">0.8</AVal>
				<AVal Row="7">0.8</AVal>
				<AVal Row="8">0.8</AVal>
			</ArrayValues>
		</Length>
		<Length Name="sinkWidthHalf">
			<Description><![CDATA["Ширина Моек"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0.4</Value>
		</Length>
		<Length Name="sinkPos">
			<Description><![CDATA["Расположение Мойки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="2">
				<AVal Column="1" Row="1">-3.58</AVal>
				<AVal Column="2" Row="1">0.3</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0</AVal>
				<AVal Column="1" Row="8">0</AVal>
				<AVal Column="2" Row="8">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="sinkPos2">
			<Description><![CDATA["Расположение Мойки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="2">
				<AVal Column="1" Row="1">-1.2</AVal>
				<AVal Column="2" Row="1">0.3</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0</AVal>
				<AVal Column="1" Row="8">0</AVal>
				<AVal Column="2" Row="8">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="nSegmentSink">
			<Description><![CDATA["Сегмент"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">1</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="sinkWidthPos">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="4">
				<AVal Column="1" Row="1">-3.98</AVal>
				<AVal Column="2" Row="1">0.3</AVal>
				<AVal Column="3" Row="1">-3.18</AVal>
				<AVal Column="4" Row="1">0.3</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="3" Row="2">0</AVal>
				<AVal Column="4" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="3" Row="3">0</AVal>
				<AVal Column="4" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="3" Row="4">0</AVal>
				<AVal Column="4" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="3" Row="5">0</AVal>
				<AVal Column="4" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="3" Row="6">0</AVal>
				<AVal Column="4" Row="6">0</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0</AVal>
				<AVal Column="3" Row="7">0</AVal>
				<AVal Column="4" Row="7">0</AVal>
				<AVal Column="1" Row="8">0</AVal>
				<AVal Column="2" Row="8">0</AVal>
				<AVal Column="3" Row="8">0</AVal>
				<AVal Column="4" Row="8">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="sinkDefaults">
			<Description><![CDATA["Значения по Умолчанию Ширины Моек"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="6" SecondDimension="0">
				<AVal Row="1">0.4</AVal>
				<AVal Row="2">0.55</AVal>
				<AVal Row="3">0.8</AVal>
				<AVal Row="4">0.8</AVal>
				<AVal Row="5">0.8</AVal>
				<AVal Row="6">0.8</AVal>
			</ArrayValues>
		</Length>
		<Boolean Name="bCooktop">
			<Description><![CDATA["Варочные Панели"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_BoldName/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Integer Name="nCooktops">
			<Description><![CDATA["Количество Варочных Панелей"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="nPrevCooktops">
			<Description><![CDATA["Предыдущее Количество Варочных Панелей"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="cooktopType">
			<Description><![CDATA["Тип Варочной Панели"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["4 конфорки"]]></Value>
		</String>
		<Integer Name="iCooktopType">
			<Description><![CDATA["Тип Варочной Панели"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Integer Name="tempCooktopType">
			<Description><![CDATA["Тип Варочной Панели"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Length Name="cooktopWidth">
			<Description><![CDATA["Ширина Варочных Панелей"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0.58</AVal>
				<AVal Row="2">0.58</AVal>
				<AVal Row="3">0.58</AVal>
				<AVal Row="4">0.58</AVal>
				<AVal Row="5">0.58</AVal>
				<AVal Row="6">0.58</AVal>
				<AVal Row="7">0.58</AVal>
				<AVal Row="8">0.58</AVal>
			</ArrayValues>
		</Length>
		<Length Name="cooktopWidth2">
			<Description><![CDATA["Ширина Варочных Панелей"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0.58</AVal>
				<AVal Row="2">0.58</AVal>
				<AVal Row="3">0.58</AVal>
				<AVal Row="4">0.58</AVal>
				<AVal Row="5">0.58</AVal>
				<AVal Row="6">0.58</AVal>
				<AVal Row="7">0.58</AVal>
				<AVal Row="8">0.58</AVal>
			</ArrayValues>
		</Length>
		<Length Name="cooktopPos">
			<Description><![CDATA["Расположение Варочной Панели"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="2">
				<AVal Column="1" Row="1">-1.09</AVal>
				<AVal Column="2" Row="1">0.3</AVal>
				<AVal Column="1" Row="2">3.08148791102e-33</AVal>
				<AVal Column="2" Row="2">0.3</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0</AVal>
				<AVal Column="1" Row="8">0</AVal>
				<AVal Column="2" Row="8">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="cooktopPos2">
			<Description><![CDATA["Расположение Варочной Панели"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="2">
				<AVal Column="1" Row="1">-1.95</AVal>
				<AVal Column="2" Row="1">0.3</AVal>
				<AVal Column="1" Row="2">3.08148791102e-33</AVal>
				<AVal Column="2" Row="2">0.3</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0</AVal>
				<AVal Column="1" Row="8">0</AVal>
				<AVal Column="2" Row="8">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="nSegmentCooktop">
			<Description><![CDATA["Сегмент"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="cooktopWidthPos">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="4">
				<AVal Column="1" Row="1">-1.38</AVal>
				<AVal Column="2" Row="1">0.3</AVal>
				<AVal Column="3" Row="1">-0.8</AVal>
				<AVal Column="4" Row="1">0.3</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="3" Row="2">0</AVal>
				<AVal Column="4" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="3" Row="3">0</AVal>
				<AVal Column="4" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="3" Row="4">0</AVal>
				<AVal Column="4" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="3" Row="5">0</AVal>
				<AVal Column="4" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="3" Row="6">0</AVal>
				<AVal Column="4" Row="6">0</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0</AVal>
				<AVal Column="3" Row="7">0</AVal>
				<AVal Column="4" Row="7">0</AVal>
				<AVal Column="1" Row="8">0</AVal>
				<AVal Column="2" Row="8">0</AVal>
				<AVal Column="3" Row="8">0</AVal>
				<AVal Column="4" Row="8">0</AVal>
			</ArrayValues>
		</Length>
		<Boolean Name="bHood">
			<Description><![CDATA["Вытяжка "]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<String Name="hoodType">
			<Description><![CDATA["Тип Вытяжки"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Настенная"]]></Value>
		</String>
		<Integer Name="iHoodType">
			<Description><![CDATA["Тип Вытяжки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Length Name="hoodWidth">
			<Description><![CDATA["Ширина Вытяжки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0.58</AVal>
				<AVal Row="2">0.58</AVal>
				<AVal Row="3">0.58</AVal>
				<AVal Row="4">0.58</AVal>
				<AVal Row="5">0.58</AVal>
				<AVal Row="6">0.58</AVal>
				<AVal Row="7">0.58</AVal>
				<AVal Row="8">0.58</AVal>
			</ArrayValues>
		</Length>
		<Length Name="hoodWidth2">
			<Description><![CDATA["Ширина Вытяжки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0.29</AVal>
				<AVal Row="2">0.29</AVal>
				<AVal Row="3">0.29</AVal>
				<AVal Row="4">0.29</AVal>
				<AVal Row="5">0.29</AVal>
				<AVal Row="6">0.29</AVal>
				<AVal Row="7">0.29</AVal>
				<AVal Row="8">0.29</AVal>
			</ArrayValues>
		</Length>
		<Length Name="hoodHeigth">
			<Description><![CDATA["Высота Верха Вытяжки"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2.7</Value>
		</Length>
		<Length Name="cooktopDefaults">
			<Description><![CDATA["Значения по Умолчанию Ширины Варочных Панелей"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="3" SecondDimension="0">
				<AVal Row="1">0.27</AVal>
				<AVal Row="2">0.58</AVal>
				<AVal Row="3">0.75</AVal>
			</ArrayValues>
		</Length>
		<Boolean Name="bRefrigerator">
			<Description><![CDATA["Холодильники"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_BoldName/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Integer Name="nRefrigerators">
			<Description><![CDATA["Количество Холодильников"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="nPrevRefri">
			<Description><![CDATA["Предыдущее Количество Холодильников"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="refrigeratorType">
			<Description><![CDATA["Тип Холодильника"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Морозильная Камера Сбоку"]]></Value>
		</String>
		<Integer Name="iRefrigeratorType">
			<Description><![CDATA["Тип Холодильника"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<Integer Name="tempRefrigeratorType">
			<Description><![CDATA["Тип Холодильника"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<Length Name="refrigeratorWidth">
			<Description><![CDATA["Ширина Холодильников"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0.9</AVal>
				<AVal Row="2">0.9</AVal>
				<AVal Row="3">0.9</AVal>
				<AVal Row="4">0.9</AVal>
				<AVal Row="5">0.9</AVal>
				<AVal Row="6">0.9</AVal>
				<AVal Row="7">0.9</AVal>
				<AVal Row="8">0.9</AVal>
			</ArrayValues>
		</Length>
		<Length Name="refrigeratorWidth2">
			<Description><![CDATA["Ширина Холодильников"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0.9</AVal>
				<AVal Row="2">0.9</AVal>
				<AVal Row="3">0.9</AVal>
				<AVal Row="4">0.9</AVal>
				<AVal Row="5">0.9</AVal>
				<AVal Row="6">0.9</AVal>
				<AVal Row="7">0.9</AVal>
				<AVal Row="8">0.9</AVal>
			</ArrayValues>
		</Length>
		<Length Name="refrigeratorHeigth">
			<Description><![CDATA["Высота Холодильников"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1.8</Value>
		</Length>
		<Length Name="refrigeratorDepth">
			<Description><![CDATA["Глубина Холодильников"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0.75</Value>
		</Length>
		<Boolean Name="bRefriWallCabinet">
			<Description><![CDATA["Навесной Шкаф"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="refrigeratorPos">
			<Description><![CDATA["Расположение Холодильника"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="2">
				<AVal Column="1" Row="1">-2.63</AVal>
				<AVal Column="2" Row="1">0.3</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0</AVal>
				<AVal Column="1" Row="8">3.08148791102e-33</AVal>
				<AVal Column="2" Row="8">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="refrigeratorPos2">
			<Description><![CDATA["Расположение Холодильника"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="2">
				<AVal Column="1" Row="1">-2.75</AVal>
				<AVal Column="2" Row="1">0.3</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0</AVal>
				<AVal Column="1" Row="8">3.08148791102e-33</AVal>
				<AVal Column="2" Row="8">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="nSegmentRefri">
			<Description><![CDATA["Сегмент"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="refrigeratorWidthPos">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="4">
				<AVal Column="1" Row="1">-3.08</AVal>
				<AVal Column="2" Row="1">0.3</AVal>
				<AVal Column="3" Row="1">-2.18</AVal>
				<AVal Column="4" Row="1">0.3</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="3" Row="2">0</AVal>
				<AVal Column="4" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="3" Row="3">0</AVal>
				<AVal Column="4" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="3" Row="4">0</AVal>
				<AVal Column="4" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="3" Row="5">0</AVal>
				<AVal Column="4" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="3" Row="6">0</AVal>
				<AVal Column="4" Row="6">0</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0</AVal>
				<AVal Column="3" Row="7">0</AVal>
				<AVal Column="4" Row="7">0</AVal>
				<AVal Column="1" Row="8">3.08148791102e-33</AVal>
				<AVal Column="2" Row="8">0</AVal>
				<AVal Column="3" Row="8">3.08148791102e-33</AVal>
				<AVal Column="4" Row="8">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="refriDefaults">
			<Description><![CDATA["Значения по Умолчанию Ширины Холодильников"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="5" SecondDimension="0">
				<AVal Row="1">0.6</AVal>
				<AVal Row="2">0.6</AVal>
				<AVal Row="3">0.9</AVal>
				<AVal Row="4">0.6</AVal>
				<AVal Row="5">0.6</AVal>
			</ArrayValues>
		</Length>
		<Boolean Name="bDishwasher">
			<Description><![CDATA["Посудомоечные Машины"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_BoldName/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Integer Name="nDishwasher">
			<Description><![CDATA["Количество Посудомоечных Машин"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="nPrevDishwasher">
			<Description><![CDATA["Предыдущее Количество Посудомоечных Машин"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Length Name="dishwasherWidth">
			<Description><![CDATA["Ширина Посудомоечных Машин"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0.6</AVal>
				<AVal Row="2">0.6</AVal>
				<AVal Row="3">0.6</AVal>
				<AVal Row="4">0.6</AVal>
				<AVal Row="5">0.6</AVal>
				<AVal Row="6">0.6</AVal>
				<AVal Row="7">0.6</AVal>
				<AVal Row="8">0.6</AVal>
			</ArrayValues>
		</Length>
		<Length Name="dishwasherWidth2">
			<Description><![CDATA["Ширина Посудомоечных Машин"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0.6</AVal>
				<AVal Row="2">0.6</AVal>
				<AVal Row="3">0.6</AVal>
				<AVal Row="4">0.6</AVal>
				<AVal Row="5">0.6</AVal>
				<AVal Row="6">0.6</AVal>
				<AVal Row="7">0.6</AVal>
				<AVal Row="8">0.6</AVal>
			</ArrayValues>
		</Length>
		<Length Name="dishwasherPos">
			<Description><![CDATA["Расположение Посудомоечной Машины"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="2">
				<AVal Column="1" Row="1">-4.38</AVal>
				<AVal Column="2" Row="1">0.3</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0</AVal>
				<AVal Column="1" Row="8">3.08148791102e-33</AVal>
				<AVal Column="2" Row="8">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="dishwasherPos2">
			<Description><![CDATA["Расположение Посудомоечной Машины"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="2">
				<AVal Column="1" Row="1">-3.6</AVal>
				<AVal Column="2" Row="1">0.3</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0</AVal>
				<AVal Column="1" Row="8">3.08148791102e-33</AVal>
				<AVal Column="2" Row="8">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="nSegmentDishwasher">
			<Description><![CDATA["Сегмент"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="dishwasherWidthPos">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="4">
				<AVal Column="1" Row="1">-4.68</AVal>
				<AVal Column="2" Row="1">0.3</AVal>
				<AVal Column="3" Row="1">-4.08</AVal>
				<AVal Column="4" Row="1">0.3</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="3" Row="2">0</AVal>
				<AVal Column="4" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="3" Row="3">0</AVal>
				<AVal Column="4" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="3" Row="4">0</AVal>
				<AVal Column="4" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="3" Row="5">0</AVal>
				<AVal Column="4" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="3" Row="6">0</AVal>
				<AVal Column="4" Row="6">0</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0</AVal>
				<AVal Column="3" Row="7">0</AVal>
				<AVal Column="4" Row="7">0</AVal>
				<AVal Column="1" Row="8">3.08148791102e-33</AVal>
				<AVal Column="2" Row="8">0</AVal>
				<AVal Column="3" Row="8">3.08148791102e-33</AVal>
				<AVal Column="4" Row="8">0</AVal>
			</ArrayValues>
		</Length>
		<Boolean Name="bOven">
			<Description><![CDATA["Духовые Шкафы"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_BoldName/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Integer Name="nOvens">
			<Description><![CDATA["Количество Духовых Шкафов"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="nPrevOvens">
			<Description><![CDATA["Предыдущее Количество Духовых Шкафов"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Length Name="ovenVerticalPos">
			<Description><![CDATA["Расположение Духового Шкафа по Вертикали"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0.6</AVal>
				<AVal Row="2">0.6</AVal>
				<AVal Row="3">0.6</AVal>
				<AVal Row="4">0.6</AVal>
				<AVal Row="5">0.6</AVal>
				<AVal Row="6">0.6</AVal>
				<AVal Row="7">0.6</AVal>
				<AVal Row="8">0.6</AVal>
			</ArrayValues>
		</Length>
		<Length Name="ovenWidth">
			<Description><![CDATA["Ширина Духовых Шкафов"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0.6</AVal>
				<AVal Row="2">0.6</AVal>
				<AVal Row="3">0.6</AVal>
				<AVal Row="4">0.6</AVal>
				<AVal Row="5">0.6</AVal>
				<AVal Row="6">0.6</AVal>
				<AVal Row="7">0.6</AVal>
				<AVal Row="8">0.6</AVal>
			</ArrayValues>
		</Length>
		<Length Name="ovenWidth2">
			<Description><![CDATA["Ширина Духовых Шкафов"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0.6</AVal>
				<AVal Row="2">0.6</AVal>
				<AVal Row="3">0.6</AVal>
				<AVal Row="4">0.6</AVal>
				<AVal Row="5">0.6</AVal>
				<AVal Row="6">0.6</AVal>
				<AVal Row="7">0.6</AVal>
				<AVal Row="8">0.6</AVal>
			</ArrayValues>
		</Length>
		<Length Name="ovenPos">
			<Description><![CDATA["Расположение Духового Шкафа"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="2">
				<AVal Column="1" Row="1">-1.78</AVal>
				<AVal Column="2" Row="1">0.3</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0</AVal>
				<AVal Column="1" Row="8">0</AVal>
				<AVal Column="2" Row="8">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="ovenPos2">
			<Description><![CDATA["Расположение Духового Шкафа"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="2">
				<AVal Column="1" Row="1">-4.3</AVal>
				<AVal Column="2" Row="1">0.3</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0</AVal>
				<AVal Column="1" Row="8">0</AVal>
				<AVal Column="2" Row="8">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="nSegmentOven">
			<Description><![CDATA["Сегмент"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="ovenWidthPos">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="4">
				<AVal Column="1" Row="1">-2.08</AVal>
				<AVal Column="2" Row="1">0.3</AVal>
				<AVal Column="3" Row="1">-1.48</AVal>
				<AVal Column="4" Row="1">0.3</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="3" Row="2">0</AVal>
				<AVal Column="4" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="3" Row="3">0</AVal>
				<AVal Column="4" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="3" Row="4">0</AVal>
				<AVal Column="4" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="3" Row="5">0</AVal>
				<AVal Column="4" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="3" Row="6">0</AVal>
				<AVal Column="4" Row="6">0</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0</AVal>
				<AVal Column="3" Row="7">0</AVal>
				<AVal Column="4" Row="7">0</AVal>
				<AVal Column="1" Row="8">0</AVal>
				<AVal Column="2" Row="8">0</AVal>
				<AVal Column="3" Row="8">0</AVal>
				<AVal Column="4" Row="8">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="ovenHeigth">
			<Description><![CDATA["Высота Духового Шкафа"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0.1</AVal>
				<AVal Row="2">0.1</AVal>
				<AVal Row="3">0.1</AVal>
				<AVal Row="4">0.1</AVal>
				<AVal Row="5">0.1</AVal>
				<AVal Row="6">0.1</AVal>
				<AVal Row="7">0.1</AVal>
				<AVal Row="8">0.1</AVal>
			</ArrayValues>
		</Length>
		<Boolean Name="bWasher">
			<Description><![CDATA["Стиральные Машины"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_BoldName/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Integer Name="nWasher">
			<Description><![CDATA["Количество Стиральных Машин"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="nPrevWasher">
			<Description><![CDATA["Предыдущее Количество Стиральных Машин"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Length Name="washerWidth">
			<Description><![CDATA["Ширина Стиральных Машин"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0.6</AVal>
				<AVal Row="2">0.6</AVal>
				<AVal Row="3">0.6</AVal>
				<AVal Row="4">0.6</AVal>
				<AVal Row="5">0.6</AVal>
				<AVal Row="6">0.6</AVal>
				<AVal Row="7">0.6</AVal>
				<AVal Row="8">0.6</AVal>
			</ArrayValues>
		</Length>
		<Length Name="washerWidth2">
			<Description><![CDATA["Ширина Стиральных Машин"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1">0.6</AVal>
				<AVal Row="2">0.6</AVal>
				<AVal Row="3">0.6</AVal>
				<AVal Row="4">0.6</AVal>
				<AVal Row="5">0.6</AVal>
				<AVal Row="6">0.6</AVal>
				<AVal Row="7">0.6</AVal>
				<AVal Row="8">0.6</AVal>
			</ArrayValues>
		</Length>
		<Length Name="washerPos">
			<Description><![CDATA["Расположение Стиральной Машины"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="2">
				<AVal Column="1" Row="1">-5.08</AVal>
				<AVal Column="2" Row="1">0.3</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0</AVal>
				<AVal Column="1" Row="8">3.08148791102e-33</AVal>
				<AVal Column="2" Row="8">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="washerPos2">
			<Description><![CDATA["Расположение Стиральной Машины"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="2">
				<AVal Column="1" Row="1">-5</AVal>
				<AVal Column="2" Row="1">0.3</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0</AVal>
				<AVal Column="1" Row="8">3.08148791102e-33</AVal>
				<AVal Column="2" Row="8">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="nSegmentWasher">
			<Description><![CDATA["Сегмент"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="7" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="washerWidthPos">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="4">
				<AVal Column="1" Row="1">-5.38</AVal>
				<AVal Column="2" Row="1">0.3</AVal>
				<AVal Column="3" Row="1">-4.78</AVal>
				<AVal Column="4" Row="1">0.3</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="3" Row="2">0</AVal>
				<AVal Column="4" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="3" Row="3">0</AVal>
				<AVal Column="4" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="3" Row="4">0</AVal>
				<AVal Column="4" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="3" Row="5">0</AVal>
				<AVal Column="4" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
				<AVal Column="3" Row="6">0</AVal>
				<AVal Column="4" Row="6">0</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0</AVal>
				<AVal Column="3" Row="7">0</AVal>
				<AVal Column="4" Row="7">0</AVal>
				<AVal Column="1" Row="8">3.08148791102e-33</AVal>
				<AVal Column="2" Row="8">0</AVal>
				<AVal Column="3" Row="8">3.08148791102e-33</AVal>
				<AVal Column="4" Row="8">0</AVal>
			</ArrayValues>
		</Length>

		<!-- gs_2D_representation: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_2D_representation">
			<Description><![CDATA["2D-отображение"]]></Description>
			<Fix/>
		</Title>
		<PenColor Name="gs_cont_pen">
			<Description><![CDATA["Перо Контура"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</PenColor>
		<FillPattern Name="gs_fill_type">
			<Description><![CDATA["Тип Штриховки"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>65</Value>
		</FillPattern>
		<PenColor Name="gs_fill_pen">
			<Description><![CDATA["Перо Штриховки"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</PenColor>
		<PenColor Name="gs_back_pen">
			<Description><![CDATA["Перо Фона Штриховки"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</PenColor>
		<Boolean Name="bShowOverhead">
			<Description><![CDATA["Показ Проекции"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<LineType Name="overheadLine">
			<Description><![CDATA["Тип Линии Проекции"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</LineType>
		<String Name="refriSymbType">
			<Description><![CDATA["Отображение Холодильника"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Символический"]]></Value>
		</String>
		<Integer Name="iRefriSymbType">
			<Description><![CDATA["Отображение Холодильника"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="refriText">
			<Description><![CDATA["Текст Холодильника"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Х"]]></Value>
		</String>
		<String Name="ovenSymbType">
			<Description><![CDATA["Отображение Духового Шкафа"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Символический"]]></Value>
		</String>
		<Integer Name="iOvenSymbType">
			<Description><![CDATA["Отображение Духового Шкафа"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="ovenText">
			<Description><![CDATA["Текст Духового Шкафа"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Д"]]></Value>
		</String>
		<String Name="dishwasherSymbType">
			<Description><![CDATA["Отображение Посудомоечной Машины"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Символический"]]></Value>
		</String>
		<Integer Name="iDishwasherSymbType">
			<Description><![CDATA["Отображение Посудомоечной Машины"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="dishwasherText">
			<Description><![CDATA["Текст Посудомоечной Машины"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["ПМ"]]></Value>
		</String>
		<String Name="washerSymbType">
			<Description><![CDATA["Отображение Стиральной Машины"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Символический"]]></Value>
		</String>
		<Integer Name="iWasherSymbType">
			<Description><![CDATA["Отображение Стиральной Машины"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="washerText">
			<Description><![CDATA["Текст Стиральной Машины"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Ст.М."]]></Value>
		</String>
		<PenColor Name="penText">
			<Description><![CDATA["Перо Текста"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>86</Value>
		</PenColor>
		<Integer Name="iTextPen">
			<Description><![CDATA["Перо Текста"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>86</Value>
		</Integer>
		<String Name="fontType">
			<Description><![CDATA["Тип Шрифта"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Arial"]]></Value>
		</String>
		<Length Name="fontSize">
			<Description><![CDATA["Размер Шрифта"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.12</Value>
		</Length>
		<Boolean Name="gs_text_style_bold">
			<Description><![CDATA["Жирный Шрифт"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_text_style_italic">
			<Description><![CDATA["Курсивный Шрифт"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_text_style_underline">
			<Description><![CDATA["Подчеркнутый Шрифт"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_text_style_strike">
			<Description><![CDATA["Зачеркнутый Шрифт"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<String Name="typeTextRotation">
			<Description><![CDATA["Ориентация Текста в Символе"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Читаемый"]]></Value>
		</String>
		<Integer Name="typeTextRotation_m">
			<Description><![CDATA["Ориентация Текста в Символе"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Angle Name="gs_readable_angle">
			<Description><![CDATA["Читаемый Угол"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>90</Value>
		</Angle>

		<!-- gs_min_space: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_min_space">
			<Description><![CDATA["Минимальное Пространство"]]></Description>
		</Title>
		<Length Name="MSFront">
			<Description><![CDATA["Минимальное Пространство Спереди"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.9</Value>
		</Length>

		<!-- gs_3D_representation: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_3D_representation">
			<Description><![CDATA["3D-отображение"]]></Description>
		</Title>
		<Boolean Name="gs_shadow">
			<Description><![CDATA["Отбрасывание Теней"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>

		<!-- gs_material: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_material">
			<Description><![CDATA["Покрытия"]]></Description>
		</Title>
		<Material Name="gs_cabinet_mat">
			<Description><![CDATA["Шкаф"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>14</Value>
		</Material>
		<Material Name="count_mat">
			<Description><![CDATA["Столешница"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>8</Value>
		</Material>
		<Material Name="gs_base_mat">
			<Description><![CDATA["Основание"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>49</Value>
		</Material>
		<Material Name="wallcab_mat">
			<Description><![CDATA["Навесной Шкаф"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>14</Value>
		</Material>
		<Material Name="refrigerator_mat">
			<Description><![CDATA["Холодильник"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>11</Value>
		</Material>
		<Material Name="sink_mat">
			<Description><![CDATA["Мойка"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>11</Value>
		</Material>
		<Material Name="dishwasher_mat">
			<Description><![CDATA["Посудомоечная Машина"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>18</Value>
		</Material>
		<Material Name="washer_mat">
			<Description><![CDATA["Стиральная Машина"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>18</Value>
		</Material>
		<Material Name="oven_mat">
			<Description><![CDATA["Духовой Шкаф"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>11</Value>
		</Material>
		<Material Name="glass_mat">
			<Description><![CDATA["Стекло"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>29</Value>
		</Material>
		<Material Name="cooktop_mat">
			<Description><![CDATA["Варочная Панель"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>11</Value>
		</Material>
		<Material Name="hotplate_mat">
			<Description><![CDATA["Конфорки"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>40</Value>
		</Material>
		<Material Name="hood_mat">
			<Description><![CDATA["Вытяжка "]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>11</Value>
		</Material>

		<!-- gs_list: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_list">
			<Description><![CDATA["Параметры Спецификаций"]]></Description>
			<Fix/>
		</Title>
		<RealNum Name="gs_list_cost">
			<Description><![CDATA["Цена"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</RealNum>
		<String Name="gs_list_manufacturer">
			<Description><![CDATA["Производитель"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_note">
			<Description><![CDATA["Примечания"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_location">
			<Description><![CDATA["Расположение"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_accessories">
			<Description><![CDATA["Аксессуары"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="FM_Type">
			<Description><![CDATA["Тип Группы"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Мебель"]]></Value>
		</String>
		<Integer Name="iFMType">
			<Description><![CDATA["Тип Группы"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>16</Value>
		</Integer>
		<String Name="FM_InventoryNumber">
			<Description><![CDATA["Инвентарный Номер"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="FM_SerialNumber">
			<Description><![CDATA["Серийный Номер"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="FM_ProductionYear">
			<Description><![CDATA["Год Производства"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<RealNum Name="FM_ObjectWeight">
			<Description><![CDATA["Вес Изделия"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</RealNum>
		<String Name="FM_ObjectWeightUnit">
			<Description><![CDATA["Единица Веса"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["кг"]]></Value>
		</String>
		<String Name="gs_list_custom1">
			<Description><![CDATA["Пользовательское Значение 1"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_custom2">
			<Description><![CDATA["Пользовательское Значение 2"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_custom3">
			<Description><![CDATA["Пользовательское Значение 3"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_custom4">
			<Description><![CDATA["Пользовательское Значение 4"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_custom5">
			<Description><![CDATA["Пользовательское Значение 5"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="gs_ui_current_page">
			<Description><![CDATA["Текущая Страница"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
	</Parameters>
</ParamSection>

<Picture MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="0" length_in_bytes="8636" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000800000
	008008020000004C5CF69C000000097048597300002E2300002E230178A53F76
	000020004944415478DAED7D5BAF24D775DE5A6BEFAAEAEB99CB19CD8DA4E6CA
	A88DD8A388C180A00519016208062CE44182F3907FE0BFE137FF0E03CE43FC64
	044E1040B060414EE4911967124A4DF126898478318F66CEE9AEEABAECBD561E
	56EDEADDD5DD67468265CA526F1E36FB54579FAA5A976FDD375144E0B03EBB45
	07121C187060C0611D187060C0611D187060C0611D187060C0611D187060C061
	1D187060C067B244E4372D3978D08003033635E0C08003030E107460C061FD86
	3200110F0CF88C19F09BC6033C14E50F1A7060C0611D187060C0611D1810A2E1
	03033ED3E5DC81019FD1626E7F9C03E6DF1006D85FA17B691A4014E7500488DA
	1F44F8B50ECD7E6518509650559024ECBD615E3300A0E541FCEB8101FFC476D7
	399FE7559E0B409DE7D618638C4D124A12632D1231115B2B44A83C205A672C10
	5B8D4184904D8A5FFF991C8718339921BA3DBDE17DA2F32BC1800FDE78E3F15F
	FC05D475F9C107FE934FCC7068B3CC8EC7C65A9B65264DC95ACA324812932426
	4D8D3136CB28494C9AA231499AA2B536CB6C9A1A6B4D9A2222250919639284AC
	456324A8145ADBBE1A83C690310080FA1162CB4E000CF4DA78630C3063CF4F53
	EA33B7FE9B082082CA44C7834E89F5D5985F2D067CFCC107DFFBE6378F118D08
	01409E03803E652B3344024000D8FD3053F8548F5070A2C47B70CE021800331C
	9A2CA334B583010D06364DCD7048D6DAE110ADC52C33C3211AA36C368301590B
	88C9608049920C0664AD4D534A124C12638C209231680C12A13164AD49533266
	6DAE68EDD4B4F7464481FACAE656578212DB67F8E3BF7C2D1611249A300F8643
	AEAA8EC4ED5D4624EE6E455466A35F858801805988C47BA9EB7A3E8F05550247
	0180A3BF460F1E982C03226196AAC2BA86F85A690A119B338074389C8EC76630
	A034A5D1C84EA734188832C95A4C12CC324C120ACCC334C53435699A6499190C
	10D1669949123B1E67972E0D8E8FFB0C10EF81DB25CCDE7B3318A469FA4BF63F
	D903F8A6D1E75462118030B7E40EC72912AE0D15511000C0A681A2C0F97CCDAA
	1EE766B3F65B698A00602D592B44EC1C5BABE7F326E7DA378F1F0300CF66E5E9
	692BE369DA0B1AD1DA35FF8CD9B83411024C1E3C187CF18BE90B2FE0789C3D7D
	FA6F2E5E6C19502E16D5C9499DE7BEAAAA3CAF178BE2673F6B9E3E2D4F4EA82C
	C7C7C7E9850B36CB92C924190E93D128190EF5C766190D069824301E4392FC02
	D447618E24940395F58D6C128203273062036ED2AB17414884090280F3F90623
	67B335223B078F1F4B3833FE6EF7F5663EE7F88AB3597B9AEA8A73EB6F39B7BE
	A8B5FCE8D1F0EB5FBFF6C77F9C4E26C02CCCEC7D5DD716008AB3B3EFFECDDF24
	DE57A7A7EEECAC3E39C1E512EB1ACA128B02BD7F3A9F4B519073BEAA1CB3303B
	66EFBD778E01A4AE7380DFFAA33FFA777FF227BF90FC47468DB9253D01007124
	FBB8498B1849247C7143D2377980310F361548014D983BE6E126E93B04EB4903
	024050B59DDFEACE94D94C820DF7AB95D660ACB5CC6C01E0C9D3A73FABEB0B97
	2ED9CB97536BA7448A89EA15B49191F764CC277FF997A77FFAA7F4F021780F00
	602D02D070987DF7BBAA7DBF88032702221C48D38200B7F66C676228266227CE
	B25FF0B10726DB04EA4E9ECD24188F0E8E3A50924DDCDB77C5ED5F55ED04C018
	43C630B3A8B3846801A0691A836811D17B61F6EA8D01B008762E1422A4A93746
	0060B180F9BCBB3FF3E08100B8D5EA1734C1A297593F73FBAA424D249B822F5B
	E02ECC3168C82E6EC5C0B2C3846CC9386C1A03D9C3B9735C1409A91E510D98CF
	693402A2AE04A9F557DB062C88CC6C42E8DF0F64F44B22C02C5B5438FF3E9E19
	BF8888706B06B67559F6A7AB6272F0163571BF98CB2657CE396D271B600BC7F6
	DD1B6EDD98D236963ADB4510AD52EC4BDA294B825FB803F27EDE34B25E579B41
	11650F3910408011FA7AB03E87798DEF5138BA534265FB88FA427B00440204ED
	D42D3897DFBDE30280C610B645789571242289E2E64E3BD627E9A2BE146E2875
	5D0340F37341907A8DDE43E8C695E887FB67424FED640F8EEFFC48B6ACF7C609
	752DFBA9DFB95E3BAD6B7CB99D57EF9BFAC140231BA37E976A80FA007A08B7C1
	A7CDB508460777AAB03C7F1E3F185E106150F8D9A1B9B4F5007DDE07D9DF4917
	DC8F481BD70AA11647B4C62D44D2577F2EDEE21E9D90C8DE196318A07D641124
	B2DBB2DF111A237D69FF10A26C818FFCBCB8EF7D4B7D6957F76763377F83076A
	6655114374069B2E103E874F429B97500D802CEBC9F23E7BC0FBE9DE63792C3A
	FA2C1E80B20C1085C373038088651124EA2C03C5217E0CEB22DBCE5C17CE1000
	AB63FADCE22FCCADEBCDAC7F9A23CCC5CDA0AC7D98ADC05800FC96B09F83F8BC
	8D4869DA5E9108AC95BADEE9F3E86D34914958273376094D2F0E4700D1880F11
	110D91047A5A15F91EF2B4221FF3237C447B8C5B7376064DF38C6038640D857D
	E7FE3073CF7EEF0D97A2D71E1B20CA5BF4288EFBF181F747D13D46960F1F9E8D
	C73933786F980D33360D00188D7EEB1AE7731544D2839BA9430270F379FDD5AF
	122287EC0B12817AFF1DB9F5838EE81D57246468653B72E954A1CBC73E8BFA10
	90878515870001F586ACEDB23ADBCE0C6F79A8B8C98F7D21580F10767AAEFB9C
	7D7DBA9FDCBE7D72749478DF3EB2CAAFF7C44C22C04CBFF33BDC3429113A07CC
	E81C348D552B2582DE27C7C7B7BFF005055E4234C6A8DDB50040C10833B3B5B6
	670962EAAF8D4177EBB319A6A9C4199567210F88888046835EF190794594D635
	0224813414C991A6A37B7AB091A508A988F3C3949DD2D3164C36ABD03DF42711
	F0DE78EFF588CA689A0262E77BD475EDD2948818B1B337248200ABBAFEB75FFA
	D2FDAF7C05364D2CAA0628E963A26F5B63D8FC143A5CD3E74C53AE6B710E77E6
	4D55F05B15110E811733B3F70230BD7CFCCA37BE41CCC5A79F2E3FFED888F8A2
	90A280BA96D5CA453A415B4166C7AA96D0CEC17C8EB319EE49C6B53ECF7C8E7B
	82E17D71802A0D07EA130078AFB7654222D9289FC2F90611880C80614EAD65EF
	3BBCF1DE5B6B11D1AA6F442144EED33D360C9BE501A53EA4A90A9A5F2E7DD3D8
	739DCE003D8AFB8A3EC0EC2F5FBFBE7AEDB5B22AFD932799F3D3F11898010405
	C07B6016EFB969C07B5F55E21A5F56BE2C7D517091FB552955C579EEF39C572B
	5F556E36F3518E0CB6F4A05F63E8CA9CC6D068E46733EC52087A4E94DC060062
	66220E7457F79410DB3C4217CF8A68ED8C83034A44CCDCBAF581B6B68D6FB117
	2DF755010144F147E9BE9598847D81714C7D66CFACD6928337E63D1B63C6A391
	880CD24C2C67C301201943484623F07E36070040DA8C95E7D6A1F21E84D97961
	2F8D63E7B8697C5D7355B9A270E5CA2F962ECF7D59F26AE5CFCE7C9EFBA2E03C
	7721F3E7BD67E70440E6F3F8713C80DB54C1F39A79E26AF066004B44B1BFA342
	6F91A867755515627F14BBA268A813F515DC5A4DA0EE247DC78096E4209E9945
	3C7B61FD186C92B47689C8262921EA0D84581C40DA1C95045BD41E4C101010A9
	6752BBC026CE65898030B377EC3C30B373DE3961E6A6E1BAF64DE3AAD2976593
	17AE289A7CD99C2DB82CB92C6D964110678A6A15B11E30B3788F7B6CA1310611
	79ABDFC9AAAFD9D38B6D3B8CBB9034865757145E83E1AE36AD6F347F27EBC57E
	1D81B16830D0E669F536AC3180D8CA8BF2A0AB4DE21A08B12DA2AF951EE3127A
	2F8A1110103D5524054096F57D7551618B8DC147D6B2896F9A8FFEEEEF3E7CF3
	CDC170C8DEF74A466D4F93BAEC6D0EBDBD21615639F2DEEB477160AB12661151
	5DA02E10EB59635C0BDEDADE6FFB18D2344E19A01753AF3C827DE99E0DD6DAC0
	C2D286D8A8DD2860489356D8F160ADB781E86DBD1BB1A5B9F221D6FEF61411EE
	294414840A02B2B45188749818C4445D35CF9C649949D338D2E4AE5ED1A1CD39
	2EB83E0B6A99D278EFBBD84B44AC3E2711E9077DD8E9EC416C8AD3B42BC56959
	55D662269DC3230021D30C124916B34600D2866012CC0C111943001BD4D7AE02
	054DEC381073A443C8961D9B497F02E9C7F56DC423022208D4AA2BB301E0B542
	58151C23C2DE7310EA0E7FF49EC47B2DF64AF088C47B248228B5CC2226AC98FD
	FA6A3B83A06FBA404C89D2A94CAC3B3BCB1D4A62D5650CCFD9491587176E451F
	3A556863621022246348840C01A0BA06666D093AA18FDF03761601B76C557047
	C2AD0610020169E3A94023064211C0F008DA12C08804E011BCF76BD821626662
	D64E1361D618A8CD110438C1CD4CFE7676671D07B489A04DA5D95685F513D575
	6C0F94074D55F9A601110DB295192D63005ACA4387FB9B00258C6D3E06519090
	80D020B5928180481819E48D7F9000D44F4345B3F88141F4F630FC57DBD60844
	D4AA2B4D0C1A89AC810161166CA33F11317A2B4844DE03330524920EF7B75027
	AE79AB79EB9562DAC857EFD818F39C1515B5FBB14F48CEB59C88DC4D887FED54
	2058B72E0BC4025D3D0000081068EDAF9121245298A78EFA88CAA9F09C9A5027
	10697DA1D84313206CA5BE4DBC929170FB9A88C5C8E3100124146644880E719C
	6E8AFD4A2D5EF732983D9C501F5FC32EEF7DCFE7B46BABB2C77EC46E5D172BD2
	7CDE4600B3D97234724747FF68CC274F9F5E7EF10566464290B5832191FCAB0D
	58972F84436CC02A9322A2B406A2F6D949E9DD6641823D6BCD0248CBAF902BD9
	882235F069DFA83C3383228D320030C085308B01F01D882B4D50FBF098B4B5CD
	FB560A15A835CE8F5CCFCE31DDAE62757ADFF999AD0600A231463FEEF9A06B7E
	AAB030D37C5ECD66D52BAF1493C972342AA7D35596AD8C41E6555DB738EFB133
	0C2DE159621F835BBF48BC67E7D939C7CCDE33339331AD6D8FEB042CAD2DE8EC
	0E76C179D796BB962CE918D4DA33206344E5581D781404DAB08720846DD65DEF
	D9E3DACBF4EC3BB75283E14E1B30F405EF5382D60813596BF5493B4E0406C4D5
	AE2D0D5A67FF45DCCD9B3FFCDAD75683C112D10D06D618039024892DCB2ACF8D
	210D6E8C31BC6103D6CEA86706111FD2D0DE7BEFBDF35E4DB1F38E54C4444CF0
	85A075EBDBE857855A9D2375144020E035F4B326EB06DB76261A910405DB9020
	4E38AA2B0B4884C220480C60104490B46668C898B61FC718EF7D9BC114C13884
	0AEF35F3D33676840BC44E8D2E1B47C95BCE2BC6ED9B0880D7AE15B76EADCECE
	ACC8A04B8479CF4475592ECE169D4C6D789F6BC40F090961EF3C8BB0B073AE5C
	AD4E4F4F3F3D3999BF393FF9F464329D0E0783E9743A9E4CC6C3619AA6599625
	699AA6699A24699ADA24B1868CB586C21268E336551ADCEC5DC0166E14F44207
	B4B631AFB38D9135C275E480189C6D4B219F232256758BD91803C6A8DCB4563A
	0E515563A26C5B27EEDE7B666E236166AEEA7AB22721DA1D2444AA6B284BB0D6
	69CC056092C4EB9544D87B11F66E6DB558B4C5B433BA2022DEFBBAAECF168B4F
	4F4EDE7FFFFD1FBEFDC31FBCF183FFFA577FB5CFF2BFF6EA2B6487E3F1F8B77F
	EBE5973E7FEBC6CD6B17A7478044483649D22CB3C602629A24484464ACB5499A
	10B6BE87724A3BC69929760B36DCA5109149542E6DC5568488C818F15EDD79B5
	A826499899107D5435F1AABEC67430458849C8F343B431D81A8240C404A3B113
	8554A2D9B962B9246B2FDDBCD978BF3839B1DE27C634792E75ADD8E29C5F8765
	CC3E88BEF7BEAAEB3CCF9F3C7DF2E1871FCEDFFCE15B6FCFFFFC3FFF97EE12AF
	BC32339002D47121900D2C16734BC937BEFEB55B2FBD20C282B0CAF38FF3B3C1
	204BD3419224F9029C77C3E168906565557BCF88026806834136182436F9E8E3
	4F17CBE5783C499324CB32638CB5361B6469921A6B298AF5BA82471BAE330B80
	73CE33A759A6F94EEF7D1BC45ADB150D158E8CB582082246F3D8A1E391829596
	8D364C6E214898933425A27DBD6B143C2D9B24D3E9D4D575626CB958B83C2FEA
	FAE9A79F589B4E895CD338D7344DD3B190999BA65916F9C9C9CF3EFCF0C337DF
	7AEB9D77DF7DFCFAFF7AFD719BE09D3D8069F6003C78785C14F3AE98506F745D
	C285AFD81FBCFDF65B3FFE117BC9B26C3A1A8C87C32B978F8FA636CF8B6C3018
	0F870002C2D3F120B1D6D8A4AACAB3B3E58FDF7BFBFB6FBEF5E8EFFFE15BDFFA
	B6FEA9AF7CF9B5E1703C994CA6D3E960381C8F86E3C9643C1E8F86A3F164321A
	8DD2549964ADB589B5699A7AF6365851B5409DDBADCCB0695AD73587664E13DC
	1602F000DE7B85CD2E148861BFF5826284DA591CEE527A64EDE2C9931FFFC3DF
	172C5EA137B50300C3B05A15CA02E77D59554F9E3EF9E4E34F7EF8EE3B67EFBE
	FBEEFF7BE3BDA63A76BC204A8617FEE0CBAF95B5B344ABA6597900E75C3D4B61
	FE3822FABF07B80990006400EEDBDFF9C76F7FE70CC00178801AE014A03B77F6
	F0959B972E8D26E3A3D1703A3D9A8E4693E9A05894AFFF9FFFFBC1073F058014
	E0D5870F01AAD5E2F1B7BFF33F9F19EB3C7CF8703A1E8F26A3F1783A1C0EA6E3
	C96838CC06030030DEEB209B92D81AA31E2A75E94222A3FEBE1A64220C8E756F
	4BC235033A2AC7367A3B27DAFE2A0222CBD40A833867B518C040CC65B17AEF47
	3FFAE8C30FDFFBC94F7EF6DEBBEFBDF1FDF7AB0A1007001744AE65C3E9002F21
	36CC97004E936CECFDFBD63AE74E8B623E9F03C09701AE01DC01B80830016080
	2700638041A874B7D97900177A3D1A80F2D1EB39400EB004781BA001A800B44D
	2C9DCD1E0300CCE151C7AEF06F0A230B60C0AC939A2940CDD5FCD1A3473D7E7C
	F9777F773C183866638C675633E09D23228BC822864842A0E8A34613139572E3
	6C689784B6219FDFF74795B1FDCC6860353130335862062070CC83C9E49BFFE3
	BFBDF3679FFCF4A34FB22C1B0224D68E92644054234EBD678046640A30F1FEFB
	CC8573A7A7A74AF7DF07F80AC00D8023800140ABB9000EA0064843B741D76760
	01D2CD9E83B8C2E50178066E0E0D809BCFFF23400D5001540005C012664B8012
	C0D5503D9E2F005EDF568159F84F0A0F00C6C3E168304892844414DF5BFF87C8
	0744226B4524B196BD27110E296101F088648C5238D68316D525A4EFF76D1C14
	67E5AC31D4C61D0C960C00030B83034E93E427EFFFF4BF7FEB5B0F1FBE02507D
	E201AA476A5047E9EC47905A6B0D800757BCFE780EF01AC06F03FC07804B00D3
	103DAA68EFEC35EB05257E5789713D2F368734700E7B67A6290E874CE400DCAB
	AFEA151BE69643DE2F9D5B00E475AD4C5ACEE7CD978F330D7A420C0522608C44
	190435B6C618563F9548FB88083115A16011373C1AE6B61EA08EEA764D78E72C
	05B7830C0C0C4C04C063A094C8338FD37406E01745016A4E67006061FE7A04ED
	5F05B803F09F00A600C3A86BCCEDE9F8DCD768BEB33D0DB71A7E64EBB4AE7B27
	014889DA6CEBD6451D73A302F1F06199653A52D93AA0216BDDFAA97AB9A64180
	244922979BAD081AE3448CB514FA4EBA6240DB96D2C3FD9E1EF48E68030B020C
	201D038C6D3A201A1A53368D56D8E700AF00A833F338F831AF017C1EE00EC065
	8029800DC53CBFBFE15B7AB9EE73A92F7B5AFE773672F79A851ACDDD6A034FEC
	071225000900583B205A59CBD6625B5013CDDB7785268398A5693BF41214A52D
	80EB6C4B482F6ECF45D875DB4F84423D66C48D8B883822BA3B9D5A006666A21A
	C0593B70CED43500BC1EE8FEFB00F7005E0238021845C2DE6C11E89CD995BD33
	275B395ADAC50FDC95CDA56DD589DAEE7BE57800F04436CB30CAAF80A24AC706
	9134495A08621691A669D018D4A85844A71CBB5A58F71AE2009124499E6BF338
	3D87488CA9BCCFBC9FE6F974B94CF2DC3E7AF4BF011E00FC6B80BB0097008E00
	925DC28EBBC625F635F9FACD7EEC73B048B67A1AB71B1A6136DB374A25BB1AE5
	489D116B75B0DB86D85E5317A1AABA5608AD386AAA8ABD27440120226BADB1EB
	3E6845FF0D37B41779EFCEC789803190A6B45A5D2D8AF16291E579F6F831054A
	3D00F822C0516427EBAD26E173882E5B5C396740EC9958B4DD9B8EB319A4A9A6
	8EFB23AE5D1660A781212263D0DAAE5B56FBFB284085D7A89839495315736B4C
	E39C92D439D70BB3FAF5800E5B76503CD429F524383DBDF8BDEF5D3D39397AFC
	B81BA6E89A828E00249853D83F3374FE58CF767B333FB7C0E21E7B20B319EA28
	80B5B499373D7FF2296E2A69CB2F21C1C9C1956466F0DE5AAB7199D2DA3B97A5
	A900B01A8000719DE9EE3A51D69DA03BFB217AE920C37CF1AFFF9A6633B7D527
	0BC183C45D5801CF0141B8AB39705B21703FA0C71DD118C6B2310C648331B439
	652FBB9460E3B8FA489A864354675F678A4C579B2232D6B610642D892062A343
	57CCC69804919DEB42B338B3B036C212D5697B6748372BA9DDF40F1E40D4440F
	5BDE056F8D2DEC9BDF943DF3D0BC471ECF4798CD486A0641E4D198D8C3A12D8B
	027B78B0F6D9B38CAC45E6B6E466DB9EFED857D1A82A4912EF3D00A4592661AB
	010E5E7ED797B86984832AED2C6C6E54C4449088EA1A363B2FCF692AC62D293E
	67E0EDFCF12ED843FAFEE85210790A220F9187235D3D76DB95DACA45C6DE773B
	C1A14D645DEA4CEB459A0B3246DB43D7791DF56E8940C4794FC150C72D588868
	B5A9089F6FEB78DC9331C55DF0227BDAC465D7D7F7995FD98C039E29F21489FC
	86634AF43C96BC0F8051DD51271858BB2EBAF4350077C512638CB51845B95E24
	B1161075F02686A0CEE9B75DF1B46B0A8A6734FA374D642E5CF09BFDB9120AF4
	B03538B86D60F15986F7D99E704F78B5137D346A77FED9EC6A85305B00BB363B
	58DF525761EF5DAB032EDD6FA603C9D0B0ACE2DBEBBA8D9BF9D6FC8BF2CA71F0
	1B20683355BDBB32C34CC6E068044DA39DF8ED833D78A0CD42F184176FB6749F
	4F6BD9A310CF7046156D2291C75D12D31BD2DB315F45CFD8B9108D4163C0398E
	A67729B4235ADD6305D1EAC60D443A03A375183DD2340D126992222E08B763AA
	D0B5E405B3AE16A31325ADBAE9B63C9824DA40C8FAD84A23EFDB7D23026362AE
	ACC91A6DC3B02FFE92CD8D510C40128D6048809A1EDD71B3579E9E05EBB8EBD7
	9DC606434B689C1DA07EEF9DE8C085770EA2193C0AA12B6E0D31AE7B43BBF9D5
	EEAF77BD34B0D1BC2746BDD5D1C89F9EC6C32A7D8435668DE95906DEB784764E
	B92251635D3BB618D485755791F95C679556B3D9723412638655955A9B38671F
	3FA6D9ACCD71468F1477A8E1E6080DEED73308F3C6B2958AC05D11F876A354CF
	726A5B714BD2007DEC7D07F23D27B385A05823E29C682F306E7B239284026276
	137A12D9AB9EDC756916D1742000669984F91E0210E7F8C18396648F1F23400D
	B078F8F02769FA81314C941873349D5E188D46C60CBEF4A59439F13E691A93E7
	A6AED17BEBBDA92AAAAA8D3126ED2F228A892B5BD3A31DBACA1688090086BD31
	3632683D2323D2ED00A1B8D40D5477F378FA8D187FBAA8CB42D4D0CADA64B179
	BDF5E544C0184C126D50D59B5E6F59126D6B12179E291A84DBD8B747637A0049
	126426EF3D40F37BBFF7F4E8E8E4E8A8240280578E8FAF5EB9321C0CAAA65955
	55DD346559D64DE38D71AAB2008E99BC37CE917396D9D4B5A96BBB5898BA06E7
	6CD3505D63D348004C8C34460078571AAE3F35962412369869377BE8E432E8C1
	06A6452D92B2D5D8A06FBAA8CB7671415C98EC6A663DF843444C12D972E960E7
	CE209136484F943A94681A00A8C7E3E5A54B4FAF5C69864326BA71E1C29DCF7F
	FEFEDDBB2FBDF8E2703050F7ACAAEB5555956559AC56799EAFCA322F8AB3C562
	B15C1665595555DD349ED91A834141BD73C67B74CE386798A9AA4C599AE592EA
	1AEBDA340DD5B5093B2CC4A1AF10A93C09911843DA7F1F2664D68DB091ECFAD0
	1CDE8A5704E210FAB6B588DFF3852C44BDB1F1079D8EF421686B0EF2FCECD80E
	7F8319988DF76E382C2F5C787AF366319D22E2603279F9DAB5BB77EEDCBF7BF7
	CAF1B1F68050404FEAB625ECA650005CD3D475BDAAAA5559E6CBE572B95C1645
	5E148BB3B3459EE745B15AADCAAA72CE196B3B57D16BE37FD3A0F7D639D33450
	55A62C71B934754D4D83756DEB1AD5362C16A2DE4BDBDD06026BC15F37DF45BD
	A46BE7A2B7FB49AFC787D97B6F256A3C89FDD3CE14AF236105F424D9E7B6C7A9
	887E00ACF8E31C7A2F49525DB8B0BC7E7D71E9122489B1F6F6B56BF76EDFBE7F
	F7EECDEBD7B3B07B0675FB16778990D827D631F324B1A3D1A8DB9213B11B89E5
	BA2E8AA2ACAA5C59B25C1679BECCF3B3B3B3659E17ABD5AA2C57756DB5212A00
	91D7EEF3BA2666720E9B464E4FC757AE8CBA744B3B630010A139C743FA9D1EA8
	DF18EA91B1A18D87712C4429CFDEB0FCC69858E7046C6D46809B152BD81C4507
	00644666E37D7374947FEE73679FFB9C1F0E1DE2D54B97EEDEBA75FFDEBDDBB7
	6E4DC6E375C629DE32BAB7578292B87BAF6DCC006BEAEB1B63284D2793C904E0
	4A4F20EADA95655E14ABB2CCF33CCFF3C572B9C8F3E5D9D962B1C89531AB55D5
	3476342222B8726561AD393DD5A20A1A6310FB9B0910711C3C47E3EC10363989
	A15FDBA5CAB21C0E87AD06F43A53E223BD41492D68C8B92155F7113927DEBBF1
	B83A3E3EBD7A75359910E2F0E8E8CE0B2FDCBF7BF7FEBD7BC7972F77BB0E43B4
	8BCE060362129FBFCE9FD6D70749D3244D2F1E1D5DDCEEFD2BCBBC288AD52A2F
	8A3CCF9F3E7D5A14C5D9D9D9C9C9C9871F7F9CA5A936DE1A6B4D92687596540B
	899C738D73A6834AE8467720561711A9AA6AB55A31739AA65555D95E3B502F0D
	17E7ED3416832CDB07F41C6F6BD2349065C5F1F1F2E6CDFCE245B496D2F4EEF5
	EBF7EEDC79F9DEBD9B376E982C5B6FF11B4B346CED16FBCFB30534118D46D3D1
	68DA3BDE34CBC5E2DB7FFBB73F7AE79DB2AEF3B22CF2DC06CF723DB523521485
	21D2FABB2152C690B518AA024DD32C974B11B972E5CA8D1B3726930900D80E79
	9C73F1E0403735B62ECB889048A7013B449E595351CD74BABC7E7D797CCCC361
	8378EDF8F8CEAD5B5F78F9E5DBB76E0D2693354DFF456C889E2493CB97FFE00F
	FFB059AD8AB2CCF3BC288AC56291E7F9D9D9D962B1288A222F8A22CFCBB2ECAC
	699C112263D2345D95A5308F46A39B376F5EBD7A3549123DB35F90E94DE56D17
	CB2818E1F8159D03EFDD64B2BA7AF5F4EAD57A3C0680C9D1D1ED175FBC7FEFDE
	FDBB772F1E1FB7E456917F0EACF8955A88988E46E96874F1F2E5DE4755599665
	B92ACB22CF574571B6582887168BC56AB52ACBB2C8F36AB522801B2FBEF8C20B
	2F8C46A3B6C953D3D15D29A68BD37AD01F4767C2AC9B4370801AD3347E3C2E8E
	8FCFAE5D5B5DBC48D69A2CBB73E3C6FD3B775EBE7FFFC68D1B6BB715F15F1CDD
	9F6765834136185CD82ECC31BBA659AD56DE7B1649AC1D4F263A831E9F663B97
	A8CBC1C573DC5D233C852D42880899C93901682E5C58DEB871767C2C59E611AF
	5EB972EFF6ED7F750BA0A0300000015849444154EFDEED5BB7D2C96463DBF6DF
	BC45446996A55B26B3B76CE8E2E2A2285435749EAF87455A9747C46438744992
	DFB9737A7CEC47232F32B970E1CE4B2FA9577341BD1A0D49B6B87D583B1850D7
	F56AB53A3939D1FE21EFBD3A49D65A6BADF243DF6469FAE377DEF9E0A38F96AF
	BE6A92C4A6E94B376FBE7CEFDECBF7EF5FBD760D93A475817F1D71E697685DDE
	78E30D00D0392C6676CE35755D5655559655589EB9699A2CCBDE7EEBADD39393
	ABD7AFDFBB73E70B2FBFFCD24B2F99C16067E6FDB09E97014F9E3C494286B92B
	A375DB85344D535755E35C53D7755DE7793E9D4C3E7FEB563A1C1E68F74FC380
	BAAEA3BD2FA2CD9B7A1B821CD62F890187FF9FF067EC2C1D487060C081018775
	60C08101877560C08101877560C08101877560C08101877560C08101877560C0
	8101877560C08101877560C08101877560C08101877560C08101877560C08101
	877560C0AFD5FAFF45280CF1CDD9E3FA0000000049454E44AE426082
	]]>
</Picture>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="10" length_in_bytes="3585" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000005B0000
	006808060000009ED88C9A000000097048597300000B1300000B1301009A9C18
	00000A4F6943435050686F746F73686F70204943432070726F66696C65000078
	DA9D53675453E9163DF7DEF4424B8880944B6F5215082052428B801491262A21
	09104A8821A1D91551C1114545041BC8A088038E8E808C15512C0C8A0AD807E4
	21A28E83A3888ACAFBE17BA36BD6BCF7E6CDFEB5D73EE7ACF39DB3CF07C0080C
	9648335135800CA9421E11E083C7C4C6E1E42E40810A2470001008B3642173FD
	230100F87E3C3C2B22C007BE000178D30B0800C04D9BC0301C87FF0FEA42995C
	01808401C07491384B08801400407A8E42A600404601809D98265300A0040060
	CB6362E300502D0060277FE6D300809DF8997B01005B94211501A09100201365
	884400683B00ACCF568A450058300014664BC43900D82D00304957664800B0B7
	00C0CE100BB200080C00305188852900047B0060C8232378008499001446F257
	3CF12BAE10E72A00007899B23CB9243945815B082D710757572E1E28CE49172B
	14366102619A402EC27999193281340FE0F3CC0000A0911511E083F3FD78CE0E
	AECECE368EB60E5F2DEABF06FF226262E3FEE5CFAB70400000E1747ED1FE2C2F
	B31A803B06806DFEA225EE04685E0BA075F78B66B20F40B500A0E9DA57F370F8
	7E3C3C45A190B9D9D9E5E4E4D84AC4425B61CA577DFE67C25FC057FD6CF97E3C
	FCF7F5E0BEE22481325D814704F8E0C2CCF44CA51CCF92098462DCE68F47FCB7
	0BFFFC1DD322C44962B9582A14E35112718E449A8CF332A52289429229C525D2
	FF64E2DF2CFB033EDF3500B06A3E017B912DA85D6303F64B27105874C0E2F700
	00F2BB6FC1D4280803806883E1CF77FFEF3FFD47A02500806649927100005E44
	242E54CAB33FC708000044A0812AB0411BF4C1182CC0061CC105DCC10BFC6036
	844224C4C24210420A64801C726029AC82422886CDB01D2A602FD4401D34C051
	688693700E2EC255B80E3D700FFA61089EC128BC81090441C808136121DA8801
	628A58238E08179985F821C14804128B2420C9881451224B91354831528A5420
	55481DF23D720239875C46BA913BC8003282FC86BC47319481B2513DD40CB543
	B9A8371A8446A20BD06474319A8F16A09BD072B41A3D8C36A1E7D0AB680FDA8F
	3E43C730C0E8180733C46C302EC6C342B1382C099363CBB122AC0CABC61AB056
	AC03BB89F563CFB17704128145C0093604774220611E4148584C584ED848A820
	1C243411DA093709038451C2272293A84BB426BA11F9C4186232318758482C23
	D6128F132F107B8843C437241289433227B9900249B1A454D212D246D26E5223
	E92CA99B34481A2393C9DA646BB20739942C202BC885E49DE4C3E433E41BE421
	F25B0A9D624071A4F853E22852CA6A4A19E510E534E5066598324155A39A52DD
	A8A15411358F5A42ADA1B652AF5187A81334759A39CD8316494BA5ADA295D31A
	681768F769AFE874BA11DD951E4E97D057D2CBE947E897E803F4770C0D861583
	C7886728199B18071867197718AF984CA619D38B19C754303731EB98E7990F99
	6F55582AB62A7C1591CA0A954A9526951B2A2F54A9AAA6AADEAA0B55F355CB54
	8FA95E537DAE46553353E3A909D496AB55AA9D50EB531B5367A93BA887AA67A8
	6F543FA47E59FD890659C34CC34F43A451A0B15FE3BCC6200B6319B3782C216B
	0DAB86758135C426B1CDD97C762ABB98FD1DBB8B3DAAA9A13943334A3357B352
	F394663F07E39871F89C744E09E728A797F37E8ADE14EF29E2291BA6344CB931
	655C6BAA96979658AB48AB51AB47EBBD36AEEDA79DA6BD45BB59FB810E41C74A
	275C2747678FCE059DE753D953DDA70AA7164D3D3AF5AE2EAA6BA51BA1BB4477
	BF6EA7EE989EBE5E809E4C6FA7DE79BDE7FA1C7D2FFD54FD6DFAA7F5470C5806
	B30C2406DB0CCE183CC535716F3C1D2FC7DBF151435DC34043A561956197E184
	91B9D13CA3D5468D460F8C69C65CE324E36DC66DC6A326062621264B4DEA4DEE
	9A524DB9A629A63B4C3B4CC7CDCCCDA2CDD699359B3D31D732E79BE79BD79BDF
	B7605A785A2CB6A8B6B86549B2E45AA659EEB6BC6E855A3959A558555A5DB346
	AD9DAD25D6BBADBBA711A7B94E934EAB9ED667C3B0F1B6C9B6A9B719B0E5D806
	DBAEB66DB67D6167621767B7C5AEC3EE93BD937DBA7D8DFD3D070D87D90EAB1D
	5A1D7E73B472143A563ADE9ACE9CEE3F7DC5F496E92F6758CF10CFD833E3B613
	CB29C4699D539BD347671767B97383F3888B894B82CB2E973E2E9B1BC6DDC8BD
	E44A74F5715DE17AD2F59D9BB39BC2EDA8DBAFEE36EE69EE87DC9FCC349F299E
	593373D0C3C843E051E5D13F0B9F95306BDFAC7E4F434F8167B5E7232F632F91
	57ADD7B0B7A577AAF761EF173EF63E729FE33EE33C37DE32DE595FCC37C0B7C8
	B7CB4FC36F9E5F85DF437F23FF64FF7AFFD100A78025016703898141815B02FB
	F87A7C21BF8E3F3ADB65F6B2D9ED418CA0B94115418F82AD82E5C1AD2168C8EC
	90AD21F7E798CE91CE690E85507EE8D6D00761E6618BC37E0C2785878557863F
	8E7088581AD131973577D1DC4373DF44FA449644DE9B67314F39AF2D4A352A3E
	AA2E6A3CDA37BA34BA3FC62E6659CCD5589D58496C4B1C392E2AAE366E6CBEDF
	FCEDF387E29DE20BE37B17982FC85D7079A1CEC2F485A716A92E122C3A96404C
	884E3894F041102AA8168C25F21377258E0A79C21DC267222FD136D188D8435C
	2A1E4EF2482A4D7A92EC91BC357924C533A52CE5B98427A990BC4C0D4CDD9B3A
	9E169A76206D323D3ABD31839291907142AA214D93B667EA67E66676CBAC6585
	B2FEC56E8BB72F1E9507C96BB390AC05592D0AB642A6E8545A28D72A07B26765
	5766BFCD89CA3996AB9E2BCDEDCCB3CADB90379CEF9FFFED12C212E192B6A586
	4B572D1D58E6BDAC6A39B23C7179DB0AE315052B865606AC3CB88AB62A6DD54F
	ABED5797AE7EBD267A4D6B815EC1CA82C1B5016BEB0B550AE5857DEBDCD7ED5D
	4F582F59DFB561FA869D1B3E15898AAE14DB1797157FD828DC78E51B876FCABF
	99DC94B4A9ABC4B964CF66D266E9E6DE2D9E5B0E96AA97E6970E6E0DD9DAB40D
	DF56B4EDF5F645DB2F97CD28DBBB83B643B9A3BF3CB8BC65A7C9CECD3B3F54A4
	54F454FA5436EED2DDB561D7F86ED1EE1B7BBCF634ECD5DB5BBCF7FD3EC9BEDB
	5501554DD566D565FB49FBB3F73FAE89AAE9F896FB6D5DAD4E6D71EDC703D203
	FD07230EB6D7B9D4D51DD23D54528FD62BEB470EC71FBEFE9DEF772D0D360D55
	8D9CC6E223704479E4E9F709DFF71E0D3ADA768C7BACE107D31F761D671D2F6A
	429AF29A469B539AFB5B625BBA4FCC3ED1D6EADE7AFC47DB1F0F9C343C59794A
	F354C969DAE982D39367F2CF8C9D959D7D7E2EF9DC60DBA2B67BE763CEDF6A0F
	6FEFBA1074E1D245FF8BE73BBC3BCE5CF2B874F2B2DBE51357B8579AAF3A5F6D
	EA74EA3CFE93D34FC7BB9CBB9AAEB95C6BB9EE7ABDB57B66F7E91B9E37CEDDF4
	BD79F116FFD6D59E393DDDBDF37A6FF7C5F7F5DF16DD7E7227FDCECBBBD97727
	EEADBC4FBC5FF440ED41D943DD87D53F5BFEDCD8EFDC7F6AC077A0F3D1DC47F7
	068583CFFE91F58F0F43058F998FCB860D86EB9E383E3939E23F72FDE9FCA743
	CF64CF269E17FEA2FECBAE17162F7EF8D5EBD7CED198D1A197F29793BF6D7CA5
	FDEAC0EB19AFDBC6C2C61EBEC97833315EF456FBEDC177DC771DEFA3DF0F4FE4
	7C207F28FF68F9B1F553D0A7FB93199393FF040398F3FC63332DDB0000002063
	48524D00007A25000080830000F9FF000080E9000075300000EA6000003A9800
	00176F925FC546000003224944415478DAECDCCB7283300C0550FBFF3F3ADD84
	9438D858426F299B4E6752424E3DC232E6F657E37FF5D65EAFD67A4BFEEA52D8
	ADB5961D9C1DFB803E5E99C1D9B0CFA3B9463613F615EC55CDCE58C7D1D82316
	76F4664247617394880CE8BDBDBF6407FCE4BAE09D8F1D11FEF1C826ADF3AFFF
	B3E9BD874327ABD954C83FEF09844E361B81E0EF2047446799FACD4030C891D0
	599B9A0384023902BA48BB4E89EC19DD3DB62774D185A8ECE8A223FB0391145D
	A58C644557ADD9D9D04D5C20B3A09B9A8D44473739F58B8A6E7A9E1D0DDD4553
	1305DD5507E91DDD65BBEE15DDF5DA8837F4100B515ED0C3ACFA69A083B76D44
	C296403F8E7D8C6ED0EDC088D81CE8E3B1C691BD831E1A9B027DF6B7B332B2BC
	079B011B837EF7DEAAD904E8BBFF905DECAF1BDF19B1AF60A1A566077BDC4E97
	1AFB0B0EB132B9C21EF744A61FD99CD855460ABBB00BBBB00BBBB00BBBB00BBB
	09806317820A3B187A486CABE8A1B1ADA1A7C0B6829E0A5B1B3D25B6167A6A6C
	69F4C216442F6C41F4701D24475406E5EED878ED3AF19E672AF4500B51E7DF59
	36993F44778FAD917E8645778B6D21FD0C8AEE0EDB62FAD92E3A047BDC9F7D77
	FEA4D81ED2CFEED077B0EF36C1CFCE9F049BA30E73A79FCDD057D8D0270D6629
	71286C4E64A9F4B3F1F3AEB0499EA1C1EEF593427E3AB2D018634C07618CDE76
	19D1425643672C8B1F6CAA6C55EE8ECF4B26D4B46673372099D3CF861438FE6C
	D5CCE9673F355B225B95FD4B1945BFBC404A65AB6643DF9A8D7067AB6641074F
	FD38B355A3A3A3DA75EE6CD5A8E88FD6463CEC4AB584FE68644BC77D7A4707CD
	46AE3A4B8DB84FAFE8CBA6E6DC494EF115E33EBDA14F9B9AD587ED9491425728
	23850EC4A6282385FEB05DC7A406674647D56CC83CBBD081B3118AA6263A3A7A
	DF084519C9800E4D3F536BD73DA363D3CFD4D7463CA15F9DD3AA6E93EF1BE14E
	0DB680BE447E674AB1674449A6066BA0DF21935C2035B12DA0EF2243B04D8E6C
	4D7428F22EB6B99AAD898E450E534624D09F2287C7A640A7424E838D41A7464E
	87BD8BCE819C167BD94A3321A7C79E8D68EE38FED4D8D24D506137DC738D855D
	D8855DD8855DD885AD84FD3700AD4BDD3D472C705B0000000049454E44AE4260
	82
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="11" length_in_bytes="3324" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00330806000000A0EEE7B7000000097048597300000B1300000B1301009A9C18
	00000A4F6943435050686F746F73686F70204943432070726F66696C65000078
	DA9D53675453E9163DF7DEF4424B8880944B6F5215082052428B801491262A21
	09104A8821A1D91551C1114545041BC8A088038E8E808C15512C0C8A0AD807E4
	21A28E83A3888ACAFBE17BA36BD6BCF7E6CDFEB5D73EE7ACF39DB3CF07C0080C
	9648335135800CA9421E11E083C7C4C6E1E42E40810A2470001008B3642173FD
	230100F87E3C3C2B22C007BE000178D30B0800C04D9BC0301C87FF0FEA42995C
	01808401C07491384B08801400407A8E42A600404601809D98265300A0040060
	CB6362E300502D0060277FE6D300809DF8997B01005B94211501A09100201365
	884400683B00ACCF568A450058300014664BC43900D82D00304957664800B0B7
	00C0CE100BB200080C00305188852900047B0060C8232378008499001446F257
	3CF12BAE10E72A00007899B23CB9243945815B082D710757572E1E28CE49172B
	14366102619A402EC27999193281340FE0F3CC0000A0911511E083F3FD78CE0E
	AECECE368EB60E5F2DEABF06FF226262E3FEE5CFAB70400000E1747ED1FE2C2F
	B31A803B06806DFEA225EE04685E0BA075F78B66B20F40B500A0E9DA57F370F8
	7E3C3C45A190B9D9D9E5E4E4D84AC4425B61CA577DFE67C25FC057FD6CF97E3C
	FCF7F5E0BEE22481325D814704F8E0C2CCF44CA51CCF92098462DCE68F47FCB7
	0BFFFC1DD322C44962B9582A14E35112718E449A8CF332A52289429229C525D2
	FF64E2DF2CFB033EDF3500B06A3E017B912DA85D6303F64B27105874C0E2F700
	00F2BB6FC1D4280803806883E1CF77FFEF3FFD47A02500806649927100005E44
	242E54CAB33FC708000044A0812AB0411BF4C1182CC0061CC105DCC10BFC6036
	844224C4C24210420A64801C726029AC82422886CDB01D2A602FD4401D34C051
	688693700E2EC255B80E3D700FFA61089EC128BC81090441C808136121DA8801
	628A58238E08179985F821C14804128B2420C9881451224B91354831528A5420
	55481DF23D720239875C46BA913BC8003282FC86BC47319481B2513DD40CB543
	B9A8371A8446A20BD06474319A8F16A09BD072B41A3D8C36A1E7D0AB680FDA8F
	3E43C730C0E8180733C46C302EC6C342B1382C099363CBB122AC0CABC61AB056
	AC03BB89F563CFB17704128145C0093604774220611E4148584C584ED848A820
	1C243411DA093709038451C2272293A84BB426BA11F9C4186232318758482C23
	D6128F132F107B8843C437241289433227B9900249B1A454D212D246D26E5223
	E92CA99B34481A2393C9DA646BB20739942C202BC885E49DE4C3E433E41BE421
	F25B0A9D624071A4F853E22852CA6A4A19E510E534E5066598324155A39A52DD
	A8A15411358F5A42ADA1B652AF5187A81334759A39CD8316494BA5ADA295D31A
	681768F769AFE874BA11DD951E4E97D057D2CBE947E897E803F4770C0D861583
	C7886728199B18071867197718AF984CA619D38B19C754303731EB98E7990F99
	6F55582AB62A7C1591CA0A954A9526951B2A2F54A9AAA6AADEAA0B55F355CB54
	8FA95E537DAE46553353E3A909D496AB55AA9D50EB531B5367A93BA887AA67A8
	6F543FA47E59FD890659C34CC34F43A451A0B15FE3BCC6200B6319B3782C216B
	0DAB86758135C426B1CDD97C762ABB98FD1DBB8B3DAAA9A13943334A3357B352
	F394663F07E39871F89C744E09E728A797F37E8ADE14EF29E2291BA6344CB931
	655C6BAA96979658AB48AB51AB47EBBD36AEEDA79DA6BD45BB59FB810E41C74A
	275C2747678FCE059DE753D953DDA70AA7164D3D3AF5AE2EAA6BA51BA1BB4477
	BF6EA7EE989EBE5E809E4C6FA7DE79BDE7FA1C7D2FFD54FD6DFAA7F5470C5806
	B30C2406DB0CCE183CC535716F3C1D2FC7DBF151435DC34043A561956197E184
	91B9D13CA3D5468D460F8C69C65CE324E36DC66DC6A326062621264B4DEA4DEE
	9A524DB9A629A63B4C3B4CC7CDCCCDA2CDD699359B3D31D732E79BE79BD79BDF
	B7605A785A2CB6A8B6B86549B2E45AA659EEB6BC6E855A3959A558555A5DB346
	AD9DAD25D6BBADBBA711A7B94E934EAB9ED667C3B0F1B6C9B6A9B719B0E5D806
	DBAEB66DB67D6167621767B7C5AEC3EE93BD937DBA7D8DFD3D070D87D90EAB1D
	5A1D7E73B472143A563ADE9ACE9CEE3F7DC5F496E92F6758CF10CFD833E3B613
	CB29C4699D539BD347671767B97383F3888B894B82CB2E973E2E9B1BC6DDC8BD
	E44A74F5715DE17AD2F59D9BB39BC2EDA8DBAFEE36EE69EE87DC9FCC349F299E
	593373D0C3C843E051E5D13F0B9F95306BDFAC7E4F434F8167B5E7232F632F91
	57ADD7B0B7A577AAF761EF173EF63E729FE33EE33C37DE32DE595FCC37C0B7C8
	B7CB4FC36F9E5F85DF437F23FF64FF7AFFD100A78025016703898141815B02FB
	F87A7C21BF8E3F3ADB65F6B2D9ED418CA0B94115418F82AD82E5C1AD2168C8EC
	90AD21F7E798CE91CE690E85507EE8D6D00761E6618BC37E0C2785878557863F
	8E7088581AD131973577D1DC4373DF44FA449644DE9B67314F39AF2D4A352A3E
	AA2E6A3CDA37BA34BA3FC62E6659CCD5589D58496C4B1C392E2AAE366E6CBEDF
	FCEDF387E29DE20BE37B17982FC85D7079A1CEC2F485A716A92E122C3A96404C
	884E3894F041102AA8168C25F21377258E0A79C21DC267222FD136D188D8435C
	2A1E4EF2482A4D7A92EC91BC357924C533A52CE5B98427A990BC4C0D4CDD9B3A
	9E169A76206D323D3ABD31839291907142AA214D93B667EA67E66676CBAC6585
	B2FEC56E8BB72F1E9507C96BB390AC05592D0AB642A6E8545A28D72A07B26765
	5766BFCD89CA3996AB9E2BCDEDCCB3CADB90379CEF9FFFED12C212E192B6A586
	4B572D1D58E6BDAC6A39B23C7179DB0AE315052B865606AC3CB88AB62A6DD54F
	ABED5797AE7EBD267A4D6B815EC1CA82C1B5016BEB0B550AE5857DEBDCD7ED5D
	4F582F59DFB561FA869D1B3E15898AAE14DB1797157FD828DC78E51B876FCABF
	99DC94B4A9ABC4B964CF66D266E9E6DE2D9E5B0E96AA97E6970E6E0DD9DAB40D
	DF56B4EDF5F645DB2F97CD28DBBB83B643B9A3BF3CB8BC65A7C9CECD3B3F54A4
	54F454FA5436EED2DDB561D7F86ED1EE1B7BBCF634ECD5DB5BBCF7FD3EC9BEDB
	5501554DD566D565FB49FBB3F73FAE89AAE9F896FB6D5DAD4E6D71EDC703D203
	FD07230EB6D7B9D4D51DD23D54528FD62BEB470EC71FBEFE9DEF772D0D360D55
	8D9CC6E223704479E4E9F709DFF71E0D3ADA768C7BACE107D31F761D671D2F6A
	429AF29A469B539AFB5B625BBA4FCC3ED1D6EADE7AFC47DB1F0F9C343C59794A
	F354C969DAE982D39367F2CF8C9D959D7D7E2EF9DC60DBA2B67BE763CEDF6A0F
	6FEFBA1074E1D245FF8BE73BBC3BCE5CF2B874F2B2DBE51357B8579AAF3A5F6D
	EA74EA3CFE93D34FC7BB9CBB9AAEB95C6BB9EE7ABDB57B66F7E91B9E37CEDDF4
	BD79F116FFD6D59E393DDDBDF37A6FF7C5F7F5DF16DD7E7227FDCECBBBD97727
	EEADBC4FBC5FF440ED41D943DD87D53F5BFEDCD8EFDC7F6AC077A0F3D1DC47F7
	068583CFFE91F58F0F43058F998FCB860D86EB9E383E3939E23F72FDE9FCA743
	CF64CF269E17FEA2FECBAE17162F7EF8D5EBD7CED198D1A197F29793BF6D7CA5
	FDEAC0EB19AFDBC6C2C61EBEC97833315EF456FBEDC177DC771DEFA3DF0F4FE4
	7C207F28FF68F9B1F553D0A7FB93199393FF040398F3FC63332DDB0000002063
	48524D00007A25000080830000F9FF000080E9000075300000EA6000003A9800
	00176F925FC5460000021D4944415478DAECDA518EC420080050BCE47A46F792
	EECFB4715CB5685150E067924953495F446C751164840388314AC9A692A37330
	3B47E71C4400877A5E9FEB9C211A2239240080544C43442675414AC434444432
	795975CE89C2548B9823A1FECF1E94144C75886959BCCBE3A75CB6926C3538DC
	982A67E2D7FAF690D86F08F7B5DEFB261617A69553045E1ED2300DB1034F2AA6
	210EE049C39C8978E78E0064437C8327057306629A2B7616B235362104F2FBAF
	C6A4442CE5260EB1B4C59801B9129302B1958B18C4BC6C7AEFA7E1ADC67C8388
	199B1D9172CD938A3982881D2B6F6C502F45A81025E1CDC6EC411CC5C36ED148
	1025E3CDC2C42052E1D5D04ABD4637E24E78D4982DC459784F4D63047068C49D
	F1A8304B882BF186CBE949786F3153442EBCE2185121DE28661A12F0AA889AF0
	6634402BF1FE216AC6EBC1AC35371C78F7D8C1F0BA3073444E3C9B89839817A2
	04BCE29A6890384C2978CDEED430EBF1E33DEADD263BA261D6F15A9B6E918886
	59C7AB6172A076BD3BD58489C52B61B2ED13C1305FE1A58069F393CFD019BFAF
	BE279E844981977E2A123F134FC2A4C2E36C7448CFD8EC84498D27BE3B3D09F3
	24BCA98812314FC45B822801F364BCA5881C981AF0581057606AC263459C81A9
	114F042205A6663C51882398862714118369789B2096300D6F53C41CA217E174
	BCED109F30BF8EB52BC1DB16F1094DD2D91743EC2C995768033C025163F93C12
	71B4F13925FE06005491781F38B78ACD0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="12" length_in_bytes="16898" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000F60000
	003D08060000009E3D94BF000000097048597300002E2300002E230178A53F76
	00000A4F6943435050686F746F73686F70204943432070726F66696C65000078
	DA9D53675453E9163DF7DEF4424B8880944B6F5215082052428B801491262A21
	09104A8821A1D91551C1114545041BC8A088038E8E808C15512C0C8A0AD807E4
	21A28E83A3888ACAFBE17BA36BD6BCF7E6CDFEB5D73EE7ACF39DB3CF07C0080C
	9648335135800CA9421E11E083C7C4C6E1E42E40810A2470001008B3642173FD
	230100F87E3C3C2B22C007BE000178D30B0800C04D9BC0301C87FF0FEA42995C
	01808401C07491384B08801400407A8E42A600404601809D98265300A0040060
	CB6362E300502D0060277FE6D300809DF8997B01005B94211501A09100201365
	884400683B00ACCF568A450058300014664BC43900D82D00304957664800B0B7
	00C0CE100BB200080C00305188852900047B0060C8232378008499001446F257
	3CF12BAE10E72A00007899B23CB9243945815B082D710757572E1E28CE49172B
	14366102619A402EC27999193281340FE0F3CC0000A0911511E083F3FD78CE0E
	AECECE368EB60E5F2DEABF06FF226262E3FEE5CFAB70400000E1747ED1FE2C2F
	B31A803B06806DFEA225EE04685E0BA075F78B66B20F40B500A0E9DA57F370F8
	7E3C3C45A190B9D9D9E5E4E4D84AC4425B61CA577DFE67C25FC057FD6CF97E3C
	FCF7F5E0BEE22481325D814704F8E0C2CCF44CA51CCF92098462DCE68F47FCB7
	0BFFFC1DD322C44962B9582A14E35112718E449A8CF332A52289429229C525D2
	FF64E2DF2CFB033EDF3500B06A3E017B912DA85D6303F64B27105874C0E2F700
	00F2BB6FC1D4280803806883E1CF77FFEF3FFD47A02500806649927100005E44
	242E54CAB33FC708000044A0812AB0411BF4C1182CC0061CC105DCC10BFC6036
	844224C4C24210420A64801C726029AC82422886CDB01D2A602FD4401D34C051
	688693700E2EC255B80E3D700FFA61089EC128BC81090441C808136121DA8801
	628A58238E08179985F821C14804128B2420C9881451224B91354831528A5420
	55481DF23D720239875C46BA913BC8003282FC86BC47319481B2513DD40CB543
	B9A8371A8446A20BD06474319A8F16A09BD072B41A3D8C36A1E7D0AB680FDA8F
	3E43C730C0E8180733C46C302EC6C342B1382C099363CBB122AC0CABC61AB056
	AC03BB89F563CFB17704128145C0093604774220611E4148584C584ED848A820
	1C243411DA093709038451C2272293A84BB426BA11F9C4186232318758482C23
	D6128F132F107B8843C437241289433227B9900249B1A454D212D246D26E5223
	E92CA99B34481A2393C9DA646BB20739942C202BC885E49DE4C3E433E41BE421
	F25B0A9D624071A4F853E22852CA6A4A19E510E534E5066598324155A39A52DD
	A8A15411358F5A42ADA1B652AF5187A81334759A39CD8316494BA5ADA295D31A
	681768F769AFE874BA11DD951E4E97D057D2CBE947E897E803F4770C0D861583
	C7886728199B18071867197718AF984CA619D38B19C754303731EB98E7990F99
	6F55582AB62A7C1591CA0A954A9526951B2A2F54A9AAA6AADEAA0B55F355CB54
	8FA95E537DAE46553353E3A909D496AB55AA9D50EB531B5367A93BA887AA67A8
	6F543FA47E59FD890659C34CC34F43A451A0B15FE3BCC6200B6319B3782C216B
	0DAB86758135C426B1CDD97C762ABB98FD1DBB8B3DAAA9A13943334A3357B352
	F394663F07E39871F89C744E09E728A797F37E8ADE14EF29E2291BA6344CB931
	655C6BAA96979658AB48AB51AB47EBBD36AEEDA79DA6BD45BB59FB810E41C74A
	275C2747678FCE059DE753D953DDA70AA7164D3D3AF5AE2EAA6BA51BA1BB4477
	BF6EA7EE989EBE5E809E4C6FA7DE79BDE7FA1C7D2FFD54FD6DFAA7F5470C5806
	B30C2406DB0CCE183CC535716F3C1D2FC7DBF151435DC34043A561956197E184
	91B9D13CA3D5468D460F8C69C65CE324E36DC66DC6A326062621264B4DEA4DEE
	9A524DB9A629A63B4C3B4CC7CDCCCDA2CDD699359B3D31D732E79BE79BD79BDF
	B7605A785A2CB6A8B6B86549B2E45AA659EEB6BC6E855A3959A558555A5DB346
	AD9DAD25D6BBADBBA711A7B94E934EAB9ED667C3B0F1B6C9B6A9B719B0E5D806
	DBAEB66DB67D6167621767B7C5AEC3EE93BD937DBA7D8DFD3D070D87D90EAB1D
	5A1D7E73B472143A563ADE9ACE9CEE3F7DC5F496E92F6758CF10CFD833E3B613
	CB29C4699D539BD347671767B97383F3888B894B82CB2E973E2E9B1BC6DDC8BD
	E44A74F5715DE17AD2F59D9BB39BC2EDA8DBAFEE36EE69EE87DC9FCC349F299E
	593373D0C3C843E051E5D13F0B9F95306BDFAC7E4F434F8167B5E7232F632F91
	57ADD7B0B7A577AAF761EF173EF63E729FE33EE33C37DE32DE595FCC37C0B7C8
	B7CB4FC36F9E5F85DF437F23FF64FF7AFFD100A78025016703898141815B02FB
	F87A7C21BF8E3F3ADB65F6B2D9ED418CA0B94115418F82AD82E5C1AD2168C8EC
	90AD21F7E798CE91CE690E85507EE8D6D00761E6618BC37E0C2785878557863F
	8E7088581AD131973577D1DC4373DF44FA449644DE9B67314F39AF2D4A352A3E
	AA2E6A3CDA37BA34BA3FC62E6659CCD5589D58496C4B1C392E2AAE366E6CBEDF
	FCEDF387E29DE20BE37B17982FC85D7079A1CEC2F485A716A92E122C3A96404C
	884E3894F041102AA8168C25F21377258E0A79C21DC267222FD136D188D8435C
	2A1E4EF2482A4D7A92EC91BC357924C533A52CE5B98427A990BC4C0D4CDD9B3A
	9E169A76206D323D3ABD31839291907142AA214D93B667EA67E66676CBAC6585
	B2FEC56E8BB72F1E9507C96BB390AC05592D0AB642A6E8545A28D72A07B26765
	5766BFCD89CA3996AB9E2BCDEDCCB3CADB90379CEF9FFFED12C212E192B6A586
	4B572D1D58E6BDAC6A39B23C7179DB0AE315052B865606AC3CB88AB62A6DD54F
	ABED5797AE7EBD267A4D6B815EC1CA82C1B5016BEB0B550AE5857DEBDCD7ED5D
	4F582F59DFB561FA869D1B3E15898AAE14DB1797157FD828DC78E51B876FCABF
	99DC94B4A9ABC4B964CF66D266E9E6DE2D9E5B0E96AA97E6970E6E0DD9DAB40D
	DF56B4EDF5F645DB2F97CD28DBBB83B643B9A3BF3CB8BC65A7C9CECD3B3F54A4
	54F454FA5436EED2DDB561D7F86ED1EE1B7BBCF634ECD5DB5BBCF7FD3EC9BEDB
	5501554DD566D565FB49FBB3F73FAE89AAE9F896FB6D5DAD4E6D71EDC703D203
	FD07230EB6D7B9D4D51DD23D54528FD62BEB470EC71FBEFE9DEF772D0D360D55
	8D9CC6E223704479E4E9F709DFF71E0D3ADA768C7BACE107D31F761D671D2F6A
	429AF29A469B539AFB5B625BBA4FCC3ED1D6EADE7AFC47DB1F0F9C343C59794A
	F354C969DAE982D39367F2CF8C9D959D7D7E2EF9DC60DBA2B67BE763CEDF6A0F
	6FEFBA1074E1D245FF8BE73BBC3BCE5CF2B874F2B2DBE51357B8579AAF3A5F6D
	EA74EA3CFE93D34FC7BB9CBB9AAEB95C6BB9EE7ABDB57B66F7E91B9E37CEDDF4
	BD79F116FFD6D59E393DDDBDF37A6FF7C5F7F5DF16DD7E7227FDCECBBBD97727
	EEADBC4FBC5FF440ED41D943DD87D53F5BFEDCD8EFDC7F6AC077A0F3D1DC47F7
	068583CFFE91F58F0F43058F998FCB860D86EB9E383E3939E23F72FDE9FCA743
	CF64CF269E17FEA2FECBAE17162F7EF8D5EBD7CED198D1A197F29793BF6D7CA5
	FDEAC0EB19AFDBC6C2C61EBEC97833315EF456FBEDC177DC771DEFA3DF0F4FE4
	7C207F28FF68F9B1F553D0A7FB93199393FF040398F3FC63332DDB0000002063
	48524D00007A25000080830000F9FF000080E9000075300000EA6000003A9800
	00176F925FC546000037234944415478DAECBDD993DCD795E7F739E7FE32B336
	A0B091204890E00242DC448A2D8ACD455B8B9246D3EA767BA267621C0E3BC26F
	7E987084430F7EF0F81FF05BBB23FC34118EF083C731FD60C5F4B8A7D5924662
	4B6A52120952A0B89320168258486229D49EF9BBE7F8E1DE9BF9CBACCC02A816
	0AE0981951814255E5F2BBBF7BEE39E77BBEE77BC4DDB9568F63C78E6DFFC94F
	7E7AE8F8F16337CFCC4C755583BB23939FE1F94B70030424FF0477297F31F40C
	774484E6758808AA6ABD5EAF5A5D5D6DDF79E79D1F7FF7BBDF7DEDB6DB6EBBCC
	163DFEF5BFFE9FA745E4DB9DCED49AAAFAC83ACBE4754FD73FB85269FC9CC6EF
	067F33FEA5A4AC8F6C5CB5A1F593ABB81C2F9FB9ACF7E8FA97EFCBFA97EFDD5D
	440411713393FC7B37B3A9A5A5A5EE5FFCC55FFC0D9F3D7EEF8FEA5ABEF8C2C2
	A53F3E7CF885FFE1F0E19776CFCFCF775BAD60EE268D4D47BED788E48D917F2B
	3896EDDC419ABBD7470CBBB189FA1B2B84E06B6B6B617575B5F3E8A38FBEF78D
	6F7CE37F028E6CD5C2BEF6DA6B7B54C3BF9B9D9D5B54154B9FAD6F9C32D9A0AE
	6CD803631A356C1F326CF7B226CDD7F4C66B82BBEBB853219F44E549864870B3
	FEFA7E02C3261B36D6787E8C71FBE2E2E247C0BECFCCF05366D8CBCBCB0FBDFB
	EEDB4FBDFCF26176EFBE8976BBC2AC1EDAACD1927756810044600DE87A8DE398
	811928A022B4807676FB86605E63E6435ECBDD0921B0B2B2C2DADA1AF3F3F33B
	CF9C39B3EDE0C1835BB6B03FFCE18FA4D56A7576EDDAD55155CC1C111F8A4CCA
	679686ED06D968CE0E988391D629C64907820D221EF791BF4B362A927E58D675
	D420CB6B9945626C7EB6F437AA3A7CC0BAB359CCD77CEDF2FA22425DD75CBC78
	B1FACC043F85865D55ADB51D3B76B277EF2DECDAB58B562B6016079E060173DC
	847560C59D0A611FCE7637A603B45D3083353396CDB82CC232A0EECC28047762
	8C441F765AC5B0171717D9B367CFFAC58B17EBAD5CD89D3B7750552D76ECD841
	089A0F9FF221AD61E4209E8CAE2BB0E660329CAF54081DCF374BA08EC9CE8653
	90A661D337DEE4B5470F80740FEA5A3684D6E5F3B947EA7AE0E0A33B2E92FE05
	4C84E04E1041DD09C5536F62D8E5A1AA74BB5D161616FC3313FC141AB6886366
	D4758D59C4CC893125CF25DC5E37588A91B60807553880B35B9C608647504F46
	616E44601DF85094931E39130D03A6B24B1B17A29B19314642085BBAB0AA82AA
	20E2A84A369646782D42F17D5D847537DAAAEC06DAD169E51CA4A7C22AC28A18
	3DA08DA03AC9B00511CB869CFE6E10CD0C87CBE0549560B6317C1651704530BA
	06311DC1744452B464868B802A5D11BAEED4EE04D54D375479FD1002AA3AE640
	F9ECF1A930ECB281DC23EE4649E7346FC3159C081CD4C0C3387B117AE29C33F8
	C89D1533BA4488D0726756845D55C54185BB55386DCA6BE67C985FB3359C3E8E
	6CE4AD7DB85BF68C8659CCFF6F26B1103DA51D2ACEADEE1C34E71E871937D452
	181C4DF858E16D83A338971D82430BB03E70D8F4B4DE0F9F53B85D0CBB9997A7
	9F99D978E0CD208AD0C3C19CED02BB45D80D6C57A5CA6FD01361D19D8BC00560
	D18C6E3EB0423A7936809AE5B0BD5EF7E533C3FEBD6CEE92D70D83362EB00C54
	E63C86F29808EBEE1C8E91D7F3260125A8A092BC729DEC9B50D7DC24709F0AF7
	8972AB0A87CD795722EB386DCFE0DB0DE50DBC017AF56D8745604E843F12F883
	08972DF2BA3B27DC581510859B2CF03957FE04615195FF84F31B336A60467528
	BC1FBCCF46204DA4990A2860A80A318E008FD960D71C76227C2EC0FE5021C065
	332E8AB0688689B00DD829C2819C779F36E36D333E142100ED111870389AFBCC
	5B7FAA3D76D94B8DAC9A0577A6806F12F8BCC34BB1E687382B22CCA9B287828C
	A72030E278DE3C316FB09FD6C61175BEA1C2D72A65B6765E8EC9B8A791FE1BDF
	081BA88908E3C9AC3E066E11E55F02BBBA35FF3E465E0982B5026D190054EF3B
	FC0A676734BE1D95FF4A955B54F88FE62CB933D75F5BD9C48C7CCCEF7C045413
	C49D3577BAEEDCABCA97AA0ACC3852D71C8FC69AA614C2CCFA87A7BBD371E740
	081C52E599568BDF9AF1DBBAC673F85E22B42642FED9E3536DD8395444D0BCF1
	965C68E37CCB8507707E6CC63F08B444B9A9846AFD2D973CBD0983D28D08D322
	4CABB208FC4D6D3CA5CE23A2B8475E34675D60B620B68DAFAD0DC58741AB4675
	8A4B38BB45F87377A6EAC85F5ACDF976454795997EEE9D726C93049E9D57E7DF
	45E783BAE69FB52BD6C5F9B1C3BA3B9D46A5FAEA2F5351B51C92A727AE03B53B
	8F05E511E0BD1879D18D45374493412AA97AD13F2E445815E10D778ED535F7AB
	F2C5AA62468497CD5857652A836AE520B8D2BDF8ABBFFAAB1DBD5E2F1C3A74A8
	7DE78103EDF5F5755F776F23785BA44E89CC608D9A2584FE7F45BCE7564527B4
	45626080AF0EA58925A2691E753EF80D887A8A3DDDDDA5C043EEA52EEB997391
	3F845B7A39177C0854493C004D755D24FFBF169128225AB648131029DF64E0B2
	44567D2683BB69DA2292D7B68A31760F1D3A74F41A1BB634161ABA927EF2B408
	F7B9F3F7B5F10BA01D02DBCBC24A5EE4524691B2D065D1D3CF15D8062CABF273
	8F04E0BE105806DEC85EA7BCD6F5F2D2C3F5DE74E7BA3917F98EC1CE18F93F30
	3EE8B4D88BD0CA5EB3998DA77CDAA91C2E8BF013A0139D6F0538571BBF4568F9
	30222E79C13786E403CF5ECA5E41D3C6AC45E89AF1C510F8820847EA9A5F0195
	2A1D1C898DDDD62C79B9D3CA91D4AA082FC4C8B2194FB65AF4CC78CD9D6E0ECB
	AFF6CC79E59523FF7B5DD7336FBEF9A6D575ED2188D4EE15E00AE62EAE792F25
	EA83F43799B90DAE1FD7081A20F6691225EFCF295B97B42F9B1F2EED316F2431
	83DAA408928CB21187FA88612756066E1B0D5B44A872AAD2736706647708DA12
	91DEE0D0EB933B247B0887BE716BAE0A5D74B705889588C46E170D6176FFFEFD
	97BFF7BDEFFDB36A2B5C97E2D43811E35E111E447995C8F39A3CF576076300B6
	0C0C425049E51F6F147D2503470ACC8AB02C81E72CF2AD203C20818F7A351773
	49461A5F5B9F5737F3D7B47B96DDF9BC2807A2F182478E55817DA2A8795A8386
	0116F0AB7894799C45119E35E74111FE409D13062B3942312F449FF121F930D0
	36386C5061DD9CDB80474578DB8C5F89D0D6C0B41BA853BBE55ABC8CBE683FF4
	ABDC5953E54D77AA18F97C55B158D7BC6D462B43F9A36496718FBFFCCBFFEDBF
	8ED1D8B1632731D684309C3D9467C67C9C0DAA2C79D337AB0430B2AEF4F18EB5
	08D32ADC8933EF4EAF1FF158C6823C7328D2BD2008B5797EDF889B67073DCC3B
	889EC1D36290E59006568033C002B003F8C310D82EC247C04A4E7146C1C672D3
	5C04CB6BBDD79D55115E75E702D05B59A1DD6EF3E4934F76BFF7BDEF5DFB503C
	9D9C42D761BBC37D08ABEEBC684E57945D9ECA2965A70D480CCD70B659BA19FC
	8DE5D3754E84F322BCE3F00511EE51E5B79E72F9EB85BDA6CF2E0D0F69F9D485
	FB6242905F11612E04347B69197AAEF70924CDC0700A581678C99D2710F63ABC
	E5C68C7803B08461EA2923074CC3A83DA3EB388F571597A271C48C4A951977AC
	CF601B8F57F41966792376F2BF6F9AB1DF8C03AA9CF384074C35082A9B3DF6ED
	BBA5E72EADF9F91DC458932B6BFD2BE901ABF920AB246D74077A3886D206A670
	14C11913B588B0E6CE5484AF231CB2C899E874B1E448CA9A4B8EAC6D109174DD
	F27B3A1E53B9763DA79CAD6CBCB57B326E2CAD6FDEAB15B04D8453EE1C31E37E
	55EE0B8137CDF828C6C4986CBA85E2C155FBD75E38472D331ED494BE3E0FACAE
	AED2AE2A76EDDCD9DB821C5B109C1E4E1BD88BB0D3E0A8453E023A4010A11E03
	740D421D6F18C9E412D6B428A7ACC77E51F686C049772E5D4700CD5D72FE9A73
	A21C86EF40B9596041940BEA741A466B2663AFAD49FCA8DCA9807745781AD8EB
	9177C5A9299B62DCF319A2A1A6B748DBDE328671ABC11E777E65CE79841D3248
	A3DC05552546DBB0961B78FAA452DC9A08AFC5C81743E0B6EC59A69B79ECA6F7
	2495C41207C1D22ED294ED2E23F480DB803B1DE6CD6979AAABAF897056224781
	0BE2CC2274F201E723D8C7B2C11755B837D63C1F23BFC87FDB16C788298BCF07
	5FCF60C59C1984DBC5D92709FC95FCBB7302EF9BB190538E4E894A308846CCC6
	5D03F784C07DAA38A984F872AFC7114BB5CD4E032419823B7DE0F8CA017A0220
	46EE55655BAE54B41AF7614B3C762FD7356F72471C8E9136E21C89C9D40CCF4A
	7EB431DAF30DA59292877BF60697443887B1CB6127CA094F61936C2C6F6F89C7
	2EB44D91F4EF3AB0538C0AE16236F4294B9E6723436CD25199F2EE0BD158AB84
	2975424E6542C353F741B1E188B941634DF7A264E6F785C0821BA7C508A26859
	BB7E1A73F5B18FB8D311E1B4190F007B449872A76E006F9BE3132167BFD6BF22
	33582445675F060EC6483467D19D758C20C2CD28F7A8F2880A2F8AF0464ED966
	490893E543CA2CD5E7F70047CDF84FC07AABC51CB0E629B252494E691D61D99C
	83113E8F308DB16C914B09BDA22D70972AFB5579D38CD7738A3895836F0B10EB
	B40956809E19DB323ED473E782190198CAC0A495351F131995033E00EB22AC02
	4BEE7D5E81379C5E75AD37B75BF24433AAEC106515E3A20912124BC91ABB6DD8
	C06D189C60A3C76E7A8B427D5974A316D82E4A4B95E57C73B73E24F72163F062
	4426B87802C95C880E3A5A4518B1F066B85B76BA5BA2795A3F4E1EC2AA93E1CA
	46E31EA43882E7CD2E187B113E88912584B6261EBEF4EF45DA72C39E7F235DB4
	542D3C6FD29E3B8B66CC00D3EE2C67FAE995507133CF699725084C844573769B
	F04D9C3D31F28A19472BE16210D63D1080699C3BDC79C4E19FBAB25B84E724E5
	AD533EA0D816046C3DFF3BE5C2547E3E182EA09E40B52EF094088F02E72DF2AA
	C33951D6109C485B8DBD18075DF88A2A379BF1923B963D7054256AF2EE22D071
	673D038E53D9005BF91E8AC800351F17D1345A238324B0154A2AB585E52E6900
	1C3339C75E77A7A7E9C68B8FDFC8E342C944B0D818020E36550A015733DF7A8E
	D42CD2873FAF332A5E42D46549ACAEED9E6E685425348DF70A6B51F0EF794DF4
	CEAEA7D7EB8CA9578FA2E21B5E3B977582E4B54352483F54EE29AFA184600D40
	6F63482D8DB0A078BDB54CA4E964EF72B5698C99E40C39B2E4CEB4285F776757
	34FE5F33DE0ACA74159812126F21FBF8DFE2BC6DCE37DC781A651DE5D7F974AB
	7C788D1C68E5F26BAFB0F3726EDE1567DDE1018427A2F17A8C3CE74EAFAAE888
	12F2DF47E0A839EF5AE451842FAAB226C21B6644842A23F69EA3D54A533434D4
	73974F5C6F6CF866DDBFFFB386D7F649916803CCBCC6E52EC7C569B923E6AC92
	3C8DBA23AA138D6210320E72D594EB6D6CD56CA2E85D556A84CA1C89969062E4
	BA84E2A3FBB8055C706741949D38DB3259A7BDC9E130E419811AA1C6B883E482
	3EC689A2E8841C7F34841EBCA6E51659C9707AEE961B132E67FC06F7D2A536F9
	00EADF8F26109A3D0C57495069A60D3D875A8CC7707644E7EFCC78A7AA980F81
	760AF75019849F2D8125517E68C6B4384FA17C8070C69C191D948F8452464811
	81332871792ED1ED009E7478AF369E4388ADC03604295078F6C2952897C5396C
	4ECB8C4321700178DF8D2AD7FF2D3B26CB5522ED774B489FB8F5C9F7980F951F
	9B86AE5B12906638589A74CF09086BFAB291DCBA6C081FDB2DE419D54D48793E
	D9903E39E6FA3C8CD16E2BCD11CC6B383B55795495C591BAF5E44D2FB9EE6A28
	91C75438E3703A7B5BED575D0BD36DF2413140D44672772673D73EC956291BAC
	84886E46AF800D9B00A023A104BD08AB0E3721DC65C67B66BC1502732130555E
	DB21DAE04B22CC4567CD855F5A6A507938EF8FDEE8550C6137B9ED3C7BFE007C
	0EA18EC61181F590402A69A475C5730671E62535FDBC9C1B626E7127E4129A86
	C1A53777A45E43EC47AFB1C34E8B1F4921A306A67371DD368563A41F7A8F1711
	18E381F2D73430258970E19AEAE0D787A05238F2836A2BC09C28AF189C12784A
	E12EE0920FEAAFE34524848A04BEAD79E40951F6B9F112CE2524A3CD83EDD6AC
	288C051C7D58C42102AB2EEC0CCAB44A1F701C57BE1B1CB632C424DB70E0E690
	7146845A52895347009ECD72EC12184783031162348E2B8490522CCB07C7B8E3
	14600638E7CEA918D9679159B77ECBE96864934825D637882E308570BBC3719C
	05493978210AA4EB6E1C52929E37959B7ACE99310B6C17A1F644ABD1A14AFBA0
	EADD2CC88D5BCBFEFFDD876BC02522CA3F1B7DAE5E6B6F1D3C21E28BEE2C485A
	F0B67B1FF819E50F4B0634CA75A49F4B938C33560A4944A8815973DA960800EB
	5B11925CD52A0C3ABD3A2474F83F4663D58CFF2EC06E31CE65C241CB9D56069F
	3487EF951817BCE692D77C51856F39FC43B7E64D4F65BEC181E0FD1AF8A4BAF3
	00B966108AAB724A9C9B45D841C24174CC8120A243620CCD7B37AA9A12B3716D
	53653D97A22A0611DB669FCD3DF5ABBB26387C3E4656042E07A7230E121954FE
	C7BF4E95094A8B0A6D490D2D34A8AD204D4D9A612C0247DC080697CD8992F002
	1FC2130669A2E74E3D07DAAA2C87404B9569917E6501C9876F8E3464C3D13BB8
	92B18A344DF241C9C99B9EAFF1F36B6ED8FD332A43FD972CF71CE75EDC5A864F
	FD8D65AFC106721FBDFC6103B77C31DB336071D98C2E0DAEED75CBB11BA7B338
	42CD76354E637CDF8CDA9DFF3E084FAB80454E9B73D69D8B38E771CEB871CE23
	7BC4F817C0B71D7ED5AB795652F7DB14032F42834C3238082784BF394F0E382A
	A925749B2AB7E7E7D50DA0A6F97CD54C16917191458EC644588D91FDAA04113E
	B2D44B1ECABDB82232DED0BE23F5879B2931366B7645B1296E8C4C1AFBA8602C
	01494CB1C6F35DD2D7A4BE9920291F16A47048C754669A68525AB7FE35360E51
	55052D1CEF464A9AF3639FC0B990CD483D23C6BC65A8B867F27AC854B833C0FD
	22DCABCAB11859F3949BD423C154120B1866A18DA2E24317EECE0AB04D606FE6
	3C5F921422854F5481FDFD1AF65840081037E6158E3AFC5B8B7CDB85AF89F279
	15DEC7B92889CCA0EE4CE1EC12E576775AD178CE6B9E17452A654E52C94C86C2
	D806AB6CCC0138E471F326AB44F808E7B81B0F85C04983E366ECC8950B1A9587
	12820FB5A236505ACB91524784FBAB8A0B31F2815942EDAF9228E4C56B5A8A12
	9654B8A576B645B810844EE18913FB649BC16945BF8C57E592D232CEA58C520C
	D28158D81F98360EE05CEAAA555831D803B4DC58D3D04F019AF7B80494AA9218
	6A66EC7067DD8C6520A8A6E748EABB9786731AE7AD2795739B6177FF5F06FD15
	5B9A638B80B911320A7ED69C330E0705EE90948FF44AED6E88C7EC23609A3736
	D4B0E72960C6AA3B7721EC3638E9910535AEB7A0D62849A4D9C2AA08F302E710
	FE2F737E122335C621371E37E349739E3078D89D7DD138158DFF07E759155A95
	3257C41E873CE6EF768495CDFE8BBA0681A743E8B399C6E5DA1BF651B98724AA
	A7E666920A38EEA912D2564D39F15570F7CD12A9433044E1840BED007788D0AD
	9DDA46E3C241AAE344F0C81A895BBFC723676364C18D2086E4BF136C6095195D
	4792E1B6F3E1F49EC29DA1628F28EBE5BE35A2A37EC52013847AEEEC46D823C2
	656039573C0AE4D13C3FBC947BCB066978DE666AB3E95A6DF2BB2DD8FBE994EC
	909AF78F78E440253C1994B3D15970D825BFEB2BA7C765E0A6A01C7261D122EF
	65665B9B74785C2FA32E865DD739EFD126573B19E176117A22BCE8C68BD1D885
	B3179843A981F36E7CE4C6922AD341D953C01236828A565C033E919A3A786F1F
	5AC469E002C2B375E49B41F98E2A3F8A910BC06CDEA04104F3411455366BE269
	276368931A49EE70E7C55E8F0FA1CF11FF248B172DB19B2A8F9C01CEA870A73A
	FBA3733AC23687761896622EA21CEB99A7FD800873EEFC1C2386C41AEB6729CD
	CF54EE4BAEDFB74868FA3B068F68E03177CEC7C86552B34D28358A1CC63BC262
	4EB5FE40035D334E6772CA14854DA6F96B7257FCB86AC1503977C45BCB26A1E2
	B505CF5CFA4CA44A848E0A273CD5FB0EA8F094A69AE0254B274C42916D24E493
	7EC8D77C844CBB5BCA0BFD8424437E1D6709A1E3CA8DD4CE9F78E08D5CBB01E0
	54387B44D8A1CABA06DE55E5B03A47D439179456ABC5CD21B02D87A8CD8A4279
	1D33E9BFC7B8537EB417BAA8DA14B04D3CA9B9BCE5C64F6364AF087FD66A7130
	6FAE8BC0A5EC7D7B224411D6711681CB992E7AAB085FAD2AEEA92A5E8C9163B9
	FF38C824D1C4C9F57B11C162E281A3CE0B068EF24C15D8A3B0E0B0181319A916
	278AB0867019A12BC2E3C023D1783D1A2743604A3401600D83287E1E930DCEA2
	EDC2B20B7F1F8DFD2A7C4B951D19F55E01D6C459F1D459B724C6ACC013A1E276
	115E33E3BC089D9C82967B940CBBD4B11B285403F91E4BF819E3A97D04FF18FD
	DB6B2FB49075B88C24D0D712E10583399C2FE596C11F9A71CE614F664159210C
	34F8D64DB44F3248711E9873E7EB55C56D66BC60C609513AF92071D11BC2A88B
	1199495F9DB47073CAFD889E9856EDECF59A67AEE42E2BC628C33475CD06C6BB
	09C9A5D108329CB2A583725684D7DD5830E3CB21F06D558E03EF03173DB28AB2
	9EA99EB392D453E704F6A9B22F7BEE9FC7C849603AB3EA46F3C5AB356ECF5E74
	DA8D8F507E1AE11BEAFCA9C2AF239C7267353A5D175CD36B6F031E74E57E370E
	D7353F0BC29426AE7A619E5B2657044F07EE3A8EE6BE74B3846F882734FD1D33
	FEA636BE8AF0672169EC9DC5E9A1980895C30E8443AECC9AF3BC19C74468E56B
	EF577E486DA051A4D1BF90CB5D2380DFB80359FADC8386CE4033721BD1B2DE92
	50BC59129901164927A1A9F085A0EC96C8CFCD3845A22CCEA83035D2634BF60A
	ABB91C23C021111E0B8159775E8C9137B327AF487A61DAA8855F4FEDBC4673CE
	D0F71388776368820324B504D16EB9F737FE63CA70237C951C5ACFA972DA9DBF
	EEF5B82F839DB7282CC714722E3918CA541598C199CA54E177CC386AC69208D3
	39C7F6DF79CD321B2E267EF94C308E8BF21F223CEDC29745F8C08CF380983093
	318B3BDCA862E4658BBC14802A60082B381D407162CEB42B77E68169113EF681
	F72EAAAC259F3EE2C619771E56E54E9C3BB26888E3B41C2CC259AB79C38D331A
	98CA44963A7BD682A8AFB850B931AB42E5C266A8C815A39B112191D1286DCB34
	CFFA808108DBB371FFC49CF3449E10F83351DE46394EE44387559C9EA5452BE5
	AF4A84395237CD01110E082C98F36C8CBC9F49F125A7B93135308779DB1B1B34
	F28D126FA87F27E4BBBF093C6D14C96AA58A0FD5572791518637CA604B35CB8A
	E54829EA345D117E03BC1A237BA2730BB0CB85791245721DE77434CE9AF131D0
	CD35F822EF641B4A9872D53255652DCAB084E0CE76352EA9F2D7E6DC22CE83C0
	9744D82742DBA1EBC2A5E87C942B09DF09816552FAF77E4E1966556991E8CCA7
	5CB83F287F82F18BCC126D8D72B155A91D96114EBA73D98D5D08731EE979E49C
	3B1FBB734915A4E210425B04CB8EA878E34802FD0E88B2C785E36ECCE534A5D9
	DC316ECA8A8CB6E69570BC78EC0C4C36EBDA5B60D80364BBE0979241A375E0B0
	454EE03C26C2BD28779B705EE0631196806E0E5DDB2ACC89B0C39DEDD997BF11
	232F99B122926F582394F12B96FAB6C088BD51C31E178A0E1B60C81BA027B91E
	2AD01168FB20FA8808EB06DDFCDA55D6FA0E0C5AFE36339C8D0A2AD230F261B1
	8656FE32112E90543EFA6C2FAB1370648AE64377A64952617C83C8D570C547FB
	BB21C930B7C50912590E8ABB3087B26C911763CD39112EE25CCE74C79DC0BEDA
	B945847BF27E3A2CCE7B9634E2A61CDEC883291E75E19F60AC3478DBDEF82A82
	0DB5084BA162C52D29E26AEA20DB09044B5E3862D49EAA00A5B9A7CE787D4B52
	33CC3BBD2EC7DD79A44839FBA0BE3EBA363E2A9CD7305ED970246F51DBA6C828
	55A5F450A7C56B8BB34B9C45831FB8B1D39D7B71EE74E1EED2F841CAC3C9F5EE
	0B66BC60CE7181CB24639FCF17DC97C911EFB72D5E47B8AC113B24A1C5D1D3B8
	D9DC212449E6DA8519776E13E1267376ABB05394995C7A5AD5D4AA783E1AE748
	FAEB8BA44EB1E9A2B4B18971A776586BA404BE214D188D770A03AE0DB896969A
	8A68C3CA2FA3D1C238EF73B51E7BC3FAB8B3101306F34C701E74385EF7F881C0
	3911BA41896E88A616CED338EF38CCC4C83EE00B2A7CB70ABC60CE8B19635081
	5FB8F3961BBB06C5B241C79559BF8D12605D95AE40C761A73837BBB3DBD31087
	68914517CEB9F3514E4724D7D19BD8FD22C6499C6D39CAE88B278CA95B8FFEDF
	9BB5C6E2CD4BC977A48C78EDFBB1BD1859C2200BF9A4F4D208C2ACA472CBBAC2
	0B0E2F46672E1A6DF714D690008D95BCF99104CCEC6CA23F85FDD36F22911B40
	94BEA0FC36BE069F6F4CF4A485D6021E14E10B087B811EC2457396C4B898699E
	9DE8EC51E190A490EF9C3BAF026F00CB66CC34002B1F056064207AD8D8AF1B94
	5BC65176FB1BA9C1B82ACA4FDE98C2B2B19DD63FB1C71EF7FBD51C953CEDCAA1
	681CC67955855ED5C2512A9C0EB9CBCD937AE10AB01A840BC05177BE54479ED2
	C094C3F3392A0AC02911CE2029AD691AA20892B5DB57736A7427707F80F91A96
	1D4E788FDAD235CD22DC1C02F3C0DBC0DB997137234924DE735E2E4169C5264D
	E8EA01C5E1B2571383190692AEB9C72EE36D206E10D9931CF259E62C4FE1B43D
	91011635859B452421E49EE399A20BD5506F1CC8B6CA5084703DF5AB07A05DA2
	3DA6364ADDB0E1EB5CFFDD093CA3CA7DC08918F9B13B27B23881ABA613399FCE
	D49139E036111E12E1BBAA3C20C24FCC389BD54BAA31E1DC40836D94D9E493C3
	BF093F6F4EF1F4919EB0DFC7BA370F80A2A5F2942877033F8FCEEB0A9D2A85B6
	9643EA3DAAECF114557CEC899ABBAC49036DC59D9F03CB6EFC5155B160C6915C
	9FDF4E3A08A431C9D41B07D94AD66F7F3C28F78873B21779AE3696AA545A8B08
	6E4285B32353691F13E14E555EB47428777082A78342D49068F99E4A9F8E2A4C
	9E643AAEA6DD4F1744374442D5D66C721F0AF906FE6CA02449EEBD5D8F29509F
	71676743A82E9274B47A667DADED1B5976DEAC78C2C1245AFADDCEC5532794FF
	0E11FE4B55628CFCDF31F25EE610979289378A5F052C59065E035E73E7405DF3
	4F45F86F42E06F8157B26A49B521242F9F63B30AC62423BE52CA251B9E33CE3B
	7F92505C72B4B6EECE7D2170BB3BBF8D91D75568AB427454238FA3DC2DD08D35
	4B9E38F48704AA4A79D585DF44A3234AC4F98D3BF3663C2AC245E01D9274D368
	5A543E61179811E51985B958F333334E025EA536CD40EAC934600DE7AC081F9A
	71DC9D2743E08FAA8A9FF77A7C6CC6946A16B168FAA091F464423BF310A5B4F1
	77FDC37E0448DA52D665D900CDD63F323ADCCDAD9DB3C06D0AB74B12D4EBE40F
	BD469A9E715284B39E26535679E2E3F0603AC6E48CD7CB6B9731C08A48CC7CF7
	98650785CB380FA8F05F8870ACDBE3EFCCB9DC0ACC88A649968D1BB821542677
	C989705284FFD39D3F32E34FAB5419F8074F9D5AA11F56A6F71EC661BC7F085D
	71E675F95D7FE2A624214406DA739AA58FCAC863F37F9C177733BA5904F15E77
	16B24E79A54A74D823CAD751BC57F31C910BAA58111D88CE1D31F2B8066E53E5
	C71659CCF5E51763E4AE10F85C504EE566A130824D84AC646AC0D30A9D5EE459
	8B9C0E425B932269D341856273EE982A1F9AF1F775E449E0C92AF0A368AC93C7
	24972ECC0D08D4F8D07B4308DED8E4E5A0DF5269A4912EB33EF29AC252E97FBF
	141367F65E55BEA4CA4D19143A6B96944645D829C25D227C3E044E39BC649113
	59086EBACFC2697652DD08C494422249397F08A5C32B72DE858328FFC48CE3E6
	FC07117AADC0364DC651E0B7A1BEDB120D3468839A37E1B2087F9B75D4BEA5C2
	853AF26E0617039E85F4370E3070DF5C67ADBFAA22F43CF1A1C5A1E3963BCBE8
	97767AD9C3696E3FD5063BEA9330CF2C835696196E7701ED1879C39D95DC1938
	4F925FB65ECD2F2C72AE4A14532DCAA2227C4460C19C6FA8F17511FE2EAFDD22
	F08E3B7702FB1C8EBAB1BBD1472E5920A12B70BF3BFB223CE7C6F120EC088994
	62324C1BEE3BACAC22ABAA9CC7F88D451ED78A475579CE8CAE1B411B18878F20
	DE1342F049E58D49DD8BD7DC63C7E8F94B0841F2485CF2B0FB34ADB1E3CED359
	51E4585DF36FCD38975BFE5C350BFF3952D71C50E5C910F8D31078DE8C97CC58
	834C0A68967C36B2B0AE77BE9DDB7259116307CAD34456A3F1EF5DA8B34AA6FA
	D8593493ABE2B966BC1DB804FCA88E6C0B29B4FF3731B22AC2D4C8C0BE665417
	E364B653F3705ACD17B25FE09EA0ECF65692F333F05692FA59CCB8C0313356B2
	72ECA82ACB28DABB592E5F5A71F7E599E8A78BE1017739EC8E353F70E76489EE
	0C24445C12616545942331E9DF3D1D848366BCE189EFF09E3B071C6E33E75D4D
	BA714DBE501798F504661EB79A639AB4DB2A1A23A886AB4F7D3CAB8CF29951E5
	B439EF9AF39028EF189C0F83A690DFD5515CCD634B082A85165AD7250449BB6B
	C5136BE96BAA7C4E84E7EA9AE7DDE986C074A331BFE4303104DEF434BFEA2BAD
	164FE6111147B22769F7C70335081F374C22EEC4984EFAAEC057147618FCAD3B
	CB41D99D3FB35DE1666E08931BA7F52E11CE99F33383FF36C01F2AFC2CD75CA7
	FA21F97008DEA4A26EE097E7E7AC5AD2677B22046EC338EFCED1E85CF248CC65
	B8594935DD47F270BEC375CDE93C47BB3581BB7E35B5ECCA9DE9ACECB9AE4A04
	767A6A9439E1CEB9CC61A8B2BC732035DB38CE0CCEAAC0BB08779970870BEFE4
	54E242AEB26C9784A6D7B96498043B129CB58BA4AE7ADC8DAE0ADB450687AE0F
	B094B15147E6259073EE55857D02E73DA9AA14CE38A3ED3C63442D27F662333C
	166BCBEAD8E0B9297F80BE96124F2F03628F06E56E775E8A9167DDE984C0CE22
	53DBCC3DF2A277445830E347BD1EADA03C1C94058363A9EB2EE53E32686EB8D1
	1E5D87DD28074C38EDC6BB01E635E1E3E683668161D552D9206C30EA590B436B
	4E850B38BF36E78BAA1CB19A73EE7DE1FC716495491D450EAC997113F0AD10E8
	59E467E69C455893A42C62489A96E149B0723E4FA878A6AA385CD7BC998DB25D
	E8955709C89583453341C64551514C527FC0B43B274B5E2F52F418FBBCF91012
	5A3E258967BF60B0C3854A521EDE73A747442C2252215548AA329EC0D980B303
	61D59CD5203407F71559E752269C3844219730D744B8E0CECE2CEAD965D031DA
	0CE964043C1B8B8AB331741F2D6DC2F5500ECA06BB0EDC02DC4D22F3FF86349C
	6F5B0EDFAC80190D0650CC27F20E114C955F39F45CB8478419337A9E7A9F5208
	3E2879DD28A37425E7A977922892EF3AFD1AEC30A9A51E22B88C867CCD5EE0C1
	3582614C61D41E79DB6BC461AF25C1867A088368769B8DF70AA5CCB35B956FB7
	5A2C9AF18368BC9DA76BB6C4985167360853A593498473C07331F26A5DF36855
	7148D2C0081B11C1DF54B6A9747765B02E8FB84B5594869284E4891A035C6550
	79B128793EDE40B8C1620DB146325BDC3D660B48D41427A218E69180B15D9CA8
	E960D00605D77DE3FA8D35C4BC5FD75D587263C63C4B36F95049D647E48EC669
	9E0D21E30DB6DA24BEF935366C699054A4EF05BA5978E1D6CCED3EE1CE82A76E
	A16641C6474EA42683670AB8E8CE7B6ECC03B768EA75AD25B7C4E5217265DED7
	F5CFB3079F632FB0E6CEFB66098869F0E14B275831EC42EC295F83DFFBC8FF93
	804091F35904CE8BB34F9419094986AA01F64CEA002B5E613573061E512598F1
	D3687CA4CA9C2A3302A1DFA4933A94C45393C59CA4DAEE61338E6529DEDB5459
	F1ABD78BEDAF55992B5E1BC10DB7345575291F2EB76669DF5EA30DB2D89565FC
	60A58696C136D7A4E91E52AF76A2A7067A08882549E12CB6508A36860EAACC45
	98B38F4B4C2AE76EDC6F2A8E6AA20B5B230EF546D42457E1187CB45E3C62E8CD
	DFE9F5F05C356922C2AECC28FA288BDFB5AE70F39B1BAF70984F592AE3CCE319
	FD2D4302E406CBB1931F9E15615BE6C12F039AF18718071B66B8AAD1AC811B4D
	B590C1F775DFBB3B50A96028A71CF6B8306D50678F56F08ECD0E3B01D6CDB813
	D8EFCECF7B3D2EA9302F9AD698ACAFE9C3AA3005A29B1621A8F2EB1831110E66
	94BCBE4ACCA8DF0D98AF6E95A41A3A2D4AA5CA25E0B43BB7E1EC71A3E7A95BAB
	A9B4A3A49077CDE0761376A39C124DBDE49EC40D3B08977268DC2A21B6A7D03E
	0A5CB248A736DA961A3812084CA3AF7E231F7E5498D344684B3AF05644A885AC
	A3965B799BCD1B639A3E865EAF19328C28966EB1C71E095372F8609208062D77
	56731D51FB79A26F203A8C12E14BAEA6994954BBD04650348FA6497CC78168FE
	F50BBD872A04B951A2A54A37D75CB53FF5210925C42843A0D6C62AA737BC74AE
	A27A12F32F06A69EBAAF3E36A3654645CC1320F3848D2B9046EA6C9CFBDC5933
	E33D726F75D15893D2573E3CD8A199074E6501CBB39E44126FCE79EDD5125460
	208C785653BBEFDE468A765C848F55F99A56EC75E7827BE6DA2720F5529E8BF5
	A0288FA9F041AC3996A3A33A3AFB4D88D13957D8608D1CBAC8635FC6E84860BB
	2BA4C0219769C777CF8DBBB6AE27006EDED2FD48C33212EBB2238207A5CE3DDA
	CDC3B1E8058ECA0A17A3AEB3332CFA0489D1A65B6FD8D2946F2D686E53E625D7
	27B912A7B8C8B78E091FB5782D1F9032AE97C71EBDC97DBE7546917D432BDE60
	C246A920C4D86CAF9421B9DBE17AF4486492257B6291488A49E4C163934F2063
	0F22CD5D773B73D87D1EFA254786F4CA1B94521F569A4D33A29D962A6762C43C
	29C4C44F50B629F969A5CA077900DDED66B46344DD5931E397B5B186F38D203C
	A9C23E494CBD9608FB45F8A62A5FD54468FAA5195D4FE6DBF1542EFBD89D0F1C
	A6A3A4869602B85ACACFCF9BB020700FC2AC25145D99CC7C6A6ADC0B697699E2
	DC9CAFE5831C4D0612E1AA2DC2BD55C50CB060C66A8E60D7DC5923A9B5AC36FE
	5DCD9CF5C53C8CE01611664260852DE68A4F123E977CDAB80855537EB5D16C30
	76E0DB4819C6B3CA05383D8B98E4F9C6E6B8DD788878992159A478C53D19CDD8
	DC4CFA2173F3801A1DE6313ABB43727E8909B34171316A133C7A1F48DAF45EE5
	0D39938DEA820AC441356372B561A0B5D64766B39EBCE5FCDB3719EB34E9506C
	65BEFCDB21F045331E020E7B6A99BC108DBF37E32155EE02F68BB3A601C99F5F
	DD7923465E73673D0444957533BEAA4AEDCEDB66AC8B306365B2E8401EB822A9
	9BBE2C916F878AFBDD793E1B596704FDDEB04773A4B1E4CE3DC03D1A385A472E
	A932A349A5765584D77A3D1E6FB5F84E5571B4AE89854156861B36426F6F447D
	B8B337047665CEC0B20C4617F956D5B1C786582229FF1161B72A73B979C1AE72
	305D1F3F16D84145106795D897AEB28162DD0D65D80A2C921A123AEE54EE74C7
	CA7E8E27B78C1A76B191669406507B1A40B757D2E084353E990C734973B441F0
	917FE401FFBB4C3C2D1CF929E028B04795FBDCB96CC69B38D321B0E8F04BCF2D
	9438739A0ECC33EE9CCEF259ADDC441363E411550E3AFCB2AE399D674BDB48F4
	E37924711BE1A8C3EB667C21045663E4B799C63BCDF0BA34C1DD1A5871B85D95
	47711662E435375A95D2CAFA2C02BC6506BD1E0742E0D61052E76223DDB43CAA
	CA6550AF36F2A4CD7C301D73A70A81B8D5049571A14A3BEB809F75E72E11EE00
	4E66439F62A0BC312E87290BD9736839DCA929DFF838172CDA7934AD00375A19
	5B7313CB65336E07768A72CAF310F50DAD92CDCAC200496D4EBA2C20CEF075A6
	D951D3C0CDEE1C316325877D88343AE1261B5355801E52D799D01CCD230C46EA
	8E027D239842060B430EEFE52A6FC8681AD6C993630EE768EF3160DAE14D8FD4
	282D84739AE6714B63469866F6E2AA3B33663C2EC2E78023BD1EEF6A02E2AAFC
	3947D7C5B3386634E31FEA9A4A95A772EFFF11921A4BB034979B9162651BB85F
	E161112E46E397D1B0A0CC4A024FEA98A67CD64179CD9DB763642EDF9B822188
	0DE3E7A35341D6DDE9656DBF3669247093EB5E6D85218F862B21BFF14977EECE
	C67D42847772078C362F70A456A739945DC57840949B715EB79A0BB94C2119E0
	50FD64C3DAAF3578E68DF6D30FCCB83B04EE0A7022FA58618449FDD1A37CEFD1
	7649CB06B427F7B87F4892389A6B8C661D97E736DFAF2DC27987258C9BFACFDB
	886B8CABE3F663A5CCF0DA9BD981170B13EB77C0274C844E8CAC98F1EB7C3D9F
	57E51687F770CE911C8597EBCFDFAB3BB39E7AA80F85C04E777E53D7BC2A82E6
	76CE38D22DD5C409C8B4D815117E16234BAA1CD424017D92D494B46296402C4D
	229ABBF281BAC79DD3B1E6154BFCF63951C42D8D02F21415545E249D533FBE34
	B018F761F59DFE18DD86367BA771A0C8D60A2D6CDC44E5834F01974578D98C6F
	ABF265152ED4497D625E92AA644109B5111E2E018B661C10785C9C0FCD780BC7
	249D82B19197AA5EBF50DCCC72F3C770B4D151E558341EC2B95312C77B956484
	9B4DA31C275C30423E4A396D46B41F564D5A64EE84905445E298B6CA0D074ADE
	140BEE7C08DC11840326BC6749F5238835C4019ACC02FABCF5A233DE76671F49
	F7FDC33CDE894F808A97BD62665836B235775E74E7428CDCAF812F082C085C04
	5633EA2C9AE8C8B322ECC29973B85CD73CEBCE2911A68AD0E2A4891B8D3C1777
	664458AB2A7E65C6A9187920040E8AB03F97CA3CDD702A555A992A7DD892CE9A
	AB302B429A965DCA71C353544A33CF28B945C674728DF6634F7A5C971CBB6C85
	999C0B3D1F235FAE943F6F077ED133DE746721974C4A3F76EDCE7ADEB45F12E1
	0F042E5BCD0B662C05655A1DA9533B614197AF273125C698C7D91A9AC9339E41
	9945155E89C6D783F287AAFC9D19ED310D139BB19A46BDB9664FB6EECEC339BD
	F9EB1859C9A2F50E57EC189286EE7647E01870ABC3572BE5C35E12CC9FCF2370
	7C846041238F5FCB07DBE3AA5419E0E98AB08DCDBBC11B9FADFF416BB3B496B9
	7252BCECDBEE9C30E30E11F6AB724B9F4A92BD5A9EF5BDE0C62BD139235087C0
	0C8356DF71C0976F0C43F00CFE99A6D4E9748CEC74677726555539555836E382
	2AE7DDA9F350BE74801885FB37CA23D82C521BF7B3497BBA38922D0FC5C71977
	3BFFFE1D77D6A3F1A52AF0F556E05E334EB9B340AA850A302D6910F901845D0E
	672DF2A21917549896A485136D72A8797D4A5EC9C0554B392A958D668177106E
	75784484F72535FC4F154EF5849B3DEE0617B4BACE79DFDDAA3C2EC25BBD1EC7
	B27C52958D6134721AEBB132C63145EA167BD99C3FAEE09920FC343A8B24DE79
	1BCF9D7A83525B17582781820F0187543952D79CF204745DED31DBED762B3363
	6D6D8D5EB73B14F99493A495F3CAD7DD7993349EB893276BF6EAC8E2DA3A6BAA
	AC67A8AAA329175FE2EA451E860C3F6324C5C95C26C92DF5719FEC41AB10FA22
	90ABFD34B26E18602A3D5E6D94DB146018E2D98F480FAFACACD06AB5585E5E9E
	B96E1EBB69DC9DFC014FB8F351CF7850858302BB490AA5DD8C20B61C2A7396DD
	7801E75D8C3A64A95B777A71DC203CB94E0AA5C36374CAC6D44C816C91A67F1C
	76D82EF08C0AEB96DA0F632EA7684147C760147D11BB6C846B248AEAED223C23
	C29A19CF029D10FADE64332FCD18F08EAC017FCE9C1FF78C6782F22D81C3E69C
	97D42A5B67E9A7D2205109ECC2931679505EE9F592D67B06A96CCC4132B62C18
	C2BF51D5B9942A0B55558D3D805AF9B347F71CAD18E6E6FB6EBF6DE689CF7F61
	4F6FBD1B2B19569FF1AB40F87D4CC9B529C1D56CD6183B586F0851F43E5DF85A
	897F8808DD6E9756ABD5B9F7DE7B17AFBF61E77A76C5408EF897598B6A1F7053
	10B66516D0A22751F673404F49028845BF39CAD89A7942900BD9FE7A806703D4
	3A7D9E480849F6684E8565879F397C4D943F51E757EEBC62C6E56CFCAD0C3486
	91C90F31AF499DBD64001E09812FABB2D4EBF1D775CD7AABC54C7312E684F6CF
	8921797EEF298113AE7CBF677C45856FA29C413861354B9EAEA584AA7B506ECB
	B5D85FD43D8E6744BCD3984B3D1A024F78FC2FF96CF3497FE78D82A6E6353087
	BA57FBA1BBEFD9F33FFEAB7F75E8D2A54B3DE546D598FFFD633A2252CDCFCFAF
	6F01785650BDCDD1F27292B6818E2835CEFBEE9C20CBEBB8A1E25455DA68B356
	4E6AF2CCAA8D61E620AFF5EB26B830508A195C6F629319A8322D15CBC08FCDF8
	4381AF88707B8023061F89B0EA79C6B70F933B0AD16746847DAA3C0CDC23C23B
	75D2E45ACA5D7243F5D509B9DB6664A052479E55E1922B3FF09A3BDCB94B020F
	4B0B42920122AFEF2AC2518BBC1D8D452187BFC3EF7535DD76A74F9FFEF01FB9
	F41F02AFF3FFE3C71679EC4123C3F069DD1033ECE70EC953CC14D85F72C78DE4
	90AFCC3FCEB94A53E2E7467B0C1A6F86C3B1BA76548DA0916955D680671DDE77
	E3F1A07C47E1ACC1FB222CE02CFB40C1A493D1DE7977EE50659F088B31F28318
	791BD0AA62AE5160962B20EB9B79ECFE1D7298C6A9C5392A4978602A26918C8E
	A7BAF98A196BA274715C3D0DC1F3C1941211E1B3C77F26863DE03E47DCEB7E48
	3C4AA828D949BAF77168424519792379989A654436D6CDF9571BE56F6F44432F
	D75F38DFE61175634A9428CA519493B5B1DF9D43020F69A095D5357BB9C92364
	D0B116E143777ED2EB712C5326A73323A99FFB6D42CBDDECFF1B41364331DA40
	254ACF52596D9106E9241F222D20880EF3E13F7BFCE7E6B14BAE2BD435B45AA3
	1A5145DC7F74438DE66109F14E5EBA7970340F851B77138DEBFC49A5B012A246
	821A73B96FFA9408EFBBD3AE23F3A45A7795F3E5AE3B2B21B090413309A13F6B
	6BD21410BF82815FB9BC5286F74A9E19961882C8B8C32033E4C6E4F09F6412C8
	678F1BDAB093CC4FBAA98A596820C4E9F745ADB4E4A4CDF0B5BC4619150BD218
	3FDB1C073B1E1852D544CE0883F7DD5AF06CF0A5B97B6DBC965506ABD498D290
	DA2B735578815476A2013A95AF368994225789744F9A4632890C53041CD2AF35
	1F46A30499CDF3746DE20243F8C767DEFC536BD831C6D6EAEA2A6B6B6B2C2D2D
	D16EB71B35491874610F0C326D04DF303564D2069D24C4575515CBCBCBACACAC
	B0B4B4546DDFBE3D6CE5C2AEAFAF1363A4DD6E1342D814851ECC1B4B25315541
	32DFCE18430575276483A93739B0AEC6B0273D2F63AD8DD428DD93187D486EF7
	4A863DEE3D55955EAFB7E587ED6786FDFB7B2C5455B534353535DDE97462ABD5
	F20CCB6FD8D8E9E6DB98B0EECA9B70F4358B57E8743A12636C038B37DD7453DC
	CA85ED76BBD4754DABD5EA1BF6A49077B0F9B37A658E66D2BF9A8CBCE4CEFDDE
	C2E1E8E44A07DD6643F2C68BF11575161F4A1DEAFAEAF5C127CDF02AF7ACAA2A
	FDCC043F8586BD6DDBB6BF7DE49147A65BADD6C1B9B9B995AAAAA2BB4B8CB14F
	7F9B54FE2854CCDFF5A1AAD6ED765BCBCBCBD30F3DF4D05B9D4EE783AD5CD87F
	FECFFFBC16D1B39D4E672984E0573BD6667852CAE0D09B6C389BFDCD58FAC455
	E323E30F5FFF9DC3E8A671C718B7AFACAC7CFC99097E0A0DFBE1871F7EE3FBDF
	FFFEFFBA7DFBF6D6ECECAC87101CE88761D7D8B069B55A2222323D3D5DAB6ABD
	950B7BEBADB77E2C227FDC6E77A2AAFA27995775F5C0245B60D8C38D1EBF47C3
	6EADACACF43E33C16BF3F8FF060065A298973892FCE40000000049454E44AE42
	6082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="13" length_in_bytes="3880" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000001480000
	007A0806000000DDD1CA21000000097048597300002E2300002E230178A53F76
	00000A4F6943435050686F746F73686F70204943432070726F66696C65000078
	DA9D53675453E9163DF7DEF4424B8880944B6F5215082052428B801491262A21
	09104A8821A1D91551C1114545041BC8A088038E8E808C15512C0C8A0AD807E4
	21A28E83A3888ACAFBE17BA36BD6BCF7E6CDFEB5D73EE7ACF39DB3CF07C0080C
	9648335135800CA9421E11E083C7C4C6E1E42E40810A2470001008B3642173FD
	230100F87E3C3C2B22C007BE000178D30B0800C04D9BC0301C87FF0FEA42995C
	01808401C07491384B08801400407A8E42A600404601809D98265300A0040060
	CB6362E300502D0060277FE6D300809DF8997B01005B94211501A09100201365
	884400683B00ACCF568A450058300014664BC43900D82D00304957664800B0B7
	00C0CE100BB200080C00305188852900047B0060C8232378008499001446F257
	3CF12BAE10E72A00007899B23CB9243945815B082D710757572E1E28CE49172B
	14366102619A402EC27999193281340FE0F3CC0000A0911511E083F3FD78CE0E
	AECECE368EB60E5F2DEABF06FF226262E3FEE5CFAB70400000E1747ED1FE2C2F
	B31A803B06806DFEA225EE04685E0BA075F78B66B20F40B500A0E9DA57F370F8
	7E3C3C45A190B9D9D9E5E4E4D84AC4425B61CA577DFE67C25FC057FD6CF97E3C
	FCF7F5E0BEE22481325D814704F8E0C2CCF44CA51CCF92098462DCE68F47FCB7
	0BFFFC1DD322C44962B9582A14E35112718E449A8CF332A52289429229C525D2
	FF64E2DF2CFB033EDF3500B06A3E017B912DA85D6303F64B27105874C0E2F700
	00F2BB6FC1D4280803806883E1CF77FFEF3FFD47A02500806649927100005E44
	242E54CAB33FC708000044A0812AB0411BF4C1182CC0061CC105DCC10BFC6036
	844224C4C24210420A64801C726029AC82422886CDB01D2A602FD4401D34C051
	688693700E2EC255B80E3D700FFA61089EC128BC81090441C808136121DA8801
	628A58238E08179985F821C14804128B2420C9881451224B91354831528A5420
	55481DF23D720239875C46BA913BC8003282FC86BC47319481B2513DD40CB543
	B9A8371A8446A20BD06474319A8F16A09BD072B41A3D8C36A1E7D0AB680FDA8F
	3E43C730C0E8180733C46C302EC6C342B1382C099363CBB122AC0CABC61AB056
	AC03BB89F563CFB17704128145C0093604774220611E4148584C584ED848A820
	1C243411DA093709038451C2272293A84BB426BA11F9C4186232318758482C23
	D6128F132F107B8843C437241289433227B9900249B1A454D212D246D26E5223
	E92CA99B34481A2393C9DA646BB20739942C202BC885E49DE4C3E433E41BE421
	F25B0A9D624071A4F853E22852CA6A4A19E510E534E5066598324155A39A52DD
	A8A15411358F5A42ADA1B652AF5187A81334759A39CD8316494BA5ADA295D31A
	681768F769AFE874BA11DD951E4E97D057D2CBE947E897E803F4770C0D861583
	C7886728199B18071867197718AF984CA619D38B19C754303731EB98E7990F99
	6F55582AB62A7C1591CA0A954A9526951B2A2F54A9AAA6AADEAA0B55F355CB54
	8FA95E537DAE46553353E3A909D496AB55AA9D50EB531B5367A93BA887AA67A8
	6F543FA47E59FD890659C34CC34F43A451A0B15FE3BCC6200B6319B3782C216B
	0DAB86758135C426B1CDD97C762ABB98FD1DBB8B3DAAA9A13943334A3357B352
	F394663F07E39871F89C744E09E728A797F37E8ADE14EF29E2291BA6344CB931
	655C6BAA96979658AB48AB51AB47EBBD36AEEDA79DA6BD45BB59FB810E41C74A
	275C2747678FCE059DE753D953DDA70AA7164D3D3AF5AE2EAA6BA51BA1BB4477
	BF6EA7EE989EBE5E809E4C6FA7DE79BDE7FA1C7D2FFD54FD6DFAA7F5470C5806
	B30C2406DB0CCE183CC535716F3C1D2FC7DBF151435DC34043A561956197E184
	91B9D13CA3D5468D460F8C69C65CE324E36DC66DC6A326062621264B4DEA4DEE
	9A524DB9A629A63B4C3B4CC7CDCCCDA2CDD699359B3D31D732E79BE79BD79BDF
	B7605A785A2CB6A8B6B86549B2E45AA659EEB6BC6E855A3959A558555A5DB346
	AD9DAD25D6BBADBBA711A7B94E934EAB9ED667C3B0F1B6C9B6A9B719B0E5D806
	DBAEB66DB67D6167621767B7C5AEC3EE93BD937DBA7D8DFD3D070D87D90EAB1D
	5A1D7E73B472143A563ADE9ACE9CEE3F7DC5F496E92F6758CF10CFD833E3B613
	CB29C4699D539BD347671767B97383F3888B894B82CB2E973E2E9B1BC6DDC8BD
	E44A74F5715DE17AD2F59D9BB39BC2EDA8DBAFEE36EE69EE87DC9FCC349F299E
	593373D0C3C843E051E5D13F0B9F95306BDFAC7E4F434F8167B5E7232F632F91
	57ADD7B0B7A577AAF761EF173EF63E729FE33EE33C37DE32DE595FCC37C0B7C8
	B7CB4FC36F9E5F85DF437F23FF64FF7AFFD100A78025016703898141815B02FB
	F87A7C21BF8E3F3ADB65F6B2D9ED418CA0B94115418F82AD82E5C1AD2168C8EC
	90AD21F7E798CE91CE690E85507EE8D6D00761E6618BC37E0C2785878557863F
	8E7088581AD131973577D1DC4373DF44FA449644DE9B67314F39AF2D4A352A3E
	AA2E6A3CDA37BA34BA3FC62E6659CCD5589D58496C4B1C392E2AAE366E6CBEDF
	FCEDF387E29DE20BE37B17982FC85D7079A1CEC2F485A716A92E122C3A96404C
	884E3894F041102AA8168C25F21377258E0A79C21DC267222FD136D188D8435C
	2A1E4EF2482A4D7A92EC91BC357924C533A52CE5B98427A990BC4C0D4CDD9B3A
	9E169A76206D323D3ABD31839291907142AA214D93B667EA67E66676CBAC6585
	B2FEC56E8BB72F1E9507C96BB390AC05592D0AB642A6E8545A28D72A07B26765
	5766BFCD89CA3996AB9E2BCDEDCCB3CADB90379CEF9FFFED12C212E192B6A586
	4B572D1D58E6BDAC6A39B23C7179DB0AE315052B865606AC3CB88AB62A6DD54F
	ABED5797AE7EBD267A4D6B815EC1CA82C1B5016BEB0B550AE5857DEBDCD7ED5D
	4F582F59DFB561FA869D1B3E15898AAE14DB1797157FD828DC78E51B876FCABF
	99DC94B4A9ABC4B964CF66D266E9E6DE2D9E5B0E96AA97E6970E6E0DD9DAB40D
	DF56B4EDF5F645DB2F97CD28DBBB83B643B9A3BF3CB8BC65A7C9CECD3B3F54A4
	54F454FA5436EED2DDB561D7F86ED1EE1B7BBCF634ECD5DB5BBCF7FD3EC9BEDB
	5501554DD566D565FB49FBB3F73FAE89AAE9F896FB6D5DAD4E6D71EDC703D203
	FD07230EB6D7B9D4D51DD23D54528FD62BEB470EC71FBEFE9DEF772D0D360D55
	8D9CC6E223704479E4E9F709DFF71E0D3ADA768C7BACE107D31F761D671D2F6A
	429AF29A469B539AFB5B625BBA4FCC3ED1D6EADE7AFC47DB1F0F9C343C59794A
	F354C969DAE982D39367F2CF8C9D959D7D7E2EF9DC60DBA2B67BE763CEDF6A0F
	6FEFBA1074E1D245FF8BE73BBC3BCE5CF2B874F2B2DBE51357B8579AAF3A5F6D
	EA74EA3CFE93D34FC7BB9CBB9AAEB95C6BB9EE7ABDB57B66F7E91B9E37CEDDF4
	BD79F116FFD6D59E393DDDBDF37A6FF7C5F7F5DF16DD7E7227FDCECBBBD97727
	EEADBC4FBC5FF440ED41D943DD87D53F5BFEDCD8EFDC7F6AC077A0F3D1DC47F7
	068583CFFE91F58F0F43058F998FCB860D86EB9E383E3939E23F72FDE9FCA743
	CF64CF269E17FEA2FECBAE17162F7EF8D5EBD7CED198D1A197F29793BF6D7CA5
	FDEAC0EB19AFDBC6C2C61EBEC97833315EF456FBEDC177DC771DEFA3DF0F4FE4
	7C207F28FF68F9B1F553D0A7FB93199393FF040398F3FC63332DDB0000002063
	48524D00007A25000080830000F9FF000080E9000075300000EA6000003A9800
	00176F925FC546000004494944415478DAECDDDD71DA40148051AD8742E88016
	D401EA8456440794001DA8053A50279B2765620FD89808F6EF9C274F1E88E77A
	F7D302B60831C60EF8EC7ABDC6DD6E174CA2ED39068184CF1BFAEBBF0965BB73
	CC3690AEE0E6987A430BA539661748577073CC6D439B63BB73CC2690AEE0E698
	FB8636C7F6E6983C90AEE0E6F86E97CB256EB7DBD51ECF1CEB9D63B240BA829B
	63CA8DBD7C2D94E6985D205DC1CD31978D2D94E6F89D8F54FFF13CCFDD3CCFAB
	9DA2D6384995C81CCDD11C2B0CA485698EB9CEF1743A99A3F59847205F31D0E3
	F1D8EC6FBF9BA30D6E8E9504729AA655073A4DD3CDC7AC9D39DAE0B93B9D4E45
	CEF1A3868569439BA393B939BEC2A6848176DDED77C76C6673CC698ECF9CF45B
	7876D3F77DB173DC94B8306D68737CE766FEDF509A73B973DC94B888314727F3
	764E9429E7B8F12383754F94C258CF339C0F3F12703237478104104800810410
	4880C602F9E83B84004E9000AD07D2AF420002F9CD536B3746007297EC2F6996
	D71F97487A3D121048A10404522881B2657747F1BEEFBD46F9E4C505A8F404E9
	440938413E114A27CAC74FE060FD357082BC77A25CEBF32C6A796AED848DF527
	90FC70E1104A725C7FA5AF4781144AB0FE04D242E5B1D9F17B5FD75B2D274A81
	AC6471DE5B884249CA0B73E96FE408A413254E946F09E56F3E044D2049BA709F
	F9C07658EB44594A2805B2D185EBD7A5104A810484522001A11448A0FA50E6F2
	1AB94002598472B9EF42D7E5F31AB90FED02B209656E04124020010A0AA4BF54
	30C714F6FB7D1886C120CCD10912EE1986A1134A73CC2E90AEE0E6985A8C3108
	A539667D82B430CD31F5E6164A73CC329016A639E6BAC1C7713447A14C7F8274
	05374773344781B430CDD11CCDB1C0396E721B68D7755D08212E03EDBAAE3B9F
	CF0F3FC6E1700816A639E63247CA9EE3A69681DAD0E668839BE3DA428C31FBC1
	2E035D8CE368439B633673FC7783FF749305732E6B8E45DCCDE7EB95C7423347
	2773737482042773734C3847F78304277373748204F81D37AB00104800810410
	480081041048008104104800810410480081041048000412A0FC405EAF57B719
	0292CAEE7667B7C2B8DBEDDC5B0F6837908F9C188512682A90CF3C95164AA0EA
	40AEF11AA35002D505F272B9C4ED76BBDAE30925F00AC9DEC59EE7F9C7CFBEFD
	CD69D4BBDE403581144A40201384F2783C8A24507620A7695A3594D334DD7C4C
	80676C72FDC696483EF2668E28024D05F291500A23D074206F855218817728EE
	6E3EE20808248040020824804002082480400208240002092090000209209000
	B507B2EF7B3F0140200104F201FBFD3E0CC360FA8040DE330C43279480407E11
	630C420908E43791144A40208512284C8831BF8F900E217CFAA6CEE7F3DFAF7F
	FA48D8C3E110FC58816A03F95D28EF05521881A602792F94E3380A23F072457C
	ECEBF2FAE4BFA11446C0091220117F6A08209000020920900002092090000209
	20900002092090000209D0B43F000000FFFF0300DB60018B0BE0451E00000000
	49454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="14" length_in_bytes="23882" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000001480000
	00F40806000000F96BBF89000000097048597300002E2300002E230178A53F76
	00000A4F6943435050686F746F73686F70204943432070726F66696C65000078
	DA9D53675453E9163DF7DEF4424B8880944B6F5215082052428B801491262A21
	09104A8821A1D91551C1114545041BC8A088038E8E808C15512C0C8A0AD807E4
	21A28E83A3888ACAFBE17BA36BD6BCF7E6CDFEB5D73EE7ACF39DB3CF07C0080C
	9648335135800CA9421E11E083C7C4C6E1E42E40810A2470001008B3642173FD
	230100F87E3C3C2B22C007BE000178D30B0800C04D9BC0301C87FF0FEA42995C
	01808401C07491384B08801400407A8E42A600404601809D98265300A0040060
	CB6362E300502D0060277FE6D300809DF8997B01005B94211501A09100201365
	884400683B00ACCF568A450058300014664BC43900D82D00304957664800B0B7
	00C0CE100BB200080C00305188852900047B0060C8232378008499001446F257
	3CF12BAE10E72A00007899B23CB9243945815B082D710757572E1E28CE49172B
	14366102619A402EC27999193281340FE0F3CC0000A0911511E083F3FD78CE0E
	AECECE368EB60E5F2DEABF06FF226262E3FEE5CFAB70400000E1747ED1FE2C2F
	B31A803B06806DFEA225EE04685E0BA075F78B66B20F40B500A0E9DA57F370F8
	7E3C3C45A190B9D9D9E5E4E4D84AC4425B61CA577DFE67C25FC057FD6CF97E3C
	FCF7F5E0BEE22481325D814704F8E0C2CCF44CA51CCF92098462DCE68F47FCB7
	0BFFFC1DD322C44962B9582A14E35112718E449A8CF332A52289429229C525D2
	FF64E2DF2CFB033EDF3500B06A3E017B912DA85D6303F64B27105874C0E2F700
	00F2BB6FC1D4280803806883E1CF77FFEF3FFD47A02500806649927100005E44
	242E54CAB33FC708000044A0812AB0411BF4C1182CC0061CC105DCC10BFC6036
	844224C4C24210420A64801C726029AC82422886CDB01D2A602FD4401D34C051
	688693700E2EC255B80E3D700FFA61089EC128BC81090441C808136121DA8801
	628A58238E08179985F821C14804128B2420C9881451224B91354831528A5420
	55481DF23D720239875C46BA913BC8003282FC86BC47319481B2513DD40CB543
	B9A8371A8446A20BD06474319A8F16A09BD072B41A3D8C36A1E7D0AB680FDA8F
	3E43C730C0E8180733C46C302EC6C342B1382C099363CBB122AC0CABC61AB056
	AC03BB89F563CFB17704128145C0093604774220611E4148584C584ED848A820
	1C243411DA093709038451C2272293A84BB426BA11F9C4186232318758482C23
	D6128F132F107B8843C437241289433227B9900249B1A454D212D246D26E5223
	E92CA99B34481A2393C9DA646BB20739942C202BC885E49DE4C3E433E41BE421
	F25B0A9D624071A4F853E22852CA6A4A19E510E534E5066598324155A39A52DD
	A8A15411358F5A42ADA1B652AF5187A81334759A39CD8316494BA5ADA295D31A
	681768F769AFE874BA11DD951E4E97D057D2CBE947E897E803F4770C0D861583
	C7886728199B18071867197718AF984CA619D38B19C754303731EB98E7990F99
	6F55582AB62A7C1591CA0A954A9526951B2A2F54A9AAA6AADEAA0B55F355CB54
	8FA95E537DAE46553353E3A909D496AB55AA9D50EB531B5367A93BA887AA67A8
	6F543FA47E59FD890659C34CC34F43A451A0B15FE3BCC6200B6319B3782C216B
	0DAB86758135C426B1CDD97C762ABB98FD1DBB8B3DAAA9A13943334A3357B352
	F394663F07E39871F89C744E09E728A797F37E8ADE14EF29E2291BA6344CB931
	655C6BAA96979658AB48AB51AB47EBBD36AEEDA79DA6BD45BB59FB810E41C74A
	275C2747678FCE059DE753D953DDA70AA7164D3D3AF5AE2EAA6BA51BA1BB4477
	BF6EA7EE989EBE5E809E4C6FA7DE79BDE7FA1C7D2FFD54FD6DFAA7F5470C5806
	B30C2406DB0CCE183CC535716F3C1D2FC7DBF151435DC34043A561956197E184
	91B9D13CA3D5468D460F8C69C65CE324E36DC66DC6A326062621264B4DEA4DEE
	9A524DB9A629A63B4C3B4CC7CDCCCDA2CDD699359B3D31D732E79BE79BD79BDF
	B7605A785A2CB6A8B6B86549B2E45AA659EEB6BC6E855A3959A558555A5DB346
	AD9DAD25D6BBADBBA711A7B94E934EAB9ED667C3B0F1B6C9B6A9B719B0E5D806
	DBAEB66DB67D6167621767B7C5AEC3EE93BD937DBA7D8DFD3D070D87D90EAB1D
	5A1D7E73B472143A563ADE9ACE9CEE3F7DC5F496E92F6758CF10CFD833E3B613
	CB29C4699D539BD347671767B97383F3888B894B82CB2E973E2E9B1BC6DDC8BD
	E44A74F5715DE17AD2F59D9BB39BC2EDA8DBAFEE36EE69EE87DC9FCC349F299E
	593373D0C3C843E051E5D13F0B9F95306BDFAC7E4F434F8167B5E7232F632F91
	57ADD7B0B7A577AAF761EF173EF63E729FE33EE33C37DE32DE595FCC37C0B7C8
	B7CB4FC36F9E5F85DF437F23FF64FF7AFFD100A78025016703898141815B02FB
	F87A7C21BF8E3F3ADB65F6B2D9ED418CA0B94115418F82AD82E5C1AD2168C8EC
	90AD21F7E798CE91CE690E85507EE8D6D00761E6618BC37E0C2785878557863F
	8E7088581AD131973577D1DC4373DF44FA449644DE9B67314F39AF2D4A352A3E
	AA2E6A3CDA37BA34BA3FC62E6659CCD5589D58496C4B1C392E2AAE366E6CBEDF
	FCEDF387E29DE20BE37B17982FC85D7079A1CEC2F485A716A92E122C3A96404C
	884E3894F041102AA8168C25F21377258E0A79C21DC267222FD136D188D8435C
	2A1E4EF2482A4D7A92EC91BC357924C533A52CE5B98427A990BC4C0D4CDD9B3A
	9E169A76206D323D3ABD31839291907142AA214D93B667EA67E66676CBAC6585
	B2FEC56E8BB72F1E9507C96BB390AC05592D0AB642A6E8545A28D72A07B26765
	5766BFCD89CA3996AB9E2BCDEDCCB3CADB90379CEF9FFFED12C212E192B6A586
	4B572D1D58E6BDAC6A39B23C7179DB0AE315052B865606AC3CB88AB62A6DD54F
	ABED5797AE7EBD267A4D6B815EC1CA82C1B5016BEB0B550AE5857DEBDCD7ED5D
	4F582F59DFB561FA869D1B3E15898AAE14DB1797157FD828DC78E51B876FCABF
	99DC94B4A9ABC4B964CF66D266E9E6DE2D9E5B0E96AA97E6970E6E0DD9DAB40D
	DF56B4EDF5F645DB2F97CD28DBBB83B643B9A3BF3CB8BC65A7C9CECD3B3F54A4
	54F454FA5436EED2DDB561D7F86ED1EE1B7BBCF634ECD5DB5BBCF7FD3EC9BEDB
	5501554DD566D565FB49FBB3F73FAE89AAE9F896FB6D5DAD4E6D71EDC703D203
	FD07230EB6D7B9D4D51DD23D54528FD62BEB470EC71FBEFE9DEF772D0D360D55
	8D9CC6E223704479E4E9F709DFF71E0D3ADA768C7BACE107D31F761D671D2F6A
	429AF29A469B539AFB5B625BBA4FCC3ED1D6EADE7AFC47DB1F0F9C343C59794A
	F354C969DAE982D39367F2CF8C9D959D7D7E2EF9DC60DBA2B67BE763CEDF6A0F
	6FEFBA1074E1D245FF8BE73BBC3BCE5CF2B874F2B2DBE51357B8579AAF3A5F6D
	EA74EA3CFE93D34FC7BB9CBB9AAEB95C6BB9EE7ABDB57B66F7E91B9E37CEDDF4
	BD79F116FFD6D59E393DDDBDF37A6FF7C5F7F5DF16DD7E7227FDCECBBBD97727
	EEADBC4FBC5FF440ED41D943DD87D53F5BFEDCD8EFDC7F6AC077A0F3D1DC47F7
	068583CFFE91F58F0F43058F998FCB860D86EB9E383E3939E23F72FDE9FCA743
	CF64CF269E17FEA2FECBAE17162F7EF8D5EBD7CED198D1A197F29793BF6D7CA5
	FDEAC0EB19AFDBC6C2C61EBEC97833315EF456FBEDC177DC771DEFA3DF0F4FE4
	7C207F28FF68F9B1F553D0A7FB93199393FF040398F3FC63332DDB0000002063
	48524D00007A25000080830000F9FF000080E9000075300000EA6000003A9800
	00176F925FC5460000526B4944415478DAECBDDB931CD77927F83B79AB7B5755
	DFD14067371A0D80244012244112044989B2444AA399D53A34B1F646586B7B23
	BC613F8C23EC87799897D908FF03B311BB0FDC8879B062E50769C2922D599A18
	89BAD88448F0029216EF24AE09807DADAAAEAAAE6B5ECE3EE4A532B332EBD25D
	D55D059C5F04D075CDCAFCE539BFF37DDFF9CE7708A5140C0C0C0C0CEDE01805
	0C0C0C0C4C2019181818984032303030308164606060182284513A194551A200
	CE033801E00C8005EB710DC01700AE01B86EFD7D5B96E5FABD78531445F97300
	2F01C88EF8A91600FC5C96E5FFF78078C902F80BAB8D445D6FC5EEF17E5A733D
	AE037815C0CB7B6DFF1D78BC97B9ACF99EF7C42339EC596C45518E00F853007F
	55AFD7671B8D0628A59E7F004008F1FC8B46A38844229F027819C0F765595EBB
	0784F10CA5F48352A93456E79D4EA701E0AC2CCB1F0E919BE7344D7BB552A930
	B30640329904CFF3E76559BEC2781C1E8F8726908AA2BC08E07B954A65B6D96C
	C2300C701CD7268404807D867EE1B4BF2349121289C42680EFC8B2FC8B71BD59
	B76EDDA2E3268E2E91D400A48661D52B8A925555355FAD56598F6EEFDC93B22C
	17188FC3E1F1C05D6C45519E00F0C352A9246B9A064208388E832008A0944255
	55349A4D68AA8AA6AA42D5340080288A100501922842922488A2084110601806
	9ACD26EAF5FAAC288A3F5714E53D4B283F1CA79BA428CA9F8FAB380240B15814
	D2E9F48B007E3284C3FF0DEBD4EDD8DDDD453A9DFE2B00FF27E371383C0A0728
	005100BF2E97CB179ACDA6238A0050ABD7512A95502C96B053C8F766B14C4E22
	9B4E63229542341A05CFF3D0751DB95CEE5C2412F94051941FCAB2FCEFC7E83E
	7DEB1E686BDF1A9240BEC8BA71285EEA4320198F7DF2782002A928CA8A6118D7
	0A8502388E83288A2004289576F1C5FA3A8A3D8AA2C762C9E751CC9BDF4B6726
	7174E10852A9A46385E6F3F96F5BDEF9C298C427EF85E0F889313BEEBD8015C6
	E3F0781CBA402A8AF262BD5EFF79A55201CFF3E0791E956A156B6BEBC86D6F0D
	C6BDDBC9A3B893C7D4F434161616108FC5A0EB3AF2F93C1289C4178AA23C2FCB
	F225D606181818FAC150F3201545F9F372B9FCF36AB50A5110C0F31CD6D637F0
	C1FBEF0F4C1CDDC86D6FE3FDDFFD0EEB1B1B2D31AE5450A9545E5514E54FD8ED
	6660601809815414E5C572B9FCB2AAAA10451114C08D5B0A945B37877E51B76E
	DEC48D9BB74C135910D0683450A954FE565194E7D82DBFB7204912A2D1282382
	6128188A8BAD28CA4ABD5EFFB92D8EB55A0DD76EDC44A57C70B3B49B1BEBA8D5
	EB38B57AC2114951145F5514A5E7B48851802889B87BE72E6EDEBC85547A02D1
	68146DA959D44E85A270FF693DEC9CCA159EE9459DF70947108B463199C9201E
	8F8F0637A2881B376EE0CEDDBB989A9E86208800A5BEAB6D23239C131F8F3CC7
	23918863667A3AF41C6AB51A3EFDF453E806453A9B013568288F6DCF68C809D8
	B96D84201A8D209BC922954C0C95C79B376FB6F1E83D451A4229ED78B914143C
	CF2311EFCC2300EC148B28164BE038D2F59C6938BD2648585BA7E008C1E2B163
	8723908AA2440DC3B856A9542049125455C5AF7EFD1B245229C424F1403B50B9
	B883CFAF5DC7E99327C1F33C767777313939B909401C1781BC74E9B778F5D54B
	A8D5EA38FFD4794C670F6F71CD0E80B5BB77717471110BF3F387CECD2F5E7905
	6FBEF92634C3C0C58BCF22118D0CFC37B600ACADADE3C4CA0A1209EFC0F0C5DA
	1A7EFAB39FE1CE9D3B585A5AC2C367CE0CFCF78B0036D6D630333B87E525792C
	796CA81A4008BE585BC7EA8915244206D84C3A8D783CEE689B281E7E371D868B
	FDB342A1004110C0711C7EF9AB5FE29672EBC0C5D14669A700E5CE6D701C078E
	E390CFE7054551BE37F296A328E2D34F3FC32BAFFC12CD6613D168C41CD94700
	776FDF466167E750DDEAB7DE7E1BAF5EBA04835244231108023FBC36542EE3EA
	F5EB9ED7AAD52A7EF24FFF84B5B535489204291219EA356F6D6E606D63632C79
	8C880222028F72B98CABD7AE77FCACDBF05355F5DE72B1154539532E97BF62A7
	F2BCF9D65B78FDF21B38BEB272A817B9B1B68658348AB9D959504A51A954FE48
	5194FF2CCBF2F55115485555F1F6952BA0943AF9A26484CEEFEEDA3AB299CCA1
	FC76B3D9C4DB57DE812088E038738C8F08C34BC8888802CABBBBD8DCDEC6ECF4
	342449C2DB57AE607D6303D148049AB59861D8B8A32838323737D63C36EB356C
	6D6F07BADBB97C1E3B3B3B201CEFF19B8927FCD13D64D4FA94B912CFE938D474
	F90921583C7AB4270B75D06CFC4C5555489284CDCD4DFCFA37BF318919F2E8DA
	0B6EDEB88189D404A2D1081A8D061289C4DF0178665405B256AB2397CB39E2D8
	6BA338B0F3DB2D1F92652D607D7D03D56A153C7FB0C5A8EC5528CD66135B5B5B
	DE01EB806E4FA3D94444920672AC5C2EE7E5911E2C8F7E4C4D4E626A7272A4DA
	F9C00452519427CAE5B24C0801CFF3B8F2CE3BD8DDDDB596074A2371B11B9B9B
	585E92410841A552B9A028CACAA85A919AA6B65B26848081C02C68621CA83845
	041EBADEFACD46A301E2BE1F07746B745D1F5808A78D471CD43518A15E53C7EB
	B36A33F4DD625CF7C99E03937A1C64066941FE4C5555442211288A8277DF7BCF
	4CEF310C1823B2EFCDC6FA1AA6A7A79088C76D2BF267001E184519A09E1B6BDE
	56A68FED0DFE60A539FC1CC8B8F3480F8948178AA512F27973B59DC79DA6EE5E
	409D03F492A161A66010CFA1388E606971B127911C88402A8A72A452A9CC721C
	074A29DE78F34DD4EB75489204CD304622D86A636D6D0D274F9C002104B55AED
	B4A228D1F1A92BC9143270243938451989D3B817BC80204C4F4D617A6AEA9E74
	B1FF505555F03C8F42A1806B376EB8626740B3D118990BCEE772682C2E3A2E46
	2C16FB16801F8CB60230611CFD2ECFEED17EA1AA5658A9938740F71269229E2E
	44D0FBBCC8A004F2AF0DC3B0DCEBDBA855ABAD99574246CA8204CCB48D99E969
	349B4D00F8EBD116C89E0C1886C336E0C9E19FC25858E11D2EA252ADA25CDE05
	E1825D7FEA99D926C14E76C013EA19C0CC59EC63478F1E8C402A8A126D341A32
	C771D0751D376FDD8461189E3847A5B23B52ED7CA758C2CCF4B42DDE17EE8D1E
	CADCEBFB401FEFE97126934E236356A7EF8A4E293A24C0FFF2C78C1BA6717420
	16E4F946A3E11486506EDF06CFB7924D398E43B55AC54EB98C4C2A351A6EF6F6
	16B425191CC7A15EAF43519433A3596097320B725C06281684DC378FB55A0D75
	7776409725B0FD7408E24CEC9816647A62E2C0047281520A8EE350A95450AD56
	9DA4531BBAAE239FCB8F8C40DAF18E4824625BBB0B003E1CEB0ECA70B843191B
	BD06D0273554ABB5968B4D83C591BA7A03ED3A58518F8B7D180279C611C86AD5
	E35EB7AC48825C6E1B2BCB4BA37333340D916814D43CDF95F16842AC131E2AFB
	1D45909990FBE571622285A9A96C672ADD932D84DBF36F367A9C381E84409EA0
	D454E56AB50A5DD7DB4E86E378944AA59172B3D5A60A0E8066E6689E1D8F86C5
	3AD7E80E5DE3757308212327E9BBBBBBA854AB2EE1A31D2DC3A00ED169C28610
	E204256767660ED8C57609645000D5300CDCB8760D8F9D3B371237C34E2770B9
	D8636EC130B0016ABC7934772AA520C408B5CAA9FB6542BBA9E2BEFBD140D762
	771A45799EC7762E87ED42E1504B768D8BB74A98873D5683C4380E5EA376CEA9
	540AA93E3CCC7ECBA171A4B502A77980B3D8D708215F312845221177B66F0D22
	9F1082EBD7AE61F6E2B3309A879B3C2E5A4541AD09A52FC6C38D63385C538EC5
	2087C963B55A45AD5E6FD70E1ABCACD07699699FFC134230D9A391360881BC4E
	0801350C241209701C1738510398293FC562119F7CF4111E79F411D42B9543BB
	458228C08023E41FB046CBB01F7DA46CF8DA378F84E3C073BC6B00EC5CADBC6B
	D6150D1853697F03EC2004F20B42885970331A054708F40EE7CE711C14E516A6
	676630999E38B47B24088215E725636341C6248975AE10F0A2045D6D8E5A9F67
	3CF6D3BEA351C4FAD85FA8D764714F38811080D2034D14BF460801A514C9540A
	C9640AF9421EE0F950F396528AF77FF73B9C7BEC311C397204D503DCAB060022
	F104442B146025B57FC824E61E36EF06F60BA4A3DB3606A8014875E6F0F0782C
	164B28EF963DB3D85E4B90069C2FEDC9826CAD343CE0A58600DE8E46A3A856AB
	482692585E5EC2D6F69667354D9015A9AA0DBCFBEE3B50B587B1786CF1C00AB0
	D65415516A409224349B4D2412098C664D48E6B2F5DCB10919F206C63DDC1142
	C7BF5D10801C228FD168D4D48D6E97B887FA2DC4DF5E0ECAC59665B9AE28CA7B
	954AE51C4780E5E565BCF3EEBBA113352D91E4A1AB2ADE7BE71D542A159C3A75
	1A8D21AFD9AEAB1A3E7CFF7D7CE585176097661345F1F2E81A444C24832C3512
	60401C481E2219608F1D051E030BD01E1E8F9188844864B861245114A0AABD6F
	9131A8349F97398E7B59D375C88B8B482412A856AB5DDD0EC27100A5F8EC934F
	5029EFE281071F0437A40AC78552091F7EF02108019664199AA6D91587FECB08
	59490CBDF56E6FF1DA03737149B83E8EB363610D3487CDE3CE4E1125C7C5A6DE
	B187B69C6ED2E64277587EE873B3CD9C6D0EF2E2C16EFBFA0351145F565515E9
	741AA74E9EC45B57AEF4B47786BD45C39D3BB791CBE5B0BCBC84C51EE303BD60
	B756C7CD1B37B0B9B9815AAD86672F5E442A95B2760A8C02C08F475C0DACD009
	45ADD964133541FA44298C016D45D0459743DF38A88DBB86CDA37E003C86897C
	2693462C1645A7D86257F73860F782A02D170ED4829465B9A0288A92CFE76541
	10F0F4534FE1E34F3E41A3D1682B5C117A22828046A38E8F3FFE18B7EFDCC1D2
	D23266676721727B1BD14A952ABEF8E22ED6BEF8C269BC99741A4F9E3F0F4A29
	28A588C562EF8D6A35717F797F4DD3502E9510EBB2F9FAFDE0627BBD108B9B72
	19F1E8E16C0EC77104BBE5DDB1E331B08D95CB43D95FDCDBB6C3FBF4286CF037
	0C0B1200FE4892A457354DC391F9799C3B770E972E5DEAEB82EDBDABAB950A3E
	FAF0037CFE9988743A8DA9E9694C4E4E2119EB9C0290DF29623BB78D7C2E8F6A
	B5025DD7C1711C789E47A3D1C0638F3D8ED9D959673B0800DF1975CBD17ECC71
	1C6EDEBC89D9FB5D2003EC0B6A18B87EED1ACE9E79E8504C1F8EE3B1B35340AE
	58C2D421A6AEF518C649B9AF84BADD4FDD5C0E3C6C1EC3E471B752C1EEEE6EE0
	5A6C1A12D67092C469F09B34E007098023F3F3072B90B22C5F5214E5BD7C3E7F
	4E370C3CF5E493F8E0C30F512E953CDB2FF42A948059266D7B7B1B5B5B5B1044
	113CC743107873A37649826150349B0D349B4D1886014DD31C51B45D77C05C77
	3D393989F34F3C0E5DD7CD94A464F2F268D6800C6E456692FD0E3EFAE4539C7B
	EC31346BD5433DBD482271281DDB74B1BCE9289CC063636303C9540ACBF2E2F0
	AC890EED98528A8F3FFC100F3FF208D2C9E17133B01861108FFCC1F0C80BC119
	2EC944C213961345D135A1D25FA0D7FEB4E4CB955455B5AF258A83DE17FB3B91
	48E40355553199CDE2EB2FBE881FFEE84730A8016E0FF9036E91A386616D00D6
	44AD5603B5620DF66C9C7DCFFD8DD8300CF08280AFBFF81232990C1A8D861D7B
	FCF638584AEE57045EC0DD3BB7512A1571E4C81124924973307105B09DC641DB
	E332C1EF5367A425AECFB45EA3FE8F821A669AD483274FF6BD1E763F1045D19A
	4808E8743C8FAB9F7F8E5C6E1BF3F3479048245A156BA8DF12A13E0BC4FF5A3B
	4F9AA6221A4F607E76267004338B2FD770E5EDB73037378F7426034914CD704E
	088FE679113345C8B901AE4FBB0266D43073761F505544F7E98686F2483AF148
	DBADB6204BCE43653B8FAAC3E36CE8B9799F0B036F4387E5624396E50F1545F9
	61A150F8B6AAAA78E4E18791CFE7F1CAAF7E69DD94BD8F7E2D11ECFD18945268
	9A86975E7C1167CE3C64ED034C118FC7FF1F5996D7464C13EBDD7D1102411050
	D9DDC5A79F7CE2191CB0A771B6BBDBE3891B59BEAD4E2912B1187EEF852F1F7C
	FC91845F80200828168AC8E7F2309D1082400FAC07A6FCEF361A0DF084E0F173
	8F86EEB1C45959195FDCBD832FEEDE09AE47E0E2B165C879B7F76DDB610A8061
	5088A2888BCF5CE83B55259847D2D1523679CC81E348071EBBB7B6201E0542F0
	70801B5F2A9551DEDD45A7DD6869C0C0DE3EDAB9C8A5B4ED2D4208168F1D3D78
	81B46391D96CB6BCB3B323A8AA8AE79F7B0EB95C1E57DEB982482472602B0E28
	A568341A78F2FC93B8F8CC335055158661607272725396E5BF1C8F681B02F3D4
	EC586DAF8D72BFE2D8F629C3F06EAC7450D6A33520D00E67CEF11C389E43502D
	C1FD746E9EE73BB65DE2725D3B879488F711E9C033F19E8D7DCFF7238EB60515
	5A0FD2126F9347A98D274AFB6F6DBDF2383191C2C4446AA47AE1C0F3E6AD59E1
	D94422E1A40CFCDB6FFE1B9C3F7FDE11A961C38E473EFDD453F8C6D75F02A514
	AAAA62C22CB3FE00C6003CCF391653BFC9BCA4CF7FFD38FBF6B35EB313066D5D
	13D86117D24550DA23F3A44B10A3138F00C05BB16DD35A243D1E259CC7DEC5B1
	F55D42C87EC21A75B717D6E29174685EA42D7439081EA5030CCDEC07C3B020ED
	B49FF39148E4ED46A3015114F1FBDFFA16A62627F19B7FFE677792F6C0A1AA2A
	0441C44B2FFE1E9EB970C111C7783C0E4110CECAB25C18871B138DC5904CA5CC
	3D7E04CE0953B50DF50760C5FA3BB5410DA4D3E94349C9302845269D862409A8
	D5B4766BC4438B8F2357B8AF5F1E09807426038EE31089449049A7EDED3AF6CC
	633F831EA514114942329118C836CAB48D47AE030FED3CB67FB44F1E791EF05D
	47A96CBAD89C5DF91BEDA5CC68C0038FD74DEC559FBEEFB8E2CBDC01AFC50E13
	C92B8AA2FC2980BF6D341A1004012F7CF94B989A9CC4CF5F7905B95C0E822074
	5CB3DD0F745D87A669989E9AC24B2FBE84871E7AD0D9883C168B21168B7D6BA4
	67AD7D2B6962B1181E38750A5FDCBD6B0E26A19D1B4310CA109BD57A59D335AC
	AEAE5AB38C07B2E779CD1642C3303031318153ABE6620473C28DF4D5B9FBE551
	D334241309AC9E38E17845AB274FE28D37DF84AAAA1DDA70671E3B59BBFE279A
	DAC4EAEAA348EC4F20DB783CB97A126F07F1D845EF08090A5B74FE92C963D2C3
	A3C7C54EA530911A2D175B18E6C16559FEAEA2281F0882F076A552816118387B
	F62C8E2D2EE2ADB7DFC63BEFBC83929506C4B9DC977E4641DB9D4EA7D378FCF1
	C771FEF1C7914EA79DD49F8989090882705E96E52B1823D4AA553CF7ECB3B87D
	F72E3EFFEC33F03C6F7644DAB17EC980C4910676085DD3A1EB3A4E9F3EEDC475
	0F8A0EF78414C771F8EAD7BE8AB58D0DDCBE7307A220382E6F301DC17505BBF1
	684FF2F13C8F175E78010B0B0BCE664F4BB28C2F7FE9CBF8C52BBF40B3D90C88
	AD85F3186C7D057FCD302834CD5CC2FBA5E79F1F088F761D024208BEF6D5AF62
	3D8CC76EF1C61EDBA297C72F7B78DCBBA7A8797E6758D91484D2E12F24551425
	0B60736767472056105B10046C6C6EE2CDB7DEC6679F7E8252B9EC8CC6767CAB
	6D86D63A57C3309CBD6F262626F0C0E9D378F2FC79CCCCCC40D334689A064A29
	B2D96C19C0ECA8AE96F171F4BD62B1F847ED1D8AC3EB6F5CC6D5CF3FC7CECE4E
	2B864B3B4922DDA330865B3B1CC72193C960F5C4095CB87021F008E974FAD7B2
	2CFFDE10B879BDD1685CB03B3660CEB4964A255C7AED35DCB87103C56209941A
	5E7DA17EDBB03FA18C4422989999C1138F3F81932757DB06045114F1E9A79FE2
	CA3BEF607B7BDB2AE3DFABD5D8CD7234EFFDC4440AC79796F1F485A703DDEB74
	3ABD29CBF25CBF3CDAFDC9CBE34D148B45C0AA87407D1CFA1CDA1E38EC8D471B
	D55A0D956A0D1C71DF43DA36D639EBB17DFE36ED785ED433B93DE74B330AE3F1
	4004D22D02B55AED8F1AD6E6E0F6CCE4EEEE2EEEDCBD8B1B376FE2E64DF326D9
	22689BE2B6056577D4E5A5251C5F5EC6C2D1A34826124EAC915A857B63B1D87F
	9565F9FF18178B515194FFBB5AADFE87B0C62308029AAADA4A5BA0B46DE0E8F5
	79BB25DE5D540921F6EAA350A4D3E9A170AE28CADF379BCD6FBB3BB6D9263810
	C2A15EAFF7BCC7C85E108944422D1EBB6C1E80BEADA25E3C267B5144D8F5A5D3
	E9CBB22C3FD32F8FEE36616745D4EB0D3487B8154A271E0F1B613C0A077912B2
	2C7F475194FF1C8BC5FEAE52A95CB0D76AC762313CF8C00378F0810750ABD59C
	7F954A0595AAB96224114F20914820168F21168DDAC9DED054D571A723910812
	89C4AF01FCD108E63976C3CF799E0F15484DD3CCE0F56817661D56E18F570921
	DF76E7C2DA3BE001A627618B37ED7300E9F67955553B766AB7700D6BD2AA8BF8
	FF782F3CDA1CDAD7ABEB3A24498024895DF919068FA3DA760FD482F48D666700
	7CAF5EAF9FB305CE8E8F38B5EA5C71273BDE68179A705B969224211A8DBE07E0
	3B233E11D38D9377EBF5FAB9116F48612370CFAEDE1E4334AF6B9A76DA9D5ED4
	A95386FDEDD4B90F30A63A10249349F03C3FD96B6686C5E37B9AA6C97E6BBC17
	EE3A89A45F0CEF151E0F4D207D37ED5B00FE44D3B4AFD4EB7547046D41B4AD06
	F7BF68346A17BBFD2F007E3C0E71C61EB85801F077CD66F382CD81DDF8FCF769
	941A613A9DDE04F0C03053A8AC01F5BF524A2FF8F9E8B5638F3A8F7D720E007D
	4F3EBA7974E724EF87C37B99C7431748DFCD8B0258007002C00A80B300B20062
	3037D6FA00C07500D746739B8481F1F02280F3D6B5C3BAFE200495378A753874
	6CC0A79AB706A79F1C60FB781EC0990ED7D3899351E5B15FCE2FC9B2FCDD01F1
	D82B87F7258F2325900C0C0C0CA3048E51C0C0C0C0C004928181818109240303
	030313480606060626900C0C0C0C4C2019181818984032303030308164606060
	6002C9C0C0C0C00492818181E1BE40C77267562189BF80B92ED8BFCE32768F72
	52F33DAF037815C0CB7B2D88D181C7D83DDEBE6A8C47C6E338F318BA165B5194
	E7344D7BB552A9B061044E49A4BD544F613C321E198F63CA63A0402A8A925555
	355FB58AD53278C8ECABFE1EE391F1C8781C5F1EC362907FC3486CC7EEEE2E00
	FC551F5F613C321E198F63CC639840BEC8680BC54B7D7C96F1C878643C8E318F
	61027982F1158A953E3ECB78643C321EC7984796E6C3C0C0C0100226900C0C0C
	0C4C2019181818FA43CFFB62AF6F6E5A3BCC13D89BCCDBFBCD53504423114C66
	B381DF2D954AF8ECF3CF21882232990C9CDDD45C1946CE11A9EF7907D0B607F6
	530A9EE3108FC53135990DDDF07E6B7B1BD56A15846B1F2728A5E008C1E2B163
	4321FEEEDDBBB873F72EA6A6A721082240A9EF32DAC809E784FADE0BE2D5F59C
	C0DCC3393D318189546A6C1BAF288AB879F326E37104781404018978025393D9
	A19CE3871F7E886AAD8E4C36D3B5FF3B37D2962A42108D4690CD64914A268623
	90F3B3B37BBAB0AB57AFE27FFC8F9F63737B0B0F3EF8204E1C3F3E50E2AA4D35
	40585BDB542662719C3A790219737B470F66A6A70FA541FEE69FFF196FBEF926
	34C3C0C58BCF22110DDF705E350010EA6D0494761F58BA746E508017781C3D72
	04CBB23C961DFB17AFBCD2338FC3C4FA175F60666E8EF10860636B02278E1F47
	24C428E917854201FFF4D39FE2FAF5EB98999BC3938F3FBEA7E314016CACAD61
	66760ECB4BBDDF276198C4E77279FCD34F7F864A6517D18804519406FE1B7149
	ECF87EA556C3279F7D8EC71E79189148E4501BA22449F8ED6BAFE1D54B97208A
	22A291080481EF3CBA73308742E27E95F4F5BB9A4103C592520AE5F61D489284
	85F9F9B1E9D0413C1E96383ADEC8C606E31140A554C28D9BB7F0C0A9930339C7
	9FFDF7FF8E1B376E40124544A4FDDFE3ADCD0D44A2111C999B1B9C40AAAA8A8D
	AD2D978BEDED6E8661201A8D6176C66B91BDF7DE7B28958A8846A3D075FD501A
	41222A61B75EC7FAE6269616173DEFAD6D6CA052A98010CEBC2AE2B6D0290821
	583C7A14A2280EC6DAAD56F1F6957720082238CBAD277D8ADD9EE2281C718492
	58BF6A5F1FC711DCBD7D7BAC3A76B3D96CE37114C07834512EEEA0582A213D31
	B177F116457CF0D147B879EB162291482B2C3700DC5194C10AA4288A38B6B0D0
	F7896C6E6D81E779477508399C86C0110EBB95F61504BD923428148B4554AB55
	F03CB7576370804249ACF08CF95AB556433CD65EABA0A9AAA8D7EB0183A3D71E
	758D2DE00887582C0A4118BC83228A02D6D737DA791C1184F1386A18368FD56A
	AD4D20455184AAAAA8542AD07453F0049E4722116FFB3EE1386C6E6E42D37588
	4368478D66B3A73040CFBFACAA6AE0EB76AC2F6822A45AAD381DF030118F88D0
	342DF09A74C3703AB7FB5CED4E2F49830B0B341A0D506AF8F4E5E0F91138E2B1
	2601B4F1532C1671E59D77904A26F7FC3BD9A9692C1E3B3AB078943DA204F338
	1A086A67A389E1F218E431BE7EF9320AC5223201135A4BCBCB989D99719E1B86
	8146A3E139AD41F6945E3DDA9E04B2D96C627D73D312438F1F0A0A801A06E2F1
	18E67C13391E713C2431E866E19677774DF782523826AE755D1C47B0B4B83830
	910C1C2C0E6900B1AD49556FEF15DBDBDBF8FFBEF73D148A45FC4FDFFCE69E7F
	E3C6AD5BD8D8DCC4E3E71E452C1A1D5CD72604E38662A9046A189DEF37F50DD2
	D440341A457480DC1D188FBE637FFF07FF0DEFBEF71ECE3DF658A0407EFCD9E7
	28144B38BD7A22F0FC0E4B3E7A1248499220EF33DDE5B0F531A82D1CDD43D860
	60A087AA8F1D3BC9AF7FF31B6C6D6F23B90FEB110032C90476CABBF8E0FDF7F1
	E4934F0E95C751C767D7AE41D73457929C2D82E117A3691AE4638B5892170FAC
	3D0EBABF499284CB97DFC0BFBEFF3E229108043E7852322E892815F2D8CE6530
	3D353532B7BA2F179B7670B13942BA4E661CAE169040CBD8ED62FB678BED3CB7
	A1C68246C61A6AC52215451998D59C4925ADCEAE779DB1BF37107C3F9F7CEC31
	DC8F68369BB87EE306883D187768EFD5A68A9D6209D3535323E325F42C903BC5
	22826A47526BC6372249C8663263E7F6D46A35E766980184560881108263478F
	DED30DD876B56D547677D1683607DF51D426042176DF0883AAAA1E83215F28C0
	300CB3ADD1308B887AAC7A4A2962B11812F1F8580F14A572D909637592BDB824
	A2D96C1CE230B60F815C387224F0479A219337A3664306FDF2CCF4342449F424
	DEFB47AE6188C528BA854EF895D2F1E98363C4A372FB0E544D6BB52FCF4A151A
	784D9AAEE3D8C291E10B243D98FE46F7795A87A11E3D0B64A15008BE00EB468B
	82805887F486439FA309F8ED4AA582C28EEA1145DB82B4F304F793CBC5C060E3
	DC230FDF5F174CF6FAB5D19A80EB59201BCD66FB2CB6ED62530A43323A0AE428
	DEAF7ABD815ABD0642384B129940320C07F942A1A7596C7783A506453C1E437C
	2C5DEC2E26F65EDF1F55813C323717B8DCCD7625D40EAE361D01173B08535393
	6D93116D2E76A371FFF5660A8601E3F69DBBD074D3C5A6AE2A0BEEC77EDE355D
	C3D18585B114C8504BB09B3E8ED875F42C901BDBDBFE9C04E7861AD480248A48
	75A968326AB3D83BC5221AF53A4038CF45398174024FF22A03C35EF1E8C36799
	8BBDEFEF1DC2A28A9E8D0A4A43EB0B51DAA3D141466B92C6300C33CD87D090D3
	25F7676FBE4F2F7B98D8DCDAB65C6CAF7D41424AB01142601814C964625FAB99
	C6C6B21CD1C6D7B340CE75B1A4D4BE66B347A3D34F66B39044B14DDC3957DA4F
	7340B3D89224319518C46D1CD3416B737B0BBAA6FB12C5A9537A0EFED740A0EB
	1A16E6E7872290C3E791EC4DFEC8686967EFB3D83B3BA1292094023CCF754D47
	18B5A65D2A97D16C36431B0B2124B408F01E5BE5788C1FA31E831C171E5D38FB
	E0837D1DC7CEA11CAAE131441EC93DE29DF42C901CC75921481AE87EF31C3F76
	0D9BE338ABDA10693F453ADA1D91F9D5E3C5E3762E07C34A940E5F5DE89DCE34
	28452291403291B8879A13D9A70B3EA2026957E40EB3227B1AE90E732D76C08F
	2713092751BCCDF52004A0743889E2F7A156DEEFF27BF5FA0DB38FF813C5DDD5
	E1EDC7D67BAAA663654946F6F4A9D10F611D521F3E2C81AC01F04C49AFADAF3B
	37D03B5763A62A442222D213E98E9D838C58A7DFDECEA1EA5A6AE8F91CBD3F96
	1A32053B181E2F3C797ECF871C477124A13148D2B3934946A08DF66C41065576
	B167B629A8AB306E78BB2123B69426994C201A8D78EE0A196C48A06DA019E590
	C30863EC78F4C7B5D7373661183AD0EE64BB6D0DE7192104BA616022951AE462
	8543E791EC6B96E6E02D829E057220454F47AC1D77AAB3278A0254551B688721
	6E1E5832F67DC563B15C82AEE9FE8568AE90556B6DB6BD479BAEEB10057128AB
	B986CE23D9A3068C9846F42C90DBB99CCFBDB6DD6D024A0D44242970E7C04EA3
	EA01F7ACB69736B7B65ADBBEFA9779510A8E7090178F0DF41C08F36A87C2A318
	8D41ADD746F6944FAFAEF6BCB791DD4F0830DC18F810DB63785FDFEB240D1DAC
	07DAE3A17A16C8B02296BD82527A681B7785F191CD643CA373D0960BC3C45855
	CE1961504A475A1C012097CF5B1B4FB9CC351AB2DFB6B592CBA0069207388B3D
	D8F64806ECC51368FAC16F67D1B340068D7EFD048F09212897CAC0016F94D5E9
	7E0D6AB7C2BD8CA88423D0340DD57A03F143DEB274DC5CEC71E4B1502C9A2EB6
	4B0AFD7147FF735D374040862290C3E631DC32257D9D970D8EE3B05B2E8F8C40
	3AC15C7B27B25CBE001A14A8A014945208A288648744719EE7B1B1BE86D32757
	0F491FDB89CF170AA8D5EBE0AC1DFEFC1F21008E0C681B4F1210EAA18681EBD7
	AEE1EC99870E5F7802467A6A5014772B482747270F6FDC78B4F1E0A953CE7993
	D02F92032B9632741E7D0A69B7A746BDBEA7C37184A05EABE1EEDA3A8E1E39B8
	AD757BB6202752C97DB1440841B3D9C45B57AEE0C9279E38F086CB0794FB9FCC
	669D82BF92CF9AF45784DE235AB38684B89AA575D3051E1B1B1B48A652583E88
	7D47FA1AB939A89A8662B1380A0239C63C9AB8A9283074EFDECEC10647EB8161
	50A4D31383ACD47F603C06EDB34D386067A700743A36097F8910826B573F8728
	8A989D9E1ACA7DEA4B206D81B0ADC8FD0E253CCFA3B8B3837F79F512168E2E60
	229D862008DEFC4A5FF927778C26EC7DE26E6CCE6BADE6A76B3A1AAA86932B2B
	6D67278588E0A0DD6F12127FE1791E573FFF1CB9DC36E6E78F2091489825B12C
	EBDCDB6F6840B97EF76B413CC135A1D6FEBE3919656E019A713A22711AD1CD9B
	37201F5D181003FB83288A63C1635079B246A301DD2390ED2EB5F7544D173B9E
	187CA9B361F3A836554C4E4DE1C8DC9CA796012FF0585F5F47E1F87164432A7F
	B5B9FEBEF7344DC307EFFF0ED33333C864B29024A955A796B805C1A5022EB39D
	1A664AE203AA8A680FFB4D09BDA86C5355B1532CC2A0EE136E0910350C889284
	092B57D216546F7621756E80A6A9B871FD9AC7A5A043EA760404AAA661796909
	CF5D7CC6F3DED6F636AAB55A6BDB575F7B258460F1D8FE13C52549EA98F62008
	028A8522F2B93CCC8197F8FB6C90891188BECBDA530A8EE3F0C8C367C1719C27
	FD83E338EC96CA78E3ADB7F0D0D9B3481D72416473D3A7D1E7717676B6CDA078
	E0E4C98E33145CC896C0BAAE0F3C517CD83CD6EB7564D31378E4E1873D024940
	601806DEBD72058F3C7A0ED3D94CA8E674AA8F00506C6E6C60637DC3E18D7814
	9FB659C7F643C3A0104511179FB9D0532A9FD0CD7AB4ADAC99E969C7F5ECB9D1
	F873675C9B120982B8EF46497AFC146FAD8AF1C3BEA683E8D8CE281C72E61CCF
	81E3B97616DA1A25ED81F73E3B36094FA0E0051EB95C0E6FBCFE3A32992C12C9
	04388E6FB3A600024229A8B5449300A0C42C2967E806565757118BED7D7F6751
	14C79AC73B6B6BE6A65D7ECBD3495FF15B902677A95412135DEAAC8E1A8F3CCF
	7574BDEBF53ADE7AF30D64B39348A7D31044110414F5461373F93C569696BA39
	F09EDF20819710B624873AEE7F2F79CE61025977AB38A5744FA398D826829D33
	523B6DF4D3BF83463C8DF72067ACFD3CDAA3A7B730868B0B0F2D3E8E5C9E83F7
	BAFAE3B19B80DB2BA1388E736D600697D5AF6173730374A35505DBDCC5B37DBE
	92F8466C49146118F4BEE2D19F3253ADD6AC9534C142637E9E7ABC79C3D01189
	4863D81E0938D7CA3A7F3CD22C7C4391CB6D636B6BD379BDA9AA9044C1E13228
	8E193827DEB3387AE7447A091D0ABDDC744DD3502A9743D31228A51025EF2C76
	341AC5E4E4246EDEBA0541107A16C9C144AEBCDFD2751DD9AC19AF709BFCDBB9
	3CAAB5AAA7FEA37B64E706B816DBA01499741A9224A056D3DA2DDABE1A65FF3C
	76B27CA48884743A8D7ABD8E64328968348AB22F41D9ECFC42878649025E375D
	C4782281642A79DFF0A8AA2A244942BD5E77566B1DF6E4D141F2C8F33CB2990C
	745D87646D07DDCA0175B7270EEE15CABA6E606A72CAD98B3E93C9F8420F7D8A
	63C87D8A48129289444F465F689A8FDB7A140421D41DF58F94F6738EE370FAF4
	69FCEBEF7E07DAE6E20E738D989720C330B783585D3DD1F6C9E9A9490093C36C
	8735BB50AE6118989898C0A9D59378EBCA15ABE374E2A1D746897D71D96C3671
	E6CC1967C3B5482482D3A74EE2B5CB9711F3CCFC93AEE218D43E5555C5A993AB
	FB5DAAEAB4C771E1D1BEF64ECB590F0143E751559B989C9CC4D2F232745D07CF
	F33875F214DEBEF24E800E78FBA9288A387572159452341A0DAC1C3F8E4C2683
	62B1D4E601F6248E016D54539B585D7D14894108A46DE2DA5B13F8273288EFB1
	1DE4A79442D3349C3D7B06376EDEC0E5CB6F80E338703CEFBB84612C00A58E50
	EBBA59C1F9E2B317B1B2B232B0EAE0FD3648BB51701C87AF7EEDAB58DBD8C0ED
	3B77200A02388E74087C05A781D07D47CCCC7BAA691A8E1E3D8A175E78C1F3DE
	575E780177BFF8028AA280E779CB72746F07E0FFB996F54889FBF83A161717F1
	15DFF1EF171E2391084AA51226466767CCA1F168F7F968348A17BFF635643319
	D4EB75A8AA8A071E388D672E3C8DDFBEF6BA1386701B60F60ABB17BEF4254F3F
	9D999EC6577FEFF7F0937FFA291A8D060441704DE2049D0E09D573C3A0D0341D
	F2E222BEF4FCF33D13161A837413691814954A15FE5DD8A8CB5C9778BEADE20F
	A514FFF69BDFC4FCDC1C3EF8E043E4F379681D971B0E6E9A4610044C4D4DE2E1
	B30FE34C48E2EB4EB1887ABDE10B58B77A0E21C0DCECECBE623EF640633784C9
	6C167FFAC7FF1B2EBDF61A6EDCB88162B1044A0DEFFDA46D9BEBF6D1C1BBF348
	08C1C4C40496969670E1E9A7DBB6EB8DC7E3F8E3EF7C07AF5DBE8C6BD7AEA358
	2C9AA3BF6D397489F71042904EA7B1727C05CF5CB860564CDA67EC6C1C79B4BD
	8772B9EC9C7BD072BE4E33B63CCF83E3B8416DD9311C1E29108BC73137378BA7
	9E7A0ACB4B4BA8FB12C2FFCD37BE8163478FE2BD7FFD1DB67339C77A93240933
	D35338F7E8A33873E68CE73B8D66138F3CF208521369BCF5D65BD8DCDCB436D9
	EBC7720408E1303191C2F1A5653C7DE1E99EDD6B002041374C5194BF6F369BDF
	B689B46F160D2AEEE97A1CE46E9B33D6029ACD261A8D46E831829E87BDD68BAB
	CF711C44516C8B3BEE17E974FAB22CCBCFF4F259378FEE73E4790E8470CE08DB
	8A7F7A83F4AD7C2E841757ED81C7200E2549EA991BFBBE798A097719AABA1DFF
	7EE4711818051E2935730B239108388E43AD16BC2E3E1A8D3ABF61C6245BFD34
	128984AE1AB22753DCDFEB658019447B0CB3205F25847CDB49070810C9B0C7FE
	13B767C0398E433C1E0F1453FF770799F7358486FBE33E3EEBF0E8E6C39CD1D5
	1D010F1B643A75D0A0CFF77BADBD7E3E12890C83FB91E5B1DFF6D83CDCAAF323
	C323A534541C01385665504649A7259536FFFBCD44D94B7B0CB320B300DED334
	4DF68F3641E485FD0D22D3FDDEB8554A4E2693E0797E5296E5428F237616C0EB
	9AA69D76A72C746A7CDDB8DC8F20321E3B8B246B8F8C47FF7B81199DD607BF29
	08C2E530D7BA97BF866138FFEC11C63695C78DC4743A0D9EE7CFF7DA185D3CFE
	7B9BC75E078FA0BF8D46038D4603CD66D3F9378E386C1EFDEDB1D96CB2F6C878
	0CE591748AF1298A1205F03C80330082D69985E530C47C7F7BF95EA7756C87B9
	C62D0FE0922CCBDFDDEB017C3CA20F2E198F8C47C6E321F24858D15606060686
	60708C020606060626900C0C0C0C4C2019181818984032303030308164606060
	6002C9C0C0C0C004928181818109240303030313480606060626900C0C0C0CF7
	053AEE496355FFF80B00E7D1BECE32768F72E2AFD75407F02A80976559AEB326
	C3C070FF20742DB6A228CF699AF66AA552612CC12989745E96E52B8C0D0686FB
	58201545C9AAAA9AAF56AB8CA176919CECA7C4140303C3F8222C06F9374C1CDB
	B1BBBB0B007FC5986060B8BF05F245464D285E62143030DCDF02798251138A15
	460103C3FD2D900C0C0C0C4C2019050C0C0C0C4C2019181818FA82D0CF874551
	C4CD9B3771E7EE5D4C4D4F431044EF46E2BE47DE87E6135110118FC7313599BD
	A789B5364662E8009678CF704F09E42F5E79056FBEF92634C3C0C58BCF22110D
	DE505EA5963812EA1149F3310508412693C6EAF1154892784F11AA28CA0A80BF
	330CE38261181D3FDB69CBCD7EBED309F6F69EC33A4EB7F73B7DEFD6AD5B2084
	FC0CC077586E29C3D80AA42449F8ED6BAFE1D54B97208A22A2910804810FB734
	090002F3BFB6FE61BE50C817709DDCC403A74E0EEC622AD50AD4A6DAB933FBDE
	2321E2118D46118944FA15C7AC6118D7CAE5326B59BDE39BE9743AAF284A8C59
	940C632990CD66136F5F7907822082E3384B58C8BE7E581278948B3B28964A48
	4F4C0CE4623EFEE4536C6DE7C0F37CCB64F519B1A0D4F39C10B47D46559B38F3
	E04378F0F429349ACD7E4EE1AFFCE2188944C0F33C344D6BE394C144B158443A
	9DFE0B00FF170B550C275CC178DC1B8F3D09642E9743B55A05CF732D5799ECFF
	645483A25AADB509A4288A505515954A059A6EBAA902CF239188071EA7D16820
	1289E0FCE38FA3A9AA6DA746BBB97E6D1FA01045B15F710480B3EE27F1781CEB
	EBEBB871F31626A726C1713C006A856DBBBBD7D4179AA02EEE239284F9D959CF
	E737B7B7B1BEBE0E9EE7415D5F6EFF39EA1E2FE0BDA9016C516F8C9980A05707
	9D0498E9140047084EAD9E442A95B4078BF3BE0EFDE7005ED634CDB9576DFC50
	DA57C820EC33C3DE1B7E2FE187A0CFF83FEFE64551140DC09FC9B2FC5DC6E3E0
	78EC2A90A228A2D168805223D055DE0F2805745D6F7BFDF5CB97B1532C223531
	015D379CCE188F4571F4C8026667A63D9FB78F218AA2E516F7A6E0A18403A8D5
	F7E7ED45A351DCBC790B3FFC871FA15AADE2F9679F1D7883D9DADAC6C9D51388
	5AA180D9E969CC4E4F8FD588EDB2A463AE4EFD5CA3D17859D334088210D8B1DB
	3BB9E1B9E7D4305C4F89F9794A3DAFD98395DFBAE7380E8410DF6F50F8FB7F50
	FBA1943ADFA39482E338F03CDF73E7E6423A6F6047B7BC394A292A958A208AE2
	DF2A8AF2815D5065703C12A8AA3A16ED499244503A381E85BE959B06C7F2F63C
	22F88EF3FD1FFC37BCFBDE7B38F7D86348A752D02C61A60076772BF8F8B3CFB0
	532CE2D46AFB629FABD7AEA1542A3B610074B07368072B52D7351C999FC7CCCC
	CC1E6F92846AB58A9FFCF4A728ECEC203D911E4A63A8572BB87EF3161E3A7D6A
	841AA8D4D3404408413D7C10FA13DBE2B97DE72E1A8D862958F64DA2F03C76EC
	647FD6040D12B756888552D31A3E7A7401114902A5148220A0B0B38366A30141
	1060F4621559E3312104F1780CD14814866180E779ECEE5670E78BBBE66F1112
	F8BD8E1D19FE8EDD324E08010C4A9188C7B124CBD0340D9224FD29802B83E4D1
	D00D6433196432DE769CCBE7CD4C16DF3182725ADC422C8A22928944289D8542
	01BAC55F18D7A22020994C7ADEDAD8D844A1B8E30C7083E051D8BBB80DC2666E
	1D4792245CBEFC067EF7FEFB884422102C72EC0B2500C01370D42462329BC1F4
	D494E733D55A0DBB950A387728C073DF7C1681431B7588A700344DC7F494EAB8
	FAFD82E7796C6D6FA3542A421484A10A52A55444B3D9842449C8E5F3D8CEE5C1
	731CA8BF91060884ABF5FADE239E0FD0905004B13884C7FDF67F94B4EEB55B98
	380E0F9C3C09499282E2B131FBBE4E4F4DC2308CD629122B8EECBA28EA3B417F
	0883B6DD7B6FA715AC7B248A22DE79E71DFCF257BFC2E9D30F607A6AB2A77BD0
	D00D27B62D0A024EAC1CC7DCCC0C0C4A118944706C61A1A585218345CFD68EEF
	18C46A6FAEEBC906F138333DB5A7F6D568344001C74B01804AA5821FFEE847D0
	0D03671E7CB0AFE36986C9F9D4D4244EADAEB6BDFF2FFFF22F78FBCA159C79F8
	114CA63BCF4D4462713C72F68CF37C6E6E16131329871F3F8FD11E275DDD3CEE
	B9F78A03504891785DADEB376EB459962E09333B20010C42B1532C39026937F4
	074F9F1EA8F8ECC7AD68341A0766B569BA0EC98A79CEB8632A7DC73C5C0FFC9D
	32402303DD46EA7B9DB8FFB46735749BAC1204213066DBD94DA45D6363D41234
	625D07C77128140AF8E5AF7E854AA5D2B305D0D47544781E0DDD00A1148D6613
	37AF5F47369D86248AA01C81E8B2AADBAD48DA974006C5D3C840AC951011F289
	8A288A78FDF2657C7EF52A8EAFF45F9640E00834836263631313A914E6E7E69C
	F76EDFBE8D4BAFBD069EE37AE27F636B0B376EDDC2F1A5A5D688101B6C1D6F61
	6F1D68A0A157E751A96CBAC7A6EBE3355509A596CD62C6179ACD8313A0410694
	87C9602C1A452C3AB8C9CA207779AF41F3A0D76AB55AF74EB0B98946A3D9EA2F
	BE0923EA7715832C48EA7527285A314242088E1E3982882421B7BD8D7ABDEE89
	D775E5C8B2DE2296D7D2B0C299B57A1DD14804BBD52AEEDCBDEB71A75B5361DE
	47BED1C4777F89EBEDD663EA720D3B613B97DB338F866120934E23934E435555
	6C6E6D41144570646F0BF1048EC0E038545C25152392848DCD4D689A06311AEB
	89FF4C3281DD4AEB18EB1B1B28168BD664E86078140E5D487A789FBADB0E0D8A
	2798CF3FF8E823E4F3054F0C9286083D0D7A62FD98A669583DB182D5951534C7
	24380D00E57219452B064B43E24234C85A0C1AFF0226B5DD0E35A5FD845988E7
	B3F6778F1D3DDAF59B471716CCB8992BE9DEA03E57DE97BAD5AB05E9B1262935
	8F6B9FE81E0738E2EA70765CEB8153DE1831173A80B80493239EDE11360B6B4F
	26996108BA2F1E7BF69828EDA9EF761F5C49E03DA1A477FADD1F9B9F9BC3E2B1
	639E98D27E793C74810C6599B82EC2DD492DD10FCAC39C9B9D43369345E0DC8B
	AFF7D30E3FAF1B1493D9CC5889A379DE069ACDA6354084C72003DA7ABB808688
	6480A38D103F3B74F4764F5884C4209D0EB3532C42D374842D6175EE26F55D05
	0D9E20688B531282CCC484C75AA603F200EC89A8C2CE4E57C6DA986AB37EFC61
	8B96B44522114C4F4D755C35B51F1E0D6A201E8B21EAF64E28F63711D1253440
	F6A01FC55209B55ACD23BEFBE55118DDEEEE0FEE136BF5226D4BAEB33BC0CCF4
	5457B7B017979010A05E1F800B4F8715960871392C37E8201189482116637737
	BB56AB7514474208345583AAA93EEBBF433CD2A5FA1EB7B16D469B3A37BBEDFB
	FBE8FB926FE69552DAD3A28076BEBC1D9978ACA0D6FB9486CCF60E9047C33010
	D943BFEADABD49DF6F75361074DD65200C86C71170B149475F85A314861387B4
	2D4812D880ABD52A767676FA1EFDFD9FDFEB52C35130C3EBF5067C467788F147
	D1C92EF470D3E13BF62C67E7EF058B4E2F31CEB9B959CBFD313C8DB9930B4D0D
	EAE91734C002A6D4DBB18691E44CA98168348A95E5E596254E8207907E2766FC
	D0342DF41AF6CF230914F9FDD8D822E9B0168FF673F4D6E726B3591C999F1F28
	8F422FE2410FA66F8782B3473270AD3407D27ED19F5EBD8A5CDE4A73094CFD68
	77BF82D25E544DC583A74EE1F4A953FB5A12786006A4C5C5762E87CDAD6D67C5
	13A541D717900A437D0E366D73C403059676B86E12E89BDB013A03847038B97A
	02A9542A9063DB0AB8BBB6E68A8D91E0B869D759EC807640A919532504B33333
	1045B1B781BBAF8197C3EE6E195FACAF07842BFCFC918EAD25EC7C2828128904
	966539B0C30F8247C33030914A2165E71DD20128649703F4CABFFB53EB1B9B28
	964AE03832301E47D6C50EBA0C0E862594C12EF6638F3C0255D5DA1A62D7D14C
	0CAE2834B0F5D20734A13D3D35E5A43E8D0BBAB9D8D393934E4A4E6711A41E45
	ECE9F39668093CDF6E7D7164DF37DD304C0B523E76ACA3D742BB5990011362EE
	F77D7990813C4E66328763DDF41556E8DFC7761F637E6E16F373B303B0FCFB9C
	A4196ECA0AE99FFA0EE7934CC443259174BB3ED732B47ABD3E22CDE8FE86B942
	90B6C50ADB44B0CB4C76A068B69BCA036BF3EEAFB7ADC6A100219DE30FB4DB4A
	10970170902965836CD79D8B6E8D46AF19DD349F8EEC21D0C5BE7DE70ECAE5B2
	B9B692B64FC186A5FC10E2FD9CA6E9989F9FC3CC1ED7351FD6CDCDE5F2D8CAE7
	C013CE330BE971E85CEE749BEB4D11F0BDF05044DB5A39B71084550C21AD9534
	274F9C402A990C8E6F591C167676D0D4549740B4BBCF2420AE48036205D4FA8C
	BDD8CE5E6A38333DD57569DA5EC059B97E6BEBEB6DD901C45F4484F868729F3A
	710BA2B77B98A944092C2FC981676C5FD74EB1B4671E0D43472A9944369331DD
	74327C173B198FF52DB2EB9B9B28954A569ADB60781CDD349F8E5F21810DB856
	AFA35AAB3B7117EA8F37B62DA9F3350CEB355DD3A16ADA9E971ADAC4131C8CF5
	687782A9A9C9D08A471DADB40E5130D2253ED64FB278D0A44C27179BE3381C99
	9F6BB7FB287AB624BB3E8737304F60A64BE9BE02167B81611848C4E3387DB2BD
	E6696031059707437C991A3D4D2E0C91C766B3D9D617B4FD72D4A17394AB35A4
	E2FDAD8A999F9DC5D2E2A2A745EF97C7114EF3E93F6610B4B6733FD86F05136A
	058FCCFCB3831963A2D1832DFBE7173DD2A1F1114FFA0545AD56EF2AFA956AD5
	A9D644423C816EEE7468BCD23280A39188E77C0DC340A1504036BDF73AA5F612
	C0A6AAA2542AB50D485D2BB4B7A5A7040F3EF6FAEF6432D931B56A3F3C524ADB
	D631731C8752B104311A85BAC77014CF7181E7AB691A4AC52226A7A6A0D6AA5D
	AD741BF57A1DE572D9B74C767F3C8609640D40EA60A26AA47B030930CFC8A807
	F65C155E1A8D06B60B054C6787BB0F8FBD928670FE4CF9E06A36813982FEF7DC
	D6A37F563CC80CB53ED196E0EF79CD1C388E2F2D754C14B72D174DD3CDD4A5B0
	541CDA76F6DE996BEF7FADF75CB535DDFE16CFF3B875EB260C6A606E7E1E022F
	7893A8AD19704B3D3C09E9F6A4886E55D131747D4FA5F3DA139A433AB65510C3
	5FD966903C526A201A89B83C2A73ED7AAD56C35B6FBC89E5E3C7114F26416C2E
	1C4EBC611BEA6A6F9AA66162B7123AB85CBB76158D6613D9C92C38C2B906B5D6
	3DD5350D9C6B82B5D96CA256AFFB8A7BEC8F4761809A36D0785D2701E47D35EB
	EC637CFCE9672814F2CE5ACCB0E57608D82AC755040A9AAA61E5F871AC1C5FEE
	D78AAC055D1321049F7CFC314E9E3C85B999C1D76BB41B8F5D7B90E388C74A0A
	DD56CD2F22BE07C4C3CA5E1B08753808AA85D1C9C506806CE0ECABDF3D6CC536
	D18BE5E87BECAE494A2CF7D7300C5CBF760DB76EDEF4251E77BF173CC7E1C153
	273135652E5C70176408B5AEF79807693F0E5B6A38281E29A56D7D81E338E472
	DBC8E5B6C1F342E06819D67A1A8D06CE3FF1044EBBB65C71C21C844053555CBF
	FAB9554B930BD005B346E5C95327F1C4B97300808989094C0414DFDE0F8F3DE5
	41124286164B237B15E180F7E7666791CD64E03654DAC7C460ABC71397B416E7
	EFC7C5F6706675B88F3FFE0857AF4A9024D1B42E68A71A86ED4AEE177C831A10
	04012B2B2B8846A34824124874A8B33768442429B064F8208A55D86B63D73737
	A159A95B6DB24B43C21A410383DBEDB61F1BA6524F5B2BB07857709F23044410
	9CF5B9BDB6654A290C4B3C384250ABD5B0BEB1E92924D7EEDA063567DF041809
	B62E2935108FC7212F2E86F2BE5F1E0DC3403299403693316B4A72AD81D31446
	0A4A8DB6DCE34E221954289B73AD6421845895F1A993D06E5ABF2D160DC3F05C
	CBE6D69659F0867003E351E85BCDAC9B29466350EBB54353481290073999CD98
	BB24D25E7F377C3DE87ECA95998DD20E7A50CF0DD734CD125EDAB58E6167CBD7
	6C20A2283AD7DF6834CCF326DE346DDA36BDDBA9880775F8A508ED3DED4B71DD
	613DD2E57E59D6A9BF00AB5B3BEDC985A93EC312BD5A8DEEC71CC7C1300CCCCC
	CE221E4FA058DC09CD8DEDD65A5555C5F4F434262727A15979908BC78E0ECC7A
	0CB27C3AC43307C6A32DB4F1781C0B0B0BF8ECB3CFC073BC270324E851D0A060
	170559585870422C8D66130BF3F3902409BAA6B996FD85AF2FD7740D478E1C41
	241241A3D1C0ECCC0C66F758E43A0C7B72B129A58311C70E9248FA1424C05C6A
	582CAADD3EEC5DF5D516C1A5A006452C16DBD3BA6E1BE66C32815D44D6FE9F23
	C4CA71A36D560E0D10C43697C5A757A22822168B5B02D94461A7E89DC5F7C7E3
	6890451550AA8206A5CAB88E17268E2116847F6280908E02E95485D675C3B324
	AE27873F24FEE859A7ED7A2D22494E49AF6F7CE3EBF8F9CF7F8E6AB5DAD9E108
	68A394524C4F4FE3EB2FBD84783C0E5DD7611886B9B7912FD99B86C6DB030A7D
	74DA89D31A7813F1F8D078A430EB72F296483E7BF122F2F91CAE5FBBE11252DF
	204E105CA418004F081E7FEC313CFAC8239E10CBC2C202BEFA95AFE0B7AFBD66
	BD4EDCB68CF7EA09C1B907CFE1E233CF788C994AB5DA5AC5D5278F4105757B73
	B17DCF354D43A5DE08DD177B3FC168D22536D96924BE7EF316F28582C7550A14
	04CF08D96EC9A9AA8A53ABAB38B9BABAA7D534BAAE6366660693D92CD6D6D710
	91221D2DF2B091B6DB579ACD268E1F3FEEA4F64C4CA4CC8ACA0780B0C123CC42
	2201AF55C35DECBA7D9CDD4A059AA6BA0A2877E8E001930CEDE92BAE09036A80
	1002319B852008D0340D67CF9CC1F2D212F285020CCB0DA4EEDA6E34B8121485
	392B3B393989783C0E7BAB03555591CBE59DB6ED9F2C6B1562A19EFEE07FEE2E
	AEE1B7F8E3B11812F1B8CD7D61D03C5283229188434AA560180652C924FED73F
	F8436CE772A856AA9E0BA3415E0AF50ECE894402E990A22AE7CF9FC7430F3D84
	9D623150606D3F3B168B239BF5C65573B93CCABBBB201CD9338F7659389BC7AE
	B3D86D441280EA066E5CBB86B3671E1ABC8B6D91DDCF4A169BF8B30F3D385011
	D8EB5243BB48C137BEF175FCE34F7E827C3E6F2EFC0FB4E882DCECEE5624E138
	2C2C2CE06B5FFB5AD799E06160C8BFF77D4110FE83AEEB8149DCFDBA88DD1EDB
	C52AEC89886834EAD4AA0C5DBD4383C314865572CE89D3462266F2718FF9A27D
	BBD7B64767EEA30200DF1F068F866138B1585DD74100CCCECC80CCBA563BA1FD
	AFCD533FF1FC783C8E78BCFF7CDEA9A9494C59DB64749A9CE987C7EE2EB6535B
	8D7882A91B1B1B48A652589617F7D51302670809B0532C0058ECCB82EC64D9F4
	F25DF7FB7B5C6A58337F9F5845774FE07FFFE33FC6F51B3750AD565DBBCA05C5
	15C32B607B1C46EBBD443289132B2B48A5528E8B512C95902FEC588BF52DAB84
	524F3A4F2B0DC3F77B94B6B9A59E153781E7E4AFD24D5A1901146D2B17A8CF8D
	5C3D7E1CC9D64A1AC79C9465F992A2287F2808C27F82B9AF8AFD5E2C64300F42
	2CE4310044033E1B0BF2AEFADD12B5DF58750FAF75CAC676AE3D625A3CFF5196
	E54B8CC7C1F1D851204551B4F6EC6817309EE771F5F3CF91CB6D637EFE081289
	446BC7347FA70EEAE800D4A68AECD41416E6E73D71049EE7B1BEB68EC2F27164
	53A90EC2ED25E3EEDD2F502A975A09C95D0BBDD25017796E7616D3FD2F357C9B
	E3B83FB3CF47D33464B3593C353DAD01A81140B2CE82779D85105E9AAC95A81B
	34A26B9AE6E12D3D31D1B6C7F8A8C3656DBDEA7E5D96E51F00F80118F605C6E3
	FE207455E60ED696200828168AC8E7728ED5D216D7EF1012AED7EBC8A627F0E8
	C30F7B3A3AB1D262DEBD72058F3CFA68608275D0693554154D5533F3003D0617
	F5467D286D9BC420AEE79AA641D3F5BD2C35FC412412F9EB46A371DA16495DD7
	A1EBBA40294D75DBB8DDFDFA41BBCC8789743ABD09E0BBAC3B328C8D40DA3E7C
	683D48CB00E3780E1C2F21BC947FB848DA750B833EC3711CEAF53ADE7AF34D64
	B39348A7D31044110414F5661373F93C565CBB9901C0CAF2D240C9E9370F5296
	E582A228CF442291BF01F05C077725CCD5719EBB76678B867C2616763F7BD993
	65D0E8674DB6E5EE08D6DFEF03F84B5996EBAC3B328C8B40D6DD8DDBCC490A28
	BDE0F1527DB94FC46F49924037D79D1C6AAE80696D5E64EF7098CB6D636B6BB3
	655DA92A2461349791CBB25C00F097AC693130DCE32EB66D7D64D2694892805A
	4DB396FD74AAB8D82D6FA5F522CFF3C866B3D0751D9224219BC9B8562DB436FF
	E6790EEEED2274DDC0D4E49493206A0BF9D56BD751D869ED6A484397D2054F90
	D88696A6A9585E5AC2F1E5E5FBCAD5656060E84D206BEEB58913131338B97A12
	6F5FB962558B71295F97E4BD764BD2FC92AA3631393989255986AEEBE0791EA7
	4F9DC2DB57DEF1EC7AE787BD7AE4D4C955CF1AE47ABD8ED9D959649C35A7C16B
	8C69A7ED035CC5082626524C1C19189840860BA4EDE21242F0B5AF7E15EB1B1B
	B87DE70E4441F0EEFBD02DDEE8DB8253D33444A311BCF8B5AF219BCDA25EAF43
	55559C3D7B16CF5C781ABF7DED7567699E7B62C35EBFF9C297BE8495951547C0
	244942A552413422616A321BBC0A87843E69B76F291DBB2D5F191818060F1214
	C05714E5F546A371A1E5AA5208828052A9844BAFBD861B376EA2582C02D6D225
	A782954713832A8B9849A07373B378EAA9A7B0BCB414986FF8FEFBEFE3BD7FFD
	1D72B99C3351224A1266A6A770EED14771E6CC996055AFD59C150C9D76780B03
	C771CEBFB07CCA743ABD29CBF21C6B3A0C0CF7AF40FE7DB3D9FCB66D41FA05A4
	5E6F40559B014B895CC69967E9512B8D85E779442211A79E5C10A2D1A8239CCD
	66D3A98A2C8AA213773C2CA4D3E9CBB22C3FC39A0E03C3FDEB62BF4A08F9B65D
	29C49DA7674EA8089024313081B9534D3AFB31A5B463A92BB755E9B7E40E531C
	2DFC98351B0686FB03619540BF2B8AA262C71FED8A202DC16C099D5D2FCFFFD7
	FDCFFF1AA5B4EF7252A300ABDAF0CBACD93030DCC70269E5F27D531084CBFE78
	5ED8A2F4A0BF7E51B48B01D8FFC609E9741A3CCF9FB7B8616060B80F403AADB2
	5014250AE079006710BC72236C87A84EAB3DC2BED7690BB3D821729407704996
	65B6148E818109240303030343A88BCDC0C0C0C0C00492818181810924030303
	0313480606060626900C0C0C0C4C201918181898403230303030816460606060
	02C9C0C0C0C004928181818109240303030313480606060626900C0C0C0C0C4C
	20191818189840323030303081646060606002C9C0C0C0C00492818181810924
	0303030313480606060626900C0C0C0C4C2019181818984032303030DCBF10EC
	078AA2FC398097354D03210400E0DF33DBFDBC97FDB4C33E33ECBDB8EDF3EFF5
	F5B0CFF83FEFE64510040DC09FC9B2FC5DF7677AE1B152A9DC578D2C9148F4CD
	2303C32880504AA128CA738D46E3554DD320084260C76E174B03404B409ACDE6
	581210894400D7B585892200108E73B8505515A2284292A4F3B22C5FB1C4F1B9
	62B1F82A6B56FD239D4E3B3C32308C9A05F927B6C573FBCE5D341A0D10424061
	090785E7B1F9873A8F0DC340269346269DF61C7C3B9783288AA6C8041CC3F5C0
	79442985288A48FAAC0E1B9B5B5B10780184237D5DA828084826936DC72AECEC
	80E35A910602BF40C2190808010C4A9188C7B124CBD0340D9224FD2900BB63FF
	89FF778BA5120441748E1AC8A3DFBAA6802889884622A1D793CFE741380E1CE1
	FAE2716D7D1DA552D9127B6A5DAFFF2CBAB9069EB1317860E991C723F3F3F647
	DC3C32308C9440C6EC463E333DD5F741EA8D86A733D76A35FCE81FFE11D57A1D
	8F9E3DB3A7139BC86470FAE449CF317FFC939F2097CFE3C9279ED8D331A3F104
	1E3EF390F37C766606A964D2B10C9DCF7510A6805041D6F552ACE54657F10FFF
	F80FE04509279697F674BE73F347202F1E6B7BFD17BFF8053EFCE8233C7BF162
	DF3C4E66B39848A54C95A296DA11BF9C05C61EBA862C3A5ADF002449EAF40B59
	D61D19465520F705B7A0442211FCFA37BFC1279F7E0A5996F77CCCD2CE0EBE58
	5BC7C211D3C2B872E50A3EF8F0431C397264CFC7AC572BB8A5DCC692BCD852B4
	586C28C4FEF6B5DFE296721B274EACEEF9181BEB6B989848792CF3CF3EFF1C6F
	BCF966CFE7EDE7311289986105060686FE05723B9743A3D16C190CD4EBC051BF
	CB0DC0D00DA4D313C8A4D368341AD8DE365D6B8EDBDF2479AD5EF39C973B3EBA
	579477775D2EF636F2853C789EF7B987D6FFC4E52E9296D568BBD89D90B3C30B
	FBCC13A8566B1E81DCDADA8261187D71EBE6717D63C372B109DAFC728FEFDCEE
	7613E7A3DE472EA2FAE6D1E56233308CBE401E5D5830E38F86E1BCD6E87302C6
	14310AEC4FCB3ACE28EF15EE6E3F3B338DD99969E7B9DB050CFB6D420828A530
	0CA3C7D97832B0F3F5BDB1271EE7E7E6303F37C75A3E0343BF024929C54EB108
	4DD3BD3D9006745AD75C83611888C7A28846A3833DBB0189A257AE88C79AAC54
	2A20846BFB294F548EC063594522114C4F4DF5983634B8F3F59EC5DE782C964A
	A8D5EBE008B126EF6988A8D3B6DF213D0C04FDF238914AB15EC830FA02492905
	21049AAA41D5548F3806CEB4BA3AAAA11B8848E2806DA7B0EF0F4E34754D43B3
	D9B4DC556F4776776CF70C2CA5469B4BDE8FC00D6290E8378DD47D044DB5AE99
	90806402DA2690FD58A76DBF36401E19180EDD822484606E6ED672230D4F630E
	1348BBC306E7410E41220778C84C268339CBDDEC38031B20529AA60D3DE17D70
	E341EB2053539398C2246BF90C0CFD08A41DF4BFBBB6065555431D3A1A60C2E8
	BA81895412293BCF7040461E19828BEDC6E6F6360AF902389EEBD9F2A3A04824
	125896E5DECE6FC02EF67E79DCDCDA427977D74C6DA2AD7BE9099B3806645098
	C5EF4F74B636BBF1B8C0266918C6C9C59ECC640666AF90C17B970330205B4798
	9D9EC6ECF4F49E8FD5DD82A443E1A05F22DCC7989D99417A22DDFE7D9F208689
	7F975C4606867BD7C51E3D908371DB47D8476EB7C0EC154E64CFE7E0083B0540
	A8DB646C37187D2F361A8D8E563E1350867B5220ED86BE532CA1A9A9AE8ED91E
	6F24B693642F35A40652C92412F1B8A78391FD4FE10EDE65757D7F6B7B1B85C2
	0E08CF993AE1FA0D4283BF672E914B607949EE7A2A140390E341D45BF25DF36E
	A5E25A6F6FFEE799B3A6DE396CF71C0E71E5C2BA8FED3CED93473B819D8161E4
	5D6C8EE370647EAEAD9B7B3C49EA8B4159CFFD933404B0D285F6A30DEDF2A2EB
	DAC0C462667A1AC78E1E7575DCF0DC473F344DEB3ACF4B40A0EBC63E3908898F
	F63141E4E671667A1A33FB082B3030DCD71664A55A85AEEB1E2DF177C5B6596C
	832212913C5D98E33894CBA5FD89836FF28410826AA5BABF63BA56A0341A0D94
	CA651042DAF2F548881B49D12A7CD1D94226201C8762B108607120E76B9B6884
	10A8AA8AD26E0513C9445F3CD6EA7568AA161083A42EA33078E2A517AFA05F1E
	994BCE30160269A3D96C42D374B39601EDBC8AC371CCA85F20CDCED06834F0EE
	7BFF8AE3275690E93321B85CAD6177B7D2764C4DD3F0C65B6F435E929148245D
	9D9BB65C46D703F7ACBBA6EBE084D625ABAA8A5AAD16289008EBD8D44C70F657
	060A02CF11542ABBF8F4F3AB906519B148FF6250A956303599F508907D361FBC
	FF3E2E3E73A12F1E555545BDDE689BFCF1DEEBDEF320BB0964371E9940328C8D
	8B0D00D9C0596CBF9B6D367E7FBD48BF9BCD711CF2853CF26FE52108BCF3DDF6
	E25CEDDDB1D168E0FC134FE0F4C9D5B66396CB257CF0FEFBE6DAEC101FBAD517
	5BEB845555C5C9D55378E2B1C70000C9643254E8BA2D3BECBAD490B43EBFB5B9
	89ADAD4DF03CEFAC5E09FBDBD2738A7ABD81679FBD08F99859D1279148989F20
	0047086AB51A7EF1CA2F21087C2BA6D885C789548AAD5E6160D88B8B4D29C5FA
	E6A6E38211BFD14803A51386614ED264D369D41B0DCF2C2BCFF300050C83FA04
	A0FD80EE67BAAE83865838B6DB490D2330278F38213AD79A706AE66BBA5DD6ED
	5C0E3B3B45EB35DF940A09B68A2835108FC7212F2EF63009450010F082298CA6
	A88608A36B62C47E4DD775F01C874422E15421777E93983C701C074A8DB6D54D
	613C6EE772D8DDADB4D6CBFB3EEF597E485B7E02090CB5044D42F5C7235B17CE
	300E0259B32769A6B2FD95E5B33B2621C49C994C24303F37870F3FFC083CCF39
	C57211E8C079BB9DFDCC3EE6FCDC1C22910828A5989F9BC7BBEFBDE754F409B3
	1C3B9DA7AEEB38BA7004D16814F57A1DD35353989E9A1A249F35DBD29B9B9B83
	A2DCB6D6A7D3EE732A3E05320C0A41E071D49A4402CCAD1A8ECCCF83E779E8BA
	0E8E703DF3686308D7CCC070EF5B901C678A99AE1B9EA585BD44A2ACBD452070
	1C0CC3C0C5672E2297CBE3EAB5ABDE9C3B78AD939691E7B303390E8F3EF2081E
	7FEC3127EFEEC285A7B1B9BD85CF3EFD34C0B57515DD0A70AD4D01E7F0F8E30F
	E1E9A79F42BD5E77894EB5AD3A797B756CCF9B5D0BEA1200CF3FFB2C4A3B45DC
	BE7BB783C5E875A9DDEF89A28827CF5FC4CAF1E39E3D6C969797F1C20B2FE08D
	37DE3467F47BE4D1861963D65A3108DA39D4E1BF7E1A166FB40AEF0E92470686
	5111C8BADD98772B15689AEA34F68ED5635C7990C978021149826118482613F8
	C33FF85FB0BDBD8D6AADE6F6DD1C71A33E17CEFE0CB5ACD0B46FFB0600F8D6BF
	FB77283CFB2CAAB55AD7FC42FF8C693C164726E33D66BE5040A95436DD54C716
	F35D31F1D64DA4A088C7624E59380005D721EB3687D96C16BFFFFBFF33762B15
	730B0BDF71A92F7641DDDE2905262652C866B3811B7C5D7CE6193C76EE31944A
	458B4FD2338F956A15956AD565D9D3F67BE1BB2FC41716A1AE21C9CF5BBF3CBA
	528E0AAC3B328C1A9C4DBB344D7B55D775C792EC178661C0B06A48DACB16DDC7
	A27E81F4FD1D954DBFFCB3AAFE091A629DB36AEE470349929E9765F912008747
	B7A8754F0772A98F2BBD71D755D8F77E403A9D76786460182981B43AF71F00F8
	4F30F755B14B50C7C2E26C0188853C068068C0676341D66CBF5BCBF675B13DEC
	AB02A05326BAFBDA0B00FEA32CCB3F707F80F138181E1918464A201918181818
	BCE018050C0C0C0C4C20191818189840323030303081646060606002C9C0C0C0
	C004928181818109240303030313480606060626900C0C0C0C4C201918181898
	4032303030308164606060606002C9C0C0C0C004928181818109240303030313
	480606060626900C0C0C0C4C20191818184618FFFF0012DB2A34D454AFC30000
	000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="15" length_in_bytes="3923" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000014A0000
	0041080300000080471D40000000097048597300000B1300000B1301009A9C18
	00000A4F6943435050686F746F73686F70204943432070726F66696C65000078
	DA9D53675453E9163DF7DEF4424B8880944B6F5215082052428B801491262A21
	09104A8821A1D91551C1114545041BC8A088038E8E808C15512C0C8A0AD807E4
	21A28E83A3888ACAFBE17BA36BD6BCF7E6CDFEB5D73EE7ACF39DB3CF07C0080C
	9648335135800CA9421E11E083C7C4C6E1E42E40810A2470001008B3642173FD
	230100F87E3C3C2B22C007BE000178D30B0800C04D9BC0301C87FF0FEA42995C
	01808401C07491384B08801400407A8E42A600404601809D98265300A0040060
	CB6362E300502D0060277FE6D300809DF8997B01005B94211501A09100201365
	884400683B00ACCF568A450058300014664BC43900D82D00304957664800B0B7
	00C0CE100BB200080C00305188852900047B0060C8232378008499001446F257
	3CF12BAE10E72A00007899B23CB9243945815B082D710757572E1E28CE49172B
	14366102619A402EC27999193281340FE0F3CC0000A0911511E083F3FD78CE0E
	AECECE368EB60E5F2DEABF06FF226262E3FEE5CFAB70400000E1747ED1FE2C2F
	B31A803B06806DFEA225EE04685E0BA075F78B66B20F40B500A0E9DA57F370F8
	7E3C3C45A190B9D9D9E5E4E4D84AC4425B61CA577DFE67C25FC057FD6CF97E3C
	FCF7F5E0BEE22481325D814704F8E0C2CCF44CA51CCF92098462DCE68F47FCB7
	0BFFFC1DD322C44962B9582A14E35112718E449A8CF332A52289429229C525D2
	FF64E2DF2CFB033EDF3500B06A3E017B912DA85D6303F64B27105874C0E2F700
	00F2BB6FC1D4280803806883E1CF77FFEF3FFD47A02500806649927100005E44
	242E54CAB33FC708000044A0812AB0411BF4C1182CC0061CC105DCC10BFC6036
	844224C4C24210420A64801C726029AC82422886CDB01D2A602FD4401D34C051
	688693700E2EC255B80E3D700FFA61089EC128BC81090441C808136121DA8801
	628A58238E08179985F821C14804128B2420C9881451224B91354831528A5420
	55481DF23D720239875C46BA913BC8003282FC86BC47319481B2513DD40CB543
	B9A8371A8446A20BD06474319A8F16A09BD072B41A3D8C36A1E7D0AB680FDA8F
	3E43C730C0E8180733C46C302EC6C342B1382C099363CBB122AC0CABC61AB056
	AC03BB89F563CFB17704128145C0093604774220611E4148584C584ED848A820
	1C243411DA093709038451C2272293A84BB426BA11F9C4186232318758482C23
	D6128F132F107B8843C437241289433227B9900249B1A454D212D246D26E5223
	E92CA99B34481A2393C9DA646BB20739942C202BC885E49DE4C3E433E41BE421
	F25B0A9D624071A4F853E22852CA6A4A19E510E534E5066598324155A39A52DD
	A8A15411358F5A42ADA1B652AF5187A81334759A39CD8316494BA5ADA295D31A
	681768F769AFE874BA11DD951E4E97D057D2CBE947E897E803F4770C0D861583
	C7886728199B18071867197718AF984CA619D38B19C754303731EB98E7990F99
	6F55582AB62A7C1591CA0A954A9526951B2A2F54A9AAA6AADEAA0B55F355CB54
	8FA95E537DAE46553353E3A909D496AB55AA9D50EB531B5367A93BA887AA67A8
	6F543FA47E59FD890659C34CC34F43A451A0B15FE3BCC6200B6319B3782C216B
	0DAB86758135C426B1CDD97C762ABB98FD1DBB8B3DAAA9A13943334A3357B352
	F394663F07E39871F89C744E09E728A797F37E8ADE14EF29E2291BA6344CB931
	655C6BAA96979658AB48AB51AB47EBBD36AEEDA79DA6BD45BB59FB810E41C74A
	275C2747678FCE059DE753D953DDA70AA7164D3D3AF5AE2EAA6BA51BA1BB4477
	BF6EA7EE989EBE5E809E4C6FA7DE79BDE7FA1C7D2FFD54FD6DFAA7F5470C5806
	B30C2406DB0CCE183CC535716F3C1D2FC7DBF151435DC34043A561956197E184
	91B9D13CA3D5468D460F8C69C65CE324E36DC66DC6A326062621264B4DEA4DEE
	9A524DB9A629A63B4C3B4CC7CDCCCDA2CDD699359B3D31D732E79BE79BD79BDF
	B7605A785A2CB6A8B6B86549B2E45AA659EEB6BC6E855A3959A558555A5DB346
	AD9DAD25D6BBADBBA711A7B94E934EAB9ED667C3B0F1B6C9B6A9B719B0E5D806
	DBAEB66DB67D6167621767B7C5AEC3EE93BD937DBA7D8DFD3D070D87D90EAB1D
	5A1D7E73B472143A563ADE9ACE9CEE3F7DC5F496E92F6758CF10CFD833E3B613
	CB29C4699D539BD347671767B97383F3888B894B82CB2E973E2E9B1BC6DDC8BD
	E44A74F5715DE17AD2F59D9BB39BC2EDA8DBAFEE36EE69EE87DC9FCC349F299E
	593373D0C3C843E051E5D13F0B9F95306BDFAC7E4F434F8167B5E7232F632F91
	57ADD7B0B7A577AAF761EF173EF63E729FE33EE33C37DE32DE595FCC37C0B7C8
	B7CB4FC36F9E5F85DF437F23FF64FF7AFFD100A78025016703898141815B02FB
	F87A7C21BF8E3F3ADB65F6B2D9ED418CA0B94115418F82AD82E5C1AD2168C8EC
	90AD21F7E798CE91CE690E85507EE8D6D00761E6618BC37E0C2785878557863F
	8E7088581AD131973577D1DC4373DF44FA449644DE9B67314F39AF2D4A352A3E
	AA2E6A3CDA37BA34BA3FC62E6659CCD5589D58496C4B1C392E2AAE366E6CBEDF
	FCEDF387E29DE20BE37B17982FC85D7079A1CEC2F485A716A92E122C3A96404C
	884E3894F041102AA8168C25F21377258E0A79C21DC267222FD136D188D8435C
	2A1E4EF2482A4D7A92EC91BC357924C533A52CE5B98427A990BC4C0D4CDD9B3A
	9E169A76206D323D3ABD31839291907142AA214D93B667EA67E66676CBAC6585
	B2FEC56E8BB72F1E9507C96BB390AC05592D0AB642A6E8545A28D72A07B26765
	5766BFCD89CA3996AB9E2BCDEDCCB3CADB90379CEF9FFFED12C212E192B6A586
	4B572D1D58E6BDAC6A39B23C7179DB0AE315052B865606AC3CB88AB62A6DD54F
	ABED5797AE7EBD267A4D6B815EC1CA82C1B5016BEB0B550AE5857DEBDCD7ED5D
	4F582F59DFB561FA869D1B3E15898AAE14DB1797157FD828DC78E51B876FCABF
	99DC94B4A9ABC4B964CF66D266E9E6DE2D9E5B0E96AA97E6970E6E0DD9DAB40D
	DF56B4EDF5F645DB2F97CD28DBBB83B643B9A3BF3CB8BC65A7C9CECD3B3F54A4
	54F454FA5436EED2DDB561D7F86ED1EE1B7BBCF634ECD5DB5BBCF7FD3EC9BEDB
	5501554DD566D565FB49FBB3F73FAE89AAE9F896FB6D5DAD4E6D71EDC703D203
	FD07230EB6D7B9D4D51DD23D54528FD62BEB470EC71FBEFE9DEF772D0D360D55
	8D9CC6E223704479E4E9F709DFF71E0D3ADA768C7BACE107D31F761D671D2F6A
	429AF29A469B539AFB5B625BBA4FCC3ED1D6EADE7AFC47DB1F0F9C343C59794A
	F354C969DAE982D39367F2CF8C9D959D7D7E2EF9DC60DBA2B67BE763CEDF6A0F
	6FEFBA1074E1D245FF8BE73BBC3BCE5CF2B874F2B2DBE51357B8579AAF3A5F6D
	EA74EA3CFE93D34FC7BB9CBB9AAEB95C6BB9EE7ABDB57B66F7E91B9E37CEDDF4
	BD79F116FFD6D59E393DDDBDF37A6FF7C5F7F5DF16DD7E7227FDCECBBBD97727
	EEADBC4FBC5FF440ED41D943DD87D53F5BFEDCD8EFDC7F6AC077A0F3D1DC47F7
	068583CFFE91F58F0F43058F998FCB860D86EB9E383E3939E23F72FDE9FCA743
	CF64CF269E17FEA2FECBAE17162F7EF8D5EBD7CED198D1A197F29793BF6D7CA5
	FDEAC0EB19AFDBC6C2C61EBEC97833315EF456FBEDC177DC771DEFA3DF0F4FE4
	7C207F28FF68F9B1F553D0A7FB93199393FF040398F3FC63332DDB0000002063
	48524D00007A25000080830000F9FF000080E9000075300000EA6000003A9800
	00176F925FC54600000300504C5445FF00000000006E6E6E7272727575757777
	777878787A7A7A7B7B7B7D7D7D7E7E7E8080808181818383838585858989898F
	8F8F919191949494969696C2C2C2D4D4D4D6D6D6D7D7D7D8D8D8878787797979
	B6B6B68686866363636B6B6BD2D2D27676766C6C6C8484848A8A8A8282826F6F
	6FA6A6A6A8A8A8B0B0B0B2B2B27C7C7C717171C8C8C8CBCBCBCCCCCCCFCFCF64
	64648888887373736969699E9E9EC6C6C6D1D1D16A6A6AAAAAAAABABABAFAFAF
	7070708C8C8CB3B3B3B4B4B4B5B5B5A9A9A9B9B9B9BBBBBBBDBDBDBEBEBEBFBF
	BF6767678E8E8EC7C7C77F7F7FC9C9C9909090686868929292CDCDCD6D6D6D95
	9595656565989898D3D3D3999999D5D5D59B9B9BD9D9D9DADADADBDBDB616161
	8B8B8B626262C4C4C4939393B1B1B1DDDDDD9A9A9AB8B8B8DCDCDCA2A2A2C3C3
	C3CACACA9C9C9CC5C5C5C0C0C0C1C1C1747474B7B7B7D0D0D09D9D9D666666AD
	ADADACACACA4A4A4A5A5A5979797A7A7A7CECECEDEDEDE9F9F9F8D8D8DBABABA
	AEAEAEA3A3A3BCBCBCA0A0A0A1A1A1606060DFDFDF8282828383838484848585
	858686868787878888888989898A8A8A8B8B8B8C8C8C8D8D8D8E8E8E8F8F8F90
	90909191919292929393939494949595959696969797979898989999999A9A9A
	9B9B9B9C9C9C9D9D9D9E9E9E9F9F9FA0A0A0A1A1A1A2A2A2A3A3A3A4A4A4A5A5
	A5A6A6A6A7A7A7A8A8A8A9A9A9AAAAAAABABABACACACADADADAEAEAEAFAFAFB0
	B0B0B1B1B1B2B2B2B3B3B3B4B4B4B5B5B5B6B6B6B7B7B7B8B8B8B9B9B9BABABA
	BBBBBBBCBCBCBDBDBDBEBEBEBFBFBFC0C0C0C1C1C1C2C2C2C3C3C3C4C4C4C5C5
	C5C6C6C6C7C7C7C8C8C8C9C9C9CACACACBCBCBCCCCCCCDCDCDCECECECFCFCFD0
	D0D0D1D1D1D2D2D2D3D3D3D4D4D4D5D5D5D6D6D6D7D7D7D8D8D8D9D9D9DADADA
	DBDBDBDCDCDCDDDDDDDEDEDEDFDFDFE0E0E0E1E1E1E2E2E2E3E3E3E4E4E4E5E5
	E5E6E6E6E7E7E7E8E8E8E9E9E9EAEAEAEBEBEBECECECEDEDEDEEEEEEEFEFEFF0
	F0F0F1F1F1F2F2F2F3F3F3F4F4F4F5F5F5F6F6F6F7F7F7F8F8F8F9F9F9FAFAFA
	FBFBFBFCFCFCFDFDFDFEFEFEFFFFFFE33352F20000000174524E530040E6D866
	0000015B4944415478DAEC9CD10E83200C0091FFFF66D8CB4C8C8A968294EAF5
	C1C4A50D7833BD84C19640748A05048FA2DC7D98833AA9CB7797F565D2817387
	499EA34CDBBB58402949BA2B9344CCFAB2F27C933C5738DA05CA75B44B943749
	13A28C697F052528BF88925EE905650C2189AE2B4A71C1A6AC1565CD68BC95E5
	DC983CF4CACA59DAF44A5082128363705082128397CA06AE0CA9B5239CA435CA
	1C4645034AD92441296806CD2847F44A0394F5DA012528E74149AF443BA0C4E0
	F44AB4034A0C8E7640094A0C8E7640094A0C8E7640094A0C8E763E86F2B0171F
	94DA5E7978107A6523CA7F1228413983C16B50A21D094A51AF0425283138DA01
	656F9492A7C9C1D5FE4A23834BA265FBAEE506EAC1DA012528E7337825135747
	A0066B0794A0C4E0EFD44EF5C16E6599C579700CEED2E0FE504EAB1D50821283
	BB33F8E512CB79D2C34B3CA6FFC9D6F03B38A10950768B1F000000FFFF0300DC
	60DB6FF5A4BAD20000000049454E44AE426082
	]]>
</GDLPict>

<Copyright SectVersion="1" SectionFlags="0" SubIdent="0">
	<Author>GRAPHISOFT</Author>
	<License>
		<Type>CC BY-ND</Type>
		<Version>3.0</Version>
	</License>
</Copyright>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_FWM SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
actualGUID = FROM_GUID

! ==============================================================================
! Subroutines
! ==============================================================================

	_autoID		= "787849A5-D900-492C-9574-09F97D785966"
	_startID	= "38B8A9DB-22C3-4F07-A0D3-E9DB2A056A95"
	_endID		= "99EC7C33-79D8-4288-BC4A-431867BFA2E5"
gosub "newparameters_FWM"

! ==============================================================================
! Set migration GUID
! ==============================================================================

setmigrationguid actualGUID

! ==============================================================================
end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! en
! ==============================================================================


! ==============================================================================
! newparameters_FontSize
! ==============================================================================
"newparameters_FWM":
	if actualGuid = _startID | actualGuid = _autoID then
		bHas = DELETED_PAR_VALUE("fontSizeMM", _fontSizeMM)
		
		fontSize = _fontSizeMM / 100
		parameters fontSize = fontSize

		bHas = DELETED_PAR_VALUE("textPen", _textPen)

		penText = _textPen
		parameters penText = penText

		actualGuid = _endID
	endif
return

]]>
</Script_FWM>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_BWM SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
targetGUID = TO_GUID

! ==============================================================================
! Subroutines
! ==============================================================================

gosub "newparameters_BWM"

! ==============================================================================
! Set migration GUID
! ==============================================================================

setmigrationguid targetGuid

! ==============================================================================
end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! en
! ==============================================================================


! ==============================================================================
! newparameters_FontSize
! ==============================================================================
"newparameters_BWM":
	if targetGUID # "" then
	
		newparameter "fontSizeMM", "RealNum"
		newparameter "fontSizePoint", "RealNum"
		
		fontSizeMM		= fontSize * 100
		fontSizePoint	= fontSize * 7200 / 25.4
		
		parameters 	fontSizeMM		= fontSizeMM,
					fontSizePoint	= fontSizePoint

		newparameter "textPen", "PenColor"

		textPen 		= penText

		parameters textPen 			= textPen
	endif
return

]]>
</Script_BWM>

<MigrationTable SectVersion="1" SectionFlags="0" SubIdent="0">
	<MigrationTableElement>
		<MainGUID>787849A5-D900-492C-9574-09F97D785966</MainGUID>
		<Version>19</Version>
		<Name><![CDATA[""]]></Name>
		<AutoMigration>false</AutoMigration>
	</MigrationTableElement>
	<MigrationTableElement>
		<MainGUID>38B8A9DB-22C3-4F07-A0D3-E9DB2A056A95</MainGUID>
		<Version>0</Version>
		<Name><![CDATA[""]]></Name>
		<AutoMigration>false</AutoMigration>
	</MigrationTableElement>
</MigrationTable>

</Symbol>
