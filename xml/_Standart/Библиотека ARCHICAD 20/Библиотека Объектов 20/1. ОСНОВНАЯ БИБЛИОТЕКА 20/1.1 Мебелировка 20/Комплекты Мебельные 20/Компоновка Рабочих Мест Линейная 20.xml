<?xml version="1.0" encoding="UTF-8"?>
<Symbol IsArchivable="true" IsPlaceable="true" MainGUID="E3576C80-076D-44A4-8CF4-D4C7FCB7264B" MigrationValue="Normal" Owner="1196638531" Signature="1196644685" Version="38">
<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_3D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
if gs_detlevel_3D_m = 0 then end

unID = 1
centerunID = 30000

if iLayoutType = LAYOUT_WAVE then
	rotz axisAngle
		hotspot 0, 0, 0, unID, lengthRight, 1 + 128, totalLength:		unID = unID + 1
		hotspot -1, 0, 0, unID, lengthRight, 3, totalLength:			unID = unID + 1
		hotspot lengthRight, 0, 0, unID, lengthRight, 2, totalLength:	unID = unID + 1

		hotspot 0, 0, 0, unID, lengthLeft, 1 + 128, totalLength:		unID = unID + 1
		hotspot 1, 0, 0, unID, lengthLeft, 3, totalLength:				unID = unID + 1
		hotspot -lengthLeft, 0, 0, unID, lengthLeft, 2, totalLength:	unID = unID + 1
	del 1
else
	hotspot 0, 0, 0, unID, totalLength, 1 + 256:		unID = unID + 1
	hotspot -1, 0, 0, unID, totalLength, 3:				unID = unID + 1
	hotspot totalLength, 0, 0, unID, totalLength, 2:	unID = unID + 1
endif

if iLayoutType = LAYOUT_WAVE then
	firstLengthStep	= -partitionFrameThk / COS(diagonalAngle) * (bEndPartitions1) + (tableLength2 / 2) / SIN(diagonalAngle)\
					+ partitionFrameThk / SIN(diagonalAngle) * (bFrontPartitions or bEndPartitions1)

	if (iPartitionPos = PARPOS_ABOVE_D) or NOT(bShowPartitionParams) then
		add -lengthLeft, 0, 0
	else
		add -lengthLeft + firstLengthStep * NOT(bDeskNumLeftIsEven), 0, 0
	endif

	rotz totalAngle
	add xPosSideCorner / 2, -yPosSideCorner / 2, 0

	if (iPartitionPos = PARPOS_ABOVE_D) or NOT(bShowPartitionParams) then
		add deskDist / 2 * NOT(bDeskNumLeftIsEven), -deskDist2 / 2 * NOT(bDeskNumLeftIsEven), 0
	else
		pthkDB	= TAN(totalAngle) * partitionFrameThk
		yy		= COS(totalAngle) * (partitionFrameThk - pthkDB)
		add	INT(deskNumberLeft / 2) * (yy / SIN(totalAngle)) * NOT(bDeskNumLeftIsEven) * bFrontPartitions,
				deskNumberLeft / 2 * (yy / COS(totalAngle)) * bDeskNumLeftIsEven * bFrontPartitions, 0
	endif
endif

! ======================================================================
! Desks (with Front Panel, Desk Cabinet, Chair, Keyboard, LCD Monitor)
! ======================================================================

if iLayoutType = LAYOUT_STRAIGHT then
	if iPartitionPos = PARPOS_BETW_D then add partitionFrameThk * bEndPartitions1, (partitionFrameThk / 2 + partitionFrameThk / 2 * NOT(bDoubleRow)) * bFrontPartitions, 0

	for iDe = 1 to deskNumberInRow
		for iRow = 1 to 1 + bDoubleRow

			bMirroredComputer	= (iRow = 2) * (iArrangement = ARRANGE_MIRR)
			gosub "desk"

			mul 1 - 2 * (iArrangement = ARRANGE_ROT), -1, 1
			add (partitionFrameThk * (iPartitionPos = PARPOS_BETW_D) * bDoubleRow * bSidePartitions - deskDist) * (iArrangement = ARRANGE_ROT), partitionFrameThk * (iPartitionPos = PARPOS_BETW_D) * bDoubleRow * bFrontPartitions, 0
		next iRow
		del (1 + bDoubleRow) * 2

		add deskDist, 0, 0
	next iDe
	del deskNumberInRow

	if iPartitionPos = PARPOS_BETW_D then del 1
endif

if iLayoutType = LAYOUT_CUBICLE then
	if iPartitionPos = PARPOS_BETW_D then add partitionFrameThk * bEndPartitions1, (partitionFrameThk / 2 + partitionFrameThk / 2 * NOT(bDoubleRow)) * bFrontPartitions, 0

	for iDe = 1 to deskNumberInRow
		for iRow = 1 to 1 + bDoubleRow

			bMirroredComputer	= (iRow = 2) * (iArrangement = ARRANGE_MIRR)
			gosub "desk"

			mul	1 - 2 * (iArrangement = ARRANGE_ROT), -1, 1
			add	(partitionFrameThk * (iPartitionPos = PARPOS_BETW_D) * bDoubleRow * bSidePartitions - deskDist) * (iArrangement = ARRANGE_ROT),
				partitionFrameThk * (iPartitionPos = PARPOS_BETW_D) * bDoubleRow * bFrontPartitions, 0
		next iRow
		del (1 + bDoubleRow) * 2

		add deskDist, 0, 0
	next iDe
	del deskNumberInRow

	if iPartitionPos = PARPOS_BETW_D then del 1
endif

if iLayoutType = LAYOUT_WAVE then
	add partitionFrameThk * bEndPartitions1 * (iPartitionPos = PARPOS_BETW_D), 0, 0

	for iDe = 1 to deskNumber
		iRow = iDe

		if NOT(bDeskNumLeftIsEven) then
			rotz 180
			add	-deskDist * ((iDe / 2) = INT(iDe / 2)) + partitionFrameThk * (iPartitionPos = PARPOS_BETW_D) * bFrontPartitions,
					-deskDist2 * ((iDe / 2) <> INT(iDe / 2)) + partitionFrameThk * (iPartitionPos = PARPOS_BETW_D) * bFrontPartitions, 0
		endif

		bMirroredComputer	= 0
		gosub "desk"

		if NOT(bDeskNumLeftIsEven) then del 2

		rotz 180
		add	-deskDist * ((iDe / 2) <> INT(iDe / 2)) + partitionFrameThk * (iPartitionPos = PARPOS_BETW_D) * bFrontPartitions,
				-deskDist2 * ((iDe / 2) = INT(iDe / 2)) + partitionFrameThk * (iPartitionPos = PARPOS_BETW_D) * bFrontPartitions, 0
	next iDe
	del deskNumber * 2

	del 1
endif



! ======================================================================
! Extensions (Rounded, Desk, Desk with Chair, Cabinet, Partition)
! ======================================================================

if iLayoutType = LAYOUT_STRAIGHT then
	for iExt = 1 to 2
		add extDistFromCenter[iExt * 2], 0, 0
		rotz 90
		mul 1, 1 - 2 * (iExt = 1), 1

		iExtType		= iExtensionType[iExt * 2]
		extRoundedRad	= layoutEndWidth[iExt * 2]
		bPartColumnCut	= 0
		gosub "extension"
		del 3
	next iExt
endif

if iLayoutType = LAYOUT_WAVE then
	if bDeskNumLeftIsEven then
		extNumInTopRow		= CEIL(deskNumber / 2) - 1
		extNumInBottomRow	= INT(deskNumber / 2) - 1
	else
		extNumInTopRow		= INT(deskNumber / 2) - 1
		extNumInBottomRow	= CEIL(deskNumber / 2) - 1
	endif

	if deskNumber > 1 then
		for iExtTop = 1 to extNumInTopRow

			if iPartitionPos = PARPOS_BETW_D then
				add	deskDist - partitionFrameThk * NOT(bEndPartitions1) + partitionFrameThk * NOT(bFrontPartitions),
						partitionFrameThk * bFrontPartitions * (iExtensionType[1] = EXT_CABINET) - partitionFrameThk * bFrontPartitions, 0
			else
				add	deskDist, 0, 0
			endif

			iExtType		= iExtensionType[1]
			extRoundedRad	= layoutEndWidth[1]
			bPartColumnCut	= bFrontPartitions * (iPartitionPos = PARPOS_BETW_D)
			gosub "extension"
			del 1

		add deskDist, -deskDist2, 0
		next iExtTop
		del extNumInTopRow

		for iExtBottom = 1 to extNumInBottomRow

			if iPartitionPos = PARPOS_BETW_D then
				add deskDist * bDeskNumLeftIsEven + partitionFrameThk * bEndPartitions1, -partitionFrameThk * bFrontPartitions * (iExtensionType[1] = EXT_CABINET) - deskDist2 * bDeskNumLeftIsEven, 0
			else
				add deskDist * bDeskNumLeftIsEven, -deskDist2 * bDeskNumLeftIsEven, 0
			endif
			rotz 180

			iExtType		= iExtensionType[3]
			extRoundedRad	= layoutEndWidth[3]
			bPartColumnCut	= bFrontPartitions * (iPartitionPos = PARPOS_BETW_D)
			gosub "extension"

			del 2

		add deskDist, -deskDist2, 0
		next iExtBottom
		del extNumInBottomRow
	endif
endif



! ======================================================================
! Desk Partitions
! ======================================================================

if iLayoutType = LAYOUT_STRAIGHT then
	!!!Left End Partition and Partition Column
	if bEndPartitions1 then
		add partitionFrameThk / 2, 0, 0

		!!!Left End Column if NOT(bDoubleRow)
		if NOT(bDoubleRow) * bFrontPartitions then
			add 0, partitionFrameThk / 2, 0
				bPartColumnCover	= 0
				bShowPartEdgeTop	= 0
				bShowPartEdgeLeft	= 1
				bShowPartEdgeBottom	= 1
				bShowPartEdgeRight	= 0
				bOnlyPartitionCover	= bPartColumnCover * NOT(bFrontPartitions) * NOT(bSidePartitions)
				gosub "partitionColumn"
			del 1
		endif

		if NOT(bDoubleRow) then
			add 0, partLength[4] / 2 + partitionFrameThk * bFrontPartitions, 0
		else
			rotz 90
		endif

		bShowPartEdgeLeft	= NOT(bDoubleRow) * NOT(bFrontPartitions)
		bShowPartEdgeRight	= 1
		bCalledAsExtension	= bDoubleRow
		anglePartititon		= 90 * NOT(bDoubleRow)
		gosub "leftEndPartition"

		del 1

		del 1
	endif

	!!!Right End Partition and Partition Column
	if bEndPartitions2 then
		add totalLength - partitionFrameThk / 2, 0, 0

		!!!Right End Column if NOT(bDoubleRow)
		if NOT(bDoubleRow) * bFrontPartitions then
			add 0, partitionFrameThk / 2, 0
				bPartColumnCover	= 0
				bShowPartEdgeTop	= 0
				bShowPartEdgeLeft	= 0
				bShowPartEdgeBottom	= 1
				bShowPartEdgeRight	= 1
				bOnlyPartitionCover	= bPartColumnCover * NOT(bFrontPartitions) * NOT(bSidePartitions)
				gosub "partitionColumn"
			del 1
		endif

		if NOT(bDoubleRow) then
			add 0, partLength[3] / 2 + partitionFrameThk * bFrontPartitions, 0
		else
			rotz -90
		endif

		bShowPartEdgeLeft	= NOT(bDoubleRow) * NOT(bFrontPartitions)
		bShowPartEdgeRight	= 1
		bCalledAsExtension	= bDoubleRow
		anglePartititon		= 90 * NOT(bDoubleRow)
		gosub "rightEndPartition"

		del 1

		del 1
	endif

	!!!Front Partitions
	if bFrontPartitions then
		add 0, partitionFrameThk / 2 * NOT(bDoubleRow), 0
		for iPa = 1 to deskNumberInRow
			if iPa = 1 then
				if iPartitionPos = PARPOS_BETW_D then
					frontPartLength = partLength[1] - partitionFrameThk / 2 * NOT(bSidePartitions) + partitionFrameThk / 2 * (deskNumberInRow = 1)
				else
					frontPartLength = partLength[1] - partitionFrameThk / 2 * (deskNumberInRow > 1)	- partitionFrameThk * bEndPartitions1 - partitionFrameThk * bEndPartitions2 * (deskNumberInRow = 1)
				endif
				add frontPartLength / 2 + partitionFrameThk * bEndPartitions1, 0, 0
			endif

			if iPa > 1 and iPa < deskNumberInRow then
				if iPartitionPos = PARPOS_BETW_D then
					frontPartLength = partLength[1] - partitionFrameThk * NOT(bSidePartitions)
					add deskDist * (iPa - 1) + frontPartLength / 2 + partitionFrameThk * bEndPartitions1 + partitionFrameThk / 2 * NOT(bSidePartitions), 0, 0
				else
					frontPartLength = partLength[1] - partitionFrameThk
					add deskDist * (iPa - 1) + frontPartLength / 2 + partitionFrameThk / 2, 0, 0
				endif
			endif
			if iPa = deskNumberInRow and iPa > 1 then
				if iPartitionPos = PARPOS_BETW_D then
					frontPartLength = partLength[1] - partitionFrameThk / 2 * NOT(bSidePartitions)
					add deskDist * (iPa - 1) + frontPartLength / 2 + partitionFrameThk * bEndPartitions1 + partitionFrameThk / 2 * NOT(bSidePartitions), 0, 0
				else
					frontPartLength = partLength[1] - partitionFrameThk / 2 - partitionFrameThk * bEndPartitions2
					add deskDist * (iPa - 1) + frontPartLength / 2 + partitionFrameThk / 2, 0, 0
				endif
			endif

			bShowPartEdgeRight	= NOT(bEndPartitions2) * (iPa = deskNumberInRow)
			bShowPartEdgeLeft	= NOT(bEndPartitions1) * (iPa = 1)
			gosub "frontPartition"
			del 1
		next iPa
		del 1
	endif

	!!!Side Partitions
	if bSidePartitions then
		add deskDist, 0, 0
		if iPartitionPos = PARPOS_BETW_D then
			if bEndPartitions1 then
				add partitionFrameThk / 2, 0, 0
			else
				add -partitionFrameThk / 2, 0, 0
			endif
		endif

		for iPa = 1 to deskNumberInRow - 1
			if NOT(bDoubleRow) then
				add 0, partLength[2] / 2 + partitionFrameThk * bFrontPartitions, 0
			else
				add 0, extPartLengthStart[2] / 2 + partitionFrameThk / 2, 0
			endif

			for iPa2 = 1 to 1 + bDoubleRow
				add 0, -(extPartLengthStart[2] + partitionFrameThk) * (iPa2 = 2), 0
				mul 1, 1 - 2 * (iPa2 = 2), 1

				bShowPartEdgeLeft	= NOT(bDoubleRow) * NOT(bFrontPartitions)
				bShowPartEdgeRight	= 1
				bOnlyPartitionCover	= NOT(bSidePartitions)
				sidePartLength		= partLength[2] * NOT(bDoubleRow) + extPartLengthStart[2] * bDoubleRow
				gosub "sidePartition"
				del 2
			next iPa2
			del 1
		add deskDist, 0, 0
		next iPa
		del deskNumberInRow - 1

		del 1 + (iPartitionPos = PARPOS_BETW_D)
	endif

	!!!Internal Partition Column
	if bSidePartitions * bDoubleRow or bFrontPartitions then
		add deskDist, 0, 0
		if iPartitionPos = PARPOS_BETW_D then add partitionFrameThk * bEndPartitions1 - partitionFrameThk / 2 * bSidePartitions, 0, 0

		for iPa = 1 to deskNumberInRow - 1
			add deskDist * (iPa - 1), partitionFrameThk / 2 * NOT(bDoubleRow), 0
				bPartColumnCover	= 1
				bShowPartEdgeTop	= NOT(bSidePartitions)
				bShowPartEdgeLeft	= NOT(bFrontPartitions)
				bShowPartEdgeBottom	= NOT(bSidePartitions) or NOT(bDoubleRow)
				bShowPartEdgeRight	= NOT(bFrontPartitions)
				bOnlyPartitionCover	= bPartColumnCover * NOT(bFrontPartitions) * NOT(bSidePartitions)
				gosub "partitionColumn"
			del 1
		next iPa

		del 1 + (iPartitionPos = PARPOS_BETW_D)
	endif
endif

if iLayoutType = LAYOUT_CUBICLE then
	!!!Left End Partition and Partition Column
	if bEndPartitions1 then
		add partitionFrameThk / 2, 0, 0

		!!!Left End Column if NOT(bDoubleRow)
		if NOT(bDoubleRow) * bFrontPartitions then
			add 0, partitionFrameThk / 2, 0
				bPartColumnCover	= 0
				bShowPartEdgeTop	= 0
				bShowPartEdgeLeft	= 1
				bShowPartEdgeBottom	= 1
				bShowPartEdgeRight	= 0
				gosub "partitionColumn"
			del 1
		endif

		if NOT(bDoubleRow) then
			add 0, partLength[4] / 2 + partitionFrameThk * bFrontPartitions, 0
		else
			rotz 90
		endif

		bShowPartEdgeLeft	= NOT(bDoubleRow) * NOT(bFrontPartitions)
		bShowPartEdgeRight	= 1
		bCalledAsExtension	= bDoubleRow
		anglePartititon		= 90 * NOT(bDoubleRow)
		gosub "leftEndPartition"

		del 1

		del 1
	endif

	!!!Right End Partition and Partition Column
	if bEndPartitions2 then
		add totalLength - partitionFrameThk / 2, 0, 0

		!!!Right End Column if NOT(bDoubleRow)
		if NOT(bDoubleRow) * bFrontPartitions then
			add 0, partitionFrameThk / 2, 0
				bPartColumnCover	= 0
				bShowPartEdgeTop	= 0
				bShowPartEdgeLeft	= 0
				bShowPartEdgeBottom	= 1
				bShowPartEdgeRight	= 1
				gosub "partitionColumn"
			del 1
		endif

		if NOT(bDoubleRow) then
			add 0, partLength[3] / 2 + partitionFrameThk * bFrontPartitions, 0
		else
			rotz -90
		endif

		bShowPartEdgeLeft	= NOT(bDoubleRow) * NOT(bFrontPartitions)
		bShowPartEdgeRight	= 1
		bCalledAsExtension	= bDoubleRow
		anglePartititon		= 90 * NOT(bDoubleRow)
		gosub "rightEndPartition"

		del 1

		del 1
	endif

	!!!Front Partitions
	if bFrontPartitions then
		add 0, partitionFrameThk / 2 * NOT(bDoubleRow), 0
		for iPa = 1 to deskNumberInRow
			if iPa = 1 then
				if iPartitionPos = PARPOS_BETW_D then
					frontPartLength = partLength[1] - partitionFrameThk / 2 * NOT(bSidePartitions) + partitionFrameThk / 2 * (deskNumberInRow = 1)
				else
					frontPartLength = partLength[1]\
									- partitionFrameThk / 2 * (deskNumberInRow > 1) * NOT(bSidePartitions)\
									- partitionFrameThk * (bEndPartitions1 + bEndPartitions2 * (deskNumberInRow = 1))\
									- partitionFrameThk / 2 * bSidePartitions * (iArrangement = ARRANGE_ROT) * (bDoubleRow + (deskNumberInRow > 1))
				endif
				add frontPartLength / 2 + partitionFrameThk * bEndPartitions1, 0, 0
			endif
			if iPa > 1 and iPa < deskNumberInRow then
				if iPartitionPos = PARPOS_BETW_D then
					frontPartLength = partLength[1] - partitionFrameThk * NOT(bSidePartitions)
					add deskDist * (iPa - 1) + frontPartLength / 2 + partitionFrameThk * bEndPartitions1 + partitionFrameThk / 2 * NOT(bSidePartitions), 0, 0
				else
					frontPartLength = partLength[1] - partitionFrameThk - partitionFrameThk * bSidePartitions * bDoubleRow * (iArrangement = ARRANGE_ROT)
					add deskDist * (iPa - 1) + frontPartLength / 2 + partitionFrameThk / 2 + partitionFrameThk / 2 * bSidePartitions, 0, 0
				endif
			endif
			if iPa = deskNumberInRow and iPa > 1 then
				if iPartitionPos = PARPOS_BETW_D then
					frontPartLength = partLength[1] - partitionFrameThk / 2 * NOT(bSidePartitions)
					add deskDist * (iPa - 1) + frontPartLength / 2 + partitionFrameThk * bEndPartitions1 + partitionFrameThk / 2 * NOT(bSidePartitions), 0, 0
				else
					frontPartLength = partLength[1] - partitionFrameThk / 2 - partitionFrameThk * bEndPartitions2 - partitionFrameThk / 2 * bSidePartitions
					add deskDist * (iPa - 1) + frontPartLength / 2 + partitionFrameThk / 2 + partitionFrameThk / 2 * bSidePartitions, 0, 0
				endif
			endif

			bShowPartEdgeRight	= NOT(bEndPartitions2) * (iPa = deskNumberInRow)
			bShowPartEdgeLeft	= NOT(bEndPartitions1) * (iPa = 1)
			gosub "frontPartition"
			del 1
		next iPa
		del 1
	endif

	!!!Side Partitions
	if bSidePartitions then
		add deskDist, 0, 0
		if iPartitionPos = PARPOS_BETW_D then
			if bEndPartitions1 then
				add partitionFrameThk / 2, 0, 0
			else
				add -partitionFrameThk / 2, 0, 0
			endif
		endif

		for iPa = 1 to deskNumberInRow - 1
			if NOT(bDoubleRow) then
				add 0, partLength[2] / 2 + partitionFrameThk * bFrontPartitions, 0
			else
				add 0, extPartLengthStart[2] / 2 + partitionFrameThk / 2, 0
			endif

			for iPa2 = 1 to 1 + bDoubleRow
				if iPartitionPos = PARPOS_ABOVE_D then
					add	partitionFrameThk / 2 * ((iPa2 = 1) + (iPa2 = 2) * (iArrangement = ARRANGE_MIRR))\
						- partitionFrameThk / 2 * ((iPa2 = 2) * (iArrangement = ARRANGE_ROT)), 0, 0
				endif
				add 0, -(extPartLengthStart[2] + partitionFrameThk) * (iPa2 = 2), 0
				mul 1, 1 - 2 * (iPa2 = 2), 1

				bShowPartEdgeLeft	= NOT(bDoubleRow) * NOT(bFrontPartitions)
				bShowPartEdgeRight	= 1
				bOnlyPartitionCover	= NOT(bSidePartitions)
				sidePartLength		= partLength[2] * NOT(bDoubleRow) + extPartLengthStart[2] * bDoubleRow
				gosub "sidePartition"
				del 2
				if iPartitionPos = PARPOS_ABOVE_D then del 1
			next iPa2
			del 1
		add deskDist, 0, 0
		next iPa
		del deskNumberInRow - 1

		del 1 + (iPartitionPos = PARPOS_BETW_D)
	endif

	!!!Internal Partition Column
	if bSidePartitions * bDoubleRow or bFrontPartitions then
		add deskDist, 0, 0
		if iPartitionPos = PARPOS_BETW_D then add partitionFrameThk * bEndPartitions1 - partitionFrameThk / 2 * bSidePartitions, 0, 0

		for iPa2 = 1 to 1 + (iPartitionPos = PARPOS_ABOVE_D) * bSidePartitions * (iArrangement = ARRANGE_ROT)
			if iPartitionPos = PARPOS_ABOVE_D and bSidePartitions then
				add	partitionFrameThk / 2 * (iPa2 = 1) - partitionFrameThk / 2 * (iPa2 = 2), 0, 0
			endif

			for iPa = 1 to deskNumberInRow - 1
				add deskDist * (iPa - 1), partitionFrameThk / 2 * NOT(bDoubleRow), 0
					bPartColumnCover	= 1
					if iPartitionPos = PARPOS_BETW_D or iArrangement = ARRANGE_MIRR then
						bShowPartEdgeTop	= NOT(bSidePartitions)
						bShowPartEdgeLeft	= NOT(bFrontPartitions)
						bShowPartEdgeBottom	= NOT(bSidePartitions) or NOT(bDoubleRow)
						bShowPartEdgeRight	= NOT(bFrontPartitions)
					else
						bShowPartEdgeTop	= NOT(bSidePartitions) or (bSidePartitions and iPa2 = 2)
						bShowPartEdgeLeft	= (NOT(bFrontPartitions) and iPa2 = 2)
						bShowPartEdgeBottom	= NOT(bSidePartitions) or (bSidePartitions and iPa2 = 1)
						bShowPartEdgeRight	= (NOT(bFrontPartitions) and iPa2 = 1)
					endif
					gosub "partitionColumn"
				del 1
			next iPa

			if iPartitionPos = PARPOS_ABOVE_D and bSidePartitions then del 1
		next iPa2

		if iPartitionPos = PARPOS_BETW_D then del 1
		del 1
	endif
endif

if iLayoutType = LAYOUT_WAVE then
	!!!Left End Partition and Partition Column
	if bEndPartitions1 then
		!!!Left End Column if deskNumber = 1
		if (deskNumber = 1) * bFrontPartitions then
			add partitionFrameThk / 2 - deskDist * NOT(bDeskNumLeftIsEven), (deskDist2 - partitionFrameThk) * NOT(bDeskNumLeftIsEven)\
			+ partitionFrameThk / 2 * (iPartitionPos = PARPOS_ABOVE_D)\
			+ (partitionFrameThk / 2 * NOT(bDeskNumLeftIsEven) - partitionFrameThk / 2 * bDeskNumLeftIsEven) * (iPartitionPos = PARPOS_BETW_D), 0

				if bDeskNumLeftIsEven then
					bShowPartEdgeTop	= 0
					bShowPartEdgeLeft	= 1
					bShowPartEdgeBottom	= 1
					bShowPartEdgeRight	= 0
				else
					bShowPartEdgeTop	= 1
					bShowPartEdgeLeft	= 1
					bShowPartEdgeBottom	= 0
					bShowPartEdgeRight	= 0
				endif
				bPartColumnCover	= 0
				bOnlyPartitionCover	= bPartColumnCover * NOT(bFrontPartitions)
				gosub "partitionColumn"
			del 1
		endif

		if bDeskNumLeftIsEven then
			if iPartitionPos = PARPOS_BETW_D then
				add partitionFrameThk / 2,
				(partLength[4] / 2 + partitionFrameThk / 2 * bFrontPartitions) * (deskNumber = 1) - partitionFrameThk / 2 + partitionFrameThk / 2 * NOT(bFrontPartitions), 0
			else
				add partitionFrameThk / 2,
				(partLength[4] / 2 + partitionFrameThk * bFrontPartitions) * (deskNumber = 1), 0
			endif
		else
			if iPartitionPos = PARPOS_BETW_D then
				add partitionFrameThk / 2 - deskDist * (deskNumber = 1) + partitionFrameThk / 2 * NOT(bFrontPartitions) * (deskNumber > 1),
				deskDist2 - partitionFrameThk / 2 + (partitionFrameThk / 2 - partLength[4] / 2 - partitionFrameThk * bFrontPartitions) * (deskNumber = 1)\
				+ partitionFrameThk * NOT(bFrontPartitions) * (deskNumber > 1), 0
			else
				add (partitionFrameThk / 2 - deskDist) * (deskNumber = 1),
				deskDist2 - partitionFrameThk / 2 + (partitionFrameThk / 2 - partLength[4] / 2 - partitionFrameThk * bFrontPartitions) * (deskNumber = 1), 0
			endif
		endif

		bShowPartEdgeLeft	= NOT(bFrontPartitions)
		bShowPartEdgeRight	= 1
		bCalledAsExtension	= (deskNumber > 1)
		anglePartititon		= 90 * bDeskNumLeftIsEven - 90 * NOT(bDeskNumLeftIsEven) * (deskNumber = 1)

		gosub "leftEndPartition"

		del 1
	endif

	!!!Right End Partition and Partition Column
	if bEndPartitions2 then
		if bDeskNumLeftIsEven then
			rightEndPartPosX = deskDist * (INT(deskNumber / 2) + (deskNumber = 1))
			rightEndPartPosY = -deskDist2 * (CEIL(deskNumber / 2) - 1) + tableDepth1 / 2 * (deskNumber = 1)
			if iPartitionPos = PARPOS_BETW_D then
				rightEndPartPosmodX = partitionFrameThk / 2 - partitionFrameThk * NOT(bEndPartitions1) + partitionFrameThk * NOT(bFrontPartitions)\
									- partitionFrameThk / 2 * NOT(bFrontPartitions) * (NOT(bDeskNumberIsEven) * (deskNumber > 3) + (deskNumber = 3))
				rightEndPartPosmodY = -partitionFrameThk / 2 + partitionFrameThk / 2 * ((deskNumber = 1) * bFrontPartitions + (deskNumber < 3) * NOT(bFrontPartitions))\
									+ partitionFrameThk / 2 * NOT(bFrontPartitions) * bDeskNumberIsEven * (deskNumber > 3)
			else
				rightEndPartPosmodX = -partitionFrameThk / 2 * bDeskNumberIsEven - partitionFrameThk / 2 * (deskNumber = 1)
				rightEndPartPosmodY = partitionFrameThk / 2 * NOT(bDeskNumberIsEven) * ((deskNumber > 1) + (deskNumber = 1) * bFrontPartitions)
			endif
		else
			rightEndPartPosX = deskDist * (CEIL(deskNumber / 2) - 1)
			rightEndPartPosY = -deskDist2 * (INT(deskNumber / 2) - 1) * (deskNumber > 1) + partLength[3] / 2 * (deskNumber = 1)
			if iPartitionPos = PARPOS_BETW_D then
				rightEndPartPosmodX = partitionFrameThk / 2 - partitionFrameThk * NOT(bEndPartitions1)\
									+ partitionFrameThk * NOT(bFrontPartitions) * NOT(bDeskNumberIsEven)\
									+ partitionFrameThk / 2 * NOT(bFrontPartitions) * bDeskNumberIsEven

				rightEndPartPosmodY = -partitionFrameThk / 2 + partitionFrameThk / 2 * (deskNumber = 1) * bFrontPartitions\
									+ partitionFrameThk / 2 * NOT(bFrontPartitions) * NOT(bDeskNumberIsEven)
			else
				rightEndPartPosmodX = -partitionFrameThk / 2 * NOT(bDeskNumberIsEven)
				rightEndPartPosmodY = partitionFrameThk / 2 * bDeskNumberIsEven
			endif
		endif

		add rightEndPartPosX + rightEndPartPosmodX, rightEndPartPosY + rightEndPartPosmodY, 0

		!!!Right End Column if deskNumber = 1
		if (deskNumber = 1) * bFrontPartitions then
			add 0, partLength[3] / 2 * NOT(bDeskNumLeftIsEven) - (partitionFrameThk + partLength[3] / 2) * bDeskNumLeftIsEven + partitionFrameThk / 2, 0
				if bDeskNumLeftIsEven then
					bShowPartEdgeTop	= 0
					bShowPartEdgeLeft	= 0
					bShowPartEdgeBottom	= 1
					bShowPartEdgeRight	= 1
				else
					bShowPartEdgeTop	= 1
					bShowPartEdgeLeft	= 0
					bShowPartEdgeBottom	= 0
					bShowPartEdgeRight	= 1
				endif
				bPartColumnCover	= 0
				bOnlyPartitionCover	= bPartColumnCover * NOT(bFrontPartitions)
				gosub "partitionColumn"
			del 1
		endif

		if bDeskNumLeftIsEven then
			if (deskNumber > 1) then
				rotz -90 * bDeskNumberIsEven
				mul 1, 1 - 2 * NOT(bDeskNumberIsEven), 1
			endif
		else
			if (deskNumber > 1) then
				rotz 90 * NOT(bDeskNumberIsEven) + 180 * bDeskNumberIsEven
				mul 1, 1 - 2 * NOT(bDeskNumberIsEven), 1
			endif
		endif

		bShowPartEdgeLeft	= NOT(bFrontPartitions)
		bShowPartEdgeRight	= 1
		bCalledAsExtension	= (deskNumber > 1)
		anglePartititon		= (90 * bDeskNumLeftIsEven - 90 * NOT(bDeskNumLeftIsEven)) * (deskNumber = 1)

		gosub "rightEndPartition"

		del 2 * (deskNumber > 1)

		del 1
	endif

	!!!Front Partitions
	if bFrontPartitions then
		if bDeskNumLeftIsEven then
			frontPartNum	= INT(deskNumber / 2) + (deskNumber = 1)
		else
			frontPartNum	= CEIL(deskNumber / 2) - 1 + (deskNumber = 1)
		endif

		add 0, -partitionFrameThk / 2 * (iPartitionPos = PARPOS_BETW_D), 0

		for iPa = 1 to frontPartNum
			if iPa = 1 then
				if bDeskNumLeftIsEven then
					if iPartitionPos = PARPOS_BETW_D then
						frontPartLength = partLength[1]
						add frontPartLength / 2 + partitionFrameThk * bEndPartitions1, 0, 0
					else
						frontPartLength = partLength[1] + partitionFrameThk * NOT(bEndPartitions1) - partitionFrameThk / 2 * (deskNumber > 2) - partitionFrameThk * bEndPartitions2 * (deskNumber < 3)
						add frontPartLength / 2 + partitionFrameThk - partitionFrameThk * NOT(bEndPartitions1), partitionFrameThk / 2 * (deskNumber = 1), 0
					endif
				else
					if iPartitionPos = PARPOS_BETW_D then
						frontPartLength = partLength[1]
						add frontPartLength / 2 + partitionFrameThk * bEndPartitions1 * (deskNumber > 1) - (frontPartLength + partitionFrameThk * NOT(bEndPartitions1)) * (deskNumber = 1),
						deskDist2 * (deskNumber = 1), 0
					else
						frontPartLength = partLength[1] + (partitionFrameThk - partitionFrameThk * bEndPartitions1 - partitionFrameThk * bEndPartitions2) * (deskNumber = 1)\
										+ (partitionFrameThk / 2 * NOT(bEndPartitions2) - partitionFrameThk / 2 * bEndPartitions2) * (deskNumber = 3)
						add frontPartLength / 2 + partitionFrameThk / 2 - (frontPartLength + partitionFrameThk / 2 + partitionFrameThk * bEndPartitions2) * (deskNumber = 1),
						(deskDist2 - partitionFrameThk / 2) * (deskNumber = 1), 0
					endif
				endif
			endif
			if iPa > 1 and iPa < frontPartNum then
				if iPartitionPos = PARPOS_BETW_D then
					frontPartLength = partLength[1]
					add frontPartLength / 2 + partitionFrameThk * bEndPartitions1, 0, 0
				else
					frontPartLength = partLength[1]
					add frontPartLength / 2 + partitionFrameThk / 2, 0, 0
				endif
			endif
			if iPa > 1 and iPa = frontPartNum then
				if bDeskNumLeftIsEven then
					if iPartitionPos = PARPOS_BETW_D then
						frontPartLength = partLength[1]
						add frontPartLength / 2 + partitionFrameThk * bEndPartitions1, 0, 0
					else
						frontPartLength = partLength[1] + (partitionFrameThk * NOT(bEndPartitions2) - partitionFrameThk / 2) * bDeskNumberIsEven
						add frontPartLength / 2 + partitionFrameThk / 2, 0, 0
					endif
				else
					if iPartitionPos = PARPOS_BETW_D then
						frontPartLength = partLength[1]
						add frontPartLength / 2 + partitionFrameThk * bEndPartitions1, 0, 0
					else
						frontPartLength = partLength[1] + (partitionFrameThk * NOT(bEndPartitions2) - partitionFrameThk / 2) * NOT(bDeskNumberIsEven)
						add frontPartLength / 2 + partitionFrameThk / 2, 0, 0
					endif
				endif
			endif

			if bDeskNumLeftIsEven then
				bShowPartEdgeRight	= NOT(bEndPartitions2) * (iPa = frontPartNum) * (bDeskNumberIsEven or (deskNumber = 1))
				bShowPartEdgeLeft	= NOT(bEndPartitions1) * (iPa = 1)
			else
				bShowPartEdgeRight	= NOT(bEndPartitions2) * (iPa = frontPartNum) * NOT(bDeskNumberIsEven)
				bShowPartEdgeLeft	= NOT(bEndPartitions1) * (deskNumber = 1)
			endif

			gosub "frontPartition"

			del 1

			add deskDist, -deskDist2, 0

		next iPa
		del frontPartNum

		del 1
	endif

	!!!Side Partitions
	if bFrontPartitions then
		if bDeskNumLeftIsEven then
			sidePartNum	= CEIL(deskNumber / 2) - 1
		else
			sidePartNum	= INT(deskNumber / 2)
		endif

		add deskDist * bDeskNumLeftIsEven, deskDist2 * NOT(bDeskNumLeftIsEven), 0
		if iPartitionPos = PARPOS_BETW_D then
			if bEndPartitions1 then
				add partitionFrameThk / 2, 0, 0
			else
				add -partitionFrameThk / 2, 0, 0
			endif
		endif

		for iPa = 1 to sidePartNum
			if bDeskNumLeftIsEven then
				if iPartitionPos = PARPOS_BETW_D then
					sidePartLength	= partLength[2]
					add	0, -sidePartLength / 2 - partitionFrameThk, 0
				else
					sidePartLength	= partLength[2] + (partitionFrameThk * NOT(bEndPartitions2) - partitionFrameThk / 2) * NOT(bDeskNumberIsEven) * (iPa = sidePartNum)
					add	0, -sidePartLength / 2 - partitionFrameThk / 2, 0
				endif
			else
				if iPartitionPos = PARPOS_BETW_D then
					sidePartLength	= partLength[2]
					add	0, -sidePartLength / 2 - partitionFrameThk, 0
				else
					if iPa = 1 then
						sidePartLength	= partLength[2] - partitionFrameThk / 2 + partitionFrameThk * NOT(bEndPartitions1)\
										+ (partitionFrameThk / 2 * NOT(bEndPartitions2) - partitionFrameThk / 2 * bEndPartitions2) * (deskNumber < 3)
						add	0, -sidePartLength / 2 - partitionFrameThk * (bEndPartitions1), 0
					endif
					if iPa > 1 and iPa < sidePartNum then
						sidePartLength	= partLength[2]
						add	0, -sidePartLength / 2 - partitionFrameThk / 2, 0
					endif
					if iPa > 1 and iPa = sidePartNum then
						sidePartLength	= partLength[2] + (partitionFrameThk * NOT(bEndPartitions2) - partitionFrameThk / 2) * bDeskNumberIsEven
						add	0, -sidePartLength / 2 - partitionFrameThk / 2, 0
					endif
				endif
			endif

			if bDeskNumLeftIsEven then
				bShowPartEdgeLeft	= NOT(bEndPartitions2) * (iPa = sidePartNum) * NOT(bDeskNumberIsEven)
				bShowPartEdgeRight	= 0
			else
				bShowPartEdgeLeft	= NOT(bEndPartitions2) * (iPa = sidePartNum) * bDeskNumberIsEven
				bShowPartEdgeRight	= NOT(bEndPartitions1) * (iPa = 1)
			endif
			bOnlyPartitionCover	= NOT(bFrontPartitions)

			gosub "sidePartition"

			del 1
		add deskDist, -deskDist2, 0
		next iPa
		del sidePartNum

		del 1 + (iPartitionPos = PARPOS_BETW_D)
	endif

	!!!Internal Partition Columns
	if bFrontPartitions then
		if bDeskNumLeftIsEven then
			colNumInTopRow		= CEIL(deskNumber / 2) - 1
			colNumInBottomRow	= INT(deskNumber / 2) - 1
		else
			colNumInTopRow		= INT(deskNumber / 2) - 1
			colNumInBottomRow	= CEIL(deskNumber / 2) - 1
		endif

		if deskNumber > 1 then
			for iPaTop = 1 to colNumInTopRow

				if iPartitionPos = PARPOS_BETW_D then
					add	deskDist + partitionFrameThk / 2 * (bEndPartitions1) - partitionFrameThk / 2 * NOT(bEndPartitions1), -partitionFrameThk / 2, 0
				else
					add	deskDist, 0, 0
				endif

				bPartColumnCover	= 1
				bShowPartEdgeTop	= 1
				bShowPartEdgeLeft	= 0
				bShowPartEdgeBottom	= 0
				bShowPartEdgeRight	= 1
				bOnlyPartitionCover	= bPartColumnCover * NOT(bFrontPartitions)

				gosub "partitionColumn"

				del 1

			add deskDist, -deskDist2, 0
			next iPaTop
			del colNumInTopRow

			for iPaBottom = 1 to colNumInBottomRow

				if iPartitionPos = PARPOS_BETW_D then
					add deskDist * bDeskNumLeftIsEven + partitionFrameThk / 2 * (bEndPartitions1) - partitionFrameThk / 2 * NOT(bEndPartitions1),
					-deskDist2 * bDeskNumLeftIsEven - partitionFrameThk / 2, 0
				else
					add deskDist * bDeskNumLeftIsEven, -deskDist2 * bDeskNumLeftIsEven, 0
				endif

				bPartColumnCover	= 1
				bShowPartEdgeTop	= 0
				bShowPartEdgeLeft	= 1
				bShowPartEdgeBottom	= 1
				bShowPartEdgeRight	= 0
				bOnlyPartitionCover	= bPartColumnCover * NOT(bFrontPartitions)

				gosub "partitionColumn"

				del 1

			add deskDist, -deskDist2, 0
			next iPaBottom
			del colNumInBottomRow
		endif
	endif
endif

if iLayoutType = LAYOUT_WAVE then del 4

! ======================================================================
end
! ======================================================================



"desk":
	call "completeTable_m" parameters all	iTableTopType			= 1 + (iLayoutType = LAYOUT_STRAIGHT),
											iDeskAngle				= iDeskAngle,
											bCalledAsExtension		= 0,
											bPartOfLayout			= 1,
											bPartOfWsSolo			= 0,
											bChair					= 1,
											bEnableDeskHsCorner		= 0,
											bEnableDeskHsHalfEdge	= 0,
											bEnableDeskHsEditingX	= (iDe = 1) * (iRow = 1) * (iSizing = SIZING_WS_SIZE),
											bEnableDeskHsEditingY	= (iDe = 1) * (iRow = 1),
											bEnableDeskHsEditingC	= (iDe = 1) * (iRow = 1),
											bEnableChairHsEditing 	= (iDe = 1) * (iRow = 1),
											bMirroredComputer		= bMirroredComputer,
											bMirroredCabPos			= bMirroredCabPos,
											chairPos				= chairPos,
											zzyzx					= tableTopHeight,
											completeTable_unID		= unID,
											stSymbolTypes			= stSymbolTypes,
											bKnobNoneType			= 0,
											returned_parameters completeTable_unID
	unID = completeTable_unID
	if iLayoutType = 1 then
		hotspot tableLength1 / 2, tableDepth1 / 2, 0,				centerunID, tableTopHeight, 1 : centerunID = centerunID + 1
		hotspot tableLength1 / 2, tableDepth1 / 2, tableTopHeight,	centerunID, tableTopHeight, 2 : centerunID = centerunID + 1
		hotspot tableLength1 / 2, tableDepth1 / 2, -1,				centerunID, tableTopHeight, 3 : centerunID = centerunID + 1
	endif
return

"extension":
	call "deskClosings_m" parameters all	iExtensionType			= iExtType,
											partitionFrameThk		= partitionFrameThk,
											bSymmetricalDeskEnd		= bSymmetricalDeskEnd,
											extRoundedRad			= extRoundedRad,
											bCalledAsExtension		= 1,
											bPartOfLayout			= 1,
											bPartOfWsSolo			= 0,
											bPartColumnCut			= bPartColumnCut,
											partColumnCutWidth		= partitionFrameThk,
											anglePartititon			= 0,
											xPartOrigPos			= 0,
											yPartOrigPos			= 0,
											iExtraDeskCab			= iExtraDeskCab * bShowCabParams,
											deskClosings_unID		= unID,
											stSymbolTypes			= stSymbolTypes,
											bKnobNoneType			= 0,
											returned_parameters deskClosings_unID
	unID = deskClosings_unID
	if iExtType = 2 or iExtType = 3 then
		hotspot 0, extraDeskDepth / 2, 0,				centerunID, tableTopHeight, 1 : centerunID = centerunID + 1
		hotspot 0, extraDeskDepth / 2, tableTopHeight,	centerunID, tableTopHeight, 2 : centerunID = centerunID + 1
		hotspot 0, extraDeskDepth / 2, -1,				centerunID, tableTopHeight, 3 : centerunID = centerunID + 1
	endif
return

"leftEndPartition":
	call "deskClosings_m" parameters all	iExtensionType			= DESK_PARTITION,
											partitionFrameThk		= partitionFrameThk,
											iDeskAngle				= iDeskAngle,
											bCalledAsExtension		= bCalledAsExtension,
											bPartOfLayout			= 1,
											bPartOfWsSolo			= 0,
											lengthPartition			= partLength[4],
											extPartLengthStart		= extPartLengthStart[4],
											extPartLengthEnd		= extPartLengthEnd[4],
											bShowExtPartConnEdge	= NOT(bFrontPartitions),
											bShowPartEdgeLeft		= bShowPartEdgeLeft,
											bShowPartEdgeRight		= bShowPartEdgeRight,
											anglePartititon			= anglePartititon,
											xPartOrigPos			= 0,
											yPartOrigPos			= 0,
											deskClosings_unID		= unID,
											stSymbolTypes			= stSymbolTypes,
											bKnobNoneType			= 0,
											returned_parameters deskClosings_unID
	unID = deskClosings_unID
return

"rightEndPartition":
	call "deskClosings_m" parameters all	iExtensionType			= DESK_PARTITION,
											partitionFrameThk		= partitionFrameThk,
											iDeskAngle				= iDeskAngle,
											bCalledAsExtension		= bCalledAsExtension,
											bPartOfLayout			= 1,
											bPartOfWsSolo			= 0,
											lengthPartition			= partLength[3],
											extPartLengthStart		= extPartLengthStart[3],
											extPartLengthEnd		= extPartLengthEnd[3],
											bShowExtPartConnEdge	= NOT(bFrontPartitions),
											bShowPartEdgeLeft		= bShowPartEdgeLeft,
											bShowPartEdgeRight		= bShowPartEdgeRight,
											anglePartititon			= anglePartititon,
											xPartOrigPos			= 0,
											yPartOrigPos			= 0,
											deskClosings_unID		= unID,
											stSymbolTypes			= stSymbolTypes,
											bKnobNoneType			= 0,
											returned_parameters deskClosings_unID
	unID = deskClosings_unID
return

"frontPartition":
	call "deskClosings_m" parameters all	iExtensionType			= DESK_PARTITION,
											partitionFrameThk		= partitionFrameThk,
											iDeskAngle				= iDeskAngle,
											bCalledAsExtension		= 0,
											bPartOfLayout			= 1,
											bPartOfWsSolo			= 0,
											bOnlyPartitionColumn	= 0,
											bOnlyPartitionCover		= NOT(bFrontPartitions),
											lengthPartition			= frontPartLength,
											bShowPartEdgeLeft		= bShowPartEdgeLeft,
											bShowPartEdgeRight		= bShowPartEdgeRight,
											anglePartititon			= 0,
											xPartOrigPos			= 0,
											yPartOrigPos			= 0,
											deskClosings_unID		= unID,
											stSymbolTypes			= stSymbolTypes,
											bKnobNoneType			= 0,
											returned_parameters deskClosings_unID
	unID = deskClosings_unID
return

"sidePartition":
	call "deskClosings_m" parameters all	iExtensionType			= DESK_PARTITION,
											partitionFrameThk		= partitionFrameThk,
											iDeskAngle				= iDeskAngle,
											bCalledAsExtension		= 0,
											bPartOfLayout			= 1,
											bPartOfWsSolo			= 0,
											bOnlyPartitionColumn	= 0,
											bOnlyPartitionCover		= bOnlyPartitionCover,
											lengthPartition			= sidePartLength,
											bShowPartEdgeLeft		= bShowPartEdgeLeft,
											bShowPartEdgeRight		= bShowPartEdgeRight,
											anglePartititon			= 90,
											xPartOrigPos			= 0,
											yPartOrigPos			= 0,
											deskClosings_unID		= unID,
											stSymbolTypes			= stSymbolTypes,
											bKnobNoneType			= 0,
											returned_parameters deskClosings_unID
	unID = deskClosings_unID
return

"partitionColumn":
	call "deskClosings_m" parameters all	iExtensionType			= DESK_PARTITION,
											partitionFrameThk		= partitionFrameThk,
											iDeskAngle				= iDeskAngle,
											bCalledAsExtension		= 1,
											bPartOfLayout			= 1,
											bPartOfWsSolo			= 0,
											bOnlyPartitionColumn	= 1,
											bOnlyPartitionCover		= bOnlyPartitionCover,
											bShowPartEdgeTop		= bShowPartEdgeTop,
											bShowPartEdgeLeft		= bShowPartEdgeLeft,
											bShowPartEdgeBottom		= bShowPartEdgeBottom,
											bShowPartEdgeRight		= bShowPartEdgeRight,
											deskClosings_unID		= unID,
											stSymbolTypes			= stSymbolTypes,
											bKnobNoneType			= 0,
											returned_parameters deskClosings_unID
	unID = deskClosings_unID
return

]]>
</Script_3D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_2D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
unID = 1
centerunID = 20000

if iLayoutType = LAYOUT_WAVE then
	rot2 axisAngle
		hotspot2 0, 0, unID, lengthRight, 1 + 128, totalLength:		unID = unID + 1
		hotspot2 -1, 0, unID, lengthRight, 3, totalLength:			unID = unID + 1
		hotspot2 lengthRight, 0, unID, lengthRight, 2, totalLength:	unID = unID + 1

		hotspot2 0, 0, unID, lengthLeft, 1 + 128, totalLength:		unID = unID + 1
		hotspot2 1, 0, unID, lengthLeft, 3, totalLength:			unID = unID + 1
		hotspot2 -lengthLeft, 0, unID, lengthLeft, 2, totalLength:	unID = unID + 1
	del 1
else
	hotspot2 0, 0, unID, totalLength, 1 + 256:		unID = unID + 1
	hotspot2 -1, 0, unID, totalLength, 3:			unID = unID + 1
	hotspot2 totalLength, 0, unID, totalLength, 2:	unID = unID + 1
endif

if iLayoutType = LAYOUT_WAVE then
	firstLengthStep	= -partitionFrameThk / COS(diagonalAngle) * (bEndPartitions1) + (tableLength2 / 2) / SIN(diagonalAngle)\
					+ partitionFrameThk / SIN(diagonalAngle) * (bFrontPartitions or bEndPartitions1)

	if (iPartitionPos = PARPOS_ABOVE_D) or NOT(bShowPartitionParams) then
		add2 -lengthLeft, 0
	else
		add2 -lengthLeft + firstLengthStep * NOT(bDeskNumLeftIsEven), 0
	endif

	rot2 totalAngle
	add2 xPosSideCorner / 2, -yPosSideCorner / 2

	if (iPartitionPos = PARPOS_ABOVE_D) or NOT(bShowPartitionParams) then
		add2 deskDist / 2 * NOT(bDeskNumLeftIsEven), -deskDist2 / 2 * NOT(bDeskNumLeftIsEven)
	else
		pthkDB	= TAN(totalAngle) * partitionFrameThk
		yy		= COS(totalAngle) * (partitionFrameThk - pthkDB)
		add2	INT(deskNumberLeft / 2) * (yy / SIN(totalAngle)) * NOT(bDeskNumLeftIsEven) * bFrontPartitions,
				deskNumberLeft / 2 * (yy / COS(totalAngle)) * bDeskNumLeftIsEven * bFrontPartitions
	endif
endif

! ======================================================================
! Desks (with Front Panel, Desk Cabinet, Chair, Keyboard, LCD Monitor)
! ======================================================================

if iLayoutType = LAYOUT_STRAIGHT then
	if iPartitionPos = PARPOS_BETW_D then add2 partitionFrameThk * bEndPartitions1, (partitionFrameThk / 2 + partitionFrameThk / 2 * NOT(bDoubleRow)) * bFrontPartitions

	for iDe = 1 to deskNumberInRow
		for iRow = 1 to 1 + bDoubleRow

			bMirroredComputer	= (iRow = 2) * (iArrangement = ARRANGE_MIRR)
			gosub "desk"

			mul2 1 - 2 * (iArrangement = ARRANGE_ROT), -1
			add2 (partitionFrameThk * (iPartitionPos = PARPOS_BETW_D) * bDoubleRow * bSidePartitions - deskDist) * (iArrangement = ARRANGE_ROT), partitionFrameThk * (iPartitionPos = PARPOS_BETW_D) * bDoubleRow * bFrontPartitions
		next iRow
		del (1 + bDoubleRow) * 2

		add2 deskDist, 0
	next iDe
	del deskNumberInRow

	if iPartitionPos = PARPOS_BETW_D then del 1
endif

if iLayoutType = LAYOUT_CUBICLE then
	if iPartitionPos = PARPOS_BETW_D then add2 partitionFrameThk * bEndPartitions1, (partitionFrameThk / 2 + partitionFrameThk / 2 * NOT(bDoubleRow)) * bFrontPartitions

	for iDe = 1 to deskNumberInRow
		for iRow = 1 to 1 + bDoubleRow

			bMirroredComputer	= (iRow = 2) * (iArrangement = ARRANGE_MIRR)
			gosub "desk"

			mul2	1 - 2 * (iArrangement = ARRANGE_ROT), -1
			add2	(partitionFrameThk * (iPartitionPos = PARPOS_BETW_D) * bDoubleRow * bSidePartitions - deskDist) * (iArrangement = ARRANGE_ROT),
					partitionFrameThk * (iPartitionPos = PARPOS_BETW_D) * bDoubleRow * bFrontPartitions
		next iRow
		del (1 + bDoubleRow) * 2

		add2 deskDist, 0
	next iDe
	del deskNumberInRow

	if iPartitionPos = PARPOS_BETW_D then del 1
endif

if iLayoutType = LAYOUT_WAVE then
	add2 partitionFrameThk * bEndPartitions1 * (iPartitionPos = PARPOS_BETW_D), 0

	for iDe = 1 to deskNumber
		iRow = iDe

		if NOT(bDeskNumLeftIsEven) then
			rot2 180
			add2	-deskDist * ((iDe / 2) = INT(iDe / 2)) + partitionFrameThk * (iPartitionPos = PARPOS_BETW_D) * bFrontPartitions,
					-deskDist2 * ((iDe / 2) <> INT(iDe / 2)) + partitionFrameThk * (iPartitionPos = PARPOS_BETW_D) * bFrontPartitions
		endif

		bMirroredComputer	= 0
		gosub "desk"

		if NOT(bDeskNumLeftIsEven) then del 2

		rot2 180
		add2	-deskDist * ((iDe / 2) <> INT(iDe / 2)) + partitionFrameThk * (iPartitionPos = PARPOS_BETW_D) * bFrontPartitions,
				-deskDist2 * ((iDe / 2) = INT(iDe / 2)) + partitionFrameThk * (iPartitionPos = PARPOS_BETW_D) * bFrontPartitions
	next iDe
	del deskNumber * 2

	del 1
endif



! ======================================================================
! Extensions (Rounded, Desk, Desk with Chair, Cabinet, Partition)
! ======================================================================

if iLayoutType = LAYOUT_STRAIGHT then
	for iExt = 1 to 2
		add2 extDistFromCenter[iExt * 2], 0
		rot2 90
		mul2 1, 1 - 2 * (iExt = 1)

		iExtType		= iExtensionType[iExt * 2]
		extRoundedRad	= layoutEndWidth[iExt * 2]
		bPartColumnCut	= 0
		gosub "extension"
		del 3
	next iExt
endif

if iLayoutType = LAYOUT_WAVE then
	if bDeskNumLeftIsEven then
		extNumInTopRow		= CEIL(deskNumber / 2) - 1
		extNumInBottomRow	= INT(deskNumber / 2) - 1
	else
		extNumInTopRow		= INT(deskNumber / 2) - 1
		extNumInBottomRow	= CEIL(deskNumber / 2) - 1
	endif

	if deskNumber > 1 then
		for iExtTop = 1 to extNumInTopRow

			if iPartitionPos = PARPOS_BETW_D then
				add2	deskDist - partitionFrameThk * NOT(bEndPartitions1) + partitionFrameThk * NOT(bFrontPartitions),
						partitionFrameThk * bFrontPartitions * (iExtensionType[1] = EXT_CABINET) - partitionFrameThk * bFrontPartitions
			else
				add2	deskDist, 0
			endif

			iExtType		= iExtensionType[1]
			extRoundedRad	= layoutEndWidth[1]
			bPartColumnCut	= bFrontPartitions * (iPartitionPos = PARPOS_BETW_D)
			gosub "extension"
			del 1

		add2 deskDist, -deskDist2
		next iExtTop
		del extNumInTopRow

		for iExtBottom = 1 to extNumInBottomRow

			if iPartitionPos = PARPOS_BETW_D then
				add2 deskDist * bDeskNumLeftIsEven + partitionFrameThk * bEndPartitions1, -partitionFrameThk * bFrontPartitions * (iExtensionType[1] = EXT_CABINET) - deskDist2 * bDeskNumLeftIsEven
			else
				add2 deskDist * bDeskNumLeftIsEven, -deskDist2 * bDeskNumLeftIsEven
			endif
			rot2 180

			iExtType		= iExtensionType[3]
			extRoundedRad	= layoutEndWidth[3]
			bPartColumnCut	= bFrontPartitions * (iPartitionPos = PARPOS_BETW_D)
			gosub "extension"

			del 2

		add2 deskDist, -deskDist2
		next iExtBottom
		del extNumInBottomRow
	endif
endif



! ======================================================================
! Desk Partitions
! ======================================================================

if iLayoutType = LAYOUT_STRAIGHT then
	!!!Left End Partition and Partition Column
	if bEndPartitions1 then
		add2 partitionFrameThk / 2, 0

		!!!Left End Column if NOT(bDoubleRow)
		if NOT(bDoubleRow) * bFrontPartitions then
			add2 0, partitionFrameThk / 2
				bPartColumnCover	= 0
				bShowPartEdgeTop	= 0
				bShowPartEdgeLeft	= 1
				bShowPartEdgeBottom	= 1
				bShowPartEdgeRight	= 0
				bOnlyPartitionCover	= bPartColumnCover * NOT(bFrontPartitions) * NOT(bSidePartitions)
				gosub "partitionColumn"
			del 1
		endif

		if NOT(bDoubleRow) then
			add2 0, partLength[4] / 2 + partitionFrameThk * bFrontPartitions
		else
			rot2 90
		endif

		bShowPartEdgeLeft	= NOT(bDoubleRow) * NOT(bFrontPartitions)
		bShowPartEdgeRight	= 1
		bCalledAsExtension	= bDoubleRow
		anglePartititon		= 90 * NOT(bDoubleRow)
		gosub "leftEndPartition"

		del 1

		del 1
	endif

	!!!Right End Partition and Partition Column
	if bEndPartitions2 then
		add2 totalLength - partitionFrameThk / 2, 0

		!!!Right End Column if NOT(bDoubleRow)
		if NOT(bDoubleRow) * bFrontPartitions then
			add2 0, partitionFrameThk / 2
				bPartColumnCover	= 0
				bShowPartEdgeTop	= 0
				bShowPartEdgeLeft	= 0
				bShowPartEdgeBottom	= 1
				bShowPartEdgeRight	= 1
				bOnlyPartitionCover	= bPartColumnCover * NOT(bFrontPartitions) * NOT(bSidePartitions)
				gosub "partitionColumn"
			del 1
		endif

		if NOT(bDoubleRow) then
			add2 0, partLength[3] / 2 + partitionFrameThk * bFrontPartitions
		else
			rot2 -90
		endif

		bShowPartEdgeLeft	= NOT(bDoubleRow) * NOT(bFrontPartitions)
		bShowPartEdgeRight	= 1
		bCalledAsExtension	= bDoubleRow
		anglePartititon		= 90 * NOT(bDoubleRow)
		gosub "rightEndPartition"

		del 1

		del 1
	endif

	!!!Front Partitions
	if bFrontPartitions then
		add2 0, partitionFrameThk / 2 * NOT(bDoubleRow)
		for iPa = 1 to deskNumberInRow
			if iPa = 1 then
				if iPartitionPos = PARPOS_BETW_D then
					frontPartLength = partLength[1] - partitionFrameThk / 2 * NOT(bSidePartitions) + partitionFrameThk / 2 * (deskNumberInRow = 1)
				else
					frontPartLength = partLength[1] - partitionFrameThk / 2 * (deskNumberInRow > 1)	- partitionFrameThk * bEndPartitions1 - partitionFrameThk * bEndPartitions2 * (deskNumberInRow = 1)
				endif
				add2 frontPartLength / 2 + partitionFrameThk * bEndPartitions1, 0
			endif

			if iPa > 1 and iPa < deskNumberInRow then
				if iPartitionPos = PARPOS_BETW_D then
					frontPartLength = partLength[1] - partitionFrameThk * NOT(bSidePartitions)
					add2 deskDist * (iPa - 1) + frontPartLength / 2 + partitionFrameThk * bEndPartitions1 + partitionFrameThk / 2 * NOT(bSidePartitions), 0
				else
					frontPartLength = partLength[1] - partitionFrameThk
					add2 deskDist * (iPa - 1) + frontPartLength / 2 + partitionFrameThk / 2, 0
				endif
			endif
			if iPa = deskNumberInRow and iPa > 1 then
				if iPartitionPos = PARPOS_BETW_D then
					frontPartLength = partLength[1] - partitionFrameThk / 2 * NOT(bSidePartitions)
					add2 deskDist * (iPa - 1) + frontPartLength / 2 + partitionFrameThk * bEndPartitions1 + partitionFrameThk / 2 * NOT(bSidePartitions), 0
				else
					frontPartLength = partLength[1] - partitionFrameThk / 2 - partitionFrameThk * bEndPartitions2
					add2 deskDist * (iPa - 1) + frontPartLength / 2 + partitionFrameThk / 2, 0
				endif
			endif

			bShowPartEdgeRight	= NOT(bEndPartitions2) * (iPa = deskNumberInRow)
			bShowPartEdgeLeft	= NOT(bEndPartitions1) * (iPa = 1)
			gosub "frontPartition"
			del 1
		next iPa
		del 1
	endif

	!!!Side Partitions
	if bSidePartitions then
		add2 deskDist, 0
		if iPartitionPos = PARPOS_BETW_D then
			if bEndPartitions1 then
				add2 partitionFrameThk / 2, 0
			else
				add2 -partitionFrameThk / 2, 0
			endif
		endif

		for iPa = 1 to deskNumberInRow - 1
			if NOT(bDoubleRow) then
				add2 0, partLength[2] / 2 + partitionFrameThk * bFrontPartitions
			else
				add2 0, extPartLengthStart[2] / 2 + partitionFrameThk / 2
			endif

			for iPa2 = 1 to 1 + bDoubleRow
				add2 0, -(extPartLengthStart[2] + partitionFrameThk) * (iPa2 = 2)
				mul2 1, 1 - 2 * (iPa2 = 2)

				bShowPartEdgeLeft	= NOT(bDoubleRow) * NOT(bFrontPartitions)
				bShowPartEdgeRight	= 1
				bOnlyPartitionCover	= NOT(bSidePartitions)
				sidePartLength		= partLength[2] * NOT(bDoubleRow) + extPartLengthStart[2] * bDoubleRow
				gosub "sidePartition"
				del 2
			next iPa2
			del 1
		add2 deskDist, 0
		next iPa
		del deskNumberInRow - 1

		del 1 + (iPartitionPos = PARPOS_BETW_D)
	endif

	!!!Internal Partition Column
	if bSidePartitions * bDoubleRow or bFrontPartitions then
		add2 deskDist, 0
		if iPartitionPos = PARPOS_BETW_D then add2 partitionFrameThk * bEndPartitions1 - partitionFrameThk / 2 * bSidePartitions, 0

		for iPa = 1 to deskNumberInRow - 1
			add2 deskDist * (iPa - 1), partitionFrameThk / 2 * NOT(bDoubleRow)
				bPartColumnCover	= 1
				bShowPartEdgeTop	= NOT(bSidePartitions)
				bShowPartEdgeLeft	= NOT(bFrontPartitions)
				bShowPartEdgeBottom	= NOT(bSidePartitions) or NOT(bDoubleRow)
				bShowPartEdgeRight	= NOT(bFrontPartitions)
				bOnlyPartitionCover	= bPartColumnCover * NOT(bFrontPartitions) * NOT(bSidePartitions)
				gosub "partitionColumn"
			del 1
		next iPa

		del 1 + (iPartitionPos = PARPOS_BETW_D)
	endif
endif

if iLayoutType = LAYOUT_CUBICLE then
	!!!Left End Partition and Partition Column
	if bEndPartitions1 then
		add2 partitionFrameThk / 2, 0

		!!!Left End Column if NOT(bDoubleRow)
		if NOT(bDoubleRow) * bFrontPartitions then
			add2 0, partitionFrameThk / 2
				bPartColumnCover	= 0
				bShowPartEdgeTop	= 0
				bShowPartEdgeLeft	= 1
				bShowPartEdgeBottom	= 1
				bShowPartEdgeRight	= 0
				gosub "partitionColumn"
			del 1
		endif

		if NOT(bDoubleRow) then
			add2 0, partLength[4] / 2 + partitionFrameThk * bFrontPartitions
		else
			rot2 90
		endif

		bShowPartEdgeLeft	= NOT(bDoubleRow) * NOT(bFrontPartitions)
		bShowPartEdgeRight	= 1
		bCalledAsExtension	= bDoubleRow
		anglePartititon		= 90 * NOT(bDoubleRow)
		gosub "leftEndPartition"

		del 1

		del 1
	endif

	!!!Right End Partition and Partition Column
	if bEndPartitions2 then
		add2 totalLength - partitionFrameThk / 2, 0

		!!!Right End Column if NOT(bDoubleRow)
		if NOT(bDoubleRow) * bFrontPartitions then
			add2 0, partitionFrameThk / 2
				bPartColumnCover	= 0
				bShowPartEdgeTop	= 0
				bShowPartEdgeLeft	= 0
				bShowPartEdgeBottom	= 1
				bShowPartEdgeRight	= 1
				gosub "partitionColumn"
			del 1
		endif

		if NOT(bDoubleRow) then
			add2 0, partLength[3] / 2 + partitionFrameThk * bFrontPartitions
		else
			rot2 -90
		endif

		bShowPartEdgeLeft	= NOT(bDoubleRow) * NOT(bFrontPartitions)
		bShowPartEdgeRight	= 1
		bCalledAsExtension	= bDoubleRow
		anglePartititon		= 90 * NOT(bDoubleRow)
		gosub "rightEndPartition"

		del 1

		del 1
	endif

	!!!Front Partitions
	if bFrontPartitions then
		add2 0, partitionFrameThk / 2 * NOT(bDoubleRow)
		for iPa = 1 to deskNumberInRow
			if iPa = 1 then
				if iPartitionPos = PARPOS_BETW_D then
					frontPartLength = partLength[1] - partitionFrameThk / 2 * NOT(bSidePartitions) + partitionFrameThk / 2 * (deskNumberInRow = 1)
				else
					frontPartLength = partLength[1]\
									- partitionFrameThk / 2 * (deskNumberInRow > 1) * NOT(bSidePartitions)\
									- partitionFrameThk * (bEndPartitions1 + bEndPartitions2 * (deskNumberInRow = 1))\
									- partitionFrameThk / 2 * bSidePartitions * (iArrangement = ARRANGE_ROT) * (bDoubleRow + (deskNumberInRow > 1))
				endif
				add2 frontPartLength / 2 + partitionFrameThk * bEndPartitions1, 0
			endif
			if iPa > 1 and iPa < deskNumberInRow then
				if iPartitionPos = PARPOS_BETW_D then
					frontPartLength = partLength[1] - partitionFrameThk * NOT(bSidePartitions)
					add2 deskDist * (iPa - 1) + frontPartLength / 2 + partitionFrameThk * bEndPartitions1 + partitionFrameThk / 2 * NOT(bSidePartitions), 0
				else
					frontPartLength = partLength[1] - partitionFrameThk - partitionFrameThk * bSidePartitions * bDoubleRow * (iArrangement = ARRANGE_ROT)
					add2 deskDist * (iPa - 1) + frontPartLength / 2 + partitionFrameThk / 2 + partitionFrameThk / 2 * bSidePartitions, 0
				endif
			endif
			if iPa = deskNumberInRow and iPa > 1 then
				if iPartitionPos = PARPOS_BETW_D then
					frontPartLength = partLength[1] - partitionFrameThk / 2 * NOT(bSidePartitions)
					add2 deskDist * (iPa - 1) + frontPartLength / 2 + partitionFrameThk * bEndPartitions1 + partitionFrameThk / 2 * NOT(bSidePartitions), 0
				else
					frontPartLength = partLength[1] - partitionFrameThk / 2 - partitionFrameThk * bEndPartitions2 - partitionFrameThk / 2 * bSidePartitions
					add2 deskDist * (iPa - 1) + frontPartLength / 2 + partitionFrameThk / 2 + partitionFrameThk / 2 * bSidePartitions, 0
				endif
			endif

			bShowPartEdgeRight	= NOT(bEndPartitions2) * (iPa = deskNumberInRow)
			bShowPartEdgeLeft	= NOT(bEndPartitions1) * (iPa = 1)
			gosub "frontPartition"
			del 1
		next iPa
		del 1
	endif

	!!!Side Partitions
	if bSidePartitions then
		add2 deskDist, 0
		if iPartitionPos = PARPOS_BETW_D then
			if bEndPartitions1 then
				add2 partitionFrameThk / 2, 0
			else
				add2 -partitionFrameThk / 2, 0
			endif
		endif

		for iPa = 1 to deskNumberInRow - 1
			if NOT(bDoubleRow) then
				add2 0, partLength[2] / 2 + partitionFrameThk * bFrontPartitions
			else
				add2 0, extPartLengthStart[2] / 2 + partitionFrameThk / 2
			endif

			for iPa2 = 1 to 1 + bDoubleRow
				if iPartitionPos = PARPOS_ABOVE_D then
					add2	partitionFrameThk / 2 * ((iPa2 = 1) + (iPa2 = 2) * (iArrangement = ARRANGE_MIRR))\
							- partitionFrameThk / 2 * ((iPa2 = 2) * (iArrangement = ARRANGE_ROT)), 0
				endif
				add2 0, -(extPartLengthStart[2] + partitionFrameThk) * (iPa2 = 2)
				mul2 1, 1 - 2 * (iPa2 = 2)

				bShowPartEdgeLeft	= NOT(bDoubleRow) * NOT(bFrontPartitions)
				bShowPartEdgeRight	= 1
				bOnlyPartitionCover	= NOT(bSidePartitions)
				sidePartLength		= partLength[2] * NOT(bDoubleRow) + extPartLengthStart[2] * bDoubleRow
				gosub "sidePartition"
				del 2
				if iPartitionPos = PARPOS_ABOVE_D then del 1
			next iPa2
			del 1
		add2 deskDist, 0
		next iPa
		del deskNumberInRow - 1

		del 1 + (iPartitionPos = PARPOS_BETW_D)
	endif

	!!!Internal Partition Column
	if bSidePartitions * bDoubleRow or bFrontPartitions then
		add2 deskDist, 0
		if iPartitionPos = PARPOS_BETW_D then add2 partitionFrameThk * bEndPartitions1 - partitionFrameThk / 2 * bSidePartitions, 0

		for iPa2 = 1 to 1 + (iPartitionPos = PARPOS_ABOVE_D) * bSidePartitions * (iArrangement = ARRANGE_ROT)
			if iPartitionPos = PARPOS_ABOVE_D and bSidePartitions then
				add2	partitionFrameThk / 2 * (iPa2 = 1) - partitionFrameThk / 2 * (iPa2 = 2), 0
			endif

			for iPa = 1 to deskNumberInRow - 1
				add2 deskDist * (iPa - 1), partitionFrameThk / 2 * NOT(bDoubleRow)
					bPartColumnCover	= 1
					if iPartitionPos = PARPOS_BETW_D or iArrangement = ARRANGE_MIRR then
						bShowPartEdgeTop	= NOT(bSidePartitions)
						bShowPartEdgeLeft	= NOT(bFrontPartitions)
						bShowPartEdgeBottom	= NOT(bSidePartitions) or NOT(bDoubleRow)
						bShowPartEdgeRight	= NOT(bFrontPartitions)
					else
						bShowPartEdgeTop	= NOT(bSidePartitions) or (bSidePartitions and iPa2 = 2)
						bShowPartEdgeLeft	= (NOT(bFrontPartitions) and iPa2 = 2)
						bShowPartEdgeBottom	= NOT(bSidePartitions) or (bSidePartitions and iPa2 = 1)
						bShowPartEdgeRight	= (NOT(bFrontPartitions) and iPa2 = 1)
					endif
					gosub "partitionColumn"
				del 1
			next iPa

			if iPartitionPos = PARPOS_ABOVE_D and bSidePartitions then del 1
		next iPa2

		if iPartitionPos = PARPOS_BETW_D then del 1
		del 1
	endif
endif

if iLayoutType = LAYOUT_WAVE then
	!!!Left End Partition and Partition Column
	if bEndPartitions1 then
		!!!Left End Column if deskNumber = 1
		if (deskNumber = 1) * bFrontPartitions then
			add2 partitionFrameThk / 2 - deskDist * NOT(bDeskNumLeftIsEven), (deskDist2 - partitionFrameThk) * NOT(bDeskNumLeftIsEven)\
			+ partitionFrameThk / 2 * (iPartitionPos = PARPOS_ABOVE_D)\
			+ (partitionFrameThk / 2 * NOT(bDeskNumLeftIsEven) - partitionFrameThk / 2 * bDeskNumLeftIsEven) * (iPartitionPos = PARPOS_BETW_D)

				if bDeskNumLeftIsEven then
					bShowPartEdgeTop	= 0
					bShowPartEdgeLeft	= 1
					bShowPartEdgeBottom	= 1
					bShowPartEdgeRight	= 0
				else
					bShowPartEdgeTop	= 1
					bShowPartEdgeLeft	= 1
					bShowPartEdgeBottom	= 0
					bShowPartEdgeRight	= 0
				endif
				bPartColumnCover	= 0
				bOnlyPartitionCover	= bPartColumnCover * NOT(bFrontPartitions)
				gosub "partitionColumn"
			del 1
		endif

		if bDeskNumLeftIsEven then
			if iPartitionPos = PARPOS_BETW_D then
				add2 partitionFrameThk / 2,
				(partLength[4] / 2 + partitionFrameThk / 2 * bFrontPartitions) * (deskNumber = 1) - partitionFrameThk / 2 + partitionFrameThk / 2 * NOT(bFrontPartitions)
			else
				add2 partitionFrameThk / 2,
				(partLength[4] / 2 + partitionFrameThk * bFrontPartitions) * (deskNumber = 1)
			endif
		else
			if iPartitionPos = PARPOS_BETW_D then
				add2 partitionFrameThk / 2 - deskDist * (deskNumber = 1) + partitionFrameThk / 2 * NOT(bFrontPartitions) * (deskNumber > 1),
				deskDist2 - partitionFrameThk / 2 + (partitionFrameThk / 2 - partLength[4] / 2 - partitionFrameThk * bFrontPartitions) * (deskNumber = 1)\
				+ partitionFrameThk * NOT(bFrontPartitions) * (deskNumber > 1)
			else
				add2 (partitionFrameThk / 2 - deskDist) * (deskNumber = 1),
				deskDist2 - partitionFrameThk / 2 + (partitionFrameThk / 2 - partLength[4] / 2 - partitionFrameThk * bFrontPartitions) * (deskNumber = 1)
			endif
		endif

		bShowPartEdgeLeft	= NOT(bFrontPartitions)
		bShowPartEdgeRight	= 1
		bCalledAsExtension	= (deskNumber > 1)
		anglePartititon		= 90 * bDeskNumLeftIsEven - 90 * NOT(bDeskNumLeftIsEven) * (deskNumber = 1)

		gosub "leftEndPartition"

		del 1
	endif

	!!!Right End Partition and Partition Column
	if bEndPartitions2 then
		if bDeskNumLeftIsEven then
			rightEndPartPosX = deskDist * (INT(deskNumber / 2) + (deskNumber = 1))
			rightEndPartPosY = -deskDist2 * (CEIL(deskNumber / 2) - 1) + tableDepth1 / 2 * (deskNumber = 1)
			if iPartitionPos = PARPOS_BETW_D then
				rightEndPartPosmodX = partitionFrameThk / 2 - partitionFrameThk * NOT(bEndPartitions1) + partitionFrameThk * NOT(bFrontPartitions)\
									- partitionFrameThk / 2 * NOT(bFrontPartitions) * (NOT(bDeskNumberIsEven) * (deskNumber > 3) + (deskNumber = 3))
				rightEndPartPosmodY = -partitionFrameThk / 2 + partitionFrameThk / 2 * ((deskNumber = 1) * bFrontPartitions + (deskNumber < 3) * NOT(bFrontPartitions))\
									+ partitionFrameThk / 2 * NOT(bFrontPartitions) * bDeskNumberIsEven * (deskNumber > 3)
			else
				rightEndPartPosmodX = -partitionFrameThk / 2 * bDeskNumberIsEven - partitionFrameThk / 2 * (deskNumber = 1)
				rightEndPartPosmodY = partitionFrameThk / 2 * NOT(bDeskNumberIsEven) * ((deskNumber > 1) + (deskNumber = 1) * bFrontPartitions)
			endif
		else
			rightEndPartPosX = deskDist * (CEIL(deskNumber / 2) - 1)
			rightEndPartPosY = -deskDist2 * (INT(deskNumber / 2) - 1) * (deskNumber > 1) + partLength[3] / 2 * (deskNumber = 1)
			if iPartitionPos = PARPOS_BETW_D then
				rightEndPartPosmodX = partitionFrameThk / 2 - partitionFrameThk * NOT(bEndPartitions1)\
									+ partitionFrameThk * NOT(bFrontPartitions) * NOT(bDeskNumberIsEven)\
									+ partitionFrameThk / 2 * NOT(bFrontPartitions) * bDeskNumberIsEven

				rightEndPartPosmodY = -partitionFrameThk / 2 + partitionFrameThk / 2 * (deskNumber = 1) * bFrontPartitions\
									+ partitionFrameThk / 2 * NOT(bFrontPartitions) * NOT(bDeskNumberIsEven)
			else
				rightEndPartPosmodX = -partitionFrameThk / 2 * NOT(bDeskNumberIsEven)
				rightEndPartPosmodY = partitionFrameThk / 2 * bDeskNumberIsEven
			endif
		endif

		add2 rightEndPartPosX + rightEndPartPosmodX, rightEndPartPosY + rightEndPartPosmodY

		!!!Right End Column if deskNumber = 1
		if (deskNumber = 1) * bFrontPartitions then
			add2 0, partLength[3] / 2 * NOT(bDeskNumLeftIsEven) - (partitionFrameThk + partLength[3] / 2) * bDeskNumLeftIsEven + partitionFrameThk / 2
				if bDeskNumLeftIsEven then
					bShowPartEdgeTop	= 0
					bShowPartEdgeLeft	= 0
					bShowPartEdgeBottom	= 1
					bShowPartEdgeRight	= 1
				else
					bShowPartEdgeTop	= 1
					bShowPartEdgeLeft	= 0
					bShowPartEdgeBottom	= 0
					bShowPartEdgeRight	= 1
				endif
				bPartColumnCover	= 0
				bOnlyPartitionCover	= bPartColumnCover * NOT(bFrontPartitions)
				gosub "partitionColumn"
			del 1
		endif

		if bDeskNumLeftIsEven then
			if (deskNumber > 1) then
				rot2 -90 * bDeskNumberIsEven
				mul2 1, 1 - 2 * NOT(bDeskNumberIsEven)
			endif
		else
			if (deskNumber > 1) then
				rot2 90 * NOT(bDeskNumberIsEven) + 180 * bDeskNumberIsEven
				mul2 1, 1 - 2 * NOT(bDeskNumberIsEven)
			endif
		endif

		bShowPartEdgeLeft	= NOT(bFrontPartitions)
		bShowPartEdgeRight	= 1
		bCalledAsExtension	= (deskNumber > 1)
		anglePartititon		= (90 * bDeskNumLeftIsEven - 90 * NOT(bDeskNumLeftIsEven)) * (deskNumber = 1)

		gosub "rightEndPartition"

		del 2 * (deskNumber > 1)

		del 1
	endif

	!!!Front Partitions
	if bFrontPartitions then
		if bDeskNumLeftIsEven then
			frontPartNum	= INT(deskNumber / 2) + (deskNumber = 1)
		else
			frontPartNum	= CEIL(deskNumber / 2) - 1 + (deskNumber = 1)
		endif

		add2 0, -partitionFrameThk / 2 * (iPartitionPos = PARPOS_BETW_D)

		for iPa = 1 to frontPartNum
			if iPa = 1 then
				if bDeskNumLeftIsEven then
					if iPartitionPos = PARPOS_BETW_D then
						frontPartLength = partLength[1]
						add2 frontPartLength / 2 + partitionFrameThk * bEndPartitions1, 0
					else
						frontPartLength = partLength[1] + partitionFrameThk * NOT(bEndPartitions1) - partitionFrameThk / 2 * (deskNumber > 2) - partitionFrameThk * bEndPartitions2 * (deskNumber < 3)
						add2 frontPartLength / 2 + partitionFrameThk - partitionFrameThk * NOT(bEndPartitions1), partitionFrameThk / 2 * (deskNumber = 1)
					endif
				else
					if iPartitionPos = PARPOS_BETW_D then
						frontPartLength = partLength[1]
						add2 frontPartLength / 2 + partitionFrameThk * bEndPartitions1 * (deskNumber > 1) - (frontPartLength + partitionFrameThk * NOT(bEndPartitions1)) * (deskNumber = 1),
						deskDist2 * (deskNumber = 1)
					else
						frontPartLength = partLength[1] + (partitionFrameThk - partitionFrameThk * bEndPartitions1 - partitionFrameThk * bEndPartitions2) * (deskNumber = 1)\
										+ (partitionFrameThk / 2 * NOT(bEndPartitions2) - partitionFrameThk / 2 * bEndPartitions2) * (deskNumber = 3)
						add2 frontPartLength / 2 + partitionFrameThk / 2 - (frontPartLength + partitionFrameThk / 2 + partitionFrameThk * bEndPartitions2) * (deskNumber = 1),
						(deskDist2 - partitionFrameThk / 2) * (deskNumber = 1)
					endif
				endif
			endif
			if iPa > 1 and iPa < frontPartNum then
				if iPartitionPos = PARPOS_BETW_D then
					frontPartLength = partLength[1]
					add2 frontPartLength / 2 + partitionFrameThk * bEndPartitions1, 0
				else
					frontPartLength = partLength[1]
					add2 frontPartLength / 2 + partitionFrameThk / 2, 0
				endif
			endif
			if iPa > 1 and iPa = frontPartNum then
				if bDeskNumLeftIsEven then
					if iPartitionPos = PARPOS_BETW_D then
						frontPartLength = partLength[1]
						add2 frontPartLength / 2 + partitionFrameThk * bEndPartitions1, 0
					else
						frontPartLength = partLength[1] + (partitionFrameThk * NOT(bEndPartitions2) - partitionFrameThk / 2) * bDeskNumberIsEven
						add2 frontPartLength / 2 + partitionFrameThk / 2, 0
					endif
				else
					if iPartitionPos = PARPOS_BETW_D then
						frontPartLength = partLength[1]
						add2 frontPartLength / 2 + partitionFrameThk * bEndPartitions1, 0
					else
						frontPartLength = partLength[1] + (partitionFrameThk * NOT(bEndPartitions2) - partitionFrameThk / 2) * NOT(bDeskNumberIsEven)
						add2 frontPartLength / 2 + partitionFrameThk / 2, 0
					endif
				endif
			endif

			if bDeskNumLeftIsEven then
				bShowPartEdgeRight	= NOT(bEndPartitions2) * (iPa = frontPartNum) * (bDeskNumberIsEven or (deskNumber = 1))
				bShowPartEdgeLeft	= NOT(bEndPartitions1) * (iPa = 1)
			else
				bShowPartEdgeRight	= NOT(bEndPartitions2) * (iPa = frontPartNum) * NOT(bDeskNumberIsEven)
				bShowPartEdgeLeft	= NOT(bEndPartitions1) * (deskNumber = 1)
			endif

			gosub "frontPartition"

			del 1

			add2 deskDist, -deskDist2

		next iPa
		del frontPartNum

		del 1
	endif

	!!!Side Partitions
	if bFrontPartitions then
		if bDeskNumLeftIsEven then
			sidePartNum	= CEIL(deskNumber / 2) - 1
		else
			sidePartNum	= INT(deskNumber / 2)
		endif

		add2 deskDist * bDeskNumLeftIsEven, deskDist2 * NOT(bDeskNumLeftIsEven)
		if iPartitionPos = PARPOS_BETW_D then
			if bEndPartitions1 then
				add2 partitionFrameThk / 2, 0
			else
				add2 -partitionFrameThk / 2, 0
			endif
		endif

		for iPa = 1 to sidePartNum
			if bDeskNumLeftIsEven then
				if iPartitionPos = PARPOS_BETW_D then
					sidePartLength	= partLength[2]
					add2	0, -sidePartLength / 2 - partitionFrameThk
				else
					sidePartLength	= partLength[2] + (partitionFrameThk * NOT(bEndPartitions2) - partitionFrameThk / 2) * NOT(bDeskNumberIsEven) * (iPa = sidePartNum)
					add2	0, -sidePartLength / 2 - partitionFrameThk / 2
				endif
			else
				if iPartitionPos = PARPOS_BETW_D then
					sidePartLength	= partLength[2]
					add2	0, -sidePartLength / 2 - partitionFrameThk
				else
					if iPa = 1 then
						sidePartLength	= partLength[2] - partitionFrameThk / 2 + partitionFrameThk * NOT(bEndPartitions1)\
										+ (partitionFrameThk / 2 * NOT(bEndPartitions2) - partitionFrameThk / 2 * bEndPartitions2) * (deskNumber < 3)
						add2	0, -sidePartLength / 2 - partitionFrameThk * (bEndPartitions1)
					endif
					if iPa > 1 and iPa < sidePartNum then
						sidePartLength	= partLength[2]
						add2	0, -sidePartLength / 2 - partitionFrameThk / 2
					endif
					if iPa > 1 and iPa = sidePartNum then
						sidePartLength	= partLength[2] + (partitionFrameThk * NOT(bEndPartitions2) - partitionFrameThk / 2) * bDeskNumberIsEven
						add2	0, -sidePartLength / 2 - partitionFrameThk / 2
					endif
				endif
			endif

			if bDeskNumLeftIsEven then
				bShowPartEdgeLeft	= NOT(bEndPartitions2) * (iPa = sidePartNum) * NOT(bDeskNumberIsEven)
				bShowPartEdgeRight	= 0
			else
				bShowPartEdgeLeft	= NOT(bEndPartitions2) * (iPa = sidePartNum) * bDeskNumberIsEven
				bShowPartEdgeRight	= NOT(bEndPartitions1) * (iPa = 1)
			endif
			bOnlyPartitionCover	= NOT(bFrontPartitions)

			gosub "sidePartition"

			del 1
		add2 deskDist, -deskDist2
		next iPa
		del sidePartNum

		del 1 + (iPartitionPos = PARPOS_BETW_D)
	endif

	!!!Internal Partition Columns
	if bFrontPartitions then
		if bDeskNumLeftIsEven then
			colNumInTopRow		= CEIL(deskNumber / 2) - 1
			colNumInBottomRow	= INT(deskNumber / 2) - 1
		else
			colNumInTopRow		= INT(deskNumber / 2) - 1
			colNumInBottomRow	= CEIL(deskNumber / 2) - 1
		endif

		if deskNumber > 1 then
			for iPaTop = 1 to colNumInTopRow

				if iPartitionPos = PARPOS_BETW_D then
					add2	deskDist + partitionFrameThk / 2 * (bEndPartitions1) - partitionFrameThk / 2 * NOT(bEndPartitions1), -partitionFrameThk / 2
				else
					add2	deskDist, 0
				endif

				bPartColumnCover	= 1
				bShowPartEdgeTop	= 1
				bShowPartEdgeLeft	= 0
				bShowPartEdgeBottom	= 0
				bShowPartEdgeRight	= 1
				bOnlyPartitionCover	= bPartColumnCover * NOT(bFrontPartitions)

				gosub "partitionColumn"

				del 1

			add2 deskDist, -deskDist2
			next iPaTop
			del colNumInTopRow

			for iPaBottom = 1 to colNumInBottomRow

				if iPartitionPos = PARPOS_BETW_D then
					add2 deskDist * bDeskNumLeftIsEven + partitionFrameThk / 2 * (bEndPartitions1) - partitionFrameThk / 2 * NOT(bEndPartitions1),
					-deskDist2 * bDeskNumLeftIsEven - partitionFrameThk / 2
				else
					add2 deskDist * bDeskNumLeftIsEven, -deskDist2 * bDeskNumLeftIsEven
				endif

				bPartColumnCover	= 1
				bShowPartEdgeTop	= 0
				bShowPartEdgeLeft	= 1
				bShowPartEdgeBottom	= 1
				bShowPartEdgeRight	= 0
				bOnlyPartitionCover	= bPartColumnCover * NOT(bFrontPartitions)

				gosub "partitionColumn"

				del 1

			add2 deskDist, -deskDist2
			next iPaBottom
			del colNumInBottomRow
		endif
	endif
endif

if iLayoutType = LAYOUT_WAVE then del 3

! ======================================================================
! Minimal Space
! ======================================================================

reqBMinSpace = 0
minSpaceUnID = 3000
call "fa_minimalspace" parameters all MSType = 0, unID = 3000,
							returned_parameters reqBMinSpace,
												MSFillType,
												MSFillPen,
												MSFillBackPen,
												MSContLineType,
												MSContLinePen

if reqBMinSpace <> 0 then
	drawindex 10
	FILL MSFillType
	pen MSContLinePen
	line_type MSContLineType

	if iLayoutType = LAYOUT_STRAIGHT or ((iLayoutType = LAYOUT_CUBICLE) and (iArrangement = ARRANGE_MIRR)) then
		poly2_b 4, 1+2+4+64, MSFillPen, MSFillBackPen,
			minSpaceRightSideDimA, minSpaceTopSideDimB, 1,
			minSpaceRightSideDimA, -minSpaceBottomSideDimB, 1,
			-minSpaceLeftSideDimA, -minSpaceBottomSideDimB, 1,
			-minSpaceLeftSideDimA, minSpaceTopSideDimB, 1

		hotspot2 minSpaceRightSideDimA, minSpaceTopSideDimB,		minSpaceUnID : minSpaceUnID = minSpaceUnID + 1
		hotspot2 minSpaceRightSideDimA, -minSpaceBottomSideDimB,	minSpaceUnID : minSpaceUnID = minSpaceUnID + 1
		hotspot2 -minSpaceLeftSideDimA, -minSpaceBottomSideDimB,	minSpaceUnID : minSpaceUnID = minSpaceUnID + 1
		hotspot2 -minSpaceLeftSideDimA, minSpaceTopSideDimB,		minSpaceUnID : minSpaceUnID = minSpaceUnID + 1
	endif
	if (iLayoutType = LAYOUT_CUBICLE) and (iArrangement = ARRANGE_ROT) then
		poly2_b 8, 1+2+4+64, MSFillPen, MSFillBackPen,
			minSpaceRightSideDimA, minSpaceTopSideDimB, 1,
			minSpaceRightSideDimA, 0, 1,
			layoutRightSideDimA + MSSide, 0, 1,
			layoutRightSideDimA + MSSide, -minSpaceBottomSideDimB, 1,
			-layoutLeftSideDimA - MSSide2, -minSpaceBottomSideDimB, 1,
			-layoutLeftSideDimA - MSSide2, 0, 1,
			-minSpaceLeftSideDimA, 0, 1,
			-minSpaceLeftSideDimA, minSpaceTopSideDimB, 1

		hotspot2 minSpaceRightSideDimA, minSpaceTopSideDimB,				minSpaceUnID : minSpaceUnID = minSpaceUnID + 1
		hotspot2 minSpaceRightSideDimA, 0,									minSpaceUnID : minSpaceUnID = minSpaceUnID + 1
		hotspot2 layoutRightSideDimA + MSSide, 0,							minSpaceUnID : minSpaceUnID = minSpaceUnID + 1
		hotspot2 layoutRightSideDimA + MSSide, -minSpaceBottomSideDimB,		minSpaceUnID : minSpaceUnID = minSpaceUnID + 1
		hotspot2 -layoutLeftSideDimA - MSSide2, -minSpaceBottomSideDimB,	minSpaceUnID : minSpaceUnID = minSpaceUnID + 1
		hotspot2 -layoutLeftSideDimA - MSSide2, 0,							minSpaceUnID : minSpaceUnID = minSpaceUnID + 1
		hotspot2 -minSpaceLeftSideDimA, 0,									minSpaceUnID : minSpaceUnID = minSpaceUnID + 1
		hotspot2 -minSpaceLeftSideDimA, minSpaceTopSideDimB,				minSpaceUnID : minSpaceUnID = minSpaceUnID + 1
	endif
	if iLayoutType = LAYOUT_WAVE then
		rot2 axisAngle
			poly2_b 6, 1+2+4+64, MSFillPen, MSFillBackPen,
				-layoutLeftSideDimA - MSSide * COS(diagonalAngle) - MSSide2 * SIN(diagonalAngle),
				contourPointLeft - MSSide * SIN(diagonalAngle) + MSSide2 * COS(diagonalAngle), 1,

				-layoutLeftSideDimA + contourPointTopLeft + MSFront * TAN(minSpaceBetaTopLeft),
				layoutTopSideDimB + MSFront, 1,

				layoutRightSideDimA - contourPointTopRight - MSFront * TAN(minSpaceBetaTopRight),
				layoutTopSideDimB + MSFront, 1,

				layoutRightSideDimA + MSSide * COS(diagonalAngle) + MSSide2 * SIN(diagonalAngle),
				contourPointRight + MSSide * SIN(diagonalAngle) - MSSide2 * COS(diagonalAngle), 1,

				layoutRightSideDimA - contourPointBottomRight - MSFront * TAN(minSpaceBetaBottomRight),
				-layoutBottomSideDimB - MSFront, 1,

				-layoutLeftSideDimA + contourPointBottomLeft + MSFront * TAN(minSpaceBetaBottomLeft),
				-layoutBottomSideDimB - MSFront, 1

			hotspot2 -layoutLeftSideDimA - MSSide * COS(diagonalAngle) - MSSide2 * SIN(diagonalAngle),
				contourPointLeft - MSSide * SIN(diagonalAngle) + MSSide2 * COS(diagonalAngle),	minSpaceUnID : minSpaceUnID = minSpaceUnID + 1

			hotspot2 -layoutLeftSideDimA + contourPointTopLeft + MSFront * TAN(minSpaceBetaTopLeft),
				layoutTopSideDimB + MSFront, 													minSpaceUnID : minSpaceUnID = minSpaceUnID + 1

			hotspot2 layoutRightSideDimA - contourPointTopRight - MSFront * TAN(minSpaceBetaTopRight),
				layoutTopSideDimB + MSFront,													minSpaceUnID : minSpaceUnID = minSpaceUnID + 1

			hotspot2 layoutRightSideDimA + MSSide * COS(diagonalAngle) + MSSide2 * SIN(diagonalAngle),
				contourPointRight + MSSide * SIN(diagonalAngle) - MSSide2 * COS(diagonalAngle),	minSpaceUnID : minSpaceUnID = minSpaceUnID + 1

			hotspot2 layoutRightSideDimA - contourPointBottomRight - MSFront * TAN(minSpaceBetaBottomRight),
				-layoutBottomSideDimB - MSFront,												minSpaceUnID : minSpaceUnID = minSpaceUnID + 1

			hotspot2 -layoutLeftSideDimA + contourPointBottomLeft + MSFront * TAN(minSpaceBetaBottomLeft),
				-layoutBottomSideDimB - MSFront,												minSpaceUnID : minSpaceUnID = minSpaceUnID + 1
		del 1
	endif

	line_type 1
endif

if iLayoutType = LAYOUT_WAVE then del 1

! ======================================================================
end
! ======================================================================



"desk":
	call "completeTable_m" parameters all	iTableTopType			= 1 + (iLayoutType = LAYOUT_STRAIGHT),
											iDeskAngle				= iDeskAngle,
											bCalledAsExtension		= 0,
											bPartOfLayout			= 1,
											bPartOfWsSolo			= 0,
											bChair					= 1,
											bEnableDeskHsCorner		= 0,
											bEnableDeskHsHalfEdge	= 0,
											bEnableDeskHsEditingX	= (iDe = 1) * (iRow = 1) * (iSizing = SIZING_WS_SIZE),
											bEnableDeskHsEditingY	= (iDe = 1) * (iRow = 1),
											bEnableDeskHsEditingC	= (iDe = 1) * (iRow = 1),
											bEnableChairHsEditing 	= (iDe = 1) * (iRow = 1),
											bMirroredComputer		= bMirroredComputer,
											bMirroredCabPos			= bMirroredCabPos,
											chairPos				= chairPos,
											zzyzx					= tableTopHeight,
											completeTable_unID		= unID,
											stSymbolTypes			= stSymbolTypes,
											returned_parameters completeTable_unID
	unID = completeTable_unID
	if iLayoutType = 1 then
		hotspot2 tableLength1 / 2, tableDepth1 / 2, centerunID : centerunID = centerunID + 1
	endif
return

"extension":
	call "deskClosings_m" parameters all	iExtensionType			= iExtType,
											partitionFrameThk		= partitionFrameThk,
											bSymmetricalDeskEnd		= bSymmetricalDeskEnd,
											extRoundedRad			= extRoundedRad,
											bCalledAsExtension		= 1,
											bPartOfLayout			= 1,
											bPartOfWsSolo			= 0,
											bPartColumnCut			= bPartColumnCut,
											partColumnCutWidth		= partitionFrameThk,
											anglePartititon			= 0,
											xPartOrigPos			= 0,
											yPartOrigPos			= 0,
											iExtraDeskCab			= iExtraDeskCab * bShowCabParams,
											deskClosings_unID		= unID,
											stSymbolTypes			= stSymbolTypes,
											returned_parameters deskClosings_unID
	unID = deskClosings_unID
	if iExtType = 2 or iExtType = 3 then
		hotspot2 0, extraDeskDepth / 2, centerunID : centerunID = centerunID + 1
	endif
return

"leftEndPartition":
	call "deskClosings_m" parameters all	iExtensionType			= DESK_PARTITION,
											partitionFrameThk		= partitionFrameThk,
											iDeskAngle				= iDeskAngle,
											bCalledAsExtension		= bCalledAsExtension,
											bPartOfLayout			= 1,
											bPartOfWsSolo			= 0,
											lengthPartition			= partLength[4],
											extPartLengthStart		= extPartLengthStart[4],
											extPartLengthEnd		= extPartLengthEnd[4],
											bShowExtPartConnEdge	= NOT(bFrontPartitions),
											bShowPartEdgeLeft		= bShowPartEdgeLeft,
											bShowPartEdgeRight		= bShowPartEdgeRight,
											anglePartititon			= anglePartititon,
											xPartOrigPos			= 0,
											yPartOrigPos			= 0,
											deskClosings_unID		= unID,
											stSymbolTypes			= stSymbolTypes,
											returned_parameters deskClosings_unID
	unID = deskClosings_unID
return

"rightEndPartition":
	call "deskClosings_m" parameters all	iExtensionType			= DESK_PARTITION,
											partitionFrameThk		= partitionFrameThk,
											iDeskAngle				= iDeskAngle,
											bCalledAsExtension		= bCalledAsExtension,
											bPartOfLayout			= 1,
											bPartOfWsSolo			= 0,
											lengthPartition			= partLength[3],
											extPartLengthStart		= extPartLengthStart[3],
											extPartLengthEnd		= extPartLengthEnd[3],
											bShowExtPartConnEdge	= NOT(bFrontPartitions),
											bShowPartEdgeLeft		= bShowPartEdgeLeft,
											bShowPartEdgeRight		= bShowPartEdgeRight,
											anglePartititon			= anglePartititon,
											xPartOrigPos			= 0,
											yPartOrigPos			= 0,
											deskClosings_unID		= unID,
											stSymbolTypes			= stSymbolTypes,
											returned_parameters deskClosings_unID
	unID = deskClosings_unID
return

"frontPartition":
	call "deskClosings_m" parameters all	iExtensionType			= DESK_PARTITION,
											partitionFrameThk		= partitionFrameThk,
											iDeskAngle				= iDeskAngle,
											bCalledAsExtension		= 0,
											bPartOfLayout			= 1,
											bPartOfWsSolo			= 0,
											bOnlyPartitionColumn	= 0,
											bOnlyPartitionCover		= NOT(bFrontPartitions),
											lengthPartition			= frontPartLength,
											bShowPartEdgeLeft		= bShowPartEdgeLeft,
											bShowPartEdgeRight		= bShowPartEdgeRight,
											anglePartititon			= 0,
											xPartOrigPos			= 0,
											yPartOrigPos			= 0,
											deskClosings_unID		= unID,
											stSymbolTypes			= stSymbolTypes,
											returned_parameters deskClosings_unID
	unID = deskClosings_unID
return

"sidePartition":
	call "deskClosings_m" parameters all	iExtensionType			= DESK_PARTITION,
											partitionFrameThk		= partitionFrameThk,
											iDeskAngle				= iDeskAngle,
											bCalledAsExtension		= 0,
											bPartOfLayout			= 1,
											bPartOfWsSolo			= 0,
											bOnlyPartitionColumn	= 0,
											bOnlyPartitionCover		= bOnlyPartitionCover,
											lengthPartition			= sidePartLength,
											bShowPartEdgeLeft		= bShowPartEdgeLeft,
											bShowPartEdgeRight		= bShowPartEdgeRight,
											anglePartititon			= 90,
											xPartOrigPos			= 0,
											yPartOrigPos			= 0,
											deskClosings_unID		= unID,
											stSymbolTypes			= stSymbolTypes,
											returned_parameters deskClosings_unID
	unID = deskClosings_unID
return

"partitionColumn":
	call "deskClosings_m" parameters all	iExtensionType			= DESK_PARTITION,
											partitionFrameThk		= partitionFrameThk,
											iDeskAngle				= iDeskAngle,
											bCalledAsExtension		= 1,
											bPartOfLayout			= 1,
											bPartOfWsSolo			= 0,
											bOnlyPartitionColumn	= 1,
											bOnlyPartitionCover		= bOnlyPartitionCover,
											bShowPartEdgeTop		= bShowPartEdgeTop,
											bShowPartEdgeLeft		= bShowPartEdgeLeft,
											bShowPartEdgeBottom		= bShowPartEdgeBottom,
											bShowPartEdgeRight		= bShowPartEdgeRight,
											deskClosings_unID		= unID,
											stSymbolTypes			= stSymbolTypes,
											returned_parameters deskClosings_unID
	unID = deskClosings_unID
return

]]>
</Script_2D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_1D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
EPS = 0.0001

partitionFrameThk	= 0.03
maxDeskNumberByWave	= 20

CABINET				= 0
SIMPLE_DESK			= 1
LAYOUT_ISLAND		= 2
LAYOUT_LINEAR		= 3
WS_SOLO				= 4

dim	stLayoutType[3]
	stLayoutType[1] = `Прямой`
	stLayoutType[2] = `Кубическая`
	stLayoutType[3] = `Волна`

LAYOUT_STRAIGHT	= 1
LAYOUT_CUBICLE	= 2
LAYOUT_WAVE		= 3

dim	stArrangement[2]
	stArrangement[1] = `Зеркально`
	stArrangement[2] = `С Поворотом`

ARRANGE_MIRR	= 1
ARRANGE_ROT		= 2

dim	stSizing[2]
	stSizing[1] = `по Размеру Рабочего Места`
	stSizing[2] = `по Количество Рабочих Мест`

SIZING_WS_SIZE	= 1
SIZING_WS_COUNT	= 2

dim	stDeskSizing[2]
	stDeskSizing[1] = `Постоянный Угол`
	stDeskSizing[2] = `Постоянная Ориентация Стола`

DESKSIZING_FIX_AXIS	= 1
DESKSIZING_FIX_ORI	= 2

dim	stExtensionsType[6]
	stExtensionsType[1] = `Нет`
	stExtensionsType[2] = `Закругленный`
	stExtensionsType[3] = `Стол`
	stExtensionsType[4] = `Стол со Стулом`
	stExtensionsType[5] = `Тумбочка`
	stExtensionsType[6] = `Перегородка`

dim stSymbolTypes[16]
	stSymbolTypes[ 1] = `Круглый`
	stSymbolTypes[ 2] = `Круглый со Спинкой`
	stSymbolTypes[ 3] = `Прямоугольный`
	stSymbolTypes[ 4] = `Прямоугольный со Спинкой 1`
	stSymbolTypes[ 5] = `Трапециевидный`
	stSymbolTypes[ 6] = `Трапециевидный со Спинкой`
	stSymbolTypes[ 7] = `Криволинейный`
	stSymbolTypes[ 8] = `Криволинейный со Спинкой`
	stSymbolTypes[ 9] = `Прямоугольный со Спинкой 3`
	stSymbolTypes[10] = `Прямоугольный со Спинкой 2`
	stSymbolTypes[11] = `Круг со Спинкой 2`
	stSymbolTypes[12] = `Круглый со Спинкой 3`
	stSymbolTypes[13] = `Криволинейный со Спинкой 2`
	stSymbolTypes[14] = `Криволинейный со Спинкой 3`
	stSymbolTypes[15] = `Детальный 1`
	stSymbolTypes[16] = `Детальный 2`

EXT_NONE			= 0
EXT_ROUNDED			= 1
EXT_DESK			= 2
EXT_DESK_WCHAIR		= 3
EXT_CABINET			= 4
EXT_PARTITION		= 5
DESK_PARTITION		= 6

PARPOS_ABOVE_D		= 1
PARPOS_BETW_D		= 2

STRAIGHT			= 1
ROUNDED				= 2

DESK_L_SHAPED		= 1
DESK_STRAIGHT		= 2

OFFICECAB_NONE		= 0
OFFICECAB_SIDE1		= 1
OFFICECAB_SIDE2		= 2
OFFICECAB_BOTH		= 3

iTableTopType		= 1 + (iLayoutType = LAYOUT_STRAIGHT)

iDeskAngle			= 90

deskDiagonal		= SQR(tableLength1 ** 2 + tableLength2 ** 2)
diagonalAngle		= ATN(tableLength2 / tableLength1)

xPosSideCorner		= tableLength2 * COS(180 - iDeskAngle)
yPosSideCorner		= tableLength2 * SIN(180 - iDeskAngle) + partitionFrameThk * 2 * TAN(diagonalAngle) * bEndPartitions1 * (iPartitionPos = PARPOS_BETW_D)

callAnyPartition	= bFrontPartitions or bSidePartitions * NOT(iLayoutType = LAYOUT_WAVE) or bEndPartitions1 or bEndPartitions2

bSymmetricalDeskEnd	= (iLayoutType = LAYOUT_STRAIGHT) * bDoubleRow

bDeskNumberIsEven	= (deskNumber / 2 = INT(deskNumber / 2))

deskDist			= tableLength1 + partitionFrameThk * (iPartitionPos = PARPOS_BETW_D) * (bSidePartitions * (iLayoutType <> LAYOUT_WAVE) + bFrontPartitions * (iLayoutType = LAYOUT_WAVE))
deskDist2			= tableLength2 + partitionFrameThk * (iPartitionPos = PARPOS_BETW_D) * bFrontPartitions

if iLayoutType = LAYOUT_STRAIGHT then
	chairPos	= 1
else
	chairPos	= 2
endif

bDeskNumLeftIsEven	= (deskNumberLeft / 2 = INT(deskNumberLeft / 2))
bDeskNumRightIsEven	= (deskNumberRight / 2 = INT(deskNumberRight / 2))

bMirroredCabPos		= (iLayoutType <> LAYOUT_STRAIGHT)

!!!4	- Left End Partition
!!!2	- Side Partition
!!!1	- Front Partition
!!!3	- Right End Partition

dim	iExtensionType[4]
	iExtensionType[4]	= iExtensionTypeLeft
	iExtensionType[2]	= iExtensionTypeRight
	iExtensionType[1]	= iExtensionTypeTop
	iExtensionType[3]	= iExtensionTypeBottom

dim	extDistFromCenter[4]
if bSymmetricalDeskEnd then
	extDistFromCenter[4]	= 0
	extDistFromCenter[2]	= totalLength
	extDistFromCenter[1]	= 0
	extDistFromCenter[3]	= 0
else
	extDistFromCenter[4]	= 0
	extDistFromCenter[2]	= totalLength
	extDistFromCenter[1]	= deskDist
	extDistFromCenter[3]	= 0
endif

dim	layoutEndWidth[4]
	layoutEndWidth[4]		= tableDepth1 + (partitionFrameThk / 2 + partitionFrameThk / 2 * NOT(bSymmetricalDeskEnd)) * (iPartitionPos = PARPOS_BETW_D) * bFrontPartitions
	layoutEndWidth[2]		= tableDepth1 + (partitionFrameThk / 2 + partitionFrameThk / 2 * NOT(bSymmetricalDeskEnd)) * (iPartitionPos = PARPOS_BETW_D) * bFrontPartitions
	layoutEndWidth[1]		= MIN(tableDepth2, tableDepth1) * NOT(bSymmetricalDeskEnd) + tableDepth1 * bSymmetricalDeskEnd + partitionFrameThk * (iPartitionPos = PARPOS_BETW_D) * bFrontPartitions
	layoutEndWidth[3]		= MIN(tableDepth2, tableDepth1) * NOT(bSymmetricalDeskEnd) + tableDepth1 * bSymmetricalDeskEnd + partitionFrameThk * (iPartitionPos = PARPOS_BETW_D) * bFrontPartitions

dim	partLength[4]
partLengthMod = partitionFrameThk * NOT(bDoubleRow) * bFrontPartitions * (iPartitionPos = PARPOS_ABOVE_D)
if iLayoutType = LAYOUT_STRAIGHT then
	partLength[4] =	tableDepth1 - partLengthMod
	partLength[2] =	tableDepth1 - partLengthMod
	partLength[1] =	tableLength1
	partLength[3] =	tableDepth1 - partLengthMod
endif
if iLayoutType = LAYOUT_CUBICLE then
	partLength[4] =	tableLength2 - partLengthMod
	partLength[2] =	tableLength2 - partLengthMod
	partLength[1] =	tableLength1
	partLength[3] =	tableDepth1 - partLengthMod
endif
if iLayoutType = LAYOUT_WAVE then
	partLength[4] =	tableLength2 * bDeskNumLeftIsEven + tableDepth1 * NOT(bDeskNumLeftIsEven) - partitionFrameThk * (deskNumber = 1) * bFrontPartitions * (iPartitionPos = PARPOS_ABOVE_D)
	partLength[2] =	tableLength2 - partitionFrameThk * (iPartitionPos = PARPOS_ABOVE_D)
	partLength[1] =	tableLength1 - partitionFrameThk * (iPartitionPos = PARPOS_ABOVE_D)
	partLength[3] =	tableDepth1 * bDeskNumLeftIsEven + tableLength2 * NOT(bDeskNumLeftIsEven) - partitionFrameThk * (deskNumber = 1) * bFrontPartitions * (iPartitionPos = PARPOS_ABOVE_D)
endif

dim	extPartLengthStart[4]
dim	extPartLengthEnd[4]
extPartLengthMod = partitionFrameThk / 2 * (iPartitionPos = PARPOS_BETW_D) * bFrontPartitions
if iLayoutType = LAYOUT_STRAIGHT then
	extPartLengthStart[4]	= tableDepth1 + extPartLengthMod
	extPartLengthStart[2]	= tableDepth1 - partitionFrameThk / 2 + extPartLengthMod
	extPartLengthStart[1]	= tableDepth1
	extPartLengthStart[3]	= tableDepth1 + extPartLengthMod

	extPartLengthEnd[4]		= tableDepth1 + extPartLengthMod
	extPartLengthEnd[2]		= tableDepth1 + extPartLengthMod
	extPartLengthEnd[1]		= tableDepth1
	extPartLengthEnd[3]		= tableDepth1 + extPartLengthMod
endif
if iLayoutType = LAYOUT_CUBICLE then
	extPartLengthStart[4]	= tableDepth1 * (iArrangement = ARRANGE_ROT) + tableLength2 * (iArrangement = ARRANGE_MIRR) + extPartLengthMod
	extPartLengthStart[2]	= tableLength2 - partitionFrameThk / 2 + extPartLengthMod
	extPartLengthStart[1]	= tableDepth1
	extPartLengthStart[3]	= tableDepth1 + extPartLengthMod

	extPartLengthEnd[4]		= tableLength2 + extPartLengthMod
	extPartLengthEnd[2]		= tableDepth1
	extPartLengthEnd[1]		= tableDepth1
	extPartLengthEnd[3]		= tableDepth1 * (iArrangement = ARRANGE_MIRR) + tableLength2 * (iArrangement = ARRANGE_ROT) + extPartLengthMod
endif
if iLayoutType = LAYOUT_WAVE then
	if bDeskNumLeftIsEven then
		extPartLengthStart[4]	= tableDepth1 + extPartLengthMod
		extPartLengthStart[2]	= tableLength2 - partitionFrameThk * (iPartitionPos = PARPOS_ABOVE_D)
		extPartLengthStart[1]	= tableDepth1
		extPartLengthStart[3]	= tableDepth1 * bDeskNumberIsEven + tableDepth2 * NOT(bDeskNumberIsEven) + extPartLengthMod

		extPartLengthEnd[4]		= tableLength2 + extPartLengthMod
		extPartLengthEnd[2]		= tableDepth1
		extPartLengthEnd[1]		= tableDepth1
		extPartLengthEnd[3]		= tableLength2 * bDeskNumberIsEven + tableLength1 * NOT(bDeskNumberIsEven) + extPartLengthMod
	else
		extPartLengthStart[4]	= tableLength1 + extPartLengthMod
		extPartLengthStart[2]	= tableLength2 - partitionFrameThk * (iPartitionPos = PARPOS_ABOVE_D)
		extPartLengthStart[1]	= tableDepth1
		extPartLengthStart[3]	= tableLength1 * bDeskNumberIsEven + tableLength2 * NOT(bDeskNumberIsEven) + extPartLengthMod

		extPartLengthEnd[4]		= tableDepth2 + extPartLengthMod
		extPartLengthEnd[2]		= tableDepth1
		extPartLengthEnd[1]		= tableDepth1
		extPartLengthEnd[3]		= tableDepth2 * bDeskNumberIsEven + tableDepth1 * NOT(bDeskNumberIsEven) + extPartLengthMod
	endif
endif



! ======================================================================
! Calculation For Object Dimensions and Minimal Space
! ======================================================================

dim extHeight[4]
for iExtNum = 1 to 4
	if iExtensionType[iExtNum] = EXT_NONE then			extHeight[iExtNum] = 0
	if iExtensionType[iExtNum] = EXT_ROUNDED then		extHeight[iExtNum] = tableTopHeight
	if iExtensionType[iExtNum] = EXT_DESK then			extHeight[iExtNum] = tableTopHeight
	if iExtensionType[iExtNum] = EXT_DESK_WCHAIR then	extHeight[iExtNum] = tableTopHeight
	if iExtensionType[iExtNum] = EXT_CABINET then		extHeight[iExtNum] = extCabinetHeight
next iExtNum
maxExtHeight 	= MAX(extHeight[1], extHeight[2], extHeight[3], extHeight[4])
realPartHeight	= (gs_partitionHeight + tableTopHeight * (iPartitionPos = PARPOS_ABOVE_D)) * callAnyPartition

if iLayoutType <> LAYOUT_WAVE then
	dim extWidth[4]
	for iExtNum = 1 to 2
		if iExtensionType[iExtNum * 2] = EXT_NONE then			extWidth[iExtNum * 2] = 0
		if iExtensionType[iExtNum * 2] = EXT_ROUNDED then		extWidth[iExtNum * 2] = layoutEndWidth[iExtNum * 2]
		if iExtensionType[iExtNum * 2] = EXT_DESK then			extWidth[iExtNum * 2] = extraDeskDepth
		if iExtensionType[iExtNum * 2] = EXT_DESK_WCHAIR then	extWidth[iExtNum * 2] = extraDeskDepth
		if iExtensionType[iExtNum * 2] = EXT_CABINET then		extWidth[iExtNum * 2] = extCabinetWidth
	next iExtNum
	extWidthRight			= extWidth[2]
	extWidthLeft			= extWidth[4]

	dim extDepth[4]
	for iExtNum = 1 to 2
		if iExtensionType[iExtNum * 2] = EXT_NONE then			extDepth[iExtNum * 2] = 0
		if iExtensionType[iExtNum * 2] = EXT_ROUNDED then		extDepth[iExtNum * 2] = layoutEndWidth[iExtNum * 2]
		if iExtensionType[iExtNum * 2] = EXT_DESK then			extDepth[iExtNum * 2] = extraDeskWidth / 2
		if iExtensionType[iExtNum * 2] = EXT_DESK_WCHAIR then	extDepth[iExtNum * 2] = extraDeskWidth / 2
		if iExtensionType[iExtNum * 2] = EXT_CABINET then		extDepth[iExtNum * 2] = extCabinetDepth
	next iExtNum
	extDepthRight			= extDepth[2]
	extDepthLeft			= extDepth[4]

	deskGroupLeftSideDimA	=	0
	deskGroupRightSideDimA	=	totalLength
	deskGroupDimA			=	deskGroupLeftSideDimA + deskGroupRightSideDimA

	if iLayoutType = LAYOUT_STRAIGHT then
		deskGroupTopSideDimB	=	tableDepth1 + (partitionFrameThk * NOT(bDoubleRow) + partitionFrameThk / 2 * bDoubleRow) * (iPartitionPos = PARPOS_BETW_D) * bFrontPartitions
		deskGroupBottomSideDimB	=	(tableDepth1 + extPartLengthMod) * bDoubleRow
	endif
	if iLayoutType = LAYOUT_CUBICLE then
		deskGroupTopSideDimB	=	tableLength2 + (partitionFrameThk * NOT(bDoubleRow) + partitionFrameThk / 2 * bDoubleRow) * (iPartitionPos = PARPOS_BETW_D) * bFrontPartitions
		deskGroupBottomSideDimB	=	(tableLength2 + extPartLengthMod) * bDoubleRow
	endif
	deskGroupDimB			=	deskGroupTopSideDimB + deskGroupBottomSideDimB

	layoutLeftSideDimA		=	deskGroupLeftSideDimA + extWidthLeft
	layoutRightSideDimA		=	deskGroupRightSideDimA + extWidthRight
	layoutTopSideDimB		=	MAX(deskGroupTopSideDimB, extDepthLeft, extDepthRight)
	layoutBottomSideDimB	=	MAX(deskGroupBottomSideDimB, extDepthLeft, extDepthRight)

	minSpaceLeftSideDimA	=	layoutLeftSideDimA + MSSide
	minSpaceRightSideDimA	=	layoutRightSideDimA + MSSide2
	minSpaceTopSideDimB		=	deskGroupTopSideDimB + MSFront
	minSpaceBottomSideDimB	=	deskGroupBottomSideDimB + MSFront
else
	cabDiagonal				=	SQR(extCabinetDepth ** 2 + extCabinetWidth ** 2)
	cabAngle				=	ATN(extCabinetDepth / extCabinetWidth)

	dim extDepth[4]
	for iExtNum = 1 to 2
		if iExtensionType[iExtNum * 2 - 1] = EXT_NONE then			extDepth[iExtNum * 2 - 1] = 0
		if iExtensionType[iExtNum * 2 - 1] = EXT_ROUNDED then		extDepth[iExtNum * 2 - 1] = layoutEndWidth[iExtNum * 2 - 1]
		if iExtensionType[iExtNum * 2 - 1] = EXT_DESK then			extDepth[iExtNum * 2 - 1] = 0
		if iExtensionType[iExtNum * 2 - 1] = EXT_DESK_WCHAIR then	extDepth[iExtNum * 2 - 1] = 0
		if iExtensionType[iExtNum * 2 - 1] = EXT_CABINET then		extDepth[iExtNum * 2 - 1] = cabDiagonal * SIN(cabAngle + (90 - totalAngle))
	next iExtNum
	extDepthTop				= extDepth[1]
	extDepthBottom			= extDepth[3]

	if bDeskNumLeftIsEven then
		deskGroupLeftSideDimA	=	tableLength2 / 2 * SIN(diagonalAngle)
	else
		deskGroupLeftSideDimA	=	tableLength1 / 2 * COS(diagonalAngle)
	endif
	if bDeskNumRightIsEven then
		deskGroupRightSideDimA	=	totalLength + tableLength2 / 2 * SIN(diagonalAngle)
	else
		deskGroupRightSideDimA	=	totalLength + (tableLength1 / 2) * COS(diagonalAngle)
	endif
	deskGroupTopSideDimB		=	MAX(tableLength2 / 2 * COS(diagonalAngle) + MAX(tableDepth2 * SIN(diagonalAngle), extDepthTop), tableLength1 * SIN(diagonalAngle) + MAX(tableDepth1 * COS(diagonalAngle), extDepthTop) - tableLength2 / 2 * COS(diagonalAngle))
	if deskNUmber = 1 then
		deskGroupBottomSideDimB	=	tableLength2 / 2 * COS(diagonalAngle)
	else
		deskGroupBottomSideDimB	=	MAX(tableLength2 / 2 * COS(diagonalAngle) + MAX(tableDepth2 * SIN(diagonalAngle), extDepthBottom),\
									tableLength1 * SIN(diagonalAngle) + MAX(tableDepth1 * COS(diagonalAngle), extDepthBottom) - tableLength2 / 2 * COS(diagonalAngle))
	endif


	if bDeskNumLeftIsEven then
		contourPointLeft			= tableLength2 / 2 * COS(diagonalAngle)

		contourPointTopLeft			= -tableLength2 / 2 * COS(diagonalAngle) / TAN(diagonalAngle) + deskGroupTopSideDimB / TAN(diagonalAngle)
		contourPointBottomLeft		= tableLength2 / 2 * SIN(diagonalAngle) + deskGroupBottomSideDimB * TAN(diagonalAngle)
	else
		contourPointLeft			= -tableLength1 / 2 * SIN(diagonalAngle)

		contourPointTopLeft			= tableLength1 / 2 * COS(diagonalAngle) + deskGroupTopSideDimB / TAN(diagonalAngle)
		contourPointBottomLeft		= -tableLength1 / 2 * SIN(diagonalAngle) * TAN(diagonalAngle) + deskGroupBottomSideDimB * TAN(diagonalAngle)
	endif

	if bDeskNumRightIsEven then
		contourPointRight			= -tableLength2 / 2 * COS(diagonalAngle)

		contourPointTopRight		= tableLength2 / 2 * SIN(diagonalAngle) + deskGroupTopSideDimB * TAN(diagonalAngle)
		contourPointBottomRight		= -tableLength2 / 2 * COS(diagonalAngle) / TAN(diagonalAngle) + deskGroupBottomSideDimB / TAN(diagonalAngle)
	else
		contourPointRight			= tableLength1 / 2 * SIN(diagonalAngle)

		contourPointTopRight		= -tableLength1 / 2 * SIN(diagonalAngle) * TAN(diagonalAngle) + deskGroupTopSideDimB * TAN(diagonalAngle)
		contourPointBottomRight		= tableLength1 / 2 * COS(diagonalAngle) + deskGroupBottomSideDimB / TAN(diagonalAngle)
	endif

	layoutLeftSideDimA		=	deskGroupLeftSideDimA
	layoutRightSideDimA		=	deskGroupRightSideDimA
	layoutTopSideDimB		=	deskGroupTopSideDimB
	layoutBottomSideDimB	=	deskGroupBottomSideDimB



	minSpaceTopLeft			=	MAX(EPS, MSSide2)
	msAngle					=	180 - diagonalAngle
	minSpaceAlphaTopLeft	=	ATN(COS(msAngle - 90) / (MSFront / minSpaceTopLeft - SIN(msAngle - 90)))
	minSpaceBetaTopLeft		=	msAngle - 90 - minSpaceAlphaTopLeft

	minSpaceTopRight		=	MAX(EPS, MSSide)
	msAngle					=	90 + diagonalAngle
	minSpaceAlphaTopRight	=	ATN(COS(msAngle - 90) / (MSFront / minSpaceTopRight - SIN(msAngle - 90)))
	minSpaceBetaTopRight	=	msAngle - 90 - minSpaceAlphaTopRight

	minSpaceBottomLeft		=	MAX(EPS, MSSide)
	msAngle					=	90 + diagonalAngle
	minSpaceAlphaBottomLeft	=	ATN(COS(msAngle - 90) / (MSFront / minSpaceBottomLeft - SIN(msAngle - 90)))
	minSpaceBetaBottomLeft	=	msAngle - 90 - minSpaceAlphaBottomLeft

	minSpaceBottomRight		=	MAX(EPS, MSSide2)
	msAngle					=	180 - diagonalAngle
	minSpaceAlphaBottomRight=	ATN(COS(msAngle - 90) / (MSFront / minSpaceBottomRight - SIN(msAngle - 90)))
	minSpaceBetaBottomRight	=	msAngle - 90 - minSpaceAlphaBottomRight
endif




! ======================================================================
! For Parameter Locking and Hiding
! ======================================================================

bShowExtCabParams		= 0
bShowExtDeskParams		= 0
bShowExtDeskChairParams	= 0
for ii = 1 to 4
	if iExtensionType[ii] = EXT_CABINET then		bShowExtCabParams		= 1
	if iExtensionType[ii] = EXT_DESK_WCHAIR then	bShowExtDeskChairParams	= 1
	if iExtensionType[ii] = EXT_DESK then			bShowExtDeskParams 		= 1
	if iExtensionType[ii] = EXT_DESK_WCHAIR then	bShowExtDeskParams		= 1
next ii

bShowPartitionParams	=	bFrontPartitions or\
							bSidePartitions * (iLayoutType <> LAYOUT_WAVE) or\
							bEndPartitions1 or\
							bEndPartitions2
bShowCabParams			=	gs_bOfficeCab * (iTableTopType = DESK_L_SHAPED) or\
							(gs_officeCab_m > 0) * (iTableTopType = DESK_STRAIGHT)
bShowExtDeskCabParams	=	bShowExtDeskParams and (iExtraDeskCab > OFFICECAB_NONE) and bShowCabParams
bShowCommonCabParams	=	bShowExtCabParams or bShowExtDeskCabParams or bShowCabParams




]]>
</Script_1D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_VL SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
hideparameter all "A", "B", "ZZYZX"

call "FM_types" parameters all

! ======================================================================
! UI
! ======================================================================

call "ui_tabcontrol" parameters		controlType			= 1,
									nTabs				= 10,
									gs_ui_current_page	= gs_ui_current_page



! ======================================================================
! Object sizing
! ======================================================================

lock "deskNumberInRow"
if iLayoutType <> LAYOUT_WAVE then
	if GLOB_MODPAR_NAME = "bDoubleRow" then
		if NOT(bDoubleRow) then
			deskNumber = deskNumberInRow
			parameters deskNumber = deskNumber
		else
			deskNumber = deskNumberInRow * 2
			parameters deskNumber = deskNumber
		endif
	endif

	desklengthStart	= tableLength1 + (partitionFrameThk * bEndPartitions1 + partitionFrameThk * bEndPartitions2) * (iPartitionPos = PARPOS_BETW_D)
	deskLengthStep	= tableLength1 + partitionFrameThk * bSidePartitions * (iPartitionPos = PARPOS_BETW_D)

	if iSizing = SIZING_WS_SIZE then
		values "totalLength" range[desklengthStart,] step desklengthStart, deskLengthStep

		if GLOB_MODPAR_NAME = "totalLength" then
			parameters deskNumberInRow	=	totalLength / tableLength1 * (iPartitionPos = PARPOS_ABOVE_D)\
											+ (totalLength - partitionFrameThk * bEndPartitions1 - partitionFrameThk * bEndPartitions2 + partitionFrameThk * bSidePartitions) / (partitionFrameThk * bSidePartitions + tableLength1) * (iPartitionPos = PARPOS_BETW_D)

			parameters deskNumber		= deskNumberInRow * (1 + bDoubleRow)
		else
			parameters deskNumberInRow	= deskNumber / (1 + bDoubleRow)

			parameters totalLength		=	deskNumberInRow * tableLength1 * (iPartitionPos = PARPOS_ABOVE_D)\
											+ (deskNumberInRow * tableLength1 + (deskNumberInRow - 1) * partitionFrameThk * bSidePartitions + partitionFrameThk * bEndPartitions1 + partitionFrameThk * bEndPartitions2) * (iPartitionPos = PARPOS_BETW_D)
		endif

		lock		"totalLength"
	else
		if GLOB_MODPAR_NAME = "totalLength" then
			parameters tableLength1		=	totalLength / deskNumberInRow * (iPartitionPos = PARPOS_ABOVE_D)\
											+ (totalLength - partitionFrameThk * bEndPartitions1 - partitionFrameThk * bEndPartitions2\
											- (deskNumberInRow - 1) * partitionFrameThk * callAnyPartition) / deskNumberInRow * (iPartitionPos = PARPOS_BETW_D)
		else
			parameters deskNumberInRow	= deskNumber / (1 + bDoubleRow)

			if GLOB_MODPAR_NAME = "deskNumber" then
				parameters tableLength1	=	totalLength / deskNumberInRow * (iPartitionPos = PARPOS_ABOVE_D)\
											+ (totalLength - partitionFrameThk * bEndPartitions1 - partitionFrameThk * bEndPartitions2\
											- (deskNumberInRow - 1) * partitionFrameThk * bSidePartitions) / deskNumberInRow * (iPartitionPos = PARPOS_BETW_D)
			else
				parameters totalLength	=	deskNumberInRow * tableLength1 * (iPartitionPos = PARPOS_ABOVE_D)\
											+ (deskNumberInRow * tableLength1 + (deskNumberInRow - 1) * partitionFrameThk * bSidePartitions + partitionFrameThk * bEndPartitions1 + partitionFrameThk * bEndPartitions2) * (iPartitionPos = PARPOS_BETW_D)
			endif
		endif

		values "totalLength" range[tableLength1, )
		lock	"tableLength1"
	endif
else
	if (iPartitionPos = PARPOS_ABOVE_D) or NOT(bShowPartitionParams) then
		deskLengthStep	= deskDiagonal / 2

		if GLOB_MODPAR_NAME = "lengthRight" or GLOB_MODPAR_NAME = "lengthLeft" then
			deskNumberLeft = lengthLeft / deskLengthStep
			deskNumberRight = lengthRight / deskLengthStep

			parameters deskNumberLeft = deskNumberLeft
			parameters deskNumberRight = deskNumberRight

			totalLength	= lengthRight + lengthLeft
			parameters totalLength	= totalLength
			parameters deskNumber	= totalLength / deskLengthStep
		else
			if GLOB_MODPAR_NAME = "deskNumber" then
				deskNumberRight = deskNumber - deskNumberLeft
				if deskNumberRight < 1 then deskNumberRight = 1
				parameters deskNumberRight = deskNumberRight

				deskNumberLeft = deskNumber - deskNumberRight
				parameters deskNumberLeft = deskNumberLeft

				lengthLeft = deskNumberLeft * deskLengthStep
				parameters lengthLeft = lengthLeft

				lengthRight = deskNumberRight * deskLengthStep
				parameters lengthRight = lengthRight

				totalLength	= lengthRight + lengthLeft
				parameters totalLength	= totalLength
			else
				lengthLeft = deskNumberLeft * deskLengthStep
				parameters lengthLeft = lengthLeft

				lengthRight = deskNumberRight * deskLengthStep
				parameters lengthRight = lengthRight

				deskNumber = deskNumberLeft + deskNumberRight
				parameters deskNumber = deskNumber

				totalLength	= deskNumber * deskLengthStep
				parameters totalLength = totalLength
			endif
		endif

		values "lengthLeft" range[0,] step 0, deskLengthStep
		values "lengthRight" range[deskLengthStep,] step deskLengthStep, deskLengthStep
	else
		dim lengthValuesRight[]
		desklengthStartRight = partitionFrameThk / COS(diagonalAngle) * bEndPartitions1
		for ii = 1 to maxDeskNumberByWave
			if ii = 1 then
				lengthMr			= tableLength2 / 2
				lengthStep			= desklengthStartRight + lengthMr / SIN(diagonalAngle)\
									+ partitionFrameThk / SIN(diagonalAngle) * (bFrontPartitions or bEndPartitions2)

				lengthValuesRight[ii] = lengthStep
			else
				if ii / 2 = INT(ii / 2) then	!!!ii páros
					lengthMr		= tableLength1 - lengthMr / TAN(diagonalAngle)\
									- partitionFrameThk / TAN(diagonalAngle) * (bFrontPartitions or bEndPartitions2) * (ii = 2)\
									- partitionFrameThk / TAN(diagonalAngle) * bFrontPartitions * (ii <> 2)
					lengthStep		= lengthMr / COS(diagonalAngle)\
									+ partitionFrameThk / COS(diagonalAngle) * (bEndPartitions2 and NOT(bFrontPartitions))\
									+ partitionFrameThk / COS(diagonalAngle) * bFrontPartitions * (ii - deskNumberRight > EPS)\
									+ partitionFrameThk / COS(diagonalAngle) * (bEndPartitions2 and (bFrontPartitions)) * (ii - deskNumberRight < EPS)
				else							!!!ii páratlan
					lengthMr		= tableLength2 - lengthMr * TAN(diagonalAngle)\
									- partitionFrameThk * TAN(diagonalAngle) * bFrontPartitions
					lengthStep		= lengthMr / SIN(diagonalAngle)\
									- partitionFrameThk / COS(diagonalAngle) * (bEndPartitions2 and NOT(bFrontPartitions))\
									+ partitionFrameThk / SIN(diagonalAngle) * bFrontPartitions * (ii - deskNumberRight > EPS)\
									+ partitionFrameThk / SIN(diagonalAngle) * (bEndPartitions2 and (bFrontPartitions)) * (ii - deskNumberRight < EPS)
				endif

				lengthValuesRight[ii] = lengthValuesRight[ii - 1] + lengthStep
			endif
		next ii

		dim lengthValuesLeft[]
		desklengthStartLeft = -partitionFrameThk / COS(diagonalAngle) * (bEndPartitions1)
		for ii = 1 to maxDeskNumberByWave
			if ii = 1 then
				lengthMr	= tableLength2 / 2
				lengthStep	= desklengthStartLeft + lengthMr / SIN(diagonalAngle)\
							+ partitionFrameThk / SIN(diagonalAngle) * (bFrontPartitions or bEndPartitions1)

				lengthValuesLeft[ii] = lengthStep
			else
				if ii / 2 = INT(ii / 2) then		!!!ii páros
					lengthMr		= tableLength1 - lengthMr / TAN(diagonalAngle)\
									- partitionFrameThk / TAN(diagonalAngle) * (bFrontPartitions or bEndPartitions1) * (ii = 2)\
									- partitionFrameThk / TAN(diagonalAngle) * bFrontPartitions * (ii <> 2)
					lengthStep		= lengthMr / COS(diagonalAngle)\
									+ partitionFrameThk / COS(diagonalAngle) * bFrontPartitions\
									+ partitionFrameThk / COS(diagonalAngle) * (NOT(bFrontPartitions) and bEndPartitions1)\
									+ partitionFrameThk / COS(diagonalAngle) * bFrontPartitions * (ii - deskNumberLeft > EPS)\
									+ partitionFrameThk / COS(diagonalAngle) * (bFrontPartitions and bEndPartitions1) * (ii - deskNumberLeft < EPS)
				else								!!!ii páratlan
					lengthMr		= tableLength2 - lengthMr * TAN(diagonalAngle)\
									- partitionFrameThk * TAN(diagonalAngle) * bFrontPartitions
					lengthStep		= lengthMr / SIN(diagonalAngle)\
									- partitionFrameThk / COS(diagonalAngle) * bFrontPartitions\
									- partitionFrameThk / COS(diagonalAngle) * (NOT(bFrontPartitions) and bEndPartitions1)\
									+ partitionFrameThk / SIN(diagonalAngle) * bFrontPartitions * (ii - deskNumberLeft > EPS)\
									+ partitionFrameThk / SIN(diagonalAngle) * (bFrontPartitions and bEndPartitions1) * (ii - deskNumberLeft < EPS)
				endif

				lengthValuesLeft[ii] = lengthValuesLeft[ii - 1] + lengthStep
			endif
		next ii

		values "lengthRight" lengthValuesRight
		values "lengthLeft" 0, lengthValuesLeft

		if GLOB_MODPAR_NAME = "lengthRight" or GLOB_MODPAR_NAME = "lengthLeft" then
			totalLength	= lengthRight + lengthLeft
			parameters totalLength	= totalLength

			for iDnumRight = 1 to maxDeskNumberByWave
				if ABS(lengthRight - lengthValuesRight[iDnumRight]) < EPS then deskNumberRight = iDnumRight
			next iDnumRight

			if lengthLeft > EPS then
				for iDnumLeft = 1 to maxDeskNumberByWave
					if ABS(lengthLeft - lengthValuesLeft[iDnumLeft]) < EPS then deskNumberLeft = iDnumLeft
				next iDnumLeft
			else
				deskNumberLeft = 0
			endif

			parameters deskNumberRight = deskNumberRight
			parameters deskNumberLeft = deskNumberLeft

			deskNumber = deskNumberRight + deskNumberLeft
			parameters deskNumber = deskNumber
		else
			if GLOB_MODPAR_NAME = "deskNumber" then
				deskNumberRight = deskNumber - deskNumberLeft
				if deskNumberRight < 1 then deskNumberRight = 1
				parameters deskNumberRight = deskNumberRight

				deskNumberLeft = deskNumber - deskNumberRight
				parameters deskNumberLeft = deskNumberLeft

				if deskNumberLeft > 0 then
					lengthLeft = lengthValuesLeft[deskNumberLeft]
				else
					lengthLeft = 0
				endif
				parameters lengthLeft = lengthLeft

				lengthRight = lengthValuesRight[deskNumberRight]
				parameters lengthRight = lengthRight

				totalLength	= lengthRight + lengthLeft
				parameters totalLength	= totalLength
			else
				if deskNumberLeft > 0 then
					lengthLeft = lengthValuesLeft[deskNumberLeft]
				else
					lengthLeft = 0
				endif
				parameters lengthLeft = lengthLeft

				lengthRight = lengthValuesRight[deskNumberRight]
				parameters lengthRight = lengthRight

				deskNumber = deskNumberRight + deskNumberLeft
				parameters deskNumber = deskNumber

				totalLength	= lengthRight + lengthLeft
				parameters totalLength	= totalLength
			endif
		endif
	endif

	lock		"totalLength"
endif

lock			"lengthLeft",
				"lengthRight",
				"deskNumberLeft",
				"deskNumberRight"

hideparameter	"lengthLeft",
				"lengthRight",
				"deskNumberLeft",
				"deskNumberRight"

a		= layoutLeftSideDimA + layoutRightSideDimA
b		= layoutTopSideDimB + layoutBottomSideDimB
zzyzx	= MAX(tableTopHeight, maxExtHeight, realPartHeight)
parameters a		= a
parameters b		= b
parameters zzyzx	= zzyzx
lock	"a",
		"b",
		"zzyzx"



! ======================================================================
! Desks
! ======================================================================

if GLOB_MODPAR_NAME = "layoutType" or GLOB_MODPAR_NAME = "iLayoutType" then
	if iLayoutType = LAYOUT_STRAIGHT then
		defaultTableChairDistX	= 0
	else
		defaultTableChairDistX	= 0.5
	endif
	if iLayoutType = LAYOUT_WAVE then
		defaultInnerEdge		= ROUNDED

		defaultExtensionType	= EXT_ROUNDED
	else
		defaultInnerEdge		= STRAIGHT

		defaultExtensionType	= EXT_NONE
	endif
	if iLayoutType = LAYOUT_CUBICLE then
		defaultMSFront			= 0.75
	else
		defaultMSFront			= 1.1
	endif

	tableChairDistX	= defaultTableChairDistX
	parameters tableChairDistX	= tableChairDistX

	iInnerEdge = defaultInnerEdge
	parameters iInnerEdge = iInnerEdge

	MSFront= defaultMSFront
	parameters MSFront = MSFront

	iExtensionTypeTop		= defaultExtensionType
	iExtensionTypeBottom	= defaultExtensionType

	parameters iExtensionTypeTop	= iExtensionTypeTop
	parameters iExtensionTypeBottom	= iExtensionTypeBottom
endif

if GLOB_MODPAR_NAME = "extensionTypeLeft" or GLOB_MODPAR_NAME = "iextensionTypeLeft" then
	if bShowExtDeskParams then
		defaultMSSide	= 1.1
	else
		defaultMSSide	= 0.75
	endif

	MSSide = defaultMSSide
	parameters MSSide = MSSide
endif
if GLOB_MODPAR_NAME = "extensionTypeRight" or GLOB_MODPAR_NAME = "iextensionTypeRight" then
	if bShowExtDeskParams then
		defaultMSSide2	= 1.1
	else
		defaultMSSide2	= 0.75
	endif

	MSSide2 = defaultMSSide2
	parameters MSSide2 = MSSide2
endif

values "MSSide" range[0, ]
values "MSSide2" range[0, ]

values "iCabKnobType" 1, 2, 3, 4, 5, 6, 7, 8
values "iCabKnobVerPos" 1, 0, -1
values "iExtCabKnobType" 0, 1, 2, 3, 4, 5, 6, 7, 8
values "iExtCabKnobVerPos" 1, 0, -1
if GLOB_MODPAR_NAME = "iCabKnobType" or GLOB_MODPAR_NAME = "iExtCabKnobType" then
	if GLOB_MODPAR_NAME = "iCabKnobType" then
		gs_knob_type_m = iCabKnobType
		parameters gs_knob_type_m = gs_knob_type_m
	else
		gs_knob_type_m = iExtCabKnobType
		parameters gs_knob_type_m = gs_knob_type_m
	endif
else
	iCabKnobType	= gs_knob_type_m
	iExtCabKnobType	= gs_knob_type_m
	parameters iCabKnobType		= iCabKnobType
	parameters iExtCabKnobType	= iExtCabKnobType
endif
if GLOB_MODPAR_NAME = "iCabKnobVerPos" or GLOB_MODPAR_NAME = "iExtCabKnobVerPos" then
	if GLOB_MODPAR_NAME = "iCabKnobVerPos" then
		gs_knobVerPos_m = iCabKnobVerPos
		parameters gs_knobVerPos_m = gs_knobVerPos_m
	else
		gs_knobVerPos_m = iExtCabKnobVerPos
		parameters gs_knobVerPos_m = gs_knobVerPos_m
	endif
else
	iCabKnobVerPos		= gs_knobVerPos_m
	iExtCabKnobVerPos	= gs_knobVerPos_m
	parameters iCabKnobVerPos		= iCabKnobVerPos
	parameters iExtCabKnobVerPos	= iExtCabKnobVerPos
endif

if ((iExtensionTypeLeft <> 4 and iExtensionTypeRight <> 4) or iCabinetScheme = 5) and gs_officeCab_m = 0 then
	hideparameter  "bKnob", "iCabKnobType", "iCabKnobVerPos"
	lock "bKnob", "iCabKnobType", "iCabKnobVerPos"
endif

if not(bKnob) then
	hideparameter "iCabKnobVerPos", "iCabKnobType"
	lock "iCabKnobVerPos", "iCabKnobType"
endif
if NOT(bShowExtCabParams) then
	lock "iExtCabKnobType"
	lock "iExtCabKnobVerPos"
endif
if iExtCabKnobType = 0 then
	lock "iExtCabKnobVerPos"
endif

call "completeTable_m" parameters all	iTableTopType			= (iLayoutType = LAYOUT_CUBICLE or iLayoutType = LAYOUT_WAVE) + 2 * (iLayoutType = LAYOUT_STRAIGHT),
										zzyzx					= tableTopHeight,
										iDeskAngle				= iDeskAngle,
										chairPos				= chairPos,
										bCalledAsExtension		= 0,
										bPartOfLayout			= 1,
										bPartOfWsSolo			= 0,
										bEnableBasetypes		= 0,
										bMirroredCabPos			= bMirroredCabPos,
										bShowCommonCabParams	= bShowCommonCabParams,
										bShowCabParams			= bShowCabParams,
										bShowExtDeskCabParams	= bShowExtDeskCabParams,
										bKnobNoneType			= 0,
										stSymbolTypes			= stSymbolTypes



! ======================================================================
! Extensions, Partitions
! ======================================================================

call "deskClosings_m" parameters all	bPartOfLayout			= 1,
										bPartOfWsSolo			= 0,
										bShowCabParams			= bShowCabParams,
										bShowPartitionParams	= bShowPartitionParams,
										bShowExtCabParams		= bShowExtCabParams,
										bShowExtDeskParams		= bShowExtDeskParams,
										bShowExtDeskChairParams	= bShowExtDeskChairParams,
										bShowExtDeskCabParams	= bShowExtDeskCabParams,
										bShowCommonCabParams	= bShowCommonCabParams,
										bEnableCustPartLength	= 0,
										bKnobNoneType			= 0,
										stSymbolTypes			= stSymbolTypes

! enableExtensionTypes - possible values
!	2		- enable None
!	4		- enable Rounded
!	8		- enable Desk
!	16		- enable Desk with Chair
!	32		- enable Cabinet
!	64		- enable Partition

if iLayoutType = LAYOUT_STRAIGHT then
	enableExtensionTypes = 2 + 4 + 32 + (8 + 16) * bSymmetricalDeskEnd
endif
if iLayoutType = LAYOUT_CUBICLE then
	enableExtensionTypes = 2
endif
if iLayoutType = LAYOUT_WAVE then
	enableExtensionTypes = 2 + 4 + 32
endif

dim extensionTypeValueList[]
j = 1
for i = 1 to vardim1(stExtensionsType)
	if bittest(enableExtensionTypes, i) then
		put i - 1
		extensionTypeValueList[j] = stExtensionsType[i]
		j = j + 1
	endif
next i

values "extensionTypeTop" extensionTypeValueList
values "iExtensionTypeTop" use(NSP)
if GLOB_MODPAR_NAME = "extensionTypeTop" then
	for iExtTop = 1 to vardim1(stExtensionsType)
		if extensionTypeTop = stExtensionsType[iExtTop] then iExtensionTypeTop = iExtTop - 1
	next iExtTop
	parameters iExtensionTypeTop = iExtensionTypeTop
else
	extensionTypeTop = stExtensionsType[iExtensionTypeTop + 1]
	parameters extensionTypeTop = extensionTypeTop
endif

values "extensionTypeRight" extensionTypeValueList
values "iExtensionTypeRight" use(NSP)
if GLOB_MODPAR_NAME = "extensionTypeRight" then
	for iExtRight = 1 to vardim1(stExtensionsType)
		if extensionTypeRight = stExtensionsType[iExtRight] then iExtensionTypeRight = iExtRight - 1
	next iExtRight
	parameters iExtensionTypeRight = iExtensionTypeRight
else
	extensionTypeRight = stExtensionsType[iExtensionTypeRight + 1]
	parameters extensionTypeRight = extensionTypeRight
endif

values "extensionTypeBottom" extensionTypeValueList
values "iExtensionTypeBottom" use(NSP)
if GLOB_MODPAR_NAME = "extensionTypeBottom" then
	for iExtBottom = 1 to vardim1(stExtensionsType)
		if extensionTypeBottom = stExtensionsType[iExtBottom] then iExtensionTypeBottom = iExtBottom - 1
	next iExtBottom
	parameters iExtensionTypeBottom = iExtensionTypeBottom
else
	extensionTypeBottom = stExtensionsType[iExtensionTypeBottom + 1]
	parameters extensionTypeBottom = extensionTypeBottom
endif

values "extensionTypeLeft" extensionTypeValueList
values "iExtensionTypeLeft" get(NSP)
if GLOB_MODPAR_NAME = "extensionTypeLeft" then
	for iExtLeft = 1 to vardim1(stExtensionsType)
		if extensionTypeLeft = stExtensionsType[iExtLeft] then iExtensionTypeLeft = iExtLeft - 1
	next iExtLeft
	parameters iExtensionTypeLeft = iExtensionTypeLeft
else
	extensionTypeLeft = stExtensionsType[iExtensionTypeLeft + 1]
	parameters extensionTypeLeft = extensionTypeLeft
endif

if iLayoutType = LAYOUT_STRAIGHT then
	iExtensionTypeTop		= 0
	iExtensionTypeBottom	= 0

	parameters iExtensionTypeTop		= iExtensionTypeTop
	parameters iExtensionTypeBottom		= iExtensionTypeBottom

	lock			"extensionTypeTop",
					"iExtensionTypeTop",
					"extensionTypeBottom",
					"iExtensionTypeBottom"
	hideparameter	"extensionTypeTop",
					"iExtensionTypeTop",
					"extensionTypeBottom",
					"iExtensionTypeBottom"
endif
if iLayoutType = LAYOUT_CUBICLE then
	iExtensionTypeRight		= 0
	iExtensionTypeLeft		= 0
	iExtensionTypeTop		= 0
	iExtensionTypeBottom	= 0

	parameters iExtensionTypeRight		= iExtensionTypeRight
	parameters iExtensionTypeLeft		= iExtensionTypeLeft
	parameters iExtensionTypeTop		= iExtensionTypeTop
	parameters iExtensionTypeBottom		= iExtensionTypeBottom

	lock			"gs_extensions"
endif
if iLayoutType = LAYOUT_WAVE then
	if bDeskNumLeftIsEven then
		if deskNumber < 4 then
			iExtensionTypeBottom	= 0
			lock		"extensionTypeBottom",
						"iExtensionTypeBottom"
		endif
		if deskNumber < 3 then
			iExtensionTypeTop		= 0
			lock		"extensionTypeTop",
						"iExtensionTypeTop"
		endif
	else
		if deskNumber < 3 then
			iExtensionTypeBottom	= 0
			lock		"extensionTypeBottom",
						"iExtensionTypeBottom"
		endif
		if deskNumber < 4 then
			iExtensionTypeTop		= 0
			lock		"extensionTypeTop",
						"iExtensionTypeTop"
		endif
	endif

	iExtensionTypeRight	= 0
	IExtensionTypeLeft	= 0
	bSidePartitions		= 1

	parameters iExtensionTypeRight	= iExtensionTypeRight
	parameters iExtensionTypeLeft	= iExtensionTypeLeft
	parameters bSidePartitions		= bSidePartitions

	lock			"extensionTypeRight",
					"iExtensionTypeRight",
					"extensionTypeLeft",
					"iExtensionTypeLeft",
					"bSidePartitions"
	hideparameter	"extensionTypeRight",
					"iExtensionTypeRight",
					"extensionTypeLeft",
					"iExtensionTypeLeft",
					"bSidePartitions"
endif

if deskNumber = 1 + bDoubleRow then
	bSidePartitions = 0
	parameters bSidePartitions = bSidePartitions
	lock "bSidePartitions"
endif



! ======================================================================
! Layout
! ======================================================================

values "layoutType" stLayoutType
values "iLayoutType" 1, 2, 3
if GLOB_MODPAR_NAME = "layoutType" then
	for iLay = 1 to vardim1(stLayoutType)
		if layoutType = stLayoutType[iLay] then iLayoutType = iLay
	next iLay
	parameters iLayoutType = iLayoutType
else
	layoutType = stLayoutType[max(iLayoutType, 1)]
	parameters layoutType = layoutType
endif

values "arrangement" stArrangement
values "iArrangement" 1, 2
if GLOB_MODPAR_NAME = "arrangement" then
	for iArr = 1 to vardim1(stArrangement)
		if arrangement = stArrangement[iArr] then iArrangement = iArr
	next iArr
	parameters iArrangement = iArrangement
else
	arrangement = stArrangement[max(iArrangement, 1)]
	parameters arrangement = arrangement
endif

if (iLayoutType = LAYOUT_STRAIGHT or iLayoutType = LAYOUT_CUBICLE) and NOT(bDoubleRow) then
	iArrangement	= 1
	parameters iArrangement	= iArrangement

	lock	"arrangement",
			"iArrangement"
endif
if iLayoutType = LAYOUT_WAVE then
	iArrangement	= 2
	parameters iArrangement	= iArrangement

	lock	"arrangement",
			"iArrangement"
endif



! ======================================================================
! Dimensions
! ======================================================================

values "sizing" stSizing
values "iSizing" 1, 2
if GLOB_MODPAR_NAME = "sizing" then
	for iSiz = 1 to vardim1(stSizing)
		if sizing = stSizing[iSiz] then iSizing = iSiz
	next iSiz
	parameters iSizing = iSizing
else
	sizing = stSizing[max(iSizing, 1)]
	parameters sizing = sizing
endif

values "deskSizing" stDeskSizing
values "iDeskSizing" 1, 2
if GLOB_MODPAR_NAME = "deskSizing" then
	for iDSiz = 1 to vardim1(stDeskSizing)
		if deskSizing = stDeskSizing[iDSiz] then iDeskSizing = iDSiz
	next iDSiz
	parameters iDeskSizing = iDeskSizing
else
	deskSizing = stDeskSizing[max(iDeskSizing, 1)]
	parameters deskSizing = deskSizing
endif

if iLayoutType = LAYOUT_WAVE then
	values "deskNumber" range[1, )
else
	values "deskNumber" range[1 + bDoubleRow, ) step 1 + bDoubleRow, 1 + bDoubleRow
endif

if iLayoutType = LAYOUT_WAVE then
	iSizing = 1
	parameters iSizing = iSizing
	lock			"sizing",
					"iSizing"
	hideparameter 	"sizing",
					"iSizing"

	bDoubleRow = 1
	parameters bDoubleRow = bDoubleRow
	lock			"bDoubleRow"
endif

if iLayoutType = LAYOUT_STRAIGHT then
	lock			"tableLength2", "tableDepth2", "innerEdge", "iInnerEdge", "innerEdgeRad"
	hideparameter 	"tableLength2", "tableDepth2", "innerEdge", "iInnerEdge", "innerEdgeRad"
endif
if iLayoutType = LAYOUT_WAVE then
	if	GLOB_MODPAR_NAME = "tableLength1" or GLOB_MODPAR_NAME = "tableLength2" or\
		GLOB_MODPAR_NAME = "xPosTopCorner" or GLOB_MODPAR_NAME = "yPosTopCorner" then
		if iDeskSizing = DESKSIZING_FIX_AXIS then
			parameters totalAngle = diagonalAngle
		else
			parameters axisAngle = totalAngle - diagonalAngle
		endif
	else
		parameters totalAngle = diagonalAngle + axisAngle
	endif

	if iDeskSizing = DESKSIZING_FIX_AXIS then
		parameters axisAngle = 0
		lock		"axisAngle"
	endif

	parameters iSizing = 1
	lock			"sizing",
					"iSizing"
	hideparameter 	"sizing",
					"iSizing"
else
	lock			"deskSizing",
					"iDeskSizing",
					"axisAngle"
	hideparameter 	"deskSizing",
					"iDeskSizing",
					"axisAngle"
endif

if gs_officeCab_m = 0 or not(gs_bOfficeCab) then
	hideparameter "gs_bevel"
	lock "gs_bevel"
endif

! ======================================================================
! Layout Components Listing
! ======================================================================

parameters iListDeskNum90	= 0
parameters iListDeskNumRect	= 0
parameters iListExtDeskNum	= 0
parameters iListDeskCabNum	= 0
parameters iListExtRounded	= 0
parameters iListExtCab		= 0
parameters iListChairNum	= 0
parameters iListPartNum		= 0

lock	"iListDeskNum90",
		"iListDeskNumRect",
		"iListExtDeskNum",
		"iListDeskCabNum",
		"iListExtRounded",
		"iListExtCab",
		"iListChairNum",
		"iListPartNum"

if iLayoutType = LAYOUT_STRAIGHT then
	parameters iListDeskNumRect	= deskNumber

	parameters iListExtCab		= ((iExtensionTypeLeft = EXT_CABINET)\
								+ (iExtensionTypeRight = EXT_CABINET)) * (1 + bDoubleRow)

	parameters iListExtDeskNum	= (iExtensionTypeLeft = EXT_DESK)\
								+ (iExtensionTypeRight = EXT_DESK)\
								+ (iExtensionTypeRight = EXT_DESK_WCHAIR)\
								+ (iExtensionTypeLeft = EXT_DESK_WCHAIR)

	parameters iListDeskCabNum	= deskNumber * CEIL(gs_officeCab_m / 2)\
								+ iListExtDeskNum * CEIL(iExtraDeskCab / 2) * bShowCabParams

	parameters iListExtRounded	= (iExtensionTypeLeft = EXT_ROUNDED)\
								+ (iExtensionTypeRight = EXT_ROUNDED)

	parameters iListChairNum	= deskNumber + (iExtensionTypeLeft = EXT_DESK_WCHAIR)\
								+ (iExtensionTypeRight = EXT_DESK_WCHAIR)

	parameters iListPartNum		= bFrontPartitions * (deskNumber / (1 + bDoubleRow))\
								+ bSidePartitions * ((deskNumber / (1 + bDoubleRow)) - 1) * (1 + bDoubleRow)\
								+ bEndPartitions1 * (1 + bDoubleRow)\
								+ bEndPartitions2 * (1 + bDoubleRow)
endif

if iLayoutType = LAYOUT_CUBICLE then
	parameters iListDeskNum90	= deskNumber

	parameters iListDeskCabNum	= deskNumber * gs_bOfficeCab

	parameters iListChairNum	= deskNumber

	parameters iListPartNum		= bFrontPartitions * (deskNumber / (1 + bDoubleRow))\
								+ bSidePartitions * ((deskNumber / (1 + bDoubleRow)) - 1) * (1 + bDoubleRow)\
								+ bEndPartitions1 * (1 + bDoubleRow)\
								+ bEndPartitions2 * (1 + bDoubleRow)
endif

if iLayoutType = LAYOUT_WAVE then
	parameters iListDeskNum90	= deskNumber

	parameters iListExtCab		= (iExtensionTypeTop = EXT_CABINET) * (CEIL(deskNumber / 2) - 1)\
								+ (iExtensionTypeBottom = EXT_CABINET) * (bDeskNumberIsEven * ((deskNumber / 2) - 1) + (deskNumber > 1) * NOT(bDeskNumberIsEven) * (((deskNumber - 1) / 2) - 1))

	parameters iListDeskCabNum	= deskNumber * gs_bOfficeCab

	parameters iListExtRounded	= (iExtensionTypeTop = EXT_ROUNDED) * (CEIL(deskNumber / 2) - 1)\
								+ (iExtensionTypeBottom = EXT_ROUNDED) * (bDeskNumberIsEven * ((deskNumber / 2) - 1) + (deskNumber > 1) * NOT(bDeskNumberIsEven) * (((deskNumber - 1) / 2) - 1))

	parameters iListChairNum	= deskNumber

	parameters iListPartNum		= bFrontPartitions * ((deskNumber - 1) * (deskNumber > 1) + (deskNumber = 1))\
								+ bEndPartitions1 * (1 + (deskNumber > 1))\
								+ bEndPartitions2 * (1 + (deskNumber > 1))
endif


]]>
</Script_VL>

<ParamSection SectVersion="26" SectionFlags="0" SubIdent="0">
	<ParamSectHeader>
		<Version>26</Version>
		<AutoHotspots>false</AutoHotspots>
		<StatBits>
			<STBit_UIDefault/>
			<STBit_FixSize/>
			<STBit_UIUseHierarchicalPages/>
		</StatBits>
		<WDLeftFrame>0</WDLeftFrame>
		<WDRightFrame>0</WDRightFrame>
		<WDTopFrame>0</WDTopFrame>
		<WDBotFrame>0</WDBotFrame>
		<LayFlags>65535</LayFlags>
		<WDMirrorThickness>0</WDMirrorThickness>
		<WDWallInset>0</WDWallInset>
		<SymbolColor>0</SymbolColor>
	</ParamSectHeader>
	<Parameters>
		<Length Name="A">
			<Description><![CDATA["Размер 1"]]></Description>
			<Fix/>
			<Value>3</Value>
		</Length>
		<Length Name="B">
			<Description><![CDATA["Размер 2"]]></Description>
			<Fix/>
			<Value>1.2</Value>
		</Length>
		<Length Name="zzyzx">
			<Description><![CDATA["Размер 3"]]></Description>
			<Fix/>
			<Value>1.15</Value>
		</Length>
		<Boolean Name="AC_show2DHotspotsIn3D">
			<Description><![CDATA["Показ Узловых 2D Точек в 3D"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="ac_bottomlevel">
			<Description><![CDATA["Отметка Низа"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="ac_toplevel">
			<Description><![CDATA["Отметка Верха"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="innerCornerPos">
			<Description><![CDATA["Положение по Х Внутреннего Угла"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0.6</Value>
		</Length>
		<Length Name="innerArcStartPos">
			<Description><![CDATA["Положение по Х Начала Внутренней Дуги"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0.9</Value>
		</Length>
		<Length Name="innerArcEndPos">
			<Description><![CDATA["Конечное Положение Внутренней Дуги"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0.9</Value>
		</Length>

		<!-- gs_layout: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_layout">
			<Description><![CDATA["Компоновка"]]></Description>
		</Title>
		<String Name="layoutType">
			<Description><![CDATA["Тип Планировки"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Прямой"]]></Value>
		</String>
		<Integer Name="iLayoutType">
			<Description><![CDATA["Тип Планировки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="arrangement">
			<Description><![CDATA["Расположение"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Зеркально"]]></Value>
		</String>
		<Integer Name="iArrangement">
			<Description><![CDATA["Расположение"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Boolean Name="bDoubleRow">
			<Description><![CDATA["Два Ряда"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>

		<!-- gs_dimensions: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_dimensions">
			<Description><![CDATA["Размеры"]]></Description>
		</Title>
		<String Name="sizing">
			<Description><![CDATA["Размер"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["по Размеру Рабочего Места"]]></Value>
		</String>
		<Integer Name="iSizing">
			<Description><![CDATA["Размер"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="deskSizing">
			<Description><![CDATA["Размер Стола"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Постоянный Угол"]]></Value>
		</String>
		<Integer Name="iDeskSizing">
			<Description><![CDATA["Размер Стола"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Length Name="totalLength">
			<Description><![CDATA["Общая Длина Рабочих Мест"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>3</Value>
		</Length>
		<Length Name="lengthLeft">
			<Description><![CDATA["Длина Слева"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="lengthRight">
			<Description><![CDATA["Длина Справа"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>4.24264068712</Value>
		</Length>
		<Integer Name="deskNumberLeft">
			<Description><![CDATA["Количество Столов Слева"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="deskNumberRight">
			<Description><![CDATA["Количество Столов Справа"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>4</Value>
		</Integer>
		<Angle Name="axisAngle">
			<Description><![CDATA["Угол Оси"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Angle Name="totalAngle">
			<Description><![CDATA["Общий Угол Компоновки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>45</Value>
		</Angle>
		<Integer Name="deskNumber">
			<Description><![CDATA["Количество Столов"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</Integer>
		<Integer Name="deskNumberInRow">
			<Description><![CDATA["Количество Столов в Ряду"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Length Name="tableLength1">
			<Description><![CDATA["Длина Стола 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1.5</Value>
		</Length>
		<Length Name="tableLength2">
			<Description><![CDATA["Длина Стола 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1.5</Value>
		</Length>
		<Length Name="tableDepth1">
			<Description><![CDATA["Глубина Стола 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.6</Value>
		</Length>
		<Length Name="tableDepth2">
			<Description><![CDATA["Глубина Стола 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.6</Value>
		</Length>
		<Length Name="tableTopHeight">
			<Description><![CDATA["Высота Столешницы"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.75</Value>
		</Length>
		<Length Name="topThk">
			<Description><![CDATA["Толщина Столешницы"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.025</Value>
		</Length>
		<Length Name="tableChairDistX">
			<Description><![CDATA["Расстояние Стул-Стол 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="xPosDeskChair">
			<Description><![CDATA["Реальное Расстояние Стол-Стул 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="tableChairDistY">
			<Description><![CDATA["Расстояние Стул-Стол 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.5</Value>
		</Length>
		<String Name="innerEdge">
			<Description><![CDATA["Внутренний Угол"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Прямой"]]></Value>
		</String>
		<Integer Name="iInnerEdge">
			<Description><![CDATA["Внутренний Угол"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Length Name="innerEdgeRad">
			<Description><![CDATA["Радиус"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.3</Value>
		</Length>

		<!-- gs_extensions: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_extensions">
			<Description><![CDATA["Приставные Элементы"]]></Description>
		</Title>
		<String Name="extensionTypeLeft">
			<Description><![CDATA["Элемент Слева"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Нет"]]></Value>
		</String>
		<Integer Name="iExtensionTypeLeft">
			<Description><![CDATA["Элемент Слева"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<String Name="extensionTypeRight">
			<Description><![CDATA["Элемент Справа"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Нет"]]></Value>
		</String>
		<Integer Name="iExtensionTypeRight">
			<Description><![CDATA["Элемент Справа"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<String Name="extensionTypeTop">
			<Description><![CDATA["Элемент Сверху"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Нет"]]></Value>
		</String>
		<Integer Name="iExtensionTypeTop">
			<Description><![CDATA["Элемент Сверху"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<String Name="extensionTypeBottom">
			<Description><![CDATA["Элемент Внизу"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Нет"]]></Value>
		</String>
		<Integer Name="iExtensionTypeBottom">
			<Description><![CDATA["Элемент Внизу"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="extCabinetWidth">
			<Description><![CDATA["Ширина"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.6</Value>
		</Length>
		<Length Name="extCabinetDepth">
			<Description><![CDATA["Глубина"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.5</Value>
		</Length>
		<Length Name="extCabinetHeight">
			<Description><![CDATA["Высота"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1.15</Value>
		</Length>
		<String Name="cabinetScheme">
			<Description><![CDATA["Схема"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Двери и Ящики"]]></Value>
		</String>
		<Integer Name="iCabinetScheme">
			<Description><![CDATA["Схема"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="cupboardDoors">
			<Description><![CDATA["Двери Шкафа"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Двойные"]]></Value>
		</String>
		<Integer Name="iCupboardDoors">
			<Description><![CDATA["Двери Шкафа"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Length Name="gs_drawerHeight">
			<Description><![CDATA["Высота Ящика"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.233333333333</Value>
		</Length>
		<Length Name="totalDrawerHeight">
			<Description><![CDATA["Общая Высота Ящиков"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0.75</Value>
		</Length>
		<Length Name="gs_upperCabHeight">
			<Description><![CDATA["Высота Верхнего Шкафа"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.4</Value>
		</Length>
		<Integer Name="drawerNum">
			<Description><![CDATA["Количество Ящиков"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<Integer Name="shelfNum">
			<Description><![CDATA["Количество Полок"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="iExtCabKnobType">
			<Description><![CDATA["Тип Ручки Приставного Шкафа"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="iExtCabKnobVerPos">
			<Description><![CDATA["Вертикальное Расположения Ручки Приставного Шкафа"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Boolean Name="bCabinetBase">
			<Description><![CDATA["Основание Приставного Шкафа"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Length Name="cabinetBaseHeight">
			<Description><![CDATA["Высота Основания Приставного Шкафа"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.05</Value>
		</Length>
		<Length Name="extraDeskWidth">
			<Description><![CDATA["Ширина Приставного Стола"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1.2</Value>
		</Length>
		<Length Name="halfExtraDeskWidth">
			<Description><![CDATA["Половина Ширины Приставного Стола для Редактирования Узловой Точки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0.6</Value>
		</Length>
		<Length Name="extraDeskDepth">
			<Description><![CDATA["Глубина Дополнительного Стола"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.6</Value>
		</Length>
		<String Name="extraDeskCab">
			<Description><![CDATA["Тумбочка Приставного Стола"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Нет"]]></Value>
		</String>
		<Integer Name="iExtraDeskCab">
			<Description><![CDATA["Тумбочка Приставного Стола"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="extraDeskChairDistX">
			<Description><![CDATA["Расстояние Стула Приставного Стола X"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="extraDeskChairDistY">
			<Description><![CDATA["Расстояние Стула Приставного Стола"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.5</Value>
		</Length>

		<!-- gs_chair: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_chair">
			<Description><![CDATA["Стул"]]></Description>
		</Title>
		<Length Name="chairWidth">
			<Description><![CDATA["Ширина Стула"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.62</Value>
		</Length>
		<Length Name="chairDepth">
			<Description><![CDATA["Глубина Стула"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.59</Value>
		</Length>
		<Length Name="chairHeight">
			<Description><![CDATA["Высота Стула"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.95</Value>
		</Length>
		<Length Name="gs_seat_height">
			<Description><![CDATA["Высота Сидения"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.45</Value>
		</Length>
		<Boolean Name="gs_armrest">
			<Description><![CDATA["Подлокотники"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="gs_headrest">
			<Description><![CDATA["Подголовник"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<String Name="gs_back_type">
			<Description><![CDATA["Стиль Спинки"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Низкая"]]></Value>
		</String>
		<Integer Name="gs_back_type_m">
			<Description><![CDATA["Стиль Спинки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>

		<!-- gs_partition: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_partition">
			<Description><![CDATA["Перегородка"]]></Description>
		</Title>
		<String Name="partitionPos">
			<Description><![CDATA["Расположение Перегородки"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Над Столами"]]></Value>
		</String>
		<Integer Name="iPartitionPos">
			<Description><![CDATA["Расположение Перегородки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Boolean Name="bFrontPartitions">
			<Description><![CDATA["Перегородки Спереди"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bSidePartitions">
			<Description><![CDATA["Перегородки Сбоку"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bEndPartitions1">
			<Description><![CDATA["Перегородки в Конце 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bEndPartitions2">
			<Description><![CDATA["Перегородки в Конце 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Length Name="gs_partitionHeight">
			<Description><![CDATA["Высота Перегородки"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.4</Value>
		</Length>
		<Length Name="partitionBaseHeight">
			<Description><![CDATA["Высота Основания"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Integer Name="iPartitionDiv">
			<Description><![CDATA["Перегородки"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>3</Value>
		</Integer>

		<!-- gs_accessories: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_accessories">
			<Description><![CDATA["Аксессуары"]]></Description>
		</Title>
		<String Name="gs_leg_type">
			<Description><![CDATA["Стиль Ножек"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_BoldName/>
			</Flags>
			<Value><![CDATA["Стиль 1"]]></Value>
		</String>
		<Integer Name="gs_leg_type_m">
			<Description><![CDATA["Стиль Ножек"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Boolean Name="bComputer">
			<Description><![CDATA["Компьютер"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="gs_bFrontPanel">
			<Description><![CDATA["Передняя Панель"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_frontPanelHeight">
			<Description><![CDATA["Высота Передней Панели"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.72</Value>
		</Length>
		<Length Name="gs_frontPanelTop">
			<Description><![CDATA["Отметка Верха Передней Панели"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.72</Value>
		</Length>
		<Boolean Name="gs_bOfficeCab">
			<Description><![CDATA["Тумбочка"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_BoldName/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<String Name="gs_officeCab">
			<Description><![CDATA["Тумбочка"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_BoldName/>
			</Flags>
			<Value><![CDATA["Cо Стороны 1"]]></Value>
		</String>
		<Integer Name="gs_officeCab_m">
			<Description><![CDATA["Тумбочка"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Length Name="gs_officeCab_width">
			<Description><![CDATA["Ширина Тумбочки"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.4</Value>
		</Length>
		<Integer Name="drawer_num">
			<Description><![CDATA["Количество Ящиков"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</Integer>
		<Length Name="drawerThk">
			<Description><![CDATA["Толщина Панели Ящика"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.02</Value>
		</Length>
		<String Name="gs_drawerScheme">
			<Description><![CDATA["Схема"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Схема 1"]]></Value>
		</String>
		<Integer Name="gs_drawerScheme_m">
			<Description><![CDATA["Схема"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Length Name="gs_topDrawerH">
			<Description><![CDATA["Высота Верхнего Ящика"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.1</Value>
		</Length>
		<Length Name="gs_bottomDrawerH">
			<Description><![CDATA["Высота Нижнего Ящика"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.35</Value>
		</Length>
		<Length Name="gs_drawerHeights">
			<Description><![CDATA["Высота Ящиков"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="6" SecondDimension="0">
				<AVal Row="1">0.16875</AVal>
				<AVal Row="2">0.16875</AVal>
				<AVal Row="3">0.16875</AVal>
				<AVal Row="4">0.16875</AVal>
				<AVal Row="5">0.185</AVal>
				<AVal Row="6">0.0916666666667</AVal>
			</ArrayValues>
		</Length>
		<Boolean Name="gs_bevel">
			<Description><![CDATA["Фаска Торца"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bKnob">
			<Description><![CDATA["Ручка"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Integer Name="iCabKnobType">
			<Description><![CDATA["Стиль Ручки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="iCabKnobVerPos">
			<Description><![CDATA["Расположение Ручки по Вертикали"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="gs_knob_type">
			<Description><![CDATA["Стиль Ручки"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Стиль 1"]]></Value>
		</String>
		<Integer Name="gs_knob_type_m">
			<Description><![CDATA["Стиль Ручки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Length Name="gs_knobHorPos">
			<Description><![CDATA["Расположение Ручки по Горизонтали"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<String Name="gs_knobVerPos">
			<Description><![CDATA["Расположение Ручки по Вертикали"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Верх"]]></Value>
		</String>
		<Integer Name="gs_knobVerPos_m">
			<Description><![CDATA["Расположение Ручки по Вертикали"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Boolean Name="gs_editableKnobs">
			<Description><![CDATA["Узловые Точки Редактирования Расположения Ручки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_knobPosArray">
			<Description><![CDATA["Расположение Ручки для Узловой Точки"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="6" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0</AVal>
			</ArrayValues>
		</Length>
		<Boolean Name="bCabBase">
			<Description><![CDATA["Основание"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Integer Name="gs_baseType_m">
			<Description><![CDATA["Тип Основания"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Length Name="gs_baseHeight">
			<Description><![CDATA["Высота Основания"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.05</Value>
		</Length>

		<!-- gs_2D_representation: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_2D_representation">
			<Description><![CDATA["2D-отображение"]]></Description>
			<Fix/>
		</Title>
		<String Name="gs_detlevel_2D">
			<Description><![CDATA["2D-детализация"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Зависит от Масштаба"]]></Value>
		</String>
		<Integer Name="gs_detlevel_2D_m">
			<Description><![CDATA["2D-детализация"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<String Name="gs_SymbolType">
			<Description><![CDATA["Тип Символа"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Круглый"]]></Value>
		</String>
		<Integer Name="gs_SymbolType_Mask">
			<Description><![CDATA["Активировать Маску Типа Символа"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>4019</Value>
		</Integer>
		<Integer Name="gs_SymbolType_m">
			<Description><![CDATA["Тип Символа"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<PenColor Name="gs_cont_pen">
			<Description><![CDATA["Перо Контура"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</PenColor>
		<FillPattern Name="gs_fill_type">
			<Description><![CDATA["Тип Штриховки"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>65</Value>
		</FillPattern>
		<PenColor Name="gs_fill_pen">
			<Description><![CDATA["Перо Штриховки"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</PenColor>
		<PenColor Name="gs_back_pen">
			<Description><![CDATA["Перо Фона Штриховки"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</PenColor>

		<!-- gs_min_space: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_min_space">
			<Description><![CDATA["Минимальное Пространство"]]></Description>
		</Title>
		<Length Name="MSFront">
			<Description><![CDATA["Минимальное Пространство перед Столами"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1.1</Value>
		</Length>
		<Length Name="MSSide">
			<Description><![CDATA["Минимальное Пространство Сбоку 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.75</Value>
		</Length>
		<Length Name="MSSide2">
			<Description><![CDATA["Минимальное Пространство Сбоку 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.75</Value>
		</Length>

		<!-- gs_3D_representation: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_3D_representation">
			<Description><![CDATA["3D-отображение"]]></Description>
		</Title>
		<String Name="gs_detlevel_3D">
			<Description><![CDATA["3D-детализация"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Простой"]]></Value>
		</String>
		<Integer Name="gs_detlevel_3D_m">
			<Description><![CDATA["3D-детализация"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="gs_resol">
			<Description><![CDATA["Разрешение Столешницы"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>24</Value>
		</Integer>
		<Integer Name="gs_leg_resol">
			<Description><![CDATA["Разрешение"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>8</Value>
		</Integer>
		<Boolean Name="gs_shadow">
			<Description><![CDATA["Отбрасывание Теней"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>

		<!-- gs_material: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_material">
			<Description><![CDATA["Покрытия"]]></Description>
			<Fix/>
		</Title>
		<Material Name="gs_top_mat">
			<Description><![CDATA["Столешница"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>18</Value>
		</Material>
		<Material Name="gs_leg_mat">
			<Description><![CDATA["Ножки Стола"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>11</Value>
		</Material>
		<Material Name="legbase_mat">
			<Description><![CDATA["Опора Ножки Стола"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>49</Value>
		</Material>
		<Material Name="gs_partition_mat">
			<Description><![CDATA["Заполнение Перегородки"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>3</Value>
		</Material>
		<Material Name="gs_partitionFrame_mat">
			<Description><![CDATA["Обвязка Перегородки"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>49</Value>
		</Material>
		<Material Name="gs_frontPanel_mat">
			<Description><![CDATA["Передняя Панель"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>18</Value>
		</Material>
		<Material Name="gs_cabinet_mat">
			<Description><![CDATA["Корпус"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>18</Value>
		</Material>
		<Material Name="gs_door_mat">
			<Description><![CDATA["Дверь / Ящик"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>18</Value>
		</Material>
		<Material Name="gs_knob_mat">
			<Description><![CDATA["Ручка"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>49</Value>
		</Material>
		<Material Name="gs_base_mat">
			<Description><![CDATA["Основание"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>49</Value>
		</Material>
		<Material Name="gs_frame_mat">
			<Description><![CDATA["Корпус Стула"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>49</Value>
		</Material>
		<Material Name="gs_seat_mat">
			<Description><![CDATA["Обивка Стула"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>48</Value>
		</Material>
		<Material Name="box_mat">
			<Description><![CDATA["Монитор, Корпус Клавиатуры"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>18</Value>
		</Material>
		<Material Name="feetmat">
			<Description><![CDATA["Опора Монитора"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>99</Value>
		</Material>
		<Material Name="dispmat">
			<Description><![CDATA["Экран Монитора"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>29</Value>
		</Material>
		<Material Name="cover_mat">
			<Description><![CDATA["Верхняя Панель Клавиатуры"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>3</Value>
		</Material>
		<Material Name="keyb_mat">
			<Description><![CDATA["Клавиши Клавиатуры"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>10</Value>
		</Material>
		<Integer Name="gs_ui_current_page">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>

		<!-- gs_list: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_list">
			<Description><![CDATA["Параметры Спецификаций"]]></Description>
			<Fix/>
		</Title>
		<RealNum Name="gs_list_cost">
			<Description><![CDATA["Цена"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</RealNum>
		<String Name="gs_list_manufacturer">
			<Description><![CDATA["Производитель"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_note">
			<Description><![CDATA["Примечания"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_location">
			<Description><![CDATA["Расположение"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_accessories">
			<Description><![CDATA["Аксессуары"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="FM_Type">
			<Description><![CDATA["Тип Группы"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Мебель"]]></Value>
		</String>
		<Integer Name="iFMType">
			<Description><![CDATA["Тип Группы"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>16</Value>
		</Integer>
		<String Name="FM_InventoryNumber">
			<Description><![CDATA["Инвентарный Номер"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="FM_SerialNumber">
			<Description><![CDATA["Серийный Номер"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="FM_ProductionYear">
			<Description><![CDATA["Год Производства"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<RealNum Name="FM_ObjectWeight">
			<Description><![CDATA["Вес Изделия"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</RealNum>
		<String Name="FM_ObjectWeightUnit">
			<Description><![CDATA["Единица Веса"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["кг"]]></Value>
		</String>
		<String Name="gs_list_custom1">
			<Description><![CDATA["Пользовательское Значение 1"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_custom2">
			<Description><![CDATA["Пользовательское Значение 2"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_custom3">
			<Description><![CDATA["Пользовательское Значение 3"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_custom4">
			<Description><![CDATA["Пользовательское Значение 4"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_custom5">
			<Description><![CDATA["Пользовательское Значение 5"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="iListDeskNum90">
			<Description><![CDATA["Количество Столов (90°)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="iListDeskNumRect">
			<Description><![CDATA["Количество Столов (Прямоугольных)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</Integer>
		<Integer Name="iListExtDeskNum">
			<Description><![CDATA["Количество Приставных Столов"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="iListDeskCabNum">
			<Description><![CDATA["Количество Тумбочек"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</Integer>
		<Integer Name="iListExtRounded">
			<Description><![CDATA["Количество Закругленных Приставных Столов"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="iListExtCab">
			<Description><![CDATA["Количество Приставных Шкафов"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="iListChairNum">
			<Description><![CDATA["Количество Стульев"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</Integer>
		<Integer Name="iListPartNum">
			<Description><![CDATA["Количество Перегородок"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>8</Value>
		</Integer>
	</Parameters>
</ParamSection>

<DescDef NumDescs="1" SectVersion="4" SectionFlags="0" SubIdent="0">
	<DescRec>
		<Code><![CDATA[""]]></Code>
		<Keycode><![CDATA[""]]></Keycode>
		<DBSetname><![CDATA[""]]></DBSetname>
		<Reference>false</Reference>
		<Name><![CDATA[""]]></Name>
	</DescRec>
</DescDef>

<Picture MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="0" length_in_bytes="14341" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000800000
	008008020000004C5CF69C000000097048597300002E2300002E230178A53F76
	000020004944415478DAECBD4790A557762676CCBDBF79FEE54B5BBE0A28000D
	A0D1405B12DD249B9C21199C09CA9B198D66CB9DB491096D14A2C85168238642
	66A585162345CC50412AA4A16886D3CD6EB641371B6D800661CBBBCC4AFBF2F9
	DFDC738E16F765C1B049020D481C72EA46141085A84CE4BBE71EF77DDF398566
	060FCF5FDDA18757F0D0000F0DF0F03C34C043033C3C0F0DF0D0000FCF43033C
	34C0C3F3D0000F0DF0F03C34C043033C3C0F0DF0D0000FCF43033C34C0C3F3D0
	00FF8A18E02137F9576C00447C6883FFFFCFC34B7F9803FE1537C0430F781882
	1E86A00F71AEBDFECAFD3B371EDEE38F7DDC8FFD95D7DF78F5A53FF9FA747C4C
	CC66D66A775637CF6C6C9E5ADFDCEAAD6F3DBCD9FF0F43D0CE9D1BDF7FE16B07
	7BF73B9D2E329B2A118AA84A1DEA1A00C1ACD5EDAD6E9E5ADBD85CDF3CD55E59
	7FE79757F371D2E87C849FE12B5FFFD29F7CE70503E9767B67B74E3F72E1E293
	4F7D1280FF061AE0F860F73BDFF8CAF6ED9BCD56334953158D5F8D004808488C
	040844A412421D4228CD0C113BBDC1EAC6D6E6A933FBBB3BDFFEA3DFFF95FFFC
	D728C93E920F703C3AFA3B7FF7DFC8FB299253AD25D4AEC51F3BB7F95FFCC7BF
	7AE6FC637F734250319BBCF88DAFDEB8F27A92669DFE0AA84AD0930E0ECCC0D4
	8854C018C84C01D0A74996370001092584BB37AE5C7BED65760924D962316FBE
	DB00D14E3FC607F8D257BE045E07BD412DA5E30CD967897BF5FADE3FFDADFFFD
	3FFD4F7EED6F8201A42E5FFCE6D7AEBEF6123BDFEA74CC4045081111010C91C0
	0CC810894E6ED0D4885145C50231A112809A21BACCA79E89EABA7EAF27FE58B7
	0F00FFE2AB7FD86C658B7246004520A085815B69775F7DED95BA9CFAB4F5D7D9
	00A6DFFFD6D7DF7CF507524BDE6C637CA86A44640600169F3F103A6400043024
	3435222464744444A65A2CE6455979EFBC235505D0AAAC3E929FFEEA8DB77EF0
	FDD74E9FDA2AEA821808145455284DDCCDBDE1EEFD9D33E72FFF7535C02BDFFB
	F6EB2F7DB72A8A46AB0509A8999A11921158BC77000420A208222100201A0031
	112231AA5A5D968BA23033EF5D9A242104222264D1FA23893FDFFACEB7000034
	802A11C51F485501400ABB79F3DA5F4B035C7DFD9557BEF72793A3A3BCD5489B
	4D5145402244423520034003406636040333032644400343442234D510544228
	CB2A491295A0AA755D2F2FDAB45C141F49FCF9FA0B5FED341B950500D0E893AA
	C00E0090F4D6DDDB5FF8EB9503B66FDF7CF9C56F1E6CDF4B1A79A3D336331005
	8AE11E90D823861062D60500025C5E1F8299B1630254D3E1F1F16C365B1BAC35
	9A0D0400F000A0A255A8442588D4221FFE47BFBB7DEB87AFBCBEB1BA11A40250
	55202202025355758DECE6EDDB7F9D92F077BFF19557BEF7CD56BBDF591948A8
	4514C09234511533202213554242242600045B5E3D0210323B0483BA2A178BC5
	F0E8B8AE2B536B359BCCEC9D4BB2C43B9FA42D4224B46232FAF03FFAF75EFA9E
	5640042A0F5A7A05200555D1CCB9BDDDDB00E1DD8F4C3EF2FEE0FFFC9DDFBC79
	F33A0274DAED539BA72E9EBBF0F8634FA14B3FB001C6A3D1E170ACE093A2CCB2
	344D53224200722E888A062034556646A458F81311001A281280DA7C310F5558
	660500E71D1333131054655597B59802589E35EE5C7DEDEED5D756374FAFAC6F
	ACAE6F75D74FFF381E70EF2E310555500250C7044BBF7446E07CB2B3B75B97A5
	4F979F717E74FF852FFFEED33FF1B39B672F7D54B7FF475FFFD2FFF0DFFF2F49
	37935099AA06730DB8787AFD1FFE3BFFF067BEF8773F9801BAFD3E020C8F87A3
	E37150F1DE67699A6759AFD75BE9F71B8D06228A888A1A18333F2837C1A8AAAA
	AA2C99D827AE2A6B330303308D010A019088993D80881465C1CC8EF8E6F5ABD7
	AFBE85A06992F6FAFDFEDAE6CADAC6CADA46A3B7F6232AB23F93A8EFDEBB9B7A
	A712005409D480F0C40F140068B2A8ABAAF2691300EEBEF5C357BFFFE29D7BF7
	1E7DAEFA3069FF3DE7FFFEBD7FD6E8668DBC11347304CCEC90C633FA2FFFABDF
	F8EDDFFCF8DAE6B90F6000EFBD775E91D22CAD67F3DDDDDDFB7BC3A2AE12E241
	BFD3EF77D7D7D737D6D6FABD6E96A54CA4A648A4A11E8D27CC94A789284810D1
	0006B508181A989921B2998520604644CCEC8888B9D96AAAAA2900E2F0787C74
	7478F5F5579224497CD21FAC76076BFDB5CDDE60CD373AEF49D4E3BB6F4CCB3A
	CF9BA281283A0128281010929EA08C4555192200FCF0EBFFFCEA953791132474
	CEBFFFFBFD8BEDF48357BEFBBD175E5ADB5A2BCA39000506A7501335921C33B8
	79EBEAFB32405DD74C44CCC44C8C2216427D7C3C1C8DC7AD865F4DDBAA5AD5D5
	CECECEDD7BDB4C9864D9A3972E7DE693CF3AC78B62816084E81C9B818854555D
	D741CD0841D454A5AE4D44889889905041638360A6200000DE31122A93E39C98
	8BA2A8157676EEDFBB7B5B0D12EFD22CEBADACF5076BFDB5CD66AB75FD075FB9
	FADDFFEB0B7FFFD72E5CB8341995695E22997704403107802A008D27E3D5C160
	FBDA1B07DB776FDFBAC3DE27840F68D7F7F9FCFFE23FF6D5AF7D05188256A00A
	0464CB7F8BA9A85DB97EED339FFBB9BFDC00DE7B11318024CD2484E1687E7070
	6462839501129A8299A59A1A588CB0A3E3F1F97367B3D41F1D0E93246176798E
	26A66AA602A0000660A2222266F109A299A9A9D5461C3B04204462676AA6B196
	D53A188A10211125492EC1572118405985EDBB77EFDCBC4ECC9EB9D16E772FFF
	D2643C3EDF6BFF9BBFF45347E3C9BDBDBDA3E1383E7B4E5C9E27C3D9F4F2B9B3
	FFEE2FFCC28D375F3B381C6649EA530F800480481F49081A8E0E7EF74B7FD0ED
	B7431D88967627060595BACE5AC9F59BD7DE6F0E8801BDDDE9CD8BB2288AC1A0
	4F88220A0662AAA626224182A881B5DAEA9CABEAE0BC77DEA9A8A929A884106F
	5C55558389890453430655254460D6D848074124230B75ED9C238420C1008878
	59DEAA012A323638030211F1DE13E6551DD4743E9B01F00F5F7C21CF1B3FFF13
	3FA966F3A298158BA3E3D1DDFDFDFDE3C3EDC3FD9F7BFAD39FFFC47393F16434
	1E27DE11938A191A227AEF3F4CE7F1E07CF3DBDF9C1FD6CDCD56A11501685020
	00235255833C6DDCBC79CDA4444EDF6F0E68B65AFD6EF7EC9973665A56755196
	8B4551964559554AC4CE7933038DEFC73B5F61A1226A66662AAA6AA2B1E53222
	2A8A2ACDEA931C0000686A8E0910C51442EDBD1755A92AE7D8CC625D0B688464
	0841040195140454C4009129CB920878A8884AA3ACEAD9FC285604B94B2E9EDA
	7AE4CC6951E524C99374365B84103AAD665155AA8AA002102498E94752FF7CED
	856F644D174C01205E3E9C14C2AA9AB1BB73349C4C469DDEFAFB3540A3D952B3
	BB3BDB8ED93BEF9857FA1DC72BAA56D5F57CBE98CF17555D4A3055754CA28684
	606A0031E068D05A83994910640403530B410080D900001D33A2980182A83293
	8AA9283303A268400401256422D4136F028805B041080F0208A0C5AF8A0F2084
	6A341E6759B2B9B9391C8E5EFAC1CB1BEBEBFD5ED779D76AB789B02A6B05984F
	463EFD0860F0EDFB775F78E15B83DEA00A4B508B081448558129D6618BB18C46
	C30F600097249D4E6F519465551F1C1E15F3C5743A0F1A06FD95F5CDD56EA73B
	18F410703C9DF9D4D72130A2998A280048BC7F096020226AA041EA10AA109889
	91021822B2511502011A9A9AAA2A2139C78818F30D028520024A8444CC0E9D77
	2188AA12A92A8994C48C8006602AA6060884A806A74F6DA559B6BBB77BF3E69D
	AA2AEFDFDF9D4EA63EF1CEBB3CCD1A8D2C49B3AD53A776AEBDA1E5BCBB32F830
	A4D0ABAFBD1216A0BDF83C1E247E202207040044A401168BF907822230CD7330
	73CC88305F14E3C9988876CAEDFDA3036697B2EBF6BBAD46B3DB6E11919A5930
	0593102C769F66755DABE9707874EFDE4EA7DD2E1745B3DD6C359BDE7B846066
	8814913C62330564080109D5790F8021888121A002804A55EB12F53603600420
	762A8AA831DB307108C28ED637D6431D6EDEBC55D7C10042D03CF38D4646CC04
	B8582CCAB2241A13BBBDFBDF4E5FFE5E9AA7CD76B7B7B2BAB2BAD15919F407EB
	1F8820BA76E33A702C7E15084863274E800AB0EC0741613A9DFEB928D6EFFED6
	E7FFD62F51D67C171694E58DAAAEA6B3C5E1D1B1485859E933524C8B6A1644F7
	F6F6AF4F6E10D3B9B3A7EA503B661395A022A26A665694D59D9B37F6EFDC8550
	8C8FF7673BDB492BCD9B9D46A79337DA59236BB73B59EA139F20908189AA1928
	A1561521456843CD404D114D150098091183D4B1CFAA434044C71C0CCAB2CA1B
	D9CACA60341A1F1D1E8A1A22988A19D4A1AAEAC0AA4C94A60922C63A18205380
	4519E68BFDFBDBDB8490A6699AA6ED5EBF3F58EF0DD67A83B5F660ED2F902B98
	D9EEDE9E23D01004041563014CF1172B202C5177A97FE47778E10FFF59391B89
	19BD078C4BD27477F700087ADD5EE2C8CC444C4DCD2C486D6248D868349D73A6
	80002212828A8420B588EDEDEEDDB9FE4679346A26896BE4119D0CF3C56C3C9B
	6CDF53A4B495E7AD56D6ECB47B2B8D66236F36F23C77CEB3A1218A0980117374
	9148AB9999AA21981928C8B21606A843D010066BAB599AEDEDED8D2753C7CCA0
	751DCC2C56538C84800028A28E59544121716C0091D6C8D2A69A05916ABE98CC
	E6F76EDF2246669FE7D9CAEA6634467F753D6BF796573F3FFAFE1FFE936470AE
	D9E85475002204A5187F008002A80354C7A4A0AAC03FAAD6FAEAEFFE76274F42
	9689AA7F8F011ACDE68573A7DBDDEE625116C5A228ABBAAE540C00D4BC9A8181
	73819855A51659467CD5E97C71E7C6F5E19D3B5E75A5D78828850180AACF9265
	940C2245399F2FA6B0BFA7D77C234B9A79A3D56DF6FACD562B4DB346B395260E
	D40821BA021279E7247A84458A4811494C98E8F4D93326766F7BA7284BCF4E55
	EB10EA5087100C4182060B1EBC8822A210A29A73CE54C392322244F4CC897355
	0866866952D7220AA3C9FC787405AF5D2142EF5CD668F6D736FAFD95F1F695E3
	FDED4F3CF3C5F53B879349D96C965257CC9E13F609C7544C442AE0081424C91A
	EF7DFBFFE277129046B3391E1F7392BF178ECEB2C6A22A9ADACDF3ACD36D2380
	8A9565399D4E1755154240003048920489621AADEA7AF7FEFDBB57DFB0F1A4D7
	F18809C5974F6800A06C001AA91BC7CE717A02D58420D5E170B17F7860EAD23C
	6B67BED9CD5B9D76B79BE58DBC91A749CA4C7672FB8428668400A6CCBCB1B939
	9F2F76F7F699D03B568D5939560091AC0315ABA522E6501B8022B2854048AA8A
	C8E41C0048088618090F35734C00E631414203D4200638994E0F0E0E1D63DEEA
	5076FEB5575E594BE83FFB957F3099CEEFEEDDDF3D3ADE3D3A9CCF0B02002097
	71234F8F675533D17EABFDAED6E10F7F47CBD9CACA40EA80E462FBF52E03E48D
	06081C1C1E15C5A22C2AEF1D11FA24397D6A6B2B4DE3754FC6132292A0A23A3A
	1EDDBE7E65746F3B739AB452500032F6EC31B653068000F13142BC9688D13101
	659C241CFF8B0493C9AC1E8EA64A7B04AED5C8DAEDB4D14A9BED56BBD36C34D3
	2CF5CE031A328B489AA4A1AE77EEEFFAC483998A8AAA2D3906955ACC14099730
	131880D6B5311BA203346232B5BAAA989928465A71CC9E9D8185500380639620
	E40881D2D435B25C5544EA45319F8C8E885CAFD95CED741E3F7FB6ACC3BC584C
	17C5E1E8F8FEE1C1683ABF3F3AFCE213A73E7BBECBA37B004F2EDFFE977EB75E
	8C7BBDBE9A1200B28BCDE0BB0C9066599EA70AA4E6E7F3C5BDDBF78E8FE789A3
	D75F7BA3D7EDAE0C56FAFD6EB7D36EB55ACEF3F6F6CEADD77F88F3593BCBD845
	560000C0828A2302881C3D133AC7A99929D412633304353530804823BA04214D
	CDD218642CD4D5EE7E01BB02C049E69BB9CB9BCD4EAFD9EE6479C3A7496C0A89
	10CDD44C44554424C4D2564C01404D35083093410025A45865090A222102138B
	86C4395B0A3B4C54E23311132925121E888A1A817770EC1D3BF1695587D96C4E
	84D1BB8969A5D5DCECF59E79F4D179510495AD5EC387113796C9E35B5FFEBDC5
	F8B0DF1F981A3A5415E7FC8F304092664404C0E3D1ECE0E8C8F9ECECE93610A8
	485195376FDEBA7E5D0DB4D7E93E7D69ABB8FB560F4AEE6622A010D948103547
	B87CEC068410D400000199C0139880213846155036D1E8364000014C1510009C
	7309E349D7AB935139194DEFDE3572BE9D2A25672F3CB2B63620A41004000122
	A60A2188AA81819A9AAAD9B25240007227D785F1F33B62325551414202242411
	61263941BD18B116654655101140008BF420124133CB14CCC06227B458147358
	A81A337B76BBC3827DEBE0BB2F77AEDE46C2B098C6B7CF440828AAECFD8FA024
	1BCD565587DDFDBD10AAF5F5358718DF97045133551113532DCBFADB2FBDF1EC
	334FAF273CDEBFC752593D0F4559055506110430885459BC4400033344062CD1
	08D000D80303B0229885600A4018716B54B5A06000A8C0C09CB10368E4086095
	84C5D151187463DC404288ADB04AA8458284BA1609A1164BC1C024087B262291
	50A8201122C63420410001D44080090D62D12B8E5854C020A88245E402018010
	638781044C0C082651A88000E09D373450100D416AAB6B99CF8286AA5CACADAD
	365B9DBAAE9DF76A262AAAEA7DF6230C90A49967DEDC5827A2A2AAEAAAAA4388
	A69220B5A90609523B9F00002499EFB44321A2AA6191F4DDE95E77B47383AB49
	5D179558105341620005040403056088B910E7A500A1A92190F7E00C43500434
	0462F386410108044C145821903140E2099BCD2CCB97BA24C51872445455CD54
	0D1645391A8D6B11CF3E4DBD050006406044428C54918929AAA925DE8B68AD02
	12CC80081142A4FCD49488E203073000870848A822AAB12A33440CA2608AC4A0
	600688646080E6BC5FE9AEB55BCDA2AAD2248D0D1A21116259D5CDF6E0471820
	4DD346B309EC13C744A46A41EAD96C315F2CCAB26209E63D406A91FE4674482A
	004845606DE41B4FFFC46E09AB2B83E2DEB5A49CA4A1202D25545A07350B82C8
	8E3020B14F214F4014CA4A15B4AA40400150D412460604046258D2CE0042A600
	41416AABAB104444A30A4254354414D634A8CDA693BD3B37B5129D0E8BD17ED6
	EC369A79D668E7799638173B0CB510509C31115575CD480010130300881AA120
	3120AA1931814184A5820A9D48106252111342048CC685A08211480668B7DAED
	769389B13204B25815AAA8A2A8648DC68F30003BE77DB27B78182A51159FB8C4
	FB3CCBCF9E3E05886559CE678BC96C5A95B5631763E1D9AD866FA547B36A32B3
	CA6A4597F506616F6F5219A52D08155095F89042C8A0660812A0286BA980B394
	189A1E3456546095A804748E545514F044F4880C89020218530D0644C8CCCC12
	049014542444F0FCE8E868E7EA9B7955E69947A8745A85F170426E927ACC1A69
	A39536DA69966679C3314392304310212202248E143812A106D110889863AE8A
	80AE0123A919A0A92AA022A2891A2213AB6AFC33915CE9F67BCD46D33157559D
	26293B9220664A44485885E0933436D5EFD10561A3DD494763461C4F1777AEDF
	DBD93B740ED75656D6D756BABD5EBFD7EDF74F03C0643645E476C36F351B6676
	B69156EB5CCE6F9CDBF24C33D74EB022AB4D2909C6731130F33E3D7FE1DCF4D6
	D5FE464316E3FDAB6FA90624E0B4E5F21C0132A790A88A1AA211043009107164
	5160002665264FC08831462398A805913AC8CEBD3B87B76FB69C66DD14010D88
	00994104442B9ED732399E114E3D53D2E0B499B53B79DECCF266927A6662E558
	C5B1632404013535413089C510222260E4622D42B96A220A8821088031B14625
	72B7DB6AB61C47AD66741E0330660203222E66F3BA0EEFF18065DACCB20C09EA
	528E87A3A2AE36D6FA8E59D56EDDD9965B37995CB3D1180C068395DEFAFAD64A
	275B69E278515308A96A13CA41871546672F346F74F1AD6B8750063CF9E6015D
	DA5D9B358F9FFDDCE77FFA0B5FD8DDB9B77FEFCEED2B7FBA7FE38DE1DD2BA1A8
	EAAA7679871B49AC7E1C8003334001AB0356624181C182824435B02A00AA84AA
	0EB7AFBC39DFBBDFCB9C4F3D82110202C620C60C0089011080374535AB26504C
	AAE14EE59361925192278D8E4BB334CFB22C4F7C922451C824B1FA548D250112
	42F47B030BA284C84C48A4A2311222E1CACAA0D16832E3894ECCC44C55104982
	FAC42F16C5F557BFF7FC2FFEEB9117726F234CA608E45C727C7C3C9ECCBDF7A7
	B636C14C44CCB4D16A6A105509A2DBDB3B57AE5CDB3C7DFA997FEB67C04A0250
	44234280200A661EE442DBDDEEA4E3FB0521A1A181856A5E160BABEA10647F78
	3C0F70F1E94F7EECD3CF17F3E9F1C1DED1DECE9DAB6F1CDD796B78E3F5B22E91
	72205460050040EFCC3B080124AAF200C1964CC074B6B8F2FA9FD68787DD8E77
	1E63FF8111760350B0580123820340200508C206F1B76AD554CAC9EC6887BD9B
	70062E73CD76DE68FA34CBF2DC25DE3147AD25018650032231C7820988551550
	1030F24EDD6E2FCF73623435E448412F41145561EF55EDFB5FFBD2D39FFE7CAB
	BF7AE201A691A78EA5AE4F3CB3DBDC5C3383AAAC4515114C971C6F55852021CB
	934623276207D18F2C5617AAC6688628AA19BBCD8E9F1C392B838280921100A2
	CFB2FD83FDFFE3377F73369B9D3D73F6677FEE67373636F356E7F4A5CB4F7EFA
	F9D974321B0DEF5D7BF34F5FF8E7D562B118ED4929215805008E9D0387608E08
	2152114747C35B6FBC2CD379AB9529605503B3392607A6068E11014123B20400
	80441E20613080201A8C8808817C02410348696521B3E1B101261E7CC669EE1A
	9D34CD1B8D3C4D52EF9D73242198199C24DB78C58438585BEB74BBDE39045014
	242624557B201E24A2EF7FE32BE72F5EDABAF8E8BBF8005B96D24A484996F7BA
	DD7E7F2516D1B5D48B4559556559D5A10E690AAAAA26655A139186D27899A334
	8AA28801622783E77AF9B56C5A2F4A312B1613CE1A08B8A8AA9DED1D243E77FE
	C2A38F5C72CCE3F1888988C90CD22C6F767A79BB5B153351998C47B3D171313E
	2A67A3F9E8A098972A2021A81912DDBB7B77FBEA5B0D08493743592A56292AB8
	1599C9800801189080F181AB9F5882804F0492AAC0EC84C0005C021E40EB5AAB
	69984F167B3B4372E813F659D66EE78D7696676996A7898F9046242CD8B956AB
	858875083199E0F21E204D3C0030272F7DFB9BEB1B9B9B172F6B789B16750F6E
	5F44C0A1F3C9743A99CCE7A1AEBDF7AD46334B93955ECF7B5E14E5643A5B921B
	C8DE91A83046E01C71A9374000232040E8A4C96A3FBF7D349E0D2783D367D32C
	1F0E87605655F5A38F9EBB7CF9F26075A0AA755D2931092191845055555D95BD
	6E07D8F5FBFDE1787AFDF60E662B2B9B8F78B2E2F87074B8036171FFD6D5E3BB
	57DA10B27682003194126294C711C6EA5199DD896C9708D408188090C4C01478
	29AA87282D8EBD770CA4E219815CA2997A11A9A592A2984F8FA640E09CCB3297
	B61BAD569235D22C6584487C02D849170A680000A10E599AB24F5EFBFE8B79E6
	2F3CF9F1F96CDA597D9BA77451E916DF860649B3ACDB6E17B51C2F16FBBBFB87
	C74309BABEBABAB6B136E8F7FBDDCEFAEA40558EC7B3B298999A222021183061
	108D3032119881673ADD496EE7F95A6B256F3677EFDF2F43581DAC9DBB70EED2
	C54B4992148BC279EF9889280AB6008098250451655442CCF3ECEC858B45D0F1
	D15EBF99B42E3E3A9FCDA693F1EECEF6D6E9B3140AA9665A0540355BF2C79EC1
	8054140854148918811830967C1835744AEC1EA0DC4460003EA67502070402B5
	045D4E5F71C303A81A8018482DE57C5A1C8DA600408EF3549D3B75E6FC858B17
	4195891110090D4044EA10922C7BF3951F6A31BDFC133F531615A83A9FBEC303
	96112882FE9A246994135675985765B3D5CA924CA4BE75F3CEF5EBB7D853BFDB
	EBF7FBDD6EE7D4E61A20AA2A02050D841891C5F82109C1C036F2E4FC85B307F7
	8EB7EFDDE90F36363737CE9D3BBFB9B9A9227555817766A61C15A4142444D190
	8804514025A2CC3B4F41C10DD2750975E67D6330E8F57A69DEBA7EF316825959
	867281D52C636228A09C9A80581070440A080C000C6880A46000914601022064
	809328143D174151895919216157AB06010008A2D15B18C079761EF29415A0AA
	55EA62727814FABD2449425DDBC9184BEC627C920CF7F726073BCF7EFE8B66C6
	CC2A9864F97B38E1386C84AA9AA46910391A0E8384ADF5CD88C485109A4D1011
	5199CF17A3D1B896D069E6677FF113CD34B138B8614A8880A81A032EAA69BB91
	358F0F6FD78BB5B5CDAD53A7CF5F38DF69B7A5AEC0278850D7C0AC6ACA224248
	4835A24F7C5DD57BFB078898A6499EE5CE3BCF40891387AA6612D4809912EF4C
	A176AA02B31AD61F7B6AB0BAFAEAF7BFD34D10C6F75D282D14B8E45341915001
	C01181588830382B3CA02B001451CD00A2B69100141C1193AA82070AA2C14075
	99DE23D99679C20409BADD4E2788402C5B01C810C092249D4D7771367AEA33CF
	2345361B4D2C4DDF610022365355B45896BA2488B49AAD7EBFA7AA759028BD0A
	12425DD712BC17805C45D5AC0E6A9919181246ACC3110514334444322684AD86
	CF3FF3C9D47C7F65C531D7418808428DE05514CCA9AA31A3A299117174C6B5D5
	95D9A2A8AB6A383A1691C4A700D6683412CF41CD3B471156348980049A38E77C
	9A53B397F4FAFBA54212B4983BAB13ABBC560C0119CAE95899B3665721229941
	2DA2202451F2A4800004C014153E4BCC1C003C1003C40F6E606149782CD3469A
	E584A8A07022834A92F4E8E070EFC695A73EF53997A62A81999828203AEFDFE9
	01D12D89996375D5EFB69AAD4E1D44CDAAAA2A8AA22CAB1024A45E55967A0485
	B2AA0C62ABB784A50C4CF401BA1EC95BEAA77ECE616DE5B4AA2A604EDA82092D
	8E251D4CA80B601C510D400033C4AAAAD0244DB3C4274458ABED1E1C4E2753EF
	79365F5455E5BDCFF32CCA8D8868A9488F5F6EE6B39452AC552580526A9A466D
	CBEA60AD181FAD5D6897A3A3DD375EA2105C4A49B399367B6A91D4498ABA92E8
	0A004E0001C44001401481F06424CB54CD2C2134802016D9346256D5382364AA
	2E498E8F8F5FFBEEB79EF9DC4FE6AD76A86BC70C80AA0666C93BB4496EC9B55A
	1C7384FEEAEA139F7C7E3C3A5E4CC775314B53DFEFB611A928CA45592E168BAA
	AC83D46AE6B3D48096F52B3D48FE86CB89484204036BE45979B44B1B8F2666B9
	1C25D3BB20C57832492F9C71CE231811A9082245A3C57E9388830651649F77D6
	CEE4BD7A323CECB7204B93E3D1645E1455510291869A7029A6086ADD66FEDC96
	555CF8CBABD3420E0F27D5A2D6DAAA40BEB9B280E4D9BFFDF3674F9F1E1E1E1C
	EEDEBF7BF5B5833BD7F6DE7A4917053B489BCD46DE5176002ACB619E08C7810A
	1944CED35C44E3E215797520000017A1494441541353382155CC27899E10418E
	DD6C3E7BEDC5AF7DE273CFF75637CA72414448242A86A8002E49FF8C07204531
	79A7D379E6B94F9765319FCDC6C7C3D168381D1D87C5CC7BDF6D3715B00E613E
	2F16C562349955B5829D14FE86082732C493C93D006076991D2B49B73AB2E337
	859B47C3A271FE79C8BADED44E54C86A1ABB575505D320819D93A050172D2668
	A4B6483414CEB9C14A6F8D68783C1A4F2678E204CC6C0A0D9BB6335C5475AFED
	8A0697FDC1A2D65121D30A0B5B00DACEF6CE6251B4DBED0B4F3C7DF999E7E6D3
	E9623A1E1EEC6DDFB8BA7BE3CDFDAB2FD7E3A94B28C9F266AB85CE45BCA30E85
	0A29402D1082BC5DC3AB31012306409FA6482C7595F8A4AAEB57BFFDB5C79E7C
	AE3BD8A8CA72F9F0C930C2782AF4CE10B4BC29043054333360E7726A341ACDD5
	B535552DCB6A3A391E0F8FC7A3E17C3272E53CCF12C26E2DD64E4AB5C9725283
	965A9228EC615A6A0809B19965AFBFFAF5BC978A2593F141A5DC6F0F90398E56
	AA9A6317FB7055434233D8DB3F429024491B8D9C1549A4DDF0758DA22AA22E72
	F548806626914F97BAE0EAA8566066514DC112D0B6878DD4D76A01CBAB1086E3
	F16C3E3BD83F78F6B9E7CE9F3BE77CB2B2BEB9B2BEF5E8539F288B623E991C1F
	EEEDDCBAB67BF3ADDD375F9AEEEFB293A49927CD3611112845D9091080566235
	60150C49EB4A2072498806F8F2B7FEF8E2E58FAD6C9D298B45F4178ECF1F08D1
	7CE406DEEE034E2E0BC088D0948040F1C1609E367DD2683636B74ED7753D9FCD
	26E3E3D1F068323AE6622E41C9204E15889E8C0DA3E15289BFD4B50581DBA3C9
	C178FA44275D4B13AD65341F0EFA5BD17B440212321012C59E108936D70793C9
	645E94A3FB23044CD29499B334CAB954014DF501C010CB445B1C43F5A0ED0745
	04A465DC00683A7A6CC55D9B8F30E0D6D656B3D198CF67CCAEAA888911D12749
	7F6D6D657DFDD2C79EAECA72319D1C1F1DDCBF73F3CE1B3FDC7EEB6594323262
	C88E8900A9C16AA6B5A028D400CE7B4654EF5F7AE1EBA7CF9C593F77A9AA2BC2
	D812B268E4D1502470D67C973491901E88E511911C0140340912A92A02880022
	A6699AF8B4DBEB9F397731D4D56C3A9B8F0FC76FFD515D14F19BC45412AD10D1
	82383D39AF653C2B0E839E4EDD99B62FC4FEE9FFF3BFFE7BBFFC2B67D64F8BE8
	12F47724AAB86C5B8D9857FABD01515585BBDB3BB3D92C4D92F1685C853A4BD3
	2CCBAB3A2C6B6D001155839526C54AF34163151D1B880CAC36683AA0F9B4DB3B
	77EEDC5966AAEA9A4599595989490B45A2087F3251BB3FE8AC0C2E3DF1F4C133
	9FFAFAEFFD76512CCAF1703E3E5ECC4645B1500026244426760C8D8CBDF7C8FC
	EA77BEDD6E354E5FFE5808159805B5F8480C22E1696AF6CE12E86D381A29EA78
	4E46B04F0E715403B8134D099A089871966579636575EDD6F0D6FCEA9F50DEB7
	502958DC49C0CB3AD810D00CB627D3625A20E8E1D8B98DDE743E3DB57A69D01B
	38EF0103318281EA838E084135189445E19D5374CDB5D3349B4DC7C3B5413FF1
	FE70389C4C27F3F90289D024565DDEF1A0E5A303E2520EA086860A8616C5BC0C
	B4DE76ABE74E4B082520332B8B9A53150CCB563C12262A185B2A9F2480D85F5F
	739CD4A12E8BC574329D4DC6E57C329F1C17C7C3B22800402AF169B67DE796B3
	F0C8339F09751D033B21A8E9525D010448A05592E4EF32409CA1FBB357FF67C7
	75E21F437651A20666C87CEAC99F9C0D77C67BD77DD68D9B2310E2B5030078A4
	83457975F718554DEDCD3BFB977B696FEDFCDFFBD42F34F3BCAE033303702CEC
	9CE708C18750A361E29D98856AD14BF2B49948E1AB5ADAADD6A9CD0D511D0E47
	37EEDC338986868CB9917B15A0E50CF3528A61918C060335F06932DE11A92A71
	29524C872188778C712E27CEF113452169FC2E755D491D989C234A5AADB4BB0E
	C3B10CF79B8D95D38FE416AAF1F0703A3A78FD7BDFDED83CF5C4273FAB6A6820
	27F77E523019394644557BCF909A338B6DD4079C18C138A40D49ABFFF8CFFCBD
	FB577E70EF8D17288220888E08C01C7315C28B377627D39002DCDDBFCF958ECE
	E4179FF85CB7DB93BA728E49D1CC1EA0628A184260E283E151288BAC91E5591E
	EA2263DAE8B783685555714E53CDD0965594A83652CA3C1BD8120C7BFB4D9942
	8C71104268A7D964BCDB6C6C0294CC6CCCA814CB6844A428033E514E20228550
	97158089482C295A0DD7BF78161E79E4E060BF9E1E74DBAD70E65C599655B1E8
	F77B806C26B61C2F8B2FC190C90C540D4142A87D9ABCD700041F6A5EC765CD33
	1FFF826BF65FFFE37F92E66D021B163520947578E1D51B5F7DED1E4860845FFE
	C5BFA5C37BA71F79E2F4939F234274CE963C90AA6A044222B867A0FD5E6F78B8
	3F9BCCC7A389AAF9C43B76799E45F13A9A2D1B525004086AA977DE7355057830
	CC16E160345CAEB6B02092F97C7E70AB7161434388FF675CB2C184442C1A791C
	428A50333B379B4F67B345BB9B442EAC5ECC8AE9080012229F65A6E03D3BD768
	B75B89732A0204AA46715ED34063B5100B650333782710041F6665D97BCECADA
	968320E5B408F5775FBF797BB89855811BBD2F7EF6B94BE7CF3FF7DC672E5D7C
	14B45664662F128C396A7B0C63F22335D3109838D4759AA6AB2B7D640EB5DCDF
	DB2FCAC2331F8F8E55D5B16F34B210C4D4000851D12C71713E3CE6FF07607CEC
	0A97A901C10C29AF87405A97EA114484980D226388B21404139E889A5882D4F5
	BC288E27D32C4DB32C4D933449133063036232B01014C0C09CB8259E46140B7F
	A5A50ECC00AC0EE288CC347D8F0142A8011CBB0FBBBD2F69F73FF5AFFD47E3FD
	BB47DBD7FFC14FFF87576FDC22ABD74E9D2FEBF0ECB3CF55551D425D07F614B3
	13018199C5CE7E3902AE2A4C2A0A661229560341CC57B65C5DCE27E37EBF9178
	1E8DA693E9AC28CB78A7518CC3B4D445C63A2CC6A79349D393F20C31A8B57D32
	9B1E3AEAB2A80104D52807625A2A4E96D23744332DD44CE5CCD616202E16C56C
	3E1F8FC72104E713666AE479ABD56424665EBA260219AA9EA8EBF964950C1145
	8A1830CB1BEF4EC2C422C2CE017CC8C1416C0C4E3706A7372E7F0AD969DA4992
	A458CC9310CAB2ACAA0A0C104C448948558899995515398EBEB0458527098089
	2CC7AD18AC975A95645A978BE9A8B7B1DE6EB555F568787CEDC6AD38A5241A66
	B3E952456D71C0461F88F21E58C10C4C344DD2C3E3EDFEA935A9820174329786
	515D4C8B6C6B5E06267A67096EA610EAAAAE9C4F9A8DBCDD691D4D16B3F1D834
	A8DA783C3E383ACAD2B4D96CE659DA62A7B80C8071774C4C5448A4220AC88075
	5938F7EE1C90248984BAAAAA24493F82486462662075E2DD7C362B8B4523CF11
	31F189AA46CA45551CBB18FB63E517ABB128E0082120D1BC280EEEDDEDF40759
	9A78EF502D23F1ADC67CB12026C225688AC055B998CD1683473F16295560155D
	6ECE79500FA1992ECB253374BE38622601182475B5FDBDD1FC185C8BCE6CC5AB
	AFEA9A995135A8002086606A6A5A0541D5CD3317AA208B4531DADF5EEDE444B4
	28CAF9A298CE244952EF38AAE362168A843C5AC4546DBE98A5ADDE643AC9DADD
	77CF093B0F12425D2D35871FE2A868512CCAB21C0E87AABA582CB6B7EFED1FEC
	C729BE88BD3B9F6469D2EFF5565757D52CA2B0914B7008CEB92449BA2B1BBB7B
	FBDB7BFB5297599AB69B4DF6CE3BBF041D51E2A0525195E3E9F4F293CFAC6EAC
	697D1B3853893127EE90C2655964CB898FD89AB1D4CEBBB6CE27D7FF3869AC52
	D249CF7C6654A9239225B008AA0AAA41154350D3945DD43E4E766F934B9BCD96
	36F23A4896BA76BBDD6E35999D98AA443031C20A244100235F4E5207553CFBC8
	E3AD5EEF9D63E26F6F4D548913421F2C2DCFA7E3BB77EFD555B928CA50577508
	655118C0F6BD7BAD76E778747CFBC6F54F3CFB49EF3D31A559C6E4D234616251
	79E6998F3B664064663C013F08D1D4C4643A991E1EECDFDFD91E1EEC1F0F0F43
	5998863449D22C4D92745194B76FDF1E4DE7172F3F05CCC3EDAB7FFB139B714B
	8299E9F2578CFECBCDFC1128F444A5CAB4756AB538746CF3E9B8B1F9D42CDD60
	5C2ADDA3221B11A38A767A7CB87DF37AB3DD4E129F67996372EC90002C729496
	2449EC58114044634901A0A2CB570560A0305BCC1EF9D8B3171F7BBCD96E0310
	2EF78ABCA30A2266530153C00F9090AB3A886A9637F3668B9818991DCFA6D3A3
	9D5B776FDF44976E6D0C08C2934F3FE7386E9A83344D5E7AF987FFF5AFFDFA7F
	FBDFFCFA4FFFD44F8946E409D97B503553F28E8CFB2B2BFDC1CA238F5E2E8A62
	743CDCDFDF3B3A3838DCDB1D8D86F57024A10E864F3CF3C96EB7F7E28B2FAE34
	9B555D1351AC81D0CC0840967B2100CD34B292A6A6E4DCCB6FBC7CA1996D765A
	58959C3612EF558501000218E089039959B7D5B2CDD57911CAA258CCE7CCE45C
	92789FA6093331712CF65534565091A65D3622882A8284D3C9F8ECE5A7CE5CB8
	D868364F52F2891CF4577FF557DFB19B825465B90BF1FD9D2B57DEFAEF7EE337
	9E7CF2C9271E7F3CCE23AACAAB2F7F6F345D3CF6B1A72E5DBCB4B175FA686F67
	361AAF6D6E7AE79C73CCE41C9F3973FAC2F9F3AB83C1B2EC885A2A4450436640
	8228D225F6DEB73AED8D8DADB3E7CE9FBF7869EBF4B9FEDA66D66A5F78F4F147
	1F7B7CBE58B4DA1D4AB34183580B83383C6EA0F6B6E8CFE2C41198414254A8BD
	B43F79F360723AF79B2BBD6B7B7BEDD57359921818C57D77844BEF013029D1B4
	D369B7DBED669ECF8AB2AE2A55992FE6E3F1B40E2184E0BD0740628265771231
	405311249E4DC66B672E5E7CEC89C1FA3A928BCA9D3FB70F2076A1AE18A2B0EF
	2F3F5B5B5BCF3FFF3C33975519DDFEAD3F7D79FBDEBDC73FFEC933A74EA55916
	443ABDFEB5375E7DE93B2F3CF7D9E7DBCD2E805DB870E1F1C71F7F1076D84511
	228129BAE484DB39D98385084080C649D272AED5E99CBB7021F61021848DF5F5
	C964325F944D196EBFFCFBBEB91AEA920005DEDE488B000A446071186C38591C
	1FCF504545106038DE3BEB886363A8AAA82210F752016030A8AB4A0C52EFC867
	1BE71E5BCC67D3D17102F54A9ECE16F3F97C713C1A775AADC1CACA1201443415
	3020C78BD9B4D55F3B7FE9B1D58D5388FC677754FCE8CDB975553AE7DEA70D1E
	A414A9ABEFBFF8ED97BEFFDDA73FF9B953A7B698390EC2AB5A55872B6FBE3619
	EE3FFB99E737373622F4450F34AFEC3F50A68F5C6D90101768C63457CCC657BF
	F15B8BD1B64BDA55A8DF8EFD6066680004A60099F77F74FDFE2B37EFD7A23F77
	61F5E3E736DA4FFE1CF9B6695CAFA371E819CCE2EEDFC5E86031398E55323BE7
	D286CB3243BFBF73ABD7C84F34BB1803EC52E2832772D8BA32E4273EF1E90B97
	1FF73EF9914B427E74A8F1491A42307D5FABF51E7CD3D17874FDC68D673EF3FC
	D34F3DB5BEB6D6ED74B32C2522EF5DAB993FF9F433A72F3C56577592A4DE7B97
	A4E413743EAA673FC8212006269724B1610D21A884246F5DFCEC2FE7830BC5FC
	981169A98C8238E702066A963AB73F2B5EBF77943A5F9472F7FE11B846B3B992
	24DE39EF9D4F7CE2BC8F25037B97A6C96432391A0EE7F385C6A53AD562717C30
	DDBFDBF4BEAAEA10E75B018978F992114C45CD54425194671FFDD8E933673DD3
	9FB7A2E5CFAD797C9286AA720E80DEEF0589D8C79FFDD4E5CB977D92C62A212A
	59425D87109224397FFEFCEFFDC11FECEDEF7FFE0B9F7F47DFF763348027D02C
	290322380350D5BCB7FAF817FEEDEBAF7EE7DEEB2F64BC1CBCF0444006869EDD
	2CE857DED85ECC8AE3E311501D1CB5564FB3F7A84A44F1DE9040D59829EE67CB
	D274EEFCA22C47E3B1634ED224F14992241637653B4624D18001E27E4F3BE93E
	2693C9B9C79E3A7DE66C9A26A08A24CB499DF7BF39D77957D7B5F7F83EEBA2B7
	DE7AF31FFDFA3FFAC7FFDB3F5E5D5B4744886BB80092340713539D2F165FFEF2
	9776B6773EFBD9CFFAF4A3D85E486E290D56430411619F5C7EEE6700E8E6777F
	CF671D009DCE1606488EF687E3DFFFCE9BBBC7559AF17FF0F7FFFDF5CCC362B2
	FAD867151825308092AA29338B880A3976755D39C72BBD0E3947008BB29E8CC7
	B37A3E9E4C1C3B9F24CD469E7A00C2BA0E48646868C6EC26E3D1C6D9474E9D39
	D7E974622C4433B0281CA2F70DC62179EFEBBAF6DE01FEE5F7D5E9749FFEF8D3
	C7C7C3B5F58D3FF3AD189907ABEBFFF3FFF83F19127FE88EEF5DDE80146B3F66
	0E2120DAEADAE65D0A5A8F11F0DEC1F8CD3BBB4090AD5FFEE2CFFF9DF3A7B61E
	BBFCC4DADAA673CE00CAB22453233A1943D208960851FC9DAA1455ED0D98D837
	DAA9CB7532B2B248532FAA8747476A9026BEDB69E779AEAAC43C9D8CDA2BEB5B
	E7CEADAEADC1C942615003C62520F4CEBFBCEA2F5F5F6F2222ECFEF22B8B0ADF
	086D7E243B093F50668E22C20866A88662322AA74747F7AE0D43DAE8AE568B79
	DA6C3F76F9720C5612248410CD2722270312CBB98FA5565975319F5F7BF50775
	55C6F6985CE2F3B6CB1BD3E9B41EED75DBEDB897633E5F6469EABC57D5AA2C81
	938B4F3C75FEC2C52CCB985D84BA89081E94FF480F62D1FBE87B91D9914940A2
	BF3816D109A7FA5771E2DC84C46DA6AA9477079034BFF1E56F6F6C6E3E757E65
	C2499E67A25AD77514BFFAC42F3B645B962EB6EC15962815A91473982DE66496
	24899999D4D5E4683EDCE324497C52859A90C0A0D56A229288888432C8A5471F
	3D7DE6DC72F12AC69F68A9917CDB0627D5D2FBBC2F44A693ED44FF721E540900
	C8C44868A68C787474F0E53FFAF2623E9B4CC693D1284B92130DB6D555B5582C
	66B3F9D1D151088251BCE09889FDC9C9D2DC27E9A2A8EFDEBBB7BDB37D743C9C
	CE16551060923A446196882A6808CB251593C9ECCCA5C7CF9CBBD06C3498E2E8
	E4B23D5E0E1D9E540F0F3CE083FC0D1A1161C77F59FFEA3195AAAEEAAA2ACAB8
	E9AE9CCDE657AE5C391A0E1F79E491E96C3A3C8882DF6C65302022554DD3B4AE
	EBB367CF0C06031161E293257751F58D2184BDBDFB3BDBDB87FB7BC74707E56C
	6A2A699A24699AE7799E654B253E80F36E3A1AAD9FBF7CE9F2E3EBEB6B444CCC
	8ED80098E964DBFC837FFE78068093352480FF6F7B57D3DBC41545DFC77DF68C
	E340660C715C27448910214A202882562081685521166CE027B0A2FF8356820D
	FC8122D6B083459522B1084248846DD934094E4988ED38CF8E27B6E7E3CD4C17
	779C508A0448A405EB9D8D575ECC9C37EFDD77EF3DE77E692F7FA5B4BCBCB4CC
	18F57D3F0802DF0F3CCF45CBEB8D4A25A4D4719AED6673FAF84CDA3000A02F9B
	350DA35AAD56ABD5F3E7CE0DE6079552C0017BD428A18CF308DD3F28218478AE
	DB741CB9B9296B5559AB39CD7AD06EC7244EA745B6AF3F954E87BE670D0D1F3A
	7C6464E49000403F3BD437B21D0276DF3EF99433E0DD00FC8B43CB69964A2BF9
	424100B6CFB0984451183346EB52CACAAAEB13C330F7650CB9B17EE6ECF7B99C
	ED765C10F0E2C5C2AF77EE4E1E9DB06D9B50EC768E19C5208270E071A2722222
	DB9FEDEF2F140A6118B6DBEDAD46A32E656DA32C6BB5A6B315C8CDC2F0687174
	BCF84D312504658CB124EBC0384BBA94E8AE76E6C3A988AF0BF7EFDFBB75EBF6
	2F3F5F3F75F2A4EBBA581DC4E2FCD3F9C77FBD5E3D7C74CA48A5092595F5D55A
	A53CFBEDE962B1E8FB7EA7E3D6EBD2B6EC01CB12023807018087266E472C716C
	239CB377EFFE310954B0BDBDED38CD8694FB07ACE2F0482A25F08F89A30766B1
	9296AAF76FDDBD404043CAE70BCF0F1E3C30345408C390E3EE41C9CAD2E2C2B3
	F9D123D35353D300DC71B6FD20587FB3F6BAB438363E3131390980AECD9C5226
	04605213D56ED05DFE89F2AD5B29DED90618A384B17FAFE84F0E1E7A6694611C
	AA8EDBF13D5F291545D1D65663FED16FC63EFBBBD367D096268EE2280A0961E5
	4AB9B4F4A73560CFCCCEF6F56538E79C032144086038808526CEFC9825678CC6
	31A12816FEE70EFE19A2B71E9B251985810A54BBD379F2F8F7B572E5C2C54B46
	3A1546910A029CA182FD2FAD56EBD5D2A265DB333327305AEF4A055972694AC6
	E3A0349EA3FE752F8E4020BD05C6458A0BD77583889E3DFF432E674561A4940A
	180380388EB1EAC219E3223D60E5D85BD8D1C463871F9A02BD756BDD9300A407
	E7097B9DF683870F070BC5F1B13100815D6F2084619A6626933133A6616E4A79
	F9CA95B9B9B97867A40100FE706C98E140282594EF75E0D783E36CD7D6567F1C
	1EB97AF3C64FD7AE750B84144DE2924C4318B55AAD3F5EBE344DE3D8B1E30200
	9335A4DB93FBF119784DC07BA0942AAFBFF13C2F9FCF0B004A2907A05DE5068A
	D1308EE99A2AD0DDF225A5FFF15D470F74FEBF0FAD5E7DB0AF6561E92F407F01
	9A000D4D8026404313A009D0D00468023434019A000D4D8026404313A009D0D0
	0468023434019A000D4D802640638FF03703A807F4ABF68DC60000000049454E
	44AE426082
	]]>
</Picture>

<Ancestry SectVersion="1" SectionFlags="0" SubIdent="0" Template="false">
	<MainGUID>F938E33A-329D-4A36-BE3E-85E126820996</MainGUID>
	<MainGUID>103E8D2C-8230-42E1-9597-46F84CCE28C0</MainGUID>
	<MainGUID>C76BC373-89AE-4368-A490-BB2485825242</MainGUID>
	<MainGUID>FC9AA201-5720-4CD0-AA2F-A9E9D5812565</MainGUID>
</Ancestry>

<CalledMacros SectVersion="2" SectionFlags="0" SubIdent="0">
	<Macro>
		<MName><![CDATA["fa_minimalspace"]]></MName>
		<MainGUID>948022D5-BA0C-4407-8518-A3B5922DF84C</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["completeTable_m"]]></MName>
		<MainGUID>842042EF-1396-4BDE-82C8-BA46B2D57950</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["deskClosings_m"]]></MName>
		<MainGUID>31AF2F3D-8018-41F0-B40F-C43BB5A93422</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["ui_officeLayout"]]></MName>
		<MainGUID>FB90EF3A-0F3B-47C9-B4E2-B542F0BE127E</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["FM_types"]]></MName>
		<MainGUID>2759D2DF-AA8E-44D1-AD1D-261581266B34</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["ui_tabcontrol"]]></MName>
		<MainGUID>D512885C-336A-4161-B8CB-EE5DC5D09FFE</MainGUID>
	</Macro>
</CalledMacros>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_PR SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_PR>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_UI SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! ======================================================================
! UI
! ======================================================================

ui_dialog `Параметры Компоновки Офисной Мебели`

call "ui_officeLayout" parameters all	iCallerType				= LAYOUT_LINEAR,
										bShowCabParams			= bShowCabParams,
										bShowPartitionParams	= bShowPartitionParams,
										bShowExtDeskParams		= bShowExtDeskParams,
										bShowExtDeskChairParams	= bShowExtDeskChairParams,
										bShowExtDeskCabParams	= bShowExtDeskCabParams,
										bShowExtCabParams		= bShowExtCabParams,
										bShowCommonCabParams	= bShowCommonCabParams,
										stSymbolTypes			= stSymbolTypes,
										iTableTopType			= (iLayoutType = LAYOUT_CUBICLE or iLayoutType = LAYOUT_WAVE) + 2 * (iLayoutType = LAYOUT_STRAIGHT),										iInnerEdge				= iInnerEdge


]]>
</Script_UI>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Comment SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[Вспомогательные средства проектирования с минимальным пространством и 3D-модель.]]>
</Comment>

<Keywords SectVersion="1" SectionFlags="0" SubIdent="0">
<![CDATA[Стили расположения, стили стульев, стили ножек, шкаф, перегородка, расширение стола и шкафа, 2D-символ, рабочий стол, письменный стол]]>
</Keywords>

<Copyright SectVersion="1" SectionFlags="0" SubIdent="0">
	<Author>GRAPHISOFT</Author>
	<License>
		<Type>CC BY-ND</Type>
		<Version>3.0</Version>
	</License>
</Copyright>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_FWM SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
actualGUID = FROM_GUID

! ==============================================================================
! Subroutines
! ==============================================================================

	_autoID		= "4C0813CA-1900-42F4-A1B1-E48ADE51BC24"
	_startID	= "24D27F22-F03C-43E5-AFFD-425996F9EB30"
	_endID		= "E3576C80-076D-44A4-8CF4-D4C7FCB7264B"
gosub "newparameters_FWM"

! ==============================================================================
! Set migration GUID
! ==============================================================================

setmigrationguid actualGUID

! ==============================================================================
end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! en
! ==============================================================================


! ==============================================================================
! newparameters
! ==============================================================================
"newparameters_FWM":
	if actualGuid = _startID | actualGuid = _autoID then
		
		bHas = STORED_PAR_VALUE("gs_knob_type_m",_gs_knob_type_m)
		
		! If Knob Style was 0, that equals with Knob being off, otherwise it is on.
		if _gs_knob_type_m = 0 then
			bKnob = 0
			gs_knob_type_m = 1
		else
			bKnob = 1
		endif
		
		parameters	bKnob			= bKnob,
					gs_knob_type_m	= gs_knob_type_m
		
		actualGuid = _endID
	endif
return

]]>
</Script_FWM>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_BWM SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
targetGUID = TO_GUID

! ==============================================================================
! Subroutines
! ==============================================================================

gosub "newparameters_BWM"

! ==============================================================================
! Set migration GUID
! ==============================================================================

setmigrationguid targetGuid

! ==============================================================================
end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! en
! ==============================================================================


! ==============================================================================
! newparameters
! ==============================================================================
"newparameters_BWM":
	if targetGUID # "" then
		! If Knob Style was 0, that equals with Knob being off, otherwise it is on.
		if not(bKnob) then
			gs_knob_type_m = 0
		else
			gs_knob_type_m = gs_knob_type_m
		endif

		parameters gs_knob_type_m = gs_knob_type_m
		
	endif
return

]]>
</Script_BWM>

<MigrationTable SectVersion="1" SectionFlags="0" SubIdent="0">
	<MigrationTableElement>
		<MainGUID>4C0813CA-1900-42F4-A1B1-E48ADE51BC24</MainGUID>
		<Version>18</Version>
		<Name><![CDATA[""]]></Name>
		<AutoMigration>false</AutoMigration>
	</MigrationTableElement>
	<MigrationTableElement>
		<MainGUID>24D27F22-F03C-43E5-AFFD-425996F9EB30</MainGUID>
		<Version>19</Version>
		<Name><![CDATA[""]]></Name>
		<AutoMigration>false</AutoMigration>
	</MigrationTableElement>
</MigrationTable>

</Symbol>
