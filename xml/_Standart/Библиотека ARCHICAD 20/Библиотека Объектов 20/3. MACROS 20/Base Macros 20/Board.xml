<?xml version="1.0" encoding="UTF-8"?>
<Symbol IsArchivable="false" IsPlaceable="false" MainGUID="94F5BAFE-DE56-43CD-9BC2-A2BF20AAF00C" MigrationValue="Normal" Owner="1196638531" Signature="1196644685" Version="38">
<Ancestry SectVersion="1" SectionFlags="0" SubIdent="0" Template="false">
	<MainGUID>F938E33A-329D-4A36-BE3E-85E126820996</MainGUID>
	<MainGUID>103E8D2C-8230-42E1-9597-46F84CCE28C0</MainGUID>
	<MainGUID>6ACDA889-69B2-4EC5-936C-CB1DA7032A92</MainGUID>
	<MainGUID>F6AE9687-2BC7-4D47-88C9-8F793E1DE2D6</MainGUID>
</Ancestry>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_3D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! Contact person: <NJ>

! ==============================================================================
! This macro draws the Board
! ------------------------------------------------------------------------------
! Input parameters:
! Geometry ---------------------------------------------------------------------
!	A:						wallhole width (length) (Obsolete)
!	B:						wallhole height (length)
!	refWidth:				reference width in curved walls (length)
!	leftWidth:				wallhole's side distance from the origin at the left side (length)
!	rightWidth:				wallhole's side distance from the origin at the right side (length)
!	AC_Hole_Position_Angle:	Position angle of the window in a curved wall
!	offsY:					for positioning 3D along y (length)
! Functions --------------------------------------------------------------------
!	gs_IsCurved:			Does the window follow the curvature of the wall? (0 / 1)
!	iWindowShape:			Shape of the window (integer)
!								0 = rectangular (default)
!								1 = arched
!							Note: only the rectangular shape can be a Corner Window
! Reveal -----------------------------------------------------------------------
!	iRevealType:
!	gs_reveal_left_angle:
!	gs_reveal_right_angle:
! Corner Function --------------------------------------------------------------
!	bLeftCornerFunction:		Turn macro in Corner Window mode at the left side (0 / 1)
!	leftCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	leftConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
!	bRightCornerFunction:	Turn macro in Corner Window mode at the right side (0 / 1)
!	rightCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	rightConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
! Oversize ---------------------------------------------------------------------
!	gs_left_oversize:		Left opening oversize (length)
!	gs_right_oversize:		Right opening oversize (length)
!	gs_lower_oversize:		Lower opening oversize (length)
! Sill -------------------------------------------------------------------------
!	gs_sill_oversize:		Identifies the method as the macro handles the nominal
!								opening sizes when Sill are turned on. (0 / 1)
!	iSillType:				Identifies the type of the Sill.
!								(integer; 1 = Standard Sill, 2 = Brick Sill, 3 = Stone Sill, 4 = Ceramic Sill)
!								(5 = Eternite Sill, 6 = Concrete Tub, 7 = Aluminum Sill)
!	gs_sill_thk:			Thickness of the Sill. (length)
!	gs_board_width:			Width of the Board. (length)
!	gs_board_thk:			Thickness of the Board. (length)
!	gs_board_nosing:		Nosing of the Board. (length)
!	gs_board_angle:			Board slope. (angle)
!	gs_board_ovhg_left:		Board overhang on the left side. (length)
!	gs_board_ovhg_right:	Board overhang on the right side. (length)
!	gs_board_slip_in:		Slip in of the Board. Only effective when iSillType = 2 or iSillType = 3 (length)
!	gs_board_curved:		Board edge is curved or straight. (0 / 1)
!	bShowBoardSplice:		Show or hide the Board's joint line in case of Corner Window  (0 / 1)
! Ganging ----------------------------------------------------------------------
!	gs_stack_left:			Align to door/window on left side (0 / 1)
!	gs_stack_right:			Align to door/window on right side (0 / 1)
!	gs_stack_bottom:		Align to door/window on bottom side (0 / 1)
! 2D Representation ------------------------------------------------------------
!	gs_board_fill:			Type of the fill on the Board. (fill type)
!	gs_board_pen_fg:		Fill pen on the Board. (pen)
!	gs_board_pen_bg:		Fill background pen on the Board. (pen)
! 3D Representation ------------------------------------------------------------
!	lod3D:					Level of detail. Not used. (integer)
!	gs_frame_pen:			Drawing pen of 3D. (pen)
! Materials --------------------------------------------------------------------
!	gs_board_mat:			Board material (material)
!
! Related Global Variables:
!	GLOB_SCRIPT_TYPE
!	GLOB_CONTEXT
!	WALL_THICKNESS
!	WALL_INCL
!	WALL_RESOL
!	WIDO_FRAME_THICKNESS
!	WIDO_SILL
!	WIDO_LEFT_JAMB
!	WIDO_RIGHT_JAMB
!	WIDO_THRES_DEPTH
!	WIDO_HEAD_DEPTH
!	WIDO_ORIG_DIST
!	WIDO_REVEAL_SIDE
!	SYMB_MIRRORED
!	SYMB_ROTANGLE
!	SYMB_FILL
!	SYMB_SECT_PEN
!	SYMB_FILL_PEN
!	SYMB_FBGD_PEN
! ==============================================================================

widoInnerBottomJamb	= 0
if iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC then
	widoInnerBottomJamb	= gs_reveal_splayed_innerBottom
endif
if iRevealType = REVEAL_DOUBLE then
	widoInnerBottomJamb	= gs_reveal_double_innerBottom
endif

boardLeft_sL	= 0
boardRight_sL	= 0
boardLeft_sR	= 0
boardRight_sR	= 0
boardElevation = -overSizeLower + widoInnerBottomJamb + bBoardElevUsa


! Draw Board -------------------------------------------------------------------

if bDrawBoard & lod3D > 0 & ((WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS + gs_board_nosing) > EPS) & not(gs_stack_bottom) then

! Save the current parameter buffer --------------------------------------------

	dim savedQueueValues[]
	call "SaveQueue" parameters returned_parameters savedQueueValues

	if gs_board_fill	< 1 then gs_board_fill		= SYMB_FILL
	if gs_board_pen_bg	< 1 then gs_board_pen_bg	= SYMB_FBGD_PEN
	if gs_board_pen_fg	< 1 then gs_board_pen_fg	= SYMB_FILL_PEN
	if gs_board_pen_3D	< 1 then gs_board_pen_3D	= gs_frame_pen		! Compatibility

	rotx -90
	if WIDO_REVEAL_SIDE then
		addy -WIDO_FRAME_THICKNESS
	else
		muly -1
	endif

	resol WALL_RESOL

	if not(gs_turn_plaster_show_3D) then
		thkPlasterAtBoardLeft	= 0
		thkPlasterAtBoardRight	= 0
	endif
	if gs_stack_left then
		thkPlasterAtBoardLeft	= 0
	endif
	if gs_stack_right then
		thkPlasterAtBoardRight	= 0
	endif

! Draw Board -------------------------------------------------------------------

	if bTShapedOpening then
		if gs_board_inside_sl_left & gs_sidelight_left & gs_sidelight_parapet_hgt_left > EPS then
			addz gs_sidelight_parapet_hgt_left + (gs_reveal_double_innerBottom_sL - gs_reveal_double_innerBottom)
			sidelightCutLeft  = 0
			sidelightCutRight = 1
			sidelightCutPosRight = -leftWidth + gs_sidelight_WHole_width_left + bDrawInsideTrim * gs_trim_width_in + gs_reveal_double_innerLeft_sL + thkPlasterAtBoardSlLeft
			gosub "DrawBoard"
			del 1
			boardLeft_sL  = leftWidth + gs_board_ovhg_left - gs_reveal_double_innerLeft_sL - thkPlasterAtBoardSlLeft
			boardRight_sL = -sidelightCutPosRight
		else
			boardLeft_sL  = 0
			boardRight_sL = 0
		endif

		if gs_board_inside_sl_right & gs_sidelight_right & gs_sidelight_parapet_hgt_right > EPS then
			addz gs_sidelight_parapet_hgt_right + (gs_reveal_double_innerBottom_sR - gs_reveal_double_innerBottom)
			sidelightCutLeft  = 1
			sidelightCutRight = 0
			sidelightCutPosLeft = rightWidth - gs_sidelight_WHole_width_right - bDrawInsideTrim * gs_trim_width_in - gs_reveal_double_innerRight_sR - thkPlasterAtBoardSlRight
			gosub "DrawBoard"
			del 1
			boardLeft_sR  = sidelightCutPosLeft
			boardRight_sR = rightWidth  + gs_board_ovhg_right - gs_reveal_double_innerRight_sR - thkPlasterAtBoardSlRight
		else
			boardLeft_sR  = 0
			boardRight_sR = 0
		endif
	else
		sidelightCutLeft  = 0
		sidelightCutRight = 0
		gosub "DrawBoard"

		boardLeft_sL  = 0
		boardRight_sL = 0
		boardLeft_sR  = 0
		boardRight_sR = 0
	endif

! Restore the saved parameter buffer --------------------------------------------

	call "LoadQueue" parameters savedQueueValues = savedQueueValues
endif


! ==============================================================================
! returning parameters for cutting the casing
! ==============================================================================

dim boardPoly[]
	boardPoly[1] = 0

! --- cutting shape for casing ----------------------------------------------

if iRevealType = REVEAL_DOUBLE_SPLAYED & gs_reveal_bottom_angle > EPS  then
	boardPoly[1] = WIDO_FRAME_THICKNESS - bBoardNnosUsa - EPS	: boardPoly[2] = -boardElevation - EPS * tan(gs_reveal_bottom_angle)
	boardPoly[3] = WIDO_FRAME_THICKNESS - bBoardNnosUsa - EPS 	: boardPoly[4] = -boardElevation - gs_board_thk/cos(gs_reveal_bottom_angle) - EPS * tan(gs_reveal_bottom_angle)
	boardPoly[5] = WALL_THICKNESS + 1							: boardPoly[6] = -boardElevation - gs_board_thk/cos(gs_reveal_bottom_angle) + (WALL_THICKNESS + 1 - WIDO_FRAME_THICKNESS + bBoardNnosUsa + EPS)*tan(gs_reveal_bottom_angle)
	boardPoly[7] = WALL_THICKNESS + 1							: boardPoly[8] = -boardElevation + (WALL_THICKNESS + 1 - WIDO_FRAME_THICKNESS + bBoardNnosUsa + EPS)*tan(gs_reveal_bottom_angle)
	gs_board_angle = gs_reveal_bottom_angle
	boardSideHeight = boardElevation + gs_board_thk / cos(gs_reveal_bottom_angle)
else
	if abs (gs_board_angle) > EPS then
		boardPoly[1] = WIDO_FRAME_THICKNESS - bBoardNnosUsa - EPS 			: boardPoly[2] = -boardElevation
		boardPoly[3] = WIDO_FRAME_THICKNESS - bBoardNnosUsa - EPS 			: boardPoly[4] = -boardElevation - gs_board_thk
		boardPoly[5] = boardPoly[3] + gs_board_thk / tan (gs_board_angle)	: boardPoly[6] = -boardElevation
	else
		boardPoly[1] = WIDO_FRAME_THICKNESS - bBoardNnosUsa - EPS	: boardPoly[2] = -boardElevation
		boardPoly[3] = WIDO_FRAME_THICKNESS - bBoardNnosUsa - EPS 	: boardPoly[4] = -boardElevation - gs_board_thk
		boardPoly[5] = WALL_THICKNESS + 1							: boardPoly[6] = -boardElevation - gs_board_thk
		boardPoly[7] = WALL_THICKNESS + 1							: boardPoly[8] = -boardElevation
	endif
	boardSideHeight = boardElevation + gs_board_thk
endif

end rightRevealPnts[1][1] + gs_board_ovhg_right,	! boardRight
	leftRevealPnts[1][1]  - gs_board_ovhg_left,		! boardLeft
	boardLeft_sL,
	boardRight_sL,
	boardLeft_sR,
	boardRight_sR,
	boardElevation,									! boardBottom
	boardSideHeight,								! boardSideHeight
	gs_board_angle,									! boardSideAngle
	boardPoly										! boardPoly


! ==============================================================================
! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
! ==============================================================================


! ==============================================================================
! Draw Board
! ==============================================================================

"DrawBoard":
	pen gs_board_pen_3D
	sect_fill gs_board_fill, gs_board_pen_bg, gs_board_pen_fg, gs_board_pen_sectcont

	if iSillType = 1 | not(gs_sill_oversize) then gs_board_slip_in = 0

	if maxBoardAngle > -EPS & gs_board_angle > maxBoardAngle then gs_board_angle = maxBoardAngle
	if gs_board_angle < 0 then gs_board_angle = 0

	addz boardElevation

	if abs(bBoardNnosUsa) > EPS then		! Cut Board with FrameSill
		add 0, leftRevealPnts[idxBoardStartRevealLeft][2] - bBoardNnosUsa, gs_board_thk - gs_rebw_lower
		rotx 90
		roty 90
		cutpoly	4,
			0, 0,
			bBoardNnosUsa, tan(gs_sill_angle) * bBoardNnosUsa,
			bBoardNnosUsa, -0.2,
			0, -0.2
		del 3
	endif

	if iRevealType = REVEAL_DOUBLE_SPLAYED then
		boardAngleTop	 = gs_reveal_bottom_angle
		boardAngleBottom = gs_reveal_bottom_angle
		boardThickness 	 = gs_board_thk / cos(gs_reveal_bottom_angle)
	else
		boardAngleTop	 = gs_board_angle
		boardAngleBottom = 0
		boardThickness	 = gs_board_thk
	endif

	if AC_WallType <> 2 then

		bCurvedAtBoardSide		= (curvedWall & gs_board_curved)
		bCurvedAtWindowFrame	= (curvedWall & gs_IsCurved)

		if not(curvedWall) then

			if sidelightCutLeft then
				py = bpy6 - (bpy6 - bpy7) / (bpx7 - bpx6) * (sidelightCutPosLeft - bpx6)
				put sidelightCutPosLeft,	WIDO_FRAME_THICKNESS,	15, gs_board_mat,
					sidelightCutPosLeft,	py,						15, gs_board_mat
			else
				if thkPlasterAtBoardLeft > EPS then
					startIdx = idxBoardStartPlasterLeft
					endIdx	 = idxBoardEndPlasterLeft
				else
					startIdx = idxBoardStartRevealLeft
					endIdx	 = idxBoardEndRevealLeft
				endif

				if abs(bBoardNnosUsa) > EPS then	! Board Negative Nosing by USA Framesill
					put leftRevealPnts[startIdx][1] + frameWidthLeft,	leftRevealPnts[startIdx][2] - bBoardNnosUsa,	15, gs_board_mat
					put leftRevealPnts[startIdx][1] + frameWidthLeft,	leftRevealPnts[startIdx][2],					15, gs_board_mat
				endif

				for i = startIdx to endIdx
					put leftRevealPnts[i][1], leftRevealPnts[i][2], 8 + 7 * not(gs_stack_left), gs_board_mat	! 15 or 8
				next i

				put	bpx5, bpy5,	 8 + 7 * not(gs_stack_left),							gs_board_mat,	! 15 or 8
					bpx6, bpy6, 13 + 2 * not(gs_stack_left) + bCurvedAtBoardSide * 64,	gs_board_mat	! 15 or 13
			endif

			if sidelightCutRight then
				py = bpy6 - (bpy6 - bpy7) / (bpx7 - bpx6) * (sidelightCutPosRight - bpx6)
				put sidelightCutPosRight,	py,						15, gs_board_mat,
					sidelightCutPosRight,	WIDO_FRAME_THICKNESS,	15, gs_board_mat
			else
				put	bpx7, bpy7,  8 + 7 * not(gs_stack_right),							gs_board_mat,	! 15 or 8
					bpx8, bpy8,  8 + 7 * not(gs_stack_right),							gs_board_mat	! 15 or 8

				if thkPlasterAtBoardRight > EPS then
					startIdx = idxBoardEndPlasterRight
					endIdx	 = idxBoardStartPlasterRight
				else
					startIdx = idxBoardEndRevealRight
					endIdx	 = idxBoardStartRevealRight
				endif

				for i = startIdx to endIdx step -1
					if i = endIdx then
						put rightRevealPnts[i][1], rightRevealPnts[i][2], 13 + 2 * not(gs_stack_right), gs_board_mat	! 15 or 13
					else
						put rightRevealPnts[i][1], rightRevealPnts[i][2],  8 + 7 * not(gs_stack_right), gs_board_mat	! 15 or 8
					endif
				next i

				if abs(bBoardNnosUsa) > EPS then	! Board Negative Nosing by USA Framesill
					put rightRevealPnts[endIdx][1] - frameWidthRight, rightRevealPnts[endIdx][2],					15, gs_board_mat
					put rightRevealPnts[endIdx][1] - frameWidthRight, rightRevealPnts[endIdx][2] - bBoardNnosUsa,	15, gs_board_mat
				endif
			endif
		else
			put 0, WOD, 900, gs_board_mat

			if sidelightCutLeft then
				if bCurvedAtBoardSide then
					py = WOD - iArchSign * sqr((radBoard - iArchSign * gs_board_nosing)^2 - sidelightCutPosLeft^2)
				else
					py = bpy6 - (bpy6 - bpy7) / (bpx7 - bpx6) * (sidelightCutPosLeft - bpx6)
				endif
				put sidelightCutPosLeft,	WIDO_FRAME_THICKNESS,	15,								gs_board_mat,
					sidelightCutPosLeft,	py,						15 + bCurvedAtBoardSide * 64,	gs_board_mat
			else
				if thkPlasterAtBoardLeft > EPS then
					startIdx = idxBoardStartPlasterLeft
					endIdx	 = idxBoardEndPlasterLeft
				else
					startIdx = idxBoardStartRevealLeft
					endIdx	 = idxBoardEndRevealLeft
				endif

				for i = startIdx to endIdx - 1
					put leftRevealPnts[i][1], leftRevealPnts[i][2],	8 + 7 * not(gs_stack_left), gs_board_mat			! 15 or 8
				next i

				if gs_board_ovhg_left > EPS | thkPlasterAtBoardLeft > EPS then
					alfaStart	= -signWallIsLeft * atn(leftRevealPnts[endIdx][1] / (leftRevealPnts[endIdx][2] - WOD))
					alfaEnd		= -signWallIsLeft * atn(bpx5 / (bpy5 - WOD))

					arcRadius	= radBoard
					bMiddlePoints = 1
					firstStatus	= 8 + 7 * not(gs_stack_left) + 64
					lastStatus	= 8 + 7 * not(gs_stack_left) + 64

					if abs(alfaStart - alfaEnd) > EPS then gosub 100
				endif

				put	bpx6, bpy6, 13 + 2 * not(gs_stack_right) + bCurvedAtBoardSide * 64,		gs_board_mat
			endif

			if sidelightCutRight then
				if bCurvedAtBoardSide then
					py = WOD - iArchSign * sqr((radBoard - iArchSign * gs_board_nosing)^2 - sidelightCutPosRight^2)
				else
					py = bpy6 - (bpy6 - bpy7) / (bpx7 - bpx6) * (sidelightCutPosRight - bpx6)
				endif
				put sidelightCutPosRight,	py,						3000 * bCurvedAtBoardSide + 15, gs_board_mat,
					sidelightCutPosRight,	WIDO_FRAME_THICKNESS,	15,								gs_board_mat
			else
				put	bpx7, bpy7, 3000 * bCurvedAtBoardSide + 8 + 7 * not(gs_stack_right),	gs_board_mat	! 15 or 8

				if thkPlasterAtBoardRight > EPS then
					startIdx = idxBoardEndPlasterRight
					endIdx	 = idxBoardStartPlasterRight
				else
					startIdx = idxBoardEndRevealRight
					endIdx	 = idxBoardStartRevealRight
				endif

				if gs_board_ovhg_right > EPS | thkPlasterAtBoardRight > EPS then
					alfaStart	= -signWallIsLeft * atn(bpx8 / (bpy8 - WOD))
					alfaEnd		= -signWallIsLeft * atn(rightRevealPnts[startIdx][1] / (rightRevealPnts[startIdx][2] - WOD))

					arcRadius	= radBoard
					bMiddlePoints = 1
					firstStatus	= 8 + 7 * not(gs_stack_right) + 64
					lastStatus	= 8 + 7 * not(gs_stack_right) + 64

					if abs(alfaStart - alfaEnd) > EPS then gosub 100
				endif

				for i = startIdx - 1 to endIdx step -1
					if i = endIdx then
						put rightRevealPnts[i][1], rightRevealPnts[i][2], 13 + 2 * not(gs_stack_left), gs_board_mat	! 15 or 13
					else
						put rightRevealPnts[i][1], rightRevealPnts[i][2],  8 + 7 * not(gs_stack_right), gs_board_mat	! 15 or 8
					endif
				next i
			endif

			if not(sidelightCutLeft) then
				! Close polygon
				if thkPlasterAtBoardLeft > EPS then
					put leftRevealPnts[idxBoardStartPlasterLeft][1], leftRevealPnts[idxBoardStartPlasterLeft][2], 3000 * (bCurvedAtWindowFrame) + 8 + 7 * not(gs_stack_left), gs_board_mat	! 15 or 8
				else
					put leftRevealPnts[idxBoardStartRevealLeft][1],  leftRevealPnts[idxBoardStartRevealLeft][2],  3000 * (bCurvedAtWindowFrame) + 8 + 7 * not(gs_stack_left), gs_board_mat	! 15 or 8
				endif
			endif
		endif

		sprism_{2} gs_board_mat, gs_board_mat, gs_board_mat,
			nsp/4,
			0,WIDO_FRAME_THICKNESS, 1,WIDO_FRAME_THICKNESS, boardThickness,	boardAngleTop,
			0,WIDO_FRAME_THICKNESS, 1,WIDO_FRAME_THICKNESS, 0,				boardAngleBottom,
			get(nsp)

		if sidelightCutLeft then
			hotspot sidelightCutPosLeft, leftRevealPnts[idxBoardStartRevealLeft][2]  - bBoardNnosUsa, boardThickness, 10061
		else
			hotspot leftRevealPnts[idxBoardStartRevealLeft][1], leftRevealPnts[idxBoardStartRevealLeft][2]  - bBoardNnosUsa, boardThickness, 10002
		endif

		if sidelightCutRight then
			hotspot sidelightCutPosRight, rightRevealPnts[idxBoardStartRevealRight][2] - bBoardNnosUsa, boardThickness, 10060
		else
			hotspot rightRevealPnts[idxBoardStartRevealRight][1], rightRevealPnts[idxBoardStartRevealRight][2] - bBoardNnosUsa, boardThickness, 10003
		endif
	else

		ch = initaddonscope ("PolyOperations", "", "")

! Generate Board Polygon -------------------------------------------------------

		bPolyFor3D = 1
		gosub 2000

! Draw resulting polygons ------------------------------------------------------

		defaultStatusCode = 8
		dim statusCodes[2]
		statusCodes[1] = 15
		statusCodes[2] = 15

		dim resPolyIDArr[]
		numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)

		for i = 1 to numPoly
			polygonID = resPolyIDArr[i]
			gosub 1000	! Get GDL Polygon

			sprism_{2} gs_board_mat, gs_board_mat, gs_board_mat,
				nsp/4,
				0,WIDO_FRAME_THICKNESS, 1,WIDO_FRAME_THICKNESS, boardThickness,	boardAngleTop,
				0,WIDO_FRAME_THICKNESS, 1,WIDO_FRAME_THICKNESS, 0,				boardAngleBottom,
				get(nsp)
		next i

! Close channel ----------------------------------------------------------------

		closeaddonscope ch
	endif

	if abs(bBoardNnosUsa) > EPS then cutend

	del 1

return


! ==============================================================================
! Arch Segmentation
! ------------------------------------------------------------------------------
! Input parameters:
!	alfaStart:		Start angle (angle)
!	alfaEnd:		End angle (angle)
!	arcRadius:		Arc radius (length)
!	bMiddlePoints:	Generate middle points (0 / 1)
!	firstStatus:	Status of the first segment (integer)
!	lastStatus:		Status of the last segment (integer)
! ==============================================================================

100:
	if not(wallIsLeft) then
		alfaStart = 180 - alfaStart
		alfaEnd = 180 - alfaEnd
	endif
	segmentAngle = 360 / WALL_RESOL


	! --- Point at Start Angle ---
	if WIDO_REVEAL_SIDE then
		if SYMB_ROTANGLE < EPS then
			difAngle = (AC_Hole_Position_Angle + alfaStart) mod segmentAngle
		else
			difAngle = -(AC_Hole_Position_Angle - 180 - alfaStart) mod segmentAngle
		endif
	else
		if SYMB_ROTANGLE < EPS then
			difAngle = -(AC_Hole_Position_Angle - alfaStart + 180) mod segmentAngle
		else
			difAngle = (AC_Hole_Position_Angle + alfaStart) mod segmentAngle
		endif
	endif

	difAngle2 = difAngle
	if abs(difAngle) > segmentAngle / 2 then difAngle = -segmentAngle / 2 + abs(difAngle mod (segmentAngle / 2))

	segmentR = arcRadius / cos(difAngle)
	put segmentR * sin(alfaStart), -segmentR * cos(alfaStart) + WOD, firstStatus, gs_board_mat

	if bMiddlePoints then
		! --- Middle Points ---
		segmentR = arcRadius / cos(segmentAngle / 2)

		if alfaStart > alfaEnd then
			alfaActual = alfaStart - difAngle2 + segmentAngle / 2

			if alfaActual > alfaStart then alfaActual = alfaActual - segmentAngle
			if alfaActual > alfaStart then alfaActual = alfaActual - segmentAngle

			if alfaActual < alfaEnd then alfaActual = alfaActual + segmentAngle

			if alfaActual < alfaStart & alfaActual > alfaEnd then
				do
					put segmentR * sin(alfaActual), -segmentR * cos(alfaActual) + WOD, 79, gs_board_mat

					alfaActual = alfaActual - segmentAngle

				while alfaActual > alfaEnd
			endif
		else
			alfaActual = alfaStart - difAngle2 + segmentAngle / 2

			if alfaActual < alfaStart then alfaActual = alfaActual + segmentAngle
			if alfaActual > alfaEnd then alfaActual = alfaActual - segmentAngle

			if alfaActual > alfaStart & alfaActual < alfaEnd then
				do
					put segmentR * sin(alfaActual), -segmentR * cos(alfaActual) + WOD, 79, gs_board_mat

					alfaActual = alfaActual + segmentAngle
				while alfaActual < alfaEnd
			endif
		endif
	endif


	! --- Point at End Angle ---
	if WIDO_REVEAL_SIDE then
		if SYMB_ROTANGLE < EPS then
			difAngle = (AC_Hole_Position_Angle + alfaEnd) mod segmentAngle
		else
			difAngle = -(AC_Hole_Position_Angle + 180 - alfaEnd) mod segmentAngle
		endif
	else
		if SYMB_ROTANGLE < EPS then
			difAngle = -(AC_Hole_Position_Angle - alfaEnd + 180) mod segmentAngle
		else
			difAngle = (AC_Hole_Position_Angle + alfaEnd) mod segmentAngle
		endif
	endif

	if abs(difAngle) > segmentAngle / 2 then difAngle = -segmentAngle / 2 + abs(difAngle mod (segmentAngle / 2))

	segmentR = arcRadius / cos(difAngle)
	put segmentR * sin(alfaEnd), -segmentR * cos(alfaEnd) + WOD, lastStatus, gs_board_mat

return


1000:
! ==============================================================================
! Get GDL Polygon
! ------------------------------------------------------------------------------
! Input variables:
!	ch:					Channel
!	polygonID:			Polygon index
!	defaultStatusCode:	Default status code
!	statusCodes[]:		Status code array
!
! Returned variables:
!	GDL stack:			GDL polygon
! ==============================================================================

	dim resVertices[]
	numVertices = callfunction(ch, "GetVertices", polygonID, resVertices)
	numVertices = numVertices / 3

	dim contArr[]
	numContours = callfunction(ch, "GetContourEnds", polygonID, contArr)

	dim inhEdgeInfos[]
	numEdges = callfunction(ch, "GetInhEdgeInfos", polygonID, inhEdgeInfos)

	for contIndex = 1 to numContours

		if contIndex = 1 then
			begIdx = 0
		else
			begIdx = contArr[contIndex] - 1
		endif
		if contIndex = numContours then
			endIdx = numVertices - 1
		else
			endIdx = contArr[contIndex + 1] - 2
		endif

		bClosed = 0
		bStartWithLast = 0

		index = endIdx * 3
		lastVertX	= resVertices[index + 1]
		lastVertY	= resVertices[index + 2]
		lastVertA	= resVertices[index + 3]
		edgeInfo	= inhEdgeInfos[begIdx + 1]

		if abs(lastVertA) > EPS then
			put lastVertX, lastVertY, 1, gs_board_mat
			bStartWithLast = 1
		endif

		for vertIndex = begIdx to endIdx
			index = vertIndex * 3
			actVertX = resVertices[index + 1]
			actVertY = resVertices[index + 2]
			actVertA = resVertices[index + 3]

			if edgeInfo > 0 & edgeInfo <= vardim1(statusCodes) then
				statusCode = statusCodes[edgeInfo]
			else
				statusCode = defaultStatusCode
			endif

			if vertIndex = begIdx then
				if bStartWithLast then
					ac2gdl_spx = lastVertX
					ac2gdl_spy = lastVertY
				else
					ac2gdl_spx = actVertX
					ac2gdl_spy = actVertY
				endif
			endif

			if abs(lastVertA) > EPS then
				ac2gdl_mx = (actVertX + lastVertX) / 2
				ac2gdl_my = (actVertY + lastVertY) / 2
				ac2gdl_ratio = 1 / 2 / tan (lastVertA / 2)

				ac2gdl_cx = ac2gdl_mx - ac2gdl_ratio * (actVertY - lastVertY)	! Arc center
				ac2gdl_cy = ac2gdl_my + ac2gdl_ratio * (actVertX - lastVertX)

				put ac2gdl_cx,	ac2gdl_cy,	900,					gs_board_mat,
					0,			lastVertA,	4000 + statusCode + 64,	gs_board_mat
			endif

			if vertIndex > begIdx & abs(ac2gdl_spx - actVertX) < EPS & abs(ac2gdl_spy - actVertY) < EPS then
!!!				put actVertX, actVertY, -1, gs_board_mat	! Board polygon never contains holes
				bClosed = 1
			else
				if vertIndex < endIdx | not(bStartWithLast) then
					put actVertX, actVertY, statusCode, gs_board_mat
				endif
			endif

			lastVertX	= actVertX
			lastVertY	= actVertY
			lastVertA	= actVertA
			edgeInfo	= inhEdgeInfos[vertIndex + 2]
		next vertIndex

		if not(bClosed) & numContours > 1 then	! Close the polygon if it has holes
			put ac2gdl_spx, ac2gdl_spy, -1, gs_board_mat
		endif

	next contIndex
return

]]>
</Script_3D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_2D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! Contact person: <NJ>

! ==============================================================================
! This macro draws the Board
! ------------------------------------------------------------------------------
! Input parameters:
! Geometry ---------------------------------------------------------------------
!	A:						wallhole width (length) (Obsolete)
!	refWidth:				reference width in curved walls (length)
!	leftWidth:				wallhole's side distance from the origin at the left side (length)
!	rightWidth:				wallhole's side distance from the origin at the right side (length)
! Functions --------------------------------------------------------------------
!	gs_IsCurved:			Does the window follow the curvature of the wall? (0 / 1)
!	bParalellInCurvedWalls:	is the wallhole parallel in curved walls (0 / 1)
! Reveal -----------------------------------------------------------------------
!	iRevealType:
!	gs_reveal_left_angle:
!	gs_reveal_right_angle:
! Corner Function --------------------------------------------------------------
!	bLeftCornerFunction:		Turn macro in Corner Window mode at the left side (0 / 1)
!	leftCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	leftConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
!	bRightCornerFunction:	Turn macro in Corner Window mode at the right side (0 / 1)
!	rightCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	rightConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
! Oversize ---------------------------------------------------------------------
!	gs_left_oversize:		Left opening oversize (length)
!	gs_right_oversize:		Right opening oversize (length)
! Board ------------------------------------------------------------------------
!	gs_board_width:			Width of the Board. (length)
!	gs_board_nosing:		Nosing of the Board. (length)
!	gs_board_ovhg_left:		Board overhang on the left side. (length)
!	gs_board_ovhg_right:	Board overhang on the right side. (length)
!	gs_board_curved:		Board edge is curved or straight. (0 / 1)
!	bShowBoardSplice:		Show or hide the Board's joint line in case of Corner Window  (0 / 1)
!	bWindowSymbolAtMiddle:	Is the window symbol appears always on the middle of the wall (CHI special) (0 / 1)
! 2D Representation ------------------------------------------------------------
!	lod2D_sillBoard:		Level of detail. (integer, 0..1)
!	gs_pen_2D:				Contour pen of the Trim, Sill and Board. (pen)
!	gs_bFills:				Use fills (boolean)
!	gs_board_wallhole_fill:			Type of the fill on the Board. (fill type)
!	gs_board_wallhole_pen_fg:		Fill pen on the Board. (pen)
!	gs_board_wallhole_pen_bg:		Fill background pen on the Board. (pen)
!	gs_board_wallhole_fill_sl:		Type of the fill on the Board, at the sidelights. (fill type)
!	gs_board_wallhole_pen_sl_fg:	Fill pen on the Board, at the sidelights. (pen)
!	gs_board_wallhole_pen_sl_bg:	Fill background pen on the Board, at the sidelights. (pen)
! Ganging ----------------------------------------------------------------------
!	gs_stack_left:			Align to door/window on left side (0 / 1)
!	gs_stack_right:			Align to door/window on right side (0 / 1)
!	gs_stack_bottom:		Align to door/window on bottom side (0 / 1)
! Wall Inset -----------------------------------------------------------
!	gs_parapet_wall_inset:	Switch on / off the Wall Inset function. (0 / 1)
!	gs_parapet_inset_thk:	Depth of Wall Inset. (length)
!
! Related Global Variables:
!	GLOB_SCRIPT_TYPE
!	GLOB_CONTEXT
!	WALL_THICKNESS
!	WALL_INCL
!	WALL_SECT_PEN
!	WIDO_FRAME_THICKNESS
!	WIDO_SILL
!	WIDO_LEFT_JAMB
!	WIDO_RIGHT_JAMB
!	WIDO_ORIG_DIST
!	WIDO_REVEAL_SIDE
!	SYMB_MIRRORED
!	SYMB_ROTANGLE
!
! Hotspot IDs:
!	10002:		Board left
!	10003:		Board right
! ==============================================================================

LINE_ATTRIBUTES_GDLLINE		= 0			! Draw GDL Line in the section
LINE_ATTRIBUTES_WALLLINE	= 1			! Draw WallLine in the section
LINE_ATTRIBUTES_WALLSIDE	= 2			! The section is on the wall side (it is an arc in curved wall)
LINE_ATTRIBUTES_DRAWCC		= 3			! The section is drawn by CavityClosure macro (otherwise the WallHoleCut macro)
LINE_ATTRIBUTES_CONTOUR		= 4			! The section is contour or inner line
!!!	LINE_ATTRIBUTES_WALLEDGE	= 0			! The section is on the wall edge (always a line)

! Line Property defines:
LINE_PROPERTY_GENERIC	= 0
LINE_PROPERTY_INNER		= 1
LINE_PROPERTY_CONTOUR	= 2


! Draw Board -------------------------------------------------------------------

if lod2D_sillBoard > 0 & bDrawBoard & not(gs_stack_bottom) then

! Save the current parameter buffer --------------------------------------------

	dim savedQueueValues[]
	call "SaveQueue" parameters returned_parameters savedQueueValues

	if gs_board_pen_2D < 1 then gs_board_pen_2D = gs_pen_2D		! Compatibility

	if WIDO_REVEAL_SIDE then
		add2 0,-WIDO_FRAME_THICKNESS
	else
		mul2 1,-1
	endif

	if gs_stack_left then
		gs_board_ovhg_left = gs_left_oversize
		overSizeLeft = gs_left_oversize
		widoLeftJamb = 0
	endif

	if gs_stack_right then
		gs_board_ovhg_right = gs_right_oversize
		overSizeRight = gs_right_oversize
		widoRightJamb = 0
	endif

! Draw Board -------------------------------------------------------------------

	if bTShapedOpening then
		gs_wallhole_fill	= gs_board_wallhole_fill_sl
		gs_wallhole_pen_fg	= gs_board_wallhole_pen_sl_fg
		gs_wallhole_pen_bg	= gs_board_wallhole_pen_sl_bg

		if gs_board_inside_sl_left & gs_sidelight_left & gs_sidelight_parapet_hgt_left > EPS then
			sidelightCutLeft  = 0
			sidelightCutRight = 1
			sidelightCutPosRight = -leftWidth + gs_sidelight_WHole_width_left + bDrawInsideTrim * gs_trim_width_in + gs_reveal_double_innerLeft_sL + thkPlasterAtBoardLeft
			gosub "DrawBoard"
		endif

		if gs_board_inside_sl_right & gs_sidelight_right & gs_sidelight_parapet_hgt_right > EPS then
			sidelightCutLeft  = 1
			sidelightCutRight = 0
			sidelightCutPosLeft = rightWidth - gs_sidelight_WHole_width_right - bDrawInsideTrim * gs_trim_width_in - gs_reveal_double_innerRight_sR - thkPlasterAtBoardRight
			gosub "DrawBoard"
		endif
	else
		gs_wallhole_fill	= gs_board_wallhole_fill
		gs_wallhole_pen_fg	= gs_board_wallhole_pen_fg
		gs_wallhole_pen_bg	= gs_board_wallhole_pen_bg

		sidelightCutLeft  = 0
		sidelightCutRight = 0
		gosub "DrawBoard"
	endif

! Restore the saved parameter buffer --------------------------------------------

	call "LoadQueue" parameters savedQueueValues = savedQueueValues
endif


! ==============================================================================
end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
! ==============================================================================


! ==============================================================================
!	Draw Board
! ==============================================================================

"DrawBoard":
	set fill gs_wallhole_fill
	line_property 0
	line_type 1
	pen gs_board_pen_2D

	if AC_WallType <> 2 then

		bCurvedAtBoardSide		= (curvedWall & gs_board_curved)
		bCurvedAtWindowFrame	= (curvedWall & gs_IsCurved)

		if curvedWall then put 0,WOD,900

		if sidelightCutLeft then
			if bCurvedAtBoardSide then
				py = WOD - iArchSign * sqr((radBoard - iArchSign * gs_board_nosing)^2 - sidelightCutPosLeft^2)
			else
				py = bpy6 - (bpy6 - bpy7) / (bpx7 - bpx6) * (sidelightCutPosLeft - bpx6)
			endif
			put sidelightCutPosLeft,	WIDO_FRAME_THICKNESS,	1,
				sidelightCutPosLeft,	py,						1
		else
			if abs(bBoardNnosUsa) > EPS then	! Board Negative Nosing by USA Framesill
				put leftRevealPnts[idxBoardStartRevealLeft][1] + frameWidthLeft,	leftRevealPnts[idxBoardStartRevealLeft][2] - bBoardNnosUsa,	0
				put leftRevealPnts[idxBoardStartRevealLeft][1] + frameWidthLeft,	leftRevealPnts[idxBoardStartRevealLeft][2],					0
			endif

			for i=idxBoardStartPlasterLeft to idxBoardEndPlasterLeft
				put leftRevealPnts[i][1],	leftRevealPnts[i][2],	0
			next i

			put	bpx5,	bpy5,	3000 * curvedWall + (not(gs_stack_left) & not(bLeftCornerFunction)),
				bpx6,	bpy6,	1
		endif

		if sidelightCutRight then
			if bCurvedAtBoardSide then
				py = WOD - iArchSign * sqr((radBoard - iArchSign * gs_board_nosing)^2 - sidelightCutPosRight^2)
			else
				py = bpy6 - (bpy6 - bpy7) / (bpx7 - bpx6) * (sidelightCutPosRight - bpx6)
			endif
			put sidelightCutPosRight,	py,						3000 * bCurvedAtBoardSide + 1,
				sidelightCutPosRight,	WIDO_FRAME_THICKNESS,	0
		else
			put	bpx7,	bpy7,	3000 * bCurvedAtBoardSide + (not(gs_stack_right) & not(bRightCornerFunction)),
				bpx8,	bpy8,	0

			for i=idxBoardEndPlasterRight to idxBoardStartPlasterLeft step -1
				put rightRevealPnts[i][1],	rightRevealPnts[i][2]
				if i = idxBoardEndPlasterRight then
					put 3000 * curvedWall
				else
					put 0
				endif
			next i

			if abs(bBoardNnosUsa) > EPS then	! Board Negative Nosing by USA Framesill
				put rightRevealPnts[idxBoardStartRevealRight][1] - frameWidthRight,	rightRevealPnts[idxBoardStartRevealRight][2],				0
				put rightRevealPnts[idxBoardStartRevealRight][1] - frameWidthRight,	rightRevealPnts[idxBoardStartRevealRight][2] - bBoardNnosUsa,	0
			endif

			! Close polygon
			if curvedWall & bCurvedAtWindowFrame then
				put	leftRevealPnts[idxBoardStartPlasterLeft][1],	leftRevealPnts[idxBoardStartPlasterLeft][2],	3000
			endif
		endif

		penFillFg	= gs_wallhole_pen_fg
		penFillBg	= gs_wallhole_pen_bg
		gosub 300	! Draw wallhole fill

		if bShowAddHotspots then
			if sidelightCutLeft then
				hotspot2 sidelightCutPosLeft, bpy6, 10061
			else
				hotspot2 bpx6, bpy6, 10002
			endif

			if sidelightCutRight then
				hotspot2 sidelightCutPosRight, bpy6, 10060
			else
				hotspot2 bpx7, bpy7, 10003
			endif
		endif
	else
		ch = initaddonscope ("PolyOperations", "", "")

! Generate Board Polygon -------------------------------------------------------

		bPolyFor3D = 0
		gosub 2000

! Draw resulting polygons ------------------------------------------------------

		dim resPolyIDArr[]
		numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)

		for i = 1 to numPoly
			polygonID = resPolyIDArr[i]
			gosub 1000	! Get GDL Polygon

			fill gs_wallhole_fill
			poly2_b nsp/3, 2+4+64, gs_wallhole_pen_fg, gs_wallhole_pen_bg,
				get(nsp)
		next i

! Draw wall contour lines ------------------------------------------------------

		dim lineAttributes[2][4]
		lineAttributes[1][1] = WALL_SECT_PEN
		lineAttributes[1][2] = WALL_LINETYPE
		lineAttributes[1][3] = LINE_PROPERTY_CONTOUR
		lineAttributes[1][4] = bitset(0, LINE_ATTRIBUTES_WALLLINE)

		lineAttributes[2][1] = gs_board_pen_2D
		lineAttributes[2][2] = 1
		lineAttributes[2][3] = LINE_PROPERTY_GENERIC
		lineAttributes[2][4] = bitset(0, LINE_ATTRIBUTES_GDLLINE)

		bPutHotsopts	= 0

		for i = 1 to numPoly
			polygonID = resPolyIDArr[i]
			gosub 1001	! Draw one polygon contour line
		next i

! Show Hotspots ----------------------------------------------------------------

		if boardNosing > EPS & bShowAddHotspots then

			if sidelightCutLeft then
				hotspot2 sidelightCutPosLeft, hotspotLeftY, 10061
			else
				if not(gs_stack_left) & hotspotLeftX < -EPS then
					hotspot2 hotspotLeftX, hotspotLeftY, 10002	! Left
				endif
			endif
			if sidelightCutRight then
				hotspot2 sidelightCutPosRight, hotspotRightY, 10060
			else
				if not(gs_stack_right) & hotspotRightX > EPS then
					hotspot2 hotspotRightX, hotspotRightY, 10003	! Right
				endif
			endif
		endif

! Close channel ----------------------------------------------------------------

		closeaddonscope ch
	endif

return



! ==============================================================================
! Direction Angle
! ------------------------------------------------------------------------------
! Input variables:
!	vx, vy:				vector
!
! Returned variables:
!	alpha:				selected intersection point
! ==============================================================================

103:

if abs(vx) < EPS & abs(vy) < EPS then
	angle = 0
	return
endif

if abs(vx) < EPS then
	if vy > 0 then
		angle = 90
	else
		angle = 270
	endif
else
	angle = atn(vy / vx)
	if vx >= 0 then
		if angle < 0 then
			angle = angle + 360
		endif
	else
		angle = 180 + angle
	endif
endif

return

! ==============================================================================
! Draw wallblock with contour
! ------------------------------------------------------------------------------
! Input variables:
!	stack:				wallblock polygon
!	penFillFg			fill foreground pen (pen index)
!	penFillBg			fill background pen (pen index)
! ==============================================================================

300:
	if nsp >= 9 then
		if gs_bFills then
			poly2_b nsp/3, 2+4+64, penFillFg, penFillBg,
				use(nsp)
		endif
	else
		for ii=1 to nsp
			n = get(1)
		next ii
		return
	endif

	bHaveFirst = 0
	numPoints = nsp/3

	for ii=1 to numPoints
		if ii = 1 | not(bHaveFirst) then
			x1 = get(1)
			y1 = get(1)
			s1 = get(1)
			firstX = x1
			firstY = y1
			firstS = s1
			if s1 < 100 then bHaveFirst = 1
		endif
		if ii = numPoints then
			x2 = firstX
			y2 = firstY
			s2 = firstS
		else
			if bHaveFirst then
				x2 = get(1)
				y2 = get(1)
				s2 = get(1)
			endif
		endif

		if bHaveFirst then
			if bittest(s1, 0) & (s1 >= 1000 | s1 < 100) then
				if s2 >= 3000 then
					R = sqr(x2^2 + (y2 - WOD)^2)

					vx = x1
					vy = y1 - WOD
					gosub 103	! Direction Angle
					alpha = angle

					vx = x2
					vy = y2 - WOD
					gosub 103	! Direction Angle
					beta = angle

					if abs(alpha - beta) > EPS then
						arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
					endif
				else
					if s2 < 100 then
						line2 x1,y1, x2,y2
					endif
				endif
			endif

			if s2 >= 1000 | s2 < 100 then
				x1 = x2
				y1 = y2
				s1 = s2
			endif
		endif
	next ii
return


1000:
! ==============================================================================
! Get GDL Polygon
! ------------------------------------------------------------------------------
! Input variables:
!	ch:						Channel
!	polygonID:			Polygon index
!
! Returned variables:
!	GDL stack:			GDL polygon
! ==============================================================================

	dim resVertices[]
	numVertices = callfunction(ch, "GetVertices", polygonID, resVertices)
	numVertices = numVertices / 3

	dim contArr[]
	numContours = callfunction(ch, "GetContourEnds", polygonID, contArr)

	for contIndex = 1 to numContours

		if contIndex = 1 then
			begIdx = 0
		else
			begIdx = contArr[contIndex] - 1
		endif
		if contIndex = numContours then
			endIdx = numVertices - 1
		else
			endIdx = contArr[contIndex + 1] - 2
		endif

		bClosed = 0
		bStartWithLast = 0

		index = endIdx * 3
		ac2gdl_lpx = resVertices[index + 1]
		ac2gdl_lpy = resVertices[index + 2]
		ac2gdl_lpa = resVertices[index + 3]

		if abs(ac2gdl_lpa) > EPS then
			put ac2gdl_lpx, ac2gdl_lpy, 1
			bStartWithLast = 1
		endif

		for vertIndex = begIdx to endIdx
			index = vertIndex * 3
			ac2gdl_px = resVertices[index + 1]
			ac2gdl_py = resVertices[index + 2]
			ac2gdl_pa = resVertices[index + 3]

			if vertIndex = begIdx then
				if bStartWithLast then
					ac2gdl_spx = ac2gdl_lpx
					ac2gdl_spy = ac2gdl_lpy
				else
					ac2gdl_spx = ac2gdl_px
					ac2gdl_spy = ac2gdl_py
				endif
			endif

			if abs(ac2gdl_lpa) > EPS then
				ac2gdl_mx = (ac2gdl_px + ac2gdl_lpx) / 2
				ac2gdl_my = (ac2gdl_py + ac2gdl_lpy) / 2
				ac2gdl_ratio = 1 / 2 / tan (ac2gdl_lpa / 2)

				ac2gdl_cx = ac2gdl_mx - ac2gdl_ratio * (ac2gdl_py - ac2gdl_lpy)	! Arc center
				ac2gdl_cy = ac2gdl_my + ac2gdl_ratio * (ac2gdl_px - ac2gdl_lpx)

				put ac2gdl_cx,	ac2gdl_cy,	900,
					0,			ac2gdl_lpa,	4001
			endif

			if vertIndex > begIdx & abs(ac2gdl_spx - ac2gdl_px) < EPS & abs(ac2gdl_spy - ac2gdl_py) < EPS then
!!!				put ac2gdl_px, ac2gdl_py, -1	! Board polygon never contains holes
				bClosed = 1
			else
				if vertIndex < endIdx | not(bStartWithLast) then
					put ac2gdl_px, ac2gdl_py, 1
				endif
			endif

			ac2gdl_lpx = ac2gdl_px
			ac2gdl_lpy = ac2gdl_py
			ac2gdl_lpa = ac2gdl_pa
		next vertIndex

		if not(bClosed) & numContours > 1 then	! Close the polygon if it has holes
			put ac2gdl_spx, ac2gdl_spy, -1
		endif

	next contIndex
return


1001:
! ==============================================================================
! Draw one polygon contour line
! ------------------------------------------------------------------------------
! Input variables:
!	ch:						Channel
!	polygonID:				Polygon ID
!	lineAttributes[][3]:	Line attribute array
!								[][1] = pen color
!								[][2] = line type
!								[][3] = line property
!								[][4] = additional line attributes
! ==============================================================================

	dim resVertices[]
	numVertices = callfunction(ch, "GetVertices", polygonID, resVertices)
	numVertices = numVertices / 3

	dim contArr[]
	numContours = callfunction(ch, "GetContourEnds", polygonID, contArr)

	dim inhEdgeInfos[]
	numEdges = callfunction(ch, "GetInhEdgeInfos", polygonID, inhEdgeInfos)

	for contIndex = 1 to numContours

		if contIndex = 1 then
			begIdx = 0
		else
			begIdx = contArr[contIndex] - 1
		endif
		if contIndex = numContours then
			endIdx = numVertices - 1
		else
			endIdx = contArr[contIndex + 1] - 2
		endif

		bClosed = 0
		bStartWithLast = 0

		index = endIdx * 3
		lastVertX	= resVertices[index + 1]
		lastVertY	= resVertices[index + 2]
		lastVertA	= resVertices[index + 3]
		edgeInfo	= inhEdgeInfos[endIdx + 1]

		for vertIndex = begIdx to endIdx

			index = vertIndex * 3
			actVertX = resVertices[index + 1]
			actVertY = resVertices[index + 2]
			actVertA = resVertices[index + 3]

!!text2	(lastVertX + actVertX) / 2,
!!		(lastVertY + actVertY) / 2,
!!		edgeInfo

!!!ccc=ccc+0.1
!!!circle2 lastVertX, lastVertY, ccc
!!!circle2 actVertX, actVertY, ccc

			if edgeInfo > 0 & edgeInfo <= vardim1(lineAttributes) then

				if lineAttributes[edgeInfo][1] > 0 then
					pen				lineAttributes[edgeInfo][1]
					line_type		lineAttributes[edgeInfo][2]

					line_property	lineAttributes[edgeInfo][3]
					iAttributes = round_int(lineAttributes[edgeInfo][4])

					if abs(lastVertA) > EPS then
						ac2gdl_mx = (actVertX + lastVertX) / 2
						ac2gdl_my = (actVertY + lastVertY) / 2
						ac2gdl_ratio = 1 / 2 / tan (lastVertA / 2)

						ac2gdl_cx = ac2gdl_mx - ac2gdl_ratio * (actVertY - lastVertY)	! Arc center
						ac2gdl_cy = ac2gdl_my + ac2gdl_ratio * (actVertX - lastVertX)
						ac2gdl_rad = sqr((ac2gdl_cx - actVertX)^2 + (ac2gdl_cy - actVertY)^2)

						vx = actVertX - ac2gdl_cx
						vy = actVertY - ac2gdl_cy
						gosub 103	! Direction Angle
						alpha = angle

						vx = lastVertX - ac2gdl_cx
						vy = lastVertY - ac2gdl_cy
						gosub 103	! Direction Angle
						beta = angle

						if abs(alpha - beta) > EPS then
							if abs(alpha - beta) > 180 + EPS then
								angleStart	= max(alpha,beta)
								angleEnd	= min(alpha,beta)
							else
								angleStart	= min(alpha,beta)
								angleEnd	= max(alpha,beta)
							endif
							if bittest(iAttributes, LINE_ATTRIBUTES_GDLLINE) then
								arc2 ac2gdl_cx,	ac2gdl_cy, ac2gdl_rad, angleStart, angleEnd
							endif
							if bittest(iAttributes, LINE_ATTRIBUTES_WALLLINE) then
								wallarc2 ac2gdl_cx,	ac2gdl_cy, ac2gdl_rad, angleStart, angleEnd
							endif
						endif
					else
						if bittest(iAttributes, LINE_ATTRIBUTES_GDLLINE) then
							line2 lastVertX, lastVertY, actVertX, actVertY
						endif
						if bittest(iAttributes, LINE_ATTRIBUTES_WALLLINE) then
							wallline2 lastVertX, lastVertY, actVertX, actVertY
						endif
					endif
				endif
			endif

			lastVertX	= actVertX
			lastVertY	= actVertY
			lastVertA	= actVertA
			edgeInfo	= inhEdgeInfos[vertIndex + 1]

		next vertIndex
	next contIndex
return



]]>
</Script_2D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_1D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! const values for parameter: iBoardInPolyWall
BOARD_PARALLEL_WINDOW      = 1
BOARD_PARALLEL_WALLPOLYGON = 2

EPS = 0.0001

! iRevealType:
REVEAL_EDGE				= 0
REVEAL_NO				= 1
REVEAL_POSITIVE			= 2
REVEAL_NEGATIVE			= 3
REVEAL_SLANTED			= 4
REVEAL_SPLAYED			= 5
REVEAL_HISTORIC			= 6
REVEAL_DOUBLE			= 7
REVEAL_DOUBLE_SPLAYED	= 8
REVEAL_OUTSIDE_SPLAYED	= 9

! iWindowShape:
SHAPE_RECTANGULAR			= 0
SHAPE_ARCHED				= 1
SHAPE_ROUND					= 2
SHAPE_EYEBROWS				= 3
SHAPE_HALFCIRCLE			= 4 	! straight side is horizontal
SHAPE_MULTISIDE				= 5
SHAPE_OCTAGONAL				= 6
SHAPE_HALFARCH				= 7
SHAPE_PENTAGON				= 8
SHAPE_QUARTERROUND			= 9
SHAPE_HALFROUND				= 10 	! straight side is vertical
SHAPE_TRAPEZOID				= 11
SHAPE_TRIANGLE				= 12
SHAPE_GOTHICARCH			= 13
SHAPE_ELLIPSEARCH			= 14
SHAPE_ROMBUS				= 15
SHAPE_HORSESHOE				= 16
SHAPE_OGEECENTERED			= 17
SHAPE_SARACENIC				= 18
SHAPE_T						= 19
SHAPE_HALF_T_LEFT			= 20
SHAPE_ARCHED_T				= 21
SHAPE_ARCHED_HALF_T_LEFT	= 22
SHAPE_PARALLELOGRAM			= 23
SHAPE_ELLIPSE				= 24
SHAPE_CORNER_TRIANGLE		= 25
SHAPE_QUARTERROUND_NOFRAME	= 26
SHAPE_HALF_T_RIGHT			= 27
SHAPE_ARCHED_HALF_T_RIGHT	= 28

! const values for parameter: iBoardInPolyWall
BOARD_PARALLEL_WINDOW      = 1
BOARD_PARALLEL_WALLPOLYGON = 2

! ==============================================================================

bTShapedOpening =  (iWindowShape = SHAPE_T |\
					iWindowShape = SHAPE_HALF_T_LEFT |\
					iWindowShape = SHAPE_HALF_T_RIGHT |\
					iWindowShape = SHAPE_ARCHED_T |\
					iWindowShape = SHAPE_ARCHED_HALF_T_LEFT |\
					iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT)

bInclinedWall	= (abs(WALL_INCL) > EPS)
curvedWall		= (abs(WIDO_ORIG_DIST) > EPS)
wallIsLeft		= (SYMB_ROTANGLE > EPS) exor WIDO_REVEAL_SIDE
signWallIsLeft	= wallIsleft - not(wallIsleft)

if bDoorWithSidelightSupport then
	bHasAnyBoardOn = (	(gs_sidelight_left  & gs_sidelight_parapet_hgt_left > EPS  & gs_board_inside_sl_left) | \
						(gs_sidelight_right & gs_sidelight_parapet_hgt_right > EPS & gs_board_inside_sl_right))
else
	bHasAnyBoardOn = (gs_board_inside)
endif


! ==============================================================================

if SYMB_MIRRORED exor (SYMB_ROTANGLE > EPS) then
	widoRightJamb	= WIDO_LEFT_JAMB
	widoLeftJamb	= WIDO_RIGHT_JAMB
else
	widoRightJamb	= WIDO_RIGHT_JAMB
	widoLeftJamb	= WIDO_LEFT_JAMB
endif


! ==============================================================================
! Restrictions for Window Shapes
! ==============================================================================

if iWindowShape = 1 then
	! --- Arched Window Shape ---

	widoLeftJamb	= widoRightJamb
endif


! ==============================================================================
! Calculations for Corner Window
! ==============================================================================

if bRightCornerFunction & abs(rightCornerAngle) > EPS then
	rx = 1 / tan(rightCornerAngle / 2)

	if rightCornerAngle > 180 then
		rightCwDx = WIDO_FRAME_THICKNESS / tan(-rightCornerAngle / 2)
	else
		rightCwDx = 0
	endif

	rightCwDx2 = 0
	if abs(WALL_THICKNESS - rightConnWallThk) > EPS then
		rightCwDx2 = (WALL_THICKNESS - rightConnWallThk) / cos(rightCornerAngle - 90)
	endif
	bFitMode = (rightConnWallThk > WALL_THICKNESS + EPS)

	gs_right_oversize = 0
endif

if bLeftCornerFunction & abs(leftCornerAngle) > EPS then
	lx = 1 / tan(leftCornerAngle / 2)

	if leftCornerAngle > 180 then
		leftCwDx = WIDO_FRAME_THICKNESS / tan(-leftCornerAngle / 2)
	else
		leftCwDx = 0
	endif

	leftCwDx2 = 0
	if abs(WALL_THICKNESS - leftConnWallThk) > EPS then
		leftCwDx2 = (WALL_THICKNESS - leftConnWallThk) / cos(leftCornerAngle - 90)
	endif
	bFitMode = (leftConnWallThk > WALL_THICKNESS + EPS)

	gs_left_oversize = 0
endif


! ==============================================================================
! Calculations for Inclined Walls
! ==============================================================================

if bInclinedWall then
	bFactor = SYMB_MIRRORED exor WIDO_REVEAL_SIDE exor wallIsLeft
	incFactor = not(bFactor) - bFactor
	incX = incFactor * tan(WALL_INCL)
	incY = incFactor * (1 / cos(WALL_INCL))

	bDir = SYMB_MIRRORED exor (SYMB_ROTANGLE > EPS)
	iDir = not(bDir) - bDir
	incH = cos(WALL_INCL)
	incV = sin(WALL_INCL) * iDir
else
	incX = 0
	incY = 1
	incH = 0
	incV = 0
endif


! ==============================================================================
! Calculations for Stack Window
! ==============================================================================

if gs_stack_left then
	gs_board_ovhg_left	= gs_left_oversize
	overSizeLeft		= gs_left_oversize
	overSizeLeftOut		= gs_left_oversize
	widoLeftJamb		= 0
else
	overSizeLeft		= 0
	overSizeLeftOut		= -widoLeftJamb
endif

if gs_stack_right then
	gs_board_ovhg_right	= gs_right_oversize
	overSizeRight		= gs_right_oversize
	overSizeRightOut	= gs_right_oversize
	widoRightJamb		= 0
else
	overSizeRight		= 0
	overSizeRightOut	= -widoRightJamb
endif


! ==============================================================================
! Calculations for Wall Inset
! ==============================================================================

parapetInset = gs_parapet_wall_inset * gs_parapet_inset_thk


! ==============================================================================
! Board Nosing
! ==============================================================================

boardNosing = gs_board_nosing


! ==============================================================================
! Reveal Points Indexes
! ==============================================================================

idxFrameStartRevealLeft		= iRevealPointsIdx[3]
idxFrameEndRevealLeft		= iRevealPointsIdx[4]
idxBoardStartRevealLeft		= iRevealPointsIdx[5]
idxBoardEndRevealLeft		= iRevealPointsIdx[6]
idxBoardStartPlasterLeft	= iRevealPointsIdx[9]
idxBoardEndPlasterLeft		= iRevealPointsIdx[10]
idxFrameStartRevealRight	= iRevealPointsIdx[13]
idxFrameEndRevealRight		= iRevealPointsIdx[14]
idxBoardStartRevealRight	= iRevealPointsIdx[15]
idxBoardEndRevealRight		= iRevealPointsIdx[16]
idxBoardStartPlasterRight	= iRevealPointsIdx[19]
idxBoardEndPlasterRight		= iRevealPointsIdx[20]


! ==============================================================================
! Calculations for Straight Walls
! ==============================================================================

maxBoardAngle = 0

casingOffsetLeft = 0
casingOffsetRight = 0

if gs_trim_show_cover_in & GLOB_SCRIPT_TYPE = 2 then
	casingOffsetLeft	= (bDrawInsideTrim * not(gs_trim_atframe_in) * gs_trim_thk_in * (gs_board_ovhg_left  < CasingInsLeftOutPoint))
	casingOffsetRight	= (bDrawInsideTrim * not(gs_trim_atframe_in) * gs_trim_thk_in * (gs_board_ovhg_right < CasingInsRightOutPoint))
endif

if not(curvedWall) then

	if GLOB_SCRIPT_TYPE = 2 | GLOB_SCRIPT_TYPE = 3 then
		if vardim1(leftRevealPnts) >= idxBoardEndRevealLeft then
			if bLeftCornerFunction then
				bpx5 = leftRevealPnts[idxBoardEndRevealLeft][1]
				bpy5 = leftRevealPnts[idxBoardEndRevealLeft][2]

				bpx6 = bpx5 + boardNosing * lx
				bpy6 = bpy5 + boardNosing
			else
				if bInclinedWall then
					if gs_stack_left then
						bpx5 = leftRevealPnts[idxBoardEndRevealLeft][1]
						bpy5 = leftRevealPnts[idxBoardEndRevealLeft][2]

						bpx6 = bpx5
						bpy6 = bpy5 + boardNosing / incH
					else
						bpx5 = leftRevealPnts[idxBoardEndRevealLeft][1] - gs_board_ovhg_left * incH
						bpy5 = leftRevealPnts[idxBoardEndRevealLeft][2] - gs_board_ovhg_left * incV

						bpx6 = bpx5 - boardNosing * incV
						bpy6 = bpy5 + boardNosing * incH

						bpx5 = bpx5 - casingOffsetLeft * incV
						bpy5 = bpy5 + casingOffsetLeft * incH
					endif
				else
					bpx5 = leftRevealPnts[idxBoardEndRevealLeft][1] - not(gs_stack_left) * gs_board_ovhg_left
					bpy5 = leftRevealPnts[idxBoardEndRevealLeft][2] + casingOffsetLeft

					bpx6 = bpx5
					bpy6 = bpy5 + boardNosing - casingOffsetLeft
				endif
			endif
		endif

		if vardim1(rightRevealPnts) >= idxBoardEndRevealRight then
			if bRightCornerFunction then
				bpx8 = rightRevealPnts[idxBoardEndRevealRight][1]
				bpy8 = rightRevealPnts[idxBoardEndRevealRight][2]

				bpx7 = bpx8 - boardNosing * rx
				bpy7 = bpy8 + boardNosing
			else
				if bInclinedWall then
					if gs_stack_right then
						bpx8 = rightRevealPnts[idxBoardEndRevealRight][1]
						bpy8 = rightRevealPnts[idxBoardEndRevealRight][2]

						bpx7 = bpx8
						bpy7 = bpy8 + boardNosing / incH
					else
						bpx8 = rightRevealPnts[idxBoardEndRevealRight][1] + gs_board_ovhg_right * incH
						bpy8 = rightRevealPnts[idxBoardEndRevealRight][2] + gs_board_ovhg_right * incV

						bpx7 = bpx8 - boardNosing * incV
						bpy7 = bpy8 + boardNosing * incH

						bpx8 = bpx8 - casingOffsetLeft * incV
						bpy8 = bpy8 + casingOffsetLeft * incH
					endif
				else
					bpx8 = rightRevealPnts[idxBoardEndRevealRight][1] + not(gs_stack_right) * gs_board_ovhg_right
					bpy8 = rightRevealPnts[idxBoardEndRevealRight][2] + casingOffsetRight

					bpx7 = bpx8
					bpy7 = bpy8 + boardNosing - casingOffsetRight
				endif
			endif
		endif
	endif

	if bHasAnyBoardOn then
		if bLeftCornerFunction & (abs(WALL_THICKNESS - leftConnWallThk) > EPS) then
			tempWallThkLeft = leftConnWallThk
		else
			tempWallThkLeft = WALL_THICKNESS
		endif
		if bRightCornerFunction & (abs(WALL_THICKNESS - rightConnWallThk) > EPS) then
			tempWallThkRight = rightConnWallThk
		else
			tempWallThkRight = WALL_THICKNESS
		endif
		wallThk = min (WALL_THICKNESS, tempWallThkLeft, tempWallThkRight)
		temp = wallThk - WIDO_SILL - WIDO_FRAME_THICKNESS + gs_board_nosing
		if abs(temp) < EPS then
			maxBoardAngle = 90
		else
			maxBoardAngle = atn(gs_board_thk / temp)
		endif
	endif
endif


! ==============================================================================
! Calculations for Curved Walls
! ==============================================================================

if curvedWall & abs(radBoard) > EPS then

	if gs_parapet_wall_inset & not(bDrawBoard) & not(bDrawInsideTrim) then gs_board_curved = 0

	if GLOB_SCRIPT_TYPE = 2 | GLOB_SCRIPT_TYPE = 3 then
		bArchSign = (WIDO_REVEAL_SIDE exor SYMB_ROTANGLE > EPS)
		iArchSign = bArchSign - not(bArchSign)		! 1 / -1

		if wallIsLeft then
			alfaL = -atn((leftWidth)  / (WOD - WIDO_FRAME_THICKNESS))
			alfaR =  atn((rightWidth) / (WOD - WIDO_FRAME_THICKNESS))
		else
			alfaL = -atn((leftWidth)  / WOD)
			alfaR =  atn((rightWidth) / WOD)
		endif

		ArcLengthBoardToAngle	= 180 / radBoard / PI

		alfaBoardLeftOvhg	= not(gs_stack_left)  * gs_board_ovhg_left  * ArcLengthBoardToAngle
		alfaBoardRightOvhg	= not(gs_stack_right) * gs_board_ovhg_right * ArcLengthBoardToAngle

		if gs_stack_left then
			bpx5 = leftRevealPnts[idxBoardEndRevealLeft][1] - casingOffsetLeft * sin(alfaL)
			bpy5 = leftRevealPnts[idxBoardEndRevealLeft][2] + casingOffsetLeft

			bpx6 = bpx5 - boardNosing * sin(alfaL) + casingOffsetLeft * sin(alfaL)
			bpy6 = bpy5 + boardNosing * cos(alfaL) - casingOffsetLeft
		else
			if bParalellInCurvedWalls then
				bpx5 = leftRevealPnts[idxBoardEndRevealLeft][1] - gs_board_ovhg_left
				bpy5 = -signWallIsLeft * sqr(radBoard^2 - bpx5^2) + WOD + casingOffsetLeft

				bpx6 = bpx5
				bpy6 = -signWallIsLeft * sqr((radBoard - signWallIsLeft * boardNosing)^2 - bpx6^2) + WOD
			else
				x = leftRevealPnts[idxBoardEndRevealLeft][1] - casingOffsetLeft * sin(alfaL)
				y = leftRevealPnts[idxBoardEndRevealLeft][2] + casingOffsetLeft
				alpha = -alfaBoardLeftOvhg
				gosub 9000	! Rotate 2D points around curved wall's center
				bpx5 = x
				bpy5 = y

				alpha = abs(atn(bpx5 / (bpy5 - WOD)))
				bpx6 = bpx5 + boardNosing * sin(alpha) * signWallIsLeft + casingOffsetLeft * sin(alfaL)
				bpy6 = bpy5 + boardNosing * cos(alpha) - casingOffsetLeft
			endif
		endif

		if gs_stack_right then
			bpx8 = rightRevealPnts[idxBoardEndRevealRight][1] - casingOffsetRight * sin(alfaR)
			bpy8 = rightRevealPnts[idxBoardEndRevealRight][2] + casingOffsetRight

			bpx7 = bpx8 - boardNosing * sin(alfaR) + casingOffsetRight * sin(alfaR)
			bpy7 = bpy8 + boardNosing * cos(alfaR) - casingOffsetRight
		else
			if bParalellInCurvedWalls then
				bpx8 = rightRevealPnts[idxBoardEndRevealRight][1] + gs_board_ovhg_right
				bpy8 = -signWallIsLeft * sqr(radBoard^2 - bpx8^2) + WOD + casingOffsetRight

				bpx7 = bpx8
				bpy7 = -signWallIsLeft * sqr((radBoard - signWallIsLeft * boardNosing)^2 - bpx7^2) + WOD
			else
				x = rightRevealPnts[idxBoardEndRevealRight][1] - casingOffsetRight * sin(alfaR)
				y = rightRevealPnts[idxBoardEndRevealRight][2] + casingOffsetRight
				alpha = alfaBoardRightOvhg
				gosub 9000	! Rotate 2D points around curved wall's center
				bpx8 = x
				bpy8 = y

				alpha = abs(atn(bpx8 / (bpy8 - WOD)))
				bpx7 = bpx8 - boardNosing * sin(alpha) * signWallIsLeft + casingOffsetRight * sin(alfaR)
				bpy7 = bpy8 + boardNosing * cos(alpha) - casingOffsetRight
			endif
		endif
	endif

	if bHasAnyBoardOn then
		! --- Check Board angle ---

		temp = max(abs(bpy6 + WOD) - WIDO_FRAME_THICKNESS, abs(bpy7 + WOD) - WIDO_FRAME_THICKNESS)
		maxBoardLength = max(abs(radBoard - iArchSign * gs_board_nosing - abs(WOD)) - WIDO_FRAME_THICKNESS, temp)
		if abs(maxBoardLength) < EPS then
			maxBoardAngle = 90
		else
			asnMaxBoardAngle = (gs_board_thk - 0.001) / maxBoardLength
			if asnMaxBoardAngle <= 1.0 & asnMaxBoardAngle >= -1.0 then
				maxBoardAngle = asn((gs_board_thk - 0.001) / maxBoardLength)
			else
				maxBoardAngle = 0
			endif
		endif
	endif
endif

goto 1


! ==============================================================================
! Rotate 2D points around curved wall's center
! ------------------------------------------------------------------------------
! Input variables:
!	x,y:				2D point
!	WOD:				"wido orig dist" in the wallhole coordinate system
!	alpha:				rotation angle
! Returned variables:
!	x,y:				rotated 2D point
! ==============================================================================

9000:
	xo = x
	yo = y - WOD
	x = xo * cos(signWallIsLeft * alpha) - yo * sin(signWallIsLeft * alpha)
	y = xo * sin(signWallIsLeft * alpha) + yo * cos(signWallIsLeft * alpha) + WOD
return


! ==============================================================================
! Generate Board Polygon - in Polygonal Walls
! ------------------------------------------------------------------------------
! Input variables:
!	ch:
!	leftRevealPnts, rightRevealPnts:
!	reveal point indices:
!	bPolyFor3D:
!	AC_WallContourPolygon:
!	boardNosing:
!	gs_stack_left:
!	gs_stack_right:
! ==============================================================================

2000:

	hotspotLeftX	= 0
	hotspotLeftY	= 0
	hotspotRightX	= 0
	hotspotRightY	= 0

	preparefunction ch, "CreateContainer", "mySourceContainer", ""
	preparefunction ch, "CreateContainer", "myDestinationContainer", ""

	preparefunction ch, "SetSourceContainer",	 	"mySourceContainer", ""
	preparefunction ch, "SetDestinationContainer",	"myDestinationContainer", ""

	! Avoid generating invalid polygons
	if WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS < EPS then
		return
	endif

! Store original wallhole polygon ----------------------------------------------

	dim vertArr1[][3]

	defaultInhEdgeInfo = -1
	dim inhEdgeInfos1[]

	put leftRevealPnts[idxFrameStartRevealLeft][1],	leftRevealPnts[idxFrameStartRevealLeft][2],	not(gs_stack_left)
	put leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2]

	lastBoardPointX = leftRevealPnts[idxFrameEndRevealLeft][1]
	lastBoardPointY = leftRevealPnts[idxFrameEndRevealLeft][2]
	for i=idxBoardStartRevealLeft to idxBoardEndRevealLeft
		if leftRevealPnts[i][2] >= WIDO_FRAME_THICKNESS then
			distFromLast = abs((leftRevealPnts[i][1] - lastBoardPointX)^2 + (leftRevealPnts[i][2] - lastBoardPointY)^2)
			if distFromLast > EPS then
				put not(gs_stack_left)	! previous point status
				put leftRevealPnts[i][1], leftRevealPnts[i][2]
				lastBoardPointX = leftRevealPnts[i][1]
				lastBoardPointY = leftRevealPnts[i][2]
				bHasAnyBoardPoint = 1
			endif
		endif
	next i
	put -1	! last pont status

	bHasAnyBoardPoint = 0
	for i = idxBoardEndRevealRight to idxBoardStartRevealRight step -1
		if rightRevealPnts[i][2] >= WIDO_FRAME_THICKNESS then
			distFromLast = abs((rightRevealPnts[i][1] - lastBoardPointX)^2 + (rightRevealPnts[i][2] - lastBoardPointY)^2)
			if not(bHasAnyBoardPoint) | distFromLast > EPS then
				put rightRevealPnts[i][1], rightRevealPnts[i][2], not(gs_stack_right)
				lastBoardPointX = rightRevealPnts[i][1]
				lastBoardPointY = rightRevealPnts[i][2]
				bHasAnyBoardPoint = 1
			endif
		endif
	next i
	if idxBoardStartRevealRight <> idxFrameEndRevealRight then
		put rightRevealPnts[idxFrameEndRevealRight][1],	rightRevealPnts[idxFrameEndRevealRight][2],	not(gs_stack_right)
	endif
	put rightRevealPnts[idxFrameStartRevealRight][1],rightRevealPnts[idxFrameStartRevealRight][2],	0

	nVertices1 = nsp/3
	for i=1 to nVertices1
		px = get(1)
		py = get(1)
		ps = get(1)
		vertarr1[i][1]	 = px
		vertarr1[i][2]	 = py
		vertarr1[i][3]	 = 0
		if bPolyFor3D then
			if ps < 0 then
				inhEdgeInfos1[i] = ps
			else
				inhEdgeInfos1[i] = 2 * ps
			endif
		else
			inhEdgeInfos1[i] = -(ps < 0)	! Mark wallhole edges (0 / -1)
		endif
	next i

	nContours1 = 1
	dim contArr1[]
	contArr1[1] = nVertices1 + 1

	if nVertices1 >= 2 then
		preparefunction ch, "Store", "poly1", nVertices1, nContours1, vertArr1, contArr1, defaultInhEdgeInfo, inhEdgeInfos1
	endif

	prevSourceContainer	= ""
	lastDestContainer	= "mySourceContainer"
	preparefunction ch, "SetDestinationContainer", lastDestContainer, ""

! Offset board side edge -------------------------------------------------------

	dim dstPolyIDArr[]
	numPoly = callfunction (ch, "GetDestinationPolygons", "", dstPolyIDArr)

	dim edgeIds[]
	edgeIds[numPoly] = 0
	for i=1 to numPoly

		dim inhEdgeInfos[]
		numEdges = callfunction(ch, "GetInhEdgeInfos", dstPolyIDArr[i], inhEdgeInfos)

		for j=1 to numEdges
			if inhEdgeInfos[j] = -1 then edgeIds[i] = j
		next j
	next i

	if prevSourceContainer <> "" then
		preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
	endif
	preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
	prevSourceContainer	= lastDestContainer
	lastDestContainer	= "myDestContainer2"
	preparefunction ch, "CreateContainer",			lastDestContainer, ""
	preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

	dim srcPolyIDArr[]
	numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

	dim tempResPolyIDArr[]
	for i=1 to numPoly

		preparefunction ch, "OffsetParams", "", edgeIds[i], 2.00

		tempNumPoly = callfunction (ch, "OffsetEdge", srcPolyIDArr[i], tempResPolyIDArr)
	next i

!!!dim resPolyIDArr[]
!!!numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!for i = 1 to numPoly
!!!	polygonID = resPolyIDArr[i]
!!!	gosub 1000	! Get GDL Polygon
!!!
!!!	ccc=0
!!!	for j=1 to nsp/3
!!!		xx=get(1)
!!!		yy=get(1)
!!!		ss=get(1)
!!!		ccc=ccc+0.003
!!!		circle2 xx,yy,ccc
!!!		text2 xx,yy,j
!!!	next j
!!!next i
!!!end

! Store wall contour polygon in wallhole coordinate system ---------------------

	if prevSourceContainer <> "" then
		preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
	endif
	preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
	prevSourceContainer	= lastDestContainer
	lastDestContainer	= "myDestContainer3"
	preparefunction ch, "CreateContainer",			lastDestContainer, ""
	preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

	nVertices2 = vardim1(AC_WallContourPolygon)
	dim vertArr2[][3]

	dim srcPolyIDArr[]
	numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

	defaultInhEdgeInfo = 0
	dim inhEdgeInfos2[]
!!!ccc=0
	for i=1 to nVertices2
		vertarr2[i][1] = AC_WallContourPolygon[i][1]
		if WIDO_REVEAL_SIDE then
			vertarr2[i][2] = AC_WallContourPolygon[i][2] + WIDO_FRAME_THICKNESS
			vertarr2[i][3] = AC_WallContourPolygon[i][3]
		else
			vertarr2[i][2] = -AC_WallContourPolygon[i][2]
			vertarr2[i][3] = -AC_WallContourPolygon[i][3]
		endif

		inhEdgeInfos2[i] = 1
!!!ccc=ccc+0.003
!!!circle2 vertarr2[i][1], vertarr2[i][2], ccc
!!!text2 vertarr2[i][1], vertarr2[i][2], i
	next i

	nContours2 = 1
	dim contArr2[]
	contArr2[1] = nVertices2 + 1

	preparefunction ch, "Store", "wallContourPoly", nVertices2, nContours2, vertArr2, contArr2, defaultInhEdgeInfo, inhEdgeInfos2

! Substract polygons -----------------------------------------------------------

	dim tempResPolyIDArr[]
	for i = 1 to numPoly
		tempNumPoly = callfunction (ch, "wallContourPoly - " + srcPolyIDArr[i], "", tempResPolyIDArr)
	next i
	savedNumPoly = tempNumPoly

! Parallel to Polygon Wall case ------------------------------------------------

!!!	if not(bBoardInPolyWall) then

! Intersect polygon wall contour and wallhole polygons -------------------------

		dim tempResPolyIDArr[]
		for i = 1 to numPoly
			tempNumPoly = callfunction (ch, "wallContourPoly / " + srcPolyIDArr[i], "", tempResPolyIDArr)
		next i

! Choose left and right reference points ---------------------------------------

		leftPx	= 0
		leftPy	= 0
		rightPx	= 0
		rightPy	= 0

		for i = 1 to tempNumPoly
			polygonID = tempResPolyIDArr[i]

			dim resVertices[]
			numVertices = callfunction(ch, "GetVertices", polygonID, resVertices)
			numVertices = numVertices / 3

			dim contArr[]
			numContours = callfunction(ch, "GetContourEnds", polygonID, contArr)

			dim inhEdgeInfos[]
			numEdges = callfunction(ch, "GetInhEdgeInfos", polygonID, inhEdgeInfos)

			for contIndex = 1 to numContours

				if contIndex = 1 then
					begIdx = 0
				else
					begIdx = contArr[contIndex] - 1
				endif
				if contIndex = numContours then
					endIdx = numVertices - 1
				else
					endIdx = contArr[contIndex + 1] - 2
				endif

!index = endIdx * 3
!lastVertX	= resVertices[index + 1]
!lastVertY	= resVertices[index + 2]
!lastVertA	= resVertices[index + 3]
				edgeInfo	= inhEdgeInfos[endIdx + 1]

				for vertIndex = begIdx to endIdx

					index = vertIndex * 3
					actVertX = resVertices[index + 1]
					actVertY = resVertices[index + 2]
					actVertA = resVertices[index + 3]

!text2	(lastVertX + actVertX) / 2,
!		(lastVertY + actVertY) / 2,
!		edgeInfo

					if edgeInfo <> inhEdgeInfos[vertIndex + 1] then
						if actVertX < 0 then
							if actVertY > leftPy then
								leftPx = actVertX
								leftPy = actVertY
							endif
						else
							if actVertY > rightPy then
								rightPx = actVertX
								rightPy = actVertY
							endif
						endif
!circle2 actVertX, actVertY, 0.05
					endif

!lastVertX	= actVertX
!lastVertY	= actVertY
!lastVertA	= actVertA
					edgeInfo	= inhEdgeInfos[vertIndex + 1]

				next vertIndex
			next contIndex
		next i

		! If any of the reference points missing, switch back to "Parallel to Window" mode
		if abs(leftPx) < EPS | leftPy < WIDO_FRAME_THICKNESS + EPS | abs(rightPx) < EPS | rightPy < WIDO_FRAME_THICKNESS + EPS then
			bBoardInPolyWall = 1
		endif
!!!	endif	! bBoardInPolyWall

!	if not(bBoardInPolyWall) then
!		circle2 leftPx,leftPy, 0.10
!		circle2 rightPx,rightPy, 0.10
!	endif

! Store Board polygon ----------------------------------------------------------

	if prevSourceContainer <> "" then
		preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
	endif
	preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
	prevSourceContainer	= lastDestContainer
	lastDestContainer	= "myDestContainer5"
	preparefunction ch, "CreateContainer",			lastDestContainer, ""
	preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

	dim srcPolyIDArr[]
	numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)
	numPoly = savedNumPoly

	boardNosingY = max(leftRevealPnts[idxBoardEndRevealLeft][2], rightRevealPnts[idxBoardEndRevealRight][2])
	if bBoardInPolyWall then
		boardNosingY = max(boardNosingY, max(leftPy, rightPy))
	endif
	boardNosingY = boardNosingY + boardNosing

	boardOvhgLeft	= max(gs_board_ovhg_left,	EPS)
	boardOvhgRight	= max(gs_board_ovhg_right,	EPS)

	if not(bBoardInPolyWall) then
		if abs(leftPx - rightPx) > EPS then
			boardDirAngle = atn((leftPy - rightPy) / (leftPx - rightPx))
		else
			bBoardInPolyWall = 0
		endif
	endif

	if sidelightCutLeft then
		put	sidelightCutPosLeft, boardNosingY,	2,
			sidelightCutPosLeft, 0,				2
		hotspotLeftX = sidelightCutPosLeft
		hotspotLeftY = boardNosingY
	else
		if bBoardInPolyWall then
			if boardNosing > EPS then
				hotspotLeftX = leftRevealPnts[idxBoardEndRevealLeft][1] - not(gs_stack_left) * boardOvhgLeft
				hotspotLeftY = boardNosingY
				put hotspotLeftX, hotspotLeftY, 2 * not(gs_stack_left)
			endif

			for i=idxBoardEndRevealLeft to idxBoardStartRevealLeft step -1
				put leftRevealPnts[i][1] - not(gs_stack_left) * boardOvhgLeft, leftRevealPnts[i][2] - (not(bPolyFor3D) & i <> idxBoardEndRevealLeft) * EPS,
					2 * ((not(gs_stack_left) & (bPolyFor3D | i <> idxBoardStartRevealLeft)) | (bPolyFor3D & i = idxBoardStartRevealLeft))
			next i
		else
			if boardNosing > EPS then
				if gs_stack_left then
					put leftPx, leftPy + boardNosing / cos(boardDirAngle), 0
				else
					hotspotLeftX = leftPx - boardNosing * sin(boardDirAngle) - boardOvhgLeft * cos(boardDirAngle)
					hotspotLeftY = leftPy + boardNosing * cos(boardDirAngle) - boardOvhgLeft * sin(boardDirAngle)

					put hotspotLeftX, hotspotLeftY, 2
					put hotspotLeftX + 2 * boardOvhgLeft * sin(boardDirAngle), hotspotLeftY - 2 * boardOvhgLeft * cos(boardDirAngle), 2
				endif
			endif

			put leftPx, leftPy, 2 * not(gs_stack_left)
			for i=idxBoardEndRevealLeft to idxBoardStartRevealLeft step -1
				if leftRevealPnts[i][2] < leftPy - EPS then
					put leftRevealPnts[i][1] - not(gs_stack_left) * EPS, leftRevealPnts[i][2] - (not(bPolyFor3D) & i <> idxBoardEndRevealLeft) * EPS,
						2 * ((not(gs_stack_left) & (bPolyFor3D | i <> idxBoardStartRevealLeft)) | (bPolyFor3D & i = idxBoardStartRevealLeft))
				endif
			next i
		endif
	endif

	if abs(bBoardNnosUsa) > EPS then	! Board Negative Nosing by USA Framesill
		put  leftRevealPnts[idxBoardStartRevealLeft][1]  + frameWidthLeft,	 leftRevealPnts[idxBoardStartRevealLeft][2],				2,
			 leftRevealPnts[idxBoardStartRevealLeft][1]  + frameWidthLeft,	 leftRevealPnts[idxBoardStartRevealLeft][2]  - bBoardNnosUsa,	2,
			rightRevealPnts[idxBoardStartRevealRight][1] - frameWidthRight, rightRevealPnts[idxBoardStartRevealRight][2] - bBoardNnosUsa,	2,
			rightRevealPnts[idxBoardStartRevealRight][1] - frameWidthRight,	rightRevealPnts[idxBoardStartRevealRight][2],				2
	endif

	if sidelightCutRight then
		put	sidelightCutPosRight, 0,			2,
			sidelightCutPosRight, boardNosingY,	2
		hotspotRightX = sidelightCutPosRight
		hotspotRightY = boardNosingY
	else
		if bBoardInPolyWall then
			for i=idxBoardStartRevealRight to idxBoardEndRevealRight
				put rightRevealPnts[i][1] + not(gs_stack_right) * boardOvhgRight, rightRevealPnts[i][2] - (not(bPolyFor3D) & i <> idxBoardEndRevealRight) * EPS,
					2 * ((not(gs_stack_right)) | (i = idxBoardEndRevealRight & boardNosing < EPS))
			next i
			if boardNosing > EPS then
				hotspotRightX = rightRevealPnts[idxBoardEndRevealRight][1] + not(gs_stack_right) * boardOvhgRight
				hotspotRightY = boardNosingY
				put hotspotRightX, hotspotRightY, 2
			endif
		else
			for i=idxBoardStartRevealRight to idxBoardEndRevealRight
				if rightRevealPnts[i][2] < rightPy - EPS then
					put rightRevealPnts[i][1] + not(gs_stack_right) * EPS, rightRevealPnts[i][2] - (not(bPolyFor3D) & i <> idxBoardEndRevealRight) * EPS,
						2 * ((not(gs_stack_right)) | (i = idxBoardEndRevealRight & boardNosing < EPS))
				endif
			next i

			put rightPx, rightPy, 2 * not(gs_stack_right)

			if boardNosing > EPS then
				if gs_stack_right then
					put rightPx, rightPy + boardNosing / cos(boardDirAngle), 2
				else
					hotspotRightX = rightPx - boardNosing * sin(boardDirAngle) + boardOvhgRight * cos(boardDirAngle)
					hotspotRightY = rightPy + boardNosing * cos(boardDirAngle) + boardOvhgRight * sin(boardDirAngle)

					put hotspotRightX + 2 * boardOvhgRight * sin(boardDirAngle), hotspotRightY- 2 * boardOvhgRight * cos(boardDirAngle), 2
					put hotspotRightX, hotspotRightY, 2
				endif
			endif
		endif
	endif

	dim vertArrBoard[][3]
	dim inhEdgeInfosBoard[]
	defaultInhEdgeInfo = 0

	for i=1 to nsp/3
		px = get(1)
		py = get(1)
		ps = round_int (get(1))

		vertArrBoard[i][1]	= px
		vertArrBoard[i][2]	= py
		vertArrBoard[i][3]	= 0
		inhEdgeInfosBoard[i]= ps
	next i
	nVerticesBoard = vardim1(vertArrBoard)

	nContoursBoard = 1
	dim contArrBoard[]
	contArrBoard[1] = nVerticesBoard + 1

	if nVertices1 >= 2 then
		preparefunction ch, "Store", "boardPoly", nVerticesBoard, nContoursBoard, vertArrBoard, contArrBoard, defaultInhEdgeInfo, inhEdgeInfosBoard
	endif

!! Regularize polygon(s) --------------------------------------------------------
!
!	dim srcPolyIDArr[]
!	numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)
!
!	dim tempResPolyIDArr[]
!	for i=1 to numPoly
!		tempNumPoly = callfunction (ch, "Regularize", srcPolyIDArr[i], tempResPolyIDArr)
!	next i
!
!	if prevSourceContainer <> "" then
!		preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
!	endif
!	preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
!	prevSourceContainer	= lastDestContainer
!	lastDestContainer	= "myDestContainer5"
!	preparefunction ch, "CreateContainer",			lastDestContainer, ""
!	preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

! Substract polygons -----------------------------------------------------------

	dim operandPolygonNames[]
		operandPolygonNames[1] = "boardPoly"
	numOperandPolygonNames = 1
	containerIdx = 10

	while numPoly > 0 do

		for i = 2 to numPoly
			tempNumPoly = callfunction (ch, "CopyPolygon", srcPolyIDArr[i], tempResPolyIDArr)
		next i
		lastNumPoly = numPoly - 1

		for i=1 to numOperandPolygonNames
			tempNumPoly = callfunction (ch, operandPolygonNames[i] + " - " + srcPolyIDArr[1], "", tempResPolyIDArr)
		next i

		numResPoly = tempNumPoly - lastNumPoly + 1

		dim resPolyIDArr[]
		tempNumPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)

		numOperandPolygonNames = tempNumPoly - lastNumPoly

		for i=1 to numOperandPolygonNames
			operandPolygonNames[i] = resPolyIDArr[lastNumPoly + i]
		next i

		numPoly = numPoly - 1

		if numPoly > 0 then
			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer" + str(containerIdx, 1, 0)
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""
			containerIdx = containerIdx + 1
		endif
	endwhile
return


1:

]]>
</Script_1D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_PR SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_PR>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_UI SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[

pageStartY = 10

if bDoorWithSidelightSupport then
	if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then
		ui_pict 51, 7, pageStartY - 2, 12, 12, 1	! ui_warningsign.png
		ui_style 0,0
		ui_outfield stBoardUI[20], 28, pageStartY - 2, 410, 17
		end
	endif
endif

x1 = 2
x2 = 35
x3 = 140
x4 = 195
y = pageStartY
dy = 26
cx = 40
cy = 24
px = 30
py = 20

ui_style 0,1

if bDoorWithSidelightSupport then
	if iWindowShape = SHAPE_T | iWindowShape = SHAPE_ARCHED_T then
		ui_infield{3} "gs_board_inside_sl_right", x1, y, 190, 19,
				7, "",
				2,
				1, 20, 20, 20, 20,
				0, stBoardUI[17], 0,	! Board - Sidelight 1
				1, stBoardUI[17], 1		! Board - Sidelight 1
		ui_infield{3} "gs_board_inside_sl_left", 205, y, 190, 19,
				7, "",
				2,
				1, 20, 20, 20, 20,
				0, stBoardUI[18], 0,	! Board - Sidelight 2
				1, stBoardUI[18], 1		! Board - Sidelight 2
	else
		if iWindowShape = SHAPE_HALF_T_LEFT | iWindowShape = SHAPE_ARCHED_HALF_T_LEFT then
			ui_infield{3} "gs_board_inside_sl_left", x1, y, 190, 19,
					7, "",
					2,
					1, 20, 20, 20, 20,
					0, stBoardUI[19], 0,	! Board - Sidelight
					1, stBoardUI[19], 1		! Board - Sidelight
		else
			if iWindowShape = SHAPE_HALF_T_RIGHT | iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then
				ui_infield{3} "gs_board_inside_sl_right", x1, y, 190, 19,
						7, "",
						2,
						1, 20, 20, 20, 20,
						0, stBoardUI[19], 0,	! Board - Sidelight
						1, stBoardUI[19], 1		! Board - Sidelight
			endif
		endif
	endif
else
	ui_infield{3} "gs_board_inside", x1, y, 190, 19,
			7, "",
			2,
			1, 20, 20, 20, 20,
			0, stBoardUI[1], 0,		! Board
			1, stBoardUI[1], 1		! Board
endif

y = y + dy

ui_style 0,0
ui_infield{3} "gs_board_curved", x1, y, 300, 19,
			7, "",
			2,
			1, 20, 20, 20, 20,
			0, stBoardUI[5], 0,		! Is Curved in Curved Walls
			1, stBoardUI[5], 1		! Is Curved in Curved Walls

bFlag = not(bHasAnyBoardOn) | abs (gs_board_angle) > EPS
iFlag = 4 * bFlag

y = y + dy

ui_outfield stBoardUI[13], x1, y, 202, 15, iFlag		! In Polygonal Walls
ui_infield{3} "iBoardInPolyWall", x1 + 202 + 1, y-4, 180, 19,
			8, "", 2, 1, 0, 0, 0, 0,
			1, `Параллельно Окну`, BOARD_PARALLEL_WINDOW,
			2, `Параллельно Многоугольнику Стены`, BOARD_PARALLEL_WALLPOLYGON				

y = y + dy + 5

bFlag = not(bHasAnyBoardOn)
iFlag = 4 * bFlag


! --- overhangs ---
x1 = 30
x2 = x1 + 75
y1 = y + 35

if bHasAnyBoardOn and not (gs_stack_bottom) then
	if iPanelType = 0 then
		ui_pict 9, x1, y1, 60, 52, 1		!ui_board_leftovhg_win0
		ui_pict 10, x2, y1, 60, 52, 1		!ui_board_rightovhg_win0
	endif
	if iPanelType = 1 then
		if not(bOpeningDirection) then	! Outside
			ui_pict 11, x1, y1, 60, 52, 1		!ui_board_leftovhg_win1_out
			ui_pict 12, x2, y1, 60, 52, 1		!ui_board_rightovhg_win1_out
		else
			ui_pict 13, x1, y1, 60, 52, 1		!ui_board_leftovhg_win1_in
			ui_pict 14, x2, y1, 60, 52, 1		!ui_board_rightovhg_win1_in
		endif
	endif
	if iPanelType = 2 then
		! Single Double Hung`s always inside direction
		ui_pict 17, x1, y1, 60, 52, 1		!ui_board_leftovhg_win2_in
		ui_pict 18, x2, y1, 60, 52, 1		!ui_board_rightovhg_win2_in
	endif
	if iPanelType = 3 then
		ui_pict 19, x1, y1, 60, 52, 1			!ui_board_leftovhg_win3
		ui_pict 20, x2, y1, 60, 52, 1			!ui_board_rightovhg_win3
	endif

	ui_pict 21, x1, y1+52, 60, 18, 1			!ui_board_leftovhg_2
	ui_pict 22, x2, y1+52, 60, 18, 1			!ui_board_rightovhg_2

	ui_infield "gs_board_ovhg_left",	x1-19, y1+75,	79, 19	ui_tooltip stBoardUI[2]		! Left Overhang
	ui_infield "gs_board_ovhg_right",	x2, y1+75,	79, 19	ui_tooltip stBoardUI[3]		! Right Overhang
else
	if iPanelType = 0 then
		ui_pict 25, x1, y1, 60, 52, 1			!ui_board_leftovhg_win0_noboard
		ui_pict 26, x2, y1, 60, 52, 1			!ui_board_rightovhg_win0_noboard
	endif
	if iPanelType = 1 then
		if not(bOpeningDirection) then	! Outside
			ui_pict 27, x1, y1, 60, 52, 1		!ui_board_leftovhg_win1_out_noboard
			ui_pict 28, x2, y1, 60, 52, 1		!ui_board_rightovhg_win1_out_noboard
		else
			ui_pict 29, x1, y1, 60, 52, 1		!ui_board_leftovhg_win1_in_noboard
			ui_pict 30, x2, y1, 60, 52, 1		!ui_board_rightovhg_win1_in_noboard
		endif
	endif
	if iPanelType = 2 then
		! Single Double Hung`s always inside direction
		ui_pict 33, x1, y1, 60, 52, 1		!ui_board_leftovhg_win2_in_noboard
		ui_pict 34, x2, y1, 60, 52, 1		!ui_board_rightovhg_win2_in_noboard
	endif
	if iPanelType = 3 then
		ui_pict 35, x1, y1, 60, 52, 1			!ui_board_leftovhg_win3_noboard
		ui_pict 36, x2, y1, 60, 52, 1			!ui_board_rightovhg_win3_noboard
	endif
endif


! --- board section ---
x1 = 230
y1 = y + 15

if iPanelType = 0 then
	ui_pict 37,		x1, 	y1, 	94, 37, 1		!ui_board_win0
endif
if iPanelType = 1 then
	if not(bOpeningDirection) then	! Outside
		ui_pict 38, 	x1, 	y1, 	94, 37, 1		!ui_board_win1_out
	else
		ui_pict 39, 	x1, 	y1, 	94, 37, 1		!ui_board_win1_in
	endif
endif
if iPanelType = 2 then
	! Single Double Hung`s always inside direction
	ui_pict 41, 	x1, 	y1, 	94, 37, 1		!ui_board_win2_in
endif
if iPanelType = 3 then
	ui_pict 42, 			x1, 	y1, 	94, 37, 1	!ui_board_win3
endif

if bHasAnyBoardOn and not (gs_stack_bottom) then
	if iRevealType = REVEAL_DOUBLE_SPLAYED then
		ui_pict 48, x1, 	y1+37, 	125, 85, 1			!ui_board_main_splayed
		ui_infield "gs_board_thk",		x1+132, 	y1+58,	79, 19	ui_tooltip stBoardUI[11]	! Board Thickness
		ui_infield "gs_board_nosing",	x1+132, 	y1+81,	79, 19	ui_tooltip stBoardUI[12]	! Board Nosing
		ui_infield "gs_board_width",	x1+132, 	y1+104 ,	79, 19	ui_tooltip stBoardUI[14]	! Board Width
	else
		if gs_board_angle < EPS then
			ui_pict 46, 	x1, 	y1+37, 	94, 85, 1			!ui_board_main0_board
			ui_pict 47, 	x1+94, 	y1+27, 	31, 76, 1			!ui_board_main0_boardend
		else
			ui_pict 43, 	x1, 	y1+37, 	94, 85, 1			!ui_board_main_board
			ui_pict 44, 	x1+94, 	y1+27, 	31, 76, 1			!ui_board_main_boardend
		endif

		ui_infield "gs_board_angle",	x1+128, 	y1+23,	79, 19	ui_tooltip stBoardUI[10]	! Board Angle
		ui_infield "gs_board_thk",		x1+128, 	y1+46,	79, 19	ui_tooltip stBoardUI[11]	! Board Thickness
		ui_infield "gs_board_nosing",	x1+128, 	y1+69,	79, 19	ui_tooltip stBoardUI[12]	! Board Nosing
		ui_infield "gs_board_width",	x1+128, 	y1+92,	79, 19	ui_tooltip stBoardUI[14]	! Board Width
	endif
else
	ui_pict 45, 		x1, 	y1+37, 	94, 85, 1		!ui_board_main_noboard
endif

!	x1 = 2
!	x2 = x1 + 33
!	x3 = x1 + 218
!
!	y = pageStartY
!	dy = 26
!	cx = 40
!	cy = 23
!	px = 30
!	py = 20
!
!	if not(bDoorWithSidelightSupport) then
!		ui_style 0,1
!		ui_infield{3} "gs_board_inside", x1, y, x3-x1, 15,
!				7, "",
!				2,
!				1, 20, 20, 20, 20,
!				0, stBoardUI[ 1], 0,		! Board
!				1, stBoardUI[ 1], 1			! Board
!	endif
!	y=y+dy
!
!	bFlag = not(bHasAnyBoardOn)
!	iFlag = 4 * bFlag
!
!	ui_style 0,0
!
!	if bFlag then
!		ui_pict 2, x1, y-1, 12,17, 1		! ui_mat_lock.png
!	else
!		ui_pict 1, x1, y-1, 12,17, 1		! ui_mat.png
!	endif
!	ui_outfield stBoardUI[6],  x2, y, 100, 15, iFlag			! Material
!	ui_infield "gs_board_mat", x3, y-8, x3-x2-1, 28
!
!	ui_style 0,1
!	y=y+dy+5
!	ui_outfield stBoardUI[15],  x1, y, 100, 15, iFlag			! Section Attributes
!
!	ui_style 0,0
!	bFlag = not(bHasAnyBoardOn)
!	iFlag = 4 * bFlag
!	y=y+dy
!
!	if bFlag then
!		ui_pict 50, x1, y, 24, 17, 1		! ui_contour_pen_lock.png
!	else
!		ui_pict 49, x1, y, 24, 17, 1		! ui_contour_pen.png
!	endif
!	ui_outfield stBoardUI[16], x2, y, x3-x2-1, 18, iFlag	! Contour Pen
!	ui_infield "gs_board_pen_sectcont",	 x3,y, cx, cy
!	y=y+dy
!
!	bFlag = not(gs_bFills & bHasAnyBoardOn)
!	iFlag = 4 * bFlag
!
!	if bFlag then
!		ui_pict 4, x1, y, 13, 17, 1		! ui_fill_type_lock.png
!	else
!		ui_pict 3, x1, y, 13, 17, 1		! ui_fill_type.png
!	endif
!	ui_outfield stBoardUI[7], x2, y, 100, 15, iFlag			! Fill Type
!	ui_infield "gs_board_fill", x3, y, x3-x2-1, 28
!	y=y+31
!
!	if bFlag then
!		ui_pict 6, x1, y, 24, 17, 1		! ui_fill_pen_lock.png
!	else
!		ui_pict 5, x1, y, 24, 17, 1		! ui_fill_pen.png
!	endif
!	ui_outfield stBoardUI[8], x2, y, x3-x2-1, 18, iFlag	! Fill Pen
!	ui_infield "gs_board_pen_fg",	 x3,y, cx, cy
!	y=y+dy
!
!	if bFlag then
!		ui_pict 8, x1, y, 24, 17, 1		! ui_back_pen_lock.png
!	else
!		ui_pict 7, x1, y, 24, 17, 1		! ui_back_pen.png
!	endif
!	ui_outfield stBoardUI[9], x2, y, x3-x2-1, 18, iFlag	! Background Pen
!	ui_infield "gs_board_pen_bg", x3, y, cx, cy
!endif

]]>
</Script_UI>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_VL SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! Contact person: <NJ>

! ==============================================================================
! This macro draws the Board
! ------------------------------------------------------------------------------
! Input parameters:
!	A:						Window nominal width (length)
!	B:						Window nominal height (length)
!	gs_IsCurved:			Does the window follow the curvature of the wall? (0 / 1)
!	iWindowShape:			Shape of the window (integer)
!								0 = rectangular (default)
!								1 = arched
!							Note: only the rectangular shape can be a Corner Window
! Corner Function --------------------------------------------------------------
!	bLeftCornerFunction:		Turn macro in Corner Window mode at the left side (0 / 1)
!	leftCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	leftConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
!	bRightCornerFunction:	Turn macro in Corner Window mode at the right side (0 / 1)
!	rightCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	rightConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
! Oversize ---------------------------------------------------------------------
!	ac_right_oversize:		Right opening oversize (length)
! Sill -------------------------------------------------------------------------
!	gs_sill_oversize:		Identifies the method as the macro handles the nominal
!								opening sizes when Sill are turned on. (0 / 1)
!	gs_sill_thk:			Thickness of the Sill. (length)
!	gs_board_width:			Width of Board. (length)
!	gs_board_thk:			Thickness of the Board. (length)
!	gs_board_nosing:		Nosing of the Board. (length)
!	gs_board_angle:			Board slope. (angle)
!	gs_board_ovhg_left:		Board overhang on the left side. (length)
!	gs_board_ovhg_right:	Board overhang on the right side. (length)
!	gs_board_slip_in:		Slip in of the Board. Only effective when iSillType = 2 or iSillType = 3 (length)
!	gs_board_curved:		Board edge is curved or straight. (0 / 1)
! Ganging ----------------------------------------------------------------------
!	gs_stack_left:			Align to door/window on left side (0 / 1)
!	gs_stack_right:			Align to door/window on right side (0 / 1)
!	gs_stack_bottom:		Align to door/window on bottom side (0 / 1)
!	--- String Tables ---
!
! Related Global Variables:
!	GLOB_SCRIPT_TYPE
!	GLOB_CONTEXT
!	WALL_THICKNESS
!	WALL_INCL
!	WIDO_FRAME_THICKNESS
!	WIDO_SILL
!	WIDO_LEFT_JAMB
!	WIDO_RIGHT_JAMB
!	WIDO_ORIG_DIST
!	WIDO_REVEAL_SIDE
!	SYMB_MIRRORED
!	SYMB_ROTANGLE
! ==============================================================================


! ==============================================================================
! Window Oversize Calculations
! ==============================================================================

if bDoorWithSidelightSupport then
	if not(gs_sidelight_left & gs_sidelight_parapet_hgt_left > EPS) then
		hideparameter "gs_board_inside_sl_left"
		lock "gs_board_inside_sl_left"
		if gs_sidelight_left & gs_sidelight_parapet_hgt_left < EPS then
			gs_board_inside_sl_left = 0
			parameters gs_board_inside_sl_left = 0
		endif
	endif
	if not(gs_sidelight_right & gs_sidelight_parapet_hgt_right > EPS) then
		hideparameter "gs_board_inside_sl_right"
		lock "gs_board_inside_sl_right"
		if gs_sidelight_right & gs_sidelight_parapet_hgt_right < EPS then
			gs_board_inside_sl_right = 0
			parameters gs_board_inside_sl_right = 0
		endif
	endif
endif

if not(bHasAnyBoardOn) | gs_stack_bottom then						! Off
	hideparameter	"gs_board_thk",
					"gs_board_width",
					"gs_board_nosing",
					"gs_board_angle",
					"gs_board_angle",
					"gs_board_ovhg_left",
					"gs_board_ovhg_right",
					"gs_board_slip_in",
					"gs_board_curved",
					"gs_board_pen_sectcont",
					"gs_board_pen_3D",
					"gs_board_fill",
					"gs_board_pen_fg",
					"gs_board_pen_bg",
					"gs_board_mat",
					"iBoardInPolyWall"

	lock	"gs_board_thk",
			"gs_board_width",
			"gs_board_nosing",
			"gs_board_angle",
			"gs_board_angle",
			"gs_board_ovhg_left",
			"gs_board_ovhg_right",
			"gs_board_slip_in",
			"gs_board_curved",
			"gs_board_pen_sectcont",
			"gs_board_pen_3D",
			"gs_board_fill",
			"gs_board_pen_fg",
			"gs_board_pen_bg",
			"gs_board_mat",
			"iBoardInPolyWall"
else
	if bHasAnyBoardOn & not(gs_sill_oversize) then
		hideparameter	"gs_board_slip_in"	! Inside, Both Sides
		lock 			"gs_board_slip_in"
	endif

	if gs_stack_left then
		hideparameter "gs_board_ovhg_left"
		lock "gs_board_ovhg_left"
	endif
	if gs_stack_right then
		hideparameter "gs_board_ovhg_right"
		lock "gs_board_ovhg_right"
	endif

	if bHasAnyBoardOn then			! Inside, Both Sides

		values "gs_board_thk" range (0, ]

		if maxBoardAngle > EPS then
			if gs_board_angle > maxBoardAngle - EPS then
				gs_board_angle = maxBoardAngle - EPS
				parameters gs_board_angle = maxBoardAngle - EPS
			endif
			values "gs_board_angle" range[0, maxBoardAngle)
		else
			values "gs_board_angle" range[0,)
		endif

		values "gs_board_width"			range[WALL_THICKNESS + minBoardNosing - WIDO_SILL - WIDO_FRAME_THICKNESS, )
		values "gs_board_nosing"		range[minBoardNosing,]
		values "gs_board_ovhg_left"		range[minBoardOvhgLeft,]
		values "gs_board_ovhg_right"	range[minBoardOvhgRight,]
	endif
endif

values{2} "iBoardInPolyWall" 	BOARD_PARALLEL_WINDOW,		stBoardInPolyWall[1],
								BOARD_PARALLEL_WALLPOLYGON,	stBoardInPolyWall[2]

if abs(gs_board_angle) > EPS then
	iBoardInPolyWall = BOARD_PARALLEL_WINDOW
	parameters iBoardInPolyWall = iBoardInPolyWall
	lock	"iBoardInPolyWall"
endif

if iRevealType = REVEAL_DOUBLE_SPLAYED then
	if GLOB_MODPAR_NAME = "gs_board_width" then
		gs_board_nosing = gs_board_width * cos(gs_reveal_bottom_angle) - (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS)
		parameters gs_board_nosing = gs_board_nosing
	else
		gs_board_width = ((WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS) + gs_board_nosing) / cos(gs_reveal_bottom_angle)
		parameters gs_board_width = gs_board_width
	endif
else
	if GLOB_MODPAR_NAME = "gs_board_width" then
		gs_board_nosing = gs_board_width - (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS)
		parameters gs_board_nosing = gs_board_nosing
	else
		gs_board_width = gs_board_nosing + (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS)
		parameters gs_board_width = gs_board_width
	endif
endif

]]>
</Script_VL>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Comment SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Comment>

<ParamSection SectVersion="26" SectionFlags="0" SubIdent="0">
	<ParamSectHeader>
		<Version>26</Version>
		<AutoHotspots>false</AutoHotspots>
		<StatBits>
			<STBit_FixSize/>
		</StatBits>
		<WDLeftFrame>0</WDLeftFrame>
		<WDRightFrame>0</WDRightFrame>
		<WDTopFrame>0</WDTopFrame>
		<WDBotFrame>0</WDBotFrame>
		<LayFlags>65535</LayFlags>
		<WDMirrorThickness>0</WDMirrorThickness>
		<WDWallInset>0</WDWallInset>
		<SymbolColor>0</SymbolColor>
	</ParamSectHeader>
	<Parameters>
		<Length Name="A">
			<Description><![CDATA["Dimension 1"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Length Name="B">
			<Description><![CDATA["Dimension 2"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Length Name="ZZYZX">
			<Description><![CDATA["Height"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Integer Name="AC_WallContours">
			<Description><![CDATA["Wall Contours (0-None,1-Full,2-Side,3-Length)"]]></Description>
			<Fix/>
			<Value>0</Value>
		</Integer>
		<Integer Name="AC_Hole_Hotspot_Control">
			<Description><![CDATA["Hotspots 0-None,1-2D,2-3D,3-All"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<Boolean Name="AC_show2DHotspotsIn3D">
			<Description><![CDATA["Show 2D Hotspots in 3D"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="ac_bottomlevel">
			<Description><![CDATA["Bottom Level"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="ac_toplevel">
			<Description><![CDATA["Top Level"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="AC_HoleSideMaterial">
			<Description><![CDATA["Hole has Wall's Side Surface"]]></Description>
			<Fix/>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="AC_HoleMaterialCurved">
			<Description><![CDATA["Hole Surface's Split is Curved in Curved Walls"]]></Description>
			<Fix/>
			<Value>0</Value>
		</Boolean>
		<Integer Name="gs_macro_version">
			<Description><![CDATA["Macro Version"]]></Description>
			<Value>12</Value>
		</Integer>
		<Angle Name="AC_Hole_Position_Angle">
			<Description><![CDATA["Hole Position Angle"]]></Description>
			<Value>0</Value>
		</Angle>
		<Integer Name="AC_WallType">
			<Description><![CDATA["Wall Type"]]></Description>
			<Value>1</Value>
		</Integer>
		<Integer Name="AC_WindowInWallContour">
			<Description><![CDATA["Window in Wall Contour"]]></Description>
			<ArrayValues FirstDimension="4" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="AC_WallContourPolygon">
			<Description><![CDATA["Wall Contour Polygon"]]></Description>
			<ArrayValues FirstDimension="1" SecondDimension="3">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="AC_Wall_Direction_Type">
			<Description><![CDATA["Wall Direction Type"]]></Description>
			<Value>0</Value>
		</Integer>

		<!-- gs_wallhole_geometry: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_wallhole_geometry">
			<Description><![CDATA["Wallhole Geometry"]]></Description>
		</Title>
		<Length Name="refWidth">
			<Description><![CDATA["Reference Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="leftWidth">
			<Description><![CDATA["Left Offset from the Origo"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="rightWidth">
			<Description><![CDATA["Right Offset from the Origo"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="radBoard">
			<Description><![CDATA["Curved Wall - Board Radius"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="WOD">
			<Description><![CDATA["Curved Wall - Wall Center Distance"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="overSizeLower">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="offsY">
			<Description><![CDATA["Vertical Offset Size"]]></Description>
			<Value>0</Value>
		</Length>

		<!-- gs_macro_control_parameters: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_macro_control_parameters">
			<Description><![CDATA["Macro Control Parameters"]]></Description>
		</Title>
		<Integer Name="iPanelType">
			<Description><![CDATA["Window Panel Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Boolean Name="gs_IsCurved">
			<Description><![CDATA["Curved Window"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bParalellInCurvedWalls">
			<Description><![CDATA["Parallel Opening in Curved Walls"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bOpeningDirection">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bDoorWithSidelightSupport">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="iWindowShape">
			<Description><![CDATA["Window Shape"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Integer>

		<!-- iRevealType: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Integer Name="iRevealType">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Angle Name="gs_reveal_left_angle">
			<Description><![CDATA["Angle Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_right_angle">
			<Description><![CDATA["Angle Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Length Name="gs_reveal_splayed_innerBottom">
			<Description><![CDATA["Inner Sill Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerBottom">
			<Description><![CDATA["Inner Sill Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerLeft_sL">
			<Description><![CDATA["Inner Lower Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerRight_sR">
			<Description><![CDATA["Inner Lower Jamb Depth Side 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerBottom_sL">
			<Description><![CDATA["Inner Sill Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerBottom_sR">
			<Description><![CDATA["Inner Sill Depth Side 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="leftRevealPnts">
			<Description><![CDATA["Left Reveal Points"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="rightRevealPnts">
			<Description><![CDATA["Right Reveal Points"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="iRevealPointsIdx">
			<Description><![CDATA["Reveal Points Index"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="20" SecondDimension="0">
				<AVal Row="1">1</AVal>
				<AVal Row="2">1</AVal>
				<AVal Row="3">1</AVal>
				<AVal Row="4">1</AVal>
				<AVal Row="5">1</AVal>
				<AVal Row="6">1</AVal>
				<AVal Row="7">1</AVal>
				<AVal Row="8">1</AVal>
				<AVal Row="9">1</AVal>
				<AVal Row="10">1</AVal>
				<AVal Row="11">1</AVal>
				<AVal Row="12">1</AVal>
				<AVal Row="13">1</AVal>
				<AVal Row="14">1</AVal>
				<AVal Row="15">1</AVal>
				<AVal Row="16">1</AVal>
				<AVal Row="17">1</AVal>
				<AVal Row="18">1</AVal>
				<AVal Row="19">1</AVal>
				<AVal Row="20">1</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="skinOffsetBoard">
			<Description><![CDATA["Thickness of Hidden Wall Skins at Board Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_turn_plaster: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_turn_plaster">
			<Description><![CDATA["Turn Plaster"]]></Description>
		</Title>
		<Boolean Name="gs_turn_plaster_show_3D">
			<Description><![CDATA["Show in 3D"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="thkPlasterAtBoardLeft">
			<Description><![CDATA["Plaster Thickness at Board - Left Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardSlLeft">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardRight">
			<Description><![CDATA["Plaster Thickness at Board - Right Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardSlRight">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_corner_functions: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_corner_functions">
			<Description><![CDATA["Corner Functions"]]></Description>
		</Title>
		<Boolean Name="bLeftCornerFunction">
			<Description><![CDATA["Left Corner"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Angle Name="leftCornerAngle">
			<Description><![CDATA["Left Corner Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Length Name="leftConnWallThk">
			<Description><![CDATA["Left Connected Wall Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="bRightCornerFunction">
			<Description><![CDATA["Right Corner"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Angle Name="rightCornerAngle">
			<Description><![CDATA["Right Corner Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Length Name="rightConnWallThk">
			<Description><![CDATA["Right Connected Wall Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_window_oversize: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_window_oversize">
			<Description><![CDATA["Oversize"]]></Description>
		</Title>
		<Length Name="gs_left_oversize">
			<Description><![CDATA["Left Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_right_oversize">
			<Description><![CDATA["Right Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_lower_oversize">
			<Description><![CDATA["Lower Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="gs_sill_oversize">
			<Description><![CDATA["Sill Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="iSillType">
			<Description><![CDATA["Type of the Sill"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Length Name="gs_sill_thk">
			<Description><![CDATA["Sill Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.025</Value>
		</Length>

		<!-- gs_board_inside: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="gs_board_inside">
			<Description><![CDATA["Board"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="gs_board_inside_sl_left">
			<Description><![CDATA["Board - Sidelight Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="gs_board_inside_sl_right">
			<Description><![CDATA["Board - Sidelight Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bDrawBoard">
			<Description><![CDATA["Draw Board 2D and 3D"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Length Name="gs_board_width">
			<Description><![CDATA["Board Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.1</Value>
		</Length>
		<Length Name="gs_board_thk">
			<Description><![CDATA["Board Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.025</Value>
		</Length>
		<Length Name="gs_board_nosing">
			<Description><![CDATA["Board Nosing"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.03</Value>
		</Length>
		<Angle Name="gs_board_angle">
			<Description><![CDATA["Board Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Length Name="gs_board_ovhg_left">
			<Description><![CDATA["Board Overhang Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_board_ovhg_right">
			<Description><![CDATA["Board Overhang Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_board_slip_in">
			<Description><![CDATA["Board Slip-in Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="gs_board_curved">
			<Description><![CDATA["Board is Curved in Curved Walls"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bBoardInPolyWall">
			<Description><![CDATA["Board in Polygonal Walls"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bShowBoardSplice">
			<Description><![CDATA["Show Board Splice Lines (CW)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bWindowSymbolAtMiddle">
			<Description><![CDATA["Window Symbol at Middle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="minBoardNosing">
			<Description><![CDATA["Minimal Nosing"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="minBoardOvhgLeft">
			<Description><![CDATA["Minimal Left Overhang"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="minBoardOvhgRight">
			<Description><![CDATA["Minimal Right Overhang"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- bDrawInsideTrim: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="bDrawInsideTrim">
			<Description><![CDATA["Casing Inside"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_trim_thk_in">
			<Description><![CDATA["Thickness on Wall"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.019</Value>
		</Length>
		<Boolean Name="gs_trim_atframe_in">
			<Description><![CDATA["Casing at Frame Inside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_trim_width_in">
			<Description><![CDATA["Thickness in Wallhole"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_2D_representation: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_2D_representation">
			<Description><![CDATA["2D and Section Representation"]]></Description>
		</Title>
		<Integer Name="lod2D_sillBoard">
			<Description><![CDATA["Level of Detail in 2D"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Boolean Name="bShowAddHotspots">
			<Description><![CDATA["Show Additional Hotspots"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<PenColor Name="gs_pen_2D">
			<Description><![CDATA["2D Contour Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</PenColor>
		<Boolean Name="gs_bFills">
			<Description><![CDATA["Use Fills"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<FillPattern Name="gs_board_wallhole_fill">
			<Description><![CDATA["Wallhole Fill Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</FillPattern>
		<PenColor Name="gs_board_wallhole_pen_fg">
			<Description><![CDATA["Wallhole Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="gs_board_wallhole_pen_bg">
			<Description><![CDATA["Wallhole Fill Background Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>92</Value>
		</PenColor>
		<FillPattern Name="gs_board_wallhole_fill_sl">
			<Description><![CDATA["Wallhole Fill Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</FillPattern>
		<PenColor Name="gs_board_wallhole_pen_sl_fg">
			<Description><![CDATA["Wallhole Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="gs_board_wallhole_pen_sl_bg">
			<Description><![CDATA["Wallhole Fill Background Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="gs_board_pen_2D">
			<Description><![CDATA["Board 2D Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="gs_board_pen_3D">
			<Description><![CDATA["Board 3D Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<FillPattern Name="gs_board_fill">
			<Description><![CDATA["Board Fill Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>65</Value>
		</FillPattern>
		<PenColor Name="gs_board_pen_fg">
			<Description><![CDATA["Board Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="gs_board_pen_bg">
			<Description><![CDATA["Board Fill Background Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="gs_board_pen_sectcont">
			<Description><![CDATA["Section Contour Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>

		<!-- gs_3D_representation: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_3D_representation">
			<Description><![CDATA["3D Representation"]]></Description>
		</Title>
		<Integer Name="lod3D">
			<Description><![CDATA["Level of Detail in 3D"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<PenColor Name="gs_frame_pen">
			<Description><![CDATA["Frame Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2</Value>
		</PenColor>

		<!-- gs_window_material: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_window_material">
			<Description><![CDATA["Surfaces"]]></Description>
		</Title>
		<Material Name="gs_board_mat">
			<Description><![CDATA["Board Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>78</Value>
		</Material>

		<!-- ac_details: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="ac_details">
			<Description><![CDATA["Computed Oversize Values"]]></Description>
		</Title>
		<Length Name="ac_left_oversize">
			<Description><![CDATA["AC Left Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="ac_right_oversize">
			<Description><![CDATA["AC Right Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="ac_upper_oversize">
			<Description><![CDATA["AC Upper Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="ac_lower_oversize">
			<Description><![CDATA["AC Lower Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_window_stack: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_window_stack">
			<Description><![CDATA["Ganging"]]></Description>
		</Title>
		<Boolean Name="gs_stack_left">
			<Description><![CDATA["Connection on the Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_stack_right">
			<Description><![CDATA["Connection on the Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_stack_bottom">
			<Description><![CDATA["Connection on the Bottom"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- gs_parapet_wall_inset: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="gs_parapet_wall_inset">
			<Description><![CDATA["Wall Inset"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_parapet_inset_thk">
			<Description><![CDATA["Depth of Inset"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.2</Value>
		</Length>

		<!-- gs_sidelight_left: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="gs_sidelight_left">
			<Description><![CDATA["Left Sidelight"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_sidelight_WHole_width_left">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_sidelight_parapet_hgt_left">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_sidelight_right: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="gs_sidelight_right">
			<Description><![CDATA["Right Sidelight"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_sidelight_WHole_width_right">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_sidelight_parapet_hgt_right">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_string_resources: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_string_resources">
			<Description><![CDATA["String Resources"]]></Description>
		</Title>
		<String Name="stBoardUI">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="20" SecondDimension="0">
				<AVal Row="1"><![CDATA["Доска"]]></AVal>
				<AVal Row="2"><![CDATA["Выступ Слева"]]></AVal>
				<AVal Row="3"><![CDATA["Выступ Справа"]]></AVal>
				<AVal Row="4"><![CDATA["Смещение под Коробку"]]></AVal>
				<AVal Row="5"><![CDATA["По Дуге Криволинейной Стены"]]></AVal>
				<AVal Row="6"><![CDATA["Покрытие"]]></AVal>
				<AVal Row="7"><![CDATA["Тип Штриховки"]]></AVal>
				<AVal Row="8"><![CDATA["Перо Штриховки"]]></AVal>
				<AVal Row="9"><![CDATA["Перо Фона"]]></AVal>
				<AVal Row="10"><![CDATA["Угол Доски"]]></AVal>
				<AVal Row="11"><![CDATA["Толщина Доски"]]></AVal>
				<AVal Row="12"><![CDATA["Выступ Доски"]]></AVal>
				<AVal Row="13"><![CDATA["В Многоугольных Стенах"]]></AVal>
				<AVal Row="14"><![CDATA["Ширина Доски"]]></AVal>
				<AVal Row="15"><![CDATA["Реквизиты Сечения"]]></AVal>
				<AVal Row="16"><![CDATA["Перо Контура"]]></AVal>
				<AVal Row="17"><![CDATA["Доска Боковой Панели 1"]]></AVal>
				<AVal Row="18"><![CDATA["Доска Боковой Панели 2"]]></AVal>
				<AVal Row="19"><![CDATA["Доска Боковой Панели"]]></AVal>
				<AVal Row="20"><![CDATA["Доска возможна только при наличии подоконной стенки."]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stSubTabpageToolTip">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Выбор Вкладки: Общие Параметры, Реквизиты"]]></Value>
		</String>

		<!-- gs_usa_parameters: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_usa_parameters">
			<Description><![CDATA["USA Parameters"]]></Description>
		</Title>
		<Length Name="bBoardElevUsa">
			<Description><![CDATA["Board Elevation (USA)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="bBoardNnosUsa">
			<Description><![CDATA["Negative Nosing at Rebate Width Lower (USA)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="frameWidthLeft">
			<Description><![CDATA["Frame Width at Left Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="frameWidthRight">
			<Description><![CDATA["Frame Width at Right Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Angle Name="gs_sill_angle">
			<Description><![CDATA["Sill Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Length Name="gs_rebw_lower">
			<Description><![CDATA["Rebate Width Lower"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="CasingInsLeftOutPoint">
			<Description><![CDATA[""]]></Description>
			<Value>0.1</Value>
		</Length>
		<Length Name="CasingInsRightOutPoint">
			<Description><![CDATA[""]]></Description>
			<Value>0.1</Value>
		</Length>
		<Integer Name="iBoardInPolyWall">
			<Description><![CDATA[""]]></Description>
			<Value>1</Value>
		</Integer>
		<String Name="stBoardInPolyWall">
			<Description><![CDATA[""]]></Description>
			<ArrayValues FirstDimension="1" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<Boolean Name="gs_trim_show_cover_in">
			<Description><![CDATA["Cover Inner Wall Surface"]]></Description>
			<Value>1</Value>
		</Boolean>
		<Angle Name="gs_reveal_bottom_angle">
			<Description><![CDATA["Cover Inner Wall Surface"]]></Description>
			<Value>20</Value>
		</Angle>
	</Parameters>
</ParamSection>

<CalledMacros SectVersion="2" SectionFlags="0" SubIdent="0">
	<Macro>
		<MName><![CDATA["SaveQueue"]]></MName>
		<MainGUID>94152DAD-3888-4DAC-AC2E-EB7988A1C356</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["LoadQueue"]]></MName>
		<MainGUID>76C49CD5-2439-4953-8829-5B7914C1A082</MainGUID>
	</Macro>
</CalledMacros>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="9" length_in_bytes="151" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7CCCCCC00
	00002932A82C000000394944415438CB636440022CB20C688011459A0FBFF420
	D6ED805F9A17CA60961FB2D206C3CC630EC335298EEA1ED53D5475BB20F3EEA2
	4B0300DBF9081C116A75E50000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="10" length_in_bytes="153" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7CCCCCC00
	00002932A82C0000003B4944415438CB631042070E0CC840111DA04A0F62DD2E
	E80055DA180A1C05A160C848C3FC33F45C4EA4C770C4D8B04DA9A3BA47750F51
	DD28D91500C65C76DAC806908F0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="11" length_in_bytes="183" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7000000CC
	CCCC324E5B7A000000594944415438CB63604002CC8AE88001455A081D3060D1
	6D8C00D8741B0A4281890B36DD38A529D30D710F4E698828B1D2E81E234DF7E0
	93C61963306DC22E504047696374404652A42C218FEA1ED53DAA1B45374A86C4
	D00D00CBF4636F78EDE9160000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="12" length_in_bytes="177" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7000000CC
	CCCC324E5B7A000000534944415438CB63104207060CC840111DA04A1B230036
	DD2ECE8250208C4D3792344D75431C88531A42A17B0CAF3401DD83581A29C6B0
	EA86024398217494364607A8D294A5D451DDA3BA4775535B374A760500278D6B
	B20088BB370000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="13" length_in_bytes="174" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7000000CC
	CCCC324E5B7A000000504944415438CB63604002CC8AE88001455A081D300C15
	DDC6E800555A100A845DA060B0491370B921CC101397A12A8DEE31886771EA86
	A4019CD290343090BA71C6D8D0CD44A3BA47BA6E942214433700618C64FECDF9
	D2DB0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="14" length_in_bytes="175" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7000000CC
	CCCC324E5B7A000000514944415438CB63104207060CC840111DA04A0F62DDC6
	E80055DA050A0C05A160F04823B919AB6E679836E121260DF30F61DD58630C21
	8D2DBE91A4B1A5169AEA468AB121964B46758FEAA640374A010B004EF26CBA8D
	487E8D0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="15" length_in_bytes="161" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7000000CC
	CCCC324E5B7A000000434944415438CB63604002CC8AE88001455A081D300C15
	DDC6E800555A100A84219489CBC0490F4AA71108351728A0A63481181BBA4971
	54F7A8EEA1AA1B254362E80600D99F60B152F107780000000049454E44AE4260
	82
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="16" length_in_bytes="162" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7000000CC
	CCCC324E5B7A000000444944415438CB63104207060CC840111DA04A0F62DDC6
	E80055DAC559100C0C05A1808ED2C6C603673741A741002EDD50401369023136
	6C53EAA8EE51DD4354374A760500D4FB6AA750E5C2D80000000049454E44AE42
	6082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="17" length_in_bytes="160" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7000000CC
	CCCC324E5B7A000000424944415438CB63604002CC8AE88001455A081D300C15
	DDC6E800555A100A845DA08026D204EC8650262E03273D989C4620C6866E521C
	D53DAA7BA8EA46C99018BA01FB8A60B1FEF652CB0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="18" length_in_bytes="162" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7000000CC
	CCCC324E5B7A000000444944415438CB63104207060CC840111DA04A0F62DDC6
	E80055DA050A0C05A1809AD2302B71E97686880E84B4B1F1C0D94DD06978636C
	D8A6D451DDA3BA87A86E94EC0A00BCC66AA71835E2660000000049454E44AE42
	6082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="19" length_in_bytes="153" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7000000CC
	CCCC324E5B7A0000003B4944415438CB63604002CC8AE88001455A081D300C15
	DDC6E800555A100A84219489CB50951E3E1E2310634337298EEA1ED53D5475A3
	64480CDD0027885C3132B29C390000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="20" length_in_bytes="155" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7000000CC
	CCCC324E5B7A0000003D4944415438CB63104207060CC840111DA04A0F62DDC6
	E80055DAC559100C0C05A160C8481B1B0F559713F418DE181BB6297554F7A8EE
	21AA1B25BB0200BEC46663AFD683240000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="21" length_in_bytes="175" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	00120806000000075ABD340000006C4944415478DAED93310AC0300C031DB763
	FFFFA5AE19FA1F970CA1940CC1388488E8C0188416212441ACF0E41BE64B10A8
	B00536CC86FF9CBB34ACDC3037BC49C370074472F80000096283BC2A80585FC3
	C7EA6FC37DFAA4F0D7C4D0FD63C37ED2CA1BD646AB3A0973888317D960673AC1
	F78BE50000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="22" length_in_bytes="178" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	00120806000000075ABD340000006F4944415478DAED94310E8020100417B4F4
	FF5FB2B5F03F2B8585959023EA1DEE2417124233991C6061DF56463901103D44
	922D740BABB00AFB2F3CFFB570D60E6B87CFC8E1E64192E15D6C246C2757D6AA
	156230E8417279499237C21CAD309BC6094985ED9F19AFF75F4B4E08CE01889B
	673AA1C886F60000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="25" length_in_bytes="148" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7000000CC
	CCCC324E5B7A000000364944415438CB63644002CC720C688011459A1FBFF420
	D66D805F9A0FCA60321CB2D20AC3CC63064336AD8DEA1ED53D4C751B33E00300
	989207D6CBFA657F0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="26" length_in_bytes="153" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7000000CC
	CCCC324E5B7A0000003B4944415438CB63104207060CC840111DA04A0F62DDC6
	E80055DA050A0C05A160C848C3FC33F45C4EA4C770C4D8B04DA9A3BA47750FD1
	32150500006CAC76C5555F9E440000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="27" length_in_bytes="179" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7000000CC
	CCCC324E5B7A000000554944415438CB63604002CC8AE88001455A081D3060D1
	6D8C00D8741B0A4281890B36DD38A529D30D710F4E698828B1D2E81E234DF7E0
	93C61963306DC22E504047696374C040F5943AAA7B54F7A86E52741BE30500AE
	FA65A09D2AAC7B0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="28" length_in_bytes="177" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7000000CC
	CCCC324E5B7A000000534944415438CB63104207060CC840111DA04A1B230036
	DD2ECE8250208C4D3792344D75431C88531A42A17B0CAF3401DD83581A29C6B0
	EA86024398217494364607A8D294A5D451DDA3BA477553A8DB182F000041D96C
	E46EC37B8B0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="29" length_in_bytes="172" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7000000CC
	CCCC324E5B7A0000004E4944415438CB63604002CC8AE88001455A081D300C15
	DDC6E800555A100A845DA060B0491370B921CC101397A12A8DEE31886771EA86
	A4019CD290343090BA71C6D8D0CD44A3BA47BA6E63BC00006C4E66302375DB59
	0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="30" length_in_bytes="174" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7000000CC
	CCCC324E5B7A000000504944415438CB63104207060CC840111DA04A0F62DDC6
	E80055DA050A0C05A160F04823B919AB6E679836E121260DF30F61DD58630C21
	8D2D392049634B0E34D58D1463C32B138DEA1ED58DAF4C45010012846EEB18DD
	E79E0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="31" length_in_bytes="159" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7000000CC
	CCCC324E5B7A000000414944415438CB63604002CC8AE88001455A081D300C15
	DDC6E800555A100A84219489CBC0490F4AA71108351728A0A63481181BB62975
	54F7A8EE41ABDB182F0000BCA562E2C95E7AAB0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="32" length_in_bytes="161" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7000000CC
	CCCC324E5B7A000000434944415438CB63104207060CC840111DA04A0F62DDC6
	E80055DAC559100C0C05A1808ED2C6C603673741A741002EDD50401369023136
	6C53EAA8EE51DD43B44C450100EF476BD95E3A65D70000000049454E44AE4260
	82
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="33" length_in_bytes="158" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7000000CC
	CCCC324E5B7A000000404944415438CB63604002CC8AE88001455A081D300C15
	DDC6E800555A100A845DA08026D204EC8650262E03273D989C4620C6866D4A1D
	D53DAA7BD0EA36C60B00DE9062E262D5A7780000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="34" length_in_bytes="161" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7000000CC
	CCCC324E5B7A000000434944415438CB63104207060CC840111DA04A0F62DDC6
	E80055DA050A0C05A1809AD2302B71E97686880E84B4B1F1C0D94DD06978636C
	D8A6D451DDA3BA8768998A0200D7126BD9B01D2B550000000049454E44AE4260
	82
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="35" length_in_bytes="151" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7000000CC
	CCCC324E5B7A000000394944415438CB63604002CC8AE88001455A081D300C15
	DDC6E800555A100A84219489CB50951E3E1E231063C336A58EEA1ED53D68751B
	E305000A8E5E62555A6FC40000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="36" length_in_bytes="154" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	003404030000002481462C0000000F504C5445A0A0A0FFFFFFD4D0C7000000CC
	CCCC324E5B7A0000003C4944415438CB63104207060CC840111DA04A0F62DDC6
	E80055DAC559100C0C05A160C8481B1B0F559713F418DE181BB6297554F7A8EE
	215AA6A20000D910679566AFB65F0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="37" length_in_bytes="145" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000005E0000
	00250203000000B659B6FF0000000C504C5445FFFFFFD4D0C7CCCCCC000000C8
	944FCA000000364944415428CF63100402E155AB560391201230607001027788
	840B12286018D531AA6328E8F80F06587430800033161D1089C1A30300ECAEEC
	5D1AA00F050000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="38" length_in_bytes="175" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000005E0000
	00250203000000B659B6FF0000000C504C5445FFFFFFD4D0C7CCCCCC000000C8
	944FCA000000544944415428CF6370F15BB56A1D18AD764102050C8272700941
	2460C0304875F8FF07817F983A641840800F53870F5C6254C7B0D4C10F4C1058
	75F030303063D50192A09D0E797012FD83A90308DCC19A50750000D08ACFB814
	B718C90000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="39" length_in_bytes="170" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000005E0000
	00250203000000B659B6FF0000000C504C5445FFFFFFD4D0C7CCCCCC000000C8
	944FCA0000004F4944415428CF63100402E155AB56BD02A3232E5050C00022DD
	E1121705A1C0806170EBF80F0658741C6000012C3A2012A33A869B0E6032C0AE
	0328845D075C82B63A2049148B0E06066617245000001985F9D8F22595F40000
	000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="40" length_in_bytes="160" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000005E0000
	00250203000000B659B6FF0000000C504C5445FFFFFFD4D0C7CCCCCC000000C8
	944FCA000000454944415428CF63100402E155AB5EADDAB55A10091830B80081
	3B44C2050914300C621DFF81E017361D0C4060854D07446254C730D4F11F0C70
	E86060C6610703F3E0D1010074A2B28438A166DB0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="41" length_in_bytes="161" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000005E0000
	00250203000000B659B6FF0000000C504C5445FFFFFFD4D0C7CCCCCC000000C8
	944FCA000000464944415428CF63100402E155BB56AD5BB55A10091830B80081
	3B44C2050914300C661DFBFF0301361D1B18181898B1E9004B8CEA18863AFE83
	01161D0C0C38744024068F0E00B6FCB9C8CB0B70520000000049454E44AE4260
	82
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="42" length_in_bytes="148" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000005E0000
	00250203000000B659B6FF0000000C504C5445FFFFFFD4D0C7CCCCCC000000C8
	944FCA000000394944415428CF63100402E155AB560391201230607001027788
	840B12286018C43AFE8301161D0C20C08C4507446254C730D401490C43D91F00
	437F9EBDC1FAEE4F0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="43" length_in_bytes="211" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000005E0000
	00550203000000BD7BBB3E0000000C504C5445000000A0A0A0D4D0C7FFFFFFD7
	D550550000007849444154785EEDCEC10980301044D145FBB1010F6A0901EDC7
	B2845C5290841420E8AA73086C02014110F75F8707439E5BF7B3CD4739B2DC72
	0F366AFEB020AE15024393121D9410182821AE02A31A420C9510C811841C8440
	01420ECF049535A5EB4B86F115A142850A9313434E505C9130D9BBBF18541C26
	0695416089C3130000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="44" length_in_bytes="224" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000001F0000
	004C0803000000A26A9C5200000009504C5445FF0000000000FFFFFFCA92C399
	0000000174524E530040E6D8660000007B4944415478DAEDD2C10AC320144451
	4FFFFFA34B376942C90C09362BAF2E84F1EA7BE2D8F099018CDB3903A23E22CA
	0EF90CE516A50EB952A517A55BE53DC41773CAD78FA0C48C84109D8EC05315F7
	DC91CBF96BCFB41C241F37EBB78D3F60F9D37DF970762BBFF181E25FBA7FFD9F
	E53FEA6B72FFFFD59FDDDC1B29A201677E9A31300000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="45" length_in_bytes="147" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000005E0000
	00550203000000BD7BBB3E0000000C504C5445A0A0A0FFFFFFD4D0C700000003
	C88455000000384944415448C763480382F45010084F4302050C338160364462
	2612D8C030AA63E4E9F88F1D7C60C0010C4625462546254625462546900400C3
	5D164F3FCEE21F0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="46" length_in_bytes="184" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000005E0000
	00550203000000BD7BBB3E0000000C504C5445000000A0A0A0D4D0C7FFFFFFD7
	D550550000005D4944415448C7637807046FFE83C09F7748E000C36E20D80191
	D88D041A1886AE0E061480A40355024987FD7F04F880AC03556218EA60200E84
	62070EC448848CEA18D531AA832E3A0271E970C4A503573EC7AD239054E78E4A
	0C2F0900E5359CFAFA9A99490000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="47" length_in_bytes="228" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000001F0000
	004C0203000000E8DA84F300000009504C5445FF0000000000FFFFFFCA92C399
	0000000174524E530040E6D8660000007F49444154785ECD90310AC3300C459F
	40DE13A8EFE3A1DD352437CB297CCA42252130ED5228F44F8F27998F0C6C034F
	6781D67364441E092394D012B080500A58424BC01C5C9DAF18E85ACEE9E531F2
	DD63DF37071830E7BC100B684700E30BA8E7625551A56FA33F368AB8B821F7FC
	042B933B9FA37F6A24C47A5719D6BB9E98C52CEB8D3F822A0000000049454E44
	AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="48" length_in_bytes="481" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000007D0000
	0055080300000053A11B4C0000000F504C5445FF0000ADADAD000000FFFFFFDE
	D6CE0F47327A0000000174524E530040E6D866000001764944415478DAEDD4D1
	6AC330104451F5DAFFFFCD3528EDE04AD9C55D56FB108D21E421E170AD38ED38
	878B633E8EF3E1457336F9D25BFD7CCA7BFA6EDFED7E3BA5ED50D80E50DB0ED4
	9E3B54FDE63B0CB5CF3B14B4A34F414DBBFAD7B6FFE5A0A65DFDB5FFF3B0A89D
	79292C6907C0E84F6EB7FAF3DBFBABD19FDAEE9D7F7EBBDD9FDDEEF5E7B6FBFD
	B9ED7E7F4ABB78B73FD06E4CBED7FFCF76BEDE8F67FDAE6EE3E31EF5BBBA81C7
	FB5DDEC0E3FD34C737F078FF45DBBE81C7FB2FD8F60D3CD0AF76DB37F040BFDA
	6DDFC0A3FD6A97CF5D37F078FFDD627C040C3CE6AB5D03EEBE8147FDA17D3C7E
	E109FEDD9A9CBBF014BFD9139EED33D18557F40B4FF699E9C297F5A3B7C2F3FD
	51D7B792FD1F1500E92B7CD0D90B979EEBFF820C773EDF0789D0D275F94A172F
	3D9BA7A76BB455FA65C1802FD3AFD5E90285AFD38516EA62696B758D125D8356
	A18BAFD44BDBA96AA7E3F081779E3A5D2B6D6FBB7DB7EFF6541DD1EB75BA4E49
	BB56DAFE89E7FEDAD6B7DEB46FB0843F240EC0E9C20000000049454E44AE4260
	82
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="51" length_in_bytes="481" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000000E0000
	000E08060000001F482DD100000006624B474400FF00FF00FFA0BDA793000001
	8C494441542891AD91CB4B025114C6BF3B332A6333A989540699653E02C17C5D
	14A345F470DDAAD7BF5021FD03B54DD761D0B65AB56ED92208DA852DA25D51B9
	7282B0521CEF6D110E65136D3ACB73CEC7EF7CE703FEBBE8746A3F359D3E0140
	CCE6A2593318CBA6643B2B3914362A28BE8A567DB8EDDE11CC84BDAABEBBB1A4
	D9B7D66A8AC3CE8A66D41FC2709C262481A7FAFB7462B332B89C6C3098A4F9BF
	AC2139953E3BDC1F63514A7994527E7AECE3F15CFAA69BFA8DD8A12DCEBC9066
	8BA0D92298CBBCC2A5B68742F1CCFCAF42A58797D65734D96AE1468F10A0B056
	53547BBB682AFC4A038044A48144A4010058C8D6A1AAEDE1F1249DEDEC1B718C
	04868E3657B5402CD42000E071E9484EBCC3E76D8110C0ED60B68B2B3956BD7F
	DA3388DD340028940650280D18A7E573752832F30727333306D11FF41E6C2C6B
	E10E0D00C2234DCC67EBF0795B9F9E08E07632CBE5B51C7ABC7B3C9000401048
	75A7EC11B6CB9E6FD14822D74509BA6C650D9B155C12191345FE86EE6CCC2A40
	69AFFC66317E51A99C3F03C007C40F77771DFF36FB0000000049454E44AE4260
	82
	]]>
</GDLPict>

<Copyright SectVersion="1" SectionFlags="0" SubIdent="0">
	<Author>GRAPHISOFT</Author>
	<License>
		<Type>CC BY-ND</Type>
		<Version>3.0</Version>
	</License>
</Copyright>

</Symbol>
