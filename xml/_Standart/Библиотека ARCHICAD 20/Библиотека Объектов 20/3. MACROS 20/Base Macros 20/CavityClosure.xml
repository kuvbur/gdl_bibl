<?xml version="1.0" encoding="UTF-8"?>
<Symbol IsArchivable="false" IsPlaceable="false" MainGUID="CAFB07D3-6F9E-4D30-9E4C-49ADBB81C772" MigrationValue="Normal" Owner="0" Signature="1465080141" Version="43">
<Ancestry SectVersion="1" SectionFlags="0" SubIdent="0" Template="false">
	<MainGUID>F938E33A-329D-4A36-BE3E-85E126820996</MainGUID>
	<MainGUID>103E8D2C-8230-42E1-9597-46F84CCE28C0</MainGUID>
	<MainGUID>6ACDA889-69B2-4EC5-936C-CB1DA7032A92</MainGUID>
	<MainGUID>F6AE9687-2BC7-4D47-88C9-8F793E1DE2D6</MainGUID>
</Ancestry>

<CalledMacros SectVersion="2" SectionFlags="0" SubIdent="0">
	<Macro>
		<MName><![CDATA["SaveQueue"]]></MName>
		<MainGUID>94152DAD-3888-4DAC-AC2E-EB7988A1C356</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["LoadQueue"]]></MName>
		<MainGUID>76C49CD5-2439-4953-8829-5B7914C1A082</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["WallContourDivider"]]></MName>
		<MainGUID>39C131DF-CC37-40EA-ACB5-BAF01DE1FDB6</MainGUID>
	</Macro>
</CalledMacros>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_3D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
if GLOB_CONTEXT = 6 | GLOB_CONTEXT = 46 then end
if iWindowShape <> SHAPE_RECTANGULAR then end

! ==============================================================================
! Cavity Closure
! ==============================================================================

dim skinCummThkRef[]	! Cummulative skin thickness from the Outside Face (8 +1 skins))
dim skinCummThkOpp[]	! Cummulative skin thickness from the Inside Face (8 + 1 skins)

cumRefThk = 0
cumOppThk = 0

if bCompositeWall then
	for i=1 to WALL_SKINS_NUMBER
		idx = i: gosub 10	! Get proper index

		cumRefThk = cumRefThk + WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
		skinCummThkRef[idx] = cumRefThk

		idx = WALL_SKINS_NUMBER + 1 - idx	! reorder
		cumOppThk = cumOppThk + WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
		skinCummThkOpp[idx] = cumOppThk
	next i
endif

! ==============================================================================

if bCompositeWall then

	if curvedWall then
		if WIDO_REVEAL_SIDE then
			mulz -1
			addz -WIDO_FRAME_THICKNESS
		endif
		addz WOD
	else
		if WIDO_REVEAL_SIDE then addz WIDO_FRAME_THICKNESS
		if SYMB_ROTANGLE > EPS then mulz -1
		if wallIsLeft then
			addz WIDO_SILL
		else
			addz WALL_THICKNESS - WIDO_SILL
		endif
		if reorder then
			mulz -1
			addz WALL_THICKNESS
		endif
	endif
	mulz -1

	if bCavityCloserBottom | iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then

		revealWidth		= gs_reveal_bottom
		revealAngle		= gs_reveal_bottom_angle
		revealSillAngle	= gs_reveal_outerBottom_angle

		addy -gs_lower_oversize
		if	(iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) &\
			(bCavityCloserBottom | gs_cc_dutch_ShowBottom) & not(gs_stack_bottom) then

			gs_showJoint = gs_cc_dutch_ShowBottom
			bSlantedJointTop = 0
			gosub 2000													! Variable Closure
		endif
		del 1
	endif
	if bCavityCloserTop | iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then

		revealWidth		= gs_reveal_top
		revealAngle		= gs_reveal_top_angle
		revealSillAngle	= gs_reveal_outerTop_angle

		addy B + gs_upper_oversize
		muly -1
		if	(iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) &\
			(bCavityCloserTop | gs_cc_dutch_ShowTop) & not(gs_stack_top) then

			gs_showJoint = gs_cc_dutch_ShowTop
			bSlantedJointTop = not(curvedWall)
			gosub 2000													! Variable Closure
		endif
		del 2
	endif

endif

end

! ==============================================================================
! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
! ==============================================================================


2000:
	if iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
		thkJoint = gs_cc_dutch_thkJoint
	else
		thkJoint = gs_thkJoint
	endif

	nSkins = WALL_SKINS_NUMBER - possibleSkinTurnOut - possibleSkinTurnIn
	if nSkins < 3 then return

	if iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
		signTurnDir = (gs_cc_dutch_ClosureToSide = 2) - not(gs_cc_dutch_ClosureToSide = 2)

		if gs_cc_dutch_ClosureToSide = 2 then
			idx = WALL_SKINS_NUMBER - possibleSkinTurnOut - gs_cc_dutch_ClosureToSkin: gosub 10	! Get proper index
			idx = max(idx, 1)
			idx = min(idx, WALL_SKINS_NUMBER + 1)
			baseSkinLevel = skinCummThkRef[idx]

			idx = WALL_SKINS_NUMBER - possibleSkinTurnOut:	gosub 10	! Get proper index
			idx = max(idx, 1)
			idx = min(idx, WALL_SKINS_NUMBER)
			baseSkinIdx = idx
		else
			idx = possibleSkinTurnIn + gs_cc_dutch_ClosureToSkin: gosub 10	! Get proper index
			idx = max(idx, 1)
			idx = min(idx, WALL_SKINS_NUMBER + 1)
			baseSkinIdx = idx
			baseSkinLevel = skinCummThkRef[baseSkinIdx]
		endif
	endif

	offsetFromJoint = ((iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) & not(gs_cc_dutch_TurnToClosure)) * gs_cc_dutch_TurnToClosureOffs
	if iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
		signTurnDir2 = (gs_bTurnDir) - not(gs_bTurnDir)
		if (gs_cc_dutch_ClosureToSide = 2) exor gs_bTurnDir then
			lengthSkinTurnIn = baseSkinLevel - signTurnDir2 * gs_bJoint * (offsetFromJoint)
		else
			lengthSkinTurnIn = baseSkinLevel - signTurnDir2 * gs_bJoint * (thkJoint + offsetFromJoint)
		endif
	else
		lengthSkinTurnIn = baseSkinLevel - signTurnDir * gs_bJoint * (thkJoint + offsetFromJoint)
	endif

!!!	idx = nSkinTurnIn + gs_nTurn: gosub 10	! Get proper index
	if gs_bTurnDir then
		idx = possibleSkinTurnIn + gs_nTurn: gosub 10	! Get proper index
		if idx > 0 then
			level_1 = skinCummThkRef[idx]
		else
			level_1 = 0
		endif
	else
		idx = WALL_SKINS_NUMBER - possibleSkinTurnOut - gs_nTurn: gosub 10	! Get proper index
		level_1 = skinCummThkRef[idx]
	endif

!!!	idx = nSkinTurnIn: gosub 10	! Get proper index
	if gs_bTurnDir then
		idx = possibleSkinTurnIn: gosub 10	! Get proper index
		if idx > 0 then
			level_2 = skinCummThkRef[idx]
		else
			level_2 = 0
		endif
	else
		idx = WALL_SKINS_NUMBER - possibleSkinTurnOut: gosub 10	! Get proper index
		level_2 = skinCummThkRef[idx]
	endif

	summThicknessOfTurnedSkins = abs(level_1 - level_2)

	dx = 0
	bCuttedPlug = 0
	bNegativeTurn = 0

	vectS = -sin(revealAngle) * signWallIsLeft
	vectC =  cos(revealAngle)

	if bFirstSkinAtReveal exor not(gs_bTurnDir) then
		if iRevealType = REVEAL_POSITIVE then dx = -revealWidth
		if iRevealType = REVEAL_NEGATIVE then dx = -revealWidth
		if iRevealType = REVEAL_SLANTED  then dx = -revealWidth

		if not(curvedWall) then
			slantX = 0
			vectS = 0
			vectC = 1
		endif

		bCuttedPlug		= 0
		plugLeftDx		= 0
		plugOnWindow	= 0		! GER request

		bIncludeReveal	= 0

		if iRevealType <> REVEAL_NEGATIVE & revealWidth + EPS >= summThicknessOfTurnedSkins & summThicknessOfTurnedSkins + (thkJoint + offsetFromJoint) < WIDO_SILL then
			! note: summThicknessOfTurnedSkins equals the summ width of the turned skins

			if gs_bTurnDir then
				baseSkinLevel = WIDO_SILL
				lengthSkinTurnIn = baseSkinLevel - gs_bJoint * (thkJoint + offsetFromJoint)
			else
				baseSkinLevel = WALL_THICKNESS - WIDO_SILL
				lengthSkinTurnIn = baseSkinLevel + gs_bJoint * (thkJoint + offsetFromJoint)
			endif
			plugOnWindow = 1
		else
			if iRevealType = REVEAL_NEGATIVE & not(iClosureType	= CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) then
				plugLeftDx = 0

				if gs_bTurnDir then
					if baseSkinLevel - EPS > WIDO_SILL then
						bCuttedPlug = 1
					endif
				else
					if baseSkinLevel - EPS < WALL_THICKNESS - WIDO_SILL then
						bCuttedPlug = 1
					endif
				endif
			else
				if gs_bTurnDir then
					if lengthSkinTurnIn - EPS >= WIDO_SILL then
						if lengthSkinTurnIn < WIDO_SILL + EPS then
							plugLeftDx = revealWidth
						else
							bIncludeReveal = 1
							if bSlantedInnerSide then
								if iRevealType = REVEAL_SLANTED then slantDy = lengthSkinTurnIn - WIDO_SILL
								if iRevealType = REVEAL_SPLAYED then slantDy = lengthSkinTurnIn - WIDO_SILL - WIDO_FRAME_THICKNESS
								dx = slantDy * tan(revealAngle)
							else
								dx = 0
							endif
						endif
					else
						bCuttedPlug = 1
					endif
				else
					if lengthSkinTurnIn + EPS <= WALL_THICKNESS - WIDO_SILL then
						if lengthSkinTurnIn > WALL_THICKNESS - WIDO_SILL + EPS then
							plugLeftDx = revealWidth
						else
							bIncludeReveal = 1
							if bSlantedInnerSide then
								if iRevealType = REVEAL_SLANTED then slantDy = WALL_THICKNESS - lengthSkinTurnIn - WIDO_SILL
								if iRevealType = REVEAL_SPLAYED then slantDy = WALL_THICKNESS - lengthSkinTurnIn - WIDO_SILL - WIDO_FRAME_THICKNESS
								dx = slantDy * tan(revealAngle)
							else
								dx = 0
							endif
						endif
					else
						bCuttedPlug = 1
					endif
				endif
			endif
		endif
		if WIDO_SILL < EPS & (iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE) then
			bIncludeReveal = 0
		endif
	else

		if iRevealType = REVEAL_NEGATIVE then
			if gs_bTurnDir then
				if baseSkinLevel + EPS >= WALL_THICKNESS - WIDO_SILL & WIDO_SILL < WALL_THICKNESS then
					bIncludeReveal = 1
				endif
			else
				if baseSkinLevel + EPS <= WIDO_SILL & WIDO_SILL < WALL_THICKNESS then
					bIncludeReveal = 1
				endif
			endif
		else
			if gs_bTurnDir then
				if curvedWall & not(bWndCurved) then
					if wallIsLeft then
						sLevel = sqr(bx^2 + (by + WOD)^2) - radBoard
					else
						sLevel = WALL_THICKNESS - sqr(bx^2 + (by + WOD)^2) + radSill
					endif

					if baseSkinLevel - EPS >= sLevel then
						bCuttedPlug = 1
						plugLeftDx = -revealWidth
					endif
				else
					if baseSkinLevel + EPS > WALL_THICKNESS - WIDO_SILL then
						bCuttedPlug = 1
						plugLeftDx = -revealWidth
					endif
				endif
			else
				if curvedWall & not(bWndCurved) then
					if wallIsLeft then
						sLevel = radSill - sqr(bx^2 + (by + WOD)^2)
					else
						sLevel = sqr(bx^2 + (by + WOD)^2) - radSill
					endif

					if baseSkinLevel + EPS <= sLevel then
						bCuttedPlug = 1
						plugLeftDx = -revealWidth
					endif
				else
					if baseSkinLevel + EPS < WIDO_SILL then
						bCuttedPlug = 1
						plugLeftDx = -revealWidth
					endif
				endif
			endif
		endif

		if iRevealType = REVEAL_NEGATIVE then
			if gs_bTurnDir then
				if WALL_THICKNESS - WIDO_SILL < baseSkinLevel + EPS then
					dx = -revealWidth
				endif
			else
				if WIDO_SILL > baseSkinLevel + EPS then
					dx = -revealWidth
				endif
			endif
			bNegativeTurn = 1
		endif
		if iRevealType = REVEAL_SLANTED then slantLength = WALL_THICKNESS - WIDO_SILL
		if iRevealType = REVEAL_SPLAYED then slantLength = WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS

		if not(curvedWall) then
			if bSlantedInnerSide then
				slantX = tan(revealAngle)
				vectS = -sin(revealAngle) * signWallIsLeft
				vectC =  cos(revealAngle)
			else
				slantX = 0
				vectS = 0
				vectC = 1
			endif
		endif
	endif

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		bCuttedPlug		= 0
		bIncludeReveal	= 0
	endif

	if iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
		bCuttedPlug	= 0
		plugLeftDx	= 0

		dx = 0
		if bFirstSkinAtReveal then
			if	iRevealType = REVEAL_POSITIVE | \
				iRevealType = REVEAL_SLANTED then
				refLevelForDxTest = baseSkinLevel + (gs_cc_dutch_ClosureToSide = 1) * thkJoint
				if WIDO_SILL > refLevelForDxTest - EPS then
					dx = -revealWidth
				endif
			endif
			if iRevealType = REVEAL_NEGATIVE then
				refLevelForDxTest = baseSkinLevel - (gs_cc_dutch_ClosureToSide = 2) * thkJoint
				if WIDO_SILL > refLevelForDxTest + EPS then
					dx = -revealWidth
				endif
			endif
		else
			if	iRevealType = REVEAL_POSITIVE | \
				iRevealType = REVEAL_SLANTED then
				refLevelForDxTest = baseSkinLevel - (gs_cc_dutch_ClosureToSide = 2) * thkJoint
				if WALL_THICKNESS - WIDO_SILL < refLevelForDxTest + EPS then
					dx = -revealWidth
				endif
			endif
			if iRevealType = REVEAL_NEGATIVE then
				refLevelForDxTest = baseSkinLevel + (gs_cc_dutch_ClosureToSide = 1) * thkJoint
				if WALL_THICKNESS - WIDO_SILL < refLevelForDxTest - EPS then
					dx = -revealWidth
				endif
			endif
		endif
	endif

	if gs_bJoint then

		if iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
			widthJoint = gs_cc_dutch_widthJoint
		else
			widthJoint = summThicknessOfTurnedSkins
		endif

! Draw Insulation Strip ========================================================

		if GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY & not(iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) then
			gs_showJoint = 0
		endif

		if gs_showJoint then

			if AC_HoleSideMaterial then
				if (baseSkinLevel < WALL_THICKNESS - WIDO_SILL) exor WIDO_REVEAL_SIDE then
					matWallSide = WALL_MAT_A
				else
					matWallSide = WALL_MAT_B
				endif
			else
				matWallSide = WALL_MAT_EDGE
			endif

			if gs_cc_dutch_matJointCustom then
				matSpouwlat = gs_cc_dutch_matJoint
			else
				matSpouwlat = matWallSide
			endif
			bShowEdges = (matWallSide <> matSpouwlat)

			if GLOB_CONTEXT = 3 | GLOB_CONTEXT = 23 then
				pen WALL_VIEW_PEN
			else
				pen gs_penJoint
			endif

! Closure is always placed to inside face of the wall at Dutch Closure =========

			offsetToJoint = 0
			if iClosureType = CLOSURE_DUTCH_VARIABLE then

				offsetToJoint = offsetFromJoint * not(gs_cc_dutch_TurnToClosure)

				if curvedWall & reorder then
					offsetToJoint = -offsetToJoint
				endif
			endif

! End of closure moving to inside face of the wall =============================

			if not(curvedWall) then
				slantedTopDiff = min(widthJoint, bSlantedJointTop * thkJoint * tan(10))
				if (gs_cc_dutch_ClosureToSide = 2 exor (wallIsLeft & not(bInclinedWall)) exor reorder) exor (wallIsLeft & bInclinedWall) then
					slantedTopDiff1 = slantedTopDiff
					slantedTopDiff2 = 0
				else
					slantedTopDiff1 = 0
					slantedTopDiff2 = slantedTopDiff
				endif

				material matSpouwlat
				sect_attrs gs_fillJoint, gs_penJointBg, gs_penJointFg, gs_penJoint, gs_ltJoint

				add 0, -dx, baseSkinLevel + offsetToJoint
				roty 90
				rotz 90
				addz -A/2
				prism_ 4,A,
					 0,								 0,							13 + 2 * bShowEdges,
					 0,								-signTurnDir * thkJoint,	13 + 2 * bShowEdges,
					-widthJoint + slantedTopDiff2,	-signTurnDir * thkJoint,	15,
					-widthJoint + slantedTopDiff1,	 0,							15

				material matWallSide
				wallniche 4, 1, 2,
					0,0,1, A,
					 0,								 0,							29,
					 0,								-signTurnDir * thkJoint,	29,
					-widthJoint + slantedTopDiff2,	-signTurnDir * thkJoint,	31,
					-widthJoint + slantedTopDiff1,	 0,							31
				del 4

			else

				offsArc = iHolePosSign * AC_Hole_Position_Angle / 180 * PI * rBoard
				resol WALL_RESOL

				bCondition = WIDO_REVEAL_SIDE exor SYMB_MIRRORED
				signCondition = (not(bCondition) - bCondition)
				roty signCondition * abs(AC_Hole_Position_Angle) + not(wallIsLeft) * 180

				if reorder exor wallIsLeft then
					rBaseSkinLevel = radSill - signReorder * baseSkinLevel
				else
					rBaseSkinLevel = radBoard - signReorder * baseSkinLevel
				endif
				rBaseSkinLevel = rBaseSkinLevel - offsetToJoint

				offsArc = signWallIsLeft * AC_Hole_Position_Angle / 180 * PI * rBaseSkinLevel

				sideLeft	= leftAlfa  / 180 * PI * rBaseSkinLevel
				sideRight	= rightAlfa / 180 * PI * rBaseSkinLevel

				addz rBaseSkinLevel

				sect_attrs gs_fillJoint, gs_penJointBg, gs_penJointFg, gs_penJoint, gs_ltJoint
				bprism_ matSpouwlat,matSpouwlat,matSpouwlat,
					4,signTurnDir * signReorder * thkJoint, rBaseSkinLevel,
					offsArc - signWallIsLeft * sideLeft,	 0,			 13 + 2 * bShowEdges,
					offsArc - signWallIsLeft * sideLeft,	-widthJoint, 15,
					offsArc + signWallIsLeft * sideRight,	-widthJoint, 15,
					offsArc + signWallIsLeft * sideRight,	 0,			 8 + 7 * bShowEdges

				del 2

				alfaEnd		= -leftAlfa
				alfaStart	= rightAlfa
				arcRadius	= rBaseSkinLevel
				bMiddlePoints = 1
				firstStatus	= 15
				midStatus	= 15
				lastStatus	= 15
				gosub 100

				alfaEnd		= rightAlfa
				alfaStart	= -leftAlfa
				arcRadius	= rBaseSkinLevel + signTurnDir * signReorder * thkJoint
				bMiddlePoints = 1
				firstStatus	= 14
				midStatus	= 14
				lastStatus	= 14
				gosub 100

				addz WOD
				rotx -90

				material matWallSide
				if nsp >= 12 then
					wallniche nsp/3, 1, 2,
						0,0,1, -widthJoint,
						get(nsp)
				else
					for i=1 to nsp
						n = get(1)
					next i
				endif

				del 2

			endif
		endif
	endif

return


! ==============================================================================
! Arch Segmentation
! ------------------------------------------------------------------------------
! Input parameters:
!	alfaStart:		Start angle (angle)
!	alfaEnd:		End angle (angle)
!	arcRadius:		Arc radius (length)
!	bMiddlePoints:	Generate middle points (0 / 1)
!	firstStatus:	Status of the first segment (integer)
!	midStatus:		Status of the middle segments (integer)
!	lastStatus:		Status of the last segment (integer)
! ==============================================================================

100:
	if not(wallIsLeft) then
		alfaStart = 180 - alfaStart
		alfaEnd = 180 - alfaEnd
	endif
	segmentAngle = 360 / WALL_RESOL


	! --- Point at Start Angle ---
	if WIDO_REVEAL_SIDE then
		if SYMB_ROTANGLE < EPS then
			difAngle = (AC_Hole_Position_Angle + alfaStart) mod segmentAngle
		else
			difAngle = -(AC_Hole_Position_Angle - 180 - alfaStart) mod segmentAngle
		endif
	else
		if SYMB_ROTANGLE < EPS then
			difAngle = -(AC_Hole_Position_Angle - alfaStart + 180) mod segmentAngle
		else
			difAngle = (AC_Hole_Position_Angle + alfaStart) mod segmentAngle
		endif
	endif

	difAngle2 = difAngle
	if abs(difAngle) > segmentAngle / 2 then difAngle = -segmentAngle / 2 + abs(difAngle mod (segmentAngle / 2))

	segmentR = arcRadius / cos(difAngle)
	put segmentR * sin(alfaStart), -segmentR * cos(alfaStart) + WOD, firstStatus

	if bMiddlePoints then
		! --- Middle Points ---
		segmentR = arcRadius / cos(segmentAngle / 2)

		if alfaStart > alfaEnd then
			alfaActual = alfaStart - difAngle2 + segmentAngle / 2

			if alfaActual > alfaStart then alfaActual = alfaActual - segmentAngle
			if alfaActual > alfaStart then alfaActual = alfaActual - segmentAngle

			if alfaActual < alfaEnd then alfaActual = alfaActual + segmentAngle

			if alfaActual < alfaStart & alfaActual > alfaEnd then
				do
					put segmentR * sin(alfaActual), -segmentR * cos(alfaActual) + WOD, midStatus + 64

					alfaActual = alfaActual - segmentAngle

				while alfaActual > alfaEnd
			endif
		else
			alfaActual = alfaStart - difAngle2 + segmentAngle / 2

			if alfaActual < alfaStart then alfaActual = alfaActual + segmentAngle
			if alfaActual > alfaEnd then alfaActual = alfaActual - segmentAngle

			if alfaActual > alfaStart & alfaActual < alfaEnd then
				do
					put segmentR * sin(alfaActual), -segmentR * cos(alfaActual) + WOD, midStatus + 64

					alfaActual = alfaActual + segmentAngle
				while alfaActual < alfaEnd
			endif
		endif
	endif


	! --- Point at End Angle ---
	if WIDO_REVEAL_SIDE then
		if SYMB_ROTANGLE < EPS then
			difAngle = (AC_Hole_Position_Angle + alfaEnd) mod segmentAngle
		else
			difAngle = -(AC_Hole_Position_Angle + 180 - alfaEnd) mod segmentAngle
		endif
	else
		if SYMB_ROTANGLE < EPS then
			difAngle = -(AC_Hole_Position_Angle - alfaEnd + 180) mod segmentAngle
		else
			difAngle = (AC_Hole_Position_Angle + alfaEnd) mod segmentAngle
		endif
	endif

	if abs(difAngle) > segmentAngle / 2 then difAngle = -segmentAngle / 2 + abs(difAngle mod (segmentAngle / 2))

	segmentR = arcRadius / cos(difAngle)
	put segmentR * sin(alfaEnd), -segmentR * cos(alfaEnd) + WOD, lastStatus

return


]]>
</Script_3D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_2D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! Contact person: <NJ>

! ==============================================================================
! This macro draws the cavity closure and turned plasters
! ------------------------------------------------------------------------------
! Input parameters:
!	refWidth:				reference width in curved walls (length)
!	leftWidth:				wallhole's side distance from the origin at the left side (length)
!	rightWidth:				wallhole's side distance from the origin at the right side (length)
!	bWndCurved:				is the window made of curved panels (0 / 1)
!	bParalellInCurvedWalls:	is the wallhole parallel in curved walls (0 / 1)
!	bDrawObjContourIn:
!	bDrawObjContourOut:
!	bDrawFrameContourLeft:	Draw the wall contour border on window frame at the left side (0 / 1)
!	bDrawFrameContourRight:	Draw the wall contour border on window frame at the left side (0 / 1)
!	bWindowSymbolAtMiddle:	Is the window symbol appears always on the middle of the wall (CHI special) (0 / 1)
! Corner Window Parameters -----------------------------------------------------
!	bCornerWindow:			is the hole a corner window? (0 / 1)
!	ac_corner_angle:		angle between connected walls in case of Corner Window (angle)
!	ac_diff_con_wall_thk:	indicates the equality thickness of the two connected walls (0 / 1)
!	ac_con_wall_thk:		thickness of the connected wall in case of Corner Window (length)
! Wallhole Cover Fill Parameter (only for polygon walls ) ----------------------
!	fillWallHole:			wallhole cover fill (only for polygon walls) (fill)
!	penWallHoleFg:			wallhole cover fill pen (only for polygon walls) (pen)
!	penWallHoleBg:			wallhole cover fill background pen (only for polygon walls) (pen)
!	penWallContour:			wallhole contour pen (only for polygon walls) (pen)
!	iWallContourLine		Identifies the wall cotours to be drawn
!								(integer; 1 = none, 2 = inside, 3 = outside, 4 = both)
!	gs_wcont_line_in:		type of the wall contour line inside (line type)
!	gs_wcont_line_out:		type of the wall contour line outside (line type)
! Oversize Parameters ----------------------------------------------------------
!	gs_left_oversize:		Left opening oversize (only for polygon walls) (length)
!	gs_right_oversize:		Right opening oversize (only for polygon walls) (length)
! Reveal Parameters ------------------------------------------------------------
!	iRevealType:			reveal type (integer)
!								0 = no Reveal
!								1 = Positive Reveal
!								2 = Negative Reveal
!								3 = Slanted Reveal
!								4 =
!	gs_reveal_left:			left reveal size (length)
!	gs_reveal_right:		left reveal size (length)
!	gs_reveal_left_angle:	left reveal angle in case of slanted reveal (angle)
!	gs_reveal_right_angle:	right reveal angle in case of slanted reveal (angle)
! Stacked Window Parameters ----------------------------------------------------
!	gs_stack_left:			align to door/window on left side (0 / 1)
!	gs_stack_right:			align to door/window on right side (0 / 1)
! Cavity Closure Parameters ----------------------------------------------------
!	gs_maxPlasterThk:		wall skin classification parameter (length)
!							consider Skin as Plaster if it is thinner this
!	gs_bAutoTurnIn:			automatic plaster return at Outside Face (0 / 1)
!	gs_bAutoTurnOut:		automatic plaster return at Inside Face (0 / 1)
!	gs_bOverIn:				number of turned plaster skins at Outside Face (integer)
!	gs_bOverOut:			number of turned plaster skins at Inside Face (integer)
!	iClosureType:			controls the method being used for internal cavity closure (integer)
!	bCavityCloserLeft:		show cavity closure at left side
!	bCavityCloserRight:		show cavity closure at right side
!	gs_nTurn:				number of turned skins in traditional mode (integer value)
!	gs_bJoint:				is there an insulation strip at the front
!							 side of the turned skins (0 / 1) [MODE1]
!	gs_thkJoint:			strip thickness (length)
!	gs_penJoint:			strip contour pen (pen)
!	gs_ltJoint:				strip contour linetype (line type)
!	gs_fillJoint:			strip fill type (fill)
!	gs_penJointFg:			strip fill pen (pen)
!	gs_penJointBg:			strip fill background pen (pen)
!	gs_widthPlug:			heat insulation profile width (length) [MODE2]
!	gs_penPlug:				profile contour pen (pen)
!	gs_ltPlug:				profile contour linetype (line type)
!	gs_fillPlug:			profile fill type (fill)
!	gs_penPlugFg:			profile fill pen (pen)
!	gs_penPlugBg:			profile fill background pen (pen)
! ==============================================================================


!! ==============================================================================
!! Debug function
!! ==============================================================================
!
!for i = 1 to WALL_SKINS_NUMBER
!	text2 0,	0, i
!	text2 0.15,	0, WALL_SKINS_PARAMS[i][SKIN_CORE_STATUS]
!	text2 0.25,	0, WALL_SKINS_PARAMS[i][SKIN_THICKEN_TRAPEZOID]
!	add2 0, 0.2
!next i
!del top


if GLOB_CONTEXT = 6 | GLOB_CONTEXT = 46 then end	! List
if GLOB_CONTEXT = 5 then	! Object Settings Dialog
	bDrawObjContourIn	= 0
	bDrawObjContourOut	= 0
	bSettingsDialog		= 1
endif


! === save the current parameter buffer
dim savedQueueValues[]
call "SaveQueue" parameters returned_parameters savedQueueValues


! ==============================================================================
! Reveal Points Indexes
! ==============================================================================

idxSillStartRevealLeft		= iRevealPointsIdx[1]
idxSillEndRevealLeft		= iRevealPointsIdx[2]
idxFrameStartRevealLeft		= iRevealPointsIdx[3]
idxFrameEndRevealLeft		= iRevealPointsIdx[4]
idxBoardEndRevealLeft		= iRevealPointsIdx[6]
idxSillStartRevealRight		= iRevealPointsIdx[11]
idxSillEndRevealRight		= iRevealPointsIdx[12]
idxFrameStartRevealRight	= iRevealPointsIdx[13]
idxBoardEndRevealRight		= iRevealPointsIdx[16]
idxFrameEndRevealRight		= iRevealPointsIdx[14]


! ==============================================================================
! Cut Wallhole with WALLHOLE2
! ==============================================================================

if WIDO_REVEAL_SIDE then
	mul2 1,-1
	add2 0,WIDO_FRAME_THICKNESS
endif

! ==============================================================================

if vardim1(leftRevealPnts) > 1 then
	if iRevealType = REVEAL_NEGATIVE then
		sxL = leftRevealPnts[idxSillEndRevealLeft - 1][1]
		syL = leftRevealPnts[idxSillEndRevealLeft - 1][2]
	else
		sxL = leftRevealPnts[idxSillEndRevealLeft][1]
		syL = leftRevealPnts[idxSillEndRevealLeft][2]
	endif

	bxL = leftRevealPnts[idxFrameStartRevealLeft][1]
	byL = leftRevealPnts[idxFrameStartRevealLeft][2]

	if iRevealType = REVEAL_NEGATIVE then
		sxR = rightRevealPnts[idxSillEndRevealRight - 1][1]
		syR = rightRevealPnts[idxSillEndRevealRight - 1][2]
	else
		sxR = rightRevealPnts[idxSillEndRevealRight][1]
		syR = rightRevealPnts[idxSillEndRevealRight][2]
	endif

	bxR = rightRevealPnts[idxFrameStartRevealRight][1]
	byR = rightRevealPnts[idxFrameStartRevealRight][2]

	frameSillXL  = leftRevealPnts[idxFrameStartRevealLeft][1]
	frameSillYL  = leftRevealPnts[idxFrameStartRevealLeft][2]
	frameBoardXL = leftRevealPnts[idxFrameEndRevealLeft][1]
	frameBoardYL = leftRevealPnts[idxFrameEndRevealLeft][2]

	frameSillXR  = rightRevealPnts[idxFrameStartRevealRight][1]
	frameSillYR  = rightRevealPnts[idxFrameStartRevealRight][2]
	frameBoardXR = rightRevealPnts[idxFrameEndRevealRight][1]
	frameBoardYR = rightRevealPnts[idxFrameEndRevealRight][2]

	if curvedWall then
		syL = -syL
		syR = -syR

		byL = -byL
		byR = -byR
	endif
endif


! ==============================================================================
! Cavity Closure
! ==============================================================================

dim skinCummThkRef[]	! Cummulative skin thickness from the Outside Face (8 +1 skins))
dim skinCummThkOpp[]	! Cummulative skin thickness from the Inside Face (8 + 1 skins)

cumRefThk = 0
cumOppThk = 0

if bCompositeWall then
	for i=1 to WALL_SKINS_NUMBER
		idx = i: gosub 10	! Get proper index

		cumRefThk = cumRefThk + WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
		skinCummThkRef[idx] = cumRefThk

		idx = WALL_SKINS_NUMBER + 1 - idx	! reorder
		cumOppThk = cumOppThk + WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
		skinCummThkOpp[idx] = cumOppThk
	next i
endif


! ==============================================================================

del top

if curvedWall then
	if WIDO_REVEAL_SIDE then
		mul2 1,-1
		add2 0,WIDO_FRAME_THICKNESS
	endif
else
	if WIDO_REVEAL_SIDE then add2 0,-WIDO_FRAME_THICKNESS
	if SYMB_ROTANGLE > EPS then mul2 1, -1
	if wallIsLeft then
		add2 0, -WIDO_SILL
	else
		add2 0, -WALL_THICKNESS + WIDO_SILL
	endif
	if reorder then
		mul2 1,-1
		add2 0, -WALL_THICKNESS
	endif
endif

! Stored Contour Line Related Definitions ======================================

dim contourLines[][7]	! Contour line store array
clIdx = 1				! Actual index

! Transformation from CavityClosure coorinate system to Wallhole Coorinate system
if curvedWall then
	if wallIsLeft exor reorder then
		signX = -1
	else
		signX = -1
	endif
	signY	= -1
	offsetY	= 0
else
	signX = 1
	if wallIsLeft exor reorder then
		signY	=  1
		offsetY	= -WIDO_SILL
	else
		signY	= -1
		offsetY	= WALL_THICKNESS - WIDO_SILL
	endif
endif


! ==============================================================================
! Call Leaf- and Right Cavity Closure Subroutines
! ==============================================================================

if WIDO_SILL <= gs_reveal_outer_jamb_depth then
	bSlantedOuterSide = 0
endif

if bCompositeWall then

	dim arrayCustomCC[8][4]

	! Initialize variable to CollectWallSkinSectionLines function
	iSkin = 1
	dim _wallSkinSectionLines[][7]
	for i = 1 to 7
		_wallSkinSectionLines[iSkin][i] = 0
	next i

	iTurnSkin = 1
	dim _turnSkinEndingLines[][7]
	for i = 1 to 7
		_turnSkinEndingLines[iTurnSkin][i] = 0
	next i

! Left Cavity Closure ==========================================================

	if not(bLeftCornerFunction) then

		if curvedWall then
			numTrans = 0
		else
			mul2 -1, 1
			numTrans = 1
		endif

		sideSign		= -1
		distanceX		= leftWidth
		alfaX			= leftAlfa
		alfaJamb		= gs_reveal_left * ArcLengthSillToAngle
		revealWidth		= gs_reveal_left
		revealAngle		= gs_reveal_left_angle
		revealSillAngle	= gs_reveal_outerLeft_angle
		bx = bxL
		by = byL
		sx = sxL
		sy = syL

		if bCavityCloserLeft | iClosureType	= CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then

			bCavityCloser	= bCavityCloserLeft

			if	iClosureType = CLOSURE_TRADITIONAL |\
				iClosureType = CLOSURE_FINISH then
				gosub "TraditionalCavityClosure"
			endif
			if	(iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) &\
				(bCavityCloserLeft | gs_cc_dutch_ShowLeft) & not(gs_stack_left) then

				gs_showJoint = gs_cc_dutch_ShowLeft
				gosub "TraditionalCavityClosure"	! Variable Closure

				if gs_showJoint & not(curvedWall) then
					gosub "CollectWallSkinSectionLines"

					_leftClosureFartherSideMPx = _closureFartherSideMPx * signX * sideSign
					_leftClosureFartherSideMPy = _closureFartherSideMPy * signY + offsetY
				endif
			endif
			if	iClosureType = CLOSURE_PREFABRICATED |\
				iClosureType = CLOSURE_AIR_SPACE then
				gosub "PrefabricatedCavityClosure"
			endif
			if	iClosureType = CLOSURE_CUSTOM |\
				iClosureType = CLOSURE_PLASTER_REVEAL |\
				iClosureType = CLOSURE_INSULATED_REVEAL |\
				iClosureType = CLOSURE_INSULATED_FOR_RENOVATION then

				arrayCustomCC		= gs_custom_cc_array_left
				revealWidthInner	= revealInnerLeft

				sillPx	= leftRevealPnts[idxSillStartRevealLeft][1]
				sillPy	= leftRevealPnts[idxSillStartRevealLeft][2] * signCurvedWall
				boardPx	= leftRevealPnts[idxBoardEndRevealLeft][1]
				boardPy	= leftRevealPnts[idxBoardEndRevealLeft][2] * signCurvedWall

				sillPx2	= leftRevealPnts[idxSillStartRevealLeft + 1][1]
				sillPy2	= leftRevealPnts[idxSillStartRevealLeft + 1][2] * signCurvedWall

				frameSillX	= frameSillXL
				frameSillY	= frameSillYL
				frameBoardX	= frameBoardXL
				frameBoardY	= frameBoardYL

!add2 A/2,0
!yy = 0
!for idx=1 to vardim1(gs_custom_cc_array_left)
!	iBitfield		  = round_int(gs_custom_cc_array_left[idx][CUSTOMCC_BITFIELD])
!	ccThickness		= gs_custom_cc_array_left[idx][CUSTOMCC_THICKNESS]
!	ccOverhang		= gs_custom_cc_array_left[idx][CUSTOMCC_OVERHANG]
!	ccSeparatorPen	= gs_custom_cc_array_left[idx][CUSTOMCC_PEN]
!
!	ccTurnIn		= bittest(iBitfield, 0)
!	ccThicknessType	= bittest(iBitfield, 1)
!	ccOrientation	= bittest(iBitfield, 2)
!	ccSeparator		= bittest(iBitfield, 3)
!	ccPlaster		= bittest(iBitfield, 4)
!
!	if idx=1 | idx=5 then: pen 20: else: pen 1: endif
!	text2 0,yy, \
!		str(ccTurnIn,1,0) +","+			\
!		str(ccThicknessType,1,0) +","+	\
!		str(ccOrientation,1,0) +","+	\
!		str(ccSeparator,1,0) +","+		\
!		str(ccPlaster,1,0) +" - "+		\
!		str(ccThickness * 1000,1,0) +","+	\
!		str(ccOverhang * 1000,1,0) +","+	\
!		str(ccSeparatorPen,1,0)
!
!	yy = yy + 0.1
!next idx
!del 1

				gosub "CustomCavityClosure"
			endif
		endif

		del numTrans

	endif

! Right Cavity Closure =========================================================

	if not(bCornerWindow) then
		if curvedWall then
			mul2 -1,1
			numTrans = 1
		else
			numTrans = 0
		endif

		sideSign		= 1
		distanceX		= rightWidth
		alfaX			= rightAlfa
		alfaJamb		= gs_reveal_right * ArcLengthSillToAngle
		revealWidth		= gs_reveal_right
		revealAngle		= gs_reveal_right_angle
		revealSillAngle	= gs_reveal_outerRight_angle
		bx = bxR
		by = byR
		sx = sxR
		sy = syR

		if bCavityCloserRight | iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then

			bCavityCloser	= bCavityCloserRight

			if	iClosureType = CLOSURE_TRADITIONAL |\
				iClosureType = CLOSURE_FINISH then
				gosub "TraditionalCavityClosure"
			endif
			if	(iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) &\
				(bCavityCloserRight | gs_cc_dutch_ShowRight) & not(gs_stack_right) then

				gs_showJoint = gs_cc_dutch_ShowRight
				gosub "TraditionalCavityClosure"	! Variable Closure

				if gs_showJoint & not(curvedWall) then
					gosub "CollectWallSkinSectionLines"

					_rightClosureFartherSideMPx = _closureFartherSideMPx * signX * sideSign
					_rightClosureFartherSideMPy = _closureFartherSideMPy * signY + offsetY
				endif
			endif
			if	iClosureType = CLOSURE_PREFABRICATED |\
				iClosureType = CLOSURE_AIR_SPACE then
				gosub "PrefabricatedCavityClosure"
			endif
			if	iClosureType = CLOSURE_CUSTOM |\
				iClosureType = CLOSURE_PLASTER_REVEAL |\
				iClosureType = CLOSURE_INSULATED_REVEAL |\
				iClosureType = CLOSURE_INSULATED_FOR_RENOVATION then

				arrayCustomCC		= gs_custom_cc_array_right
				revealWidthInner	= revealInnerRight

				sillPx	= rightRevealPnts[idxSillStartRevealRight][1]
				sillPy	= rightRevealPnts[idxSillStartRevealRight][2] * signCurvedWall
				boardPx	= rightRevealPnts[idxBoardEndRevealRight][1]
				boardPy	= rightRevealPnts[idxBoardEndRevealRight][2] * signCurvedWall

				sillPx2	= rightRevealPnts[idxSillStartRevealRight + 1][1]
				sillPy2	= rightRevealPnts[idxSillStartRevealRight + 1][2] * signCurvedWall

				frameSillX	= frameSillXR
				frameSillY	= frameSillYR
				frameBoardX	= frameBoardXR
				frameBoardY	= frameBoardYR

!add2 A/2,0
!yy = 0
!circle2 0,0,0.02
!for idx=1 to vardim1(gs_custom_cc_array_right)
!	iBitfield		  = round_int(gs_custom_cc_array_right[idx][CUSTOMCC_BITFIELD])
!	ccThickness		= gs_custom_cc_array_right[idx][CUSTOMCC_THICKNESS]
!	ccOverhang		= gs_custom_cc_array_right[idx][CUSTOMCC_OVERHANG]
!	ccSeparatorPen	= gs_custom_cc_array_right[idx][CUSTOMCC_PEN]
!
!	ccTurnIn		= bittest(iBitfield, 0)
!	ccThicknessType	= bittest(iBitfield, 1)
!	ccOrientation	= bittest(iBitfield, 2)
!	ccSeparator		= bittest(iBitfield, 3)
!	ccPlaster		= bittest(iBitfield, 4)
!
!	if idx=1 | idx=5 then: pen 20: else: pen 1: endif
!	text2 0,yy, \
!		str(ccTurnIn,1,0) +","+			\
!		str(ccThicknessType,1,0) +","+	\
!		str(ccOrientation,1,0) +","+	\
!		str(ccSeparator,1,0) +","+		\
!		str(ccPlaster,1,0) +" - "+		\
!		str(ccThickness * 1000,1,0) +","+	\
!		str(ccOverhang * 1000,1,0) +","+	\
!		str(ccSeparatorPen,1,0)
!
!	yy = yy + 0.1
!next idx
!del 1

				gosub "CustomCavityClosure"
			endif
		endif

		del numTrans
	endif

endif	! bCompositeWall


! Draw wall contour lines ======================================================

dim edgeSections[][7]

if vardim1(lineSections) > 0 | vardim1(contourLines) > 0 then
	gosub "DrawWallContourLines"
endif


! Restore the saved parameter buffer ===========================================

call "LoadQueue" parameters savedQueueValues = savedQueueValues


end

! ==============================================================================
! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
! ==============================================================================




! ==============================================================================
! === SUBROUTINES
! ==============================================================================


! ==============================================================================
!		Traditional Cavity Closure
! ------------------------------------------------------------------------------
! Input variables:
!	possibleSkinTurnIn:		number of possible plaster skins at the Outside Face
!	possibleSkinTurnOut:	number of possible plaster skins at the Inside Face
!	distanceX:				horizontal distance from the original origo
!	alfaX:					alfa x in case of curved walls (alfaX > 0)
!	alfaJamb:				jamb alfa (alfaJamb > 0)
!	revealWidth:			width of the reveal
! ==============================================================================

"TraditionalCavityClosure":

	if iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
		thkJoint = gs_cc_dutch_thkJoint
	else
		thkJoint = gs_thkJoint
	endif

	nSkins = WALL_SKINS_NUMBER - possibleSkinTurnOut - possibleSkinTurnIn
	if nSkins < 3 then return

	gs_nTurn = min(gs_nTurn, nSkins - 2)

	if iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
		signTurnDir = (gs_cc_dutch_ClosureToSide = 2) - not(gs_cc_dutch_ClosureToSide = 2)

		if gs_cc_dutch_ClosureToSide = 2 then
			idx = WALL_SKINS_NUMBER - possibleSkinTurnOut - gs_cc_dutch_ClosureToSkin: gosub 10	! Get proper index
			idx = max(idx, 1)
			idx = min(idx, WALL_SKINS_NUMBER + 1)
			baseSkinLevel = skinCummThkRef[idx]

			idx = WALL_SKINS_NUMBER - possibleSkinTurnOut:	gosub 10	! Get proper index
			idx = max(idx, 1)
			idx = min(idx, WALL_SKINS_NUMBER)
			baseSkinIdx = idx
		else
			idx = possibleSkinTurnIn + gs_cc_dutch_ClosureToSkin: gosub 10	! Get proper index
			idx = max(idx, 1)
			idx = min(idx, WALL_SKINS_NUMBER + 1)
			baseSkinIdx = idx
			baseSkinLevel = skinCummThkRef[baseSkinIdx]
		endif
	else
		signTurnDir = (gs_bTurnDir) - not(gs_bTurnDir)

		if gs_bTurnDir then
			idx = WALL_SKINS_NUMBER - possibleSkinTurnOut - 1: gosub 10	! Get proper index
			baseSkinLevel = skinCummThkRef[idx]

			idx = WALL_SKINS_NUMBER - possibleSkinTurnOut:	gosub 10	! Get proper index
			baseSkinIdx = idx
		else
			idx = possibleSkinTurnIn + 1: gosub 10	! Get proper index
			baseSkinIdx = idx
			baseSkinLevel = skinCummThkRef[baseSkinIdx]
		endif
	endif

	offsetFromJoint = ((iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) & not(gs_cc_dutch_TurnToClosure)) * gs_cc_dutch_TurnToClosureOffs
	if	iClosureType = CLOSURE_VARIABLE |\
		iClosureType = CLOSURE_DUTCH_VARIABLE then

		signTurnDir2 = (gs_bTurnDir) - not(gs_bTurnDir)
		if (gs_cc_dutch_ClosureToSide = 2) exor gs_bTurnDir then
			lengthSkinTurnIn = baseSkinLevel - signTurnDir2 * gs_bJoint * (offsetFromJoint)
		else
			lengthSkinTurnIn = baseSkinLevel - signTurnDir2 * gs_bJoint * (thkJoint + offsetFromJoint)
		endif
	else
		lengthSkinTurnIn = baseSkinLevel - signTurnDir * gs_bJoint * (thkJoint + offsetFromJoint)
	endif

!!!	idx = nSkinTurnIn + gs_nTurn: gosub 10	! Get proper index
	if gs_bTurnDir then
		idx = possibleSkinTurnIn + gs_nTurn: gosub 10	! Get proper index
		if idx > 0 then
			level_1 = skinCummThkRef[idx]
		else
			level_1 = 0
		endif
	else
		idx = WALL_SKINS_NUMBER - possibleSkinTurnOut - gs_nTurn: gosub 10	! Get proper index
		level_1 = skinCummThkRef[idx]
	endif

	idx = baseSkinIdx
	baseSkinFillType		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL])
	baseSkinFillFgPen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_PEN])
	baseSkinFillBgPen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_BACK_PEN])
	baseSkinFillOrientation	= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_ORIENTATION])
	baseSkinContLinePen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
	baseSkinContLineType	= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])

!!!	idx = nSkinTurnIn: gosub 10	! Get proper index
	if gs_bTurnDir then
		idx = possibleSkinTurnIn: gosub 10	! Get proper index
		if idx > 0 then
			level_2 = skinCummThkRef[idx]
		else
			level_2 = 0
		endif
	else
		idx = WALL_SKINS_NUMBER - possibleSkinTurnOut: gosub 10	! Get proper index
		level_2 = skinCummThkRef[idx]
	endif

	summThicknessOfTurnedSkins = abs(level_1 - level_2)

	dx = 0
	bCuttedPlug = 0
	bNegativeTurn = 0

	vectS = -sin(revealAngle) * signWallIsLeft
	vectC =  cos(revealAngle)

	if bFirstSkinAtReveal exor not(gs_bTurnDir) then
		if iRevealType = REVEAL_POSITIVE then dx = -revealWidth
		if iRevealType = REVEAL_NEGATIVE then dx = -revealWidth
		if iRevealType = REVEAL_SLANTED  then dx = -revealWidth

		if not(curvedWall) then
			slantX = 0
			vectS = sin(alfaX - alfaJamb)
			vectC = cos(alfaX - alfaJamb)
		endif

		bCuttedPlug		= 0
		plugLeftDx		= 0
		plugOnWindow	= 0		! GER request

		bIncludeReveal	= 0

		if	not(iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) &\
			iRevealType <> REVEAL_NEGATIVE &\
			revealWidth + EPS >= summThicknessOfTurnedSkins &\
			summThicknessOfTurnedSkins + (thkJoint + offsetFromJoint) < WIDO_SILL then

			! note: summThicknessOfTurnedSkins equals the summ width of the turned skins

			if gs_bTurnDir then
				baseSkinLevel = WIDO_SILL
				lengthSkinTurnIn = baseSkinLevel - gs_bJoint * (thkJoint + offsetFromJoint)
			else
				baseSkinLevel = WALL_THICKNESS - WIDO_SILL
				lengthSkinTurnIn = baseSkinLevel + gs_bJoint * (thkJoint + offsetFromJoint)
			endif
			plugOnWindow = 1
		else
			if not(iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) & iRevealType = REVEAL_NEGATIVE then
				plugLeftDx = 0

				if gs_bTurnDir then
					if baseSkinLevel - EPS > WIDO_SILL then
						bCuttedPlug = 1
					endif
				else
					if baseSkinLevel - EPS < WALL_THICKNESS - WIDO_SILL then
						bCuttedPlug = 1
					endif
				endif
			else
				if gs_bTurnDir then

					if iRevealType = REVEAL_NEGATIVE then
						testEPS = -EPS
					else
						testEPS = EPS
					endif

					if lengthSkinTurnIn - testEPS >= WIDO_SILL then
						if lengthSkinTurnIn - testEPS < WIDO_SILL then
							plugLeftDx = revealWidth
						else
							bIncludeReveal = 1
							if bSlantedInnerSide then
								if iRevealType = REVEAL_SLANTED then slantDy = lengthSkinTurnIn - WIDO_SILL
								if iRevealType = REVEAL_SPLAYED then slantDy = lengthSkinTurnIn - WIDO_SILL - WIDO_FRAME_THICKNESS
								dx = slantDy * tan(revealAngle)
							else
								dx = 0
							endif
						endif
					else
						bCuttedPlug = 1
					endif
				else
					if lengthSkinTurnIn + testEPS <= WALL_THICKNESS - WIDO_SILL then
						if lengthSkinTurnIn - testEPS > WALL_THICKNESS - WIDO_SILL then
							plugLeftDx = revealWidth
						else
							bIncludeReveal = 1
							if bSlantedInnerSide then
								if iRevealType = REVEAL_SLANTED then slantDy = WALL_THICKNESS - lengthSkinTurnIn - WIDO_SILL
								if iRevealType = REVEAL_SPLAYED then slantDy = WALL_THICKNESS - lengthSkinTurnIn - WIDO_SILL - WIDO_FRAME_THICKNESS
								dx = slantDy * tan(revealAngle)
							else
								dx = 0
							endif
						endif
					else
						bCuttedPlug = 1
					endif
				endif
			endif
		endif
		if WIDO_SILL < EPS & (iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE) then
			bIncludeReveal = 0
		endif
	else

		if iRevealType = REVEAL_NEGATIVE then
			if iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
				if gs_bTurnDir then
					if lengthSkinTurnIn + EPS >= WALL_THICKNESS - WIDO_SILL & WIDO_SILL < WALL_THICKNESS then
						bIncludeReveal = 1
					endif
				else
					if lengthSkinTurnIn + EPS <= WIDO_SILL & WIDO_SILL < WALL_THICKNESS then
						bIncludeReveal = 1
					endif
				endif
			else
				if gs_bTurnDir then
					if baseSkinLevel + EPS >= WALL_THICKNESS - WIDO_SILL & WIDO_SILL < WALL_THICKNESS then
						bIncludeReveal = 1
					endif
				else
					if baseSkinLevel + EPS <= WIDO_SILL & WIDO_SILL < WALL_THICKNESS then
						bIncludeReveal = 1
					endif
				endif
			endif
		else
			if gs_bTurnDir then
				if curvedWall & not(bWndCurved) then
					if wallIsLeft then
						sLevel = sqr(bx^2 + (by + WOD)^2) - radBoard
					else
						sLevel = WALL_THICKNESS - sqr(bx^2 + (by + WOD)^2) + radSill
					endif

					if baseSkinLevel - EPS >= sLevel then
						bCuttedPlug = 1
						plugLeftDx = -revealWidth
					endif
				else
					if baseSkinLevel + EPS > WALL_THICKNESS - WIDO_SILL then
						bCuttedPlug = 1
						plugLeftDx = -revealWidth
					endif
				endif
			else
				if curvedWall & not(bWndCurved) then
					if wallIsLeft then
						sLevel = radSill - sqr(bx^2 + (by + WOD)^2)
					else
						sLevel = sqr(bx^2 + (by + WOD)^2) - radSill
					endif

					if baseSkinLevel + EPS <= sLevel then
						bCuttedPlug = 1
						plugLeftDx = -revealWidth
					endif
				else
					if baseSkinLevel + EPS < WIDO_SILL then
						bCuttedPlug = 1
						plugLeftDx = -revealWidth
					endif
				endif
			endif
		endif

		if iRevealType = REVEAL_NEGATIVE then
			if gs_bTurnDir then
				if WALL_THICKNESS - WIDO_SILL < baseSkinLevel + EPS then
					dx = -revealWidth
				endif
			else
				if WIDO_SILL > baseSkinLevel + EPS then
					dx = -revealWidth
				endif
			endif
			bNegativeTurn = 1
		endif
		if iRevealType = REVEAL_SLANTED then slantLength = WALL_THICKNESS - WIDO_SILL
		if iRevealType = REVEAL_SPLAYED then slantLength = WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS

		if not(curvedWall) then
			if bSlantedInnerSide then
				slantX = tan(revealAngle)
				vectS = -sin(revealAngle) * signWallIsLeft
				vectC =  cos(revealAngle)
			else
				slantX = 0
				vectS = sin(alfaX)
				vectC = cos(alfaX)
			endif
		endif
	endif

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		bCuttedPlug		= 0
		bIncludeReveal	= 0
	endif

	if iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
		bCuttedPlug	= 0
		plugLeftDx	= 0

		dx = 0
		if bFirstSkinAtReveal then
			if	iRevealType = REVEAL_POSITIVE | \
				iRevealType = REVEAL_SLANTED then
				refLevelForDxTest = baseSkinLevel + (gs_cc_dutch_ClosureToSide = 1) * thkJoint
				if WIDO_SILL > refLevelForDxTest - EPS then
					dx = -revealWidth
				endif
			endif
			if iRevealType = REVEAL_NEGATIVE then
				refLevelForDxTest = baseSkinLevel - (gs_cc_dutch_ClosureToSide = 2) * thkJoint
				if WIDO_SILL > refLevelForDxTest + EPS then
					dx = -revealWidth
				endif
			endif
		else
			if	iRevealType = REVEAL_POSITIVE | \
				iRevealType = REVEAL_SLANTED then
				refLevelForDxTest = baseSkinLevel - (gs_cc_dutch_ClosureToSide = 2) * thkJoint
				if WALL_THICKNESS - WIDO_SILL < refLevelForDxTest + EPS then
					dx = -revealWidth
				endif
			endif
			if iRevealType = REVEAL_NEGATIVE then
				refLevelForDxTest = baseSkinLevel + (gs_cc_dutch_ClosureToSide = 1) * thkJoint
				if WALL_THICKNESS - WIDO_SILL < refLevelForDxTest - EPS then
					dx = -revealWidth
				endif
			endif
		endif
	endif

	if curvedWall then
		signTurnDir2 = (gs_bTurnDir) - not(gs_bTurnDir)

		if reorder then
			if iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
				rBegH = min(radSill, radBoard) + baseSkinLevel
				if (gs_cc_dutch_ClosureToSide = 2) exor gs_bTurnDir then
					rBegH = min(radSill, radBoard) + baseSkinLevel + signTurnDir2 * gs_bJoint * thkJoint
					rEndH = min(radSill, radBoard) + baseSkinLevel
				else
					rBegH = min(radSill, radBoard) + baseSkinLevel
					rEndH = min(radSill, radBoard) + baseSkinLevel - signTurnDir2 * gs_bJoint * thkJoint
				endif
			else
				rBegH = min(radSill, radBoard) + baseSkinLevel
				rEndH = min(radSill, radBoard) + baseSkinLevel - signTurnDir * thkJoint
			endif
		else
			if iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
				if (gs_cc_dutch_ClosureToSide = 2) exor gs_bTurnDir then
					rBegH = max(radSill, radBoard) - baseSkinLevel - signTurnDir2 * gs_bJoint * thkJoint
					rEndH = max(radSill, radBoard) - baseSkinLevel
				else
					rBegH = max(radSill, radBoard) - baseSkinLevel
					rEndH = max(radSill, radBoard) - baseSkinLevel + signTurnDir2 * gs_bJoint * thkJoint
				endif
			else
				rBegH = max(radSill, radBoard) - baseSkinLevel
				rEndH = max(radSill, radBoard) - baseSkinLevel + signTurnDir * thkJoint
			endif
		endif
		baseSkinRadius	= rEndH
		lengthToAngle	= (180 / rBegH / PI)	! Ref circle is on the rBegH
	endif

	dxAngle = dx * ArcLengthSillToAngle

	if iRevealType = REVEAL_SLANTED & not(bIncludeReveal) & wallIsLeft & (reorder exor gs_bTurnDir) then
		! In this special case we have to draw a normal positive reveal
		bSlantedInnerSide = 0
	endif


! Insulation Strip =============================================================

	dutchSpouwlatPx = 0
	dutchSpouwlatPy = 0

	if gs_bJoint then

		if iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
			widthJoint = gs_cc_dutch_widthJoint
		else
			widthJoint = summThicknessOfTurnedSkins
		endif

		if not(bFirstSkinAtReveal exor not(gs_bTurnDir)) & bSlantedInnerSide & not(curvedWall) then widthJoint = widthJoint / cos(revealAngle)

		if gs_bTurnDir then
			slantDx = bSlantedInnerSide * not(bFirstSkinAtReveal exor not(gs_bTurnDir)) * (baseSkinLevel - thkJoint - WALL_THICKNESS + WIDO_SILL) * tan(revealAngle)
		else
			slantDx = bSlantedInnerSide * not(bFirstSkinAtReveal exor not(gs_bTurnDir)) * (WIDO_SILL - baseSkinLevel - thkJoint) * tan(revealAngle)
		endif

		if not(bFirstSkinAtReveal exor not(gs_bTurnDir)) & baseSkinLevel > WIDO_SILL then
			if gs_bTurnDir then
				plugLeftDx = (WALL_THICKNESS - lengthSkinTurnIn - WIDO_SILL) * tan(revealAngle)
			else
				plugLeftDx = (lengthSkinTurnIn - WIDO_SILL) * tan(revealAngle)
			endif
		endif

! Closure is always placed to inside face of the wall at Dutch Closure =========

		offsetToJoint = 0
		if iClosureType = CLOSURE_DUTCH_VARIABLE then

			offsetToJoint = offsetFromJoint * not(gs_cc_dutch_TurnToClosure)

			if curvedWall & reorder then
				offsetToJoint = -offsetToJoint
			endif
		endif

! End of closure moving to inside face of the wall =============================

		if curvedWall then

			if bSlantedInnerSide | bParalellInCurvedWalls then

				xo = 0
				yo = -WOD

				ro = rBegH

				if (gs_bTurnDir exor reorder exor wallIsLeft) & bCuttedPlug then
					x1 = -sx * sideSign
					y1 =  sy
					x2 = x1 - sin(alfaX - alfaJamb)
					y2 = y1 + cos(alfaX - alfaJamb) * signWallIsLeft
				else
					x1 = -bx * sideSign
					y1 =  by
					x2 = x1 - vectS
					y2 = y1 + vectC * signWallIsLeft
				endif

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px1 = cx
				py1 = cy

				ro = baseSkinRadius

				x1 = -bx * sideSign - widthJoint * vectC
				y1 = by - widthJoint * vectS * signWallIsLeft
				x2 = x1 - vectS
				y2 = y1 + vectC * signWallIsLeft

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px3 = cx
				py3 = cy

				alpha =  atn(cx/(cy+WOD))
				px2 = px3 - signTurnDir2 * signReorder * signWallIsLeft * thkJoint * sin(alpha)
				py2 = py3 - signTurnDir2 * signReorder * signWallIsLeft * thkJoint * cos(alpha)

				ro = rEndH

				if (gs_bTurnDir exor reorder exor wallIsLeft) | not(bCuttedPlug) then
					x1 = -bx * sideSign
					y1 =  by
					x2 = x1 - vectS
					y2 = y1 + vectC * signWallIsLeft
				else
					x1 = -sx * sideSign
					y1 =  sy
					x2 = x1 - sin(alfaX - alfaJamb)
					y2 = y1 + cos(alfaX - alfaJamb) * signWallIsLeft
				endif

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px4 = cx
				py4 = cy

			else

				plugAngle = widthJoint * lengthToAngle
				alfaPlug = alfaX + dxAngle

				sin1 = sin(alfaPlug)
				cos1 = cos(alfaPlug) * signWallIsLeft
				sin2 = sin(alfaPlug + plugAngle)
				cos2 = cos(alfaPlug + plugAngle) * signWallIsLeft

				if bCuttedPlug then
					if gs_bTurnDir exor reorder exor wallIsLeft then
						alfaPlug3 = alfaX - alfaJamb
					else
						alfaPlug3 = alfaX
					endif
					sin3 = sin(alfaPlug3)
					cos3 = cos(alfaPlug3) * signWallIsLeft

					sin4 = sin(alfaX + dxAngle)
					cos4 = cos(alfaX + dxAngle) * signWallIsLeft
				endif

				if bCuttedPlug then
					px1 = -(rBegH - offsetToJoint) * sin3
					py1 = -WOD + (rBegH - offsetToJoint) * cos3
				else
					px1 = -(rBegH - offsetToJoint) * sin1
					py1 = -WOD + (rBegH - offsetToJoint) * cos1
				endif

				px2 = -(rBegH - offsetToJoint) * sin2
				py2 = -WOD + (rBegH - offsetToJoint) * cos2

				px3 = -(rEndH - offsetToJoint) * sin2
				py3 = -WOD + (rEndH - offsetToJoint) * cos2

				if bCuttedPlug then
					px4 = -(rEndH - offsetToJoint) * sin4
					py4 = -WOD + (rEndH + offsetToJoint) * cos4
				else
					px4 = -(rEndH - offsetToJoint) * sin1
					py4 = -WOD + (rEndH - offsetToJoint) * cos1
				endif
			endif
		else
			px1 = distanceX + dx + plugLeftDx
			py1 = baseSkinLevel - signTurnDir * offsetToJoint

			px2 = distanceX + dx + plugLeftDx
			py2 = baseSkinLevel - signTurnDir * (thkJoint + offsetToJoint)

			px3 = distanceX + dx - slantDx + widthJoint
			py3 = baseSkinLevel - signTurnDir * (thkJoint + offsetToJoint)

			px4 = distanceX + dx - slantDx + widthJoint
			py4 = baseSkinLevel - signTurnDir * offsetToJoint
		endif

		dutchSpouwlatPx = px3
		dutchSpouwlatPy = py3


! Draw Insulation Strip ========================================================

		if GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY then
			gs_showJoint = 0
		endif

		if gs_showJoint then
			pen gs_penJoint
			line_type gs_ltJoint
			set fill gs_fillJoint
			line_property LINE_PROPERTY_INNER

			penIdx		= gs_penJoint
			lineTypeIdx	= gs_ltJoint

			if bCuttedPlug then

				bDivide		= 0		! is sill line cross the insulation plug?
				divLength	= 0

				if bFirstSkinAtReveal then
					if gs_bTurnDir then
						bDivide = (baseSkinLevel + EPS  > WIDO_SILL & baseSkinLevel - thkJoint - EPS < WIDO_SILL)
						divLength = baseSkinLevel - WIDO_SILL
					else
						bDivide = (baseSkinLevel - EPS < WIDO_SILL & baseSkinLevel + thkJoint + EPS > WIDO_SILL)
						divLength = baseSkinLevel + thkJoint - WIDO_SILL
					endif
				else
					if gs_bTurnDir then
						bDivide = (baseSkinLevel + EPS > WALL_THICKNESS - WIDO_SILL & baseSkinLevel - thkJoint - EPS < WALL_THICKNESS - WIDO_SILL)
						divLength = baseSkinLevel - thkJoint - (WALL_THICKNESS - WIDO_SILL)
					else
						bDivide = (baseSkinLevel - EPS < WALL_THICKNESS - WIDO_SILL & baseSkinLevel + thkJoint + EPS > WALL_THICKNESS - WIDO_SILL)
						divLength = baseSkinLevel - (WALL_THICKNESS - WIDO_SILL)
					endif
				endif

				if iRevealType = REVEAL_SLANTED & not(plugOnWindow) & bDivide then
					px1Slant = abs(divLength * tan(revealAngle))
					px1Slant = max(0,px1Slant)
				else
					px1Slant = 0
				endif

				if bFirstSkinAtReveal then
					pySill = WIDO_SILL
				else
					pySill = WALL_THICKNESS - WIDO_SILL
				endif

				if curvedWall then
					if curvedWall & not(bWndCurved) & not(iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | iRevealType = REVEAL_NEGATIVE) & (py4 - EPS < by) & (py3 + EPS > by) then
						xo = 0
						yo = -WOD
						ro = baseSkinRadius - (reorder exor gs_bTurnDir) * thkJoint

						x1 = 0
						y1 = by
						x2 = 1
						y2 = by

						gosub 101	! Circle - Line intersection
						gosub 102	! Select good intersection point

						if (reorder exor gs_bTurnDir) then
							put	cx,				cy,		1,
								px2,			py2,	3000 * curvedWall + 1,
								px3,			py3,	1,
								px4,			py4,	3000 * curvedWall + 1

							put	-sideSign * bx,	by,		1
						else
							put	 px1,			py1,	1,
								 px2,			py2,	3000 * curvedWall + 1,
								 px3,			py3,	1,
								 cx,			cy,		3000 * curvedWall + 1,
								-bx * sideSign,	by,		1
						endif
					else
						put	px1,			py1,	1,
							px2,			py2,	3000 * curvedWall + 1,
							px3,			py3,	1,
							px4,			py4,	3000 * curvedWall + 1

						if gs_bTurnDir exor reorder exor wallIsLeft then
							put	-sideSign * bx,	by,		1,
								-sideSign * sx,	sy,		1
						else
							put	-sideSign * sx,	sy,		1,
								-sideSign * bx,	by,		1
						endif
					endif
				else
					if gs_bTurnDir exor reorder exor wallIsLeft then
						put	px1,		py1,		1,
							px1,		pySill,		1,
							distanceX,	pySill,		1,
							distanceX + px1Slant,	py3,		1,
							px3,		py3,		1,
							px4,		py4,		1
					else
						put	distanceX + px1Slant, baseSkinLevel,	1,
							distanceX,	pySill,		1,
							px1,		pySill,		1,
							px2,		py2,		1,
							px3,		py3,		1,
							px4,		py4,		1
					endif
				endif

				penFillFg	= gs_penJointFg
				penFillBg	= gs_penJointBg
				bLocalFill	= 0
				bDrawContour	= 1
				bFitToSkinFill	= 0
				bDrawWallBlock	= 1
				bClosureContour	= 0

				gosub 200	! Draw wallblock with contour
			else
				px1Slant = bSlantedInnerSide * bFirstSkinAtReveal * not(plugOnWindow) * thkJoint * tan(revealAngle)	! Slanted Reveal

				if curvedWall then
					px1Slant = 0
				else
					if bFirstSkinAtReveal exor not(gs_bTurnDir) then
						px1Slant =  bSlantedInnerSide * not(plugOnWindow) * thkJoint * tan(revealAngle)	! Slanted Reveal
					else
						if baseSkinLevel > WIDO_SILL then
							px1Slant = -bSlantedInnerSide * not(plugOnWindow) * thkJoint * tan(revealAngle)	! Slanted Reveal
						else
							px1Slant = 0
						endif
					endif
				endif

				put	px1 + px1Slant,	py1,	1,
					px2,			py2,	3000 * curvedWall + 1,
					px3,			py3,	1,
					px4,			py4,	3000 * curvedWall + 1

				penFillFg	= gs_penJointFg
				penFillBg	= gs_penJointBg
				bLocalFill	= 0
				bDrawContour	= 1
				bFitToSkinFill	= 0
				bDrawWallBlock	= not(iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE)
				bClosureContour = (iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE)

				gosub 200	! Draw wallblock with contour

				_closureFartherSidePx = px3
				! middle point of that side of closure which is farther from local origo and perpendicular to wall axis
				_closureFartherSideMPx = (px3 + px4)/2
				_closureFartherSideMPy = (py3 + py4)/2
			endif		! if bCuttedPlug then
		endif		! if gs_showJoint then
	endif		! if gs_bJoint then


! Turn Skins - Traditional Mode ================================================

	if bInclinedWall & not(iCavityClosureTurnDir = CAVITY_TURN_REFERENCE) then
		bStraightInside	 = 0
		bStraightOutside = 0
	else
		bStraightInside	 = 1
		bStraightOutside = 1
	endif
	turnThk = 0
	baseSkinRadius = baseSkinRadius + signReorder * signTurnDir2 * offsetFromJoint

	if gs_bTurnDir then
		startCount	= possibleSkinTurnIn + 1
		endCount	= possibleSkinTurnIn + gs_nTurn
	else
		startCount	= possibleSkinTurnOut + 1
		endCount	= possibleSkinTurnOut + gs_nTurn
	endif

	bHaveShownSkinBefore = (startCount > 1)		! Skin before the first turned skins is shown or not?
	if bHaveShownSkinBefore then
		prevSkinIdx = startCount - 1
		if gs_bTurnDir then
			idx = prevSkinIdx: gosub 10	! Get proper index
		else
			idx = WALL_SKINS_NUMBER - prevSkinIdx + 1: gosub 10	! Get proper index
		endif

		bHaveShownSkinBefore = not((GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY & WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] < EPS) | \
								   (GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) < EPS))
	endif

	if not(bCavityCloser) then
		return
	endif

	for i = startCount to endCount

		if gs_bTurnDir then
			idx = i: gosub 10	! Get proper index
		else
			idx = WALL_SKINS_NUMBER - i + 1: gosub 10	! Get proper index
		endif

		skinThk = WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
		bFirst	= (i = startCount)
		bLast	= (i = endCount)

		if reorder then
			cummThk = skinCummThkRef[idx + 1]
		else
			if idx > 1 then
				cummThk = skinCummThkRef[idx - 1]
			else
				cummThk = 0
			endif
		endif


! Curved Wall ==================================================================

		if curvedWall then

			bSpecCase	= (not(bIncludeReveal) & not(wallIsLeft) & not(reorder exor gs_bTurnDir))

			if gs_bTurnDir then
				py1 = cummThk + skinThk
				slantL = slantLength - py1
			else
				py1 = cummThk
				slantL = slantLength - WALL_THICKNESS + py1
			endif

			slantX = 0

! p1 point ---------------------------------------------------------------------

			xo = 0
			yo = -WOD
			if bFirstSkinAtReveal then
				if gs_bTurnDir then
					ro = radSill - (cummThk + skinThk) * signReorder
				else
					ro = radSill - cummThk * signReorder
				endif
			else
				if gs_bTurnDir then
					ro = radBoard - (cummThk + skinThk) * signReorder
				else
					ro = radBoard - cummThk * signReorder
				endif
			endif

			if bSlantedInnerSide | bParalellInCurvedWalls then
				x1 = -bx * sideSign - (turnThk + skinThk) * vectC
				y1 =  by - (turnThk + skinThk) * vectS * signWallIsLeft
				x2 = x1 - vectS
				y2 = y1 + vectC * signWallIsLeft
			else
				alfa = alfaX + (turnThk + skinThk) * lengthToAngle + dxAngle

				x1 = 0
				y1 = -WOD
				x2 = -signWallIsLeft * sin(alfa)
				y2 =  cos(alfa) - WOD
			endif

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			px1 = cx
			py1 = cy


! Valid Skin Test --------------------------------------------------------------

			if reorder exor gs_bTurnDir then
				bSkipThisSkin = (baseSkinRadius > ro - EPS)
			else
				bSkipThisSkin = (baseSkinRadius < ro + EPS)
			endif


! p4 point ---------------------------------------------------------------------

			if bFirstSkinAtReveal then
				if gs_bTurnDir then
					ro4 = radSill - cummThk * signReorder
				else
					ro4 = radSill - (cummThk + skinThk) * signReorder
				endif
			else
				if gs_bTurnDir then
					ro4 = radBoard - cummThk * signReorder
				else
					ro4 = radBoard - (cummThk + skinThk) * signReorder
				endif
			endif
			ro = ro4

			if (bSlantedInnerSide & not(bSpecCase & bFirst)) | bParalellInCurvedWalls then
				x1 = -bx * sideSign - turnThk * vectC
				y1 =  by - turnThk * vectS* signWallIsLeft
				x2 = x1 - vectS
				y2 = y1 + vectC * signWallIsLeft
			else
				alfa = alfaX + turnThk * lengthToAngle + dxAngle

				x1 = 0
				y1 = -WOD
				x2 = -signWallIsLeft * sin(alfa)
				y2 =  cos(alfa) - WOD
			endif

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			px4 = cx
			py4 = cy


! p2 point ---------------------------------------------------------------------

			ro = baseSkinRadius

			if bSlantedInnerSide | bParalellInCurvedWalls then
				x1 = -bx * sideSign - (turnThk + skinThk) * vectC
				y1 =  by - (turnThk + skinThk) * vectS * signWallIsLeft
				x2 = x1 - vectS
				y2 = y1 + vectC * signWallIsLeft
			else
				alfa = alfaX + (turnThk + skinThk) * lengthToAngle + dxAngle

				x1 = 0
				y1 = -WOD
				x2 = -signWallIsLeft * sin(alfa)
				y2 =  cos(alfa) - WOD
			endif

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			px2 = cx
			py2 = cy


! p3 point ---------------------------------------------------------------------

			if (bSlantedInnerSide & not(bSpecCase & bFirst)) | bParalellInCurvedWalls then
				x1 = -bx * sideSign - turnThk * vectC
				y1 =  by - turnThk * vectS* signWallIsLeft
				x2 = x1 - vectS
				y2 = y1 + vectC * signWallIsLeft
			else
				alfa = alfaX + turnThk * lengthToAngle + dxAngle

				x1 = 0
				y1 = -WOD
				x2 = -signWallIsLeft * sin(alfa)
				y2 =  cos(alfa) - WOD
			endif

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			px3 = cx
			py3 = cy

			if bIncludeReveal & bFirst then
				if bNegativeTurn then
					px6 = -sideSign * bx
					py6 =  by

					px5 = -sideSign * sx
					py5 =  sy
				else
					px5 = -sideSign * bx
					py5 =  by

					px6 = -sideSign * sx
					py6 =  sy
				endif

				ro = ro4	! on the same circle as the p4 point

				alfa = alfaX - not(bNegativeTurn) * alfaJamb

				if bParalellInCurvedWalls then
					x1 = -sx * sideSign
					y1 =  sy
					x2 = x1
					y2 = y1 + 1
				else
					x1 = 0
					y1 = -WOD
					x2 = -signWallIsLeft * sin(alfa)
					y2 =  cos(alfa) - WOD
				endif

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px7 = cx
				py7 = cy

				if px4 > px7 - EPS then		! to avoid generating degenerated polygons
					px4 = px7
					py4 = py7
				endif
			endif

		else

! Straight Wall, Trapezoid Wall ================================================

			if bInclinedWall then
				inclinedWallDiffInside	= skinCummThkOpp[idx] / incH
				if idx > 1 then
					inclinedWallDiffOutside	= skinCummThkOpp[idx - 1] / incH
				else
					inclinedWallDiffOutside = 0
				endif
			endif
			slantDiffUpper = not(bFirstSkinAtReveal exor not(gs_bTurnDir)) * bSlantedInnerSide * ((turnThk + skinThk) - (turnThk + skinThk) / cos(revealAngle))
			slantDiffLower = not(bFirstSkinAtReveal exor not(gs_bTurnDir)) * bSlantedInnerSide * (turnThk - turnThk / cos(revealAngle))

			py2 = lengthSkinTurnIn
			if gs_bTurnDir then
				slantL = slantLength - py2
			else
				slantL = slantLength - WALL_THICKNESS + py2
			endif
			px2 = distanceX + dx + turnThk + skinThk + slantL * slantX - slantDiffUpper

			if not(bStraightInside) then
				bStraightInside = (WALL_SKINS_PARAMS[idx][SKIN_THICKEN_TRAPEZOID])
			endif

			if gs_bTurnDir then
				py1 = cummThk + skinThk
				slantL = slantLength - py1
			else
				py1 = cummThk
				if bInclinedWall & not(bStraightInside) then
					py1 = WALL_THICKNESS - inclinedWallDiffInside
					py1 = py1 + (distanceX + dx + turnThk + skinThk) * incHor * sideSign * iInclDir
				endif
				slantL = slantLength - WALL_THICKNESS + py1
			endif

			if bInclinedWall & not(bStraightInside) & bSlantedInnerSide then
				x11 = 0
				y11 = WALL_THICKNESS - inclinedWallDiffInside
				x12 = x11 + incH * sideSign
				y12 = y11 + incV

				x21 = px2
				y21 = py2
				x22 = x21 + sin(revealAngle)
				y22 = y21 + cos(revealAngle)

				gosub 100	! Line - Line intersection

				px1 = cx
				py1 = cy
			else
				px1 = distanceX + dx + turnThk + skinThk + slantL * slantX - slantDiffUpper
			endif

			if gs_bTurnDir then
				bSkipThisSkin = (lengthSkinTurnIn < py1 + EPS)
			else
				bSkipThisSkin = (lengthSkinTurnIn > py1 - EPS)
			endif

			py3 = lengthSkinTurnIn
			if gs_bTurnDir then
				slantL = slantLength - py3
			else
				slantL = slantLength - WALL_THICKNESS + py3
			endif
			px3 = distanceX + dx + turnThk + slantL * slantX - slantDiffLower

			if bIncludeReveal & bFirst then
				if WIDO_SILL < EPS then
					py5 = cummThk
					px5 = distanceX + (py5 - WIDO_SILL)* tan(revealAngle)
				else
					if gs_bTurnDir exor bNegativeTurn then
						py5 = WIDO_SILL
					else
						py5 = WALL_THICKNESS - WIDO_SILL
					endif
					px5 = distanceX - bNegativeTurn * revealWidth

					if gs_bTurnDir exor bNegativeTurn then
						py6 = WIDO_SILL
					else
						py6 = WALL_THICKNESS - WIDO_SILL
					endif
					px6 = distanceX - not(bNegativeTurn) * revealWidth

					if gs_bTurnDir then
						py7 = cummThk
					else
						py7 = cummThk + skinThk
					endif
					px7 = distanceX - not(bNegativeTurn) * revealWidth
				endif
			endif

			if gs_bTurnDir then
				py4 = cummThk
				slantL = slantLength - py4
			else
				py4 = cummThk + skinThk
				if bInclinedWall & not(bStraightOutside) then
					py4 = WALL_THICKNESS - inclinedWallDiffOutside
					py4 = py4 + (distanceX + dx + turnThk) * incHor * sideSign * iInclDir
				endif
				slantL = slantLength - WALL_THICKNESS + py4
			endif

			if bInclinedWall & not(bStraightOutside) & bSlantedInnerSide then
				x11 = 0
				y11 = WALL_THICKNESS - inclinedWallDiffOutside
				x12 = x11 + incH * sideSign
				y12 = y11 + incV

				x21 = px3
				y21 = py3
				x22 = x21 + sin(revealAngle)
				y22 = y21 + cos(revealAngle)

				gosub 100	! Line - Line intersection

				px4 = cx
				py4 = cy
			else
				px4 = distanceX + dx + turnThk + (slantL)* slantX - slantDiffLower
			endif

			if not(bStraightOutside) then
				bStraightOutside = (WALL_SKINS_PARAMS[idx][SKIN_THICKEN_TRAPEZOID])
	        endif
		endif

! Draw the turned skins ========================================================

		bShowSkin = not( (GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY & WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] < EPS) | \
						 (GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) < EPS) )

		if not(bSkipThisSkin) then

			skinFillType		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL])
			skinFillFgPen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_PEN])
			skinFillBgPen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_BACK_PEN])
			skinFillOrientation	= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_ORIENTATION])
			bFitToSkinFill		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_FIT_TO_SKIN])
			skinTurnThk = skinThk

			fill skinFillType
			bLocalFill	= skinFillOrientation
			penFillFg	= skinFillFgPen
			penFillBg	= skinFillBgPen

			if gs_bTurnDir then
				bCond = (baseSkinLevel - (thkJoint + offsetFromJoint) < WIDO_SILL)
			else
				bCond = (baseSkinLevel + (thkJoint + offsetFromJoint) < WIDO_SILL)
			endif

			if bFirst & abs(slantX) > EPS & bCond then

				if gs_bTurnDir then
					boardY = by + WALL_THICKNESS - WIDO_SILL
				else
					boardY = by + WIDO_SILL
				endif
				put	px1,			py1,	0,
					px2,			py2,	0,
					bx * sideSign,	py3,	0,
					bx * sideSign,	boardY, 0,
					px4,			py4,	0
			else
				if bIncludeReveal & bFirst then
					if WIDO_SILL < EPS then
						put	px1,	py1,	0,
							px2,	py2,	0,
							px3,	py3,	0,
							px5,	py5,	0,
							px4,	py4,	0
					else
						put	px1,	py1,	0,
							px2,	py2,	0,
							px3,	py3,	3000 * curvedWall,
							px5,	py5,	0,
							px6,	py6,	0,
							px7,	py7,	0
						if px4 > px7 then
							put	px4,	py4,	3000 * curvedWall
						endif
						skinTurnThk = skinThk + revealWidth
					endif
				else
					if curvedWall & not(bWndCurved) & bFirst & not(iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | iRevealType = REVEAL_NEGATIVE) & (py3 - EPS < by) & (py4 + EPS > by) then
						xo = 0
						yo = -WOD
						ro = baseSkinRadius

						x1 = 0
						y1 = by
						x2 = 1
						y2 = by

						gosub 101	! Circle - Line intersection
						gosub 102	! Select good intersection point

						put	 px1,			py1,	0,
							 px2,			py2,	0,
							 cx,			cy,		3000,
							-sx * sideSign,	sy,		0,
							 px4,			py4,	0

						px3 = -sx * sideSign
						py3 =  sy
					else
						put	px1,	py1,	0,
							px2,	py2,	0,
							px3,	py3,	3000 * curvedWall,
							px4,	py4,	0
					endif
				endif
			endif

			if bShowSkin then
				bDrawContour = 0
				bDrawWallBlock = 1
				bClosureContour	= 0
				gosub 200	! Draw wallblock
			else
				if nsp >= 9 then
					fill 0
					wallhole2 nsp/3 + 1, 2, 0, -1,
						0, 0, 0,
						0,-WOD,900,
						get(nsp)
				else
					for ii=1 to nsp
						n = get(1)
					next ii
				endif
			endif

			if gs_bTurnDir then
				tempPen		 = round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN])
				tempLineType = round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE])
			else
				tempPen		 = round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
				tempLineType = round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])
			endif
			if tempPen > 0 & bShowSkin then
				pen			tempPen
				line_type	tempLineType
				if GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY then
					line_property LINE_PROPERTY_CONTOUR
				else
					line_property LINE_PROPERTY_INNER
				endif

				wallline2	px1,py1, px2,py2

				if not(gs_bJoint) or gs_bJoint * not(gs_showJoint) then	! Contonouous mode
					if not(bForceContinousMode) & (baseSkinFillType <> skinFillType | baseSkinFillFgPen <> skinFillFgPen | baseSkinFillBgPen <> skinFillBgPen | baseSkinFillOrientation <> skinFillOrientation) then
						if baseSkinContLinePen > EPS then
							if thkJoint < EPS then
								pen baseSkinContLinePen
							endif
							line_type	baseSkinContLineType

							wallline2 px2,py2, px3,py3
						endif
					endif
				endif
			endif

			if (iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) & not(curvedWall) then
				_turnSkinEndingLines[iTurnSkin][LINE_BEG_X]			= px2 * signX * sideSign
				_turnSkinEndingLines[iTurnSkin][LINE_BEG_Y]			= py2 * signY + offsetY
				_turnSkinEndingLines[iTurnSkin][LINE_END_X]			= px3 * signX * sideSign
				_turnSkinEndingLines[iTurnSkin][LINE_END_Y]			= py3 * signY + offsetY
				_turnSkinEndingLines[iTurnSkin][LINE_ATTRIBUTES]	= 0		! unused
				_turnSkinEndingLines[iTurnSkin][LINE_PEN_IDX]		= round_int(WALL_SKINS_PARAMS[idx][SKIN_END_FACE_PEN])
				_turnSkinEndingLines[iTurnSkin][LINE_LTYPE_IDX]		= WALL_SKINS_PARAMS[idx][SKIN_END_LINE_TYPE]
				iTurnSkin = iTurnSkin + 1
			endif

! It is needed in every cases to show the overlapping (wall contour on closure contour) edges
! because the state of "Show Opening Only" MVO function are not queried.
! If it will have a query then this line is removable back to original line.
!!!			if (iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) & (offsetFromJoint > EPS | dutchSpouwlatPx < max(px2,px3)) then
			if (iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) then
				tempPen = round_int(WALL_SKINS_PARAMS[idx][SKIN_END_FACE_PEN])
				if tempPen > 0 & bShowSkin then
					pen			tempPen
					line_type	WALL_SKINS_PARAMS[idx][SKIN_END_LINE_TYPE]
					if GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY then
						line_property LINE_PROPERTY_CONTOUR
					else
						line_property LINE_PROPERTY_INNER
					endif
					if curvedWall then
						R = sqr(px2^2 + (py2 + WOD)^2)

						vx = px2
						vy = py2 + WOD
						gosub 103	! Direction Angle
						alpha = angle

						vx = px3
						vy = py3 + WOD
						gosub 103	! Direction Angle
						beta = angle

						if abs(alpha - beta) > EPS then
							wallarc2 0,-WOD, R, min(alpha,beta), max(alpha,beta)
						endif
					else
! It is needed in every cases to show the overlapping (wall contour on closure contour) edges
! because the state of "Show Opening Only" MVO function are not queried.
! If it will have a query then this four lines are allowed again.
!!!						if offsetFromJoint > EPS | not(gs_showJoint) then
							wallline2	px2,py2, px3,py3
!!!						else
!!!							wallline2	max(dutchSpouwlatPx, px2),py2,
!!!										max(dutchSpouwlatPx, px3),py3
!!!						endif
					endif
				endif
			endif
		endif

		if gs_bTurnDir then
			tempPen		 = round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
			tempLineType = round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])
		else
			tempPen		 = round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN])
			tempLineType = round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE])
		endif

		if bIncludeReveal & bFirst then
			if WIDO_SILL < EPS then
			else
				bpx = px3
				bpy = py3
				epx = px5
				epy = py5
				penIdx		= bShowSkin  * tempPen
				lineTypeIdx	= tempLineType

				if bShowSkin then
					iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, not(bHaveShownSkinBefore))
					gosub 4920	! Put line section into Cavity Closure lines array
				else
					iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
					gosub 4910	! Put line section into wallhole lines array
				endif

				bpx = px5
				bpy = py5
				epx = px6
				epy = py6
				penIdx		= bShowSkin  * tempPen
				lineTypeIdx	= tempLineType

				if bShowSkin then
					iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, not(bHaveShownSkinBefore))
					gosub 4920	! Put line section into Cavity Closure lines array
				else
					iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
					gosub 4910	! Put line section into wallhole lines array
				endif

				bpx = px6
				bpy = py6
				epx = px7
				epy = py7
				penIdx		= bShowSkin  * tempPen
				lineTypeIdx	= tempLineType

				if bShowSkin then
					iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, not(bHaveShownSkinBefore))
					gosub 4920	! Put line section into Cavity Closure lines array
				else
					iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
					gosub 4910	! Put line section into wallhole lines array
				endif
			endif
		else
			if (not(curvedWall) & (py4 > py3 exor gs_bTurnDir)) | (curvedWall & (py4 > py3 exor wallIsLeft exor reorder exor gs_bTurnDir)) then
				bpx = px3
				bpy = py3
				epx = px4
				epy = py4
				penIdx		= bShowSkin  * tempPen
				lineTypeIdx	= tempLineType

				if bShowSkin then
					iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, not(bHaveShownSkinBefore))
					gosub 4920	! Put line section into Cavity Closure lines array
				else
					iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
					gosub 4910	! Put line section into wallhole lines array
				endif
			endif
		endif

		if bFirst & bShowSkin then
			if tempPen > 0 then
				pen			tempPen
				line_type	tempLineType
				if bHaveShownSkinBefore then
					line_property LINE_PROPERTY_INNER
				else
					line_property LINE_PROPERTY_CONTOUR
				endif

				if not(curvedWall) | (py4 < py3 exor wallIsLeft exor reorder) then
					if abs(slantX) < EPS then
						if bIncludeReveal then
							if WIDO_SILL < EPS then
								wallline2	px3,py3, px5,py5
							else
								if ((wallIsLeft exor reorder) & maxSkinTurnIn = 0) | (not(wallIsLeft exor reorder) & maxSkinTurnOut = 0) then
									line_property LINE_PROPERTY_CONTOUR
								endif

								if not(bInclinedWall & not(gs_bTurnDir)) & px4 > px7 then
									! because the top of the "bIncludeReveal" polygon does not fit to the inclined wall's slanted side
									wallline2	px4,py4, px7,py7
								endif
							endif
						else
!!!							wallline2	px3,py3, px4,py4

							bpx = px3
							bpy = py3
							epx = px4
							epy = py4
							penIdx		= tempPen
							lineTypeIdx	= tempLineType

							if bShowSkin then
								iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, not(bHaveShownSkinBefore))
								gosub 4920	! Put line section into Cavity Closure lines array
							else
								iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
								gosub 4910	! Put line section into wallhole lines array
							endif
						endif
					endif
				else
					if curvedWall & bIncludeReveal then
						R = sqr(px4^2 + (py4 + WOD)^2)

						vx = px4
						vy = py4 + WOD
						gosub 103	! Direction Angle
						alpha = angle

						vx = px7
						vy = py7 + WOD
						gosub 103	! Direction Angle
						beta = angle

						if abs(alpha - beta) > EPS then
							wallarc2 0,-WOD, R, min(alpha,beta), max(alpha,beta)
						endif
					endif
				endif

				if iRevealType = REVEAL_NEGATIVE then

					line_property LINE_PROPERTY_INNER

					if curvedWall & bWndCurved then
!						R = sqr(bx^2 + (by + WOD)^2)
!
!						vx = -bx * sideSign
!						vy =  by + WOD
!						gosub 103	! Direction Angle
!						alpha = angle
!
!						vx = -sx * sideSign
!						vy =  sy + WOD
!						gosub 103	! Direction Angle
!						beta = angle
!
!						if abs(alpha - beta) > EPS then
!							wallarc2 0,-WOD, R, min(alpha,beta), max(alpha,beta)
!						endif
						wallline2 -bx * sideSign,by, -sx * sideSign,sy
					else
						if curvedWall then
							revealY = by
							signTemp = -1
						else
							signTemp = 1
							if reorder exor wallIsLeft then
								revealY = by + WIDO_SILL
							else
								revealY = by + WALL_THICKNESS - WIDO_SILL
							endif
						endif

						wallline2	bx * signTemp * sideSign, revealY,
									sx * signTemp * sideSign, revealY
						if bDrawObjContourIn | bDrawObjContourOut then
							line2	bx * signTemp * sideSign, revealY,
									sx * signTemp * sideSign, revealY
						endif
					endif
				endif
			endif
		endif

		turnThk = turnThk + skinThk
		bHaveShownSkinBefore = bShowSkin
	next i
return


! ==============================================================================
!		Prefabricated Cavity Closure
! ------------------------------------------------------------------------------
! Input variables:
!	possibleSkinTurnIn:		number of possible plaster skins at the Outside Face
!	possibleSkinTurnOut:	number of possible plaster skins at the Inside Face
!	distanceX:				horizontal distance from the original origo
!	alfaX:					alfa x in case of curved walls (alfaX > 0)
!	alfaJamb:				jamb alfa (alfaJamb > 0)
!	revealWidth:			width of the reveal
!	skinCummThkRef:			precalculated cummulative skin thickness from the Outside Face
! ==============================================================================

"PrefabricatedCavityClosure":

!!!pen 1
!!!
!!!add2 sideSign * (distanceX + 0.2),0
!!!mul2 sideSign, 1
!!!circle2 0,0, 0.010
!!!text2 0.04,0, "mm"
!!!for i=1 to WALL_SKINS_NUMBER
!!!	idx = i
!!!
!!!	sName = "N"
!!!	if abs(WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] - 1) < EPS then sName = "C"
!!!	if abs(WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] - 3) < EPS then sName = "LC"
!!!	if abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) < EPS then sName = "P"
!!!	thk = WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
!!!
!!!!!!	gosub 10	! Get proper index
!!!	add2 0, skinCummThkRef[idx] - thk/2
!!!	circle2 0,0, 0.005
!!!	text2 0,0, sName
!!!	text2 0.04,0, thk
!!!	del 1
!!!next i
!!!del 2

	if lastCoreSkin = 0 then
		return
	endif

	nSkins = WALL_SKINS_NUMBER - possibleSkinTurnOut - possibleSkinTurnIn
	if nSkins < 3 then return

	bSlantedInnerSide	= (iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED)
	bNegativeReveal		= (iRevealType = REVEAL_NEGATIVE)

	fill gs_fillPlug
	pen gs_penPlug
	line_type gs_ltPlug
	line_property LINE_PROPERTY_INNER

	idx = possibleSkinTurnIn + 1
	gosub 10	! Get proper index
	begH = skinCummThkRef[idx]
	properBegIdx = idx

	idx = min(lastCoreSkin - 1, possibleSkinTurnIn + nSkins - 1)

	if idx < 1 then
		return
	endif

	gosub 10	! Get proper index

	endH = skinCummThkRef[idx]
	properEndIdx = idx

	if abs(endH - begH) < EPS then return

	vectS = 0
	vectC = 1

	if curvedWall then

! Curved Wall ==================================================================

		rWindowEdge = sqr((bx * sideSign)^2 + (by + WOD)^2)
		rRevealEdge = sqr((sx * sideSign)^2 + (sy + WOD)^2)

		if reorder then
			rBegH = min(radSill, radBoard) + begH
			rEndH = min(radSill, radBoard) + endH
		else
			rBegH = max(radSill, radBoard) - begH
			rEndH = max(radSill, radBoard) - endH
		endif
		plugAngle = gs_widthPlug * (180 / max(rBegH, rEndH) / PI)

		if wallIsLeft exor (iRevealType = REVEAL_NEGATIVE) then
			refH = min(rBegH, rEndH)
			oppH = max(rBegH, rEndH)
		else
			refH = max(rBegH, rEndH)
			oppH = min(rBegH, rEndH)
		endif

! Curved walls - Slanted Reveal ================================================

		if bSlantedInnerSide | bParalellInCurvedWalls then

			xo = 0
			yo = -WOD
			ro = refH

			if wallIsLeft then

				bPullBackPlug = 0

				if rWindowEdge < refH + EPS then
					bSlantedPlug = 0
				else
					bSlantedPlug = 1
				endif

				if (rWindowEdge < oppH & rWindowEdge > refH) then
					bCuttedPlug = 1
				else
					bCuttedPlug = 0
				endif
			else
				bPullBackPlug = (rWindowEdge > refH + EPS & rRevealEdge < refH + EPS)

				if rWindowEdge > refH + EPS & rRevealEdge > refH + EPS then
					bSlantedPlug = 0
				else
					bSlantedPlug = 1
				endif

				if (rWindowEdge > oppH & rWindowEdge < refH) | (rRevealEdge > oppH & rRevealEdge < refH) then
					bCuttedPlug = 1
				else
					bCuttedPlug = 0
				endif
			endif

			if bParalellInCurvedWalls then
				bCuttedPlug = 0
				bSlantedPlug =1
			endif

			if bSlantedPlug & not(bPullBackPlug) then
				if bWndCurved then
					x1 = -rSillLine * sin(alfaX)
					y1 = iArchSign * (-abs(WOD) + rSillLine * cos(alfaX))
					x2 = x1 - sin(revealAngle)
					y2 = y1 - cos(revealAngle)
				else
					x1 = -distanceX
					y1 = 0
					!!! wallThkOppSide = wallThkOppSide + max(leftWidth, rightWidth) * tan(abs(WALL_INCL)) !!!
					wallThkOppSide = 0
					x2 = -distanceX - wallThkOppSide * tan(revealAngle)
					y2 = -wallThkOppSide
				endif

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point

				alfaPlug = -signWallIsLeft * atn(cx / (WOD + cy))

				ro = oppH
				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point

				alfaPlugOpp = -signWallIsLeft * atn(cx / (WOD + cy))

				sin1 = sin(alfaPlug)
				cos1 = cos(alfaPlug) * signWallIsLeft
				sin2 = sin(alfaPlug + plugAngle)
				cos2 = cos(alfaPlug + plugAngle) * signWallIsLeft
				sin3 = sin(alfaPlugOpp)
				cos3 = cos(alfaPlugOpp) * signWallIsLeft
				if bCuttedPlug then
					if bWndCurved then
						alpha = atn(bx * sideSign / (by + WOD))
					else
						alpha = atn(distanceX / WOD)
					endif
					sin4 = sin(alpha)
					cos4 = cos(alpha)
				endif

				if wallIsLeft exor reorder then
					if bCuttedPlug then
						x1 = -rBegH * sin4 * signWallIsLeft
						y1 = -WOD + rBegH * cos4 * signWallIsLeft
					else
						x1 = -rBegH * sin3
						y1 = -WOD + rBegH * cos3
					endif
				else
					x1 = -rBegH * sin1
					y1 = -WOD + rBegH * cos1
				endif

				x2 = -rBegH * sin2
				y2 = -WOD + rBegH * cos2

				x3 = -rEndH * sin2
				y3 = -WOD + rEndH * cos2

				if bCuttedPlug then
					if wallIsLeft exor reorder then
						x4 = -rEndH * sin1
						y4 = -WOD + rEndH * cos1

						x5 = -bx * sideSign
						y5 = by
					else
						x4 = -rEndH * sin4 * signWallIsLeft
						y4 = -WOD + rEndH * cos4 * signWallIsLeft

						x5 = -bx * sideSign
						y5 = by
					endif
				else
					if wallIsLeft exor reorder then
						x4 = -rEndH * sin1
						y4 = -WOD + rEndH * cos1
					else
						x4 = -rEndH * sin3
						y4 = -WOD + rEndH * cos3
					endif
				endif

				put x1,	y1,	1,
					x2,	y2,	3001,
					x3,	y3,	1,
					x4,	y4,	3001

				if bCuttedPlug then
					put x5,y5, 1
				endif

			else	! if bSlantedPlug & not(bPullBackPlug) then

				if bPullBackPlug then
					alfaPlug = abs(atn(bx / (by + WOD)))
				else
					alfaPlug = alfaX - alfaJamb
				endif

				sin1 = sin(alfaPlug)
				cos1 = cos(alfaPlug) * signWallIsLeft
				sin2 = sin(alfaPlug + plugAngle)
				cos2 = cos(alfaPlug + plugAngle) * signWallIsLeft

				x1 = -rBegH * sin1
				y1 = -WOD + rBegH * cos1

				x2 = -rBegH * sin2
				y2 = -WOD + rBegH * cos2

				x3 = -rEndH * sin2
				y3 = -WOD + rEndH * cos2

				x4 = -rEndH * sin1
				y4 = -WOD + rEndH * cos1

				put x1,y1, 1,
					x2,y2, 3001,
					x3,y3, 1,
					x4,y4, 3001
			endif	! if bSlantedPlug & not(bPullBackPlug) then ... else

		endif	! if bSlantedInnerSide then

! bPullBackPlug ================================================================

		if bWndCurved then
			if bNegativeReveal then
				if wallIsLeft then
					bPullBackPlug = (max(rBegH, rEndH) <= rSillLine + EPS)
				else
					bPullBackPlug = (min(rBegH, rEndH) >= rSillLine - EPS)
				endif
			else
				if wallIsLeft then
					bPullBackPlug = (min(rBegH, rEndH) <= rSillLine - EPS)
				else
					bPullBackPlug = (max(rBegH, rEndH) >= rSillLine + EPS)
				endif
			endif
		else
			if wallIsLeft then
				rCorner	= max(rWindowEdge, rRevealEdge)
			else
				rCorner	= min(rWindowEdge, rRevealEdge)
			endif

			if bNegativeReveal then
				if wallIsLeft then
					bPullBackPlug = (max(rBegH, rEndH) <= rCorner + EPS)
				else
					bPullBackPlug = (min(rBegH, rEndH) >= rCorner + EPS)
				endif
			else
				rWindowInnerEdge = sqr((distanceX)^2 + (WOD - WIDO_FRAME_THICKNESS)^2)

				if wallIsLeft then
					bPullBackPlug = ((min(rBegH, rEndH) < rCorner + EPS) | (min(rBegH, rEndH) < rWindowInnerEdge + EPS))
				else
					bPullBackPlug = ((max(rBegH, rEndH) > rCorner + EPS) | (max(rBegH, rEndH) > rWindowInnerEdge + EPS))
				endif
			endif
		endif

! Curved walls - not Slanted Reveal ============================================

		if not(bSlantedInnerSide | bParalellInCurvedWalls) then

			if bPullBackPlug then
				if abs(bx) < abs(sx) exor bNegativeReveal then
					alfaPlug = abs(atn(abs(sx) / (WOD + sy)))
				else
					alfaPlug = abs(atn(abs(bx) / (WOD + by)))
				endif
			else
				alfaPlug = alfaX - alfaJamb
			endif

			alfaPlugOpp = alfaPlug

			sin1 = sin(alfaPlug)
			cos1 = cos(alfaPlug) * signWallIsLeft
			sin2 = sin(alfaPlug + plugAngle)
			cos2 = cos(alfaPlug + plugAngle) * signWallIsLeft
			sin3 = sin(alfaPlugOpp)
			cos3 = cos(alfaPlugOpp) * signWallIsLeft

			if wallIsLeft then
				x1 = -rBegH * sin1
				y1 = -WOD + rBegH * cos1
			else
				x1 = -rBegH * sin3
				y1 = -WOD + rBegH * cos3
			endif

			x2 = -rBegH * sin2
			y2 = -WOD + rBegH * cos2

			x3 = -rEndH * sin2
			y3 = -WOD + rEndH * cos2

			if wallIsLeft then
				x4 = -rEndH * sin3
				y4 = -WOD + rEndH * cos3
			else
				x4 = -rEndH * sin1
				y4 = -WOD + rEndH * cos1
			endif

			put x1,y1, 1,
				x2,y2, 3001,
				x3,y3, 1,
				x4,y4, 3001
		endif	! if bSlantedInnerSide then

	else	! if curvedWall then


! Straight and Trapezoid Wall ==================================================

		if wallIsLeft exor bNegativeReveal exor reorder then
			if iRevealType = REVEAL_NEGATIVE then
				revealLevel = WALL_THICKNESS - WIDO_SILL
			else
				revealLevel = WIDO_SILL
			endif
			bPullBackPlug = (endH - EPS > revealLevel)
		else
			if iRevealType = REVEAL_NEGATIVE then
				revealLevel = WIDO_SILL
			else
				revealLevel = WALL_THICKNESS - WIDO_SILL
			endif
			bPullBackPlug = (begH + EPS < revealLevel)
		endif

		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
			posPlug = distanceX
			bPullBackPlug = 0
		endif
		if iRevealType = REVEAL_POSITIVE then
			posPlug = distanceX - not(bPullBackPlug) * revealWidth
		endif
		if iRevealType = REVEAL_NEGATIVE then
			posPlug = distanceX - bPullBackPlug * revealWidth
		endif
		if iRevealType = REVEAL_SLANTED then
			posPlug = distanceX - not(bPullBackPlug) * revealWidth
		endif

		if bSlantedInnerSide & bPullBackPlug then
			if wallIsLeft exor reorder then
				sillLine = WIDO_SILL
			else
				sillLine = WALL_THICKNESS - WIDO_SILL
			endif

			if wallIsLeft exor reorder then
				refH = endH
				oppH = begH
			else
				refH = begH
				oppH = endH
			endif

			x11 = distanceX
			y11 = sillLine
			x12 = x11 + sin(revealAngle)
			y12 = y11 + signWallIsLeft * signReorder * cos(revealAngle)

			x21 = 0
			y21 = refH
			x22 = 1
			y22 = refH

			gosub 100	! Line - Line intersection

			if sillLine < endH & sillLine > begH then
				put posPlug, sillLine, 1,
					posPlug, oppH, 1
			else
				put cx - (endH-begH) * tan(revealAngle), oppH, 1
			endif

			put	cx + gs_widthPlug, oppH, 1,
				cx + gs_widthPlug, refH, 1,
				cx, refH, 1
		else
			put	posPlug, begH, 1,
				posPlug, endH, 1,
				posPlug + gs_widthPlug, endH, 1,
				posPlug + gs_widthPlug, begH, 1
		endif

	endif	! if curvedWall then

! Draw Insulation Plug =========================================================

	if GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY then
		for ii=1 to nsp
			n = get(1)
		next ii
	else
		bLocalFill	= 0
		penFillFg	= gs_penPlugFg
		penFillBg	= gs_penPlugBg
		bDrawContour	= 1
		bFitToSkinFill	= 0
		bDrawWallBlock	= 1
		bClosureContour	= 0

		penIdx		= gs_penPlug
		lineTypeIdx	= gs_ltPlug

		gosub 200	! Draw wallblock with contour
	endif


! Draw wall skin part ==========================================================

	if (wallIsLeft exor bNegativeReveal exor reorder) | bInclinedWall then
		if iRevealType = REVEAL_NEGATIVE & bInclinedWall then
			y1 = revealLevel
			y2 = endH
			if reorder then
				idx = properEndIdx - 1
			else
				idx = properEndIdx + 1
			endif
		else
			y1 = begH
			y2 = revealLevel
			idx = properBegIdx
		endif
	else
		y1 = revealLevel
		y2 = endH
		if reorder then
			idx = properEndIdx - 1
		else
			idx = properEndIdx + 1
		endif
	endif

	skinThickness = WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]

	bShowSkin = not( (GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY & WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] < EPS) | \
					 (GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) < EPS) )

!!!	if bShowSkin then
		if curvedWall then
			if (bPullBackPlug exor bNegativeReveal) & iRevealType > REVEAL_NO then
				aWindowEdge = atn(bx * sideSign / (by + WOD))
				aRevealEdge = atn(sx * sideSign / (sy + WOD))

				px1 = -bx * sideSign
				py1 =  by

				px2 = -sx * sideSign
				py2 =  sy

				if bParalellInCurvedWalls then
					xo = 0
					yo = -WOD
					ro = oppH

					x1 = px2
					y1 = py2
					x2 = x1
					y2 = y1 + 1

					gosub 101	! Circle - Line intersection
					gosub 102	! Select good intersection point
					px3 = cx
					py3 = cy

					px33 = px3
					py33 = sqr((ro + skinThickness)^2 - px33^2) - WOD

					x1 = px1
					y1 = py1
					x2 = x1
					y2 = y1 + 1

					gosub 101	! Circle - Line intersection
					gosub 102	! Select good intersection point
					px4 = cx
					py4 = cy

					px44 = px4
					py44 = sqr((ro - skinThickness)^2 - px44^2) - WOD
				else
					px3 = -signWallIsLeft * oppH * sin(aRevealEdge)
					py3 = -WOD + signWallIsLeft * oppH * cos(aRevealEdge)

					px33 = -signWallIsLeft * (oppH + skinThickness) * sin(aRevealEdge)
					py33 = -WOD + signWallIsLeft * (oppH + skinThickness) * cos(aRevealEdge)

					px4 = -signWallIsLeft * oppH * sin(aWindowEdge)
					py4 = -WOD + signWallIsLeft * oppH * cos(aWindowEdge)

					px44 = -signWallIsLeft * (oppH - skinThickness) * sin(aWindowEdge)
					py44 = -WOD + signWallIsLeft * (oppH - skinThickness) * cos(aWindowEdge)
				endif

				bSkip4 = (abs(px1 - px4) < EPS & abs(py1 - py4) < EPS)		! Avoid generating invalid polygon

				put	px1, py1, 0,
					px2, py2, 3000 * bWndCurved + 1

				if wallIsLeft then
					if bWndCurved then
						if not(bNegativeReveal) & oppH > rWindowEdge + EPS & refH < rWindowEdge - EPS then
							put px3, py3, 0,
								px4, py4, 3000
						endif
						if bNegativeReveal & refH > rWindowEdge + EPS & oppH < rWindowEdge - EPS then
							put px3, py3, 0,
								px4, py4, 3000
						endif
					else
						bOutPoint = 0
						if py3 > py2 exor bNegativeReveal then
							put px3, py3, 0
							bOutPoint = 1
						endif
						if (py4 > py1 exor bNegativeReveal) & not(bSkip4) then
							put px4, py4, 3000 * bOutPoint
						endif
					endif
				else
					if bWndCurved then
						if not(bNegativeReveal) & refH > rWindowEdge + EPS & oppH < rWindowEdge - EPS then
							put px3, py3, 0,
								px4, py4, 3000
						endif
						if bNegativeReveal & oppH > rWindowEdge + EPS & refH < rWindowEdge - EPS then
							put px3, py3, 0,
								px4, py4, 3000
						endif
					else
						bOutPoint = 0
						if py3 > py2 exor bNegativeReveal then
							put px3, py3, 0
							bOutPoint = 1
						endif
						if (py4 > py1 exor bNegativeReveal) & not(bSkip4) then
							put px4, py4, 3000 * bOutPoint
						endif
					endif
				endif

				fill		  round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL])
				bLocalFill	= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_ORIENTATION])
				penFillFg	= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_PEN])
				penFillBg	= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_BACK_PEN])

				if WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN] > EPS then
					pen WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN]
					line_type WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE]
					line_property LINE_PROPERTY_INNER
					bDrawContour = 1

					penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN])
					lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE])
				else
					bDrawContour = 0
				endif
				bFitToSkinFill = 0
				bDrawWallBlock = 1
				bClosureContour	= 0

				if bShowSkin then
					gosub 200	! Draw wallblock with contour
				else
					if nsp >= 9 then
						fill 0
						wallhole2 nsp/3 + 1, 2, 0, -1,
							0, 0, 0,
							0,-WOD,900,
							get(nsp)
					else
						for ii=1 to nsp
							n = get(1)
						next ii
					endif
				endif

				penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_END_FACE_PEN])
				lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_END_LINE_TYPE])
				lineProperty= LINE_PROPERTY_INNER

				if penIdx > 0 then
!!!					pen				penIdx
!!!					line_type		lineTypeIdx
!!!					line_property	lineProperty

!!!					wallline2 px1,py1, px2,py2
					bpx = px1
					bpy = py1
					epx = px2
					epy = py2
					penIdx	= bShowSkin * penIdx

					if bShowSkin then
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, not(bHaveShownSkinBefore))
						gosub 4920	! Put line section into Cavity Closure lines array
					else
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
						gosub 4910	! Put line section into wallhole lines array
					endif
				endif

				if (wallIsLeft exor bNegativeReveal exor reorder) then
					penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
					lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])
				else
					penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN])
					lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE])
				endif
				lineProperty	= LINE_PROPERTY_INNER

				if penIdx > 0 then
!!!					pen				penIdx
!!!					line_type		lineTypeIdx
!!!					line_property	lineProperty

					if bNegativeReveal then
!!!						wallline2 px1,py1, px44,py44
						bpx = px1
						bpy = py1
						epx = px44
						epy = py44
					else
!!!						wallline2 px2,py2, px33,py33
						bpx = px2
						bpy = py2
						epx = px33
						epy = py33
					endif
					penIdx	= bShowSkin * penIdx

					if bShowSkin then
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, not(bHaveShownSkinBefore))
						gosub 4920	! Put line section into Cavity Closure lines array
					else
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
						gosub 4910	! Put line section into wallhole lines array
					endif
				endif
			endif

		else	! if curvedWall then

			if bPullBackPlug then
				x1 = distanceX
				if iRevealType = REVEAL_POSITIVE then x2 = distanceX - revealWidth
				if iRevealType = REVEAL_NEGATIVE then x2 = distanceX - revealWidth
				if iRevealType = REVEAL_SLANTED  then x2 = distanceX - revealWidth

				if y2 > y1 & abs(x1 - x2) > EPS then
					if bShowSkin then
						fill		 WALL_SKINS_PARAMS[idx][SKIN_FILL]
						bLocalFill = round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_ORIENTATION])
						wallblock2 4, 2 + 24 * bLocalFill + 32,
							WALL_SKINS_PARAMS[idx][SKIN_FILL_PEN],
							WALL_SKINS_PARAMS[idx][SKIN_FILL_BACK_PEN],
							0,0,0,
							x1, y1, 0,
							x1, y2, 0,
							x2, y2, 0,
							x2, y1, 0
					else
						fill 0
						wallblock2 4, 2, 0, -1,
							0,0,0,
							x1, y1, 0,
							x1, y2, 0,
							x2, y2, 0,
							x2, y1, 0
					endif
				endif

				penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_END_FACE_PEN])
				lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_END_LINE_TYPE])
				lineProperty= LINE_PROPERTY_INNER

				if penIdx > 0 then
!!!					pen				penIdx
!!!					line_type		lineTypeIdx
!!!					line_property	lineProperty

					if (wallIsLeft exor bNegativeReveal exor reorder) then
!!!						wallline2 x1,y2, x2,y2
						bpx = x1
						bpy = y2
						epx = x2
						epy = y2
					else
!!!						wallline2 x1,y1, x2,y1
						bpx = x1
						bpy = y1
						epx = x2
						epy = y1
					endif
					penIdx	= bShowSkin * penIdx

					if bShowSkin then
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, not(bHaveShownSkinBefore))
						gosub 4920	! Put line section into Cavity Closure lines array
					else
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
						gosub 4910	! Put line section into wallhole lines array
					endif
				endif

				if (wallIsLeft exor bNegativeReveal exor reorder) then
					penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
					lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])
				else
					penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN])
					lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE])
				endif
				lineProperty	= LINE_PROPERTY_INNER

				if penIdx > 0 then
!!!					pen				penIdx
!!!					line_type		lineTypeIdx
!!!					line_property	lineProperty

					if bNegativeReveal then
						if (wallIsLeft exor reorder) then
!!!							wallline2 x1,y1, x1,y2 + skinThickness
							bpx = x1
							bpy = y1
							epx = x1
							epy = y2 + skinThickness
						else
!!!							wallline2 x1,y1 - skinThickness, x1,y2
							bpx = x1
							bpy = y1 - skinThickness
							epx = x1
							epy = y2
						endif
					else
						if (wallIsLeft exor reorder) then
!!!							wallline2 x2,y1 - skinThickness, x2,y2
							bpx = x2
							bpy = y1 - skinThickness
							epx = x2
							epy = y2
						else
!!!							wallline2 x2,y1, x2,y2 + skinThickness
							bpx = x2
							bpy = y1
							epx = x2
							epy = y2 + skinThickness
						endif
					endif
					penIdx	= bShowSkin * penIdx

					if bShowSkin then
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, not(bHaveShownSkinBefore))
						gosub 4920	! Put line section into Cavity Closure lines array
					else
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
						gosub 4910	! Put line section into wallhole lines array
					endif
				endif
			endif

		endif	! if curvedWall then
!!!	endif
return




! ==============================================================================
!		Custom Cavity Closure
! ------------------------------------------------------------------------------
! Input variables:
!	possibleSkinTurnIn:		number of possible plaster skins at the Outside Face
!	possibleSkinTurnOut:	number of possible plaster skins at the Inside Face
!	distanceX:				horizontal distance from the original origo
!	alfaX:					alfa x in case of curved walls (alfaX > 0)
!	alfaJamb:				jamb alfa (alfaJamb > 0)
!	revealWidth:			width of the reveal
!	arrayCustomCC:			custom cavity closure skin data
!	sillPx, sillPy:			sill side wall edge point
!	boardPx, boardPy:		board side wall edge point
!	frameSillX, frameSillY:
!	frameBoardX, frameBoardY:
! ==============================================================================

"CustomCavityClosure":

!###################################
bUseTurnPlaster = 1
!###################################

	if bUseTurnPlaster then
		nSkins = WALL_SKINS_NUMBER - possibleSkinTurnOut - possibleSkinTurnIn
	else
		nSkins = WALL_SKINS_NUMBER
	endif
	if nSkins < 2 then return

	if wallIsLeft exor reorder then
		revealWidthIn	= revealWidthInner
		revealWidthOut	= revealWidth
	else
		revealWidthIn	= revealWidth
		revealWidthOut	= revealWidthInner
	endif

	if bInclinedWall then
		diffWallThk = WALL_THICKNESS - skinCummThkRef[WALL_SKINS_NUMBER]
	else
		diffWallThk = 0
	endif

	revealWidthAct = revealWidthIn
	bTurnSide = 0
	gosub 4001

	revealWidthAct = revealWidthOut
	bTurnSide = 1
	gosub 4001
return


4001:

! Turn Skins - Custom Cavity Closure ===========================================

	turnThk = 0

	signOverhang = not(bTurnSide) - bTurnSide

	if bUseTurnPlaster then
		if bTurnSide then
			startCount	= possibleSkinTurnIn + 1
			endCount	= WALL_SKINS_NUMBER - possibleSkinTurnOut
		else
			startCount	= possibleSkinTurnOut + 1
			endCount	= WALL_SKINS_NUMBER - possibleSkinTurnIn
		endif
	else
		startCount	= 1
		endCount	= WALL_SKINS_NUMBER
	endif

	endCount = min(4, endCount)

	if not(bTurnSide) exor wallIsLeft exor reorder then
		refX = sillPx
		refY = sillPy

		refX2 = sillPx2
		refY2 = sillPy2

		frameX		= frameSillX
		frameY		= frameSillY
		frameXopp	= frameBoardX
		frameYopp	= frameBoardY
	else
		refX = boardPx
		refY = boardPy

		refX2 = boardPx
		refY2 = boardPy

		frameX		= frameBoardX
		frameY		= frameBoardY
		frameXopp	= frameSillX
		frameYopp	= frameSillY
	endif

	if not(not(bTurnSide) exor bFirstSkinAtReveal) & bSlantedInnerSide then
		vectS = -sin(revealAngle) * signWallIsLeft
		vectC =  cos(revealAngle)
		vectT =  tan(revealAngle)

		vectS2 = vectS
		vectC2 = vectC
		vectT2 = vectT
	else
		if curvedWall & not(bParalellInCurvedWalls) then
			alpha = atn(refX / (refY + WOD))
			vectS = sin(alpha) * sideSign * signWallIsLeft
			vectC = cos(alpha)
			vectT = tan(alpha)

			vectS2 = vectS
			vectC2 = vectC
			vectT2 = vectT
		else
			if bSlantedOuterSide then
				vectS = sin(revealSillAngle) * signWallIsLeft
				vectC = cos(revealSillAngle)
				vectT = tan(revealSillAngle)
			else
				vectS = 0
				vectC = 1
				vectT = 0
			endif

			vectS2 = 0
			vectC2 = 1
			vectT2 = 0
		endif
	endif

	jdx = startCount - 1 + (4 * not(bTurnSide))	! First arrayCustomCC index

	if startCount = 1 then
		bShowPrevSkin = 0
	else
		if bTurnSide then
			idx = startCount - 1: gosub 10	! Get proper index
		else
			idx = WALL_SKINS_NUMBER - (startCount - 1) + 1: gosub 10	! Get proper index
		endif
		bShowPrevSkin = not((GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY & WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] < EPS) | \
							(GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) < EPS))
	endif

	for i = startCount to endCount

		if i = WALL_SKINS_NUMBER then
			bShowNextSkin = 0
		else
			if bTurnSide then
				idx = i + 1: gosub 10	! Get proper index
			else
				idx = WALL_SKINS_NUMBER - (i + 1) + 1: gosub 10	! Get proper index
			endif
			bShowNextSkin = not((GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY & WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] < EPS) | \
								(GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) < EPS))
		endif

		jdx = jdx + 1

!###################################
!arrayCustomCC[jdx][CUSTOMCC_OVERHANG] = 0.05 * i !!!*  (i <> startCount + 1)
!arrayCustomCC[jdx][CUSTOMCC_BITFIELD] = 1 + 2 + 4 + 8 !!!- (i = startCount + 1)	! A masodik reteget nem forgatom
!arrayCustomCC[jdx][CUSTOMCC_THICKNESS] = 0.02 * i
!###################################

		iBitfield = round_int(arrayCustomCC[jdx][CUSTOMCC_BITFIELD])
		bTurnSkin				= bittest(iBitfield, 0)
		bCustomThickness		= bittest(iBitfield, 1)
		bTurnedHatchOriantation	= bittest(iBitfield, 2)
		bSeparatingLine			= bittest(iBitfield, 3)

		bFirst	= (i = 1)
		bLast	= (i = endCount)

! Skin Geometry Calculations ===================================================

		if bTurnSkin then
			if bTurnSide then
				idx = i: gosub 10	! Get proper index
			else
				idx = WALL_SKINS_NUMBER - i + 1: gosub 10	! Get proper index
			endif

			skinThk = WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
			if bCustomThickness then
				skinTurnThk = arrayCustomCC[jdx][CUSTOMCC_THICKNESS]
			else
				skinTurnThk = skinThk
			endif
			if skinTurnThk < EPS then bTurnSkin = 0

			if reorder then
				cummThk = skinCummThkRef[idx + 1]
			else
				if idx > 1 then
					cummThk = skinCummThkRef[idx - 1]
				else
					cummThk = 0
				endif
			endif

			if bInclinedWall then
				if reorder then
					if idx > 1 then
						cummThkInc = skinCummThkOpp[idx - 1]
					else
						cummThkInc = 0
					endif
				else
					cummThkInc = skinCummThkOpp[idx + 1]
				endif
			endif

			bSkipThisSkin		= 0

			! Turned skin consist of a slanted and a perpendicular part (REVEAL_DOUBLE_SPLAYED or REVEAL_OUTSIDE_SPLAYED)
			bDoubleSplayedSkin	= (bSlantedOuterSide & (not(bTurnSide) exor bFirstSkinAtReveal))

! Curved Wall ==================================================================

			frameOffset = (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) * gs_mountingFrame * gs_mountingFrame_depth

			lengthSkinTurnOvhg	= arrayCustomCC[jdx][CUSTOMCC_OVERHANG]
			if wallIsLeft exor reorder then
				lengthSkinTurnToFrame	= WIDO_SILL + not(bTurnSide) * WIDO_FRAME_THICKNESS
				lengthSkinTurnIn		= lengthSkinTurnToFrame - signOverhang * lengthSkinTurnOvhg
			else
				lengthSkinTurnToFrame	= WALL_THICKNESS - WIDO_SILL - bTurnSide * WIDO_FRAME_THICKNESS
				lengthSkinTurnIn		= lengthSkinTurnToFrame - signOverhang * lengthSkinTurnOvhg
			endif

			if not(bTurnSide) exor bFirstSkinAtReveal then
				if wallIsLeft exor reorder then
					lengthSkinTurnToFrame = lengthSkinTurnToFrame - frameOffset
					lengthSkinTurnIn = lengthSkinTurnIn - frameOffset
				else
					lengthSkinTurnToFrame = lengthSkinTurnToFrame + frameOffset
					lengthSkinTurnIn = lengthSkinTurnIn + frameOffset
				endif
			endif

			bSplittedSkin = 0

			if curvedWall then

! p1 point ---------------------------------------------------------------------

				xo = 0
				yo = -WOD
				if bFirstSkinAtReveal then
					ro = radSill  - cummThk * signReorder - skinThk * not(bTurnSide) * signReorder
				else
					ro = radBoard - cummThk * signReorder - skinThk * not(bTurnSide) * signReorder
				endif

				if bFirstSkinAtReveal then
					x2 = -refX * sideSign - (turnThk + skinTurnThk) * vectC
					y2 =  refY			  - (turnThk + skinTurnThk) * vectS * signReorder
				else
					x2 = -refX * sideSign - (turnThk + skinTurnThk) * vectC
					y2 =  refY			  + (turnThk + skinTurnThk) * vectS * signReorder
				endif
				x1 = x2 + vectS
				y1 = y2 - vectC * signWallIsLeft

!line2 x1,y1, x2,y2
!circle2 xo,yo, ro
				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px1 = cx
				py1 = cy
!circle2 px1,py1, 0.01

! p11 point --------------------------------------------------------------------

				xo = 0
				yo = -WOD
				if bFirstSkinAtReveal then
					ro = radSill  - (cummThk + skinThk * bTurnSide) * signReorder
				else
					ro = radBoard - (cummThk + skinThk * bTurnSide) * signReorder
				endif

				if bFirstSkinAtReveal then
					x2 = -refX * sideSign - (turnThk + skinTurnThk) * vectC
					y2 =  refY			  - (turnThk + skinTurnThk) * vectS * signReorder
				else
					x2 = -refX * sideSign - (turnThk + skinTurnThk) * vectC
					y2 =  refY			  + (turnThk + skinTurnThk) * vectS * signReorder
				endif
				x1 = x2 + vectS
				y1 = y2 - vectC * signWallIsLeft

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px11 = cx
				py11 = cy
!circle2 px11,py11, 0.01

				! Select a better point if (px1,py1) zero
				if abs(px1) < EPS & abs(py1) < EPS then
					px1 = px11
					py1 = py11
				endif

! p2 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x12 = -refX2 * sideSign - (turnThk + skinTurnThk) * vectC2
					y12 =  refY2			- (turnThk + skinTurnThk) * vectS2 * signReorder
				else
					x12 = -refX2 * sideSign - (turnThk + skinTurnThk) * vectC2
					y12 =  refY2			+ (turnThk + skinTurnThk) * vectS2 * signReorder
				endif
				x11 = x12 + vectS2
				y11 = y12 - vectC2 * signWallIsLeft

				x21 = 0
				y21 = -not(bFirstSkinAtReveal) * WIDO_FRAME_THICKNESS - lengthSkinTurnOvhg * signReorder
				if bFirstSkinAtReveal exor bTurnSide then
					y21 = -WIDO_FRAME_THICKNESS + lengthSkinTurnOvhg
				else
					y21 = -lengthSkinTurnOvhg + frameOffset
				endif
				x22 = 1
				y22 = y21

!line2 x11,y11, x12,y12
!line2 x21,y21, x22,y22

				gosub 100	! Line - Line intersection

				px2 = cx
				py2 = cy
!pen i
!circle2 px2,py2, 0.005

! A befordulas melysege kisebb, mint a befordulo reteg teteje
if bFirstSkinAtReveal exor bTurnSide then
	if py11 > py2 then
		bSkipThisSkin = 1
	endif
else
	if py11 < py2 then
		bSkipThisSkin = 1
	endif
endif

				if px2 > -frameX * sideSign then
					newPy2 = -not(wallIsLeft exor reorder exor not(bTurnSide)) * WIDO_FRAME_THICKNESS
					px2 = px2 - (newPy2 - py2) * vectT * sideSign
					py2 = newPy2
					bPy2AtFrame = 1
				else
					bPy2AtFrame = 0
				endif
!circle2 px2,py2, 0.01
!circle2 -frameX * sideSign,py2, 0.02
!line2 -frameX * sideSign,py2, -frameX * sideSign + 0.1,py2

! p4 point ---------------------------------------------------------------------

				xo = 0
				yo = -WOD
				if bFirstSkinAtReveal then
					ro = radSill  - cummThk * signReorder - skinThk * not(bTurnSide) * signReorder
				else
					ro = radBoard - cummThk * signReorder - skinThk * not(bTurnSide) * signReorder
				endif

				if bFirstSkinAtReveal then
					x2 = -refX * sideSign - (turnThk) * vectC
					y2 =  refY			  - (turnThk) * vectS * signReorder
				else
					x2 = -refX * sideSign - (turnThk) * vectC
					y2 =  refY			  + (turnThk) * vectS * signReorder
				endif
				x1 = x2 + vectS
				y1 = y2 - vectC * signWallIsLeft

!line2 x1,y1, x2,y2
!circle2 xo,yo, ro
				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px4 = cx
				py4 = cy

! p3 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x12 = -refX2 * sideSign - (turnThk) * vectC2
					y12 =  refY2			  - (turnThk) * vectS2 * signReorder
				else
					x12 = -refX2 * sideSign - (turnThk) * vectC2
					y12 =  refY2			  + (turnThk) * vectS2 * signReorder
				endif
				x11 = x12 + vectS2
				y11 = y12 - vectC2 * signWallIsLeft

				x21 = 0
				if bFirstSkinAtReveal exor bTurnSide then
					y21 = -WIDO_FRAME_THICKNESS + lengthSkinTurnOvhg
				else
					y21 = -lengthSkinTurnOvhg + frameOffset
				endif
				x22 = 1
				y22 = y21

!pen i
!line2 x11,y11, x12,y12
!line2 x21,y21, x22,y22
				gosub 100	! Line - Line intersection

				px3 = cx
				py3 = cy
!circle2 px3,py3, 0.01
!circle2 -bx * sideSign,py3, 0.02

				if px3 > -frameX * sideSign then
					newPy3 = -not(wallIsLeft exor reorder exor not(bTurnSide)) * WIDO_FRAME_THICKNESS
					px3 = px3 - (newPy3 - py3) * vectT2 * sideSign
					py3 = newPy3
					bPy3AtFrame = 1
				else
					bPy3AtFrame = 0
				endif
!circle2 px3,py3, 0.01

! p22, p33 points --------------------------------------------------------------

				if not(bSkipThisSkin) & bPy2AtFrame <> bPy3AtFrame then
					bSplittedSkin = 1

					x11 = -frameX * sideSign
					y11 = -frameY
					x12 = -frameXopp * sideSign
					y12 = -frameYopp

					gosub 100	! Line - Line intersection

					px22 = cx
					py22 = cy
!pen 20
!circle2 x11,y11,0.008
!circle2 px22,py22,0.008

					px33 = -frameX * sideSign
					py33 = py3
				endif


				if not(bSkipThisSkin) & bDoubleSplayedSkin then

! p44  point -------------------------------------------------------------------

					if bFirstSkinAtReveal then
						x12 = -refX * sideSign - turnThk * vectC
						y12 =  refY			   - turnThk * vectS * signReorder
					else
						x12 = -refX * sideSign - turnThk * vectC
						y12 =  refY			   + turnThk * vectS * signReorder
					endif
					x11 = x12 + vectS
					y11 = y12 - vectC * signWallIsLeft

					if bFirstSkinAtReveal then
						x22 = -refX2 * sideSign - turnThk * vectC2
						y22 =  refY2			- turnThk * vectS2 * signReorder
					else
						x22 = -refX2 * sideSign - turnThk * vectC2
						y22 =  refY2			+ turnThk * vectS2 * signReorder
					endif
					x21 = x22 + vectS2
					y21 = y22 - vectC2 * signWallIsLeft

					gosub 100	! Line - Line intersection
					px44 = cx
					py44 = cy

! Special case check -----------------------------------------------------------

					if py44 > py4 then
						if bFirstSkinAtReveal then
							x2 = -refX2 * sideSign - turnThk * vectC2
							y2 =  refY2			   - turnThk * vectS2 * signReorder
						else
							x2 = -refX2 * sideSign - turnThk * vectC2
							y2 =  refY2			   + turnThk * vectS2 * signReorder
						endif
						x1 = x2 + vectS2
						y1 = y2 - vectC2 * signWallIsLeft

						xo = 0
						yo = -WOD
						if bFirstSkinAtReveal then
							ro = radSill  - cummThk * signReorder - skinThk * not(bTurnSide) * signReorder
						else
							ro = radBoard - cummThk * signReorder - skinThk * not(bTurnSide) * signReorder
						endif

						gosub 101	! Circle - Line intersection
						gosub 102	! Select good intersection point
						px4 = cx
						py4 = cy

						px44 = cx
						py44 = cy
					endif

! p55  point -------------------------------------------------------------------

					if bFirstSkinAtReveal then
						x12 = -refX * sideSign - (turnThk + skinTurnThk) * vectC
						y12 =  refY			   - (turnThk + skinTurnThk) * vectS * signReorder
					else
						x12 = -refX * sideSign - (turnThk + skinTurnThk) * vectC
						y12 =  refY			   + (turnThk + skinTurnThk) * vectS * signReorder
					endif
					x11 = x12 + vectS
					y11 = y12 - vectC * signWallIsLeft

					if bFirstSkinAtReveal then
						x22 = -refX2 * sideSign - (turnThk + skinTurnThk) * vectC2
						y22 =  refY2			- (turnThk + skinTurnThk) * vectS2 * signReorder
					else
						x22 = -refX2 * sideSign - (turnThk + skinTurnThk) * vectC2
						y22 =  refY2			+ (turnThk + skinTurnThk) * vectS2 * signReorder
					endif
					x21 = x22 + vectS2
					y21 = y22 - vectC2 * signWallIsLeft

					gosub 100	! Line - Line intersection
					px55 = cx
					py55 = cy

! Special case check -----------------------------------------------------------

					if py55 > py11 then
						if bFirstSkinAtReveal then
							x2 = -refX2 * sideSign - (turnThk + skinTurnThk) * vectC2
							y2 =  refY2			   - (turnThk + skinTurnThk) * vectS2 * signReorder
						else
							x2 = -refX2 * sideSign - (turnThk + skinTurnThk) * vectC2
							y2 =  refY2			   + (turnThk + skinTurnThk) * vectS2 * signReorder
						endif
						x1 = x2 + vectS2
						y1 = y2 - vectC2 * signWallIsLeft

						xo = 0
						yo = -WOD
						if bFirstSkinAtReveal then
							ro = radSill  - (cummThk + skinThk * bTurnSide) * signReorder
						else
							ro = radBoard - (cummThk + skinThk * bTurnSide) * signReorder
						endif

						gosub 101	! Circle - Line intersection
						gosub 102	! Select good intersection point
						px11 = cx
						py11 = cy

						px55 = cx
						py55 = cy
					endif

					if py55 < py2 then
						if bFirstSkinAtReveal then
							x12 = -refX * sideSign - (turnThk + skinTurnThk) * vectC
							y12 =  refY			   - (turnThk + skinTurnThk) * vectS * signReorder
						else
							x12 = -refX * sideSign - (turnThk + skinTurnThk) * vectC
							y12 =  refY			   + (turnThk + skinTurnThk) * vectS * signReorder
						endif
						x11 = x12 + vectS
						y11 = y12 - vectC * signWallIsLeft

						x21 = 0
						y21 = -not(bFirstSkinAtReveal) * WIDO_FRAME_THICKNESS - lengthSkinTurnOvhg * signReorder
						if bFirstSkinAtReveal exor bTurnSide then
							y21 = -WIDO_FRAME_THICKNESS + lengthSkinTurnOvhg
						else
							y21 = -lengthSkinTurnOvhg + frameOffset
						endif
						x22 = 1
						y22 = y21

						gosub 100	! Line - Line intersection

						px2 = cx
						py2 = cy

						px55 = cx
						py55 = cy
					endif

				endif

			else

! Straight Wall, Trapezoid Wall ================================================

				if bInclinedWall then
					if reorder then
						bSlantedSkin	 = (trapezoidCoreSkinIdx >= idx)
						bSlantedSkinNext = (trapezoidCoreSkinIdx >  idx)
					else
						bSlantedSkin	 = (trapezoidCoreSkinIdx <= idx)
						bSlantedSkinNext = (trapezoidCoreSkinIdx <  idx)
					endif
				else
					bSlantedSkin = 0
				endif

! p1 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x12 = refX * sideSign + (turnThk + skinTurnThk) * vectC
					y12 = (refY - offsetY) * signWallIsLeft * signReorder + (turnThk + skinTurnThk) * vectS * signWallIsLeft
				else
					x12 = refX * sideSign + (turnThk + skinTurnThk) * vectC
					y12 = (refY - offsetY) * signWallIsLeft * signReorder	- (turnThk + skinTurnThk) * vectS * signWallIsLeft
				endif
				x11 = x12 + vectS * signWallIsLeft
				y11 = y12 - vectC * signWallIsLeft * signReorder

				x21 = 0
				x22 = 1
				if bSlantedSkin then
					! Splanted skin eseten a slanted oldal felol szamoljuk a retegeket
					y21  = skinCummThkRef[WALL_SKINS_NUMBER] + diffWallThk - cummThkInc / incH
					y22 = y21 + incHor * iInclDir * sideSign
				else
					if bTurnSide then
						y21 = cummThk
					else
						y21 = cummThk + skinThk
					endif
					y22 = y21
				endif

				gosub 100	! Line - Line intersection
				px1 = cx
				py1 = cy

! Special case check -----------------------------------------------------------

				if px1 < distanceX & ((py1 < lengthSkinTurnToFrame + EPS) exor bTurnSide) then
					bInvalidRasterSection = 1
				else
					bInvalidRasterSection = 0
				endif

! p11 point --------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x12 = refX * sideSign + (turnThk + skinTurnThk) * vectC
					y12 = (refY - offsetY) * signWallIsLeft * signReorder + (turnThk + skinTurnThk) * vectS * signWallIsLeft
				else
					x12 = refX * sideSign + (turnThk + skinTurnThk) * vectC
					y12 = (refY - offsetY) * signWallIsLeft * signReorder	- (turnThk + skinTurnThk) * vectS * signWallIsLeft
				endif
				x11 = x12 + vectS * signWallIsLeft
				y11 = y12 - vectC * signWallIsLeft * signReorder

				x21 = 0
				x22 = 1
				if bSlantedSkinNext then
					! Splanted skin eseten a slanted oldal felol szamoljuk a retegeket
					y21  = skinCummThkRef[WALL_SKINS_NUMBER] + diffWallThk - (cummThkInc + skinThk) / incH
					y22 = y21 + incHor * iInclDir * sideSign
				else
					if bTurnSide then
						y21 = cummThk + skinThk
					else
						y21 = cummThk
					endif
					y22 = y21
				endif

				gosub 100	! Line - Line intersection
				px11 = cx
				py11 = cy

! Special case check -----------------------------------------------------------

				! A befordulas melysege kisebb, mint a befordulo reteg teteje
				if bTurnSide then
					bSkipThisSkin = (lengthSkinTurnIn < py1 + EPS)
				else
					bSkipThisSkin = (lengthSkinTurnIn > py1 - EPS)
				endif

! p2 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x12 = refX2 * sideSign + (turnThk + skinTurnThk) * vectC2
					y12 = (refY2 - offsetY) * signWallIsLeft * signReorder + (turnThk + skinTurnThk) * vectS2 * signWallIsLeft
				else
					x12 = refX2 * sideSign + (turnThk + skinTurnThk) * vectC2
					y12 = (refY2 - offsetY) * signWallIsLeft * signReorder	- (turnThk + skinTurnThk) * vectS2 * signWallIsLeft
				endif
				x11 = x12 + vectS2 * signWallIsLeft
				y11 = y12 - vectC2 * signWallIsLeft * signReorder

				x21 = 0
				x22 = 1
				if revealWidthAct > turnThk + skinTurnThk - EPS then
					y21 = lengthSkinTurnToFrame
					bPy2AtFrame = 1
				else
					y21 = lengthSkinTurnIn
					bPy2AtFrame = 0
				endif
				y22 = y21

				gosub 100	! Line - Line intersection
				px2 = cx
				py2 = cy

! Special case check -----------------------------------------------------------

!!!if py2 > cummThk + bTurnSide * skinThk - EPS exor bTurnSide then
!if i=startCount  then
!	line2	0,		cummThk + bTurnSide * skinThk,
!			0.40,	cummThk + bTurnSide * skinThk
!	line2	0,		py2,
!			0.35,	py2
!endif
!if bTurnSide then circle2 0,0, 0.1

if (py2 > cummThk + bTurnSide * skinThk - EPS) exor bTurnSide then
	! Befordul, de a beforulas melysege kisebb, mint maga az eredeti reteg vastagsaga
	bSkipThisSkin = 1
endif

! p3 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x12 = refX2 * sideSign + turnThk * vectC2
					y12 = (refY2 - offsetY) * signWallIsLeft * signReorder + turnThk * vectS2 * signWallIsLeft
				else
					x12 = refX2 * sideSign + turnThk * vectC2
					y12 = (refY2 - offsetY) * signWallIsLeft * signReorder - turnThk * vectS2 * signWallIsLeft
				endif
				x11 = x12 + vectS2 * signWallIsLeft
				y11 = y12 - vectC2 * signWallIsLeft * signReorder

				x21 = 0
				x22 = 1
				if revealWidthAct > turnThk + EPS then
					y21 = lengthSkinTurnToFrame
					bPy3AtFrame = 1
				else
					y21 = lengthSkinTurnIn
					bPy3AtFrame = 0
				endif
				y22 = y21

				gosub 100	! Line - Line intersection
				px3 = cx
				py3 = cy

! Special case check -----------------------------------------------------------

				if py1 < py2 exor bTurnSide then
					bSkipThisSkin = 1
				endif

! p22, p33 points --------------------------------------------------------------

				if not(bSkipThisSkin) & bPy2AtFrame <> bPy3AtFrame then
					bSplittedSkin = 1

					px22 = distanceX
					py22 = py2

					px33 = distanceX
					py33 = py3
				endif

! p4 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x12 = refX * sideSign + turnThk * vectC
					y12 = (refY - offsetY) * signWallIsLeft * signReorder + turnThk * vectS * signWallIsLeft
				else
					x12 = refX * sideSign + turnThk * vectC
					y12 = (refY - offsetY) * signWallIsLeft * signReorder - turnThk * vectS * signWallIsLeft
				endif
				x11 = x12 + vectS * signWallIsLeft
				y11 = y12 - vectC * signWallIsLeft * signReorder

				x21 = 0
				x22 = 1
				if bSlantedSkin then
					! Splanted skin eseten a slanted oldal felol szamoljuk a retegeket
					y21 = skinCummThkRef[WALL_SKINS_NUMBER] + diffWallThk - cummThkInc / incH
					y22 = y21 + incHor * iInclDir * sideSign
				else
					if bTurnSide then
						y21 = cummThk
					else
						y21 = cummThk + skinThk
					endif
					y22 = y21
				endif

				gosub 100	! Line - Line intersection
				px4 = cx
				py4 = cy

! Special case check -----------------------------------------------------------

if bSplittedSkin & ((py4 < py3 + EPS) exor bTurnSide) then
	bSplittedSkin = 0
	px4 = distanceX
	px3 = distanceX
	py3 = lengthSkinTurnIn
	bPy3AtFrame = 0
endif

!!!				if bSplittedSkin & (py4 > py3 & py3 > py1) then
!!!					px3 = px22
!!!					py3 = py22
!!!
!!!					px4 = px22
!!!					bSplittedSkin = 0
!!!				endif


				if not(bSkipThisSkin) & bDoubleSplayedSkin then

! p44  point -------------------------------------------------------------------

					if bFirstSkinAtReveal then
						x12 = refX * sideSign + turnThk * vectC
						y12 = (refY - offsetY) * signWallIsLeft * signReorder + turnThk * vectS * signWallIsLeft
					else
						x12 = refX * sideSign + turnThk * vectC
						y12 = (refY - offsetY) * signWallIsLeft * signReorder - turnThk * vectS * signWallIsLeft
					endif
					x11 = x12 + vectS * signWallIsLeft
					y11 = y12 - vectC * signWallIsLeft * signReorder

					if bFirstSkinAtReveal then
						x22 = refX2 * sideSign + turnThk * vectC2
						y22 = (refY2 - offsetY) * signWallIsLeft * signReorder + turnThk * vectS2 * signWallIsLeft
					else
						x22 = refX2 * sideSign + turnThk * vectC2
						y22 = (refY2 - offsetY) * signWallIsLeft * signReorder - turnThk * vectS2 * signWallIsLeft
					endif
					x21 = x22 + vectS2 * signWallIsLeft
					y21 = y22 - vectC2 * signWallIsLeft * signReorder

					gosub 100	! Line - Line intersection
					px44 = cx
					py44 = cy

! Special case check -----------------------------------------------------------

					if py44 > py4 exor bTurnSide then
						if bFirstSkinAtReveal then
							x12 = refX2 * sideSign + turnThk * vectC2
							y12 = (refY2 - offsetY) * signWallIsLeft * signReorder + turnThk * vectS2 * signWallIsLeft
						else
							x12 = refX2 * sideSign + turnThk * vectC2
							y12 = (refY2 - offsetY) * signWallIsLeft * signReorder - turnThk * vectS2 * signWallIsLeft
						endif
						x11 = x12 + vectS2 * signWallIsLeft
						y11 = y12 - vectC2 * signWallIsLeft * signReorder

						x21 = 0
						x22 = 1
						if bSlantedSkin then
							! Splanted skin eseten a slanted oldal felol szamoljuk a retegeket
							y21 = skinCummThkRef[WALL_SKINS_NUMBER] + diffWallThk - cummThkInc / incH
							y22 = y21 + incHor * iInclDir * sideSign
						else
							if bTurnSide then
								y21 = cummThk
							else
								y21 = cummThk + skinThk
							endif
							y22 = y21
						endif

						gosub 100	! Line - Line intersection
						px4 = cx
						py4 = cy

						px44 = cx
						py44 = cy
					endif

! p55  point -------------------------------------------------------------------

					if bFirstSkinAtReveal then
						x12 = refX * sideSign + (turnThk + skinTurnThk) * vectC
						y12 = (refY - offsetY) * signWallIsLeft * signReorder + (turnThk + skinTurnThk) * vectS * signWallIsLeft
					else
						x12 = refX * sideSign + (turnThk + skinTurnThk) * vectC
						y12 = (refY - offsetY) * signWallIsLeft * signReorder	- (turnThk + skinTurnThk) * vectS * signWallIsLeft
					endif
					x11 = x12 + vectS * signWallIsLeft
					y11 = y12 - vectC * signWallIsLeft * signReorder

					if bFirstSkinAtReveal then
						x22 = refX2 * sideSign + (turnThk + skinTurnThk) * vectC2
						y22 = (refY2 - offsetY) * signWallIsLeft * signReorder + (turnThk + skinTurnThk) * vectS2 * signWallIsLeft
					else
						x22 = refX2 * sideSign + (turnThk + skinTurnThk) * vectC2
						y22 = (refY2 - offsetY) * signWallIsLeft * signReorder	- (turnThk + skinTurnThk) * vectS2 * signWallIsLeft
					endif
					x21 = x22 + vectS2 * signWallIsLeft
					y21 = y22 - vectC2 * signWallIsLeft * signReorder

					gosub 100	! Line - Line intersection
					px55 = cx
					py55 = cy

! Special case check -----------------------------------------------------------

					if py55 > py11 exor bTurnSide then
						if bFirstSkinAtReveal then
							x12 = refX2 * sideSign + (turnThk + skinTurnThk) * vectC2
							y12 = (refY2 - offsetY) * signWallIsLeft * signReorder + (turnThk + skinTurnThk) * vectS2 * signWallIsLeft
						else
							x12 = refX2 * sideSign + (turnThk + skinTurnThk) * vectC2
							y12 = (refY2 - offsetY) * signWallIsLeft * signReorder	- (turnThk + skinTurnThk) * vectS2 * signWallIsLeft
						endif
						x11 = x12 + vectS2 * signWallIsLeft
						y11 = y12 - vectC2 * signWallIsLeft * signReorder

						x21 = 0
						x22 = 1
						if bSlantedSkinNext then
							! Splanted skin eseten a slanted oldal felol szamoljuk a retegeket
							y21  = skinCummThkRef[WALL_SKINS_NUMBER] + diffWallThk - (cummThkInc + skinThk) / incH
							y22 = y21 + incHor * iInclDir * sideSign
						else
							if bTurnSide then
								y21 = cummThk + skinThk
							else
								y21 = cummThk
							endif
							y22 = y21
						endif

						gosub 100	! Line - Line intersection
						px11 = cx
						py11 = cy

						px55 = cx
						py55 = cy
					endif

					if py55 < py2 exor bTurnSide then
						if bFirstSkinAtReveal then
							x12 = refX * sideSign + (turnThk + skinTurnThk) * vectC
							y12 = (refY - offsetY) * signWallIsLeft * signReorder + (turnThk + skinTurnThk) * vectS * signWallIsLeft
						else
							x12 = refX * sideSign + (turnThk + skinTurnThk) * vectC
							y12 = (refY - offsetY) * signWallIsLeft * signReorder	- (turnThk + skinTurnThk) * vectS * signWallIsLeft
						endif
						x11 = x12 + vectS * signWallIsLeft
						y11 = y12 - vectC * signWallIsLeft * signReorder

						x21 = 0
						x22 = 1
						if revealWidthAct > turnThk + skinTurnThk - EPS then
							y21 = lengthSkinTurnToFrame
							bPy2AtFrame = 1
						else
							y21 = lengthSkinTurnIn
							bPy2AtFrame = 0
						endif
						y22 = y21

						gosub 100	! Line - Line intersection
						px2 = cx
						py2 = cy

						px55 = cx
						py55 = cy
					endif

				endif

			endif
		endif	! if bTurnSkin then

! Check turned skin geometry ===================================================

!bSkipThisSkin = (lengthSkinTurnIn > py1 - EPS)

!if jdx=1 then text2 0.2,0, py1

!if bTurnSkin & not(bSkipThisSkin) then
!	if bSlantedOuterSide & (not(bTurnSide) exor bFirstSkinAtReveal) then
!		line_type 1
!		pen i
!		sss = 0.002
!		circle2 px1,py1, sss:	sss=sss+0.002
!		circle2 px11,py11,sss
!		circle2 px2,py2, sss:	sss=sss+0.002
!		if bSplittedSkin then
!			circle2 px22,py22, sss:	sss=sss+0.002
!			circle2 px33,py33, sss:	sss=sss+0.002
!		endif
!		if bDoubleSplayedSkin then
!			circle2 px44,py44, sss:	sss=sss+0.002
!			circle2 px55,py55, sss:	sss=sss+0.002
!		endif
!		circle2 px3,py3, sss:	sss=sss+0.002
!		circle2 px4,py4, sss:	sss=sss+0.002
!	endif
!endif

! Draw the turned skins ========================================================

		bShowSkin = not( (GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY & WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] < EPS) | \
						 (GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) < EPS) )
!!		bShowSkin = (GLOB_STRUCTURE_DISPLAY = STRUCTURE_ENTIRE_STRUCTURE | (GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) > EPS))

		if bTurnSkin & not(bSkipThisSkin) then

			skinFillType		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL])
			skinFillFgPen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_PEN])
			skinFillBgPen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_BACK_PEN])
			skinFillOrientation	= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_ORIENTATION])
			bFitToSkinFill		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_FIT_TO_SKIN])

			if bSplittedSkin then
				if bDoubleSplayedSkin then
					put	px1,	py1,	0,
						px55,	py55,	0,
						px2,	py2,	0,
						px22,	py22,	0,
						px33,	py33,	0,
						px3,	py3,	0,
						px44,	py44,	0,
						px4,	py4,	0
				else
					put	px1,	py1,	0,
						px2,	py2,	0,
						px22,	py22,	0,
						px33,	py33,	0,
						px3,	py3,	0,
						px4,	py4,	0
				endif
			else
				if bDoubleSplayedSkin then
					put	px1,	py1,	0,
						px55,	py55,	0,
						px2,	py2,	0,
						px3,	py3,	0,
						px44,	py44,	0,
						px4,	py4,	0
				else
					put	px1,	py1,	0,
						px2,	py2,	0,
						px3,	py3,	0,
						px4,	py4,	0
				endif
			endif
			if curvedWall then
				put	px1, py1, 3000
			endif

			if bShowSkin then
				fill skinFillType
				bLocalFill	= skinFillOrientation

				if bTurnedHatchOriantation & not(bFitToSkinFill) then
					if bLocalFill then
						fillAngle = 90
					else
						fillAngle = sideSign * WALL_DIRECTION + 90
					endif

					wallblock2 nsp/3 + 1, 2 + 8 + 32, skinFillFgPen, skinFillBgPen,
						0,0,fillAngle,
						0,-WOD,900,
						get(nsp)
				else
					dirAngle = -signWallIsLeft * atn(vectS / vectC)

					wallblock2{2} nsp/3 + 1, 2, 2,8 * (bLocalFill | bFitToSkinFill) + 32 * bFitToSkinFill + 128 * (bLocalFill & not(bFitToSkinFill)),
						skinFillFgPen, skinFillBgPen,
						use(2),
						-sin(dirAngle),-cos(dirAngle), -skinTurnThk*cos(dirAngle),skinTurnThk*sin(dirAngle),
						0,
						0,-WOD,900,
						get(nsp)
				endif
			else
				fill 0
				wallhole2 nsp/3 + 1, 2, 0,-1,
					0,0,0,
					0,-WOD,900,
					get(nsp)
			endif

!			bDrawContour = 0
!			bDrawWallBlock = 1
!			bClosureContour	= 0
!			gosub 200	! Draw wallblock
		endif

! Draw contour lines -----------------------------------------------------------


!#####################################################################

! Turned skin outer contour line -----------------------------------------------

		if bTurnSkin then
			if bTurnSide then
				penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
				lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])
			else
				penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN])
				lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE])
			endif
			lineProperty = LINE_PROPERTY_INNER + (not(bShowPrevSkin))		! (INNER / CONTOUR)

			if not(bSkipThisSkin) & not(bInvalidRasterSection) then
				if bDoubleSplayedSkin then
					bpx = px3
					bpy = py3
					epx = px44
					epy = py44
					!penIdx		= penIdx
					!lineTypeIdx= lineTypeIdx

					if bShowSkin then
!!!						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, (lineProperty = LINE_PROPERTY_CONTOUR))
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 0)
						gosub 4920	! Put line section into Cavity Closure lines array
					else
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
						gosub 4910	! Put line section into wallhole lines array
					endif

					bpx = px44
					bpy = py44
					epx = px4
					epy = py4
					!penIdx		= penIdx
					!lineTypeIdx= lineTypeIdx

					if bShowSkin then
!!!						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, (lineProperty = LINE_PROPERTY_CONTOUR))
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 0)
						gosub 4920	! Put line section into Cavity Closure lines array
					else
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
						gosub 4910	! Put line section into wallhole lines array
					endif
				else
					bpx = px3
					bpy = py3
					epx = px4
					epy = py4
					!penIdx		= penIdx
					!lineTypeIdx= lineTypeIdx

					if bShowSkin then
!!!						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, (lineProperty = LINE_PROPERTY_CONTOUR))
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 0)
						gosub 4920	! Put line section into Cavity Closure lines array
					else
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
						gosub 4910	! Put line section into wallhole lines array
					endif
				endif

				if curvedWall then
					if bShowSkin then
						R = sqr(px1^2 + (py1 + WOD)^2)

						vx = px1
						vy = -py1 - WOD
						gosub 103	! Direction Angle
						alpha = -angle

						vx = px4
						vy = -py4 - WOD
						gosub 103	! Direction Angle
						beta = -angle

						if abs(alpha - beta) > EPS then
							pen				penIdx
							line_type		lineTypeIdx
							line_property	lineProperty
							wallarc2 0,-WOD, R, min(alpha,beta), max(alpha,beta)
						endif
					endif
				else
					bpx = px1
					bpy = py1
					epx = px4
					epy = py4
					iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, (lineProperty = LINE_PROPERTY_CONTOUR))
					penIdx		= penIdx * bShowSkin
					!lineTypeIdx= lineTypeIdx
					gosub 4920	! Put line section into Cavity Closure lines array
				endif
			endif
			if not(bShowSkin) & bShowPrevSkin then
!				pen			penIdx
!				line_type	lineTypeIdx
!				line_property LINE_PROPERTY_CONTOUR
!
!!				wallline2 px1,py1, px4,py4

				bpx = px1
				bpy = py1
				epx = px4
				epy = py4
				iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)		! LINE_PROPERTY_CONTOUR
				!penIdx		= penIdx
				!lineTypeIdx= lineTypeIdx
				gosub 4920	! Put line section into Cavity Closure lines array
			endif

! Turned skin inner contour line -----------------------------------------------

			if bTurnSide then
				penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN])
				lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE])
			else
				penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
				lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])
			endif
			lineProperty = LINE_PROPERTY_INNER + (not(bShowNextSkin))		! (INNER / CONTOUR)

!!!			if bShowSkin & not(bSkipThisSkin) & not(bInvalidRasterSection) & penIdx > 0 then
			if not(bSkipThisSkin) & not(bInvalidRasterSection) & penIdx > 0 then
!				pen				penIdx
!				line_type		lineTypeIdx
!				line_property	lineProperty

				if bSeparatingLine then
!!					wallline2 px11,py11, px2,py2

					bpx = px11
					bpy = py11
					epx = px2
					epy = py2
					!penIdx		= penIdx
					!lineTypeIdx= lineTypeIdx
!circle2 bpx, bpy, 0.01
!circle2 epx, epy, 0.01
					if bShowSkin then
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, (lineProperty = LINE_PROPERTY_CONTOUR))
						gosub 4920	! Put line section into Cavity Closure lines array
					else
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
						gosub 4910	! Put line section into wallhole lines array
					endif

					if bShowSkin & arrayCustomCC[jdx][CUSTOMCC_PEN] > 0 then
!						pen arrayCustomCC[jdx][CUSTOMCC_PEN]
!						line_property LINE_PROPERTY_INNER
!
!!						wallline2 px1,py1, px11,py11

						bpx = px1
						bpy = py1
						epx = px11
						epy = py11
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 0)		! LINE_PROPERTY_INNER

						savedPenIdx		 = penIdx
						savedLineTypeIdx = lineTypeIdx

						penIdx		= arrayCustomCC[jdx][CUSTOMCC_PEN]
						lineTypeIdx	= 1
						gosub 4920	! Put line section into Cavity Closure lines array

						penIdx		= savedPenIdx
						lineTypeIdx	= savedLineTypeIdx
					endif
				else
					if bDoubleSplayedSkin then
!!						wallline2 px55,py55, px2,py2
!!						wallline2 px11,py11, px55,py55

						bpx = px55
						bpy = py55
						epx = px2
						epy = py2

						if bShowSkin then
							iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, (lineProperty = LINE_PROPERTY_CONTOUR))
							gosub 4920	! Put line section into Cavity Closure lines array
						else
							iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
							gosub 4910	! Put line section into wallhole lines array
						endif

						bpx = px11
						bpy = py11
						epx = px55
						epy = py55

						if bShowSkin then
							iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, (lineProperty = LINE_PROPERTY_CONTOUR))
							gosub 4920	! Put line section into Cavity Closure lines array
						else
							iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
							gosub 4910	! Put line section into wallhole lines array
						endif
					else
!!						wallline2 px11,py11, px2,py2

						bpx = px11
						bpy = py11
						epx = px2
						epy = py2
						!penIdx		= penIdx
						!lineTypeIdx= lineTypeIdx

						if bShowSkin then
							iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, (lineProperty = LINE_PROPERTY_CONTOUR))
							gosub 4920	! Put line section into Cavity Closure lines array
						else
							iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
							gosub 4910	! Put line section into wallhole lines array
						endif
					endif

				endif
			endif

! Turned skin end contoure line(s) ---------------------------------------------

			penIdx		= round_int(WALL_SKINS_PARAMS[idx][SKIN_END_FACE_PEN])
			lineTypeIdx	= round_int(WALL_SKINS_PARAMS[idx][SKIN_END_LINE_TYPE])
			lineProperty= LINE_PROPERTY_INNER + ((bPy2AtFrame & bPy3AtFrame) | (GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY))		! (INNER / CONTOUR)

!!!			if bShowSkin & penIdx > 0 then
!			if penIdx > 0 then
			if penIdx > 0 & not(bSkipThisSkin) then
!				pen				penIdx
!				line_type		lineTypeIdx
!				line_property	lineProperty

				if bSplittedSkin then
!!					wallline2 px2, py2,	 px22,py22

					bpx = px2
					bpy = py2
					epx = px22
					epy = py22
					!penIdx		= penIdx
					!lineTypeIdx= lineTypeIdx

					if bShowSkin then
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, (lineProperty = LINE_PROPERTY_CONTOUR))
						gosub 4920	! Put line section into Cavity Closure lines array
					else
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
						gosub 4910	! Put line section into wallhole lines array
					endif

					if bShowSkin then
!						line_property LINE_PROPERTY_CONTOUR
!!						wallline2 px22,py22, px33,py33
!!						wallline2 px33,py33, px3, py3

						bpx = px22
						bpy = py22
						epx = px33
						epy = py33
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)		! LINE_PROPERTY_CONTOUR
						!penIdx		= penIdx
						!lineTypeIdx= lineTypeIdx
						gosub 4920	! Put line section into Cavity Closure lines array

						bpx = px33
						bpy = py33
						epx = px3
						epy = py3
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)		! LINE_PROPERTY_CONTOUR
						!penIdx		= penIdx
						!lineTypeIdx= lineTypeIdx
						gosub 4920	! Put line section into Cavity Closure lines array
					endif
				else
!!					wallline2 px2,py2, px3,py3

					bpx = px2
					bpy = py2
					epx = px3
					epy = py3
					!penIdx		= penIdx
					!lineTypeIdx= lineTypeIdx

					if bShowSkin then
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, (lineProperty = LINE_PROPERTY_CONTOUR))
						gosub 4920	! Put line section into Cavity Closure lines array
					else
						iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 1)
						gosub 4910	! Put line section into wallhole lines array
					endif
				endif
			endif

		endif

! Skin loop end ----------------------------------------------------------------

		bShowPrevSkin = bShowSkin

		if bTurnSkin then
			turnThk = turnThk + skinTurnThk
		endif
	next i
return


4910:
! ==============================================================================
! Put line section into wallhole lines array.
! Convert point coordinates from Cavity Closure coordinate system
! to Wallhole coordinate system.
! ------------------------------------------------------------------------------
! Input variables:
!	bpx,bpy:		Start point coordinate
!	epx,epy:		End point coordinate
!	iAttributes:	Attribute bitfield
!!	penIdx:			Pen index (ignored)
!!	lineTypeIdx:	Line type index (ignored)
!	sideSign:		The following three variable
!	signY:				from Cavity Closure coordinate system
!	offsetY:			to Wallhole coordinate system.
! ==============================================================================

	! Conversion from Cavity Closure coordinate system to Wallhole coordinate system
	x11 = bpx * signX * sideSign
	y11 = bpy * signY + offsetY
	x12 = epx * signX * sideSign
	y12 = epy * signY + offsetY

	dim addedNewLineSections[][4]	! Array to collect newly created line sections
	idxNewLineSections = 0

4911:	! Recursive entry point
	bNeedToAdd = 1

	numLines = vardim1(lineSections)
	ii = 1

	do
		x21 = lineSections[ii][LINE_BEG_X]
		y21 = lineSections[ii][LINE_BEG_Y]
		x22 = lineSections[ii][LINE_END_X]
		y22 = lineSections[ii][LINE_END_Y]

		gosub 999	! Segment - Segment sections

		if state > 0 then
			if iStartInside = 0 & iEndInside = 0 then
				! Delete line section
				lineSections[ii][LINE_BEG_X] = 0
				lineSections[ii][LINE_BEG_Y] = 0
				lineSections[ii][LINE_END_X] = 0
				lineSections[ii][LINE_END_Y] = 0

				! Store line section to merge this into lineSections[] array at the end of this subroutine
				idxNewLineSections = idxNewLineSections + 1
				addedNewLineSections[idxNewLineSections][LINE_BEG_X] = x11
				addedNewLineSections[idxNewLineSections][LINE_BEG_Y] = y11
				addedNewLineSections[idxNewLineSections][LINE_END_X] = x21
				addedNewLineSections[idxNewLineSections][LINE_END_Y] = y21

				x11 = x22
				y11 = y22
				!x12 = x12
				!y12 = y12
				bNeedToAdd = 1
			endif
			if iStartInside = 0 & iEndInside = 1 then
				lineSections[ii][LINE_BEG_X] = x12
				lineSections[ii][LINE_BEG_Y] = y12
				lineSections[ii][LINE_END_X] = x22
				lineSections[ii][LINE_END_Y] = y22

				!x11 = x11
				!y11 = y11
				x12 = x21
				y12 = y21
				bNeedToAdd = 1
			endif
			if iStartInside = 0 & iEndInside = 2 then
				lineSections[ii][LINE_BEG_X] = 0
				lineSections[ii][LINE_BEG_Y] = 0
				lineSections[ii][LINE_END_X] = 0
				lineSections[ii][LINE_END_Y] = 0

				!x11 = x11
				!y11 = y11
				x12 = x21
				y12 = y21
				bNeedToAdd = 1
			endif
			if iStartInside = 1 & iEndInside = 0 then
				lineSections[ii][LINE_BEG_X] = x21
				lineSections[ii][LINE_BEG_Y] = y21
				lineSections[ii][LINE_END_X] = x11
				lineSections[ii][LINE_END_Y] = y11

				x11 = x22
				y11 = y22
				!x12 = x12
				!y12 = y12
				bNeedToAdd = 1
			endif
			if iStartInside = 1 & iEndInside = 1 then
				lineSections[ii][LINE_BEG_X] = x21
				lineSections[ii][LINE_BEG_Y] = y21
				lineSections[ii][LINE_END_X] = x11
				lineSections[ii][LINE_END_Y] = y11

				x11 = x12
				y11 = y12
				x12 = x22
				y12 = y22
				iAttributes = lineSections[ii][LINE_ATTRIBUTES]
				bNeedToAdd = 1
			endif
			if iStartInside = 1 & iEndInside = 2 then
				lineSections[ii][LINE_BEG_X] = x21
				lineSections[ii][LINE_BEG_Y] = y21
				lineSections[ii][LINE_END_X] = x11
				lineSections[ii][LINE_END_Y] = y11
				bNeedToAdd = 0
			endif
			if iStartInside = 2 & iEndInside = 0 then
				lineSections[ii][LINE_BEG_X] = 0
				lineSections[ii][LINE_BEG_Y] = 0
				lineSections[ii][LINE_END_X] = 0
				lineSections[ii][LINE_END_Y] = 0

				x11 = x22
				y11 = y22
				!x12 = x12
				!y12 = y12
				bNeedToAdd = 1
			endif
			if iStartInside = 2 & iEndInside = 1 then
				lineSections[ii][LINE_BEG_X] = x12
				lineSections[ii][LINE_BEG_Y] = y12
				lineSections[ii][LINE_END_X] = x22
				lineSections[ii][LINE_END_Y] = y22
				bNeedToAdd = 0
			endif
			if iStartInside = 2 & iEndInside = 2 then
				lineSections[ii][LINE_BEG_X] = 0
				lineSections[ii][LINE_BEG_Y] = 0
				lineSections[ii][LINE_END_X] = 0
				lineSections[ii][LINE_END_Y] = 0
				bNeedToAdd = 0
			endif
		endif

		ii = ii + 1
	while (ii <= numLines & bNeedToAdd)

	if bNeedToAdd then
		! This part of the original line section does dot overlaps with any other line sections in the lineSections[] array.
		! We have to add this part to the lineSections[] array.
		tempIdx = vardim1(lineSections) + 1

		lineSections[tempIdx][LINE_BEG_X]		= x11
		lineSections[tempIdx][LINE_BEG_Y]		= y11
		lineSections[tempIdx][LINE_END_X]		= x12
		lineSections[tempIdx][LINE_END_Y]		= y12
		lineSections[tempIdx][LINE_ATTRIBUTES]	= iAttributes + bitset(0, LINE_ATTRIBUTES_WALLLINE, 1) + bitset(0, LINE_ATTRIBUTES_DRAWCC, 1)
!		lineSections[tempIdx][LINE_PEN_IDX]		= penIdx		! Ignored, becouse it will be filled out when the segments splitted by wall skin separator lines
!		lineSections[tempIdx][LINE_LTYPE_IDX]	= lineTypeIdx	! Ignored
	endif

	if idxNewLineSections > 0 then
		x11 = addedNewLineSections[idxNewLineSections][LINE_BEG_X]
		y11 = addedNewLineSections[idxNewLineSections][LINE_BEG_Y]
		x12 = addedNewLineSections[idxNewLineSections][LINE_END_X]
		y12  = addedNewLineSections[idxNewLineSections][LINE_END_Y]
		idxNewLineSections = idxNewLineSections - 1

		gosub 4911	! Recurse into this algorithm
	endif
return


4920:
! ==============================================================================
! Put line section into Cavity Closure lines array.
! Convert point coordinates from Cavity Closure coordinate system
! to Wallhole coordinate system.
! ------------------------------------------------------------------------------
! Input variables:
!	bpx,bpy:		Start point coordinate
!	epx,epy:		End point coordinate
!	iAttributes:	Attribute bitfield
!	penIdx:			Pen index
!	lineTypeIdx:	Line type index
! Used global variables:
!	sideSign:
!	signY:
!	offsetY:
! ==============================================================================

	tempIdx = vardim1(contourLines) + 1

	contourLines[tempIdx][LINE_BEG_X]		= bpx * signX * sideSign
	contourLines[tempIdx][LINE_BEG_Y]		= bpy * signY + offsetY
	contourLines[tempIdx][LINE_END_X]		= epx * signX * sideSign
	contourLines[tempIdx][LINE_END_Y]		= epy * signY + offsetY
	contourLines[tempIdx][LINE_ATTRIBUTES]	= iAttributes
	contourLines[tempIdx][LINE_PEN_IDX]		= penIdx
	contourLines[tempIdx][LINE_LTYPE_IDX]	= lineTypeIdx
return


"DrawWallContourLines":
! ==============================================================================
! Draw wall contour lines
! ------------------------------------------------------------------------------
! Input variables:
!	lineSections:		Wall hole edge contour line segments, coming from the FramingGeometry macro
!	contourLines:		Cavity Closure contour line segments
! ==============================================================================

del top
if WIDO_REVEAL_SIDE then
	add2 0,-WIDO_FRAME_THICKNESS
else
	mul2 1,-1
endif


!! ==============================================================================
!! Visualize lineSections[] line segments
!! for testing purposes only!
!! ==============================================================================
!
!numLines = vardim1(lineSections)
!for i=1 to numLines
!	px1 = lineSections[i][LINE_BEG_X]
!	py1 = lineSections[i][LINE_BEG_Y]
!	px2 = lineSections[i][LINE_END_X]
!	py2 = lineSections[i][LINE_END_Y]
!	lineProperty= LINE_PROPERTY_INNER + bittest(round_int(lineSections[i][LINE_ATTRIBUTES]), LINE_ATTRIBUTES_CONTOUR)	! INNER / CONTOUR
!	penIdx		= lineSections[i][LINE_PEN_IDX]
!	lineTypeIdx	= lineSections[i][LINE_LTYPE_IDX]
!
!	if penIdx < 1 then penIdx = 20
!
!	pen				penIdx
!	line_type		lineTypeIdx
!	line_property	lineProperty
!
!	add2 0.002,0.002
!	wallline2 px1,py1, px2,py2
!next i
!del numLines
!end


! ==============================================================================
! Normalize incoming wallhole line sections
! Merge overlapping wallhole contour lines
! ==============================================================================

dim normalizedLineSections[][7]
normalizedLineSections[1][LINE_BEG_X]		= 0
normalizedLineSections[1][LINE_BEG_Y]		= 0
normalizedLineSections[1][LINE_END_X]		= 0
normalizedLineSections[1][LINE_END_Y]		= 0
normalizedLineSections[1][LINE_ATTRIBUTES]	= 0
normalizedLineSections[1][LINE_PEN_IDX]		= 0
normalizedLineSections[1][LINE_LTYPE_IDX]	= 0

idx = 1

numLines = vardim1(lineSections)
for i=1 to numLines
	x11 = lineSections[i][LINE_BEG_X]
	y11 = lineSections[i][LINE_BEG_Y]
	x12 = lineSections[i][LINE_END_X]
	y12 = lineSections[i][LINE_END_Y]
	iAttributes	= round_int(lineSections[i][LINE_ATTRIBUTES])
	penIdx		= lineSections[i][LINE_PEN_IDX]
	lineTypeIdx	= lineSections[i][LINE_LTYPE_IDX]

	bStore = 0

	! Skip deleted line sections (line section is deleted when both it's points set to (0,0) in the subroutine 4910)
	bDeletedLineSection = (abs(x11) < EPS & abs(y11) < EPS & abs(x12) < EPS & abs(y12) < EPS)

	if bittest(iAttributes, LINE_ATTRIBUTES_DRAWCC) & not(bDeletedLineSection) then
		j = i + 1
		bStandalone = 1

		if j <= numLines then
			do
				iAttributes2 = round_int(lineSections[j][LINE_ATTRIBUTES])
				if bittest(iAttributes2, LINE_ATTRIBUTES_DRAWCC) then
	
					bGDLLine1	= (bittest(iAttributes, LINE_ATTRIBUTES_GDLLINE))
					bWallLine1	= (bittest(iAttributes, LINE_ATTRIBUTES_WALLLINE))
	
					bGDLLine2	= (bittest(iAttributes2, LINE_ATTRIBUTES_GDLLINE))
					bWallLine2	= (bittest(iAttributes2, LINE_ATTRIBUTES_WALLLINE))
	
					bMerge = (bGDLLine1 = bGDLLine2 & bWallLine1 = bWallLine2)
	
					x21 = lineSections[j][LINE_BEG_X]
					y21 = lineSections[j][LINE_BEG_Y]
					x22 = lineSections[j][LINE_END_X]
					y22 = lineSections[j][LINE_END_Y]
	
					gosub 999	! Segment - Segment sections
	
					if state > 0 then
						bStandalone = 0
					endif
					if state = 1 | state = 2 then
						if iStartInside = 2 & iEndInside = 2 then
							if bGDLLine1 | bGDLLine2 then
								iAttributes = bitset(iAttributes, LINE_ATTRIBUTES_GDLLINE, 1)
							endif
							if bWallLine1 | bWallLine2 then
								iAttributes = bitset(iAttributes, LINE_ATTRIBUTES_WALLLINE, 1)
							endif
							lineSections[j][LINE_ATTRIBUTES] = 0
							bStore = 1
						endif
						if iStartInside = 2 & iEndInside = 0 then
							x11 = x22
							y11 = y22
							bStore = 1
						endif
						if iStartInside = 0 & iEndInside = 2 then
							x12 = x21
							y12 = y21
							bStore = 1
						endif
	! INFO: half overlapped lines not handled yet!
					endif
				endif
	
				j = j + 1
			while j <= numLines & not(bStore)
		endif

		if bStandalone then bStore = 1
	endif

	if bStore then
		normalizedLineSections[idx][LINE_BEG_X]	= x11
		normalizedLineSections[idx][LINE_BEG_Y]	= y11
		normalizedLineSections[idx][LINE_END_X]	= x12
		normalizedLineSections[idx][LINE_END_Y]	= y12
		normalizedLineSections[idx][LINE_ATTRIBUTES]	= iAttributes
		normalizedLineSections[idx][LINE_PEN_IDX]		= penIdx
		normalizedLineSections[idx][LINE_LTYPE_IDX]		= lineTypeIdx
		idx = idx + 1
	endif
next i


!! ==============================================================================
!! Visualize wall hole edge contour line segments
!! for testing purposes only!
!! ==============================================================================
!
!numLines = vardim1(normalizedLineSections)
!pen 1
!text2 0,0, numLines
!for i=1 to numLines
!	add2 i*0.001,i*0.001
!
!	px1 = normalizedLineSections[i][LINE_BEG_X]
!	py1 = normalizedLineSections[i][LINE_BEG_Y]
!	px2 = normalizedLineSections[i][LINE_END_X]
!	py2 = normalizedLineSections[i][LINE_END_Y]
!	penIdx		= normalizedLineSections[i][LINE_PEN_IDX]
!	lineTypeIdx	= normalizedLineSections[i][LINE_LTYPE_IDX]
!	lineProperty= LINE_PROPERTY_CONTOUR
!	iBitField	= round_int(normalizedLineSections[i][LINE_ATTRIBUTES])
!
!	if penIdx > 0 then
!		pen				penIdx
!		line_type		lineTypeIdx
!		line_property	lineProperty
!
!		pen 6		! Blue
!		if bittest(iBitField, LINE_ATTRIBUTES_GDLLINE) & bittest(iBitField, LINE_ATTRIBUTES_WALLLINE) then
!			pen 4	! Green
!		else
!			if bittest(iBitField, LINE_ATTRIBUTES_GDLLINE) then pen 1
!			if bittest(iBitField, LINE_ATTRIBUTES_WALLLINE) then pen 20
!		endif
!
!		line2 px1,py1, px2,py2
!	endif
!
!	del 1
!next i
!end


! ==============================================================================
! Split wallhole line sections with wall skin lines
! ==============================================================================

dim tempLineSections[]

call "WallContourDivider" parameters AC_Wall_Direction_Type = AC_Wall_Direction_Type,
	radSill			= radSill,
	radBoard		= radBoard,
	WOD				= WOD,
	offsetSill		= offsetSill,
	offsetBoard		= offsetBoard,
	lineSections	= normalizedLineSections,
returned_parameters tempLineSections

numLineSections = round_int(vardim1(tempLineSections) / 7)
dim normalizedLineSections[][7]
idx = 0
for i=1 to numLineSections
	for j=1 to 7
		normalizedLineSections[i][j] = tempLineSections[idx + j]
	next j
	idx = idx + 7
next i


!! ==============================================================================
!! Visualize Cavity Closure contour line segments
!! ==============================================================================
!
!numContourLines = vardim1(contourLines)
!pen 1
!text2 0,0, numContourLines
!for i=1 to numContourLines
!	add2 i*0.001,i*0.001
!	px1 = contourLines[i][LINE_BEG_X]
!	py1 = contourLines[i][LINE_BEG_Y]
!	px2 = contourLines[i][LINE_END_X]
!	py2 = contourLines[i][LINE_END_Y]
!	lineProperty= LINE_PROPERTY_INNER + bittest(round_int(contourLines[i][LINE_ATTRIBUTES]), LINE_ATTRIBUTES_CONTOUR)	! INNER / CONTOUR
!	penIdx		= contourLines[i][LINE_PEN_IDX]
!	lineTypeIdx	= contourLines[i][LINE_LTYPE_IDX]
!
!	pen				penIdx
!	line_type		lineTypeIdx
!	line_property	lineProperty
!
!	wallline2 px1,py1, px2,py2
!	del 1
!next i
!
!! ==============================================================================
!! Visualize wall hole edge contour line segments
!! ==============================================================================
!
!numLines = vardim1(normalizedLineSections)
!for i=1 to numLines
!	px1 = normalizedLineSections[i][LINE_BEG_X]
!	py1 = normalizedLineSections[i][LINE_BEG_Y]
!	px2 = normalizedLineSections[i][LINE_END_X]
!	py2 = normalizedLineSections[i][LINE_END_Y]
!	penIdx		= normalizedLineSections[i][LINE_PEN_IDX]
!	lineTypeIdx	= normalizedLineSections[i][LINE_LTYPE_IDX]
!	lineProperty= LINE_PROPERTY_CONTOUR
!	iBitField	= round_int(normalizedLineSections[i][LINE_ATTRIBUTES])
!
!	if penIdx > 0 then
!		pen				penIdx
!		line_type		lineTypeIdx
!		line_property	lineProperty
!
!		if bittest(iBitField, LINE_ATTRIBUTES_GDLLINE) then
!			line2 px1,py1, px2,py2
!		endif
!		if bittest(iBitField, LINE_ATTRIBUTES_WALLLINE) then
!			wallline2 px1,py1, px2,py2
!		endif
!	endif
!next i


! ==============================================================================
! Draw wall edge line segments if no any line coming from Cavity Closure
! ==============================================================================

numLines		= vardim1(normalizedLineSections)
numContourLines	= vardim1(contourLines)

if numContourLines = 0 then

	! No any line segment coming from Cavity Closure,
	! so we have to draw the entire wall edge line segment set only.

	for i=1 to numLines
		px1 = normalizedLineSections[i][LINE_BEG_X]
		py1 = normalizedLineSections[i][LINE_BEG_Y]
		px2 = normalizedLineSections[i][LINE_END_X]
		py2 = normalizedLineSections[i][LINE_END_Y]
		penIdx		= normalizedLineSections[i][LINE_PEN_IDX]
		lineTypeIdx	= normalizedLineSections[i][LINE_LTYPE_IDX]
		lineProperty= LINE_PROPERTY_CONTOUR
		iBitField	= round_int(normalizedLineSections[i][LINE_ATTRIBUTES])

		if penIdx > 0 then
			pen				penIdx
			line_type		lineTypeIdx
			line_property	lineProperty

			if bittest(iBitField, LINE_ATTRIBUTES_GDLLINE) then
				line2 px1,py1, px2,py2
			endif
			if bittest(iBitField, LINE_ATTRIBUTES_WALLLINE) then
				wallline2 px1,py1, px2,py2
			endif
		endif
	next i

! ------------------------------------------------------------------------------
	return
! ------------------------------------------------------------------------------
endif


! ==============================================================================
! Set LINE_ATTRIBUTES_GDLLINE attribute bit in every Cavity Closure line segment,
! because the Cavity Closure drawing subroutines does not set this
! But the contourLines contains turned skin contours too.
! These contours get LINE_ATTRIBUTES_WALLLINE attribute bit.
! ==============================================================================

numContourLines	= vardim1(contourLines)
for i=1 to numContourLines
	iBitField = round_int(contourLines[i][LINE_ATTRIBUTES])
	if bittest(iBitField, LINE_ATTRIBUTES_CONTOUR_CLOSURE) then
		iBitField = bitset(iBitField, LINE_ATTRIBUTES_GDLLINE, 1)
	else
		iBitField = bitset(iBitField, LINE_ATTRIBUTES_WALLLINE, 1)
	endif
	contourLines[i][LINE_ATTRIBUTES] = iBitField
next i

!! ==============================================================================
!! Visualize Cavity Closure contour line segments
!! ==============================================================================
!numContourLines = vardim1(contourLines)
!for i=1 to numContourLines
!!	add2 i*0.001,i*0.001
!	px1 = contourLines[i][LINE_BEG_X]
!	py1 = contourLines[i][LINE_BEG_Y]
!	px2 = contourLines[i][LINE_END_X]
!	py2 = contourLines[i][LINE_END_Y]
!	lineProperty= LINE_PROPERTY_INNER + bittest(round_int(contourLines[i][LINE_ATTRIBUTES]), LINE_ATTRIBUTES_CONTOUR)	! INNER / CONTOUR
!	penIdx		= contourLines[i][LINE_PEN_IDX]
!	lineTypeIdx	= contourLines[i][LINE_LTYPE_IDX]
!	pen				penIdx
!
!	line_type		lineTypeIdx
!	line_property	lineProperty
!
!	iBitField = round_int(contourLines[i][LINE_ATTRIBUTES])
!	text2 0, i, iBitField
!
!	if bittest(iBitField, LINE_ATTRIBUTES_CONTOUR_GDLLINE) then
!		line2 px1,py1, px2,py2
!	else
!!		wallline2 px1,py1, px2,py2
!	endif
!!	del 1
!next i
!end

! ==============================================================================
! Split line segments coming from Cavity Closure
! with line segments coming from wallhole edge.
! ==============================================================================

dim overlappingEdgeSegmentIdx[]	! Indexes of overlapping wall edge line segments for each Cavity Closure line segment
dim standaloneEdgeSegments[]	! Bitfield flags of disjunct wall edge line segments

numContourLines	= vardim1(contourLines)
for j = 1 to numContourLines
	overlappingEdgeSegmentIdx[j] = 0	! Initializing the array with zero values
next j

for i=1 to numLines		! wall edge line segments
	x21 = normalizedLineSections[i][LINE_BEG_X]
	y21 = normalizedLineSections[i][LINE_BEG_Y]
	x22 = normalizedLineSections[i][LINE_END_X]
	y22 = normalizedLineSections[i][LINE_END_Y]
	lineTypeIdx2	= normalizedLineSections[i][LINE_LTYPE_IDX]
	penIdx2			= normalizedLineSections[i][LINE_PEN_IDX]
	bContourLine2	= 1
	iBitField		= round_int(normalizedLineSections[i][LINE_ATTRIBUTES])
	bNeedGDLLine2	= (bittest(iBitField, LINE_ATTRIBUTES_GDLLINE))		! Need GDL line too

	bStandalone = 1

	numContourLines	= vardim1(contourLines)
	for j=1 to numContourLines	! Cavity Closure contour lines
		x11 = contourLines[j][LINE_BEG_X]
		y11 = contourLines[j][LINE_BEG_Y]
		x12 = contourLines[j][LINE_END_X]
		y12 = contourLines[j][LINE_END_Y]
		bContourLine1	= (bittest(round_int(contourLines[i][LINE_ATTRIBUTES]), LINE_ATTRIBUTES_CONTOUR))
		penIdx1			= contourLines[j][LINE_PEN_IDX]
		lineTypeIdx1	= contourLines[j][LINE_LTYPE_IDX]
		bNeedGDLLine1	= 0

		gosub 999	! Segment - Segment sections

		if state > 0 then
			bStandalone = 0
			overlappingEdgeSegmentIdx[j] = i	! Index of the wall edge line segment
		endif

		if state = 1 | state = 3 then	! (S1 contains whole S2) or (S1 and S2 has a section)

			iBitField = contourLines[j][LINE_ATTRIBUTES]

			if iStartInside = 0 then

				contourLines[j][LINE_BEG_X]	= x11
				contourLines[j][LINE_BEG_Y]	= y11
				contourLines[j][LINE_END_X]	= x21
				contourLines[j][LINE_END_Y]	= y21
				overlappingEdgeSegmentIdx[j] = 0	! Overhanging line section

				bx = x21
				by = y21
				if iEndInside = 0 then
					ex = x22
					ey = y22
				else
					ex = x12
					ey = y12
				endif

				numContourLines = numContourLines + 1
				contourLines[numContourLines][LINE_BEG_X]		= bx
				contourLines[numContourLines][LINE_BEG_Y]		= by
				contourLines[numContourLines][LINE_END_X]		= ex
				contourLines[numContourLines][LINE_END_Y]		= ey
				contourLines[numContourLines][LINE_ATTRIBUTES]	= bitset(iBitField, LINE_ATTRIBUTES_CONTOUR, bContourLine1)
				contourLines[numContourLines][LINE_PEN_IDX]		= penIdx1
				contourLines[numContourLines][LINE_LTYPE_IDX]	= lineTypeIdx1
				overlappingEdgeSegmentIdx[numContourLines] = i	! Index of the wall edge line segment

				if iEndInside = 0 then
					bx = x22
					by = y22
					ex = x12
					ey = y12

					numContourLines = numContourLines + 1
					contourLines[numContourLines][LINE_BEG_X]		= bx
					contourLines[numContourLines][LINE_BEG_Y]		= by
					contourLines[numContourLines][LINE_END_X]		= ex
					contourLines[numContourLines][LINE_END_Y]		= ey
					contourLines[numContourLines][LINE_ATTRIBUTES]	= bitset(iBitField, LINE_ATTRIBUTES_CONTOUR, bContourLine1)
					contourLines[numContourLines][LINE_PEN_IDX]		= penIdx1
					contourLines[numContourLines][LINE_LTYPE_IDX]	= lineTypeIdx1
					overlappingEdgeSegmentIdx[numContourLines] = 0	! Overhanging line section
				endif
			else
				if iEndInside = 0 then
					contourLines[j][LINE_BEG_X]	= x11
					contourLines[j][LINE_BEG_Y]	= y11
					contourLines[j][LINE_END_X]	= x22
					contourLines[j][LINE_END_Y]	= y22

					bx = x22
					by = y22
					ex = x12
					ey = y12

					numContourLines = numContourLines + 1
					contourLines[numContourLines][LINE_BEG_X]		= bx
					contourLines[numContourLines][LINE_BEG_Y]		= by
					contourLines[numContourLines][LINE_END_X]		= ex
					contourLines[numContourLines][LINE_END_Y]		= ey
					contourLines[numContourLines][LINE_ATTRIBUTES]	= bitset(iBitField, LINE_ATTRIBUTES_CONTOUR, bContourLine1)
					contourLines[numContourLines][LINE_PEN_IDX]		= penIdx1
					contourLines[numContourLines][LINE_LTYPE_IDX]	= lineTypeIdx1
					overlappingEdgeSegmentIdx[numContourLines] = 0	! Overhanging line section
				endif
			endif
		endif
!		if state = 2 then	! S2 contains whole S1
!			! Nothing to do
!		endif
	next j

	standaloneEdgeSegments[i] = bStandalone
next i


! ==============================================================================
! Split line segments coming from Cavity Closure
! with line segments coming from wall perpendicular section in closure farther px.
! ==============================================================================

if (iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) & not(curvedWall) then
	numLines = vardim1(_wallSkinSectionLines)
	numTurnSkinEndingLines = vardim1(_turnSkinEndingLines)
	for i=1 to numLines + numTurnSkinEndingLines		! wall edge line segments
		if i < numLines + 1 then
			x21 = _wallSkinSectionLines[i][LINE_BEG_X]
			y21 = _wallSkinSectionLines[i][LINE_BEG_Y]
			x22 = _wallSkinSectionLines[i][LINE_END_X]
			y22 = _wallSkinSectionLines[i][LINE_END_Y]
			lineTypeIdx2	= _wallSkinSectionLines[i][LINE_LTYPE_IDX]
			penIdx2			= _wallSkinSectionLines[i][LINE_PEN_IDX]
		else
			x21 = _turnSkinEndingLines[i - numLines][LINE_BEG_X]
			y21 = _turnSkinEndingLines[i - numLines][LINE_BEG_Y]
			x22 = _turnSkinEndingLines[i - numLines][LINE_END_X]
			y22 = _turnSkinEndingLines[i - numLines][LINE_END_Y]
			lineTypeIdx2	= _turnSkinEndingLines[i - numLines][LINE_LTYPE_IDX]
			penIdx2			= _turnSkinEndingLines[i - numLines][LINE_PEN_IDX]
		endif
		bStandalone = 1

		j = 1
		numContourLines	= vardim1(contourLines)
		do
			x11 = contourLines[j][LINE_BEG_X]
			y11 = contourLines[j][LINE_BEG_Y]
			x12 = contourLines[j][LINE_END_X]
			y12 = contourLines[j][LINE_END_Y]
			penIdx1			= contourLines[j][LINE_PEN_IDX]
			lineTypeIdx1	= contourLines[j][LINE_LTYPE_IDX]

			gosub 999	! Segment - Segment sections

			if (state = 0) then		! S1 and S2 segments not on the same line

				if (abs(x11 - x12) > EPS) & (abs(y11 - y12) < EPS) then		! if the contourLines is parallel to wall

					! searching for a fitting point of contour line in wall skin section direction
					! direction vector of the skin section
					dVx = 0
					dVy = 1

					! a point of the skin section
					linePx	= x21
					linePy	= y21

					! searching for first point of the contour line
					pointPx = x11
					pointPy	= y11
					gosub "SearchFitPointToLine"

					if bFitPoint then
						fitContourLinePx = x11
						fitContourLinePy = y11
					endif

					if not(bFitPoint) then
						! searching for second point of the contour line
						pointPx = x12
						pointPy	= y12
						gosub "SearchFitPointToLine"

						if bFitPoint then
							fitContourLinePx = x12
							fitContourLinePy = y12
						endif
					endif

					if bFitPoint then
						thickWallSkin		 = sqr((x21 - x22)^2 + (y21 - y22)^2)
						dist_fitP_WallSkinP1 = sqr((fitContourLinePx - x21)^2 + (fitContourLinePy - y21)^2)
						dist_fitP_WallSkinP2 = sqr((fitContourLinePx - x22)^2 + (fitContourLinePy - y22)^2)

						if sgn(fitContourLinePx) = 1 then
							_closureFartherSideFitMPx  = _rightClosureFartherSideMPx
							_closureFartherSideFitMPy  = _rightClosureFartherSideMPy
						else
							_closureFartherSideFitMPx  = _leftClosureFartherSideMPx
							_closureFartherSideFitMPy  = _leftClosureFartherSideMPy
						endif

						! -----------------------------------------------------------------------------------------------------------
						! if the contour lines is in inside of wall skin segment or fitting to one of endpoints of wall skin segment
						! contour line point:	   o		o			      o
						! wall skin segment:	o-----o		o-----o		o-----o
						! -----------------------------------------------------------------------------------------------------------
						if abs(thickWallSkin - dist_fitP_WallSkinP1 - dist_fitP_WallSkinP2) < EPS then

							if (dist_fitP_WallSkinP1 < EPS) | (dist_fitP_WallSkinP2 < EPS) then				! if the contour lines is fitting to one of contour (parallel to wall) of wall skin

								! distance of projecting closure gravity point and middle point of wall skin segment
								dist_closureMiddleP_skinMiddleP = sqr((_closureFartherSideFitMPx - ((x21 + x22)/2))^2 + (_closureFartherSideFitMPy - ((y21 + y22)/2))^2)

								! distance of projecting closure gravity point and fitting wall skin endpoint
								if (dist_fitP_WallSkinP1 < EPS) then
									dist_closureMiddleP_skinEndP = sqr((_closureFartherSideFitMPx - x21)^2 + (_closureFartherSideFitMPy - y21)^2)
								else
									dist_closureMiddleP_skinEndP = sqr((_closureFartherSideFitMPx - x22)^2 + (_closureFartherSideFitMPy - y22)^2)
								endif

								! if the skin is outside of the closure then change the contour line attributes
								if dist_closureMiddleP_skinMiddleP > dist_closureMiddleP_skinEndP then
									if penIdx2 > 0 then
										contourLines[j][LINE_PEN_IDX]	= penIdx2
										contourLines[j][LINE_LTYPE_IDX]	= lineTypeIdx2
									endif
								endif
							else
								if penIdx2 > 0 then
									contourLines[j][LINE_PEN_IDX]	= penIdx2
									contourLines[j][LINE_LTYPE_IDX]	= lineTypeIdx2
								endif
							endif
						endif
					endif
				endif
			endif

			if state = 2 then	! S2 contains whole S1
				if penIdx2 > 0 then
					contourLines[j][LINE_PEN_IDX]	= penIdx2
					contourLines[j][LINE_LTYPE_IDX]	= lineTypeIdx2
				endif
			endif

			if state = 1 | state = 3 then	! (S1 contains whole S2) or (S1 and S2 has a section)

				if iStartInside = 0 then

					contourLines[j][LINE_BEG_X]	= x11
					contourLines[j][LINE_BEG_Y]	= y11
					contourLines[j][LINE_END_X]	= x21
					contourLines[j][LINE_END_Y]	= y21

					_bInsertRow = j < numContourLines
					if _bInsertRow then
						_numRow = numContourLines
						_insertedRow = j+1
						gosub "insert row to contourLines arrays"
					endif

					bx = x21
					by = y21
					if iEndInside = 0 then
						ex = x22
						ey = y22
					else
						ex = x12
						ey = y12
					endif

					numContourLines = numContourLines + 1
					contourLines[j+1][LINE_BEG_X]		= bx
					contourLines[j+1][LINE_BEG_Y]		= by
					contourLines[j+1][LINE_END_X]		= ex
					contourLines[j+1][LINE_END_Y]		= ey
					contourLines[j+1][LINE_ATTRIBUTES]	= contourLines[j][LINE_ATTRIBUTES]
					if penIdx2 > 0 then
						contourLines[j+1][LINE_PEN_IDX]		= penIdx2
						contourLines[j+1][LINE_LTYPE_IDX]	= lineTypeIdx2
					else
						contourLines[j+1][LINE_PEN_IDX]		= penIdx1
						contourLines[j+1][LINE_LTYPE_IDX]	= lineTypeIdx1
					endif
					overlappingEdgeSegmentIdx[j+1] = overlappingEdgeSegmentIdx[j]	! Index of the wall edge line segment

					if iEndInside = 0 then
						if _bInsertRow then
							_numRow = numContourLines
							_insertedRow = j+2
							gosub "insert row to contourLines arrays"
						endif

						bx = x22
						by = y22
						ex = x12
						ey = y12

						numContourLines = numContourLines + 1
						contourLines[j+2][LINE_BEG_X]		= bx
						contourLines[j+2][LINE_BEG_Y]		= by
						contourLines[j+2][LINE_END_X]		= ex
						contourLines[j+2][LINE_END_Y]		= ey
						contourLines[j+2][LINE_ATTRIBUTES]	= contourLines[j+1][LINE_ATTRIBUTES]
						contourLines[j+2][LINE_PEN_IDX]		= penIdx1
						contourLines[j+2][LINE_LTYPE_IDX]	= lineTypeIdx1
						overlappingEdgeSegmentIdx[j+2] = overlappingEdgeSegmentIdx[j]	! Overhanging line section
					endif
				else
					if iEndInside = 0 then
						contourLines[j][LINE_BEG_X]	= x11
						contourLines[j][LINE_BEG_Y]	= y11
						contourLines[j][LINE_END_X]	= x22
						contourLines[j][LINE_END_Y]	= y22
						if penIdx2 > 0 then
							contourLines[j][LINE_PEN_IDX]	= penIdx2
							contourLines[j][LINE_LTYPE_IDX]	= lineTypeIdx2
						endif

						_bInsertRow = j < numContourLines
						if _bInsertRow then
							_numRow = numContourLines
							_insertedRow = j+1
							gosub "insert row to contourLines arrays"
						endif

						bx = x22
						by = y22
						ex = x12
						ey = y12

						numContourLines = numContourLines + 1
						contourLines[j+1][LINE_BEG_X]		= bx
						contourLines[j+1][LINE_BEG_Y]		= by
						contourLines[j+1][LINE_END_X]		= ex
						contourLines[j+1][LINE_END_Y]		= ey
						contourLines[j+1][LINE_ATTRIBUTES]	= contourLines[j+1][LINE_ATTRIBUTES]
						contourLines[j+1][LINE_PEN_IDX]		= penIdx1
						contourLines[j+1][LINE_LTYPE_IDX]	= lineTypeIdx1
						overlappingEdgeSegmentIdx[j+1] = overlappingEdgeSegmentIdx[j]	! Overhanging line section
					else
						if iStartInside = 2 & iEndInside = 2 then
							if penIdx2 > 0 then
								contourLines[j][LINE_PEN_IDX]	= penIdx2
								contourLines[j][LINE_LTYPE_IDX]	= lineTypeIdx2
							endif
						endif
					endif
				endif
			endif

			j = j + 1

		while j < numContourLines + 1

	next i
endif


! ==============================================================================
! Draw standalone wall edge line sections
! ==============================================================================

numLines = vardim1(normalizedLineSections)
for i=1 to numLines
	if standaloneEdgeSegments[i] then

		px1 = normalizedLineSections[i][LINE_BEG_X]
		py1 = normalizedLineSections[i][LINE_BEG_Y]
		px2 = normalizedLineSections[i][LINE_END_X]
		py2 = normalizedLineSections[i][LINE_END_Y]
		penIdx		= normalizedLineSections[i][LINE_PEN_IDX]
		lineTypeIdx	= normalizedLineSections[i][LINE_LTYPE_IDX]
		iBitField	= round_int(normalizedLineSections[i][LINE_ATTRIBUTES])

		if penIdx > 0 then
			pen				penIdx
			line_type		lineTypeIdx
			line_property	LINE_PROPERTY_CONTOUR

			if bittest(iBitField, LINE_ATTRIBUTES_GDLLINE) then
				line2 px1,py1, px2,py2
			endif
			if bittest(iBitField, LINE_ATTRIBUTES_WALLLINE) then
				if (GLOB_PREVIEW_MODE = 0) then
					line2 px1,py1, px2,py2
				endif
				wallline2 px1,py1, px2,py2
			endif
		endif
	endif
next i


! ==============================================================================
! Draw standalone Cavity Closure line sections
! ==============================================================================

numContourLines = vardim1(contourLines)
for i=1 to min(numContourLines, vardim1(overlappingEdgeSegmentIdx))
	if overlappingEdgeSegmentIdx[i] = 0 then
		! Cavity Closure line segment is standalone if no matching
		! wallhole edge registered in overlappingEdgeSegmentIdx[] for it.

		px1 = contourLines[i][LINE_BEG_X]
		py1 = contourLines[i][LINE_BEG_Y]
		px2 = contourLines[i][LINE_END_X]
		py2 = contourLines[i][LINE_END_Y]
		lineProperty= LINE_PROPERTY_INNER + bittest(round_int(contourLines[i][LINE_ATTRIBUTES]), LINE_ATTRIBUTES_CONTOUR)	! INNER / CONTOUR
		penIdx		= contourLines[i][LINE_PEN_IDX]
		lineTypeIdx	= contourLines[i][LINE_LTYPE_IDX]

		if penIdx > 0 then
			pen				penIdx
			line_type		lineTypeIdx
			line_property	lineProperty

			if bittest(round_int(contourLines[i][LINE_ATTRIBUTES]), LINE_ATTRIBUTES_GDLLINE) then
				line2 px1,py1, px2,py2
			else
				wallline2 px1,py1, px2,py2
			endif
		endif
	endif
next i


! ==============================================================================
! Merge overlapping Cavity Closure and wallhole line segments.
! ------------------------------------------------------------------------------
! Remarks:
!	Set attributes of Cavity Closure line segments (CCLS)
!	based on the matching wallhole line segment (WHLS).
! ------------------------------------------------------------------------------
! Line Property: (Inner or Contour)
!
!	CCLS:	WHLS:	   Result:
!	Inner	Inner	-> Inner
!	Inner	Contour	-> Contour
!	Contour	Inner	-> Contour
!	Contour	Contour	-> Contour
! ------------------------------------------------------------------------------
! Pen and Line Type:
!	Always coming from the Cavity Closure line segments
! ------------------------------------------------------------------------------
! Wallline2 and/or GDL line2:
!	Wallline2 bit is set by default of course
!	GLD line2 bit is set too if matching wallhole line segment have this bit
! ------------------------------------------------------------------------------
! Visibility:
!	It is controlled with the zero pen index
!	Hidden (0) if pen index = 0
!	Shown (1) if pen idx > 0
!
!	CCLS:	WHLS:	   Result:
!	0		0		-> 0
!	0		1		-> 0
!	1		0		-> 1
!	1		0		-> 1
! ==============================================================================

numContourLines = vardim1(contourLines)
for i=1 to min(numContourLines, vardim1(overlappingEdgeSegmentIdx))
	edgeSegmentIdx = overlappingEdgeSegmentIdx[i]	! Index of the matching wallhole line segment
	if edgeSegmentIdx > 0 then

		iBitField		= round_int(contourLines[i][LINE_ATTRIBUTES])				! Own bitfield
		iEdgeBitField	= round_int(normalizedLineSections[edgeSegmentIdx][LINE_ATTRIBUTES])	! Matching line section's bitfield

! Line Property: (Inner or Contour) --------------------------------------------

		if bittest (iEdgeBitField, LINE_ATTRIBUTES_CONTOUR) then
			iBitField = bitset (iBitField, LINE_ATTRIBUTES_CONTOUR, 1)
		endif

! Wallline2 and/or GDL line2: --------------------------------------------------

		if bittest (iEdgeBitField, LINE_ATTRIBUTES_GDLLINE) then
			iBitField = bitset (iBitField, LINE_ATTRIBUTES_GDLLINE, 1)
		endif

! Visibility: ------------------------------------------------------------------

		! Nothing to do

! ------------------------------------------------------------------------------

		contourLines[i][LINE_ATTRIBUTES] = iBitField

	endif
next i


! ==============================================================================
! Cut off Cavity Closure line segments from the matching wallhole line segments
! ==============================================================================

dim standaloneEdgeSegmentFragments[]
for i = 1 to vardim1(normalizedLineSections)
	standaloneEdgeSegmentFragments[i] = 0	! initializing
next i

numContourLines = vardim1(contourLines)
for i=1 to min(numContourLines, vardim1(overlappingEdgeSegmentIdx))
	edgeSegmentIdx = overlappingEdgeSegmentIdx[i]	! Index of the matching wallhole line segment
	if edgeSegmentIdx > 0 then

		! The _bClosureContour is needed in every cases to show the overlapping
		! (wall contour on closure contour) edges because the state of "Show Opening Only"
		! MVO function are not queried.
		! If it will have a query then this parameter are deletable.
		_bClosureContour = bittest(round_int(contourLines[i][LINE_ATTRIBUTES]), LINE_ATTRIBUTES_CONTOUR_CLOSURE)
		x11 = contourLines[i][LINE_BEG_X]
		y11 = contourLines[i][LINE_BEG_Y]
		x12 = contourLines[i][LINE_END_X]
		y12 = contourLines[i][LINE_END_Y]

		x21 = normalizedLineSections[edgeSegmentIdx][LINE_BEG_X]
		y21 = normalizedLineSections[edgeSegmentIdx][LINE_BEG_Y]
		x22 = normalizedLineSections[edgeSegmentIdx][LINE_END_X]
		y22 = normalizedLineSections[edgeSegmentIdx][LINE_END_Y]

		gosub 999	! Segment - Segment sections

		if state = 1 then	! S1 contains whole S2
			if _bClosureContour then
				standaloneEdgeSegmentFragments[edgeSegmentIdx] = 1
			else
				! Do not need to draw this segment
				standaloneEdgeSegmentFragments[edgeSegmentIdx] = 0
			endif
		endif

		if state = 2 then	! S2 contains whole S1

			if iStartInside = 2 then
				if _bClosureContour then
					! Do not need to cut this segment with closure contour
pen 30
					standaloneEdgeSegmentFragments[edgeSegmentIdx] = 1
				else
					if iEndInside = 2 then
						normalizedLineSections[edgeSegmentIdx][LINE_BEG_X] = 0
						normalizedLineSections[edgeSegmentIdx][LINE_BEG_Y] = 0
						normalizedLineSections[edgeSegmentIdx][LINE_END_X] = 0
						normalizedLineSections[edgeSegmentIdx][LINE_END_Y] = 0
pen 5
standaloneEdgeSegmentFragments[edgeSegmentIdx] = 0
					else
						normalizedLineSections[edgeSegmentIdx][LINE_BEG_X] = x12
						normalizedLineSections[edgeSegmentIdx][LINE_BEG_Y] = y12
						normalizedLineSections[edgeSegmentIdx][LINE_END_X] = x22
						normalizedLineSections[edgeSegmentIdx][LINE_END_Y] = y22
pen 20
standaloneEdgeSegmentFragments[edgeSegmentIdx] = 1
					endif
				endif
			else
				if iEndInside = 2 then
					if _bClosureContour then
						! Do not need to cut this segment with closure contour
pen 30
						standaloneEdgeSegmentFragments[edgeSegmentIdx] = 1
					else
						normalizedLineSections[edgeSegmentIdx][LINE_BEG_X] = x21
						normalizedLineSections[edgeSegmentIdx][LINE_BEG_Y] = y21
						normalizedLineSections[edgeSegmentIdx][LINE_END_X] = x11
						normalizedLineSections[edgeSegmentIdx][LINE_END_Y] = y11
pen 1
standaloneEdgeSegmentFragments[edgeSegmentIdx] = 1
					endif
				else
pen 4
				endif
			endif

		x21 = normalizedLineSections[edgeSegmentIdx][LINE_BEG_X]
		y21 = normalizedLineSections[edgeSegmentIdx][LINE_BEG_Y]
		x22 = normalizedLineSections[edgeSegmentIdx][LINE_END_X]
		y22 = normalizedLineSections[edgeSegmentIdx][LINE_END_Y]
!RRR=RRR+0.002
!!			circle2 x11,y11, RRR
!!			circle2 x12,y12, RRR
!			circle2 x21,y21, RRR
!			circle2 x22,y22, RRR
		endif
	endif
next i


! ==============================================================================
! Draw standalon wallhole line section fragments
! ==============================================================================

!!!add2 0.01, 0.01
numLines = vardim1(standaloneEdgeSegmentFragments)
for i=1 to numLines
	if standaloneEdgeSegmentFragments[i] then

		penIdx = round_int(normalizedLineSections[i][LINE_PEN_IDX])

		if penIdx > 0 then
			iBitField	= round_int(normalizedLineSections[i][LINE_ATTRIBUTES])

			pen				penIdx
			line_type		round_int(normalizedLineSections[i][LINE_LTYPE_IDX])
			line_property	LINE_PROPERTY_INNER + (bittest(iBitField, LINE_ATTRIBUTES_CONTOUR))	! INNER / CONTOUR

			px1 = normalizedLineSections[i][LINE_BEG_X]
			py1 = normalizedLineSections[i][LINE_BEG_Y]
			px2 = normalizedLineSections[i][LINE_END_X]
			py2 = normalizedLineSections[i][LINE_END_Y]

			if bittest(iBitField, LINE_ATTRIBUTES_GDLLINE) then
				line2 px1,py1, px2,py2
			endif
			if bittest(iBitField, LINE_ATTRIBUTES_WALLLINE) then
				if (GLOB_PREVIEW_MODE = 0) then
					line2 px1,py1, px2,py2
				endif
				wallline2 px1,py1, px2,py2
			endif
		endif
	endif
next i

!!!del 1

! ==============================================================================
! Draw
! ==============================================================================

numContourLines = vardim1(contourLines)
for i=1 to min(numContourLines, vardim1(overlappingEdgeSegmentIdx))
	if overlappingEdgeSegmentIdx[i] > 0 then

		penIdx = round_int(contourLines[i][LINE_PEN_IDX])

		if penIdx > 0 then
			iBitField	= round_int(contourLines[i][LINE_ATTRIBUTES])

			pen				penIdx
			line_type		round_int(contourLines[i][LINE_LTYPE_IDX])
			line_property	LINE_PROPERTY_INNER + (bittest(iBitField, LINE_ATTRIBUTES_CONTOUR))	! INNER / CONTOUR

			px1 = contourLines[i][LINE_BEG_X]
			py1 = contourLines[i][LINE_BEG_Y]
			px2 = contourLines[i][LINE_END_X]
			py2 = contourLines[i][LINE_END_Y]

!!!RRR=RRR+0.0005
!!!circle2 px1,py1, RRR
!!!circle2 px2,py2, RRR

			if bittest(iBitField, LINE_ATTRIBUTES_GDLLINE) then
				line2 px1,py1, px2,py2
			endif
			if bittest(iBitField, LINE_ATTRIBUTES_WALLLINE) then
				if (GLOB_PREVIEW_MODE = 0) then
					line2 px1,py1, px2,py2
				endif
				wallline2 px1,py1, px2,py2
			endif
		endif
	endif
next i

del 1

return


! ==============================================================================
! Segment - Segment sections
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12:	S1 segment
!	x21,y21, x22,y22:	S2 segment
!
! Returned variables:
!	state:				 0 = S1 and S2 segments not on the same line
!						-1 = disjunct segments
!						 1 = S1 contains whole S2
!						 2 = S2 contains whole S1
!						 3 = S1 and S2 has a section
!	iStartInside:		 0 = S1 line segment starts outside of S2 line segment
!						 1 = S1 line segment starts inside of S2 line segment
!						 2 = S1 line segment starts on the S2 line segment's start point
!	iEndInside:			 The same for the end points
!
!-------------------------------------------------------------------------------
!   iEndInside -----------+
!   iStartInside ----+    |
!   state ------+    |    |
!               |    |    |
!-------------------------------------------------------------------------------
!               1    0    0   Not valid
!
!               1    1    0   Not valid
!
!               1    0    1   Not valid
!
!               1    1    1   Not valid
!
!               1    1    1   (S1)  B1 o--------------------------o E1
!                             (S2)  B2     o------------------o     E2
!
!               1    2    1   (S1)  B1 o--------------------------o E1
!                             (S2)  B2 o----------------------o     E2
!
!               1    1    2   (S1)  B1 o--------------------------o E1
!                             (S2)  B2     o----------------------o E2
!
!               1    2    2   (S1)  B1 o--------------------------o E1
!                             (S2)  B2 o--------------------------o E2
!
!               2    1    1   (S1)  B1     o------------------o     E1
!                             (S2)  B2 o--------------------------o E2
!
!               2    2    1   (S1)  B1 o----------------------o     E1
!                             (S2)  B2 o--------------------------o E2
!
!               2    1    2   (S1)  B1     o----------------------o E1
!                             (S2)  B2 o--------------------------o E2
!
!               2    2    2   (S1)  B1 o--------------------------o E1
!                             (S2)  B2 o--------------------------o E2
!
!               3    0    0   Not valid
!
!               3    0    1   (S1)  B1 o----------------------o     E1
!                             (S2)  B2     o----------------------o E2
!
!               3    1    0   (S1)  B1     o----------------------o E1
!                             (S2)  B2 o----------------------o     E2
!
!               3    0    2   (S1)  B1 o--------------------------o E1
!                             (S2)  B2     o----------------------o E2
!
!               3    2    0   (S1)  B1 o--------------------------o E1
!                             (S2)  B2 o----------------------o     E2
!
!               3    1    1   Not valid
!
!               3    2    2   Not valid
! ==============================================================================

999:
	lineL1 = sqr((x12 - x11)^2 + (y12 - y11)^2)
	if lineL1 < EPS then
		state = 0
	else
		if (abs((y12 - y11)*(x21 - x11) - (x12 - x11) * (y21 - y11)) / lineL1) > EPS then
			state = 0
		else
			state = -1
		endif
	endif

	if state <> 0 then
		lineL2 = sqr((x12 - x11)^2 + (y12 - y11)^2)
		if lineL2 < EPS then
			state = 0
		else
			if (abs((y12 - y11)*(x22 - x11) - (x12 - x11) * (y22 - y11)) / lineL2) > EPS then
				state = 0
			else
				state = -1
			endif
		endif
	endif

	if state <> 0 then
		bHorizontal = (abs(y11 - y12) < EPS)
		if not(bHorizontal) then
			if atn(abs(x11 - x12) / abs(y11 - y12)) > 45 then bHorizontal = 1
		endif

		if bHorizontal then
			! Mostly horizonal segmens

			if x11 > x12 then
				temp = x11
				x11 = x12
				x12 = temp

				temp = y11
				y11 = y12
				y12 = temp
			endif

			if x21 > x22 then
				temp = x21
				x21 = x22
				x22 = temp

				temp = y21
				y21 = y22
				y22 = temp
			endif

			iStartInside = (x21 - EPS < x11 & x22 + EPS > x11)
			if iStartInside > 0 then
				iStartInside = iStartInside + (abs(x21 - x11) < EPS | abs(x22 - x11) < EPS)
			endif
			iEndInside	 = (x21 - EPS < x12 & x22 + EPS > x12)
			if iEndInside > 0 then
				iEndInside = iEndInside + (abs(x21 - x12) < EPS | abs(x22 - x12) < EPS)
			endif

			if (x21 > x12 - EPS) | (x22 < x11 + EPS) then
				state = -1	! Disjunct segments
			else
				if (x21 > x11 - EPS) & (x22 < x12 + EPS) then
					state = 1
				else
					if (x21 < x11 + EPS) & (x22 > x12 - EPS) then
						state = 2
					else
						state = 3
					endif
				endif
			endif
		else
			! Mostly vertical segmens

			if y11 > y12 then
				temp = x11
				x11 = x12
				x12 = temp

				temp = y11
				y11 = y12
				y12 = temp
			endif

			if y21 > y22 then
				temp = x21
				x21 = x22
				x22 = temp

				temp = y21
				y21 = y22
				y22 = temp
			endif

			iStartInside = (y21 - EPS < y11 & y22 + EPS > y11)
			if iStartInside > 0 then
				iStartInside = iStartInside + (abs(y21 - y11) < EPS | abs(y22 - y11) < EPS)
			endif
			iEndInside	 = (y21 - EPS < y12 & y22 + EPS > y12)
			if iEndInside > 0 then
				iEndInside = iEndInside + (abs(y21 - y12) < EPS | abs(y22 - y12) < EPS)
			endif

			if (y21 > y12 - EPS) | (y22 < y11 + EPS) then
				state = -1	! Disjunct segments
			else
				if (y21 > y11 - EPS) & (y22 < y12 + EPS) then
					state = 1
				else
					if (y21 < y11 + EPS) & (y22 > y12 - EPS) then
						state = 2
					else
						state = 3
					endif
				endif
			endif
		endif
	endif
return


! ==============================================================================
! Line - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12	line #1
!	x21,y21, x22,y22	line #2
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = valid intersection point
!	cx, cy:				intersection point
! ==============================================================================

100:
	lliDiv = (x11-x12) * (y21-y22) - (y11-y12) * (x21-x22)

	if abs(lliDiv) > EPS then
		! Intersection

		temp1 = x11 * y12 - y11 * x12
		temp2 = x21 * y22 - y21 * x22

		tempx = temp1 * (x21-x22) - (x11-x12) * temp2
		tempy = temp1 * (y21-y22) - (y11-y12) * temp2

		state = 1
		cx = (tempx / lliDiv)
		cy = (tempy / lliDiv)
	else
		! No Intersection
		state = 0
		cx = 0
		cy = 0
	endif
return


! ==============================================================================
! Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	xo,yo,ro:			circle
!	x1,y1, x2,y2		line
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = one intersection point (tangential line)
!						2 = two intersection points
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
! ==============================================================================

101:
	tempX1 = x1 - xo: tempY1 = y1 - yo
	tempX2 = x2 - xo: tempY2 = y2 - yo

	if abs(tempX2 - tempX1) < EPS then
		if abs(ro - abs(tempX1)) < EPS then
			state = 1
			xa = tempX1
			ya = 0
			xb = tempX1
			yb = 0
		else
			if abs(ro) - abs(tempX1) < 0 then
				state = 0: xa = 0: ya = 0: xb = 0: yb = 0
			else
				state = 2
				xa = tempX1
				ya = sqr(ro^2 - tempX1^2)
				xb = tempX1
				yb = -sqr(ro^2 - tempX1^2)
			endif
		endif
	else
		kf = (tempY2 - tempY1) / (tempX2 - tempX1)
		ad = 1 + kf^2
		bd = 2 * tempY1 * kf - 2 * tempX1 * kf^2
		cd = tempY1^2 - 2 * tempX1 * tempY1 * kf + tempX1^2 * kf^2 - ro^2

		if bd^2 - 4 * ad * cd < 0 then
			state = 0: xa = 0: ya = 0: xb = 0: yb = 0
		else
			xa = (-bd + sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			ya = tempY1 + (xa - tempX1) * kf
			xb = (-bd - sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			yb = tempY1 + (xb - tempX1) * kf

			if abs(xa - xb) < EPS then state = 1 else state = 2
		endif
	endif

	if state = 2 then
		da = sqr((tempX1 - xa)^2 + (tempY1 - ya)^2)
		db = sqr((tempX1 - xb)^2 + (tempY1 - yb)^2)

		if db < da then
			xxo = xa: yyo = ya
			xa = xb:  ya = yb
			xb = xxo: yb = yyo
		endif
	endif

	xa = xa + xo: ya = ya + yo
	xb = xb + xo: yb = yb + yo
return


! ==============================================================================
! Select good intersection point after Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	state:				intersection status
!	wallIsLeft:
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
!
! Returned variables:
!	cx, cy:				selected intersection point
! ==============================================================================

102:
	cx = 0
	cy = 0
	if state = 1 then
		cx = xa
		cy = ya
	endif
	if state = 2 then
		if wallIsLeft then
			if ya > yb then
				cx = xa
				cy = ya
			else
				cx = xb
				cy = yb
			endif
		else
			if ya < yb then
				cx = xa
				cy = ya
			else
				cx = xb
				cy = yb
			endif
		endif
	endif
return


! ==============================================================================
! Direction Angle
! ------------------------------------------------------------------------------
! Input variables:
!	vx, vy:				vector
!
! Returned variables:
!	alpha:				selected intersection point
! ==============================================================================

103:

if abs(vx) < EPS & abs(vy) < EPS then
	angle = 0
	return
endif

if abs(vx) < EPS then
	if vy > 0 then
		angle = 90
	else
		angle = 270
	endif
else
	angle = atn(vy / vx)
	if vx >= 0 then
		if angle < 0 then
			angle = angle + 360
		endif
	else
		angle = 180 + angle
	endif
endif

return


! ==============================================================================
! Draw wallblock with contour
! ------------------------------------------------------------------------------
! Input variables:
!	stack:				wallblock polygon
!	penFillFg:			fill foreground pen (pen index)
!	penFillBg:			fill background pen (pen index)
!	bLocalFill:			fill orientation (0 / 1)
!	bDrawContour:		draw contour lines
!	bFitToSkinFill:		use soft insulation fill (0 / 1)
!	skinTurnThk:		skin thickness in case of bFitToSkinFill
!	penIdx:
!	lineTypeIdx:
! ==============================================================================

200:
	if nsp >= 9 then
		dirAngle = -signWallIsLeft * atn(vectS / vectC)

		if bDrawWallBlock then
			wallblock2{2} nsp/3 + 1, 2, 2,8 * (bLocalFill | bFitToSkinFill) + 32 * bFitToSkinFill + 128 * (bLocalFill & not(bFitToSkinFill)),
				penFillFg, penFillBg,
				use(2),
				-sin(dirAngle),-cos(dirAngle), -skinTurnThk*cos(dirAngle),skinTurnThk*sin(dirAngle),
				0,
				0,-WOD,900,
				use(nsp)
		else
			poly2_b{5} nsp/3 + 1, 2+4, 2,8 * (bLocalFill | bFitToSkinFill) + 32 * bFitToSkinFill,
				penFillFg, penFillBg,
				use(2),
				-sin(dirAngle),-cos(dirAngle), -skinTurnThk*cos(dirAngle),skinTurnThk*sin(dirAngle),
				0,
				0,-WOD,900,
				use(nsp)
		endif
	endif
	if nsp < 9 | not(bDrawContour) then
		for ii=1 to nsp
			n = get(1)
		next ii
		return
	endif

	numPoints = nsp/3
	for ii=1 to numPoints
		if ii = 1 then
			x1 = get(1)
			y1 = get(1)
			s1 = get(1)
			firstX = x1
			firstY = y1
			firstS = s1
		endif
		if ii = numPoints then
			x2 = firstX
			y2 = firstY
			s2 = firstS
		else
			x2 = get(1)
			y2 = get(1)
			s2 = get(1)
		endif

		if bittest(s2, 0) then
			if s2 >= 3000 then
				R = sqr(x2^2 + (y2 + WOD)^2)

				vx = x1
				vy = y1 + WOD
				gosub 103	! Direction Angle
				alpha = angle

				vx = x2
				vy = y2 + WOD
				gosub 103	! Direction Angle
				beta = angle

				if abs(alpha - beta) > EPS then
					if bClosureContour then
						arc2 0,-WOD, R, min(alpha,beta), max(alpha,beta)
					else
						wallarc2 0,-WOD, R, min(alpha,beta), max(alpha,beta)
					endif
				endif
			else
!				wallline2 x1,y1, x2,y2

				bpx = x1
				bpy = y1
				epx = x2
				epy = y2
				!penIdx		= tempPen
				!lineTypeIdx	= tempLineType

				iAttributes	= bitset(0, LINE_ATTRIBUTES_CONTOUR, 0) + bitset(0, LINE_ATTRIBUTES_CONTOUR_CLOSURE, bClosureContour)
				gosub 4920	! Put line section into Cavity Closure lines array
			endif
		endif

		x1 = x2
		y1 = y2
		s1 = s2
	next ii
return


! ==============================================================================
! Segment - Segment sections
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12:	S1 segment
!	x21,y21, x22,y22:	S2 segment
!
! Returned variables:
!	state:				 0 = S1 and S2 segments not on the same line
!						-1 = disjunct segments
!						 1 = S1 contains whole S2
!						 2 = S2 contains whole S1
!						 3 = S1 and S2 has a section
! ==============================================================================

300:
	lineL1 = sqr((x12 - x11)^2 + (y12 - y11)^2)
	if lineL1 < EPS then
		state = 0
	else
		if (abs((y12 - y11)*(x21 - x11) - (x12 - x11) * (y21 - y11)) / lineL1) > EPS then
			state = 0
		else
			state = -1
		endif
	endif

	if state <> 0 then
		lineL2 = sqr((x12 - x11)^2 + (y12 - y11)^2)
		if lineL2 < EPS then
			state = 0
		else
			if (abs((y12 - y11)*(x22 - x11) - (x12 - x11) * (y22 - y11)) / lineL2) > EPS then
				state = 0
			else
				state = -1
			endif
		endif
	endif

	if state <> 0 then
		bHorizontal = (abs(y11 - y12) < EPS)
		if not(bHorizontal) then
			if atn(abs(x11 - x12) / abs(y11 - y12)) > 45 then bHorizontal = 1
		endif

		if bHorizontal then
			! Mostly horizonal segmens

			if x11 > x12 then
				temp = x11
				x11 = x12
				x12 = temp

				temp = y11
				y11 = y12
				y12 = temp
			endif

			if x21 > x22 then
				temp = x21
				x21 = x22
				x22 = temp

				temp = y21
				y21 = y22
				y22 = temp
			endif

			iStartInside = (x21 - EPS < x11 & x22 + EPS > x11)
			if iStartInside > 0 then
				iStartInside = iStartInside + (abs(x21 - x11) < EPS | abs(x22 - x11) < EPS)
			endif
			iEndInside	 = (x21 - EPS < x12 & x22 + EPS > x12)
			if iEndInside > 0 then
				iEndInside = iEndInside + (abs(x21 - x12) < EPS | abs(x22 - x12) < EPS)
			endif

			if (x21 > x12 - EPS) | (x22 < x11 + EPS) then
				state = -1	! Disjunct segments
			else
				if (x21 > x11 - EPS) & (x22 < x12 + EPS) then
					state = 1
				else
					if (x21 < x11 + EPS) & (x22 > x12 - EPS) then
						state = 2
					else
						state = 3
					endif
				endif
			endif
		else
			! Mostly vertical segmens

			if y11 > y12 then
				temp = x11
				x11 = x12
				x12 = temp

				temp = y11
				y11 = y12
				y12 = temp
			endif

			if y21 > y22 then
				temp = x21
				x21 = x22
				x22 = temp

				temp = y21
				y21 = y22
				y22 = temp
			endif

			iStartInside = (y21 - EPS < y11 & y22 + EPS > y11)
			if iStartInside > 0 then
				iStartInside = iStartInside + (abs(y21 - y11) < EPS | abs(y22 - y11) < EPS)
			endif
			iEndInside	 = (y21 - EPS < y12 & y22 + EPS > y12)
			if iEndInside > 0 then
				iEndInside = iEndInside + (abs(y21 - y12) < EPS | abs(y22 - y12) < EPS)
			endif

			if (y21 > y12 - EPS) | (y22 < y11 + EPS) then
				state = -1	! Disjunct segments
			else
				if (y21 > y11 - EPS) & (y22 < y12 + EPS) then
					state = 1
				else
					if (y21 < y11 + EPS) & (y22 > y12 - EPS) then
						state = 2
					else
						state = 3
					endif
				endif
			endif
		endif
	endif

!!!lineTypeIdx2	= normalizedLineSections[idx + LINE_LTYPE_IDX]
!!!penIdx2			= normalizedLineSections[idx + LINE_PEN_IDX]
!!!bContourLine1	= 1
!!!iBitField		= round_int(normalizedLineSections[idx + LINE_ATTRIBUTES])
!!!bNeedGDLLine2	= (bittest(iBitField, LINE_ATTRIBUTES_GDLLINE))		! Need GDL line too

!	if state = 0 | state = -1 then	! not on the same line or disjunct segments
	if state = -1 then	! disjunct segments
		return

		bx = x11
		by = y11
		ex = x12
		ey = y12
		lineTypeIdx		= lineTypeIdx1
		penIdx			= penIdx1
		bContourLine	= (bContourLine1 | bContourLine2)
		bNeedGDLLine	= bNeedGDLLine1
		gosub 301

		return
	endif

	if state = 1 then	! S1 contains whole S2

		bx = x21
		by = y21
		ex = x22
		ey = y22
		lineTypeIdx		= lineTypeIdx1
		penIdx			= penIdx1
		bContourLine	= (bContourLine1 | bContourLine2)
		bNeedGDLLine	= bNeedGDLLine1
		gosub 301

		return
	endif

	if state = 2 then	! S2 contains whole S1
	endif

	if state = 3 then	! S1 and S2 has a section
	endif

	bx = x11
	by = y11
	ex = x11
	ey = y11
!	gosub 301	! S1 out

	if iStartInside = 0 then
		bx = x12
		by = y12
	else
		bx = x21
		by = y21
	endif

	ex = x11
	ey = y11
!	gosub 301	! S1 out
return


301:
!!	if vardim1(jdxArray) >= actualJdx + 1 then
!!		if jdxArray[actualJdx + 1] then
!!			return
!!		endif
!!	endif
!!	jdxArray[actualJdx + 1] = 1
!
!	mergedSections[mdx + CLINE_BEG_X] = bx
!	mergedSections[mdx + CLINE_BEG_Y] = by
!	mergedSections[mdx + CLINE_END_X] = ex
!	mergedSections[mdx + CLINE_END_Y] = ey
!	mergedSections[mdx + LINE_PEN_IDX]	= penIdx
!	mergedSections[mdx + LINE_LTYPE_IDX]= lineTypeIdx
!	if bContourLine then
!		mergedSections[mdx + CLINE_PROPERTY] = LINE_PROPERTY_CONTOUR
!	else
!		mergedSections[mdx + CLINE_PROPERTY] = LINE_PROPERTY_INNER
!	endif
!	mergedSections[mdx + CLINE_GDL] = (bNeedGDLLine)
!	mdx = mdx + CLINE_STRUCTURE_SIZE
return

302:
return


! ==============================================================================
! Searching for a fitting point to line
! ------------------------------------------------------------------------------
! Input variables:
!	EPS
!	dVx, dVy			direction vector of the line
!	linePx, linePy		coordinates of a point of the line
!	pointPx, pointPy	coordinates of the point
!
! Output variables:
!	bFitPoint		state of fitting - 1: true, 0: false
! ------------------------------------------------------------------------------
"SearchFitPointToLine":
	! Calculate A, B and C parameter
	! paramA, paramB are equal to normal vector of the line
	paramA = -dVy
	paramB = dVx
	paramC = -(paramA*linePx) - (paramB*linePy)

	! Calculate distance
	_distPointLine = (abs((paramA * pointPx) + (paramB * pointPy) + paramC)) / (sqr(paramA^2 + paramB^2))
	if _distPointLine < EPS then
		bFitPoint = 1
	else
		bFitPoint = 0
	endif
return


! ==============================================================================
! Collect composite wall skins sizes and attributes
! ------------------------------------------------------------------------------
! Input variables:
!	WALL_SKINS_PARAMS array
!	WALL_SKINS_NUMBER
!	iSkin
!	
! Output variables:
!	_wallSkinSectionLines array
! ------------------------------------------------------------------------------
"CollectWallSkinSectionLines":

	_bpx = _closureFartherSidePx
	_epx = _closureFartherSidePx
	_bpy = 0

	for idx = 1 to WALL_SKINS_NUMBER
		_epy = _bpy + WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]

		_wallSkinSectionLines[iSkin][LINE_BEG_X]			= _bpx * signX * sideSign
		_wallSkinSectionLines[iSkin][LINE_BEG_Y]			= _bpy * signY + offsetY
		_wallSkinSectionLines[iSkin][LINE_END_X]			= _epx * signX * sideSign
		_wallSkinSectionLines[iSkin][LINE_END_Y]			= _epy * signY + offsetY
		_wallSkinSectionLines[iSkin][LINE_ATTRIBUTES]		= 0		! unused
		_wallSkinSectionLines[iSkin][LINE_PEN_IDX]			= WALL_SKINS_PARAMS[idx][SKIN_END_FACE_PEN]
		_wallSkinSectionLines[iSkin][LINE_LTYPE_IDX]		= WALL_SKINS_PARAMS[idx][SKIN_END_LINE_TYPE]

		_bpy = _epy
		iSkin = iSkin + 1
	next idx
return


! ==============================================================================
! Insert row to contourLines and overlappingEdgeSegmentIdx array
! ------------------------------------------------------------------------------
! Input variables:
!	contourLines
!	overlappingEdgeSegmentIdx
!	_insertedRow
!	_numRow
! ------------------------------------------------------------------------------
"insert row to contourLines arrays":
	for _iRow = _numRow to _insertedRow step -1
		contourLines[_iRow + 1][LINE_BEG_X]			= contourLines[_iRow][LINE_BEG_X]
		contourLines[_iRow + 1][LINE_BEG_Y]			= contourLines[_iRow][LINE_BEG_Y]
		contourLines[_iRow + 1][LINE_END_X]			= contourLines[_iRow][LINE_END_X]
		contourLines[_iRow + 1][LINE_END_Y]			= contourLines[_iRow][LINE_END_Y]
		contourLines[_iRow + 1][LINE_ATTRIBUTES]	= contourLines[_iRow][LINE_ATTRIBUTES]
		contourLines[_iRow + 1][LINE_PEN_IDX]		= contourLines[_iRow][LINE_PEN_IDX]
		contourLines[_iRow + 1][LINE_LTYPE_IDX]		= contourLines[_iRow][LINE_LTYPE_IDX]

		overlappingEdgeSegmentIdx[_iRow + 1] = overlappingEdgeSegmentIdx[_iRow]
	next _iRow
return
]]>
</Script_2D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_1D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! const values for parameter: iCustomCCEditWallSide
EDITED_WALL_FACE_OUTSIDE = 1
EDITED_WALL_FACE_INSIDE  = 2


! const values for parameter: iCustomCCEditJambSide
EDITED_JAMB_SIDE_BOTH  = 1
EDITED_JAMB_SIDE_LEFT  = 2
EDITED_JAMB_SIDE_RIGHT = 3


! const values for parameter: iCustomCCThicknessType
THICKNESS_TYPE_ORIGINAL = 1
THICKNESS_TYPE_CUSTOM   = 2


! const values for parameter: iCustomCCEditSkin
EDITED_SKIN_1 = 1
EDITED_SKIN_2 = 2
EDITED_SKIN_3 = 3
EDITED_SKIN_4 = 4


! const values for parameter: iCustomCCOrientation
ORIENTATION_ORIGINAL  = 1
ORIENTATION_TURNED_IN = 2

EPS = 0.0001

! ==============================================================================

! iWindowShape:
SHAPE_RECTANGULAR	= 0

! iRevealType:
REVEAL_EDGE				= 0
REVEAL_NO				= 1
REVEAL_POSITIVE			= 2
REVEAL_NEGATIVE			= 3
REVEAL_SLANTED			= 4
REVEAL_SPLAYED			= 5
REVEAL_HISTORIC			= 6
REVEAL_DOUBLE			= 7
REVEAL_DOUBLE_SPLAYED	= 8
REVEAL_OUTSIDE_SPLAYED	= 9

! iClosureType:
CLOSURE_NO					= 0
CLOSURE_TRADITIONAL			= 1
CLOSURE_PREFABRICATED		= 2
CLOSURE_CUSTOM				= 3
CLOSURE_SOLID_WALL			= 4
CLOSURE_STUD_WALL			= 5
CLOSURE_STUD_WALL_SIDING	= 6
CLOSURE_BRICK_VENEER		= 7
CLOSURE_VARIABLE			= 8
CLOSURE_PLASTER_REVEAL	 			= 9		! same as CLOSURE_CUSTOM
CLOSURE_INSULATED_REVEAL			= 10	! same as CLOSURE_CUSTOM
CLOSURE_INSULATED_FOR_RENOVATION	= 11	! same as CLOSURE_CUSTOM
CLOSURE_FINISH						= 12	! same as CLOSURE_TRADITIONAL
CLOSURE_AIR_SPACE					= 13	! same as CLOSURE_PREFABRICATED
CLOSURE_DUTCH_VARIABLE				= 14

CLOSURE_CUSTOM_PRESETS				= 9		! Common enable bit for the preset Custom Closure types
											!	CLOSURE_PLASTER_REVEAL
											!	CLOSURE_INSULATED_REVEAL
											!	CLOSURE_INSULATED_FOR_RENOVATION
CLOSURE_TRADITIONAL_PRESETS			= 10	! Common enable bit for the preset Traditional Closure types
											!	CLOSURE_FINISH
CLOSURE_PREFABRICATED_PRESETS		= 11	! Common enable bit for the preset Traditional Closure types
											!	CLOSURE_AIR_SPACE

! gs_custom_cc_array_left and gs_custom_cc_array_right columns:
CUSTOMCC_BITFIELD	= 1
CUSTOMCC_THICKNESS	= 2
CUSTOMCC_OVERHANG	= 3
CUSTOMCC_PEN		= 4

! lineSections[i][]:
LINE_BEG_X		= 1
LINE_BEG_Y		= 2
LINE_END_X		= 3
LINE_END_Y		= 4
LINE_ATTRIBUTES	= 5	! bitfield, look at LINE_ATTRIBUTES_xxx for available values
LINE_PEN_IDX	= 6
LINE_LTYPE_IDX	= 7
LINE_STRUCTURE_SIZE	= 7

LINE_ATTRIBUTES_GDLLINE		= 0			! Draw GDL Line in the section
LINE_ATTRIBUTES_WALLLINE	= 1			! Draw WallLine in the section
LINE_ATTRIBUTES_WALLSIDE	= 2			! The section is on the wall side (it is an arc in curved wall)
LINE_ATTRIBUTES_DRAWCC		= 3			! The section is drawn by CavityClosure macro (otherwise the WallHoleCut macro)
LINE_ATTRIBUTES_CONTOUR		= 4			! The section is contour or inner line
LINE_ATTRIBUTES_CONTOUR_CLOSURE	= 5		! The section is contour or inner line of variable or dutch closure
!!!LINE_ATTRIBUTES_WALLEDGE	= 0			! The section is on the wall edge (always a line)

! iCavityClosureSide:
CAVITY_SIDE_BOTH	= 1
CAVITY_SIDE_LEFT	= 2
CAVITY_SIDE_RIGHT	= 3
CAVITY_SIDE_NONE	= 4

! iCavityClosureTurnDir:
CAVITY_TURN_REFERENCE	= 1
CAVITY_TURN_OPPOSITE	= 2

! ==============================================================================

bInclinedWall	= (abs(WALL_INCL) > EPS)
curvedWall		= (abs(WIDO_ORIG_DIST) > EPS)
signCurvedWall	= not(curvedWall) - curvedWall

bRotAngle180	= SYMB_ROTANGLE > EPS
wallIsLeft		= bRotAngle180 exor WIDO_REVEAL_SIDE
signWallIsLeft	= wallIsleft - not(wallIsleft)

leftAlfa		= 0
rightAlfa		= 0
alfaJamb		= 0
ArcLengthSillToAngle	= 0

plugOnWindow	= 0
dirAngle		= 0
baseSkinRadius	= 0
slantLength		= 0
skinTurnThk		= 0

! ==============================================================================
! Compatibility
! ==============================================================================

if refWidth < EPS then refWidth = A
if leftWidth < EPS then leftWidth = A / 2
if rightWidth < EPS then rightWidth = A / 2


! ==============================================================================

gs_bTurnDir = (iCavityClosureTurnDir = CAVITY_TURN_REFERENCE)


! ==============================================================================
! Parameter Restrictions - only for the 2D and 3D scripts
! ==============================================================================

if GLOB_SCRIPT_TYPE = 2 | GLOB_SCRIPT_TYPE = 3 then
	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		gs_reveal_left	= 0
		gs_reveal_right	= 0
	endif

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE then
		gs_reveal_left_angle  = 0
		gs_reveal_right_angle = 0
	endif

	if WIDO_SILL < EPS & (iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE) then
		iRevealType = REVEAL_NO
	endif

	if iClosureType	= CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
		gs_bJoint = 1
		gs_showJoint = 1
		if gs_cc_dutch_thkJoint < EPS then gs_bJoint = 0
	else
		if not(gs_bJoint) then gs_thkJoint = 0
		if gs_thkJoint < EPS then gs_bJoint = 0
	endif

	if GLOB_SCRIPT_TYPE = 2 & AC_Hole_Display_Option = 5 then	! Overhead All
		gs_bAutoTurnIn		= 0		! Do not turn plasters in this display mode
		gs_bOverIn			= 0
		bDrawObjContourIn	= 1		! Always draw wall contour lines

		gs_bAutoTurnOut		= 0
		gs_bOverOut			= 0
		bDrawObjContourOut	= 1
	endif
endif


! ==============================================================================
! Calculations for Trapezoid Walls
! ==============================================================================

if bInclinedWall then
	bInclDir = SYMB_MIRRORED exor (SYMB_ROTANGLE > EPS)	! (0 / 1)
	iInclDir = not(bInclDir) - bInclDir					! (1 / -1)

	incH = cos(WALL_INCL)
	incV = sin(WALL_INCL) * iInclDir

	incHor = tan(WALL_INCL)
endif


! ==============================================================================
! Calculations for Curved Walls
! ==============================================================================

if GLOB_SCRIPT_TYPE = 2 | GLOB_SCRIPT_TYPE = 3 then
	if curvedWall & abs(radSill) > EPS then

		if GLOB_SCRIPT_TYPE <> 2 & GLOB_CONTEXT <> 22 then
			widoOrigDist = -WIDO_ORIG_DIST
		else
			widoOrigDist =  WIDO_ORIG_DIST
		endif

		tempWOD = abs(widoOrigDist) - (SYMB_ROTANGLE > EPS) * WIDO_FRAME_THICKNESS

		leftAlfa	= atn(leftWidth / tempWOD)
		rightAlfa	= atn(rightWidth / tempWOD)

		bArchSign = (WIDO_REVEAL_SIDE exor SYMB_ROTANGLE > EPS)
		iArchSign = bArchSign - not(bArchSign)		! 1 / -1

		rSillLine = radSill - iArchSign * WIDO_SILL	! Radius of the reveal at the Sill depth

		ArcLengthSillToAngle	= 180 / radSill / PI
	else
		iArchSign = 0
	endif
endif


! ==============================================================================
!
! ==============================================================================

bSlantedInnerSide	= (iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE_SPLAYED)
bSlantedOuterSide	= (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED)


! ==============================================================================
! Cavity Closure
! ==============================================================================

reorder = (AC_Wall_Direction_Type <> 1 & AC_Wall_Direction_Type <> 3)
signReorder = not(reorder) - reorder

SKIN_FILL				=  1
SKIN_THICKNESS			=  2
SKIN_CONT_PEN			=  3	! Obsolete (old contour pen)
SKIN_FILL_PEN			=  4
SKIN_FILL_BACK_PEN		=  5
SKIN_CORE_STATUS		=  6
SKIN_UPPER_LINE_PEN		=  7 + 2 * reorder
SKIN_UPPER_LINE_TYPE	=  8 + 2 * reorder
SKIN_LOWER_LINE_PEN		=  9 - 2 * reorder
SKIN_LOWER_LINE_TYPE	= 10 - 2 * reorder
SKIN_END_FACE_PEN		= 11
SKIN_FILL_ORIENTATION	= 12	! 0 - global, 1 - local
SKIN_TYPE				= 13	! 0 - cut, 1 - below cutplane, 2 - above cutplane (all skin types are 0 for simple walls)
!	For D/W in complex walls on the floor plan this variable contains the data of all cut skins, for wall ends on the floor plan the data of all skins.
!	For D/W and wall ends in the 3D window contains the data of the skins actually cut by the D/W or wall end
SKIN_END_LINE_TYPE		= 14
SKIN_FINISH_STATUS		= 15
SKIN_FILL_FIT_TO_SKIN	= 16
SKIN_THICKEN_TRAPEZOID	= 17


! Line Property defines:
LINE_PROPERTY_GENERIC	= 0
LINE_PROPERTY_INNER		= 1
LINE_PROPERTY_CONTOUR	= 2


! Partial Stucture Display defines:
STRUCTURE_ENTIRE_STRUCTURE	= 0
STRUCTURE_CORE_ONLY			= 1
STRUCTURE_WITHOUT_FINISHES	= 2


! ==============================================================================

bCompositeWall		= (WALL_SKINS_NUMBER > 0)
bFirstSkinAtReveal	= (wallIsLeft exor reorder)
lastCoreSkin		= 0	! Init
trapezoidCoreSkin	= 0	! Init

! --- find the last core skin ---
for i = 1 to WALL_SKINS_NUMBER
	idx = i: gosub 10	! Get proper index

	if abs(WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] - 3) < EPS then
		lastCoreSkin = i
	endif

	if abs(WALL_SKINS_PARAMS[idx][SKIN_THICKEN_TRAPEZOID] - 1) < EPS then
		trapezoidCoreSkin = i
	endif
next i

idx = lastCoreSkin: gosub 10	! Get proper index
lastCoreSkinIdx = idx

idx = trapezoidCoreSkin: gosub 10	! Get proper index
trapezoidCoreSkinIdx = idx


! ==============================================================================
goto 1:
! ==============================================================================



! ==============================================================================
!		Calculate proper skin index from parameter 'idx'
! ------------------------------------------------------------------------------
! Input variables:
!	idx:	index of current skin
! Output variables:
!	idx:	index of skin via 'Composite Structures' dialog
! ==============================================================================

10:
	if reorder then
		idx = WALL_SKINS_NUMBER + 1 - idx
	endif
return

! ==============================================================================

1:

]]>
</Script_1D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_PR SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_PR>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_UI SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
bDefaultElem		= (GLOB_INTGUID = "" | GLOB_INTGUID = "{00000000-0000-0000-0000-000000000000}")
bShowCavityClosure	= (bDefaultElem | WALL_SKINS_NUMBER > 0)

iFlagShowCC = 4 * not(bShowCavityClosure)


y = 34 + pageStartY
x = 0
x1 = 0
x2 = 227

! ==============================================================================
! No Closure
! ==============================================================================
if iClosureType = CLOSURE_NO then
	ui_style 0, 1
	ui_outfield gs_closure_type, x, y, 210, 16
	ui_style 0,0

	ui_pict 24, 0, 52 + pageStartY, 123,66, 1	! 01_no_closure.png
endif

! ==============================================================================
! Traditional Cavity Closure
! ==============================================================================

if	iClosureType = CLOSURE_TRADITIONAL |\
	iClosureType = CLOSURE_FINISH then

	if gs_ui_sub_tabpage = 1 then

		ui_style 0, 1
		ui_outfield gs_closure_type, x, y, x2-x-1, 16
		ui_style 0,0

		if iClosureType = CLOSURE_TRADITIONAL then
			if gs_bJoint then
				ui_pict 25, 0, 52 + pageStartY, 123,66, 1	! 02_traditional_01.png
			else
				ui_pict 32, 0, 52 + pageStartY, 123,66, 1	! 02_traditional_02.png
			endif
		else
			if gs_bJoint then
				ui_pict 33, 0, 52 + pageStartY, 123,66, 1	! 08_finishClosure_01.png
			else
				ui_pict 30, 0, 52 + pageStartY, 123,66, 1	! 08_finishClosure_02.png
			endif
		endif
		if gs_bJoint then
			if iClosureType = CLOSURE_TRADITIONAL then
				cy = 78 + pageStartY
			else
				cy = 65 + pageStartY
			endif
			ui_infield "gs_thkJoint", 128, cy, 90, 20 ui_tooltip stCavityClosureUI[9]		! Thickness
		endif

		y = y + 10
		dy = 20

		ui_style 0, 0

		ui_outfield stCavityClosureUI[3], x2, y+3, 122, 16, iFlagShowCC		! Turn Skin on Side
		ui_infield{3}	"iCavityClosureSide", x2+123, y, 90, 20,
				8, "", 4, 1,
				0, 0, 0, 0,
				1, stCavityClosureSide[4], CAVITY_SIDE_NONE,
				2, stCavityClosureSide[1], CAVITY_SIDE_BOTH,
				3, stCavityClosureSide[2], CAVITY_SIDE_LEFT,
				4, stCavityClosureSide[3], CAVITY_SIDE_RIGHT

		y = y + dy

		ui_outfield stCavityClosureUI[5], x2, y+3, 162, 16, iFlagShowCC		! Number of Skins to Turn
		ui_infield "gs_nTurn", x2+163, y, 50, 20

		y = y + dy

		NumberFromFlag = 4 * not(bShowCavityClosure & gs_nTurn > 0)

		ui_outfield stCavityClosureUI[6], x2, y+3, 122, 16, NumberFromFlag		! Number from
		ui_infield{3}	"iCavityClosureTurnDir", x2+123, y, 90, 20,
				8, "", 2, 1,
				0, 0, 0, 0,
				1, stCavityClosureTurnDir[1], CAVITY_TURN_REFERENCE,
				2, stCavityClosureTurnDir[2], CAVITY_TURN_OPPOSITE
		y = y + dy

		ui_style 0, 1

		ui_infield{3} "gs_bJoint", x2, y, 160, 16,
				7, "",
				2,
				1, 20, 20, 20, 20,
				0, stCavityClosureUI[8], 0,		! Insulation Strip
				1, stCavityClosureUI[8], 1		! Insulation Strip

		ui_style 0, 0
	endif


	if gs_ui_sub_tabpage = 2 then

		ui_style 0, 1
		ui_outfield gs_closure_type + " - " + stCavityClosureUI[36], x, y, 440, 16
		ui_style 0,0

		dy2 = 40
		dy 	= 30

		gosub "traditionalSubtabpage2"

	endif
endif


! ==============================================================================
! Prefabricated Cavity Closure
! ==============================================================================

if	iClosureType = CLOSURE_PREFABRICATED |\
	iClosureType = CLOSURE_AIR_SPACE then

	if gs_ui_sub_tabpage = 1 then

		ui_style 0, 1
		ui_outfield gs_closure_type, x, y, 440, 16
		ui_style 0,0

		if iClosureType = CLOSURE_PREFABRICATED then
			ui_pict 26, 0, 52 + pageStartY, 123,66, 1	! 03_prefabricated.png
		else
			ui_pict 31, 0, 52 + pageStartY, 123,66, 1	! 09_airSpaceClosure.png
		endif

		y = y + 23
		y2 = y
		dy = 22

		ui_style 0, 0

		ui_outfield stCavityClosureUI[3], x2, y+3, 122, 16, iFlagShowCC		! Turn Skin on Side
		ui_infield{3}	"iCavityClosureSide", x2+123, y, 90, 20,
				8, "", 4, 1,
				0, 0, 0, 0,
				1, stCavityClosureSide[4], CAVITY_SIDE_NONE,
				2, stCavityClosureSide[1], CAVITY_SIDE_BOTH,
				3, stCavityClosureSide[2], CAVITY_SIDE_LEFT,
				4, stCavityClosureSide[3], CAVITY_SIDE_RIGHT
		y = y + dy

		ui_outfield stCavityClosureUI[16], x2, y+3, 122, 16, iFlagShowCC	! Width
		ui_infield "gs_widthPlug", x2+123, y, 90, 20
		y = y + dy

	endif

	if gs_ui_sub_tabpage = 2 then

		ui_style 0, 1
		ui_outfield gs_closure_type + " - " + stCavityClosureUI[37], x, y, 440, 16
		ui_style 0,0

		y = y + 40

		bHasAnyJoint = not(gs_stack_left | bLeftCornerFunction) | not(gs_stack_right | bRightCornerFunction)
		bJointFlag = (gs_bJoint & bShowCavityClosure & bHasAnyJoint)
		jointFlag = 4 * not(bJointFlag)

		x	= 40
		x1	= 50
		x2	= 200
		x3	= 390

		if bJointFlag then
			ui_pict 2, x-20, y+2, 20, 20, 1		!ui_contour_line.png
		else
			ui_pict 3, x-20, y+2, 20, 20, 1		!ui_contour_line_lock.png
		endif

		ui_outfield stCavityClosureUI[11], x1, y+3, x2-x1-2, 16, jointFlag
		ui_infield "gs_ltPlug", x2, y, x3-x2, 24

		y = y + 30

		if bJointFlag then
			ui_pict 6, x-23, y+1, 23, 17, 1		!ui_pen.png
		else
			ui_pict 7, x-23, y+1, 23, 17, 1		!ui_pen_lock.png
		endif

		ui_outfield stCavityClosureUI[10], x1, y+3, x2-x1-2, 16, jointFlag
		ui_infield "gs_penPlug", x3-40, y, 40, 20

		y = y + 30

		if bJointFlag then
			ui_pict 4, x-20, y+2, 20, 20, 1		!ui_fill_type.png
		else
			ui_pict 5, x-20, y+2, 20, 20, 1		!ui_fill_type_lock.png
		endif

		ui_outfield stCavityClosureUI[12], x1, y+3, x2-x1-2, 16, jointFlag
		ui_infield "gs_fillPlug", x2, y, x3-x2, 24

		y = y + 30

		if bJointFlag then
			ui_pict 8, x-29, y+1, 29, 16, 1		!ui_fill_pen.png
		else
			ui_pict 9, x-29, y+1, 29, 16, 1		!ui_fill_pen_lock.png
		endif

		ui_outfield stCavityClosureUI[13], x1, y+3, x2-x1-2, 16, jointFlag
		ui_infield "gs_penPlugFg", x3-40, y, 40, 20

		y = y + 30

		if bJointFlag then
			ui_pict 10, x-29, y+1, 29, 16, 1		!ui_fill_bg_pen.png
		else
			ui_pict 11, x-29, y+1, 29, 16, 1		!ui_fill_bg_pen_lock.png
		endif

		ui_outfield stCavityClosureUI[14], x1, y+3, x2-x1-2, 16, jointFlag
		ui_infield "gs_penPlugBg", x3-40, y, 40, 20
	endif
endif


! ==============================================================================
! Custom Cavity Closure
! ==============================================================================

if	iClosureType = CLOSURE_CUSTOM |\
	iClosureType = CLOSURE_PLASTER_REVEAL |\
	iClosureType = CLOSURE_INSULATED_REVEAL |\
	iClosureType = CLOSURE_INSULATED_FOR_RENOVATION then

	ui_style 0, 1
	ui_outfield gs_closure_type, x, y, 190, 16
	ui_style 0,0

	x_pict = 0
	y_pict = 52 + pageStartY

	if iClosureType = CLOSURE_CUSTOM then
		if iRevealType = REVEAL_DOUBLE_SPLAYED or iRevealType = REVEAL_OUTSIDE_SPLAYED then
			if gs_mountingFrame then
				ui_pict 12, x_pict, y_pict, 123, 66, 1		! 99_custom_11_doubleSplayed_01.png
			else
				ui_pict 13, x_pict, y_pict, 123, 66, 1		! 99_custom_11_doubleSplayed_wBlindFrame_01.png
			endif
		else
			ui_pict 1, x_pict, y_pict, 123, 66, 1			! 99_custom_01.png
		endif
	endif
	if iClosureType = CLOSURE_PLASTER_REVEAL then
		ui_pict 27, x_pict, y_pict, 123, 66, 1			! 05_plasterReveal.png
	endif
	if iClosureType = CLOSURE_INSULATED_REVEAL then
		ui_pict 28, x_pict, y_pict, 123, 66, 1			! 06_insulatedReveal.png
	endif
	if iClosureType = CLOSURE_INSULATED_FOR_RENOVATION then
		ui_pict 29, x_pict, y_pict, 123, 66, 1			! 07_insulationClosureForRenovation.png
	endif

	y = 145 + pageStartY
	dy = 21

	ui_style 0,1
	ui_outfield stCavityClosureUI[24], x, y, 190, 16, iFlagShowCC
	ui_style 0,0
	y = y + dy

	ui_style 0,1
	ui_infield{3} "iCustomCCEditJambSide", x, y, 180, 20,
		8, "", 3, 1,
		0, 0, 0, 0,
		1, stCavityClosureEditedJambSide[1], EDITED_JAMB_SIDE_BOTH,
		2, stCavityClosureEditedJambSide[2], EDITED_JAMB_SIDE_LEFT,
		3, stCavityClosureEditedJambSide[3], EDITED_JAMB_SIDE_RIGHT
	y = y + dy + 4

	ui_style 0,0
	ui_infield{3} "iCustomCCEditWallSide", x, y, 180, 20,
		8, "", 2, 1,
		0, 0, 0, 0,
		1, stCavityClosureEditedWallSide[1], EDITED_WALL_FACE_OUTSIDE,
		2, stCavityClosureEditedWallSide[2], EDITED_WALL_FACE_INSIDE
	y = y + dy + 4

	ui_infield{3} "iCustomCCEditSkin", x, y, 180, 20,
		8, "", 4, 1,
		0, 0, 0, 0,
		1, stCavityClosureEditedSkinNumber[1], EDITED_SKIN_1,
		2, stCavityClosureEditedSkinNumber[2], EDITED_SKIN_2,
		3, stCavityClosureEditedSkinNumber[3], EDITED_SKIN_3,
		4, stCavityClosureEditedSkinNumber[4], EDITED_SKIN_4
	y = y + dy

	y = 40 + pageStartY
	x = 200

	ui_style 0,1
	ui_infield{3} "gs_custom_cc_turn_in", x, y, 230, 16,
			7, "",
			2,
			1, 20, 20, 20, 20,
			0, stCavityClosureUI[25], 0,	! Turn Skin
			1, stCavityClosureUI[25], 1		! Turn Skin
	y = y + dy

	ui_style 0,0
	ui_infield{3} "gs_custom_cc_plaster", x, y, 230, 16,
			7, "",
			2,
			1, 20, 20, 20, 20,
			0, stCavityClosureUI[40], 0,	! 1. Consider Skin as Plaster
			1, stCavityClosureUI[40], 1		! 1. Consider Skin as Plaster
	y = y + dy-4

	CCCTurnInFlag = 4 * not(gs_custom_cc_turn_in & bShowCavityClosure)

	ui_outfield stCavityClosureUI[41], x, y, 240, 29, CCCTurnInFlag
	y = y + dy + 8

	if gs_custom_cc_plaster then
		ui_outfield stCavityClosureUI[42], x, y+3, 240, 16, CCCTurnInFlag
		y = y + dy

		if iCustomCCEditSkin = EDITED_SKIN_1 then
			ui_infield{3} "gs_turn_plaster_dim_2D", x, y, 210, 16,
					7, "",
					2,
					1, 20, 20, 20, 20,
					0, stCavityClosureUI[60], 0,	! Dimensionable on 2D
					1, stCavityClosureUI[60], 1		! Dimensionable on 2D
			y = y + dy
		endif

		ui_infield{3} "gs_turn_plaster_show_3D", x, y, 210, 16,
				7, "",
				2,
				1, 20, 20, 20, 20,
				0, stCavityClosureUI[34], 0,	! Show in 3D
				1, stCavityClosureUI[34], 1		! Show in 3D
	else
		ui_outfield stCavityClosureUI[26], x, y+3, 145, 16, CCCTurnInFlag
		ui_infield{3} "iCustomCCThicknessType", x+146, y, 90, 20,
			8, "", 2, 1,
			0, 0, 0, 0,
			1, stCavityClosureTurnInThickness[1], THICKNESS_TYPE_ORIGINAL,
			2, stCavityClosureTurnInThickness[2], THICKNESS_TYPE_CUSTOM
		y = y + dy

		CCCThickFlag = 4 * (not(gs_custom_cc_turn_in & bShowCavityClosure) | iCustomCCThicknessType = THICKNESS_TYPE_ORIGINAL)

		ui_outfield stCavityClosureUI[27], x, y+3, 145, 16, CCCThickFlag
		ui_infield "gs_custom_cc_thickness", x+146, y, 90, 20
		y = y + dy

		ui_outfield stCavityClosureUI[28], x, y+3, 145, 16, CCCTurnInFlag
		ui_infield{3} "iCustomCCOrientation", x+146, y, 90, 20,
			8, "", 2, 1,
			0, 0, 0, 0,
			1, stCavityClosureHatchOrientation[1], ORIENTATION_ORIGINAL,
			2, stCavityClosureHatchOrientation[2], ORIENTATION_TURNED_IN
		y = y + dy

		ui_infield{3} "gs_custom_cc_separator", x, y, 210, 16,
				7, "",
				2,
				1, 20, 20, 20, 20,
				0, stCavityClosureUI[29], 0,	! Separating Line at Turn-in
				1, stCavityClosureUI[29], 1		! Separating Line at Turn-in
		y = y + dy

		CCCPenFlag = 4 * (not(gs_custom_cc_turn_in & bShowCavityClosure) | not(gs_custom_cc_separator))

		ui_outfield stCavityClosureUI[30], x, y, 195, 16, CCCPenFlag
		ui_infield "gs_custom_cc_separator_pen", x+196, y-3, 40, 20
		y = y + dy

		ui_outfield stCavityClosureUI[31], x, y-3, 145, 27, CCCTurnInFlag
		ui_infield "gs_custom_cc_overhang", x+146, y, 90, 20
		y = y + dy
	endif
endif


! ==============================================================================
! Variable Closure - Spouwlat
! ==============================================================================

if iClosureType = CLOSURE_VARIABLE & gs_ui_sub_tabpage_closure = 1 then

	if gs_ui_sub_tabpage = 1 then
		ui_style 0,1
		ui_outfield gs_closure_type, x, y, 440, 16
		ui_style 0,0

		xpic2 = 0
		ypic2 = 52 + pageStartY

		if iCavityClosureTurnDir = CAVITY_TURN_REFERENCE then
			if gs_cc_dutch_TurnToClosure then
				ui_pict 19, xpic2, ypic2, 123, 77, 1		! 04_variable_outsideFace_onCloser.png
			else
				ui_pict 20, xpic2, ypic2, 123, 77, 1		! 04_variable_outsideFace_notOnCloser.png
				ui_infield "gs_cc_dutch_TurnToClosureOffs", xpic2+127, ypic2+15, 90, 16 ui_tooltip stCavityClosureUI[56]
			endif

			ui_infield "gs_cc_dutch_widthJoint",xpic2+127, ypic2+65, 90, 16 ui_tooltip stCavityClosureUI[57]
			ui_infield "gs_cc_dutch_thkJoint",	xpic2+127, ypic2+40, 90, 16 ui_tooltip stCavityClosureUI[58]
		else
			if gs_cc_dutch_TurnToClosure then
				ui_pict 17, xpic2, ypic2, 123, 77, 1		! 04_variable_insideFace_onCloser.png
			else
				ui_pict 18, xpic2, ypic2, 123, 77, 1		! 04_variable_insideFace_notOnCloser.png
				ui_infield "gs_cc_dutch_TurnToClosureOffs", xpic2+127, ypic2+40, 90, 16 ui_tooltip stCavityClosureUI[56]
			endif

			ui_infield "gs_cc_dutch_widthJoint",xpic2+127, ypic2+65, 90, 16 ui_tooltip stCavityClosureUI[57]
			ui_infield "gs_cc_dutch_thkJoint",	xpic2+127, ypic2+15, 90, 16 ui_tooltip stCavityClosureUI[58]
		endif


		x1 = 0
		x2 = 99
		x3 = 100
		x4 = 217

		x5 = 227
		x6 = 326
		x7 = 327
		x8 = 444

		dy = 24
		y = 145 + pageStartY

		ui_outfield stCavityClosureUI[48], x1, y, x2-x1, 16, iFlagShowCC	! Turn Skin on Side
		ui_infield{3} "iCavityClosureSide", x3, y-2, x4-x3, 22,
				8, "",
				2,
				1, 20, 20, 20, 20,
				0, stCavityClosureSide[4], CAVITY_SIDE_NONE,
				1, stCavityClosureSide[1], CAVITY_SIDE_BOTH,
				1, stCavityClosureSide[2], CAVITY_SIDE_LEFT,
				1, stCavityClosureSide[3], CAVITY_SIDE_RIGHT
		y = y + dy

		iFlagShowTurnSkinPrms = 4 * not(bShowCavityClosure & iCavityClosureSide <> CAVITY_SIDE_NONE)

		ui_outfield stCavityClosureUI[21], x1, y, x2-x1+55, 16, iFlagShowTurnSkinPrms	! Number of Skins to Turn
		ui_infield "gs_nTurn", x3+55, y-2, x4-x3-55, 22
		y = y + dy

		ui_outfield stCavityClosureUI[46], x1, y, x2-x1, 16, iFlagShowTurnSkinPrms	! from (Turned Skins)
		ui_infield{3}	"iCavityClosureTurnDir", x3, y-2, x4-x3, 22,
				8, "", 2, 1,
				0, 0, 0, 0,
				1, stCavityClosureTurnDir[1], CAVITY_TURN_REFERENCE,
				2, stCavityClosureTurnDir[2], CAVITY_TURN_OPPOSITE
		y = y + dy

		ui_infield{3} "gs_cc_dutch_TurnToClosure", x1, y, x4-x1-1, 18,
				7, "",
				2,
				1, 20, 20, 20, 20,
				0, stCavityClosureUI[49], 0,		! Turn Skin to Closer
				1, stCavityClosureUI[49], 1

! ------------------------------------------------------------------------------

		ui_separator 222, 52 + pageStartY, 222, 247 + pageStartY

		y = 66 + pageStartY

		ui_outfield stCavityClosureUI[45], x5, y, x6-x5, 16, iFlagShowCC	! Place Closer to
		ui_infield{3} "gs_cc_dutch_ClosureToSkin", x7, y-2, x8-x7, 22,
				8, "",
				2,
				1, 20, 20, 20, 20,
				0, stCavityClosureUI[50], 1,		! 1. Skin
				1, stCavityClosureUI[51], 2,		! 2. Skin
				1, stCavityClosureUI[52], 3,		! 3. Skin
				1, stCavityClosureUI[53], 4			! 4. Skin
		y = y + dy

		ui_outfield stCavityClosureUI[46], x5, y, x6-x5, 16, iFlagShowCC	! from (Spouwlat)
		ui_infield{3} "gs_cc_dutch_ClosureToSide", x7, y-2, x8-x7, 22,
				8, "",
				2,
				1, 20, 20, 20, 20,
				0, stDutchClosureToSide[1], 1,		! Outside Face
				1, stDutchClosureToSide[2], 2		! Inside Face
		y = y + dy


		ui_style 0,1
		ui_outfield stCavityClosureUI[47], x5, y, x6-x5+15, 16, iFlagShowCC	! Closer Side (Spouwlat Side)
		ui_style 0,0

		ypic1 = y + 22
		xpic1 = x6 + 25

		ui_pict 21, xpic1, ypic1, 35, 45, 1		! 04_variable_ganging
		ui_infield "gs_cc_dutch_ShowLeft",	xpic1-18, ypic1+15, 15, 15
		ui_infield "gs_cc_dutch_ShowRight", xpic1+38, ypic1+15, 15, 15
		ui_infield "gs_cc_dutch_ShowTop",	xpic1+10, ypic1-18, 15, 15
		ui_infield "gs_cc_dutch_ShowBottom", xpic1+10, ypic1+48, 15, 15

! ------------------------------------------------------------------------------

		ui_separator x5, 208 + pageStartY, x8, 208 + pageStartY

	endif

	if gs_ui_sub_tabpage = 2 then
		ui_style 0, 1
		ui_outfield gs_closure_type + " - " + stCavityClosureUI[37], x, y, 440, 16
		ui_style 0,0

		dy2 = 22
		dy 	= 25
		gosub "traditionalSubtabpage2"

		y = y + dy

		ui_infield{3} "gs_cc_dutch_matJointCustom", x-17, y, 170, 20,
				7, "",
				2,
				1, 20, 20, 20, 20,
				0, stCavityClosureUI[54], 0,	!
				1, stCavityClosureUI[54], 1		!

		y = y + dy

		bFlagMatJoint	= (bFlagJoint & gs_cc_dutch_matJointCustom & iWindowShape = SHAPE_RECTANGULAR & \
			((gs_cc_dutch_ShowTop & not(gs_stack_top)) | (gs_cc_dutch_ShowBottom & not(gs_stack_bottom))))
		flagMatJoint	= 4 * not(bFlagMatJoint)

		if bFlagMatJoint then
			ui_pict 22, x-17, y+1, 12, 17, 1		!ui_mat.png
		else
			ui_pict 23, x-17, y+1, 12, 17, 1		!ui_mat_lock.png
		endif

		ui_outfield stCavityClosureUI[55], x1, y+4, x2-x1-2, 16, flagMatJoint
		ui_infield "gs_cc_dutch_matJoint", x2, y, x3-x2, 24
	endif
endif

! ==============================================================================
! Dutch Closure
! ==============================================================================

if iClosureType = CLOSURE_DUTCH_VARIABLE & gs_ui_sub_tabpage_closure = 1 then

	if gs_ui_sub_tabpage = 1 then
		ui_style 0,1
		ui_outfield gs_closure_type, x, y, 440, 16
		ui_style 0,0

		xpic2 = 0
		ypic2 = 52 + pageStartY

		if not(gs_cc_dutch_GapAtOutsideSkin) then
			ui_pict 34, xpic2, ypic2, 123, 77, 1		! 14_dutchvariable_insideFace_woutGap.png
			y = ypic2+15
		else
			ui_pict 35, xpic2, ypic2, 123, 77, 1		! 14_dutchvariable_insideFace_wGap.png
			ui_infield "gs_cc_dutch_TurnToClosureOffs", xpic2+127, ypic2+2, 90, 16 ui_tooltip stCavityClosureUI[56]
			y = ypic2+25
		endif

		ui_infield "gs_cc_dutch_widthJoint",xpic2+127, ypic2+65, 90, 16 ui_tooltip stCavityClosureUI[57]
		ui_infield "gs_cc_dutch_thkJoint",	xpic2+127, y, 			90, 16 ui_tooltip stCavityClosureUI[58]

		x1 = 227
		x2 = 326
		x3 = 327
		x4 = 444

		x5 = 2
		x6 = 101

		dy = 24
		y = 55 + pageStartY

		ui_outfield stCavityClosureUI[48], x1, y, x2-x1, 16, iFlagShowCC	! Turn Skin on Side
		ui_infield{3} "iCavityClosureSide", x3, y-4, x4-x3, 22,
				8, "",
				2,
				1, 20, 20, 20, 20,
				0, stCavityClosureSide[4], CAVITY_SIDE_NONE,
				1, stCavityClosureSide[1], CAVITY_SIDE_BOTH,
				1, stCavityClosureSide[2], CAVITY_SIDE_LEFT,
				1, stCavityClosureSide[3], CAVITY_SIDE_RIGHT
		y = y + dy

		iFlagShowTurnSkinPrms = 4 * not(bShowCavityClosure & iCavityClosureSide <> CAVITY_SIDE_NONE)

		ui_outfield stCavityClosureUI[21], x1, y, x2-x1+55, 16, iFlagShowTurnSkinPrms	! Number of Skins to Turn
		ui_infield "gs_nTurn", x3+55, y-4, x4-x3-55, 22
		y = y + 2*dy

		ui_infield{3} "gs_cc_dutch_GapAtOutsideSkin", x1, y, x4-x1-1, 18,
				7, "",
				2,
				1, 20, 20, 20, 20,
				0, stCavityClosureUI[59], 0,		! Gap at Outside Skin
				1, stCavityClosureUI[59], 1

! ------------------------------------------------------------------------------

		ui_separator 0, 147 + pageStartY, 444, 147 + pageStartY

		y = 153 + pageStartY

		ui_style 0,1
		ui_outfield stCavityClosureUI[47], x5, y, x6-x5+15, 16, iFlagShowCC	! Closer Side (Spouwlat Side)
		ui_style 0,0

		ypic1 = y + 22
		xpic1 = 114

		ui_pict 21, xpic1, ypic1, 35, 45, 1		! 04_variable_ganging
		ui_infield "gs_cc_dutch_ShowLeft",	xpic1-18, ypic1+15, 15, 15
		ui_infield "gs_cc_dutch_ShowRight", xpic1+38, ypic1+15, 15, 15
		ui_infield "gs_cc_dutch_ShowTop",	xpic1+10, ypic1-18, 15, 15
		ui_infield "gs_cc_dutch_ShowBottom", xpic1+10, ypic1+48, 15, 15

! ------------------------------------------------------------------------------

		ui_separator 175, 152 + pageStartY, 175, 248 + pageStartY

	endif

	if gs_ui_sub_tabpage = 2 then
		ui_style 0, 1
		ui_outfield gs_closure_type + " - " + stCavityClosureUI[37], x, y, 440, 16
		ui_style 0,0

		dy2 = 22
		dy 	= 25
		gosub "traditionalSubtabpage2"

		y = y + dy

		ui_infield{3} "gs_cc_dutch_matJointCustom", x-17, y, 170, 20,
				7, "",
				2,
				1, 20, 20, 20, 20,
				0, stCavityClosureUI[54], 0,	!
				1, stCavityClosureUI[54], 1		!

		y = y + dy

		bFlagMatJoint	= (bFlagJoint & gs_cc_dutch_matJointCustom & iWindowShape = SHAPE_RECTANGULAR & \
			((gs_cc_dutch_ShowTop & not(gs_stack_top)) | (gs_cc_dutch_ShowBottom & not(gs_stack_bottom))))
		flagMatJoint	= 4 * not(bFlagMatJoint)

		if bFlagMatJoint then
			ui_pict 22, x-17, y+1, 12, 17, 1		!ui_mat.png
		else
			ui_pict 23, x-17, y+1, 12, 17, 1		!ui_mat_lock.png
		endif

		ui_outfield stCavityClosureUI[55], x1, y+4, x2-x1-2, 16, flagMatJoint
		ui_infield "gs_cc_dutch_matJoint", x2, y, x3-x2, 24
	endif

endif


! ==============================================================================
end
! ==============================================================================


"traditionalSubtabpage2":

	if iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
		bHasAnyJoint = ((gs_cc_dutch_ShowLeft & not(gs_stack_left)) | \
						(gs_cc_dutch_ShowRight & not(gs_stack_right)) | \
						(gs_cc_dutch_ShowTop & not(gs_stack_top)) | \
						(gs_cc_dutch_ShowBottom & not(gs_stack_bottom)))
		gs_bJoint = 1
	else
		bHasAnyJoint = not(gs_stack_left | bLeftCornerFunction) | not(gs_stack_right | bRightCornerFunction)
	endif

	y = y + dy2

	bFlagJoint	=	(gs_bJoint & bShowCavityClosure &\
					 bHasAnyJoint &\
					(gs_nTurn > 0 | iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE) )
	flagJoint	= 4 * not(bFlagJoint)

	x	= 40
	x1	= 50
	x2	= 200
	x3	= 390

	if bFlagJoint then
		ui_pict 2, x-20, y+2, 20, 20, 1		!ui_contour_line.png
	else
		ui_pict 3, x-20, y+2, 20, 20, 1		!ui_contour_line_lock.png
	endif

	ui_outfield stCavityClosureUI[11], x1, y+3, x2-x1-2, 16, flagJoint
	ui_infield "gs_ltJoint", x2, y, x3-x2, 24

	y = y + dy

	if bFlagJoint then
		ui_pict 6, x-23, y+2, 23, 17, 1		!ui_pen.png
	else
		ui_pict 7, x-23, y+2, 23, 17, 1		!ui_pen_lock.png
	endif

	ui_outfield stCavityClosureUI[10], x1, y+3, x2-x1-2, 16, flagJoint
	ui_infield "gs_penJoint", x3-40, y, 40, 20

	y = y + dy

	if bFlagJoint then
		ui_pict 4, x-20, y+2, 20, 20, 1		!ui_fill_type.png
	else
		ui_pict 5, x-20, y+2, 20, 20, 1		!ui_fill_type_lock.png
	endif

	ui_outfield stCavityClosureUI[12], x1, y+3, x2-x1-2, 16, flagJoint
	ui_infield "gs_fillJoint", x2, y, x3-x2, 24

	y = y + dy

	if bFlagJoint then
		ui_pict 8, x-29, y+2, 29, 16, 1		!ui_fill_pen.png
	else
		ui_pict 9, x-29, y+2, 29, 16, 1		!ui_fill_pen_lock.png
	endif

	ui_outfield stCavityClosureUI[13], x1, y+3, x2-x1-2, 16, flagJoint
	ui_infield "gs_penJointFg", x3-40, y, 40, 20

	y = y + dy

	if bFlagJoint then
		ui_pict 10, x-29, y+2, 29, 16, 1		!ui_fill_bg_pen.png
	else
		ui_pict 11, x-29, y+2, 29, 16, 1		!ui_fill_bg_pen_lock.png
	endif

	ui_outfield stCavityClosureUI[14], x1, y+3, x2-x1-2, 16, flagJoint
	ui_infield "gs_penJointBg", x3-40, y, 40, 20

return


]]>
</Script_UI>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_VL SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! Contact person: <JT, TZs>

! ==============================================================================
! This macro draws the cavity closure and turned plasters
! ------------------------------------------------------------------------------
! Input parameters:
!	gs_maxPlasterThk:	wall skin classification parameter (length)
!						consider Skin as Plaster if it is thinner this
!	gs_bAutoTurnIn:		automatic plaster return at Outside Face (0 / 1)
!	gs_bAutoTurnOut:	automatic plaster return at Inside Face (0 / 1)
!	gs_bOverIn:			number of turned plaster skins at Outside Face (integer)
!	gs_bOverOut:		number of turned plaster skins at Inside Face (integer)
!	iClosureType:		controls the method being used for internal cavity closure (integer)
!	gs_nTurn:			number of turned skins in traditional mode (integer value)
!	gs_bJoint:			is there an insulation strip at the front
!						 side of the turned skins (0 / 1) [MODE1]
!	stCavityClosureSide:	string table for gs_gs_cavity_side
!	stCavityClosureTurnDir:	string table for gs_nTurnDir
! ==============================================================================


! =============================================================================
! Closure Type: String Parameter - Integer Parameter
! =============================================================================

if GLOB_MODPAR_NAME = "gs_closure_type" then
	gs_closure_type_int = 1
	for i=2 to vardim1(stClosureTypes)
		if gs_closure_type = stClosureTypes[i] then
			gs_closure_type_int = i
			i = vardim1(stClosureTypes)
		endif
	next i
	parameters gs_closure_type_int = gs_closure_type_int
else
	gs_closure_type = stClosureTypes[min(max(1,gs_closure_type_int),vardim1(stClosureTypes))]
	parameters gs_closure_type = gs_closure_type
endif


! =============================================================================
! Set up Closure Defaults
! =============================================================================

if GLOB_MODPAR_NAME = "gs_closure_type" | GLOB_MODPAR_NAME = "gs_closure_type_int" then

	bRevealChanged = 0

	iClosureType = gs_closure_type_int - 1

	if	iClosureType = CLOSURE_NO |\
		iClosureType = CLOSURE_TRADITIONAL |\
		iClosureType = CLOSURE_PREFABRICATED |\
		iClosureType = CLOSURE_VARIABLE |\
		iClosureType = CLOSURE_DUTCH_VARIABLE then

		gs_useWallFinishSkin	= 0
		gs_maxPlasterThk		= 0.040
		gs_turn_plaster_show_3D	= 0
		gs_bAutoTurnOut			= 0
		gs_bOverOut				= 0
		gs_bAutoTurnIn			= 0
		gs_bOverIn				= 0

		parameters	gs_useWallFinishSkin	= gs_useWallFinishSkin,
					gs_maxPlasterThk		= gs_maxPlasterThk,
					gs_turn_plaster_show_3D	= gs_turn_plaster_show_3D,
					gs_bAutoTurnOut			= gs_bAutoTurnOut,
					gs_bOverOut				= gs_bOverOut,
					gs_bAutoTurnIn			= gs_bAutoTurnIn,
					gs_bOverIn				= gs_bOverIn
	endif

	if iClosureType = CLOSURE_TRADITIONAL then
		iCavityClosureSide		= CAVITY_SIDE_BOTH
		gs_nTurn				= 1
		iCavityClosureTurnDir	= CAVITY_TURN_REFERENCE
		gs_bJoint				= 1
		gs_thkJoint				= 0.025

		parameters	iCavityClosureSide		= iCavityClosureSide,
					gs_nTurn				= gs_nTurn,
					iCavityClosureTurnDir	= iCavityClosureTurnDir,
					gs_bJoint				= gs_bJoint,
					gs_thkJoint				= gs_thkJoint
	endif

	if iClosureType = CLOSURE_PREFABRICATED then
		iCavityClosureSide		= CAVITY_SIDE_BOTH
		gs_widthPlug			= 0.150

		parameters	iCavityClosureSide	= iCavityClosureSide,
					gs_widthPlug		= gs_widthPlug
	endif

	if iClosureType = CLOSURE_CUSTOM then
		iCustomCCEditJambSide = EDITED_JAMB_SIDE_BOTH
		iCustomCCEditWallSide = EDITED_WALL_FACE_OUTSIDE
		iCustomCCEditSkin = EDITED_SKIN_1

		parameters	iCustomCCEditJambSide = iCustomCCEditJambSide,
					iCustomCCEditWallSide = iCustomCCEditWallSide,
					iCustomCCEditSkin = iCustomCCEditSkin

		for i=1 to vardim1(gs_custom_cc_array_left)
			gs_custom_cc_array_left[i][CUSTOMCC_BITFIELD]	= 0
			gs_custom_cc_array_left[i][CUSTOMCC_THICKNESS]	= defaultCustomClosureThickness
			gs_custom_cc_array_left[i][CUSTOMCC_OVERHANG]	= 0
			gs_custom_cc_array_left[i][CUSTOMCC_PEN]		= 1
		next i
		parameters gs_custom_cc_array_left = gs_custom_cc_array_left

		for i=1 to vardim1(gs_custom_cc_array_right)
			gs_custom_cc_array_right[i][CUSTOMCC_BITFIELD]	= 0
			gs_custom_cc_array_right[i][CUSTOMCC_THICKNESS]	= defaultCustomClosureThickness
			gs_custom_cc_array_right[i][CUSTOMCC_OVERHANG]	= 0
			gs_custom_cc_array_right[i][CUSTOMCC_PEN]		= 1
		next i
		parameters gs_custom_cc_array_right = gs_custom_cc_array_right
	endif

	if iClosureType = CLOSURE_VARIABLE then

		bRevealChanged = 1

		gs_reveal_type_int			= REVEAL_NO + 1
		gs_wido_sill				= 0.090
		AC_wido_sill				= 0.090
		gs_reveal_type_bottom_int	= 1	! REVEAL_BOTTOM_UNIFORM

		parameters	gs_reveal_type_int			= gs_reveal_type_int,
					gs_wido_sill				= gs_wido_sill,
					AC_wido_sill				= AC_wido_sill,
					gs_reveal_type_bottom_int	= gs_reveal_type_bottom_int

		gs_cc_dutch_ClosureToSkin		= 1
		gs_cc_dutch_ClosureToSide		= 2
		gs_cc_dutch_ShowLeft			= 1
		gs_cc_dutch_ShowRight			= 1
		gs_cc_dutch_ShowTop				= 0
		gs_cc_dutch_ShowBottom			= 0
		gs_cc_dutch_ClosureToSkin		= 1
		iCavityClosureSide				= CAVITY_SIDE_BOTH
		iCavityClosureTurnDir			= CAVITY_TURN_REFERENCE
		gs_cc_dutch_TurnToClosure		= 0
		gs_cc_dutch_TurnToClosureOffs	= 0
		gs_cc_dutch_widthJoint			= 0.038
		gs_cc_dutch_thkJoint			= 0.1

		parameters	gs_cc_dutch_ClosureToSkin		= gs_cc_dutch_ClosureToSkin,
					gs_cc_dutch_ClosureToSide		= gs_cc_dutch_ClosureToSide,
					gs_cc_dutch_ShowLeft			= gs_cc_dutch_ShowLeft,
					gs_cc_dutch_ShowRight			= gs_cc_dutch_ShowRight,
					gs_cc_dutch_ShowTop				= gs_cc_dutch_ShowTop,
					gs_cc_dutch_ShowBottom			= gs_cc_dutch_ShowBottom,
					gs_cc_dutch_ClosureToSkin		= gs_cc_dutch_ClosureToSkin,
					iCavityClosureSide				= iCavityClosureSide,
					iCavityClosureTurnDir			= iCavityClosureTurnDir,
					gs_cc_dutch_TurnToClosure		= gs_cc_dutch_TurnToClosure,
					gs_cc_dutch_TurnToClosureOffs	= gs_cc_dutch_TurnToClosureOffs,
					gs_cc_dutch_widthJoint			= gs_cc_dutch_widthJoint,
					gs_cc_dutch_thkJoint			= gs_cc_dutch_thkJoint
	endif

	if iClosureType = CLOSURE_DUTCH_VARIABLE then

		bRevealChanged = 1

		gs_reveal_type_int			= REVEAL_NO + 1
		gs_wido_sill				= 0.090
		AC_wido_sill				= 0.090
		gs_reveal_type_bottom_int	= 1	! REVEAL_BOTTOM_UNIFORM

		parameters	gs_reveal_type_int			= gs_reveal_type_int,
					gs_wido_sill				= gs_wido_sill,
					AC_wido_sill				= AC_wido_sill,
					gs_reveal_type_bottom_int	= gs_reveal_type_bottom_int

		gs_cc_dutch_ClosureToSkin		= 1
		gs_cc_dutch_ClosureToSide		= 1
		gs_cc_dutch_ShowLeft			= 1
		gs_cc_dutch_ShowRight			= 1
		gs_cc_dutch_ShowTop				= 0
		gs_cc_dutch_ShowBottom			= 0
		gs_cc_dutch_ClosureToSkin		= 1
		iCavityClosureSide				= CAVITY_SIDE_BOTH
		iCavityClosureTurnDir			= CAVITY_TURN_OPPOSITE
		gs_cc_dutch_TurnToClosure		= 0
		gs_cc_dutch_TurnToClosureOffs	= 0
		gs_cc_dutch_widthJoint			= 0.038
		gs_cc_dutch_thkJoint			= 0.1
		gs_cc_dutch_GapAtOutsideSkin	= 1

		parameters	gs_cc_dutch_ClosureToSkin		= gs_cc_dutch_ClosureToSkin,
					gs_cc_dutch_ClosureToSide		= gs_cc_dutch_ClosureToSide,
					gs_cc_dutch_ShowLeft			= gs_cc_dutch_ShowLeft,
					gs_cc_dutch_ShowRight			= gs_cc_dutch_ShowRight,
					gs_cc_dutch_ShowTop				= gs_cc_dutch_ShowTop,
					gs_cc_dutch_ShowBottom			= gs_cc_dutch_ShowBottom,
					gs_cc_dutch_ClosureToSkin		= gs_cc_dutch_ClosureToSkin,
					iCavityClosureSide				= iCavityClosureSide,
					iCavityClosureTurnDir			= iCavityClosureTurnDir,
					gs_cc_dutch_TurnToClosure		= gs_cc_dutch_TurnToClosure,
					gs_cc_dutch_TurnToClosureOffs	= gs_cc_dutch_TurnToClosureOffs,
					gs_cc_dutch_widthJoint			= gs_cc_dutch_widthJoint,
					gs_cc_dutch_thkJoint			= gs_cc_dutch_thkJoint,
					gs_cc_dutch_GapAtOutsideSkin	= gs_cc_dutch_GapAtOutsideSkin
	endif

	if iClosureType = CLOSURE_PLASTER_REVEAL then

		bRevealChanged = 1

		gs_reveal_type_int			= REVEAL_POSITIVE + 1
		gs_wido_sill				= 0.115
		AC_wido_sill				= 0.115
		gs_reveal_type_bottom_int	= 2	! REVEAL_BOTTOM_NO
		gs_reveal_uniform			= 1
		gs_reveal_right				= 0.040
		gs_reveal_left				= 0.040
		gs_reveal_top				= 0.040
		gs_reveal_bottom			= 0.040

		parameters	gs_reveal_type_int			= gs_reveal_type_int,
					gs_wido_sill				= gs_wido_sill,
					AC_wido_sill				= AC_wido_sill,
					gs_reveal_type_bottom_int	= gs_reveal_type_bottom_int,
					gs_reveal_uniform			= gs_reveal_uniform,
					gs_reveal_right				= gs_reveal_right,
					gs_reveal_left				= gs_reveal_left,
					gs_reveal_top				= gs_reveal_top,
					gs_reveal_bottom			= gs_reveal_bottom

		! Outside Face
		gs_custom_cc_array_left[1][CUSTOMCC_BITFIELD]	= 1 + 2
		gs_custom_cc_array_left[1][CUSTOMCC_THICKNESS]	= 0.040
		gs_custom_cc_array_left[1][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[1][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_left[2][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_left[2][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_left[2][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[2][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_left[3][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_left[3][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_left[3][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[3][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_left[4][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_left[4][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_left[4][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[4][CUSTOMCC_PEN]		= 1

		! Inside Face
		gs_custom_cc_array_left[5][CUSTOMCC_BITFIELD]	= 1 + 16
		gs_custom_cc_array_left[5][CUSTOMCC_THICKNESS]	= 0.015
		gs_custom_cc_array_left[5][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[5][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_left[6][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_left[6][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_left[6][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[6][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_left[7][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_left[7][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_left[7][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[7][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_left[8][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_left[8][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_left[8][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[8][CUSTOMCC_PEN]		= 1

		parameters gs_custom_cc_array_left = gs_custom_cc_array_left

		! Outside Face
		gs_custom_cc_array_right[1][CUSTOMCC_BITFIELD]	= 1 + 2
		gs_custom_cc_array_right[1][CUSTOMCC_THICKNESS]	= 0.040
		gs_custom_cc_array_right[1][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[1][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_right[2][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_right[2][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_right[2][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[2][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_right[3][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_right[3][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_right[3][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[3][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_right[4][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_right[4][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_right[4][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[4][CUSTOMCC_PEN]		= 1

		! Inside Face
		gs_custom_cc_array_right[5][CUSTOMCC_BITFIELD]	= 1 + 16
		gs_custom_cc_array_right[5][CUSTOMCC_THICKNESS]	= 0.015
		gs_custom_cc_array_right[5][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[5][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_right[6][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_right[6][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_right[6][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[6][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_right[7][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_right[7][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_right[7][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[7][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_right[8][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_right[8][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_right[8][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[8][CUSTOMCC_PEN]		= 1

		parameters gs_custom_cc_array_right = gs_custom_cc_array_right
	endif

	if iClosureType = CLOSURE_INSULATED_REVEAL then

		bRevealChanged = 1

		gs_reveal_type_int				= REVEAL_DOUBLE + 1
		gs_reveal_doubleOuterTypeInt	= REVEAL_POSITIVE + 1
		gs_reveal_doubleInnerTypeInt	= REVEAL_NO + 1
		gs_wido_sill					= 0.250
		AC_wido_sill					= 0.250
		gs_reveal_type_bottom_int		= 2	! REVEAL_BOTTOM_NO
		gs_reveal_uniform				= 1
		gs_reveal_right					= 0.065
		gs_reveal_left					= 0.065
		gs_reveal_top					= 0.065
		gs_reveal_bottom				= 0.065
		gs_reveal_double_innerRight		= 0
		gs_reveal_double_innerLeft		= 0
		gs_reveal_double_innerTop		= 0
		gs_reveal_double_innerBottom	= 0

		parameters	gs_reveal_type_int				= gs_reveal_type_int,
					gs_reveal_doubleOuterTypeInt	= gs_reveal_doubleOuterTypeInt,
					gs_reveal_doubleInnerTypeInt	= gs_reveal_doubleInnerTypeInt,
					gs_wido_sill					= gs_wido_sill,
					AC_wido_sill					= AC_wido_sill,
					gs_reveal_type_bottom_int		= gs_reveal_type_bottom_int,
					gs_reveal_uniform				= gs_reveal_uniform,
					gs_reveal_right					= gs_reveal_right,
					gs_reveal_left					= gs_reveal_left,
					gs_reveal_top					= gs_reveal_top,
					gs_reveal_bottom				= gs_reveal_bottom,
					gs_reveal_double_innerRight		= gs_reveal_double_innerRight,
					gs_reveal_double_innerLeft		= gs_reveal_double_innerLeft,
					gs_reveal_double_innerTop		= gs_reveal_double_innerTop,
					gs_reveal_double_innerBottom	= gs_reveal_double_innerBottom

		iCustomCCEditJambSide = EDITED_JAMB_SIDE_BOTH
		iCustomCCEditWallSide = EDITED_WALL_FACE_OUTSIDE
		iCustomCCEditSkin = EDITED_SKIN_1

		parameters	iCustomCCEditJambSide = iCustomCCEditJambSide,
					iCustomCCEditWallSide = iCustomCCEditWallSide,
					iCustomCCEditSkin = iCustomCCEditSkin

		! Outside Face
		gs_custom_cc_array_left[1][CUSTOMCC_BITFIELD]	= 1 + 2
		gs_custom_cc_array_left[1][CUSTOMCC_THICKNESS]	= 0.025
		gs_custom_cc_array_left[1][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[1][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_left[2][CUSTOMCC_BITFIELD]	= 1 + 2 + 8
		gs_custom_cc_array_left[2][CUSTOMCC_THICKNESS]	= 0.040
		gs_custom_cc_array_left[2][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[2][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_left[3][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_left[3][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_left[3][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[3][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_left[4][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_left[4][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_left[4][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[4][CUSTOMCC_PEN]		= 1

		! Inside Face
		gs_custom_cc_array_left[5][CUSTOMCC_BITFIELD]	= 1 + 16
		gs_custom_cc_array_left[5][CUSTOMCC_THICKNESS]	= 0.015
		gs_custom_cc_array_left[5][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[5][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_left[6][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_left[6][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_left[6][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[6][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_left[7][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_left[7][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_left[7][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[7][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_left[8][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_left[8][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_left[8][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[8][CUSTOMCC_PEN]		= 1

		parameters gs_custom_cc_array_left = gs_custom_cc_array_left

		! Outside Face
		gs_custom_cc_array_right[1][CUSTOMCC_BITFIELD]	= 1 + 2
		gs_custom_cc_array_right[1][CUSTOMCC_THICKNESS]	= 0.025
		gs_custom_cc_array_right[1][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[1][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_right[2][CUSTOMCC_BITFIELD]	= 1 + 2 + 8
		gs_custom_cc_array_right[2][CUSTOMCC_THICKNESS]	= 0.040
		gs_custom_cc_array_right[2][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[2][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_right[3][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_right[3][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_right[3][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[3][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_right[4][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_right[4][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_right[4][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[4][CUSTOMCC_PEN]		= 1

		! Inside Face
		gs_custom_cc_array_right[5][CUSTOMCC_BITFIELD]	= 1 + 16
		gs_custom_cc_array_right[5][CUSTOMCC_THICKNESS]	= 0.015
		gs_custom_cc_array_right[5][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[5][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_right[6][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_right[6][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_right[6][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[6][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_right[7][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_right[7][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_right[7][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[7][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_right[8][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_right[8][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_right[8][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[8][CUSTOMCC_PEN]		= 1

		parameters gs_custom_cc_array_right = gs_custom_cc_array_right
	endif

	if iClosureType = CLOSURE_INSULATED_FOR_RENOVATION then

		bRevealChanged = 1

		gs_reveal_type_int				= REVEAL_DOUBLE + 1
		gs_reveal_doubleOuterTypeInt	= REVEAL_POSITIVE + 1
		gs_reveal_doubleInnerTypeInt	= REVEAL_POSITIVE + 1
		gs_wido_sill					= 0.28
		AC_wido_sill					= 0.28
		gs_reveal_type_bottom_int		= 2	! REVEAL_BOTTOM_NO
		gs_reveal_uniform				= 1
		gs_reveal_right					= 0.055
		gs_reveal_left					= 0.055
		gs_reveal_top					= 0.055
		gs_reveal_bottom				= 0.055
		gs_reveal_double_innerRight		= 0.055
		gs_reveal_double_innerLeft		= 0.055
		gs_reveal_double_innerTop		= 0.055
		gs_reveal_double_innerBottom	= 0.055

		parameters	gs_reveal_type_int				= gs_reveal_type_int,
					gs_reveal_doubleOuterTypeInt	= gs_reveal_doubleOuterTypeInt,
					gs_reveal_doubleInnerTypeInt	= gs_reveal_doubleInnerTypeInt,
					gs_wido_sill					= gs_wido_sill,
					AC_wido_sill					= AC_wido_sill,
					gs_reveal_type_bottom_int		= gs_reveal_type_bottom_int,
					gs_reveal_uniform				= gs_reveal_uniform,
					gs_reveal_right					= gs_reveal_right,
					gs_reveal_left					= gs_reveal_left,
					gs_reveal_top					= gs_reveal_top,
					gs_reveal_bottom				= gs_reveal_bottom,
					gs_reveal_double_innerRight		= gs_reveal_double_innerRight,
					gs_reveal_double_innerLeft		= gs_reveal_double_innerLeft,
					gs_reveal_double_innerTop		= gs_reveal_double_innerTop,
					gs_reveal_double_innerBottom	= gs_reveal_double_innerBottom

		iCustomCCEditJambSide = EDITED_JAMB_SIDE_BOTH
		iCustomCCEditWallSide = EDITED_WALL_FACE_OUTSIDE
		iCustomCCEditSkin = EDITED_SKIN_1

		! Outside Face
		gs_custom_cc_array_left[1][CUSTOMCC_BITFIELD]	= 1 + 16
		gs_custom_cc_array_left[1][CUSTOMCC_THICKNESS]	= 0.015
		gs_custom_cc_array_left[1][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[1][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_left[2][CUSTOMCC_BITFIELD]	= 1 + 2
		gs_custom_cc_array_left[2][CUSTOMCC_THICKNESS]	= 0.030
		gs_custom_cc_array_left[2][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[2][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_left[3][CUSTOMCC_BITFIELD]	= 1
		gs_custom_cc_array_left[3][CUSTOMCC_THICKNESS]	= 0.015
		gs_custom_cc_array_left[3][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[3][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_left[4][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_left[4][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_left[4][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[4][CUSTOMCC_PEN]		= 1

		! Inside Face
		gs_custom_cc_array_left[5][CUSTOMCC_BITFIELD]	= 1 + 16
		gs_custom_cc_array_left[5][CUSTOMCC_THICKNESS]	= 0.015
		gs_custom_cc_array_left[5][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[5][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_left[6][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_left[6][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_left[6][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[6][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_left[7][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_left[7][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_left[7][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[7][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_left[8][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_left[8][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_left[8][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_left[8][CUSTOMCC_PEN]		= 1

		parameters gs_custom_cc_array_left = gs_custom_cc_array_left

		! Outside Face
		gs_custom_cc_array_right[1][CUSTOMCC_BITFIELD]	= 1 + 16
		gs_custom_cc_array_right[1][CUSTOMCC_THICKNESS]	= 0.015
		gs_custom_cc_array_right[1][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[1][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_right[2][CUSTOMCC_BITFIELD]	= 1 + 2
		gs_custom_cc_array_right[2][CUSTOMCC_THICKNESS]	= 0.030
		gs_custom_cc_array_right[2][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[2][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_right[3][CUSTOMCC_BITFIELD]	= 1
		gs_custom_cc_array_right[3][CUSTOMCC_THICKNESS]	= 0.015
		gs_custom_cc_array_right[3][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[3][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_right[4][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_right[4][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_right[4][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[4][CUSTOMCC_PEN]		= 1

		! Inside Face
		gs_custom_cc_array_right[5][CUSTOMCC_BITFIELD]	= 1 + 16
		gs_custom_cc_array_right[5][CUSTOMCC_THICKNESS]	= 0.015
		gs_custom_cc_array_right[5][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[5][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_right[6][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_right[6][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_right[6][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[6][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_right[7][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_right[7][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_right[7][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[7][CUSTOMCC_PEN]		= 1

		gs_custom_cc_array_right[8][CUSTOMCC_BITFIELD]	= 0
		gs_custom_cc_array_right[8][CUSTOMCC_THICKNESS]	= 0
		gs_custom_cc_array_right[8][CUSTOMCC_OVERHANG]	= 0
		gs_custom_cc_array_right[8][CUSTOMCC_PEN]		= 1

		parameters gs_custom_cc_array_right = gs_custom_cc_array_right
	endif

	if iClosureType = CLOSURE_FINISH then

		bRevealChanged = 1

		gs_reveal_type_int			= REVEAL_POSITIVE + 1
		gs_reveal_type_bottom_int	= 2	! REVEAL_BOTTOM_NO
		gs_reveal_uniform			= 1
		gs_reveal_right				= 0.060
		gs_reveal_left				= 0.060
		gs_reveal_top				= 0.060
		gs_reveal_bottom			= 0.060

		bDefaultElem		= (GLOB_INTGUID = "" | GLOB_INTGUID = "{00000000-0000-0000-0000-000000000000}")
		if not(bDefaultElem) & bCompositeWall then
			summThk = 0
			for i=1 to min(2, WALL_SKINS_NUMBER)
				summThk = summThk + WALL_SKINS_PARAMS[i][SKIN_THICKNESS]
			next i
			gs_wido_sill = summThk
			AC_wido_sill = summThk
		else
			gs_wido_sill = 0.255
			AC_wido_sill = 0.255
		endif

		parameters	gs_reveal_type_int			= gs_reveal_type_int,
					gs_wido_sill				= gs_wido_sill,
					AC_wido_sill				= AC_wido_sill,
					gs_reveal_type_bottom_int	= gs_reveal_type_bottom_int,
					gs_reveal_uniform			= gs_reveal_uniform,
					gs_reveal_right				= gs_reveal_right,
					gs_reveal_left				= gs_reveal_left,
					gs_reveal_top				= gs_reveal_top,
					gs_reveal_bottom			= gs_reveal_bottom

		iCavityClosureSide		= CAVITY_SIDE_BOTH
		gs_nTurn				= 1
		iCavityClosureTurnDir	= CAVITY_TURN_REFERENCE
		gs_bJoint				= 0

		parameters	iCavityClosureSide		= iCavityClosureSide,
					gs_nTurn				= gs_nTurn,
					iCavityClosureTurnDir	= iCavityClosureTurnDir,
					gs_bJoint				= gs_bJoint

		gs_useWallFinishSkin	= 0
		gs_maxPlasterThk		= 0.040
		gs_turn_plaster_show_3D	= 0
		gs_bAutoTurnOut			= 1
		gs_bOverOut				= 1
		gs_bAutoTurnIn			= 1
		gs_bOverIn				= 1

		parameters	gs_useWallFinishSkin	= gs_useWallFinishSkin,
					gs_maxPlasterThk		= gs_maxPlasterThk,
					gs_turn_plaster_show_3D	= gs_turn_plaster_show_3D,
					gs_bAutoTurnOut			= gs_bAutoTurnOut,
					gs_bOverOut				= gs_bOverOut,
					gs_bAutoTurnIn			= gs_bAutoTurnIn,
					gs_bOverIn				= gs_bOverIn
	endif

	if iClosureType = CLOSURE_AIR_SPACE then

		bRevealChanged = 1

		gs_reveal_type_int			= REVEAL_NO + 1
		gs_reveal_type_bottom_int	= 1	! REVEAL_BOTTOM_UNIFORM

		bDefaultElem		= (GLOB_INTGUID = "" | GLOB_INTGUID = "{00000000-0000-0000-0000-000000000000}")
		if not(bDefaultElem) & bCompositeWall then
			summThk = 0
			for i=1 to min(3, WALL_SKINS_NUMBER)
				summThk = summThk + WALL_SKINS_PARAMS[i][SKIN_THICKNESS]
			next i
			gs_wido_sill = summThk
			AC_wido_sill = summThk
		else
			gs_wido_sill = 0.120
			AC_wido_sill = 0.120
		endif

		parameters	gs_reveal_type_int			= gs_reveal_type_int,
					gs_wido_sill				= gs_wido_sill,
					AC_wido_sill				= AC_wido_sill,
					gs_reveal_type_bottom_int	= gs_reveal_type_bottom_int

		iCavityClosureSide		= CAVITY_SIDE_BOTH
		gs_widthPlug			= 0.050

		parameters	iCavityClosureSide	= iCavityClosureSide,
					gs_widthPlug		= gs_widthPlug

		gs_useWallFinishSkin	= 0
		gs_maxPlasterThk		= 0.040
		gs_turn_plaster_show_3D	= 1
		gs_bAutoTurnOut			= 1
		gs_bOverOut				= 0
		gs_bAutoTurnIn			= 0
		gs_bOverIn				= 2

		parameters	gs_useWallFinishSkin	= gs_useWallFinishSkin,
					gs_maxPlasterThk		= gs_maxPlasterThk,
					gs_turn_plaster_show_3D	= gs_turn_plaster_show_3D,
					gs_bAutoTurnOut			= gs_bAutoTurnOut,
					gs_bOverOut				= gs_bOverOut,
					gs_bAutoTurnIn			= gs_bAutoTurnIn,
					gs_bOverIn				= gs_bOverIn
	endif

	if bRevealChanged then
		parameters gs_reveal_auto_changed_by_cc = 1
	endif
else
	if GLOB_MODPAR_NAME = "" & GLOB_UI_BUTTON_ID = 0 then
		parameters gs_reveal_auto_changed_by_cc = 0
	endif
endif


! =============================================================================

bEnableTraditionalCavityClosure		= (	bittest(gs_ClosureTypeEnable, CLOSURE_TRADITIONAL) |\
										bittest(gs_ClosureTypeEnable, CLOSURE_TRADITIONAL_PRESETS) )
bEnablePrefabricatedCavityClosure	= (	bittest(gs_ClosureTypeEnable, CLOSURE_PREFABRICATED) |\
										bittest(gs_ClosureTypeEnable, CLOSURE_PREFABRICATED_PRESETS) )
bEnableCustomCavityClosure			= (	bittest(gs_ClosureTypeEnable, CLOSURE_CUSTOM) |\
										bittest(gs_ClosureTypeEnable, CLOSURE_CUSTOM_PRESETS) )

if bEnableTraditionalCavityClosure | bEnablePrefabricatedCavityClosure then
	if iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
		values "gs_cavity_side"		stCavityClosureSide[4], stCavityClosureSide[1], stCavityClosureSide[2], stCavityClosureSide[3]
		values "iCavityClosureSide"	CAVITY_SIDE_NONE, CAVITY_SIDE_BOTH, CAVITY_SIDE_LEFT, CAVITY_SIDE_RIGHT
	endif
	if	iClosureType = CLOSURE_TRADITIONAL |\
		iClosureType = CLOSURE_PREFABRICATED |\
		iClosureType = CLOSURE_FINISH |\
		iClosureType = CLOSURE_AIR_SPACE then
		values "gs_cavity_side"		stCavityClosureSide[1], stCavityClosureSide[2], stCavityClosureSide[3]
		values "iCavityClosureSide"	CAVITY_SIDE_BOTH, CAVITY_SIDE_LEFT, CAVITY_SIDE_RIGHT
	endif

	if GLOB_MODPAR_NAME = "gs_cavity_side" then
		iCavityClosureSide = CAVITY_SIDE_BOTH
		for i = 2 to vardim1(stCavityClosureSide)
			if gs_cavity_side = stCavityClosureSide[i] then
				iCavityClosureSide = i
				i = vardim1(stCavityClosureSide)
			endif
		next i
		parameters iCavityClosureSide = iCavityClosureSide
	else
		gs_cavity_side = stCavityClosureSide[min(max(1,iCavityClosureSide),vardim1(stCavityClosureSide))]
		parameters gs_cavity_side = gs_cavity_side
	endif

	values "gs_nTurnDir" stCavityClosureTurnDir
	values "iCavityClosureTurnDir" CAVITY_TURN_REFERENCE, CAVITY_TURN_OPPOSITE

	if GLOB_MODPAR_NAME = "gs_nTurnDir" then
		iCavityClosureTurnDir = CAVITY_SIDE_BOTH
		for i = 2 to vardim1(stCavityClosureTurnDir)
			if gs_nTurnDir = stCavityClosureTurnDir[i] then
				iCavityClosureTurnDir = i
				i = vardim1(stCavityClosureTurnDir)
			endif
		next i
		parameters iCavityClosureTurnDir = iCavityClosureTurnDir
	else
		gs_nTurnDir = stCavityClosureTurnDir[min(max(1,iCavityClosureTurnDir),vardim1(stCavityClosureTurnDir))]
		parameters gs_nTurnDir = gs_nTurnDir
	endif

	values "gs_nTurn"			range [0, )
	values "gs_thkJoint"		range (0, )
	values "gs_widthPlug"		range (0, )
endif


! ==============================================================================
! Hide and lock Cavity Closure parameters
! ==============================================================================

if	iClosureType = CLOSURE_NO |\
	iClosureType = CLOSURE_SOLID_WALL |\
	iClosureType = CLOSURE_STUD_WALL |\
	iClosureType = CLOSURE_STUD_WALL_SIDING |\
	iClosureType = CLOSURE_BRICK_VENEER then
	hideparameter	"gs_cavity_side",
				"iCavityClosureSide",
				"gs_nTurn",
				"gs_nTurnDir",
				"iCavityClosureTurnDir",
				"gs_bJoint",
				"gs_showJoint",
				"gs_thkJoint",
				"gs_penJoint",
				"gs_ltJoint",
				"gs_fillJoint",
				"gs_penJointFg",
				"gs_penJointBg",
				"gs_widthPlug",
				"gs_penPlug",
				"gs_ltPlug",
				"gs_fillPlug",
				"gs_penPlugFg",
				"gs_penPlugBg",
				"gs_custom_cc_array_left",
				"gs_custom_cc_array_right",
				"iCustomCCEditJambSide",
				"iCustomCCEditWallSide",
				"iCustomCCEditSkin",
				"gs_custom_cc_turn_in",
				"iCustomCCThicknessType",
				"gs_custom_cc_thickness",
				"iCustomCCOrientation",
				"gs_custom_cc_separator",
				"gs_custom_cc_separator_pen",
				"gs_custom_cc_overhang",
				"gs_custom_cc_last_sel_side",
				"gs_cc_dutch_ShowLeft",
				"gs_cc_dutch_ShowRight",
				"gs_cc_dutch_ShowTop",
				"gs_cc_dutch_ShowBottom",
				"gs_cc_dutch_ClosureToSkin",
				"gs_cc_dutch_ClosureToSide_str",
				"gs_cc_dutch_ClosureToSide",
				"gs_cc_dutch_TurnToClosure",
				"gs_cc_dutch_TurnToClosureOffs",
				"gs_cc_dutch_widthJoint",
				"gs_cc_dutch_thkJoint",
				"gs_cc_dutch_matJointCustom",
				"gs_cc_dutch_matJoint"

	lock	"gs_cavity_side",
		"iCavityClosureSide",
		"gs_nTurn",
		"gs_nTurnDir",
		"iCavityClosureTurnDir",
		"gs_bJoint",
		"gs_showJoint",
		"gs_thkJoint",
		"gs_penJoint",
		"gs_ltJoint",
		"gs_fillJoint",
		"gs_penJointFg",
		"gs_penJointBg",
		"gs_widthPlug",
		"gs_penPlug",
		"gs_ltPlug",
		"gs_fillPlug",
		"gs_penPlugFg",
		"gs_penPlugBg",
		"gs_custom_cc_array_left",
		"gs_custom_cc_array_right",
		"iCustomCCEditJambSide",
		"iCustomCCEditWallSide",
		"iCustomCCEditSkin",
		"gs_custom_cc_turn_in",
		"iCustomCCThicknessType",
		"gs_custom_cc_thickness",
		"iCustomCCOrientation",
		"gs_custom_cc_separator",
		"gs_custom_cc_separator_pen",
		"gs_custom_cc_overhang",
		"gs_custom_cc_last_sel_side",
		"gs_cc_dutch_ShowLeft",
		"gs_cc_dutch_ShowRight",
		"gs_cc_dutch_ShowTop",
		"gs_cc_dutch_ShowBottom",
		"gs_cc_dutch_ClosureToSkin",
		"gs_cc_dutch_ClosureToSide_str",
		"gs_cc_dutch_ClosureToSide",
		"gs_cc_dutch_TurnToClosure",
		"gs_cc_dutch_TurnToClosureOffs",
		"gs_cc_dutch_widthJoint",
		"gs_cc_dutch_thkJoint",
		"gs_cc_dutch_matJointCustom",
		"gs_cc_dutch_matJoint"

	if bittest(gs_ClosureTypeEnable, CLOSURE_DUTCH_VARIABLE) then
		hideparameter "gs_cc_dutch_GapAtOutsideSkin"
		lock "gs_cc_dutch_GapAtOutsideSkin"
	endif
endif


! ==============================================================================
! Common parameters of Traditional and Prefabricated Closures
! ==============================================================================

if not(	iClosureType = CLOSURE_TRADITIONAL |\
		iClosureType = CLOSURE_VARIABLE |\
		iClosureType = CLOSURE_DUTCH_VARIABLE  |\
		iClosureType = CLOSURE_PREFABRICATED |\
		iClosureType = CLOSURE_FINISH |\
		iClosureType = CLOSURE_AIR_SPACE) then
	hideparameter	"gs_cavity_side", "iCavityClosureSide"
	lock			"gs_cavity_side", "iCavityClosureSide"
endif


! ==============================================================================
! Traditional Cavity Closure
! ==============================================================================

if	iClosureType = CLOSURE_TRADITIONAL |\
	iClosureType = CLOSURE_FINISH then
	bHasAnyJoint = not(gs_stack_left | bLeftCornerFunction) | not(gs_stack_right | bRightCornerFunction)
	if gs_nTurn = 0 then
		hideparameter	"gs_bJoint", "gs_nTurnDir", "iCavityClosureTurnDir"
		lock			"gs_bJoint", "gs_nTurnDir", "iCavityClosureTurnDir"
	endif
	if gs_nTurn = 0 | not(gs_bJoint) | not(bHasAnyJoint) then
		hideparameter	"gs_showJoint", "gs_thkJoint", "gs_penJoint", "gs_ltJoint", "gs_fillJoint", "gs_penJointFg", "gs_penJointBg"
		lock			"gs_showJoint", "gs_thkJoint", "gs_penJoint", "gs_ltJoint", "gs_fillJoint", "gs_penJointFg", "gs_penJointBg"
	endif
else
	if iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
		lock			"gs_bJoint", "gs_showJoint", "gs_thkJoint"
		hideparameter	"gs_bJoint", "gs_showJoint", "gs_thkJoint"
	else
		lock			"gs_nTurnDir", "iCavityClosureTurnDir", "gs_nTurn", "gs_bJoint", "gs_showJoint",
						"gs_thkJoint", "gs_penJoint", "gs_ltJoint", "gs_fillJoint", "gs_penJointFg", "gs_penJointBg"

		hideparameter	"gs_nTurnDir", "iCavityClosureTurnDir", "gs_nTurn", "gs_bJoint", "gs_showJoint",
						"gs_thkJoint", "gs_penJoint", "gs_ltJoint", "gs_fillJoint", "gs_penJointFg", "gs_penJointBg"
	endif
endif


! ==============================================================================
! Variable Closure, Dutch Closure
! ==============================================================================

if iClosureType = CLOSURE_VARIABLE | iClosureType = CLOSURE_DUTCH_VARIABLE then
	values "gs_cc_dutch_ClosureToSkin" 1,2,3,4
	values "gs_cc_dutch_ClosureToSide" 1,2
	values "gs_cc_dutch_ClosureToSide_str" stDutchClosureToSide
	values "gs_cc_dutch_widthJoint" range(0,]
	values "gs_cc_dutch_thkJoint"	range(0,]
	hideparameter "gs_cc_dutch_ClosureToSide"
	if GLOB_MODPAR_NAME = "gs_cc_dutch_ClosureToSide_str" then
		gs_cc_dutch_ClosureToSide = 1
		if gs_cc_dutch_ClosureToSide_str = stDutchClosureToSide[2] then gs_cc_dutch_ClosureToSide = 2
		parameters gs_cc_dutch_ClosureToSide = gs_cc_dutch_ClosureToSide
	else
		gs_cc_dutch_ClosureToSide = max(1, gs_cc_dutch_ClosureToSide)
		gs_cc_dutch_ClosureToSide = min(2, gs_cc_dutch_ClosureToSide)
		gs_cc_dutch_ClosureToSide_str = stDutchClosureToSide[gs_cc_dutch_ClosureToSide]
		parameters gs_cc_dutch_ClosureToSide_str = gs_cc_dutch_ClosureToSide_str
	endif

	if iClosureType = CLOSURE_VARIABLE then
		if gs_cc_dutch_TurnToClosure then
			lock "gs_cc_dutch_TurnToClosureOffs"
		endif
	else
		lock "gs_cc_dutch_TurnToClosure"
		hideparameter "gs_cc_dutch_TurnToClosure"
	endif

! Parameter Settings for Dutch Closure =========================================

	if iClosureType = CLOSURE_DUTCH_VARIABLE then

		if not(gs_cc_dutch_GapAtOutsideSkin) then
			lock "gs_cc_dutch_TurnToClosureOffs"
		endif

		iCavityClosureTurnDir		= CAVITY_TURN_OPPOSITE
		gs_cc_dutch_ClosureToSkin	= 1
		gs_cc_dutch_TurnToClosure 	= not(gs_cc_dutch_GapAtOutsideSkin)
		gs_cc_dutch_ClosureToSide	= 1		! Outside

		parameters	iCavityClosureTurnDir		= iCavityClosureTurnDir,
					gs_cc_dutch_ClosureToSkin	= gs_cc_dutch_ClosureToSkin,
					gs_cc_dutch_TurnToClosure	= gs_cc_dutch_TurnToClosure,
					gs_cc_dutch_ClosureToSide	= gs_cc_dutch_ClosureToSide

		lock	"gs_nTurnDir",
				"iCavityClosureTurnDir",
				"gs_cc_dutch_ClosureToSkin",
				"gs_cc_dutch_ClosureToSide_str",
				"gs_cc_dutch_ClosureToSide",
				"gs_cc_dutch_TurnToClosure"
		hideparameter	"gs_nTurnDir",
						"iCavityClosureTurnDir",
						"gs_cc_dutch_ClosureToSkin",
						"gs_cc_dutch_ClosureToSide_str",
						"gs_cc_dutch_ClosureToSide",
						"gs_cc_dutch_TurnToClosure"
	else
		if bittest(gs_ClosureTypeEnable, CLOSURE_DUTCH_VARIABLE) then
			lock "gs_cc_dutch_GapAtOutsideSkin"
			hideparameter "gs_cc_dutch_GapAtOutsideSkin"
		endif
	endif

! End of Parameter Settings for Dutch Closure ==================================

	if not(iClosureType = CLOSURE_DUTCH_VARIABLE) then
		if not((gs_cc_dutch_ShowLeft & bCavityCloserLeft) | (gs_cc_dutch_ShowRight & bCavityCloserRight)) then
			lock			"gs_cc_dutch_TurnToClosure", "gs_cc_dutch_TurnToClosureOffs"
			hideparameter	"gs_cc_dutch_TurnToClosure", "gs_cc_dutch_TurnToClosureOffs"
		endif
	endif

	if not((gs_cc_dutch_ShowLeft & not(gs_stack_left)) | \
		   (gs_cc_dutch_ShowRight & not(gs_stack_right)) | \
		   (gs_cc_dutch_ShowTop & not(gs_stack_top)) | \
		   (gs_cc_dutch_ShowBottom & not(gs_stack_bottom))) then
		lock			"gs_ltJoint", "gs_penJoint", "gs_fillJoint", "gs_penJointFg", "gs_penJointBg"
		hideparameter	"gs_ltJoint", "gs_penJoint", "gs_fillJoint", "gs_penJointFg", "gs_penJointBg"
	endif

	if not(gs_cc_dutch_matJointCustom) then
		lock			"gs_cc_dutch_matJoint"
		hideparameter	"gs_cc_dutch_matJoint"
	endif

	if iCavityClosureSide = CAVITY_SIDE_NONE then
		lock			"gs_nTurnDir", "iCavityClosureTurnDir", "gs_nTurn"
		hideparameter	"gs_nTurnDir", "iCavityClosureTurnDir", "gs_nTurn"
	endif

	if not((gs_cc_dutch_ShowTop & not(gs_stack_top)) | \
		   (gs_cc_dutch_ShowBottom & not(gs_stack_bottom))) then
		lock			"gs_cc_dutch_matJointCustom", "gs_cc_dutch_matJoint"
		hideparameter	"gs_cc_dutch_matJointCustom", "gs_cc_dutch_matJoint"
	endif

	if iWindowShape <> SHAPE_RECTANGULAR then
		lock			"gs_cc_dutch_ShowTop", "gs_cc_dutch_ShowBottom", "gs_cc_dutch_matJointCustom", "gs_cc_dutch_matJoint"
		hideparameter	"gs_cc_dutch_ShowTop", "gs_cc_dutch_ShowBottom", "gs_cc_dutch_matJointCustom", "gs_cc_dutch_matJoint"
	endif
else
	lock			"gs_cc_dutch_ShowLeft",
					"gs_cc_dutch_ShowRight",
					"gs_cc_dutch_ShowTop",
					"gs_cc_dutch_ShowBottom",
					"gs_cc_dutch_ClosureToSkin",
					"gs_cc_dutch_ClosureToSide_str",
					"gs_cc_dutch_ClosureToSide",
					"gs_cc_dutch_TurnToClosure",
					"gs_cc_dutch_TurnToClosureOffs",
					"gs_cc_dutch_widthJoint",
					"gs_cc_dutch_thkJoint",
					"gs_cc_dutch_matJointCustom",
					"gs_cc_dutch_matJoint"

	hideparameter	"gs_cc_dutch_ShowLeft",
					"gs_cc_dutch_ShowRight",
					"gs_cc_dutch_ShowTop",
					"gs_cc_dutch_ShowBottom",
					"gs_cc_dutch_ClosureToSkin",
					"gs_cc_dutch_ClosureToSide_str",
					"gs_cc_dutch_ClosureToSide",
					"gs_cc_dutch_TurnToClosure",
					"gs_cc_dutch_TurnToClosureOffs",
					"gs_cc_dutch_widthJoint",
					"gs_cc_dutch_thkJoint",
					"gs_cc_dutch_matJointCustom",
					"gs_cc_dutch_matJoint"

	if bittest(gs_ClosureTypeEnable, CLOSURE_DUTCH_VARIABLE) then
		hideparameter "gs_cc_dutch_GapAtOutsideSkin"
		lock "gs_cc_dutch_GapAtOutsideSkin"
	endif
endif


! ==============================================================================
! Prefabricated Cavity Closure
! ==============================================================================

if	iClosureType = CLOSURE_PREFABRICATED |\
	iClosureType = CLOSURE_AIR_SPACE then
	bHasAnyJoint = not(gs_stack_left | bLeftCornerFunction) | not(gs_stack_right | bRightCornerFunction)

	if not(bHasAnyJoint) then
		lock			"gs_penPlug", "gs_ltPlug", "gs_fillPlug", "gs_penPlugFg", "gs_penPlugBg"
		hideparameter	"gs_penPlug", "gs_ltPlug", "gs_fillPlug", "gs_penPlugFg", "gs_penPlugBg"
	endif
else
	lock			"gs_widthPlug", "gs_penPlug", "gs_ltPlug", "gs_fillPlug", "gs_penPlugFg", "gs_penPlugBg"
	hideparameter	"gs_widthPlug", "gs_penPlug", "gs_ltPlug", "gs_fillPlug", "gs_penPlugFg", "gs_penPlugBg"
endif


! ==============================================================================
! Custom Cavity Closure
! ==============================================================================

if	iClosureType = CLOSURE_CUSTOM |\
	iClosureType = CLOSURE_PLASTER_REVEAL |\
	iClosureType = CLOSURE_INSULATED_REVEAL |\
	iClosureType = CLOSURE_INSULATED_FOR_RENOVATION then
	values{2} "iCustomCCEditJambSide" 	EDITED_JAMB_SIDE_BOTH, `Редактирование Обоих Откосов`,
									EDITED_JAMB_SIDE_LEFT, `Редактирование Левого Откоса`,
									EDITED_JAMB_SIDE_RIGHT, `Редактирование Правого Откоса`
	values{2} "iCustomCCEditWallSide" 	EDITED_WALL_FACE_OUTSIDE, `Снаружи`,
									EDITED_WALL_FACE_INSIDE, `Внутри`
	values{2} "iCustomCCEditSkin" 	EDITED_SKIN_1, `1. Слой`,
								EDITED_SKIN_2, `2. Слой`,
								EDITED_SKIN_3, `3. Слой`,
								EDITED_SKIN_4, `4. Слой`

	values{2} "iCustomCCThicknessType" 	THICKNESS_TYPE_ORIGINAL, `Исходная`,
										THICKNESS_TYPE_CUSTOM, `Специальный`
	values "gs_custom_cc_thickness"			range[0,]
	values "gs_custom_cc_overhang"			range[0,]
	values{2} "iCustomCCOrientation" 	ORIENTATION_ORIGINAL, `Исходная`,
									ORIENTATION_TURNED_IN, `Поворот Внутрь`

	hideparameter	"gs_useWallFinishSkin",
					"gs_maxPlasterThk",
					"gs_bAutoTurnOut",
					"gs_bOverOut",
					"gs_bAutoTurnIn",
					"gs_bOverIn"

	bHasAnyPlasterSkin = 0
	for idx = 1 to vardim1(gs_custom_cc_array_left)
		iBitfield = gs_custom_cc_array_left[idx][CUSTOMCC_BITFIELD]
		bHasAnyPlasterSkin = bHasAnyPlasterSkin | (bittest(iBitfield, 0) & bittest(iBitfield, 4))
	next idx
	for idx = 1 to vardim1(gs_custom_cc_array_right)
		iBitfield = gs_custom_cc_array_right[idx][CUSTOMCC_BITFIELD]
		bHasAnyPlasterSkin = bHasAnyPlasterSkin | (bittest(iBitfield, 0) & bittest(iBitfield, 4))
	next idx
	if not(bHasAnyPlasterSkin) then
		lock "gs_turn_plaster_show_3D", "gs_turn_plaster_dim_2D"
	endif
else
	lock	"iCustomCCEditJambSide",
		"iCustomCCEditWallSide",
		"iCustomCCEditSkin",
		"gs_custom_cc_turn_in",
		"iCustomCCThicknessType",
		"gs_custom_cc_thickness",
		"iCustomCCOrientation",
		"gs_custom_cc_separator",
		"gs_custom_cc_separator_pen",
		"gs_custom_cc_overhang",
		"gs_custom_cc_plaster"

	hideparameter	"iCustomCCEditJambSide",
				"iCustomCCEditWallSide",
				"iCustomCCEditSkin",
				"gs_custom_cc_turn_in",
				"iCustomCCThicknessType",
				"gs_custom_cc_thickness",
				"iCustomCCOrientation",
				"gs_custom_cc_separator",
				"gs_custom_cc_separator_pen",
				"gs_custom_cc_overhang",
				"gs_custom_cc_plaster"
endif

hideparameter "gs_custom_cc_last_sel_side"
lock "gs_custom_cc_last_sel_side"


! ==============================================================================
! Fill gs_custom_cc_array_left and gs_custom_cc_array_right Arrays
! ==============================================================================

if bEnableCustomCavityClosure then
	idx = 1
	if iCustomCCEditSkin = EDITED_SKIN_2 then idx = 2
	if iCustomCCEditSkin = EDITED_SKIN_3 then idx = 3
	if iCustomCCEditSkin = EDITED_SKIN_4 then idx = 4

	if iCustomCCEditWallSide = EDITED_WALL_FACE_INSIDE then	! Inside Face
		idx = idx + 4
	endif

	if	GLOB_MODPAR_NAME = "gs_custom_cc_turn_in" | \
		GLOB_MODPAR_NAME = "gs_custom_cc_plaster" | \
		GLOB_MODPAR_NAME = "iCustomCCThicknessType" | \
		GLOB_MODPAR_NAME = "gs_custom_cc_thickness" | \
		GLOB_MODPAR_NAME = "iCustomCCOrientation" | \
		GLOB_MODPAR_NAME = "gs_custom_cc_separator" | \
		GLOB_MODPAR_NAME = "gs_custom_cc_separator_pen" | \
		GLOB_MODPAR_NAME = "gs_custom_cc_overhang" then

		iBitfield = 0
		iBitfield = bitset(iBitfield, 0,  gs_custom_cc_turn_in)
		iBitfield = bitset(iBitfield, 1, (iCustomCCThicknessType = THICKNESS_TYPE_CUSTOM))
		iBitfield = bitset(iBitfield, 2, (iCustomCCOrientation = ORIENTATION_TURNED_IN))
		iBitfield = bitset(iBitfield, 3,  gs_custom_cc_separator)
		iBitfield = bitset(iBitfield, 4,  gs_custom_cc_plaster)

		if iCustomCCEditJambSide = EDITED_JAMB_SIDE_BOTH | iCustomCCEditJambSide = EDITED_JAMB_SIDE_LEFT then	! Left or Both
			gs_custom_cc_array_left[idx][CUSTOMCC_BITFIELD]		= iBitfield
			gs_custom_cc_array_left[idx][CUSTOMCC_THICKNESS]	= gs_custom_cc_thickness
			gs_custom_cc_array_left[idx][CUSTOMCC_OVERHANG]		= gs_custom_cc_overhang
			gs_custom_cc_array_left[idx][CUSTOMCC_PEN]			= gs_custom_cc_separator_pen
			parameters gs_custom_cc_array_left = gs_custom_cc_array_left
		endif
		if iCustomCCEditJambSide = EDITED_JAMB_SIDE_BOTH | iCustomCCEditJambSide = EDITED_JAMB_SIDE_RIGHT then	! Right or Both
			gs_custom_cc_array_right[idx][CUSTOMCC_BITFIELD]	= iBitfield
			gs_custom_cc_array_right[idx][CUSTOMCC_THICKNESS]	= gs_custom_cc_thickness
			gs_custom_cc_array_right[idx][CUSTOMCC_OVERHANG]	= gs_custom_cc_overhang
			gs_custom_cc_array_right[idx][CUSTOMCC_PEN]			= gs_custom_cc_separator_pen
			parameters gs_custom_cc_array_right = gs_custom_cc_array_right
		endif

		! Set plaster status
		if (GLOB_MODPAR_NAME = "gs_custom_cc_plaster" | GLOB_MODPAR_NAME = "gs_custom_cc_turn_in") then
			if gs_custom_cc_turn_in & gs_custom_cc_plaster then
				for i = 1 + (iCustomCCEditWallSide = EDITED_WALL_FACE_INSIDE) * 4 to idx - 1
					iBitfield = round_int(gs_custom_cc_array_left[i][CUSTOMCC_BITFIELD])
					iBitfield = bitset(iBitfield, 0,  1)
					iBitfield = bitset(iBitfield, 4,  1)
					gs_custom_cc_array_left[i][CUSTOMCC_BITFIELD] = iBitfield

					iBitfield = round_int(gs_custom_cc_array_right[i][CUSTOMCC_BITFIELD])
					iBitfield = bitset(iBitfield, 0,  1)
					iBitfield = bitset(iBitfield, 4,  1)
					gs_custom_cc_array_right[i][CUSTOMCC_BITFIELD] = iBitfield
				next i
			else
				for i = idx + 1 to 4 + (iCustomCCEditWallSide = EDITED_WALL_FACE_INSIDE) * 4
					iBitfield = round_int(gs_custom_cc_array_left[i][CUSTOMCC_BITFIELD])
					iBitfield = bitset(iBitfield, 4,  0)
					gs_custom_cc_array_left[i][CUSTOMCC_BITFIELD] = iBitfield

					iBitfield = round_int(gs_custom_cc_array_right[i][CUSTOMCC_BITFIELD])
					iBitfield = bitset(iBitfield, 4,  0)
					gs_custom_cc_array_right[i][CUSTOMCC_BITFIELD] = iBitfield
				next i
			endif
			parameters	gs_custom_cc_array_left  = gs_custom_cc_array_left,
						gs_custom_cc_array_right = gs_custom_cc_array_right
		endif

		! Set plaster status on both left and right side
		if iCustomCCEditJambSide = EDITED_JAMB_SIDE_LEFT then	! Left
			gs_custom_cc_array_right[idx][CUSTOMCC_BITFIELD]	= bitset(gs_custom_cc_array_right[idx][CUSTOMCC_BITFIELD], 4, gs_custom_cc_plaster)
			if gs_custom_cc_turn_in & gs_custom_cc_plaster then
				gs_custom_cc_array_right[idx][CUSTOMCC_BITFIELD]	= bitset(gs_custom_cc_array_right[idx][CUSTOMCC_BITFIELD], 0, 1)
			endif
			parameters gs_custom_cc_array_right = gs_custom_cc_array_right
		endif
		if iCustomCCEditJambSide = EDITED_JAMB_SIDE_RIGHT then	! Right
			gs_custom_cc_array_left[idx][CUSTOMCC_BITFIELD]	= bitset(gs_custom_cc_array_left[idx][CUSTOMCC_BITFIELD], 4, gs_custom_cc_plaster)
			if gs_custom_cc_turn_in & gs_custom_cc_plaster then
				gs_custom_cc_array_left[idx][CUSTOMCC_BITFIELD]	= bitset(gs_custom_cc_array_left[idx][CUSTOMCC_BITFIELD], 0, 1)
			endif
			parameters gs_custom_cc_array_left = gs_custom_cc_array_left
		endif
	else
		if GLOB_MODPAR_NAME = "iCustomCCEditJambSide" & iCustomCCEditJambSide = EDITED_JAMB_SIDE_BOTH then		! Edit Both Jambs
			if gs_custom_cc_last_sel_side then
				gs_custom_cc_array_left = gs_custom_cc_array_right
				parameters gs_custom_cc_array_left = gs_custom_cc_array_right
			else
				gs_custom_cc_array_right = gs_custom_cc_array_left
				parameters gs_custom_cc_array_right = gs_custom_cc_array_left
			endif
		endif

		iBitfield = 0
		if iCustomCCEditJambSide = EDITED_JAMB_SIDE_BOTH | iCustomCCEditJambSide = EDITED_JAMB_SIDE_LEFT then	! Left or Both
			iBitfield		  = round_int(gs_custom_cc_array_left[idx][CUSTOMCC_BITFIELD])
			gs_custom_cc_thickness		= gs_custom_cc_array_left[idx][CUSTOMCC_THICKNESS]
			gs_custom_cc_overhang		= gs_custom_cc_array_left[idx][CUSTOMCC_OVERHANG]
			gs_custom_cc_separator_pen	= gs_custom_cc_array_left[idx][CUSTOMCC_PEN]
		endif
		if iCustomCCEditJambSide = EDITED_JAMB_SIDE_RIGHT then	! Right
			iBitfield		  = round_int(gs_custom_cc_array_right[idx][CUSTOMCC_BITFIELD])
			gs_custom_cc_thickness		= gs_custom_cc_array_right[idx][CUSTOMCC_THICKNESS]
			gs_custom_cc_overhang		= gs_custom_cc_array_right[idx][CUSTOMCC_OVERHANG]
			gs_custom_cc_separator_pen	= gs_custom_cc_array_right[idx][CUSTOMCC_PEN]
		endif
		gs_custom_cc_turn_in		= bittest(iBitfield, 0)
		if (bittest(iBitfield, 1)) then
			iCustomCCThicknessType = THICKNESS_TYPE_CUSTOM
		else
			iCustomCCThicknessType = THICKNESS_TYPE_ORIGINAL
		endif
		if (bittest(iBitfield, 2)) then
			iCustomCCOrientation = ORIENTATION_TURNED_IN
		else
			iCustomCCOrientation = ORIENTATION_ORIGINAL
		endif
		gs_custom_cc_separator		= bittest(iBitfield, 3)
		gs_custom_cc_plaster		= bittest(iBitfield, 4)

		parameters	gs_custom_cc_turn_in		= gs_custom_cc_turn_in,
					gs_custom_cc_plaster		= gs_custom_cc_plaster,
					iCustomCCThicknessType = iCustomCCThicknessType,
					gs_custom_cc_thickness		= gs_custom_cc_thickness,
					iCustomCCOrientation = iCustomCCOrientation,
					gs_custom_cc_separator		= gs_custom_cc_separator,
					gs_custom_cc_separator_pen	= gs_custom_cc_separator_pen,
					gs_custom_cc_overhang		= gs_custom_cc_overhang
	endif

	parameters gs_custom_cc_last_sel_side = (iCustomCCEditJambSide = EDITED_JAMB_SIDE_RIGHT)	! Right

	if not(gs_custom_cc_turn_in) then
		lock	"gs_custom_cc_plaster",
		"iCustomCCThicknessType",
		"gs_custom_cc_thickness",
		"iCustomCCOrientation",
		"gs_custom_cc_separator",
		"gs_custom_cc_separator_pen",
		"gs_custom_cc_overhang"
	endif
	if iCustomCCThicknessType = THICKNESS_TYPE_ORIGINAL then	! Original
		lock "gs_custom_cc_thickness"
	endif
	if not(gs_custom_cc_separator) then
		lock "gs_custom_cc_separator_pen"
	endif
endif


! ==============================================================================
! Show / Hide Parameters
! ==============================================================================

bDefaultElem		= (GLOB_INTGUID = "" | GLOB_INTGUID = "{00000000-0000-0000-0000-000000000000}")
bShowCavityClosure	= (bDefaultElem | WALL_SKINS_NUMBER > 0)
bShowTurnPlaster	= (bDefaultElem | WALL_SKINS_NUMBER > 1)

if not(bShowCavityClosure) then
	if not(	bittest(gs_ClosureTypeEnable, CLOSURE_SOLID_WALL)		| \
			bittest(gs_ClosureTypeEnable, CLOSURE_STUD_WALL)		| \
			bittest(gs_ClosureTypeEnable, CLOSURE_STUD_WALL_SIDING)	| \
			bittest(gs_ClosureTypeEnable, CLOSURE_BRICK_VENEER) ) then
			lock	"gs_closure_type_int"
			lock	"gs_closure_type"
	endif
	if bittest(gs_ClosureTypeEnable, CLOSURE_DUTCH_VARIABLE) then
		lock "gs_cc_dutch_GapAtOutsideSkin"
	endif
	lock	"gs_cavity_side",
		"iCavityClosureSide",
		"gs_nTurn",
		"gs_nTurnDir",
		"iCavityClosureTurnDir",
		"gs_bJoint",
		"gs_showJoint",
		"gs_thkJoint",
		"gs_penJoint",
		"gs_ltJoint",
		"gs_fillJoint",
		"gs_penJointFg",
		"gs_penJointBg",
		"gs_cc_dutch_matJointCustom",
		"gs_cc_dutch_matJoint",
		"gs_widthPlug",
		"gs_penPlug",
		"gs_ltPlug",
		"gs_fillPlug",
		"gs_penPlugFg",
		"gs_penPlugBg",
		"iCustomCCEditJambSide",
		"iCustomCCEditWallSide",
		"iCustomCCEditSkin",
		"gs_custom_cc_turn_in",
		"gs_custom_cc_plaster",
		"iCustomCCThicknessType",
		"gs_custom_cc_thickness",
		"iCustomCCOrientation",
		"gs_custom_cc_separator",
		"gs_custom_cc_separator_pen",
		"gs_custom_cc_overhang",
		"gs_cc_dutch_ShowLeft",
		"gs_cc_dutch_ShowRight",
		"gs_cc_dutch_ShowTop",
		"gs_cc_dutch_ShowBottom",
		"gs_cc_dutch_ClosureToSkin",
		"gs_cc_dutch_ClosureToSide_str",
		"gs_cc_dutch_ClosureToSide",
		"gs_cc_dutch_TurnToClosure",
		"gs_cc_dutch_TurnToClosureOffs",
		"gs_cc_dutch_widthJoint",
		"gs_cc_dutch_thkJoint"
endif

if not(bShowTurnPlaster) & not(bShowCavityClosure) then
	lock "gs_maxPlasterThk"
endif

! --- WIDO_REVEAL_SIDE and WIDO_ORIG_DIST globals don't working in the settings dialog


]]>
</Script_VL>

<Comment SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Comment>

<ParamSection SectVersion="22" SectionFlags="0" SubIdent="0">
	<ParamSectHeader>
		<AutoHotspots>false</AutoHotspots>
		<StatBits>
			<STBit_FixSize/>
		</StatBits>
		<WDLeftFrame>0</WDLeftFrame>
		<WDRightFrame>0</WDRightFrame>
		<WDTopFrame>0</WDTopFrame>
		<WDBotFrame>0</WDBotFrame>
		<LayFlags>65535</LayFlags>
		<WDMirrorThickness>0</WDMirrorThickness>
		<WDWallInset>0</WDWallInset>
	</ParamSectHeader>
	<Parameters>
		<Length Name="A">
			<Description><![CDATA["Dimension 1"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Length Name="B">
			<Description><![CDATA["Dimension 2"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Length Name="ZZYZX">
			<Description><![CDATA["Height"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Integer Name="AC_WallContours">
			<Description><![CDATA["Wall Contours (0-None,1-Full,2-Side,3-Length)"]]></Description>
			<Fix/>
			<Value>0</Value>
		</Integer>
		<Integer Name="AC_Hole_Hotspot_Control">
			<Description><![CDATA["Hotspots 0-None,1-2D,2-3D,3-All"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<Boolean Name="AC_show2DHotspotsIn3D">
			<Description><![CDATA["Show 2D Hotspots in 3D"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Length Name="ac_bottomlevel">
			<Description><![CDATA["Bottom Level"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="ac_toplevel">
			<Description><![CDATA["Top Level"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Integer Name="gs_macro_version">
			<Description><![CDATA["Macro Version"]]></Description>
			<Value>11</Value>
		</Integer>
		<Angle Name="AC_Hole_Position_Angle">
			<Description><![CDATA["Hole Position Angle"]]></Description>
			<Value>0</Value>
		</Angle>
		<Integer Name="AC_Hole_Display_Option">
			<Description><![CDATA["Floor Plan Display Option"]]></Description>
			<Value>3</Value>
		</Integer>
		<Boolean Name="AC_HoleSideMaterial">
			<Description><![CDATA["Hole has Wall's Side Surface"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="AC_HoleMaterialCurved">
			<Description><![CDATA["Hole Surface's Split is Curved in Curved Walls"]]></Description>
			<Fix/>
			<Value>0</Value>
		</Boolean>
		<Integer Name="AC_WallType">
			<Description><![CDATA["Wall Type"]]></Description>
			<Value>0</Value>
		</Integer>
		<Length Name="AC_WallContourPolygon">
			<Description><![CDATA["Wall Contour Polygon"]]></Description>
			<ArrayValues FirstDimension="1" SecondDimension="3">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="AC_Wall_Direction_Type">
			<Description><![CDATA["Wall Direction Type"]]></Description>
			<Value>0</Value>
		</Integer>
		<Integer Name="gs_ui_sub_tabpage">
			<Description><![CDATA[""]]></Description>
			<Value>1</Value>
		</Integer>
		<Integer Name="gs_ui_sub_tabpage_closure">
			<Description><![CDATA[""]]></Description>
			<Value>1</Value>
		</Integer>
		<Integer Name="pageStartY">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Integer>

		<!-- gs_wallhole_geometry: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_wallhole_geometry">
			<Description><![CDATA["Wallhole Geometry"]]></Description>
		</Title>
		<Length Name="refWidth">
			<Description><![CDATA["Curved Wall - Reference Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="leftWidth">
			<Description><![CDATA["Left Offset from the Origo"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="rightWidth">
			<Description><![CDATA["Right Offset from the Origo"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Integer Name="iWindowShape">
			<Description><![CDATA["Window Shape"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="radSill">
			<Description><![CDATA["Curved Wall - Sill Radius"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="radBoard">
			<Description><![CDATA["Curved Wall - Board Radius"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="WOD">
			<Description><![CDATA["Curved Wall - Wall Center Distance"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="offsetSill">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="offsetBoard">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="lineSections">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="7">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
				<AVal Column="4" Row="1">0</AVal>
				<AVal Column="5" Row="1">0</AVal>
				<AVal Column="6" Row="1">0</AVal>
				<AVal Column="7" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="possibleSkinTurnIn">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="possibleSkinTurnOut">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="maxSkinTurnIn">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="maxSkinTurnOut">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>

		<!-- gs_window_oversize: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_window_oversize">
			<Description><![CDATA["Opening Oversize"]]></Description>
		</Title>
		<Length Name="gs_upper_oversize">
			<Description><![CDATA["Upper Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_lower_oversize">
			<Description><![CDATA["Lower Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- iRevealType: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Integer Name="iRevealType">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<String Name="gs_reveal_type">
			<Description><![CDATA["Outer Reveal Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Без Четверти"]]></Value>
		</String>
		<String Name="gs_reveal_double_innerType">
			<Description><![CDATA["Inner Reveal Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Без Четверти"]]></Value>
		</String>
		<Length Name="leftRevealPnts">
			<Description><![CDATA["Left Reveal Points"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="rightRevealPnts">
			<Description><![CDATA["Right Reveal Points"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="iRevealPointsIdx">
			<Description><![CDATA["Reveal Points Index"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="20" SecondDimension="0">
				<AVal Row="1">1</AVal>
				<AVal Row="2">1</AVal>
				<AVal Row="3">1</AVal>
				<AVal Row="4">1</AVal>
				<AVal Row="5">1</AVal>
				<AVal Row="6">1</AVal>
				<AVal Row="7">1</AVal>
				<AVal Row="8">1</AVal>
				<AVal Row="9">1</AVal>
				<AVal Row="10">1</AVal>
				<AVal Row="11">1</AVal>
				<AVal Row="12">1</AVal>
				<AVal Row="13">1</AVal>
				<AVal Row="14">1</AVal>
				<AVal Row="15">1</AVal>
				<AVal Row="16">1</AVal>
				<AVal Row="17">1</AVal>
				<AVal Row="18">1</AVal>
				<AVal Row="19">1</AVal>
				<AVal Row="20">1</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="gs_reveal_left">
			<Description><![CDATA["Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.05</Value>
		</Length>
		<Length Name="gs_reveal_right">
			<Description><![CDATA["Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.1</Value>
		</Length>
		<Length Name="gs_reveal_double_innerLeft">
			<Description><![CDATA["Inner Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.05</Value>
		</Length>
		<Length Name="gs_reveal_double_innerRight">
			<Description><![CDATA["Inner Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.1</Value>
		</Length>
		<Length Name="gs_reveal_top">
			<Description><![CDATA["Head Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_bottom">
			<Description><![CDATA["Sill Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_reveal_double_innerTop">
			<Description><![CDATA["Inner Head Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerBottom">
			<Description><![CDATA["Inner Sill Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_outer_jamb_depth">
			<Description><![CDATA["Outer Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Length Name="revealInnerLeft">
			<Description><![CDATA["Inner Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="revealInnerRight">
			<Description><![CDATA["Inner Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Angle Name="gs_reveal_left_angle">
			<Description><![CDATA["Angle Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_right_angle">
			<Description><![CDATA["Angle Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>40</Value>
		</Angle>
		<Angle Name="gs_reveal_top_angle">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Angle Name="gs_reveal_bottom_angle">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Angle Name="gs_reveal_outerLeft_angle">
			<Description><![CDATA["Outer Angle Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Angle Name="gs_reveal_outerRight_angle">
			<Description><![CDATA["Outer Angle Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Angle Name="gs_reveal_outerTop_angle">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Angle Name="gs_reveal_outerBottom_angle">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Boolean Name="gs_reveal_auto_changed_by_cc">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="gs_ClosureTypeEnable">
			<Description><![CDATA["Closure Type Enable Mask"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Boolean Name="gs_mountingFrame">
			<Description><![CDATA["Mounting Frame"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_mountingFrame_depth">
			<Description><![CDATA["Mounting Frame Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_macro_control_parameters: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_macro_control_parameters">
			<Description><![CDATA["Macro Control Parameters"]]></Description>
		</Title>
		<Boolean Name="isWindow">
			<Description><![CDATA["Window or Door Type Object"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bWndCurved">
			<Description><![CDATA["Curved Window"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bParalellInCurvedWalls">
			<Description><![CDATA["Parallel Opening in Curved Walls"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bDrawObjContourIn">
			<Description><![CDATA["Draw Wall Contour With LINE2 at Ref. Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bDrawObjContourOut">
			<Description><![CDATA["Draw Wall Contour With LINE2 at Opp. Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bDrawFrameContourLeft">
			<Description><![CDATA["Draw Frame Contour at Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bDrawFrameContourRight">
			<Description><![CDATA["Draw Frame Contour at Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bForceContinousMode">
			<Description><![CDATA["Force Continuous Mode"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bCornerWindow">
			<Description><![CDATA["Is Corner Window"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bLeftCornerFunction">
			<Description><![CDATA["Corner on Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bRightCornerFunction">
			<Description><![CDATA["Corner on Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bWindowSymbolAtMiddle">
			<Description><![CDATA["Window in the Middle of the Wall (CHI Special)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Angle Name="ac_corner_angle">
			<Description><![CDATA["Corner Angle"]]></Description>
			<Value>90</Value>
		</Angle>
		<Boolean Name="ac_diff_con_wall_thk">
			<Description><![CDATA["Diff. Conn. Wall Thickness"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Length Name="ac_con_wall_thk">
			<Description><![CDATA["Connecting Wall Thickness"]]></Description>
			<Value>0</Value>
		</Length>
		<FillPattern Name="fillWallHole">
			<Description><![CDATA["Wallhole Background Fill Type"]]></Description>
			<Value>0</Value>
		</FillPattern>
		<PenColor Name="penWallHoleFg">
			<Description><![CDATA["Wallhole Background Fill Pen"]]></Description>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="penWallHoleBg">
			<Description><![CDATA["Wallhole Foreground Fill Pen"]]></Description>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="penWallContour">
			<Description><![CDATA["Wall Contour Pen"]]></Description>
			<Value>0</Value>
		</PenColor>
		<Integer Name="iWallContourLine">
			<Description><![CDATA["Wall Contour Line"]]></Description>
			<Value>0</Value>
		</Integer>
		<LineType Name="gs_wcont_line_in">
			<Description><![CDATA["Wall Contour Line Type Inside"]]></Description>
			<Value>1</Value>
		</LineType>
		<LineType Name="gs_wcont_line_out">
			<Description><![CDATA["Wall Contour Line Type Outside"]]></Description>
			<Value>1</Value>
		</LineType>

		<!-- gs_opening_oversize: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_opening_oversize">
			<Description><![CDATA["Oversize"]]></Description>
		</Title>
		<Length Name="gs_left_oversize">
			<Description><![CDATA["Left Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_right_oversize">
			<Description><![CDATA["Right Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- StackedWindow: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="StackedWindow">
			<Description><![CDATA["Ganging"]]></Description>
		</Title>
		<Boolean Name="gs_stack_left">
			<Description><![CDATA["Connection on the Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_stack_right">
			<Description><![CDATA["Connection on the Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_stack_top">
			<Description><![CDATA["Connection on the Top"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_stack_bottom">
			<Description><![CDATA["Connection on the Bottom"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- gs_turn_plaster: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_turn_plaster">
			<Description><![CDATA["Turn Plaster"]]></Description>
		</Title>
		<Boolean Name="gs_useWallFinishSkin">
			<Description><![CDATA["Use Wall Finish Component"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_maxPlasterThk">
			<Description><![CDATA["Plaster Thickness Limit"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.04</Value>
		</Length>
		<Boolean Name="gs_bAutoTurnOut">
			<Description><![CDATA["Auto Turn Inside Face Plaster"]]></Description>
			<Value>1</Value>
		</Boolean>
		<Integer Name="gs_bOverOut">
			<Description><![CDATA["Turn Inside Face Plaster"]]></Description>
			<Value>0</Value>
		</Integer>
		<Boolean Name="gs_bAutoTurnIn">
			<Description><![CDATA["Auto Turn Outside Face Plaster"]]></Description>
			<Value>1</Value>
		</Boolean>
		<Integer Name="gs_bOverIn">
			<Description><![CDATA["Turn Outside Face Plaster"]]></Description>
			<Value>0</Value>
		</Integer>
		<Boolean Name="gs_turn_plaster_dim_2D">
			<Description><![CDATA["Dimensionable on 2D"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_turn_plaster_show_3D">
			<Description><![CDATA["Show in 3D"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<String Name="gs_closure_type">
			<Description><![CDATA["Closure Type"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="gs_closure_type_int">
			<Description><![CDATA["Closure Type"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="iClosureType">
			<Description><![CDATA["Closure Type"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<String Name="gs_cavity_side">
			<Description><![CDATA["Turn Skin on Side"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="iCavityClosureSide">
			<Description><![CDATA["Turn Skin on Side"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Boolean Name="bCavityCloserLeft">
			<Description><![CDATA["Cavity Closure on the Left Side"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bCavityCloserRight">
			<Description><![CDATA["Cavity Closure on the Right Side"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bCavityCloserTop">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bCavityCloserBottom">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<Integer Name="gs_nTurn">
			<Description><![CDATA["Number of Skins to Turn"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="gs_nTurnDir">
			<Description><![CDATA["Number from"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA["Снаружи"]]></Value>
		</String>
		<Integer Name="iCavityClosureTurnDir">
			<Description><![CDATA["Number from"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>

		<!-- Dutch: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="Dutch">
			<Description><![CDATA["Dutch (Spouwlat)"]]></Description>
		</Title>
		<Boolean Name="gs_cc_dutch_ShowLeft">
			<Description><![CDATA["Place Closer on Side 2"]]></Description>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="gs_cc_dutch_ShowRight">
			<Description><![CDATA["Place Closer on Side 1"]]></Description>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="gs_cc_dutch_ShowTop">
			<Description><![CDATA["Place Closer on Top"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_cc_dutch_ShowBottom">
			<Description><![CDATA["Place Closer on Bottom"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Integer Name="gs_cc_dutch_ClosureToSkin">
			<Description><![CDATA["Place Closer to Skin"]]></Description>
			<Value>1</Value>
		</Integer>
		<String Name="gs_cc_dutch_ClosureToSide_str">
			<Description><![CDATA["Place Closer from Side"]]></Description>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="gs_cc_dutch_ClosureToSide">
			<Description><![CDATA["Place Closer from Side"]]></Description>
			<Value>1</Value>
		</Integer>
		<Boolean Name="gs_cc_dutch_GapAtOutsideSkin">
			<Description><![CDATA["Gap at Outside Skin"]]></Description>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="gs_cc_dutch_TurnToClosure">
			<Description><![CDATA["Turn Skin to Closer"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_cc_dutch_TurnToClosureOffs">
			<Description><![CDATA["Distance of Skin from Closer"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="gs_cc_dutch_widthJoint">
			<Description><![CDATA["Closer Width"]]></Description>
			<Value>0.038</Value>
		</Length>
		<Length Name="gs_cc_dutch_thkJoint">
			<Description><![CDATA["Closer Thickness"]]></Description>
			<Value>0.1</Value>
		</Length>

		<!-- Traditional: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="Traditional">
			<Description><![CDATA["Traditional and Dutch (Spouwlat)"]]></Description>
		</Title>

		<!-- Strip: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="Strip">
			<Description><![CDATA["Insulation Strip"]]></Description>
		</Title>
		<Boolean Name="gs_bJoint">
			<Description><![CDATA["Insert Insulation Strip"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_showJoint">
			<Description><![CDATA["Show Insulation Strip"]]></Description>
			<Value>1</Value>
		</Boolean>
		<Length Name="gs_thkJoint">
			<Description><![CDATA["Strip Thickness"]]></Description>
			<Value>1</Value>
		</Length>
		<PenColor Name="gs_penJoint">
			<Description><![CDATA["Contour Pen"]]></Description>
			<Value>0</Value>
		</PenColor>
		<LineType Name="gs_ltJoint">
			<Description><![CDATA["Contour Line Type"]]></Description>
			<Value>0</Value>
		</LineType>
		<FillPattern Name="gs_fillJoint">
			<Description><![CDATA["Fill Type"]]></Description>
			<Value>0</Value>
		</FillPattern>
		<PenColor Name="gs_penJointFg">
			<Description><![CDATA["Fill Pen"]]></Description>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="gs_penJointBg">
			<Description><![CDATA["Fill Background Pen"]]></Description>
			<Value>0</Value>
		</PenColor>
		<Boolean Name="gs_cc_dutch_matJointCustom">
			<Description><![CDATA["Custom Surface"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Material Name="gs_cc_dutch_matJoint">
			<Description><![CDATA["Surface"]]></Description>
			<Value>15</Value>
		</Material>

		<!-- Prefabricated: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="Prefabricated">
			<Description><![CDATA["Heat Insulation"]]></Description>
		</Title>
		<Length Name="gs_widthPlug">
			<Description><![CDATA["Profile Width"]]></Description>
			<Value>0.05</Value>
		</Length>
		<PenColor Name="gs_penPlug">
			<Description><![CDATA["Contour Pen"]]></Description>
			<Value>1</Value>
		</PenColor>
		<LineType Name="gs_ltPlug">
			<Description><![CDATA["Contour Line Type"]]></Description>
			<Value>1</Value>
		</LineType>
		<FillPattern Name="gs_fillPlug">
			<Description><![CDATA["Fill Type"]]></Description>
			<Value>18</Value>
		</FillPattern>
		<PenColor Name="gs_penPlugFg">
			<Description><![CDATA["Fill Pen"]]></Description>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="gs_penPlugBg">
			<Description><![CDATA["Fill Background Pen"]]></Description>
			<Value>0</Value>
		</PenColor>

		<!-- CustomClosure: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="CustomClosure">
			<Description><![CDATA["Custom Closure"]]></Description>
		</Title>
		<Length Name="gs_custom_cc_array_left">
			<Description><![CDATA["Left Side Skin Data"]]></Description>
			<ArrayValues FirstDimension="8" SecondDimension="4">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0.015</AVal>
				<AVal Column="3" Row="1">0</AVal>
				<AVal Column="4" Row="1">1</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0.015</AVal>
				<AVal Column="3" Row="2">0</AVal>
				<AVal Column="4" Row="2">1</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0.015</AVal>
				<AVal Column="3" Row="3">0</AVal>
				<AVal Column="4" Row="3">1</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0.015</AVal>
				<AVal Column="3" Row="4">0</AVal>
				<AVal Column="4" Row="4">1</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0.015</AVal>
				<AVal Column="3" Row="5">0</AVal>
				<AVal Column="4" Row="5">1</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0.015</AVal>
				<AVal Column="3" Row="6">0</AVal>
				<AVal Column="4" Row="6">1</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0.015</AVal>
				<AVal Column="3" Row="7">0</AVal>
				<AVal Column="4" Row="7">1</AVal>
				<AVal Column="1" Row="8">0</AVal>
				<AVal Column="2" Row="8">0.015</AVal>
				<AVal Column="3" Row="8">0</AVal>
				<AVal Column="4" Row="8">1</AVal>
			</ArrayValues>
		</Length>
		<Length Name="gs_custom_cc_array_right">
			<Description><![CDATA["Right Side Skin Data"]]></Description>
			<ArrayValues FirstDimension="8" SecondDimension="4">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0.015</AVal>
				<AVal Column="3" Row="1">0</AVal>
				<AVal Column="4" Row="1">1</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0.015</AVal>
				<AVal Column="3" Row="2">0</AVal>
				<AVal Column="4" Row="2">1</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0.015</AVal>
				<AVal Column="3" Row="3">0</AVal>
				<AVal Column="4" Row="3">1</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0.015</AVal>
				<AVal Column="3" Row="4">0</AVal>
				<AVal Column="4" Row="4">1</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0.015</AVal>
				<AVal Column="3" Row="5">0</AVal>
				<AVal Column="4" Row="5">1</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0.015</AVal>
				<AVal Column="3" Row="6">0</AVal>
				<AVal Column="4" Row="6">1</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0.015</AVal>
				<AVal Column="3" Row="7">0</AVal>
				<AVal Column="4" Row="7">1</AVal>
				<AVal Column="1" Row="8">0</AVal>
				<AVal Column="2" Row="8">0.015</AVal>
				<AVal Column="3" Row="8">0</AVal>
				<AVal Column="4" Row="8">1</AVal>
			</ArrayValues>
		</Length>
		<Length Name="defaultCustomClosureThickness">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0.015</Value>
		</Length>
		<Integer Name="iCustomCCEditJambSide">
			<Description><![CDATA["Edited Jamb Side"]]></Description>
			<Value>-9999</Value>
		</Integer>
		<Integer Name="iCustomCCEditWallSide">
			<Description><![CDATA["Edited Wall Side"]]></Description>
			<Value>-9999</Value>
		</Integer>
		<Integer Name="iCustomCCEditSkin">
			<Description><![CDATA["Edited Skin Number"]]></Description>
			<Value>-9999</Value>
		</Integer>
		<Boolean Name="gs_custom_cc_turn_in">
			<Description><![CDATA["Turn-in Skin"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_custom_cc_plaster">
			<Description><![CDATA["Consider Skin as Plaster"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Integer Name="iCustomCCThicknessType">
			<Description><![CDATA["Turn-in Thickness"]]></Description>
			<Value>1</Value>
		</Integer>
		<Length Name="gs_custom_cc_thickness">
			<Description><![CDATA["Custom Thickness"]]></Description>
			<Value>0.015</Value>
		</Length>
		<Integer Name="iCustomCCOrientation">
			<Description><![CDATA["Hatch Orientation"]]></Description>
			<Value>-9999</Value>
		</Integer>
		<Boolean Name="gs_custom_cc_separator">
			<Description><![CDATA["Separating Line at Turn-in"]]></Description>
			<Value>0</Value>
		</Boolean>
		<PenColor Name="gs_custom_cc_separator_pen">
			<Description><![CDATA["Separating Line Pen"]]></Description>
			<Value>1</Value>
		</PenColor>
		<Length Name="gs_custom_cc_overhang">
			<Description><![CDATA["Skin Overhang to Frame Depth"]]></Description>
			<Value>0</Value>
		</Length>
		<Boolean Name="gs_custom_cc_last_sel_side">
			<Description><![CDATA["Last Selected Side"]]></Description>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="gs_closure_auto_changed">
			<Description><![CDATA["Closure Method Changed Automatically"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- gs_string_resources: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_string_resources">
			<Description><![CDATA["String Resources"]]></Description>
		</Title>
		<String Name="stCavityClosureSide">
			<Description><![CDATA["gs_cavity_side"]]></Description>
			<ArrayValues FirstDimension="4" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
				<AVal Row="3"><![CDATA[""]]></AVal>
				<AVal Row="4"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stCavityClosureTurnDir">
			<Description><![CDATA["gs_nTurnDir"]]></Description>
			<ArrayValues FirstDimension="2" SecondDimension="0">
				<AVal Row="1"><![CDATA["Снаружи"]]></AVal>
				<AVal Row="2"><![CDATA["Внутри"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stDutchClosureToSide">
			<Description><![CDATA["gs_cc_dutch_ClosureToSide_str"]]></Description>
			<ArrayValues FirstDimension="2" SecondDimension="0">
				<AVal Row="1"><![CDATA["Снаружи"]]></AVal>
				<AVal Row="2"><![CDATA["Внутри"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stCavityClosureEditedJambSide">
			<Description><![CDATA["gs_custom_cc_edit_jamb_side"]]></Description>
			<ArrayValues FirstDimension="3" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
				<AVal Row="3"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stCavityClosureEditedWallSide">
			<Description><![CDATA["gs_custom_cc_edit_wall_side"]]></Description>
			<ArrayValues FirstDimension="2" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stCavityClosureEditedSkinNumber">
			<Description><![CDATA["gs_custom_cc_edit_skin"]]></Description>
			<ArrayValues FirstDimension="4" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
				<AVal Row="3"><![CDATA[""]]></AVal>
				<AVal Row="4"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stCavityClosureTurnInThickness">
			<Description><![CDATA["gs_custom_cc_thickness_type"]]></Description>
			<ArrayValues FirstDimension="2" SecondDimension="0">
				<AVal Row="1"><![CDATA["Исходная"]]></AVal>
				<AVal Row="2"><![CDATA["Специальный"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stCavityClosureHatchOrientation">
			<Description><![CDATA["gs_custom_cc_orientation"]]></Description>
			<ArrayValues FirstDimension="2" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stCavityClosureUI">
			<Description><![CDATA[""]]></Description>
			<ArrayValues FirstDimension="60" SecondDimension="0">
				<AVal Row="1"><![CDATA["Замыкание Слоев"]]></AVal>
				<AVal Row="2"><![CDATA["Способ Замыкания"]]></AVal>
				<AVal Row="3"><![CDATA["Сторона Проема"]]></AVal>
				<AVal Row="4"><![CDATA["Наружных Слоев"]]></AVal>
				<AVal Row="5"><![CDATA["Поворачивающих Слоев"]]></AVal>
				<AVal Row="6"><![CDATA["Нумерация с"]]></AVal>
				<AVal Row="7"><![CDATA["Поворот на Четверти"]]></AVal>
				<AVal Row="8"><![CDATA["Термовкладыш"]]></AVal>
				<AVal Row="9"><![CDATA["Толщина Вкладыша"]]></AVal>
				<AVal Row="10"><![CDATA["Перо Контура"]]></AVal>
				<AVal Row="11"><![CDATA["Тип Линии"]]></AVal>
				<AVal Row="12"><![CDATA["Тип Штриховки"]]></AVal>
				<AVal Row="13"><![CDATA["Перо Штриховки"]]></AVal>
				<AVal Row="14"><![CDATA["Перо Фона Штриховки"]]></AVal>
				<AVal Row="15"><![CDATA["Профиль"]]></AVal>
				<AVal Row="16"><![CDATA["Ширина Профиля"]]></AVal>
				<AVal Row="17"><![CDATA["Поворот Штукатурки"]]></AVal>
				<AVal Row="18"><![CDATA["Снаружи"]]></AVal>
				<AVal Row="19"><![CDATA["Внутри"]]></AVal>
				<AVal Row="20"><![CDATA["Автоматически"]]></AVal>
				<AVal Row="21"><![CDATA["Поворачивающих Слоев"]]></AVal>
				<AVal Row="22"><![CDATA["Предел Толщины Штукатурки"]]></AVal>
				<AVal Row="23"><![CDATA["Использовать Отделку Стены"]]></AVal>
				<AVal Row="24"><![CDATA["Выбор Редактируемого Слоя"]]></AVal>
				<AVal Row="25"><![CDATA["Продлить Слой до Термовкладыша"]]></AVal>
				<AVal Row="26"><![CDATA["1. Толщина Поворота"]]></AVal>
				<AVal Row="27"><![CDATA["Специальная Толщина"]]></AVal>
				<AVal Row="28"><![CDATA["Ориентация Штриховки"]]></AVal>
				<AVal Row="29"><![CDATA["Разделитель при Повороте Внутрь"]]></AVal>
				<AVal Row="30"><![CDATA["Перо Разделительной Линии"]]></AVal>
				<AVal Row="31"><![CDATA["2. Продление Слоя за Коробку"]]></AVal>
				<AVal Row="32"><![CDATA["Считать Слой Штукатуркой, если он Тоньше или Равен"]]></AVal>
				<AVal Row="33"><![CDATA["Настройка Слоя Штукатурки"]]></AVal>
				<AVal Row="34"><![CDATA["Показ в 3D"]]></AVal>
				<AVal Row="35"><![CDATA["Прим: Ширина Четверти определяет толщину повернутого слоя Штукатурки."]]></AVal>
				<AVal Row="36"><![CDATA["Реквизиты Термовкладыша"]]></AVal>
				<AVal Row="37"><![CDATA["Реквизиты"]]></AVal>
				<AVal Row="38"><![CDATA[""]]></AVal>
				<AVal Row="39"><![CDATA[""]]></AVal>
				<AVal Row="40"><![CDATA["1. Считать Слой Штукатуркой"]]></AVal>
				<AVal Row="41"><![CDATA["Размеры Ширины Четверти определяют толщину повернутого слоя Штукатурки."]]></AVal>
				<AVal Row="42"><![CDATA["Несущий слой не может быть повернут."]]></AVal>
				<AVal Row="43"><![CDATA[""]]></AVal>
				<AVal Row="44"><![CDATA[""]]></AVal>
				<AVal Row="45"><![CDATA["Вкладыш для"]]></AVal>
				<AVal Row="46"><![CDATA["от"]]></AVal>
				<AVal Row="47"><![CDATA["Сторона Проема"]]></AVal>
				<AVal Row="48"><![CDATA["Сторона Проема"]]></AVal>
				<AVal Row="49"><![CDATA["Продлить Слой до Термовкладыша"]]></AVal>
				<AVal Row="50"><![CDATA["1. Слой"]]></AVal>
				<AVal Row="51"><![CDATA["2. Слой"]]></AVal>
				<AVal Row="52"><![CDATA["3. Слой"]]></AVal>
				<AVal Row="53"><![CDATA["4. Слой"]]></AVal>
				<AVal Row="54"><![CDATA["Специальное Покрытие"]]></AVal>
				<AVal Row="55"><![CDATA["Покрытие"]]></AVal>
				<AVal Row="56"><![CDATA["Расстояние от Термовкладыша до Слоя"]]></AVal>
				<AVal Row="57"><![CDATA["Ширина Термовкладыша"]]></AVal>
				<AVal Row="58"><![CDATA["Толщина Термовкладыша"]]></AVal>
				<AVal Row="59"><![CDATA[""]]></AVal>
				<AVal Row="60"><![CDATA["Размеры в 2D"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stClosureTypes">
			<Description><![CDATA[""]]></Description>
			<ArrayValues FirstDimension="8" SecondDimension="0">
				<AVal Row="1"><![CDATA["Без Замыкания"]]></AVal>
				<AVal Row="2"><![CDATA["Традиционное Замыкание Полости"]]></AVal>
				<AVal Row="3"><![CDATA["Готовое Замыкание Полости"]]></AVal>
				<AVal Row="4"><![CDATA["Специальное Замыкание"]]></AVal>
				<AVal Row="5"><![CDATA["Сплошная Стена"]]></AVal>
				<AVal Row="6"><![CDATA["Деревянная Каркасная Стена"]]></AVal>
				<AVal Row="7"><![CDATA["Деревянная Каркасная Стена с Наружной Обшивкой"]]></AVal>
				<AVal Row="8"><![CDATA["Кирпичная Облицовка"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stRevealClusureUITips">
			<Description><![CDATA[""]]></Description>
			<ArrayValues FirstDimension="13" SecondDimension="0">
				<AVal Row="1"><![CDATA["Глубина Четверти"]]></AVal>
				<AVal Row="2"><![CDATA["Ширина Четверти со Стороны 2"]]></AVal>
				<AVal Row="3"><![CDATA["Ширина Четверти"]]></AVal>
				<AVal Row="4"><![CDATA["Ширина Внутренней Четверти со Стороны 2"]]></AVal>
				<AVal Row="5"><![CDATA["Ширина Внутренней Четверти"]]></AVal>
				<AVal Row="6"><![CDATA["Высота Верхней Четверти"]]></AVal>
				<AVal Row="7"><![CDATA["Высота Отлива"]]></AVal>
				<AVal Row="8"><![CDATA["Высота Верхней Внутренней Четверти"]]></AVal>
				<AVal Row="9"><![CDATA["Высота Отлива Внутри"]]></AVal>
				<AVal Row="10"><![CDATA["Угол Откоса со Стороны 2"]]></AVal>
				<AVal Row="11"><![CDATA["Сторона Угла"]]></AVal>
				<AVal Row="12"><![CDATA["Угол Верхней Стороны"]]></AVal>
				<AVal Row="13"><![CDATA["Угол Нижней Стороны"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stSubTabpageToolTip">
			<Description><![CDATA[""]]></Description>
			<Value><![CDATA["Выбор Вкладки: Общие Параметры, Реквизиты"]]></Value>
		</String>
	</Parameters>
</ParamSection>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="1" length_in_bytes="577" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000007B0000
	00420803000000406C59280000002C744558744372656174696F6E2054696D65
	004373203135206E6F762E20323031322031343A32303A3435202B303130303D
	0D13CE0000000774494D4507DC0B0F0D1E13DEBCBAE100000009704859730000
	0AF000000AF00142AC34980000000467414D410000B18F0BFC61050000001250
	4C54450000FF000000FFFFFFB5ADADFF0000DEDEDE28FB743B0000000174524E
	530040E6D866000001634944415478DAED988D0E83200C84ADCEF77FE54D650A
	4AE9AF3033CE19B365F1F3AE148803907A7D44FF8BD270D2F2C348EA163670D9
	F33C9975765D970DFB21C97C9EDBD57B612FCF0EC183E66A6443B899EA6A63C3
	64394D6C83E7E53A64C41E6B865A5F7B4CC66EE9DBBBDE32B6EF3817B25DFBFB
	39BE1BD6BBF7F75FF5B779FD0EDB067060AF7EC227F9827CBECB57BC8BD07818
	C7ADFE3B9A018F68946F2804B1B2A3DB726CEF4046E6245B99B90F5B95F9CE5E
	A36F9339ACA74BE6823DF2913988C6399A394367369239E07EB1CCE56C247316
	3B2DA7940D36B62D73A89F3939AFDD9979329FAB7DC7EB0AE3C8AD63855E227C
	CBC45CBF5176B28E1D128D352D3B7E80DABE117645DF7C5E05F6237D4BD73127
	DFA5BD03AA830D02F2F5DD5E61EF40B3BF439DD96E99C4D56CE59C0AC7E6C190
	B9D137EF1DD71DF5DEDCEBD93265BAAB111B9D5B3ABBB33BFB07D85239B2C5EA
	ECCE7E165BA71C5B7B2F07F61BE6ED3C79BE5B1D4E0000000049454E44AE4260
	82
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="2" length_in_bytes="120" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000140000
	00140103000000B7478F4E00000006504C5445000000000000A567B9CF000000
	0174524E530040E6D866000000164944415408D763600082FAFF0FC038814C08
	D30F04001DB913F97129DC020000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="3" length_in_bytes="120" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000140000
	00140103000000B7478F4E00000006504C54450000009D9DA13592F545000000
	0174524E530040E6D866000000164944415408D763600082FAFF0FC038814C08
	D30F04001DB913F97129DC020000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="4" length_in_bytes="144" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000140000
	00140203000000F0E7F59E00000009504C5445000000FFFFFF00000073C68371
	0000000174524E530040E6D8660000002B4944415408D763600003AD55AB56AD
	8091D3A64D0392515151190C9A9999994072E9D2A59489239B0F0600BBC729B5
	52F540B20000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="5" length_in_bytes="144" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000140000
	00140203000000F0E7F59E00000009504C5445000000FFFFFF9D9DA1E333CFFB
	0000000174524E530040E6D8660000002B4944415408D763600003AD55AB56AD
	8091D3A64D0392515151190C9A9999994072E9D2A59489239B0F0600BBC729B5
	52F540B20000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="6" length_in_bytes="138" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000170000
	001102030000004B1DDF2E00000009504C5445000000FFFFFF00000073C68371
	0000000174524E530040E6D866000000254944415408D763608003A6AC052452
	ABC014C3AC06646A1584E26040A3B456AD82AA0702006F300EDFB3946F770000
	000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="7" length_in_bytes="138" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000170000
	001102030000004B1DDF2E00000009504C5445000000FFFFFF9D9DA1E333CFFB
	0000000174524E530040E6D866000000254944415408D763608003A6AC052452
	ABC014C3AC06646A1584E26040A3B456AD82AA0702006F300EDFB3946F770000
	000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="8" length_in_bytes="159" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000001D0000
	00100803000000DDD384E300000009504C5445000000FFFFFF00000073C68371
	0000000174524E530040E6D8660000003A4944415478DAC5CC410A00200C0341
	DDFF3F5A7A09D215042FA63D8843331EC2A452AF7DA5C6A8F073336AD6B150CA
	C9532CCCA7504ADBCC350BFF930106624DF5830000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="9" length_in_bytes="159" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000001D0000
	00100803000000DDD384E300000009504C5445000000FFFFFF9D9DA1E333CFFB
	0000000174524E530040E6D8660000003A4944415478DAC5CC410A00200C0341
	DDFF3F5A7A09D215042FA63D8843331EC2A452AF7DA5C6A8F073336AD6B150CA
	C9532CCCA7504ADBCC350BFF930106624DF5830000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="10" length_in_bytes="142" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000001D0000
	0010020300000097639C4200000009504C5445000000FFFFFF00000073C68371
	0000000174524E530040E6D866000000294944415408D7636040016AAB181844
	434303C86468C1189C2BD0195C300643032A234849A101E10000B16918201D39
	4CE70000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="11" length_in_bytes="142" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000001D0000
	0010020300000097639C4200000009504C5445000000FFFFFF9D9DA1E333CFFB
	0000000174524E530040E6D866000000294944415408D7636040016AAB181844
	434303C86468C1189C2BD0195C300643032A234849A101E10000B16918201D39
	4CE70000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="12" length_in_bytes="652" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000007B0000
	00420803000000406C59280000002C744558744372656174696F6E2054696D65
	004373203135206E6F762E20323031322031343A32323A3335202B3031303033
	3DCAEA0000000774494D4507DC0B0F0D192ACEF8A42E00000009704859730000
	0AF000000AF00142AC34980000000467414D410000B18F0BFC61050000001250
	4C54450000FF000000FFFFFFB5ADADFF0000DEDEDE28FB743B0000000174524E
	530040E6D866000001AE4944415478DAE5D8815283301004502E29FFFFCB9240
	8184D0DC6EB6B68EA98AA34E9F777B09D5C93CEB9196EB276FD754ADF485E058
	0FBD6D4E7B71E7798E63ABAEDA674BE898B9E7C3DBF3951E6B3899F74E475B7E
	7BFE9DB00F3A3D81E5F65157DC3ED3717B2AEE0ADB352DAC7BEAD8AAAC5B7977
	6C59D6E98AD9BAACAF674BC716668DD6ADCC1ACD5B99353AE7C95665DDDADF7D
	5B93355FF767F2CE83F691395F7BAEC81ADDDFAFEA56DCBFC9BC573F7F12DD6F
	9A393FD1004EDA65768788942DA9FB4C423DDF5E259A3FEFCB2A68BCE7C5D4A1
	F31AE348CFF791CF97AA5C0BF76BF95E5538B1C76CFF68B05DC6ED5FA53D7176
	D173DE1EEDF9AFD72DE9F99AB7674E743DBF9D73BBAF57D6F3627FC37679CEB8
	1F9D73CD6523B5B6F29E3436356B22FB4FD7DDD84BFFA2EE6FCFBBBA7F2BEA86
	CEB5C33642BEFE6FAFBA97F4ECCDACAE74CFFDF6131F3C53EDB881FB5EAF8512
	97D4EDFD3F72287141DE6BF5801D8CDF62F5ACE5FB38628FE09DFDFD567CDCE6
	71814DE30A9BC52536896B6C0E17D914AEB283E720BEF93B74D8262AD7D9382E
	B4615C69A3B8D40671AD8DE1621BDA6A2D9BD8AAD46AD03F2FBE3DABF629B674
	0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="13" length_in_bytes="641" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000007B0000
	00420803000000406C59280000002C744558744372656174696F6E2054696D65
	004373203135206E6F762E20323031322031343A31353A3436202B3031303073
	2EA4160000000774494D4507DC0B0F0D1D2BDD9351BC00000009704859730000
	0AF000000AF00142AC34980000000467414D410000B18F0BFC61050000001550
	4C54450000FF000000FFFFFFB5ADADD6D6D6FF0000DEDEDE5509EF4800000001
	74524E530040E6D866000001A04944415478DAE5D88D6E83300C04609CAC7DFF
	475EF909242111B9F3D1AAAAA70A3669FA7A751C2893C1F54805FDD754D5FC87
	80D643621B63BFCCE7AB225A756AC266E9E8FFCC693AAE596D4B4CD81B8DAF4F
	FF5A3BE8258A45E0E8B42B3A46E4E8B3335A907B42EC2235FEF2D89E5ECF4787
	EDEA756BBED7CD0D2BA6D74BEE6DB40DC86D56FC624CAFB37E17937E6907CBCF
	8DC97CACF3729BB9B6777C3E35A6D7F97C439F7948F872E6CC8DDBC71B70F71B
	B7F7AE3BD6396DEF07F77C7F55EE0FF65BB0CED9DCFEF9FE63FBDDDFD7987B26
	D17E9E620D55652FEFC6711D73D8B6BCDAE3DC6D7D3EDF9EDC94ADC9BD7E2982
	6D4DBFB9DCF9DCBEB9DF19FA9675AECBDDBD6FB17E5E59BF7BF76B437635EBC3
	3F17F7A983B9B99A1AE5B0A9B526B2BF3A7763967E22376E33BB1A6F97339D6C
	0C3FB71ACA1D047BCBF688EB742D19B245B929DB54FDC6AE6309A7AA41C3CF72
	59BC41E3CFB049BCB1A3E136895FCCF7ADB8C8A67095CDE0329BC075368E0B6D
	1857DA282EB5C3C86E7CFEEEAFB1B1E4621BC2D53682CB6D00D7DBE3F80DF630
	7E873D3A6A2D1B9B52BE1AF43F95C33D7A5CBB5C3C0000000049454E44AE4260
	82
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="17" length_in_bytes="578" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000007B0000
	004D0803000000B13AEBFD0000002C744558744372656174696F6E2054696D65
	004373203135206E6F762E20323031322031323A34333A3539202B3031303095
	60D7B90000000774494D4507DC0B0F0B2C3B02F43AD800000009704859730000
	0AF000000AF00142AC34980000000467414D410000B18F0BFC61050000000C50
	4C54450000FF000000FFFFFFB5ADAD5450AB390000000174524E530040E6D866
	0000016A4944415478DAED995916C2200C450DEC7FCF768016E8001948AC25D5
	167FBC3EF20839F801E5F824E1D061CBF6CE4F41BBB1D90C389F4D870BB0C970
	2E9B916EBEEEE1B5E1B517788D55CFD76B7ED1D887ECB74790BCEC2AA47CEFF0
	694C61AF5360C3A6CFB9DBE0F3509B1DE0CBE8556CB7FD0003B68B8E7B1B3B7A
	FD6DBA05D894FD20CE78279F434577CFF5FDC3ECAEF5FC9EDD771FEBCC0E2D0C
	D2DF9DFB962BCD3BBB5FBF5665A7BDA75F84B7BF2B7D6A033B81AF730EAD4F01
	F60E0FF98E69AF3DB9ECACDBD7D69DC219F9BE5E4B6D5E73D0AE797E5275C728
	BDD69A6B10C877E13515DDE75E535EDF99D7B4D777E635D5F52D55D728FB58EE
	35D17C57E250D7247D5E65975E135CDF7576BFBAD6C04EBDA69BEFC26BB8BE45
	D26B96677BC8935D51AF216FB25EC3C145BD66798E8C3CD915F51AF2265CD7EC
	BCE60DBD86AC34A3AED9FE07CDFB261EFB5901B71FFF37866E0BDD703AD441C3
	F958055D540BDAF538DD62F9FE020B3340BAB1F908D50000000049454E44AE42
	6082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="18" length_in_bytes="573" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000007B0000
	004D0803000000B13AEBFD0000002C744558744372656174696F6E2054696D65
	004373203135206E6F762E20323031322031323A35353A3430202B3031303000
	C23D730000000774494D4507DC0B0F0B38171E82816E00000009704859730000
	0AF000000AF00142AC34980000000467414D410000B18F0BFC61050000000C50
	4C54450000FF000000FFFFFFB5ADAD5450AB390000000174524E530040E6D866
	000001654944415478DAED99590283200C4405EE7FE7BA816055C824905A882D
	E28FAF4386B593691C5314961CBA6C67DD1C58C16633E07C360E1760C3702E9B
	916EBEEEE1B5E1B50EBCC61ACFB76BF960ECAFEC97C72E799D55A07C1FF0B98E
	B0B726D061E36D6E037CA9B666EFF0B5D615DB861FA0C0B6DE71BDB1BDD77BD3
	2DC046E603DFE2957C6E32BA6BF6EF1F66571DCF9FD975E7B1CAEC7D0943F477
	E575CB9DE6835D6FBD96653BB788C5BE997C17B0E7976C6D4DBE0BB09D4F33F5
	FE6EDD8C7C475EBBEF4BA53EA76947FB58A0C59B2C43CB79666F50E4B500C774
	C3F94E7696A671FF8EE1A0CF27D8E711DC60FD1B67A75E437523F358EA352CDF
	22E72DA0CF45CE5BA0FECD60A75E6BAB3BF15ADB7C9FBC465BB7487A4DF36C8F
	78B22BEA356221EB351A5CD46B9AE7C8C4935D51AF110BE1714DCF6B4ED16BC4
	91668C6BBAFF41F3DEC463BF2BCCE3E3FFC6D0ADA1DB5C56DBA0CD75BD09FA34
	5AA0D7CB748BE5FB03EAE840AC6CC7D16C0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="19" length_in_bytes="570" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000007B0000
	004D0803000000B13AEBFD0000002C744558744372656174696F6E2054696D65
	004373203135206E6F762E20323031322031323A34363A3035202B30313030FC
	0978ED0000000774494D4507DC0B0F0B2E29C37B291200000009704859730000
	0AF000000AF00142AC34980000000467414D410000B18F0BFC61050000000C50
	4C54450000FF000000FFFFFFB5ADAD5450AB390000000174524E530040E6D866
	000001624944415478DAED99010E83200C452DDCFFCE9B68141C0A6D3F452775
	1B90181FA5BF806C22639B22736CEBCBF6CE7F4DF6A3652BD06AB602ED006CB1
	EB7AB67CD487D686D686D61EA435EBB524762434EBBF50AD91A7F0585F5742B5
	467E7D745D09D59AB5DFA9D68CE31D6BADDEE7B9046BAD3AD690FC3E68CDD2EF
	546BE6F18EB426D7B9648F7DD41A38BF89A135747E5FB313ADC1E37DC93ECC6B
	689D17C63CD11A3ABF4B6CC8BCC6D1775E6BD0789FF9BCB155EFC0CB357F64EC
	9FE8D7DB3EDC3276740739117B19823E6CF998EFB7CC556BF65A0F3539FB3C97
	DAB3397EC77DDB3A603FE64165EE8DECADF932BF016CC93AD650E7056B9ADF37
	67379BCFCBEC76EB9801FB74FD2EB21BEE5BCAEC76FBB522FB36677BCC9E40DF
	817B9E23337BA267DFE41C99D913A8D6BA9E2377D49AEFA835E6BF2750AD19CF
	6BAAF95C78EE80B0E9B94617AD7FB6E1770FBF2953B34253AE6A84CEED3CB9D7
	F3FC46C5FB03714B40BA63A3E8540000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="20" length_in_bytes="1328" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000007B0000
	004D0803000000B13AEBFD0000002C744558744372656174696F6E2054696D65
	004373203135206E6F762E20323031322031323A34373A3037202B3031303084
	5402FA0000000774494D4507DC0B0F0B383B2C5AED8D00000009704859730000
	0AF000000AF00142AC34980000000467414D410000B18F0BFC61050000030050
	4C54450000FF000000FFFFFFB5ADAD0000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000009AEF8E9D0000000174524E530040E6D866000001644944415478DAED99
	8B0E83200C452DFCFF3F6FA271B801A50F5A9DD44C31311E2EBD3C640B18C792
	4520872F3B86F80EDE49CA16A0C56C013A28B0D9D2E56C7EAB4FAF4DAF4DAFDD
	C86BD673492E24DDF6FF54BD0611D26B63DF55D56B10F757F75D55BD66ADFBEC
	35E37CE75EEBD7BC5E95BDD69D6B95FEFDE5354BDD67AFF1F20D2A5EE3F87C1B
	E2E4AB7D56FF4EA36B4D5C533731C727DD908E569BB7D984FC32F28DB0799A73
	9F0BD8A41C97FAB7B76E8AA30DF25DD37CB045DFC06D9FE3EC9FECF707D2BF51
	76F60404167B6B021F36BFCD3F8FAC456BF65E4E253EBBDE97C6B329BAF3BA1D
	15B06FF3E4B2F044F671FB30DD0A6CCE3C36D0E7480CEDDF17670F1BCF71F6B8
	79CC805D9DBF51F6C0750BCE1EB75E43D997D9DB23D64475BFC5731F995813D5
	FD16E2497BBFE599FBC88E5E8B8E5E23FE7BA2EA35E3714D349E67217B938C7D
	B380C6DD3FC7D4EDA11B0A252B34948A46E8D2CA937EDC4DB756BE5FE88640AB
	9025B6D30000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="21" length_in_bytes="163" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000230000
	002D020300000059BD3ABA00000009504C5445000000FFFFFF00000073C68371
	0000000174524E530040E6D8660000003E4944415418D363E0E8808006060480
	B139189856410003435328188401C5B2C042CB8062A960B134A01894352A46A6
	18224C11E10C0F7B447C20003CDE00D47F7BA31F1403D70000000049454E44AE
	426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="22" length_in_bytes="142" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000000C0000
	001102030000009453A53100000009504C5445FF0000000000FFFFFFCA92C399
	0000000174524E530040E6D8660000002949444154085B6360000151209684D2
	4898353484816DD512380DC769290C9233A73084860680740300E7DA0A3F336E
	43A40000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="23" length_in_bytes="148" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000000C0000
	001102030000009453A53100000009504C5445FF0000FFFFFF9D9DA1AA7CC3B0
	0000000174524E530040E6D8660000002F49444154085B636000012D20567300
	D2A8986BD50A06CED04820BD124C73C2604727835A5A26C3AA554B1944434300
	1D930B4AF52DDA260000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="24" length_in_bytes="366" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000007B0000
	00420803000000406C59280000002C744558744372656174696F6E2054696D65
	004373203135206E6F762E20323031322031313A34323A3138202B30313030E5
	55D5070000000774494D4507DC0B0F0A2B120EC55E4400000009704859730000
	0AF000000AF00142AC34980000000467414D410000B18F0BFC61050000001250
	4C54450000FF000000FF0000FFFFFFDEDEDEB5ADAD8E50424A0000000174524E
	530040E6D866000000904944415478DAEDD9410AC0200C4451D3DAFB5FB92E85
	B6014D344AFF5CE031A2444812354789B8265539D5C4DA395FAED9C78E3C7391
	C8DED8D8D8D8D8D8D8D8D8D82BDA8F38D95D1FFCB1BD45390C6CEC2EBBE57A4F
	E8FDD5191B7B5B5B794B4BF59E30C7B4DEE6CF04F67FEDC63936BAB7166C6C6C
	6C6C6F7BCA6EEED536B436F78EB38D4BE9DEF92D0ECBF88ABE012A126F354B3E
	5CFC0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="25" length_in_bytes="483" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000007B0000
	00420803000000406C59280000002C744558744372656174696F6E2054696D65
	004373203135206E6F762E20323031322031313A35333A3232202B30313030E1
	E639540000000774494D4507DC0B0F0A352B8581E99300000009704859730000
	0AF000000AF00142AC34980000000467414D410000B18F0BFC61050000001250
	4C54450000FF000000FF0000FFFFFFDEDEDEB5ADAD8E50424A0000000174524E
	530040E6D866000001054944415478DAED99DB1282300C445B4BFFFF9785FA60
	057AC9DD3259181E9C618E9B2E25D110617AED02DEF2AB5029C164CBDEB64CD1
	C26CCB9AC7B87FFF9471170E36164E66634D73B0D115E760E3E19E35CF9A67CD
	B3E659F3AC79D6EA8B65BF56123025FEAC29B22FCBA8E9FB0C57ADF9396BAAEB
	BD7AD648C3D55779F608B11CC7D9F21D3BDE6FD940DF659741B1AF9F00D99F2D
	CE864DA8F903D890302BF86E79666437B33666CB3D6318F67CEFD0DF5BC6ECC3
	804CAF38B1DE783899CDD42B769EA55ECDA5E69226BB4EB5D05CD2F32D3D978C
	D93659939E4B666AAE9EB5C43C0303DF633E03FFCD0CECBFB778D61E98354ABF
	4663678A966533FE070DBC9593FD06DE6864E9BCEC27BC0000000049454E44AE
	426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="26" length_in_bytes="465" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000007B0000
	00420803000000406C59280000002C744558744372656174696F6E2054696D65
	004373203135206E6F762E20323031322031313A35343A3038202B30313030E5
	6F7A1E0000000774494D4507DC0B0F0A3622D77002F400000009704859730000
	0AF000000AF00142AC34980000000467414D410000B18F0BFC61050000001250
	4C54450000FF000000FF0000FFFFFFDEDEDEB5ADAD8E50424A0000000174524E
	530040E6D866000000F34944415478DAED998D0A83300C84ED34EFFFCA5B5161
	9B366BFE3C3A73A00541BF9EBD1A5AA722D3E325E12D9F9ADE34CB84652F0B59
	34301BF9CE4B219AAB07CDC9CE56A3ED6C3DDAC1B71AEDC2D65ACFAC65D6326B
	F7C89AA928C5D4B1C2783F7B64B545EB996FCDECE395F5D17B17983686DD7704
	B0BB3CD736C277CF587F7FD72419BDC077CB33C7F61A6F25DB25E75AB6C7FC1E
	D0376CBC553967E692C8B7667E4B7C373BE757C738DF5BFD3E1BEF3E25FBBE6C
	611D8BF6CD29D9C94EF615ECC69A08C4F65C0BFE78E7D5016ABF05B8F687EE79
	40F77A707B5C99B5CC5A66ED7FB386AB6364D1B06CC77FD0C25B3DD94FB6A861
	017D4A6D240000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="27" length_in_bytes="428" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000007B0000
	00420803000000406C59280000002C744558744372656174696F6E2054696D65
	004373203135206E6F762E20323031322031333A30303A3037202B303130300B
	C7B3840000000774494D4507DC0B0F0C00232DE6DFA500000009704859730000
	0AF000000AF00142AC34980000000467414D410000B18F0BFC61050000001250
	4C54450000FF000000FF0000FFFFFFDEDEDEB5ADAD8E50424A0000000174524E
	530040E6D866000000CE4944415478DAEDD9D90E84300805D0D2D1FFFF6533AD
	7189A9039401978B2FBE98934B6B31319167A5B5BEF71F7699DA24B5C7DEDAA4
	F6B76956E53D2FCF07AD77B52D7A0E3BC24EB061C37EAA5D0E772EBCB5D5FCEE
	5423B64DABAD1FA6BB8E33EDC3301C95D732BE4BF4A8DC825962BCDE357DCC3E
	AF5F3131F66BCF16D84C7B3E57CC6CF907FEDF73D38FCEC3862DB6D9DBDB2737
	9D350236EC3BDA27AFD37572FBCCB166EE9C8701366CAD2D99630EB99B051B36
	6CD8CFB46DFE8F69EC8ED4DDB9DF69E76CB9DE92478DED093AC56A2DF232BB64
	0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="28" length_in_bytes="481" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000007B0000
	00420803000000406C59280000002C744558744372656174696F6E2054696D65
	004373203135206E6F762E20323031322031333A30313A3438202B3031303096
	07A6A90000000774494D4507DC0B0F0C020F2D08D1C400000009704859730000
	0AF000000AF00142AC34980000000467414D410000B18F0BFC61050000001250
	4C54450000FF000000FF0000FFFFFFDEDEDEB5ADAD8E50424A0000000174524E
	530040E6D866000001034944415478DAED96D10EC2200C45298EFFFF65B3B131
	A691D0DB4237D32ECA5EF478E8AD2CD0DC0A47AD77AFAE526713879D74AA58DB
	B1797BAEC5A6DDF951DE4639CFEC44E51D5B25ECFC45947F02F00A7571D9C51C
	7317B1B3774A47F898AB847D5A4FF72E71B7E9F7B98A728E7B43BD5E578D7E1B
	78FB7CDBCDB7FC2C91E61CA83BB0B72DE867D365C6407C758212874D55D650F5
	6AC719ECAFD824E8DA1FD736752B6FDE738B66BFB3BB4DCEF3ACF7B23F7A2D64
	F3E67B041BFB6B1CEA4D1DDD77B6B3596C4EBA2778FF7276B6B31FCB6ECDD29D
	BC279C634DEF1897C5D9CE46D8DC736CB077B39CED6C673BFB3FD97089D9B0B5
	82B71D3B46AD3DE77E5891FD0602C767C985CFD9E30000000049454E44AE4260
	82
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="29" length_in_bytes="463" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000007B0000
	00420803000000406C59280000002C744558744372656174696F6E2054696D65
	004373203135206E6F762E20323031322031333A30333A3139202B303130307C
	6573440000000774494D4507DC0B0F0C032E787AF0DB00000009704859730000
	0AF000000AF00142AC34980000000467414D410000B18F0BFC61050000001250
	4C54450000FF000000FF0000FFFFFFDEDEDEB5ADAD8E50424A0000000174524E
	530040E6D866000000F14944415478DAED99DB1283200C4449C5FFFFE54A8B96
	078B09B9D592759C3C1E364BC4D1047D3D3681A4D221484B5F7A6C40B0735E25
	F571EDC086D785EB79CE7E7917F67BC9B5F0EA181B56894A66435DB5C04DF72D
	E3B9D4D408D97391AC4BA5B31D7DABE48DEEB9C23EA7B0A5E7FB06BE5DF3FE81
	F9163D4B88BEF75DC3102B6F6BF69E991BBB36DE3CEFC637D33B7BBE4D7BDEEC
	7373F6F16898CBB767DEA7E2B3C72755CD375CF4630976B0838D631306DAC0F7
	37CBC10EF67DD957B3D4D2F4CFD0AEEFE65DC2893D860DF6E46CE239A6ECBBAB
	60073BD8FFCEB6F9C675C666B866FB9E93CDFC273D788E1549B29FCF82689E26
	37E6360000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="30" length_in_bytes="438" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000007B0000
	00420803000000406C59280000002C744558744372656174696F6E2054696D65
	004373203135206E6F762E20323031322031333A30353A3230202B303130306A
	6C41330000000774494D4507DC0B0F0C052A294D934400000009704859730000
	0AF000000AF00142AC34980000000467414D410000B18F0BFC61050000001250
	4C54450000FF000000FF0000FFFFFFDEDEDEB5ADAD8E50424A0000000174524E
	530040E6D866000000D84944415478DAED97C10A84300C444DD5FFFF65B7E8C1
	16AC26991D7761025A3DD8C798574A2723D774AAF979BDCB9ED74FE56E617692
	5B6F71761E9E60A7E11976162ED7E49A5C936B63D7C8FB5813617FAD0F9E11E3
	9A1D93FA468C6BB627715E18D7CC9DB98E20D7DCBDAE23C8356EEECE356EBF5B
	D7B89E37AE71D777E71A3977EB1AB3DFBD6B4CCFC167A2D0046BBC1EE4B6DBBE
	8B2DB693EDD19B90FB2AB3D862FF2D7BB0967E2A37611F1BE52E6559C4163BC4
	76EE63DFCE3D2AB1C5165B6CB1D16CD0D93FC04EA44EE77E8F5D0AEC9F3B3F45
	B23762DB68E961EAEFDA0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="31" length_in_bytes="509" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000007B0000
	00420803000000406C59280000002C744558744372656174696F6E2054696D65
	004373203135206E6F762E20323031322031333A30343A3239202B3031303010
	366FDE0000000774494D4507DC0B0F0C0430CD345B7F00000009704859730000
	0AF000000AF00142AC34980000000467414D410000B18F0BFC61050000001550
	4C54450000FF000000FF0000FFFFFFDEDEDEB5ADADD6D6D61ABEF10300000001
	74524E530040E6D8660000011C4944415478DAED998B0E83200C450564FFFFC9
	53218618647D5C6024BDC9EC8C8FB3B6B74AB2CD51E56F912FA9692B14A89ACB
	FE64458D9664CFACB9279FFD2A631B9BC19EE9F3E30ED7A8BA28886A767E4E48
	E2DA79BB9C05FF03A8B928E73322FA2DED79C9560D4C9F19738D0A1C77B8BFF5
	F0799B9D0F1FB187CF196CB8CFA9EC1E3EFFC1BE8E9F6198CF2B6C74DE6F39D7
	D8E87E53D821F51CEE732E1B39DF7F9F77DA9BDA6F95CF1BB344AAB966BE3979
	973F0E9137B3E6DEEFFBACF9AEB087F9BCC61E35DF99DDEDFDCD64CBFBCD7C8F
	3DD963D6A949895DACD7C0F34D60775DA7B6D931863307C906C016C3116C295C
	CD16571CC096B71BD16FF39A79CDBC665E33AF99D7CC6BAB796DDE3A356AB42C
	1BF87F28F35224FB0B936A5EEDF4175B0D0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="32" length_in_bytes="471" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000007B0000
	00420803000000406C59280000002C744558744372656174696F6E2054696D65
	004373203135206E6F762E20323031322031313A35323A3430202B303130305F
	D44AC40000000774494D4507DC0B0F0A3502C73371FF00000009704859730000
	0AF000000AF00142AC34980000000467414D410000B18F0BFC61050000001250
	4C54450000FF000000FF0000FFFFFFDEDEDEB5ADAD8E50424A0000000174524E
	530040E6D866000000F94944415478DAED99CB0E83300C044943FEFF978B3854
	2915F123BB4E91BC076E687032800D5BB1E575C478CA77B62ED596B5EC7D6F33
	79307BE59A97725C7F6DBE0382ED854FB3BD4523D8EE1547B0FDF0742D5D4BD7
	D2B5742D5D4BD7FAC3CA7EED344015BC6B81EC9F6D8CACFB0A0F5DF3AB6BA1FB
	FD74D75C4315D7B532A89DED9AC0A6BA26B199AE896CE2736DCC06B966D29BEF
	DA5DCD1D9BE69A86CD724D66F3BEF5A8EA26F58A329BD72B2AEAC6F48A837BC9
	E0396C2EB9657FE2DF6E692E19D5CD9E4B64F61AD7D8738966CDC35DABE019D8
	F81ECB19F86F6660986B1A767E6F49D7625CE3F56B12BBCDE4B16CE03F68E3A9
	48F61B8B4C6683807E82720000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="33" length_in_bytes="459" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000007B0000
	00420803000000406C59280000002C744558744372656174696F6E2054696D65
	004373203135206E6F762E20323031322031333A30363A3036202B30313030A0
	AEC8770000000774494D4507DC0B0F0C06220CBB48B500000009704859730000
	0AF000000AF00142AC34980000000467414D410000B18F0BFC61050000001250
	4C54450000FFFFFFFF000000FF0000DEDEDEB5ADAD1201F2840000000174524E
	530040E6D866000000ED4944415478DAED97DB0E83201044B9E8FFFF7241B4D1
	3425CECE166A32AB5C5EE464D80124A4C1114E11EFC75C765C4B7095994D726B
	6567F370824DC319360B97D7E43579ED095E1B7C965C24B4F4D70ED2FA782DED
	8362AD8FD752530216A77F0793F690B6A7BE20FB230370CE77C99BEBB0397FD3
	6BDFA6FB401738C62E55EBD642E51B9EF38B7ACEE726F6213D72EBFB69BAE7E5
	7BA2CF67AE6F8F3BD1695F330DB0DAE3C67E9EBAFAC516DBC046EC3D40F737CD
	628BFD5876672DFD95EE01E7584F77CECB22B6D82636788EFD5A772FC4165B6C
	B1C5F66633777F8E4DA8A675CF63E7EC37E7D8A79EEC17F0A7549C918575C400
	00000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="34" length_in_bytes="487" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000007B0000
	004D0803000000B13AEBFD0000000774494D4507DD0B1C11011C1F95D82E0000
	00097048597300000AF000000AF00142AC34980000000C504C54450000FF0000
	00FFFFFFB5ADAD5450AB390000000174524E530040E6D8660000015749444154
	78DAED99EB1A8320088643EFFF9ED7412B5DA51C8436C54DEDCFDE904FF46113
	28DB743287365BB6777E365AC76633E07C361D2EC026C3B96C46B8F97E0FAD0D
	AD75A035563EDFDAF2A1B1BFA25F6FC1E5F55421C5FB80CF730A7B5B021B367D
	CDDD0E5FA6DAEC005F675DB1DDFE02066C1715D71B3B6ABD37BF05D894F320AE
	78239D43C1EF96FBFBC5ECA6F9FC99DDF61C6BCC0E5718A4BE1BDF5BEE7C3ED8
	8979542BDCD78AECE4EE498CF744669FE0FAEC03AECC4E6EFBDA7E9FE10CF6FD
	5E7A97D6F65D35B466AC35D1BA22496BD1FDD2D820AF41ED58DA63A5732CD51A
	8417A8FB72EB0E99D6AA7D5E462E3BCF6BB5B18672BCCBEC546BBA7E275AD38D
	77A635C9FD8DD39A656D0F59D915D51AB293D51A0E2EAA35CB3A32B2B22BAA35
	64279CD7ECB4E60DB586CC3423AFD9FE07CDFB251EFBB70C1E1FFFD786DF167E
	C3E554070DD7731574962D68EDE7FC168BF707C60E415BC3FBB6240000000049
	454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="35" length_in_bytes="499" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000007B0000
	004D0803000000B13AEBFD0000000774494D4507DD0B1C103529F3CE85CD0000
	00097048597300000AF000000AF00142AC34980000000C504C54450000FF0000
	00FFFFFFB5ADAD5450AB390000000174524E530040E6D8660000016349444154
	78DAED998D0E83200C842DBCFF3BCFFF8151A1BDD2CE49C9842566DFCE1E4571
	20E3189208ECF065C710C7901D603600C7D972B8025B0C47D940BA71DDDD6B62
	AF91A3D7A46CDC6B4B8973F2DA5C5D256CA89E2F0DCAB73434BCD6D9EF61E711
	590DF5390157019DDFE10B1FC712B6BCAEE16CA09EEFF06968CD5EE1F3E8996C
	C97AB0634313DD54D03DBB2CBC91BD9DF236DD0A6CAEBF3776239F5F694ED9AD
	6ACB8FB39BD5F332BBDD3A66C0BE5CBF8B6CADFB96EBB974C36E77BF76C9DE69
	E9439630DF8330DF31851BB3B3274B6BDD299CFB1C0A5FF304BEEADEE4977A85
	7C1FBD46B57DCA96AC63B9D768FD03751F749FE9E0B56ACD538FB273AFD5E79A
	CAF92EB373AFD9EACEBC669BEF83D734E737CF6B9EFBC8CC9D5D55AF310FBA5E
	E3C155BDE6F9CE82B9B3ABEA35E641B9AEF9792D3A7A8D59697A5DF37D078DFD
	12C67E56D0EDD7FF8DAEDB43379D0E6DD0743E36411FAA85B43D4CB75ABE3F30
	624141A25E772F0000000049454E44AE426082
	]]>
</GDLPict>

<Copyright SectVersion="1" SectionFlags="0" SubIdent="0">
	<Author>GRAPHISOFT</Author>
	<License>
		<Type>CC BY-ND</Type>
		<Version>3.0</Version>
	</License>
</Copyright>

</Symbol>
