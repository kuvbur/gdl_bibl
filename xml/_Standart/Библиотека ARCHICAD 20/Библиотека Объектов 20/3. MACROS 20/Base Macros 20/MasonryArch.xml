<?xml version="1.0" encoding="UTF-8"?>
<Symbol IsArchivable="false" IsPlaceable="false" MainGUID="099EFE2C-A175-4E91-9F66-44BEB9829E5A" MigrationValue="Normal" Owner="1196638531" Signature="1196644685" Version="43">
<Ancestry SectVersion="1" SectionFlags="0" SubIdent="0" Template="false">
	<MainGUID>F938E33A-329D-4A36-BE3E-85E126820996</MainGUID>
	<MainGUID>103E8D2C-8230-42E1-9597-46F84CCE28C0</MainGUID>
	<MainGUID>B2970E4C-8680-4061-8670-2F4B638F3953</MainGUID>
</Ancestry>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_3D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! Contact person: <NJ>

! ==============================================================================
! Masonry Arch macro
! ------------------------------------------------------------------------------
! Input parameters:
! Geometry ---------------------------------------------------------------------
!	A:						wallhole width (length) (Obsolete)
!	B:						wallhole height (length)
!	refWidth:				reference width in curved walls (length)
!	leftWidth:				wallhole's side distance from the origin at the left side (length)
!	rightWidth:				wallhole's side distance from the origin at the right side (length)
!	iWindowShape:			shape of the window (integer)
!							note: only the rectangular shape can be a Corner Window
!	openingArchHeight:		height of the arc (length)
! Masonry Arch parameters ------------------------------------------------------
!	gs_masonry_arch_int:			Type of the masonry arch. (integer)
!	gs_masonry_arch_structure:		Detail level of the masonry arch. (string)
!	gs_masonry_arch_structure_int:	Detail level of the masonry arch. (integer)
!	gs_masonry_arch_ovhg_left:		Masonry arch overhang - only for straight arches. (length)
!	gs_masonry_arch_ovhg_right:		Masonry arch overhang - only for straight arches. (length)
!	gs_masonry_arch_rise:			Rise of the Masonry Arch in case of straight windows
!	gs_masonry_arch_skewback_angle:	The angle made by the skewback from horizontal. (angle)
!	gs_masonry_arch_proj:			Projection of the masonry bricks. (length)
!	gs_masonry_arch_height:			Height of bricks in the arch. (length)
!	gs_masonry_arch_depth:			Depth of bricks in the arch. (length)
!	gs_masonry_arch_brick_thk:		Thickness of bricks in the arch. (length)
!	gs_masonry_arch_mort_thk:		Thickness of mortar. (length)
!	gs_masonry_arch_keystone_width:	Width of the Keystone at the bottom. (length)
!	gs_masonry_arch_keystone_osize:	Vertical overhang of the Keystone. (length)
!	gs_masonry_arch_keystone_proj:	Projection of the Keystone. (length)
!	gs_masonry_arch_fill:			Type of the fill on the Masonry Arch. (fill type)
!	gs_masonry_arch_pen_fg:			Fill pen on the Masonry Arch. (pen)
!	gs_masonry_arch_pen_bg:			Fill pen on the Masonry Arch. (pen)
!	gs_masonry_arch_pen:			3D contour pen of the Masonry Arch. (pen)
!	gs_masonry_arch_brick_mat:		Brick material (material)
!	gs_masonry_arch_mort_mat:		Mortar material (material)
!	gs_masonry_arch_keystone_mat:	Keystone material (material)
! Reveal -----------------------------------------------------------------------
!	gs_reveal_left:				Reveal size on the left (length)
!	gs_reveal_right:			Reveal size on the right (length)
!	gs_reveal_top:				Reveal size at the top (length)
! Corner Window Function -------------------------------------------------------
!	ac_cw_function:			Turn macro in Corner Window mode (0 / 1)
!	ac_corner_window:		Turn macro in Corner Window mode (0 / 1)
!	ac_corner_angle:		Angle between connected walls in case of Corner Window (angle)
!	ac_diff_con_wall_thk:	Indicates the equality thickness of the two connected walls. (0 / 1)
!	ac_con_wall_thk:		Thickness of the connected wall in case of Corner Window (length)
!	--- String Tables ---
!	stMasonryArchTypes:		String Table for gs_masonry_arch_int(text; array[])
!	stMasonryArchStructure:	String Table for gs_masonry_arch_structure (text; array[])
!
! Related Global Variables:
!	WIDO_REVEAL_ON
!	WIDO_REVEAL_SIDE
!	WIDO_FRAME_THICKNESS
!	WIDO_SILL
!	SYMB_MIRRORED
!	SYMB_ROTANGLE
!	WALL_THICKNESS
!	WALL_MAT_A
!	WALL_MAT_B
!	WALL_VIEW_PEN
!	WALL_SECT_PEN
! ==============================================================================

if gs_masonry_arch_fill = 0		then gs_masonry_arch_fill = SYMB_FILL
if gs_masonry_arch_pen_fg = 0	then gs_masonry_arch_pen_fg = SYMB_FILL_PEN
if gs_masonry_arch_pen_bg = 0	then gs_masonry_arch_pen_bg = SYMB_FBGD_PEN

gs_masonry_arch_keystone_width = min(gs_masonry_arch_keystone_width, leftWidth + rightWidth)
masonryArchMortInset = 0.01

if iWindowShape = SHAPE_ARCHED then
	gs_reveal_left	= gs_reveal_right
	gs_reveal_top	= gs_reveal_right
endif

if bEnableOnlyBullseyeArch then
	gs_reveal_left	= gs_reveal_right
	gs_reveal_top	= gs_reveal_right
	gs_reveal_bottom = gs_reveal_right
endif

if iWindowShape = SHAPE_ARCHED then
	resol nArchResolution
endif

! === Turn Plaster in 3D ===[

thkPlasterAtSillLeft	= thkPlasterAtSillLeft		* gs_turn_plaster_show_3D
thkPlasterAtSillRight	= thkPlasterAtSillRight		* gs_turn_plaster_show_3D
thkPlasterAtSillTop		= thkPlasterAtSillTop		* gs_turn_plaster_show_3D
thkPlasterAtSillBottom	= thkPlasterAtSillBottom	* gs_turn_plaster_show_3D

! ==============================================================================
! Double and Outside Splayed Reveal Cutting
! ==============================================================================

numCuts = 0

bSlantedOuterSide	= (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED)

if iWindowShape = SHAPE_ARCHED then
	if openingArchHeight < EPS then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		if openingArchHeight > (openingWidth / 2 - EPS) then
			openingArchHeight = openingWidth / 2
			arcR = openingArchHeight
			bHalfCircle = 1
		else
			arcR = (openingWidth / 2) / sin(2 * atn(openingArchHeight / (openingWidth / 2)))
			bHalfCircle = 0
		endif
	endif
endif


if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE | iRevealType = REVEAL_DOUBLE_SPLAYED then
	bNeedMiddleCut = 1
endif

if iRevealType = REVEAL_DOUBLE_SPLAYED then
	offsetInsideDepth	= WIDO_FRAME_THICKNESS
	offsetOutsideDepth	= 0
endif

if not(curvedWall) then

	! =============================================================================
	! Slanted Outer Side Cut - Straight Wall
	! =============================================================================
	if bSlantedOuterSide then
		if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then

			gs_slanted_left_angle		= gs_reveal_outerLeft_angle
			gs_slanted_right_angle		= gs_reveal_outerRight_angle
			gs_slanted_bottom_angle		= gs_reveal_outerBottom_angle
			gs_slanted_top_angle		= gs_reveal_outerTop_angle
			thkPlasterAtSlantedLeft		= thkPlasterAtSillLeft
			thkPlasterAtSlantedRight	= thkPlasterAtSillRight
			thkPlasterAtSlantedBottom	= thkPlasterAtSillBottom
			thkPlasterAtSlantedTop		= thkPlasterAtSillTop
			HalfInfiniteCut				= 1
			slantedDepth		= WIDO_SILL - gs_reveal_outer_jamb_depth
			slantedDepthBottom	= WIDO_SILL !- bHaveMountingFrame * (gs_mountingFrame_depth)
			slantedCutDepth		= slantedDepth
			offsetDepth		= offsetOutsideDepth
			offsetRight		= gs_reveal_right
			offsetLeft		= gs_reveal_left
			offsetTop		= gs_reveal_top
			offsetBott		= gs_reveal_bottom - (not(bHaveMountingFrame) * gs_reveal_outer_jamb_depth + bHaveMountingFrame * (gs_reveal_outer_jamb_depth - gs_mountingFrame_depth)) * tan(gs_reveal_outerBottom_angle)
			bWallInsetCut	= 0

			mulz -1
			addz WIDO_SILL
			gosub 1000	! Slanted Reveal cutting body
			del 2

		endif
	endif
else
	! =============================================================================
	! Slanted Outer Side Cut - Curved Left Wall
	! =============================================================================

	if bSlantedOuterSide then
		if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then

			gs_slanted_left_angle		= gs_reveal_outerLeft_angle	 + alfaLeftOs  - alfaLeftJamb
			gs_slanted_right_angle		= gs_reveal_outerRight_angle + alfaRightOs - alfaRightJamb
			gs_slanted_bottom_angle		= gs_reveal_outerBottom_angle
			gs_slanted_top_angle		= gs_reveal_outerTop_angle
			thkPlasterAtSlantedLeft		= thkPlasterAtSillLeft
			thkPlasterAtSlantedRight	= thkPlasterAtSillRight
			thkPlasterAtSlantedBottom	= thkPlasterAtSillBottom
			thkPlasterAtSlantedTop		= thkPlasterAtSillTop
			thkPlasterAtSlanted			= 0
			HalfInfiniteCut				= 1
			slantedDepth		= WIDO_SILL - gs_reveal_outer_jamb_depth
			slantedDepthBottom	= WIDO_SILL - bHaveMountingFrame * (gs_mountingFrame_depth)
			slantedCutDepth		= slantedDepth
			offsetDepth		= offsetOutsideDepth
			offsetRight		= rightWidth - (abs(WOD) + gs_reveal_outer_jamb_depth) * tan(alfaRightOs - alfaRightJamb)
			offsetLeft		= leftWidth  - (abs(WOD) + gs_reveal_outer_jamb_depth) * tan(alfaLeftOs  - alfaLeftJamb)
			offsetTop		= gs_reveal_top
			offsetBott		= gs_reveal_bottom !- (not(bHaveMountingFrame) * gs_reveal_outer_jamb_depth + bHaveMountingFrame * (gs_reveal_outer_jamb_depth - gs_mountingFrame_depth)) * tan(gs_reveal_outerBottom_angle)
			bWallInsetCut	= 0

			mulz -1
			addz WIDO_SILL
			gosub 1000	! Slanted Reveal cutting body
			del 2
		endif
	endif
endif


! ==============================================================================
! Calculations for Corner Window
! ==============================================================================

if bRightCornerFunction & abs(rightCornerAngle) > EPS then
	gs_stack_right = 1
	rx = 1 / tan(rightCornerAngle / 2)

	if rightCornerAngle > 180 then
		rightCwDx = WIDO_FRAME_THICKNESS / tan(-rightCornerAngle / 2)
	else
		rightCwDx = 0
	endif

	rightCwDx2 = 0
	if abs(WALL_THICKNESS - rightConnWallThk) > EPS then
		rightCwDx2 = (WALL_THICKNESS - rightConnWallThk) / cos(rightCornerAngle - 90)
	endif
	bFitMode = (rightConnWallThk > WALL_THICKNESS + EPS)

!	if SYMB_MIRRORED exor WIDO_REVEAL_SIDE then
!		! --- Swap Left and Right Attributes
!		gs_tw_left_in		= gs_tw_right_in
!		gs_tw_left_out		= gs_tw_right_out
!		gs_sill_ovhg_left	= gs_sill_ovhg_right
!		gs_stack_left		= gs_stack_right
!		gs_left_oversize	= gs_right_oversize
!	endif

	gs_right_oversize = 0

	gs_reveal_right = 0
	corrright = gs_masonry_arch_proj * rx * (rightCornerAngle > 0) - gs_masonry_arch_depth *  rx * (rightCornerAngle < 0)
	gs_masonry_arch_ovhg_right = rightCwDx + (WIDO_FRAME_THICKNESS + WIDO_SILL) * rx  + corrright
endif

if bLeftCornerFunction & abs(leftCornerAngle) > EPS then
	gs_stack_left = 1
	lx = 1 / tan(leftCornerAngle / 2)

	if leftCornerAngle > 180 then
		leftCwDx = WIDO_FRAME_THICKNESS / tan(-leftCornerAngle / 2)
	else
		leftCwDx = 0
	endif

	leftCwDx2 = 0
	if abs(WALL_THICKNESS - leftConnWallThk) > EPS then
		leftCwDx2 = (WALL_THICKNESS - leftConnWallThk) / cos(leftCornerAngle - 90)
	endif
	bFitMode = (leftConnWallThk > WALL_THICKNESS + EPS)

	gs_left_oversize = 0
	gs_reveal_left = 0
	corrleft = gs_masonry_arch_proj * lx * (leftCornerAngle > 0) - gs_masonry_arch_depth * lx * (leftCornerAngle < 0)
	gs_masonry_arch_ovhg_left = leftCwDx + (WIDO_FRAME_THICKNESS + WIDO_SILL) * lx + corrleft
endif


if iWindowShape = SHAPE_RECTANGULAR then
	openingArchHeight = gs_masonry_arch_rise
endif

if gs_masonry_arch_int = MASONRY_SEGMENT_ARCH			& openingArchHeight < EPS then gs_masonry_arch_int = MASONRY_ARCH
if gs_masonry_arch_int = MASONRY_SEGMENT_ARCH_KEYSTONE	& openingArchHeight < EPS then gs_masonry_arch_int = MASONRY_JACK_ARCH_KEYSTONE

if WIDO_REVEAL_SIDE then
	addz WIDO_SILL - WALL_THICKNESS + WIDO_FRAME_THICKNESS    ! Flip
else
	addz -WIDO_SILL
endif

if WIDO_REVEAL_SIDE then
	mulz -1
	addz -WALL_THICKNESS
endif

if WIDO_REVEAL_SIDE then
	matRevealSide	= WALL_MAT_A
	matOppositeSide = WALL_MAT_B
else
	matRevealSide	= WALL_MAT_B
	matOppositeSide = WALL_MAT_A
endif

_nicheSurface	= matRevealSide
if bCustomMatNicheTop then _nicheSurface	= matNicheTop

! --- Cutplanes in case of corner windows ---

if bCornerWindow or bRightCornerFunction then
	addx rightWidth + gs_masonry_arch_ovhg_right - corrright
	roty rightCornerAngle /2

	pen gs_masonry_arch_pen
	material gs_masonry_arch_brick_mat

	cutplane 1, 1, 0, (rightCornerAngle < 0)

	del 2
endif

if bLeftCornerFunction then
	addx -leftWidth - gs_masonry_arch_ovhg_left + corrleft
	roty  -leftCornerAngle /2

	pen gs_masonry_arch_pen
	material gs_masonry_arch_brick_mat

	cutplane 1, 1, 0, (leftCornerAngle < 0)

	del 2
endif


! =============================================================================
! Curved Walls
! =============================================================================

if abs (WIDO_ORIG_DIST) < eps then
	bCurvedWall = 0
else
	bCurvedWall = 1
endif

! =============================================================================
! Reveal Points Indexes
! =============================================================================

idxFrameStartRevealLeft		= iRevealPointsIdx[3]
idxFrameStartRevealRight	= iRevealPointsIdx[13]



add 0, B - gs_reveal_top + gs_upper_oversize, -gs_masonry_arch_proj
if not(gs_AutomaticArchHeight) then
	addy gs_MasonryArch_height
endif


! =============================================================================
! Masonry Arch
! =============================================================================

if gs_masonry_arch_int = MASONRY_ARCH then

	pen WALL_VIEW_PEN
	material matRevealSide

	if bCurvedWall then
		addz WOD + WIDO_SILL + gs_masonry_arch_proj 		! moving origo to the center of curved wall

		if WOD > 0 then
			rrrOut = radSill + gs_masonry_arch_proj  + 1
			rrrIn  = rrrOut  - gs_masonry_arch_depth - 1 - gs_masonry_arch_rearHoleDepth
		else
			rrrOut = radSill - gs_masonry_arch_proj  - 1
			rrrIn  = rrrOut  + gs_masonry_arch_depth + 1 + gs_masonry_arch_rearHoleDepth
		endif

		leftlength = leftWallholeRevealPnts[idxFrameStartRevealLeft][1]
		rightlength = rightWallholeRevealPnts[idxFrameStartRevealRight][1]

		alfaLeft  = atn (leftlength  / (WOD))
		alfaRight = atn (rightlength / (WOD))
		alfaOverhangLeft =  360 * (gs_masonry_arch_ovhg_left  / (2 * pi * radSill))
		alfaOverhangRight = 360 * (gs_masonry_arch_ovhg_right / (2 * pi * radSill))

		xo = 0 : yo = 0 : ro = rrrIn
		x1 = 0 : y1 = 0
		x2 = radSill * sin (alfaLeft - signWallIsLeft * (not (gs_stack_left)) * alfaOverhangLeft)
		y2 = radSill * cos (alfaLeft - signWallIsLeft * (not (gs_stack_left)) * alfaOverhangLeft)

		gosub 300
		gosub 301

		plix = cx
		pliy = cy

		xo = 0 : yo = 0 : ro = rrrOut
		x1 = 0 : y1 = 0
		x2 = radSill * sin (alfaLeft - signWallIsLeft * (not (gs_stack_left)) * alfaOverhangLeft)
		y2 = radSill * cos (alfaLeft - signWallIsLeft * (not (gs_stack_left)) * alfaOverhangLeft)

		gosub 300
		gosub 301

		plox = cx
		ploy = cy

		xo = 0 : yo = 0 : ro = rrrIn
		x1 = 0 : y1 = 0
		x2 = radSill * sin (alfaRight + signWallIsLeft * (not (gs_stack_right)) * alfaOverhangRight)
		y2 = radSill * cos (alfaRight + signWallIsLeft * (not (gs_stack_right)) * alfaOverhangRight)

		gosub 300
		gosub 301

		prix = cx
		priy = cy

		xo = 0 : yo = 0 : ro = rrrOut
		x1 = 0 : y1 = 0
		x2 = radSill * sin (alfaRight + signWallIsLeft * (not (gs_stack_right)) * alfaOverhangRight)
		y2 = radSill * cos (alfaRight + signWallIsLeft * (not (gs_stack_right)) * alfaOverhangRight)

		gosub 300
		gosub 301

		prox = cx
		proy = cy

		rotx -90

		material gs_masonry_arch_brick_mat

		wallniche 6, 1, 2,
			0, 0, 1, gs_masonry_arch_height,
			plix, pliy, 15,
			0, 0, 915,
			prix, priy, 3015,
			prox, proy, 15,
			0, 0, 915,
			plox, ploy, 3015

! Control prism - visualize points
!		prism_ 6, gs_masonry_arch_height,
!			plix, pliy, 15,
!			0, 0, 915,
!			prix, priy, 3015,
!			prox, proy, 15,
!			0, 0, 915,
!			plox, ploy, 3015

		if WOD > 0 then
			rrrOut = radSill + gs_masonry_arch_proj  + 1
			rrrIn  = rrrOut  - gs_masonry_arch_depth - 1
		else
			rrrOut = radSill - gs_masonry_arch_proj  - 1
			rrrIn  = rrrOut  + gs_masonry_arch_depth + 1
		endif

		del 2
	else
		wallniche 4, 1, 2 + 16,
			0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,
			-leftWidth  + gs_reveal_left  - gs_masonry_arch_ovhg_left,	0, 31,
			 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right,	0, 31,
			 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right,	gs_masonry_arch_height, 31,
			-leftWidth  + gs_reveal_left  - gs_masonry_arch_ovhg_left,	gs_masonry_arch_height, 31
	endif

	if gs_NicheBelowArch & gs_MasonryArch_height > 0 then
		cornerx = 2.0 * bCornerWindow

		material _nicheSurface

		wallniche 4, 1, 2 + 16 + 256,
			0, 0, 1, min(gs_masonry_arch_depth, WIDO_SILL + gs_masonry_arch_proj),
			-leftWidth  + gs_reveal_left,				-gs_MasonryArch_height, 31, matRevealSide,
			 rightWidth - gs_reveal_right + cornerx,	-gs_MasonryArch_height, 31, matRevealSide,
			 rightWidth - gs_reveal_right + cornerx,	0, 31, matRevealSide,
			-leftWidth  + gs_reveal_left,				0, 31, matRevealSide
	endif


	pen gs_masonry_arch_pen
	sect_fill gs_masonry_arch_fill, gs_masonry_arch_pen_bg, gs_masonry_arch_pen_fg, WALL_SECT_PEN

	if iArchDetail = 1 then		! Stucco Arch

		material gs_masonry_arch_brick_mat

		if bCurvedWall = 1 then
			leftAngle  = (alfaLeft - signWallIsLeft * (not (gs_stack_left)) * alfaOverhangLeft)
			rightAngle = (alfaRight + signWallIsLeft * (not (gs_stack_right)) * alfaOverhangRight)
			masLength = (abs (leftAngle) + abs (rightAngle)) / 360 * 2 * rrrIn * pi

			addz WOD + WIDO_SILL + gs_masonry_arch_proj 		! moving origo to the center or curved wall
			rotx -90
			rotz -leftAngle
			addy signWallisLeft * rrrIn

			if wallIsLeft then muly -1

			bwall_  gs_masonry_arch_brick_mat, gs_masonry_arch_brick_mat, gs_masonry_arch_brick_mat,
					gs_masonry_arch_height, 0, masLength, masLength, 0, -signWallIsLeft * gs_masonry_arch_depth, rrrIn,
					15, 15, 15, 15, 0, 0

			txAngle = 90 : gosub 201

			del 3
			if wallIsLeft then del 1
		else
			prism 4, gs_masonry_arch_depth,
				-leftWidth  + gs_reveal_left  - gs_masonry_arch_ovhg_left,	0,
				 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right,	0,
				 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right,	gs_masonry_arch_height,
				-leftWidth  + gs_reveal_left  - gs_masonry_arch_ovhg_left,	gs_masonry_arch_height

			txAngle = 90: gosub 200
		endif
	endif

	if iArchDetail = 2 then		! Brick Arch
		if bCurvedWall then
			alfaBrick = 360 * gs_masonry_arch_brick_thk / (2 * (rrrIn + signWallisLeft * gs_masonry_arch_depth) * pi)
			alfaMortar = 360 * gs_masonry_arch_mort_thk / (2 * (rrrIn + signWallisLeft * (gs_masonry_arch_depth - masonryArchMortInset)) * pi)

			leftAngle  = (alfaLeft - signWallIsLeft * (not (gs_stack_left)) * alfaOverhangLeft) + signWallIsLeft * gs_stack_left * alfaBrick/2
			rightAngle = (alfaRight + signWallIsLeft * (not (gs_stack_right)) * alfaOverhangRight) - signWallIsLeft * gs_stack_right * alfaBrick/2
			mainAngle = (abs (leftAngle) + abs (rightAngle))
			numBricks = int ((abs (leftAngle) + abs (rightAngle)) / (alfaBrick + alfaMortar))

			alfaMortar = (mainAngle - numBricks * alfaBrick) / (numBricks - 1 + gs_stack_left + gs_stack_right)

			alfaStep = alfaBrick + alfaMortar

			addz WOD + WIDO_SILL + gs_masonry_arch_proj 		! moving origo to the center or curved wall
			rotx -90
			rotz -leftAngle

			if wallIsLeft then muly -1

			if gs_stack_left then
				rotz -alfaBrick / 2
				addy - rrrIn - signWallisLeft * gs_masonry_arch_depth
				bwall_  gs_masonry_arch_brick_mat, gs_masonry_arch_brick_mat, gs_masonry_arch_brick_mat,
						gs_masonry_arch_height, 0, gs_masonry_arch_brick_thk / 2, gs_masonry_arch_brick_thk / 2, 0,
						signWallIsLeft * gs_masonry_arch_depth, (rrrIn + signWallIsLeft * gs_masonry_arch_depth),
						15, 15, 15, 15, 0, 0
				addx -gs_masonry_arch_brick_thk / 2 		! correction of texture !
				txAngle = 90 : gosub 201
				del 3
				rotz alfaMortar
			endif

			for i = 1 to numBricks
				addy - rrrIn - signWallisLeft * gs_masonry_arch_depth
				bwall_  gs_masonry_arch_brick_mat, gs_masonry_arch_brick_mat, gs_masonry_arch_brick_mat,
						gs_masonry_arch_height, 0, gs_masonry_arch_brick_thk, gs_masonry_arch_brick_thk, 0,
						signWallIsLeft * gs_masonry_arch_depth, (rrrIn + signWallIsLeft * gs_masonry_arch_depth),
						15, 15, 15, 15, 0, 0
				txAngle = 90 : gosub 201
				del 1
				rotz alfastep
			next i

			if gs_stack_right then
				addy - rrrIn - signWallisLeft * gs_masonry_arch_depth
				bwall_  gs_masonry_arch_brick_mat, gs_masonry_arch_brick_mat, gs_masonry_arch_brick_mat,
						gs_masonry_arch_height, 0, gs_masonry_arch_brick_thk / 2, gs_masonry_arch_brick_thk / 2, 0,
						signWallIsLeft * gs_masonry_arch_depth, (rrrIn + signWallIsLeft * gs_masonry_arch_depth),
						15, 15, 15, 15, 0, 0
				txAngle = 90 : gosub 201
				del 1
			endif

			del numBricks

			if gs_stack_left then del 1

			for  i = 1 to numBricks - 1 + gs_stack_left + gs_stack_right
				mortarThk = (alfaMortar / 360) * (2 * (rrrIn + signWallIsLeft * (gs_masonry_arch_depth - masonryArchMortInset)) * pi)
				if not (gs_stack_left) then rotz +alfaBrick
				addy - rrrIn - signWallisLeft * (gs_masonry_arch_depth - masonryArchMortInset)
				bwall_  gs_masonry_arch_mort_mat, gs_masonry_arch_mort_mat, gs_masonry_arch_mort_mat,
						gs_masonry_arch_height, 0, mortarThk, mortarThk, 0,
						signWallIsLeft * (gs_masonry_arch_depth - masonryArchMortInset), rrrIn + signWallIsLeft * (gs_masonry_arch_depth - masonryArchMortInset),
						15, 15, 15, 15, 0, 0
				txAngle = 90 : gosub 201
				if not (gs_stack_left) then del 1
				del 1
				rotz alfastep

			next i
			del 3
			if wallIsLeft then del 1
		else
			masonryL  = leftWidth + rightWidth - gs_reveal_left - gs_reveal_right + gs_masonry_arch_ovhg_left + gs_masonry_arch_ovhg_right \
							- (gs_stack_left + gs_stack_right) * gs_masonry_arch_brick_thk / 2
			numBricks = int(masonryL / (gs_masonry_arch_brick_thk + gs_masonry_arch_mort_thk))
			mortarThk  = (masonryL - (numBricks * gs_masonry_arch_brick_thk)) / (numBricks - 1 + gs_stack_left + gs_stack_right)

			addx -leftWidth + gs_reveal_left - gs_masonry_arch_ovhg_left

			if gs_stack_left then
				material gs_masonry_arch_brick_mat
				block gs_masonry_arch_brick_thk / 2, gs_masonry_arch_height, gs_masonry_arch_depth
				addx -gs_masonry_arch_brick_thk / 2
				txAngle = 90 : gosub 200
				del 1
				addx  gs_masonry_arch_brick_thk / 2
				material gs_masonry_arch_mort_mat
				block mortarThk, gs_masonry_arch_height, gs_masonry_arch_depth - masonryArchMortInset
				addx mortarThk
			endif

			material gs_masonry_arch_brick_mat

			for i=1 to numBricks
				block gs_masonry_arch_brick_thk, gs_masonry_arch_height, gs_masonry_arch_depth

				txAngle = 90: gosub 200

				addx gs_masonry_arch_brick_thk + mortarThk
			next i

			if gs_stack_right then
				material gs_masonry_arch_mort_mat
				addx -mortarThk
				block mortarThk, gs_masonry_arch_height, gs_masonry_arch_depth - masonryArchMortInset
				del 1
				material gs_masonry_arch_brick_mat
				block gs_masonry_arch_brick_thk / 2, gs_masonry_arch_height, gs_masonry_arch_depth
				txAngle = 90 : gosub 200
			endif

			del numBricks + gs_stack_left * 2

			material gs_masonry_arch_mort_mat

			for i=1 to numBricks - 1
				add gs_masonry_arch_brick_thk + gs_stack_left * (gs_masonry_arch_brick_thk / 2 + mortarThk), 0, masonryArchMortInset
				block mortarThk, gs_masonry_arch_height, gs_masonry_arch_depth - masonryArchMortInset
				del 1
				addx gs_masonry_arch_brick_thk + mortarThk
			next i
			del numBricks - 1

			txAngle = 90: gosub 200

			del 1
		endif
	endif
endif


! =============================================================================
! Masonry Jack Arch
! =============================================================================

if gs_masonry_arch_int = MASONRY_JACK_ARCH then

	dx_right = gs_masonry_arch_height / tan(gs_masonry_arch_skewback_angle) * not (gs_stack_right)
	dx_left  = gs_masonry_arch_height / tan(gs_masonry_arch_skewback_angle) * not (gs_stack_left)

	pen WALL_VIEW_PEN
	material matRevealSide

	wallniche 4, 1, 2 + 16,
		0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,
		-leftWidth  + gs_reveal_left  - gs_masonry_arch_ovhg_left,			0, 31,
		 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right,			0, 31,
		 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right + dx_right,	gs_masonry_arch_height, 31,
		-leftWidth  + gs_reveal_left  - gs_masonry_arch_ovhg_left  - dx_left,	gs_masonry_arch_height, 31

	if gs_NicheBelowArch & gs_MasonryArch_height > 0 then
		cornerx = 2.0 * bCornerWindow

		material _nicheSurface

		wallniche 4, 1, 2 + 16 +256,
			0, 0, 1, min(gs_masonry_arch_depth, WIDO_SILL + gs_masonry_arch_proj),
			-leftWidth  + gs_reveal_left,				-gs_MasonryArch_height, 31, matRevealSide,
			 rightWidth - gs_reveal_right + cornerx,	-gs_MasonryArch_height, 31, matRevealSide,
			 rightWidth - gs_reveal_right + cornerx,	0, 31, matRevealSide,
			-leftWidth  + gs_reveal_left,				0, 31, matRevealSide
	endif


	pen gs_masonry_arch_pen
	sect_fill gs_masonry_arch_fill, gs_masonry_arch_pen_bg, gs_masonry_arch_pen_fg, WALL_SECT_PEN

	if iArchDetail = 1 then		! Stucco Arch

		material gs_masonry_arch_brick_mat

		prism 4, gs_masonry_arch_depth,
			-leftWidth  + gs_reveal_left  - gs_masonry_arch_ovhg_left,			0,
			 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right,			0,
			 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right + dx_right,	gs_masonry_arch_height,
			-leftWidth  + gs_reveal_left  - gs_masonry_arch_ovhg_left  - dx_left,	gs_masonry_arch_height

		txAngle = 90: gosub 200
	endif

	if iArchDetail = 2 then		! Brick Arch

		masonryL = leftWidth + rightWidth - gs_reveal_left - gs_reveal_right + gs_masonry_arch_ovhg_left + gs_masonry_arch_ovhg_right \
				- (gs_stack_left + gs_stack_right) * (gs_masonry_arch_brick_thk / 2 + gs_masonry_arch_mort_thk)
		topL = masonryL + dx_left + dx_right
		numBricks = max(1, int(topL / (gs_masonry_arch_brick_thk + gs_masonry_arch_mort_thk)))
		brickTopThk = (topL - (numBricks - 1) * gs_masonry_arch_mort_thk) / numBricks

		alpha_left = -gs_masonry_arch_skewback_angle
		alpha_right = -gs_masonry_arch_skewback_angle
		if gs_stack_left then alpha_left = -90
		if gs_stack_right then alpha_right = -90
		da = (180 + alpha_left + alpha_right) / numBricks
		alpha = alpha_left
		add -leftWidth + gs_reveal_left- gs_masonry_arch_ovhg_left - dx_left, gs_masonry_arch_height, 0

		if gs_stack_left then
			material gs_masonry_arch_brick_mat
			prism 4, gs_masonry_arch_depth,
				0,								 0,
				gs_masonry_arch_brick_thk/ 2, 	 0,
				gs_masonry_arch_brick_thk/ 2,	-gs_masonry_arch_height,
				0,								-gs_masonry_arch_height
			addx - gs_masonry_arch_brick_thk/ 2
			txAngle = -90 : gosub 200
			del 1
			addz masonryArchMortInset
			material gs_masonry_arch_mort_mat
			prism 4, gs_masonry_arch_depth - masonryArchMortInset,
				 gs_masonry_arch_brick_thk/ 2, 								0,
				 gs_masonry_arch_brick_thk/ 2 + gs_masonry_arch_mort_thk, 	0,
				 gs_masonry_arch_brick_thk/ 2 + gs_masonry_arch_mort_thk,	-gs_masonry_arch_height,
				 gs_masonry_arch_brick_thk/ 2,								-gs_masonry_arch_height
			del 1
			addx gs_masonry_arch_brick_thk/ 2 + gs_masonry_arch_mort_thk
		endif

		material gs_masonry_arch_brick_mat

		for i=1 to numBricks
			prism 4, gs_masonry_arch_depth,
				 0,															0,
				 brickTopThk, 												0,
				 brickTopThk - gs_masonry_arch_height / tan(alpha - da),	-gs_masonry_arch_height,
				-gs_masonry_arch_height / tan(alpha),						-gs_masonry_arch_height

			txAngle = alpha: gosub 200

			alpha = alpha - da
			addx brickTopThk + gs_masonry_arch_mort_thk
		next i

		if gs_stack_right then
			material gs_masonry_arch_mort_mat
			addz masonryArchMortInset
			prism 4, gs_masonry_arch_depth - masonryArchMortInset,
				0, 								0,
				0 - gs_masonry_arch_mort_thk, 	0,
				0 - gs_masonry_arch_mort_thk,	-gs_masonry_arch_height,
				0,								-gs_masonry_arch_height
			del 1
			material gs_masonry_arch_brick_mat
			prism 4, gs_masonry_arch_depth,
				0,								 0,
				gs_masonry_arch_brick_thk/ 2, 	 0,
				gs_masonry_arch_brick_thk/ 2,	-gs_masonry_arch_height,
				0,								-gs_masonry_arch_height
			txAngle = -90 : gosub 200
		endif


		del numBricks
		addz masonryArchMortInset

		material gs_masonry_arch_mort_mat

		alpha_left  = -gs_masonry_arch_skewback_angle
		alpha_right = -gs_masonry_arch_skewback_angle
		if gs_stack_left  then alpha_left  = -90
		if gs_stack_right then alpha_right = -90
		da = (180 + alpha_left + alpha_right) / numBricks
		alpha = alpha_left
		for i=1 to numBricks - 1
			prism 4, gs_masonry_arch_depth - masonryArchMortInset,
				 brickTopThk, 																		0,
				 brickTopThk + gs_masonry_arch_mort_thk, 											0,
				 brickTopThk + gs_masonry_arch_mort_thk - gs_masonry_arch_height / tan(alpha - da),	-gs_masonry_arch_height,
				 brickTopThk - gs_masonry_arch_height / tan(alpha - da),							-gs_masonry_arch_height

			alpha = alpha - da
			addx brickTopThk + gs_masonry_arch_mort_thk
		next i

		del numBricks + 1 + gs_stack_left

	endif
endif


! =============================================================================
! Masonry Jack Arch with Keystone
! =============================================================================

if gs_masonry_arch_int = MASONRY_JACK_ARCH_KEYSTONE then

	gs_masonry_arch_keystone_angle = gs_masonry_arch_skewback_angle
	dx = gs_masonry_arch_height / tan(gs_masonry_arch_skewback_angle)
	dx_left  = gs_masonry_arch_height / tan(gs_masonry_arch_skewback_angle) * not (gs_stack_left)
	dx_right = gs_masonry_arch_height / tan(gs_masonry_arch_skewback_angle) * not (gs_stack_right)

	if not (gs_stack_left) and not (gs_stack_right) then
		cx = (gs_reveal_left - gs_masonry_arch_ovhg_left - gs_reveal_right + gs_masonry_arch_ovhg_right) / 2	! Keystone center position
	else
		if gs_stack_left then
			cx = - leftWidth - gs_masonry_arch_ovhg_left
		else
			cx = rightWidth + gs_masonry_arch_ovhg_right
		endif
	endif

	ky  = gs_masonry_arch_height + gs_masonry_arch_keystone_osize
	kdx = ky / tan(gs_masonry_arch_keystone_angle)

	pen WALL_VIEW_PEN
	material matRevealSide

	wallniche 4, 1, 2 + 16,
		0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,
		-leftWidth  + gs_reveal_left  - gs_masonry_arch_ovhg_left,				0, 31,
		 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right,				0, 31,
		 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right + dx_right,	gs_masonry_arch_height, 31,
		-leftWidth  + gs_reveal_left  - gs_masonry_arch_ovhg_left  - dx_left,	gs_masonry_arch_height, 31

	if gs_NicheBelowArch & gs_MasonryArch_height > 0 then
		cornerx = 2.0 * bCornerWindow

		material _nicheSurface

		wallniche 4, 1, 2 + 16 +256,
			0, 0, 1, min(gs_masonry_arch_depth, WIDO_SILL + gs_masonry_arch_proj),
			-leftWidth  + gs_reveal_left,				-gs_MasonryArch_height, 31, matRevealSide,
			 rightWidth - gs_reveal_right + cornerx,	-gs_MasonryArch_height, 31, matRevealSide,
			 rightWidth - gs_reveal_right + cornerx,	0, 31, matRevealSide,
			-leftWidth  + gs_reveal_left,				0, 31, matRevealSide
	endif

	if gs_masonry_arch_keystone_osize > EPS then
		addx cx
		wallniche 4, 1, 2 + 16,
			0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,
			(-gs_masonry_arch_keystone_width/2) * not (gs_stack_left),			0,	31,
			(-gs_masonry_arch_keystone_width/2 - kdx) * not (gs_stack_left),	ky,	31,
			( gs_masonry_arch_keystone_width/2 + kdx) * not (gs_stack_right),	ky,	31,
			( gs_masonry_arch_keystone_width/2) * not (gs_stack_right),			0,	31
		del 1
	endif


	pen gs_masonry_arch_pen
	sect_fill gs_masonry_arch_fill, gs_masonry_arch_pen_bg, gs_masonry_arch_pen_fg, WALL_SECT_PEN

	addx cx
	gosub 100	! Keystone
	del 1

	if iArchDetail = 1 then		! Stucco Arch

		material gs_masonry_arch_brick_mat
		if not (gs_stack_left) then
			prism 4, gs_masonry_arch_depth,
				-leftWidth + gs_reveal_left  - gs_masonry_arch_ovhg_left,				0,
				-leftWidth + gs_reveal_left  - gs_masonry_arch_ovhg_left  - dx_left,	gs_masonry_arch_height,
				cx - gs_masonry_arch_keystone_width/2 - dx_left,						gs_masonry_arch_height,
				cx - gs_masonry_arch_keystone_width/2,									0

			txAngle = -gs_masonry_arch_keystone_angle: gosub 200
		endif

		if not (gs_stack_right) then
			prism 4, gs_masonry_arch_depth,
				 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right,				0,
				 rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right + dx_right,	gs_masonry_arch_height,
				 cx + gs_masonry_arch_keystone_width/2 + dx_right,						gs_masonry_arch_height,
				 cx + gs_masonry_arch_keystone_width/2,									0

			txAngle = gs_masonry_arch_keystone_angle: gosub 200
		endif

	else		! iArchDetail = 2 - Brick arch

		brickThk = gs_masonry_arch_brick_thk / sin(gs_masonry_arch_skewback_angle)

		masonryL  = (leftWidth + rightWidth - (gs_masonry_arch_keystone_width / (1 + (gs_stack_left or gs_stack_right)))  - gs_reveal_left - gs_reveal_right + gs_masonry_arch_ovhg_left + gs_masonry_arch_ovhg_right) / (2 - (gs_stack_left or gs_stack_right))
		numBricks = max(1, int(masonryL / (brickThk + gs_masonry_arch_mort_thk / sin(gs_masonry_arch_skewback_angle))))
		mortarThk  = (masonryL - (numBricks * brickThk)) / numBricks

		add -leftWidth + gs_reveal_left - gs_masonry_arch_ovhg_left - dx, gs_masonry_arch_height, 0

		material gs_masonry_arch_brick_mat
		if not (gs_stack_left) then
			for i=1 to numBricks
				prism 4, gs_masonry_arch_depth,
					0,				0,
					brickThk,		0,
					brickThk + dx,	-gs_masonry_arch_height,
					dx,				-gs_masonry_arch_height

				txAngle = -gs_masonry_arch_skewback_angle: gosub 200

				addx brickThk + mortarThk
			next i
			del numBricks
			addz masonryArchMortInset

			material gs_masonry_arch_mort_mat

			for i=1 to numBricks
				prism 4, gs_masonry_arch_depth - masonryArchMortInset,
					brickThk + mortarThk,		 0,
					brickThk + dx + mortarThk,	-gs_masonry_arch_height,
					dx + brickThk,				-gs_masonry_arch_height,
					brickThk,					 0
				addx brickThk + mortarThk

			next i

			del numBricks + 1
		endif
		del 1

		add rightWidth - gs_reveal_right + gs_masonry_arch_ovhg_right + dx, gs_masonry_arch_height, 0

		material gs_masonry_arch_brick_mat
		if not (gs_stack_right) then
			for i=1 to numBricks
				prism 4, gs_masonry_arch_depth,
					 0,				0,
					-brickThk,		0,
					-brickThk - dx,	-gs_masonry_arch_height,
					-dx,			-gs_masonry_arch_height

				txAngle = gs_masonry_arch_skewback_angle: gosub 200

				addx -brickThk - mortarThk
			next i
			del numBricks

			addz masonryArchMortInset

			material gs_masonry_arch_mort_mat

			for i=1 to numBricks
				prism 4, gs_masonry_arch_depth - masonryArchMortInset,
					-brickThk - mortarThk,		 0,
					-brickThk - dx - mortarThk,	-gs_masonry_arch_height,
					-dx - brickThk,				-gs_masonry_arch_height,
					-brickThk,					 0
				addx -brickThk - mortarThk

			next i
			del numBricks + 1
		endif

		del 1
	endif
endif


! =============================================================================
! Masonry Segmented Arch
! =============================================================================

if gs_masonry_arch_int = MASONRY_SEGMENT_ARCH then

	gs_masonry_arch_ovhg_left	= max(EPS, gs_masonry_arch_ovhg_left)	! #118029 workaround
	gs_masonry_arch_ovhg_right	= max(EPS, gs_masonry_arch_ovhg_right)

	masonrySpan = leftWidth + rightWidth - gs_reveal_left - gs_reveal_right + gs_masonry_arch_ovhg_left + gs_masonry_arch_ovhg_right
	nominalMasonrySpan = leftWidth + rightWidth + gs_masonry_arch_ovhg_left + gs_masonry_arch_ovhg_right
	Ri = (nominalMasonrySpan / 2) / sin(2 * atn(openingArchHeight / (nominalMasonrySpan / 2))) - gs_reveal_top		! Intrados radius
	cx = (gs_reveal_left - gs_masonry_arch_ovhg_left - gs_reveal_right + gs_masonry_arch_ovhg_right) / 2	! Keystone center position

	if Ri - openingArchHeight + gs_reveal_top > EPS then
		alpha = acs(masonrySpan/2 / Ri)
	else
		alpha = 0
	endif
	Re = Ri + gs_masonry_arch_height	! Extrados radius

	add cx, -Ri, 0

	if iWindowShape = SHAPE_RECTANGULAR then
		addy Ri - sqr(Ri^2 - (masonrySpan / 2)^2 )
	endif

	if iArchDetail = 1 then		! Stucco Arch

		px1 = Ri * cos(alpha)
		py1 = Ri * sin(alpha)
		px2 = Re * cos(alpha)
		py2 = Re * sin(alpha)

		pen WALL_VIEW_PEN
		material matRevealSide
		if iWindowShape = SHAPE_ARCHED then
			resol nArchResolution
		else
			toler 0.001 + (90 - alpha) / 225000	! range: 0.001 - 0.005
		endif

		if iWindowShape = SHAPE_RECTANGULAR | (iWindowShape = SHAPE_ARCHED & (abs(gs_MasonryArch_height)>EPS & not(gs_AutomaticArchHeight))) then
			wallniche 6, 1, 2 + 16,
				0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,
				 px1,	py1,	31,
				 px2,	py2,	95,
				 0,		0,		900,
				-px2,	py2,	3095,
				-px1,	py1,	95,
				 px1,	py1,	3095


			if gs_NicheBelowArch then
				alf_a = asn(px1 / Ri)
				alf_r = asn((px1 - gs_masonry_arch_ovhg_right) / Ri)

				aaa = (refwidth) - WIDO_RIGHT_JAMB - WIDO_LEFT_JAMB
				oha = aaa + gs_masonry_arch_ovhg_right + gs_masonry_arch_ovhg_left
				tdcR = oha/2 - gs_masonry_arch_ovhg_right - aaa/2
				tdcL = oha/2 - gs_masonry_arch_ovhg_left  - aaa/2

				if px1 < Ri then
					xxkR =  px1 - gs_masonry_arch_ovhg_right
					xxkL = -px1 + gs_masonry_arch_ovhg_left
				else
					xxkR =  px1 - Ri + tdcR + aaa/2
					xxkL = -px1 + Ri - tdcL - aaa/2
				endif

				material _nicheSurface

				wallniche 6, 1, 2 + 16 + 256,
					0, 0, 1, min(gs_masonry_arch_depth, WIDO_SILL + gs_masonry_arch_proj),

					xxkR, py1 - gs_MasonryArch_height - EPS, 31, matRevealSide,
					xxkL, py1 - gs_MasonryArch_height - EPS, 31, matRevealSide,
					xxkL, sqr(Ri*Ri-(xxkL)*(xxkL)) + gs_masonry_arch_height/2, 0, matRevealSide,
					0, 0, 900, matRevealSide,
					xxkR, sqr(Ri*Ri-(xxkR)*(xxkR)) + gs_masonry_arch_height/2, 3095, matRevealSide,
					xxkR, sqr(Ri*Ri-(xxkR)*(xxkR)), 31, matRevealSide
			endif
		else
			wallniche 5, 1, 2 + 16,
				0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,
				 px1,	py1,	31,
				 px2,	py2,	95,
				 0,		0,		900,
				-px2,	py2,	3095,
				-px1,	py1,	31
		endif

		pen gs_masonry_arch_pen
		sect_fill gs_masonry_arch_fill, gs_masonry_arch_pen_bg, gs_masonry_arch_pen_fg, WALL_SECT_PEN
		material gs_masonry_arch_brick_mat

		prism_ 7, gs_masonry_arch_depth,
			 px1,	py1,	15,
			 px2,	py2,	79,
			 0,		0,		900,
			-px2,	py2,	3079,
			-px2,	py2,	15,
			-px1,	py1,	79,
			 px1,	py1,	3079

		txAngle = 90: gosub 200
	endif

	if iArchDetail = 2 then		! Brick Arch
		masonryL = Re * (2 * (90 - alpha)) * PI / 180		! arch length of extrados

		numBricks = max(1, int(masonryL / (gs_masonry_arch_brick_thk + gs_masonry_arch_mort_thk)))
		mortarThk  = (masonryL - (numBricks * gs_masonry_arch_brick_thk)) / (numBricks - 1)

		ArcLengthExtradosToAngle = 180 / Re / PI

		brickAngle  = gs_masonry_arch_brick_thk * ArcLengthExtradosToAngle
		mortarAngle = mortarThk * ArcLengthExtradosToAngle


		! Wallhole ============================================================

		px1 = Ri * cos(alpha)
		py1 = Ri * sin(alpha)

		actAlpha = alpha
		for i=1 to numBricks
			put Re * cos(actAlpha),				 Re * sin(actAlpha),			  95,
				Re * cos(actAlpha + brickAngle), Re * sin(actAlpha + brickAngle), 95
			actAlpha = actAlpha + brickAngle + mortarAngle
		next i

		pen WALL_VIEW_PEN
		material matRevealSide

		if iWindowShape = SHAPE_RECTANGULAR | (iWindowShape = SHAPE_ARCHED & (abs(gs_MasonryArch_height)>EPS & not(gs_AutomaticArchHeight))) then
			for i=1 to numBricks
				put Ri * cos(actAlpha - mortarAngle),				Ri * sin(actAlpha - mortarAngle),				95,
					Ri * cos(actAlpha - brickAngle - mortarAngle),	Ri * sin(actAlpha - brickAngle - mortarAngle),	95
				actAlpha = actAlpha - brickAngle - mortarAngle
			next i

			wallniche nsp/3, 1, 2 + 16,
				0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,
				 get(nsp)

			if gs_NicheBelowArch then
				if iWindowShape = SHAPE_ARCHED then
					resol nArchResolution
				else
					toler 0.001 + (90 - alpha) / 225000	! range: 0.001 - 0.005
				endif

				alf_a=asn(px1 / Ri)
				alf_r=asn((px1 - gs_masonry_arch_ovhg_right) / Ri)

				aaa = (refwidth) - WIDO_RIGHT_JAMB - WIDO_LEFT_JAMB
				oha = aaa + gs_masonry_arch_ovhg_right + gs_masonry_arch_ovhg_left
				tdcR = oha/2 - gs_masonry_arch_ovhg_right - aaa/2
				tdcL = oha/2 - gs_masonry_arch_ovhg_left  - aaa/2

				if px1 < Ri then
					xxkR =  px1 - gs_masonry_arch_ovhg_right
					xxkL = -px1 + gs_masonry_arch_ovhg_left
				else
					xxkR =  px1 - Ri + tdcR + aaa/2
					xxkL = -px1 + Ri - tdcL - aaa/2
				endif

				material _nicheSurface

				wallniche 6, 1, 2 + 16 + 256,
					0, 0, 1, min(gs_masonry_arch_depth, WIDO_SILL + gs_masonry_arch_proj),

					xxkR, py1-gs_MasonryArch_height-eps, 31, matRevealSide,
					xxkL, py1-gs_MasonryArch_height-eps, 31, matRevealSide,
					xxkL, sqr(Ri*Ri-(xxkL)*(xxkL))+gs_masonry_arch_height/2, 0, matRevealSide,
					0, 0, 900, matRevealSide,
					xxkR, sqr(Ri*Ri-(xxkR)*(xxkR))+gs_masonry_arch_height/2, 3095, matRevealSide,
					xxkR, sqr(Ri*Ri-(xxkR)*(xxkR)), 31, matRevealSide
			endif
		else
			wallniche nsp/3 + 2, 1, 2 + 16,
				0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,
				 px1,	py1,	31,
				 get(nsp),
				-px1,	py1,	31

		endif

		! Bricks ==============================================================

		pen gs_masonry_arch_pen
		sect_fill gs_masonry_arch_fill, gs_masonry_arch_pen_bg, gs_masonry_arch_pen_fg, WALL_SECT_PEN

		rotz alpha - 90
		material gs_masonry_arch_brick_mat

		px1 = -Ri * sin(brickAngle)
		py1 =  Ri * cos(brickAngle)
		px2 = -Re * sin(brickAngle)
		py2 =  Re * cos(brickAngle)

		for i=1 to numBricks
			prism 4, gs_masonry_arch_depth,
				0,		Re,
				0,		Ri,
				px1,	py1,
				px2,	py2

			rotz brickAngle + mortarAngle

			txAngle = 90 - brickAngle/2: gosub 200
		next i

		del numBricks + 1

		! Mortar ==============================================================

		rotz alpha - 90 + brickAngle
		addz masonryArchMortInset

		px1 = -Ri * sin(mortarAngle)
		py1 =  Ri * cos(mortarAngle)
		px2 = -Re * sin(mortarAngle)
		py2 =  Re * cos(mortarAngle)

		material gs_masonry_arch_mort_mat

		for i=1 to numBricks - 1
			prism 4, gs_masonry_arch_depth - masonryArchMortInset,
				0,		Re,
				0,		Ri,
				px1,	py1,
				px2,	py2

			rotz brickAngle + mortarAngle

			txAngle = 90 - brickAngle/2: gosub 200
		next i

		del numBricks - 1

	endif

	del 1
endif


! =============================================================================
! Masonry Segmented Arch with Keystone
! =============================================================================

if gs_masonry_arch_int = MASONRY_SEGMENT_ARCH_KEYSTONE then

	gs_masonry_arch_ovhg_left	= max(EPS, gs_masonry_arch_ovhg_left)	! #118029 workaround
	gs_masonry_arch_ovhg_right	= max(EPS, gs_masonry_arch_ovhg_right)

	masonrySpan = leftWidth + rightWidth - gs_reveal_left - gs_reveal_right + gs_masonry_arch_ovhg_left + gs_masonry_arch_ovhg_right
	nominalMasonrySpan = leftWidth + rightWidth + gs_masonry_arch_ovhg_left + gs_masonry_arch_ovhg_right
	Ri = (nominalMasonrySpan / 2) / sin(2 * atn(openingArchHeight / (nominalMasonrySpan / 2))) - gs_reveal_top		! Intrados radius
	cx = (gs_reveal_left - gs_masonry_arch_ovhg_left - gs_reveal_right + gs_masonry_arch_ovhg_right) / 2	! Keystone center position

	if Ri - openingArchHeight + gs_reveal_top > EPS then
		alpha = asn(masonrySpan/2 / Ri)
	else
		alpha = 90
	endif
	Re = Ri + gs_masonry_arch_height	! Extrados radius

	gs_masonry_arch_keystone_angle = 90 - acs(gs_masonry_arch_keystone_width/2 / Ri)
	ky  = (gs_masonry_arch_height + gs_masonry_arch_keystone_osize) * cos(gs_masonry_arch_keystone_angle)
	kdx = ky / tan(90 - gs_masonry_arch_keystone_angle)
	cy = sqr(Ri^2 - (gs_masonry_arch_keystone_width/2)^2)

	add cx, -Ri, 0

	if iWindowShape = SHAPE_RECTANGULAR then
		addy Ri - sqr(Ri^2 - (masonrySpan / 2)^2 )
	endif

	! Keystone's wallhole
	if gs_masonry_arch_keystone_osize > EPS then
		addy cy

		pen WALL_VIEW_PEN
		material matRevealSide

		wallniche 4, 1, 2 + 16,
			0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,
			-gs_masonry_arch_keystone_width/2,			0,	31,
			-gs_masonry_arch_keystone_width/2 - kdx,	ky,	31,
			 gs_masonry_arch_keystone_width/2 + kdx,	ky,	31,
			 gs_masonry_arch_keystone_width/2,			0,	31

		del 1
	endif

	if iArchDetail = 1 then		! Stucco Arch
		px1 = Ri * sin(alpha)
		py1 = Ri * cos(alpha)
		px2 = Re * sin(alpha)
		py2 = Re * cos(alpha)
		px3 = Ri * sin(gs_masonry_arch_keystone_angle)
		py3 = Ri * cos(gs_masonry_arch_keystone_angle)
		px4 = Re * sin(gs_masonry_arch_keystone_angle)
		py4 = Re * cos(gs_masonry_arch_keystone_angle)

		pen WALL_VIEW_PEN
		material matRevealSide
		if iWindowShape = SHAPE_ARCHED then
			resol nArchResolution
		else
			toler 0.001 + alpha / 22500	! range: 0.001 - 0.005
		endif

		if iWindowShape = SHAPE_RECTANGULAR | (iWindowShape = SHAPE_ARCHED & (abs(gs_MasonryArch_height)>EPS & not(gs_AutomaticArchHeight))) then
			wallniche 10, 1, 2 + 16,
				0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,
				 px1,	py1,	31,
				 px2,	py2,	95,
				 0,		0,		900,
				 px4,	py4,	3095,
				-px4,	py4,	95,
				-px2,	py2,	3095,
				-px1,	py1,	31,
				-px3,	py3,	3095,
				 px3,	py3,	95,
				 px1,	py1,	3095

			if gs_NicheBelowArch then
				alf_a = asn(px1 / Ri)
				alf_r = asn((px1 - gs_masonry_arch_ovhg_right) / Ri)

				aaa = (refwidth) - WIDO_RIGHT_JAMB - WIDO_LEFT_JAMB
				oha = aaa + gs_masonry_arch_ovhg_right + gs_masonry_arch_ovhg_left
				tdcR = oha/2 - gs_masonry_arch_ovhg_right - aaa/2
				tdcL = oha/2 - gs_masonry_arch_ovhg_left  - aaa/2

				if px1 < Ri then
					xxkR =  px1 - gs_masonry_arch_ovhg_right
					xxkL = -px1 + gs_masonry_arch_ovhg_left
				else
					xxkR =  px1 - Ri + tdcR + aaa/2
					xxkL = -px1 + Ri - tdcL - aaa/2
				endif

				material _nicheSurface

				wallniche 6, 1, 2 + 16 + 256,
					0, 0, 1, min(gs_masonry_arch_depth, WIDO_SILL + gs_masonry_arch_proj),

					xxkR, py1-gs_MasonryArch_height-eps, 31, matRevealSide,
					xxkL, py1-gs_MasonryArch_height-eps, 31, matRevealSide,
					xxkL, sqr(Ri*Ri-(xxkL)*(xxkL))+gs_masonry_arch_height/2, 0, matRevealSide,
					0, 0, 900, matRevealSide,
					xxkR, sqr(Ri*Ri-(xxkR)*(xxkR))+gs_masonry_arch_height/2, 3095, matRevealSide,
					xxkR, sqr(Ri*Ri-(xxkR)*(xxkR)), 31, matRevealSide
			endif
		else
			wallniche 7, 1, 2 + 16,
				0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,
				 px1,	py1,	31,
				 px2,	py2,	95,
				 0,		0,		900,
				 px4,	py4,	3095,
				-px4,	py4,	95,
				-px2,	py2,	3095,
				-px1,	py1,	31
		endif

		pen gs_masonry_arch_pen
		sect_fill gs_masonry_arch_fill, gs_masonry_arch_pen_bg, gs_masonry_arch_pen_fg, WALL_SECT_PEN
		material gs_masonry_arch_brick_mat

		prism_ 7, gs_masonry_arch_depth,
			 px1,	py1,	15,
			 px2,	py2,	79,
			 0,		0,		900,
			 px4,	py4,	3079,
			 px4,	py4,	15,
			 px3,	py3,	79,
			 px1,	py1,	3079

		txAngle = 90 - alpha/2: gosub 200

		prism_ 7, gs_masonry_arch_depth,
			-px1,	py1,	15,
			-px2,	py2,	79,
			 0,		0,		900,
			-px4,	py4,	3079,
			-px4,	py4,	15,
			-px3,	py3,	79,
			-px1,	py1,	3079

		txAngle = 90 + alpha/2: gosub 200

		addy cy
		gosub 100	! Keystone
		del 1
	endif

	if iArchDetail = 2 then		! Brick Arch
		masonryL = Re * ((alpha - gs_masonry_arch_keystone_angle)) * PI / 180		! arch length of extrados

		numBricks = max(1, int(masonryL / (gs_masonry_arch_brick_thk + gs_masonry_arch_mort_thk)))
		mortarThk  = (masonryL - (numBricks * gs_masonry_arch_brick_thk)) / (numBricks - 0)

		ArcLengthExtradosToAngle = 180 / Re / PI

		brickAngle  = gs_masonry_arch_brick_thk * ArcLengthExtradosToAngle
		mortarAngle = mortarThk * ArcLengthExtradosToAngle


		! Wallhole ============================================================


		actAlpha = 90 - alpha
		for i=1 to numBricks
			put Re * cos(actAlpha),				 Re * sin(actAlpha),			  95,
				Re * cos(actAlpha + brickAngle), Re * sin(actAlpha + brickAngle), 95
			actAlpha = actAlpha + brickAngle + mortarAngle
		next i

		actAlpha = 90 + gs_masonry_arch_keystone_angle
		for i=1 to numBricks
			put Re * cos(actAlpha),				  Re * sin(actAlpha),				95,
				Re * cos(actAlpha + mortarAngle), Re * sin(actAlpha + mortarAngle), 95
			actAlpha = actAlpha + brickAngle + mortarAngle
		next i
		put Re * cos(actAlpha),				  Re * sin(actAlpha),				95


		pen WALL_VIEW_PEN
		material matRevealSide


		if iWindowShape = SHAPE_RECTANGULAR | (iWindowShape = SHAPE_ARCHED & (abs(gs_MasonryArch_height)>EPS & not(gs_AutomaticArchHeight))) then

			for i=1 to numBricks
				put Ri * cos(actAlpha),					Ri * sin(actAlpha),					95,
					Ri * cos(actAlpha - brickAngle),	Ri * sin(actAlpha - brickAngle),	95
				actAlpha = actAlpha - brickAngle - mortarAngle
			next i
			put Ri * cos(actAlpha),				  Ri * sin(actAlpha),				95

			actAlpha = 90 - gs_masonry_arch_keystone_angle
			for i=1 to numBricks
				put Ri * cos(actAlpha),				  Ri * sin(actAlpha),				95,
					Ri * cos(actAlpha - mortarAngle), Ri * sin(actAlpha - mortarAngle), 95
				actAlpha = actAlpha - brickAngle - mortarAngle
			next i
			put Ri * cos(actAlpha),				  Ri * sin(actAlpha),				95


			wallniche nsp/3, 1, 2 + 16,
				0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,
				 get(nsp)


			if gs_NicheBelowArch then
				if iWindowShape = SHAPE_ARCHED then
					resol nArchResolution
				else
					toler 0.001 + (90 - alpha) / 225000	! range: 0.001 - 0.005
				endif

				px1 = Ri * sin(alpha)
				py1 = Ri * cos(alpha)

				alf_a = asn(px1 / Ri)
				alf_r = asn((px1 - gs_masonry_arch_ovhg_right) / Ri)

				aaa = (refwidth) - WIDO_RIGHT_JAMB - WIDO_LEFT_JAMB
				oha = aaa + gs_masonry_arch_ovhg_right + gs_masonry_arch_ovhg_left
				tdcR = oha/2 - gs_masonry_arch_ovhg_right - aaa/2
				tdcL = oha/2 - gs_masonry_arch_ovhg_left  - aaa/2

				if px1 < Ri then
					xxkR =  px1 - gs_masonry_arch_ovhg_right
					xxkL = -px1 + gs_masonry_arch_ovhg_left
				else
					xxkR =  px1 - Ri + tdcR + aaa/2
					xxkL = -px1 + Ri - tdcL - aaa/2
				endif

				material _nicheSurface

				wallniche 6, 1, 2 + 16 + 256,
					0, 0, 1, min(gs_masonry_arch_depth, WIDO_SILL + gs_masonry_arch_proj),

					xxkR, py1-gs_MasonryArch_height-eps, 31, matRevealSide,
					xxkL, py1-gs_MasonryArch_height-eps, 31, matRevealSide,
					xxkL, sqr(Ri*Ri-(xxkL)*(xxkL))+gs_masonry_arch_height/2, 0, matRevealSide,
					0, 0, 900, matRevealSide,
					xxkR, sqr(Ri*Ri-(xxkR)*(xxkR))+gs_masonry_arch_height/2, 3095, matRevealSide,
					xxkR, sqr(Ri*Ri-(xxkR)*(xxkR)), 31, matRevealSide
			endif
		else

			px1 = Ri * sin(alpha)
			py1 = Ri * cos(alpha)

			wallniche nsp/3 + 2, 1, 2 + 16,
				0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,
				 px1,	py1,	31,
				 get(nsp),
				-px1,	py1,	31
		endif

		! Bricks ==============================================================

		pen gs_masonry_arch_pen
		sect_fill gs_masonry_arch_fill, gs_masonry_arch_pen_bg, gs_masonry_arch_pen_fg, WALL_SECT_PEN

		material gs_masonry_arch_brick_mat

		px1 = -Ri * sin(brickAngle)
		py1 =  Ri * cos(brickAngle)
		px2 = -Re * sin(brickAngle)
		py2 =  Re * cos(brickAngle)

		for j=1 to 2
			rotz -alpha

			for i=1 to numBricks
				prism 4, gs_masonry_arch_depth,
					0,		Re,
					0,		Ri,
					px1,	py1,
					px2,	py2

				rotz brickAngle + mortarAngle

				txAngle = 90 - brickAngle/2: gosub 200
			next i

			del numBricks + 1
			mulx -1
		next j
		del 2


		! Mortar ==============================================================

		px1 = -Ri * sin(mortarAngle)
		py1 =  Ri * cos(mortarAngle)
		px2 = -Re * sin(mortarAngle)
		py2 =  Re * cos(mortarAngle)

		material gs_masonry_arch_mort_mat

		for j=1 to 2
			rotz -alpha + brickAngle
			addz masonryArchMortInset

			for i=1 to numBricks
				prism 4, gs_masonry_arch_depth - masonryArchMortInset,
					0,		Re,
					0,		Ri,
					px1,	py1,
					px2,	py2

				rotz brickAngle + mortarAngle

				txAngle = 90 - brickAngle/2: gosub 200
			next i

			del numBricks + 2
			mulx -1
		next j

		del 2

		addy cy
		gosub 100	! Keystone
		del 1

	endif
endif



! =============================================================================
! Masonry Bullseye Arch
! =============================================================================

if gs_masonry_arch_int = MASONRY_BULLSEYE_ARCH then
	Ra = (leftWidth + rightWidth) / 2 - gs_reveal_right + gs_masonry_arch_height
	Rb = B / 2 - gs_reveal_top + gs_masonry_arch_height

	addy gs_reveal_top - B/2

	if iArchDetail = 1 then		! Stucco Arch

		pen WALL_VIEW_PEN
		material matRevealSide

		mulx Ra/Rb
		wallniche 2, 1, 2 + 16,
			0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,
			0,0, 995,
			Rb, 360, 4095
		del 1

		mulx (Ra - gs_masonry_arch_height) / (Rb - gs_masonry_arch_height)
		cutpolya 2,1,0,
			0,0, 979,
			Rb - gs_masonry_arch_height, 360, 4079
		del 1

		pen gs_masonry_arch_pen
		sect_fill gs_masonry_arch_fill, gs_masonry_arch_pen_bg, gs_masonry_arch_pen_fg, WALL_SECT_PEN
		material gs_masonry_arch_brick_mat

		mulx Ra/Rb
		prism_ 2, gs_masonry_arch_depth,
			0,0, 979,
			Rb, 360, 4079

		txAngle = 90 - alpha/2: gosub 200
		del 1

		cutend
	endif

	if iArchDetail = 2 then		! Brick Arch
		masonryL = PI * (3 * (Ra + Rb) - sqr((Ra + 3 * Rb) * (3 * Ra + Rb)))		! arch length of extrados (approximation: Ramanujan II)

		numBricks = max(1, int(masonryL / (gs_masonry_arch_brick_thk + gs_masonry_arch_mort_thk)))
		mortarThk  = (masonryL - (numBricks * gs_masonry_arch_brick_thk)) / (numBricks - 0)

		Rc = sqr(abs(Ra^2 - Rb^2))
		if Ra > Rb then
			Rca = Rc
			Rcb = 0
		else
			Rca = 0
			Rcb = Rc
		endif

		ArcLengthExtradosToAngle = 180 / ((Ra + Rb) / 2) / PI
		brickAngle  = gs_masonry_arch_brick_thk * ArcLengthExtradosToAngle
		mortarAngle = 360 / numBricks - brickAngle


		! Wallhole ============================================================

		if Ra > Rb then
			actAlpha = 90-brickAngle/2
		else
			actAlpha = -brickAngle/2
		endif

		for i=1 to numBricks
			put	Rb * sin(actAlpha),	-Rb * cos(actAlpha),								95,
				Rb * sin(actAlpha + brickAngle),	-Rb * cos(actAlpha + brickAngle),	95

			actAlpha = actAlpha + brickAngle + mortarAngle
		next i


		pen WALL_VIEW_PEN
		material matRevealSide

		mulx Ra/Rb

		wallniche nsp/3, 1, 2 + 16,
			0, 0, 1, gs_masonry_arch_depth + gs_masonry_arch_rearHoleDepth,
			 get(nsp)
		del 1


		! Cutpoly =============================================================

		mulx (Ra - gs_masonry_arch_height) / (Rb - gs_masonry_arch_height)
		cutpolya 2,1,0,
			0,0, 979,
			Rb - gs_masonry_arch_height, 360, 4079
		del 1

		! Bricks ==============================================================

		pen gs_masonry_arch_pen
		sect_fill gs_masonry_arch_fill, gs_masonry_arch_pen_bg, gs_masonry_arch_pen_fg, WALL_SECT_PEN

		material gs_masonry_arch_brick_mat

		px1 = -Rb * sin(brickAngle)
		py1 =  Rb * cos(brickAngle)


		mulx Ra/Rb

		if Ra > Rb then
			actAlpha = 90-brickAngle/2
		else
			actAlpha = -brickAngle/2
		endif

		for i=1 to numBricks

			RefAlpha = actAlpha + brickAngle/2
			t = sin(RefAlpha) / 2
			cx = t * Rca / 2
			t = -cos(RefAlpha) / 2
			cy = t * Rcb / 2

			prism 3, gs_masonry_arch_depth,
				cx,		cy,
				Rb * sin(actAlpha),	-Rb * cos(actAlpha),
				Rb * sin(actAlpha + brickAngle),	-Rb * cos(actAlpha + brickAngle)

			actAlpha = actAlpha + brickAngle + mortarAngle

			txAngle = 90 + RefAlpha: gosub 200
		next i

		del 1


		! Mortar ==============================================================

		material gs_masonry_arch_mort_mat

		mulx Ra/Rb

		if Ra > Rb then
			actAlpha = 90-brickAngle/2
		else
			actAlpha = -brickAngle/2
		endif

		for i=1 to numBricks

			RefAlpha = actAlpha + brickAngle/2
			t = sin(RefAlpha) / 2
			cx = t * Rca / 2
			t = -cos(RefAlpha) / 2
			cy = t * Rcb / 2

			t = sin(RefAlpha + brickAngle + mortarAngle) / 2
			cx2 = t * Rca / 2
			t = -cos(RefAlpha + brickAngle + mortarAngle) / 2
			cy2 = t * Rcb / 2

			prism 4, gs_masonry_arch_depth,
				cx,		cy,
				Rb * sin(actAlpha + brickAngle),	-Rb * cos(actAlpha + brickAngle),
				Rb * sin(actAlpha + brickAngle + mortarAngle),	-Rb * cos(actAlpha + brickAngle + mortarAngle),
				cx2,	cy2

			actAlpha = actAlpha + brickAngle + mortarAngle

			txAngle = 90 - brickAngle/2: gosub 200
		next i

		del 1

		cutend

	endif

	del 1
endif

! ==============================================================================


if not(gs_AutomaticArchHeight) then
	del 1
endif

if bCornerWindow or bRightCornerFunction then cutend
if bLeftCornerFunction then cutend

for i = 1 to numCuts
	cutend
next i

end



100:
! ==============================================================================
! Keystone
! ------------------------------------------------------------------------------
! Input Parameters:
!	ky:								height of keystone
!	kdy:							width extent of the keystone's top edge
!	gs_masonry_arch_depth:			depth of brick arch
!	gs_masonry_arch_keystone_proj:	projection of keystone
!	gs_masonry_arch_keystone_width	width of keystone at the bottom
!	gs_masonry_arch_keystone_mat:	keystone material
! ==============================================================================

	if gs_masonry_arch_keystone_width < EPS & kdx < EPS then return

	material gs_masonry_arch_keystone_mat

	addz -gs_masonry_arch_keystone_proj

	prism 4, gs_masonry_arch_depth + gs_masonry_arch_keystone_proj,
		(-gs_masonry_arch_keystone_width/2) * (not (gs_stack_left) or (gs_masonry_arch_int = MASONRY_SEGMENT_ARCH_KEYSTONE)),			0,
		(-gs_masonry_arch_keystone_width/2 - kdx) * (not (gs_stack_left) or (gs_masonry_arch_int = MASONRY_SEGMENT_ARCH_KEYSTONE)),	ky,
		 (gs_masonry_arch_keystone_width/2 + kdx) * (not (gs_stack_right) or (gs_masonry_arch_int = MASONRY_SEGMENT_ARCH_KEYSTONE)),	ky,
		 (gs_masonry_arch_keystone_width/2) * (not (gs_stack_right) or (gs_masonry_arch_int = MASONRY_SEGMENT_ARCH_KEYSTONE)),			0

	txAngle = 0 : gosub 200
	del 1
return


200:
! ==============================================================================
! Texture alignment
! ------------------------------------------------------------------------------
! Input Parameters:
!	txAngle:			rotation angle of texture
! ==============================================================================
	base

	rotz txAngle

	vert 0, 0, 0
	vert 1, 0, 0
	vert 0, 1, 0
	vert 0, 0, 1
	coor 2 + 256, -1, -2, -3, -4
	body 1

	del 1
return

201:
! ==============================================================================
! Texture alignment
! ------------------------------------------------------------------------------
! Input Parameters:
!	txAngle:			rotation angle of texture
! ==============================================================================
	base

	roty txAngle

	vert 0, 0, 0
	vert 1, 0, 0
	vert 0, 1, 0
	vert 0, 0, 1
	coor 2 + 256, -1, -2, -3, -4
	body 1

	del 1
return

300:

! ==============================================================================
! Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	xo,yo,ro:			circle
!	x1,y1, x2,y2		line
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = one intersection point (tangential line)
!						2 = two intersection points
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
! ==============================================================================

	tempX1 = x1 - xo: tempY1 = y1 - yo
	tempX2 = x2 - xo: tempY2 = y2 - yo

	if abs(tempX2 - tempX1) < EPS then
		if abs(ro - abs(tempX1)) < EPS then
			state = 1
			xa = tempX1
			ya = 0
			xb = tempX1
			yb = 0
		else
			if abs(ro) - abs(tempX1) < 0 then
				state = 0: xa = 0: ya = 0: xb = 0: yb = 0
			else
				state = 2
				xa = tempX1
				ya = sqr(ro^2 - tempX1^2)
				xb = tempX1
				yb = -sqr(ro^2 - tempX1^2)
			endif
		endif
	else
		kf = (tempY2 - tempY1) / (tempX2 - tempX1)
		ad = 1 + kf^2
		bd = 2 * tempY1 * kf - 2 * tempX1 * kf^2
		cd = tempY1^2 - 2 * tempX1 * tempY1 * kf + tempX1^2 * kf^2 - ro^2

		if bd^2 - 4 * ad * cd < 0 then
			state = 0: xa = 0: ya = 0: xb = 0: yb = 0
		else
			xa = (-bd + sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			ya = tempY1 + (xa - tempX1) * kf
			xb = (-bd - sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			yb = tempY1 + (xb - tempX1) * kf

			if abs(xa - xb) < EPS then state = 1 else state = 2
		endif
	endif

	if state = 2 then
		da = sqr((tempX1 - xa)^2 + (tempY1 - ya)^2)
		db = sqr((tempX1 - xb)^2 + (tempY1 - yb)^2)

		if db < da then
			xxo = xa: yyo = ya
			xa = xb:  ya = yb
			xb = xxo: yb = yyo
		endif
	endif

	xa = xa + xo: ya = ya + yo
	xb = xb + xo: yb = yb + yo
return


301:
! ==============================================================================
! Select good intersection point after Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	state:				intersection status
!	wallIsLeft:
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
!
! Returned variables:
!	cx, cy:				selected intersection point
! ==============================================================================

	cx = 0
	cy = 0
	if state = 1 then
		cx = xa
		cy = ya
	endif
	if state = 2 then
		if wallIsLeft then
			if ya < yb then
				cx = xb
				cy = yb
			else
				cx = xa
				cy = ya
			endif
		else
			if ya > yb then
				cx = xb
				cy = yb
			else
				cx = xa
				cy = ya
			endif
		endif
	endif
return



1000:
! ==============================================================================
! Slanted Reveal cutting body
! ==============================================================================

! Similar as in WallHoleCut macro

	if gs_stack_top		then gs_slanted_top_angle	 = 0
	if gs_stack_bottom	then gs_slanted_bottom_angle = 0

	! 3D turn plaster offsets
	if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED then
		offsetSlantedLeft	= offsetLeft  + not(bLeftCornerFunction  | gs_stack_left)  * (thkPlasterAtSlantedLeft  / cos(gs_slanted_left_angle))
		offsetSlantedRight	= offsetRight + not(bRightCornerFunction | gs_stack_right) * (thkPlasterAtSlantedRight / cos(gs_slanted_right_angle))
		offsetSlantedBott	= offsetBott  + not(gs_stack_bottom) * (thkPlasterAtSlantedBottom / cos(gs_slanted_bottom_angle))
		offsetSlantedTop	= offsetTop   + not(gs_stack_top)    * (thkPlasterAtSlantedTop    / cos(gs_slanted_top_angle))
	else
		offsetSlantedLeft	= offsetLeft  - not(bLeftCornerFunction  | gs_stack_left)  * (thkPlasterAtSlanted * tan(gs_slanted_left_angle)  - thkPlasterAtSlantedLeft  / cos(gs_slanted_left_angle))
		offsetSlantedRight	= offsetRight - not(bRightCornerFunction | gs_stack_right) * (thkPlasterAtSlanted * tan(gs_slanted_right_angle) - thkPlasterAtSlantedRight / cos(gs_slanted_right_angle))
		offsetSlantedBott	= offsetBott  - not(gs_stack_bottom) * (thkPlasterAtSlanted * tan(gs_slanted_bottom_angle) - thkPlasterAtSlantedBottom / cos(gs_slanted_bottom_angle))
		offsetSlantedTop	= offsetTop   - not(gs_stack_top)    * (thkPlasterAtSlanted * tan(gs_slanted_top_angle)    - thkPlasterAtSlantedTop    / cos(gs_slanted_top_angle))
	endif


	if abs(SYMB_POS_Y) < EPS then
		offsetSlantedBott = offsetSlantedBott - EPS
	endif

	dxl = (not(bLeftCornerFunction  | gs_stack_left)  | curvedWall) * slantedDepth * tan(gs_slanted_left_angle)		! --- Left
	dxr = (not(bRightCornerFunction | gs_stack_right) | curvedWall) * slantedDepth * tan(gs_slanted_right_angle)	! --- Right
	dxt = not(gs_stack_top)    * slantedDepth * tan(gs_slanted_top_angle)											! --- Top
	dxb = not(gs_stack_bottom) * slantedDepth * tan(gs_slanted_bottom_angle)										! --- Bottom

	if bLeftCornerFunction	then gs_slanted_left_angle	= 0
	if bRightCornerFunction	then gs_slanted_right_angle	= 0

	if iWindowShape = SHAPE_ARCHED then
		if bHalfCircle then
			arcRComponentY = 0
		else
			arcRComponentY = sqr(arcR^2 - rightWidth^2)
		endif
		shm = sqr((arcR + dxr - offsetSlantedRight)^2 - (rightWidth + dxl - offsetSlantedRight)^2) - arcRComponentY
	endif

! Cut type selection -----------------------------------------------------------

	slantedOpeningWidth	 = openingWidth  - offsetSlantedRight - offsetSlantedLeft	! Width at frame
	slantedOpeningHeight = openingHeight - offsetSlantedBott  - offsetSlantedTop	! Height at frame

	slantedOpeningWidthSide	 = slantedOpeningWidth  + dxr + dxl	! Width at wall side
	slantedOpeningHeightSide = slantedOpeningHeight + dxb + dxt	! Height at wall side

	magicRatioH = 0.95
	magicRatioV = 0.95

	wallBodyThkHorizontal = slantedDepth * (tan(gs_slanted_left_angle) + tan(gs_slanted_right_angle)) - slantedOpeningWidth
	wallBodyThkVertical   = slantedDepth * (tan(gs_slanted_top_angle) + tan(gs_slanted_bottom_angle)) - slantedOpeningHeight
	bCutEdgesOnly = ((wallBodyThkHorizontal < EPS & wallBodyThkVertical < EPS) & not(curvedWall))

! Vertical Cutting Body --------------------------------------------------------

	if gs_slanted_top_angle > EPS | gs_slanted_bottom_angle > EPS then
		if iWindowShape = SHAPE_RECTANGULAR then
			if gs_slanted_bottom_angle > EPS & gs_slanted_top_angle > EPS then
				m = ((tan(gs_slanted_top_angle) / tan(gs_slanted_bottom_angle)) * (B + dxt + dxb - (offsetSlantedTop + offsetSlantedBott))) / (1 + (tan(gs_slanted_top_angle) / tan(gs_slanted_bottom_angle)))
			else
				m = B/2 + dxt - offsetSlantedTop
			endif
			method = 1

			rxv = m - B/2 - dxt + offsetSlantedTop
			ryv = 0
			if gs_slanted_top_angle > EPS then
				rzv = -m / tan(gs_slanted_top_angle)
			else
				rzv = -m / tan(gs_slanted_bottom_angle)
			endif

			dv = -sqr(rxv^2 + rzv^2) * slantedCutDepth / rzv
		endif
		if iWindowShape = SHAPE_ARCHED then
			if gs_slanted_bottom_angle > EPS then m = (B - archHeight + dxb - offsetSlantedBott) / tan(gs_slanted_bottom_angle)

			rxv = (B - archHeight)
			ryv = 0
			rzv = -m
			dv = slantedCutDepth
		endif

		method = 2
	else
		rxv = 0
		ryv = 0
		rzv = -slantedDepth
		dv	=  slantedCutDepth

		method = 1
	endif

! Top - Right Corner Cutting Body ----------------------------------------------

	if iWindowShape = SHAPE_RECTANGULAR then
		if abs(gs_slanted_top_angle) > EPS then
			ratioTL = tan(gs_slanted_right_angle) / tan(gs_slanted_top_angle)
			if openingWidth > B * ratioTL then
				rytl = 2 * B / 3
				rxtl = rytl * ratioTL
			else
				rxtl = 2 * openingWidth / 3
				rytl = rxtl / ratioTL
			endif

			if abs(gs_slanted_right_angle) > EPS then
				rztl = rxtl / tan(gs_slanted_right_angle)
			else
				rztl = rytl / tan(gs_slanted_top_angle)
			endif
		else
			if abs(gs_slanted_right_angle) > EPS then
				rxtl = 3 * openingWidth / 4
				rytl = 0
				rztl = rxtl / tan(gs_slanted_right_angle)
			else
				rxtl = 0
				rytl = 0
				rztl = 1
			endif
		endif

		vx = (slantedDepth) * tan(gs_slanted_right_angle)
		vy = (slantedDepth) * tan(gs_slanted_top_angle)
		vz = (slantedCutDepth)
		dtl = sqr(vx*vx + vy*vy + vz*vz)

		ratioV = max(1, dtl / sqr(rxtl^2 + rytl^2 + rztl^2) * 2)
		rxtl = rxtl * ratioV
		rytl = rytl * ratioV
		rztl = rztl * ratioV

		if bCutEdgesOnly then
			add rightWidth + gs_right_oversize - offsetSlantedRight, B + gs_upper_oversize - offsetSlantedTop, -slantedDepth
			if bRightCornerFunction then
				pxR = 10
			else
				pxR = 0
			endif
			cutform 4, 1, 1 + HalfInfiniteCut * 16,
				-rxtl,-rytl,-rztl, -not(HalfInfiniteCut) * dtl,
				 pxR,					 0,						31,
				-slantedOpeningWidth,	 0,						31,
				-slantedOpeningWidth,	-slantedOpeningHeight,	31,
				 pxR,					-slantedOpeningHeight,	31
			numCuts = numCuts + 1
			del 1
		else
			add rightWidth + gs_right_oversize + dxr - offsetSlantedRight, B + gs_upper_oversize + dxt - offsetSlantedTop, 0
			cutform 4, 2, 1 + HalfInfiniteCut * 16 + 128,
				-rxtl,-rytl,-rztl, dtl,
				leftDx,											 0,				31,
				magicRatioH * (-slantedOpeningWidthSide + dxl),	 0,				31,
				magicRatioH * (-slantedOpeningWidthSide + dxl),	magicRatioV * (-slantedOpeningHeightSide + dxb),	31,
				leftDx,											magicRatioV * (-slantedOpeningHeightSide + dxb),	31
			numCuts = numCuts + 1
			del 1
		endif

! Top - Left Corner Cutting Body -----------------------------------------------

		if abs(gs_slanted_top_angle) > EPS then
			ratioTR = tan(gs_slanted_left_angle) / tan(gs_slanted_top_angle)
			if openingWidth > B * ratioTR then
				rytr = 2 * B / 3
				rxtr = rytr * ratioTR
			else
				rxtr = 2 * openingWidth / 3
				rytr = rxtr / ratioTR
			endif

			if abs(gs_slanted_left_angle) > EPS then
				rztr = rxtr / tan(gs_slanted_left_angle)
			else
				rztr = rytr / tan(gs_slanted_top_angle)
			endif
		else
			if abs(gs_slanted_left_angle) > EPS then
				rxtr = 3 * openingWidth / 4
				rytr = 0
				rztr = rxtr / tan(gs_slanted_left_angle)
			else
				rxtr = 0
				rytr = 0
				rztr = 1
			endif
		endif

		vx = (slantedDepth) * tan(gs_slanted_left_angle)
		vy = (slantedDepth) * tan(gs_slanted_top_angle)
		vz = (slantedCutDepth)
		dtr = sqr(vx*vx + vy*vy + vz*vz)

		ratioV = max(1, dtr / sqr(rxtr^2 + rytr^2 + rztr^2) * 2)
		rxtr = rxtr * ratioV
		rytr = rytr * ratioV
		rztr = rztr * ratioV

		if bCutEdgesOnly then
			add -leftWidth - gs_left_oversize + offsetSlantedLeft, B + gs_upper_oversize - offsetSlantedTop, -slantedDepth
			if bLeftCornerFunction then
				pxL = -10
			else
				pxL = 0
			endif
			cutform 4, 1, 1 + HalfInfiniteCut * 16,
				rxtr,-rytr,-rztr, -not(HalfInfiniteCut) * dtr,
				pxL,				 0,						31,
				slantedOpeningWidth, 0,						31,
				slantedOpeningWidth, -slantedOpeningHeight,	31,
				pxL,				 -slantedOpeningHeight,	31
			numCuts = numCuts + 1
			del 1
		else
			add -leftWidth - gs_left_oversize - dxl + offsetSlantedLeft, B + gs_upper_oversize + dxt - offsetSlantedTop, 0
			if bRightCornerFunction then
				cutform 4, 2, 1 + HalfInfiniteCut * 16 + 128,
					rxtr,-rytr,-rztr, dtr,
					rightDx,			 0,				31,
					openingWidth + 10,	 0,				31,
					openingWidth + 10,	-3*B/4 - dxt,	31,
					rightDx,			-3*B/4 - dxt,	31
				numCuts = numCuts + 1
			else
				cutform 4, 2, 1 + HalfInfiniteCut * 16 + 128,
					rxtr,-rytr,-rztr, dtr,
					rightDx,										 0,				31,
					magicRatioH * (slantedOpeningWidthSide - dxr),	 0,				31,
					magicRatioH * (slantedOpeningWidthSide - dxr),	magicRatioV * (-slantedOpeningHeightSide + dxb),	31,
					rightDx,										magicRatioV * (-slantedOpeningHeightSide + dxb),	31
				numCuts = numCuts + 1
			endif
			del 1
		endif
	endif

	if iWindowShape = SHAPE_ARCHED & gs_slanted_right_angle > EPS & slantedDepth > EPS then
		! --- Top Arched Cut ---

		shm2 = sqr((arcR - offsetSlantedRight)^2 - (rightWidth - offsetSlantedRight)^2) - arcRComponentY
		rxh = 0
		rzh = -(rightWidth + dxr - offsetSlantedRight) / tan(gs_slanted_right_angle)
		ryh = (shm - shm2) * (rzh / slantedDepth)

		dh	=  slantedCutDepth * ((sqr(ryh^2 + rzh^2))/abs(rzh))

		x11 = 0
		y11 = 0
		x12 = rzh
		y12 = ryh
		x21 = 0
		y21 = archHeight - offsetSlantedTop + dxt - shm
		x22 = -cos(gs_slanted_right_angle)
		y22 = -sin(gs_slanted_right_angle) + y21
		gosub 500	! Line - Line intersection


!addy (B - archHeight) + shm
!roty -90
!lin_ x11,y11,0, x12,y12,0
!lin_ x21,y21,0, x22,y22,0
!del 2

		rxh2 = 0
		rzh2 = cx
		ryh2 = cy

		dh	=  slantedCutDepth * ((sqr(ryh2^2 + rzh2^2))/abs(rzh2))

		addy (B - archHeight) + shm

		cutform 5, 2, 1 + HalfInfiniteCut * 16,
			rxh2, ryh2, rzh2, dh,
			(-leftWidth - dxr + offsetSlantedLeft),		openingHeight - B-0.1,							11,
			(-leftWidth - dxr + offsetSlantedLeft),		openingHeight - B,								95,
			0, 											openingHeight - arcR - ((B - archHeight) + shm),995,
			(rightWidth + dxl - offsetSlantedRight),	openingHeight - B,								3095,
			(rightWidth + dxl - offsetSlantedRight),	openingHeight - B-0.1,							11
		numCuts = numCuts + 1
		del 1
	endif

	if abs(gs_slanted_bottom_angle) < EPS then	! Space for Board
		dxb = dxb + overSizeLower
	endif


! Wall Inset cutting body for Slanted Reveal - Right Side --------------

	if bWallInsetCut & bParapetWallInset & SYMB_POS_Y > overSizeLower & not(WALL_INCL > EPS) & gs_parapet_autodim & parapet_height > EPS then

		if curvedWall & wallIsLeft then
			dy = WOD - radBoard
		else
			dy = radBoard + WOD
		endif
		dd = (dy - (WALL_THICKNESS - WIDO_SILL)) * curvedWall
		vx = (parapetWallInsetDepth - dd) * tan(gs_slanted_right_angle)
		vy = (parapetWallInsetDepth - dd) * tan(gs_slanted_bottom_angle)
		vz = (parapetWallInsetDepth - dd)
		dbl = sqr(vx*vx + vy*vy + vz*vz)

		if abs(gs_slanted_right_angle) > EPS then
			rxbl = 3 * openingWidth / 4
			rzbl = rxbl / tan(gs_slanted_right_angle)
		else
			rxbl = 0
			rzbl = 1
		endif
		rybl = rzbl * tan(gs_slanted_bottom_angle)

		add rightWidth + gs_right_oversize + dxr - offsetSlantedRight, -dxb - gs_lower_oversize + offsetSlantedBott, 0
		cutform 4, 2, 1 + HalfInfiniteCut * 16 + 128,
			-rxbl, rybl,-rzbl, dbl,
			 leftDx,					-parapet_height*3/4,	31,
			-3 * openingWidth/4 - dxl,	-parapet_height*3/4,	31,
			-3 * openingWidth/4 - dxl,	 0,						31,
			 leftDx,					 0,						31

		numCuts = numCuts + 1
		del 1

		db2 = sqr(vx*vx + vz*vz)

		add rightWidth + gs_right_oversize + dxr - offsetSlantedRight, -parapet_height, 0
		cutform 4, 2, 1 + HalfInfiniteCut * 16 + 128,
			-rxbl, 0,-rzbl, db2,
			 leftDx,					 parapet_height*3/4,	31,
			-3 * openingWidth/4 - dxl,	 parapet_height*3/4,	31,
			-3 * openingWidth/4 - dxl,	 0,						31,
			 leftDx,					 0,						31
		numCuts = numCuts + 1
		del 1

		isParIns = 1

	endif
! Wall Inset cutting body for Slanted Reveal - Left Side ---------------

	if bWallInsetCut & bParapetWallInset & SYMB_POS_Y > overSizeLower & not(WALL_INCL > EPS) & gs_parapet_autodim & parapet_height > EPS then

		if curvedWall & wallIsLeft then
			dy = WOD - radBoard
		else
			dy = radBoard + WOD
		endif
		dd = (dy - (WALL_THICKNESS - WIDO_SILL)) * curvedWall
		vx = (parapetWallInsetDepth - dd) * tan(gs_slanted_left_angle)
		vy = (parapetWallInsetDepth - dd) * tan(gs_slanted_bottom_angle)
		vz = (parapetWallInsetDepth - dd)
		dbl = sqr(vx*vx + vy*vy + vz*vz)

		if abs(gs_slanted_left_angle) > EPS then
			rxbr = 3 * openingWidth / 4
			rzbr = rxbr / tan(gs_slanted_left_angle)
		else
			rxtr = 0
			rztr = 1
		endif
		rybr = rzbr * tan(gs_slanted_bottom_angle)

		add -leftWidth - gs_left_oversize - dxl + offsetSlantedLeft, -dxb - gs_lower_oversize + offsetSlantedBott, 0
		cutform 4, 2, 1 + HalfInfiniteCut * 16 + 128,
			 rxbr, rybr, -rzbr, dbl,
			 rightDx,					-parapet_height*3/4,	31,
			 3 * openingWidth/4 + dxl,	-parapet_height*3/4,	31,
			 3 * openingWidth/4 + dxl,	 0,						31,
			 rightDx,					 0,						31
		numCuts = numCuts + 1
		del 1

		db2 = sqr(vx*vx + vz*vz)

		add -leftWidth - gs_left_oversize - dxl + offsetSlantedLeft, -parapet_height, 0
		cutform 4, 2, 1 + HalfInfiniteCut * 16 + 128,
			 rxbr, 0, -rzbr, db2,
			 rightDx,					 parapet_height*3/4,	31,
			 3 * openingWidth/4 + dxl,	 parapet_height*3/4,	31,
			 3 * openingWidth/4 + dxl,	 0,						31,
			 rightDx,					 0,						31
		numCuts = numCuts + 1
		del 1

	endif

return



! ==============================================================================
! Line - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12	line #1
!	x21,y21, x22,y22	line #2
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = valid intersection point
!	cx, cy:				intersection point
! ==============================================================================

500:
	lliDiv = (x11-x12) * (y21-y22) - (y11-y12) * (x21-x22)

	if abs(lliDiv) > EPS then
		! Intersection

		temp1 = x11 * y12 - y11 * x12
		temp2 = x21 * y22 - y21 * x22

		tempx = temp1 * (x21-x22) - (x11-x12) * temp2
		tempy = temp1 * (y21-y22) - (y11-y12) * temp2

		state = 1
		cx = (tempx / lliDiv)
		cy = (tempy / lliDiv)
	else
		! No Intersection
		state = 0
		cx = 0
		cy = 0
	endif
return






]]>
</Script_3D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_2D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_2D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_1D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
EPS = 0.0001

! iWindowShape:
SHAPE_RECTANGULAR			= 0
SHAPE_ARCHED				= 1
SHAPE_ROUND					= 2
SHAPE_T						= 19
SHAPE_HALF_T_LEFT			= 20
SHAPE_ARCHED_T				= 21
SHAPE_ARCHED_HALF_T_LEFT	= 22
SHAPE_ELLIPSE				= 24
SHAPE_HALF_T_RIGHT			= 27
SHAPE_ARCHED_HALF_T_RIGHT	= 28

! gs_frame_style_m
FRAME_STYLE_BLOCK				= 1
FRAME_STYLE_DOUBLE_REBATE		= 2
FRAME_STYLE_SIMPLE_REBATE		= 3
FRAME_STYLE_METAL				= 4
FRAME_STYLE_DOUBLE_EGRESS_METAL = 5
FRAME_STYLE_EXTRUSION			= 6
FRAME_STYLE_WRAPPED_EXTRUSION	= 7 

! gs_masonry_arch_int
MASONRY_ARCH					= 2
MASONRY_JACK_ARCH				= 3
MASONRY_JACK_ARCH_KEYSTONE		= 4
MASONRY_SEGMENT_ARCH			= 5
MASONRY_SEGMENT_ARCH_KEYSTONE	= 6
MASONRY_BULLSEYE_ARCH			= 7

if	iWindowShape = SHAPE_T | \
	iWindowShape = SHAPE_HALF_T_LEFT | \
	iWindowShape = SHAPE_HALF_T_RIGHT then iWindowShape = SHAPE_RECTANGULAR

if	iWindowShape = SHAPE_ARCHED_T | \
	iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | \
	iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then iWindowShape = SHAPE_ARCHED


curvedWall		= (abs(WIDO_ORIG_DIST) > EPS)
bCornerWindow	= ac_cw_function & ac_corner_window


openingWidth	= leftWidth + rightWidth
openingHeight	= B
archHeight		= openingArchHeight

! ==============================================================================

widoLeftJamb	= gs_reveal_left
widoRightJamb	= gs_reveal_right

leftJamb	= gs_reveal_left
rightJamb	= gs_reveal_right
bHaveMountingFrame	= 0
bEnableOnlyBullseyeArch = (iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE)

! ==============================================================================

if gs_masonry_arch_structure_int = 0 | GLOB_MODPAR_NAME = "gs_masonry_arch_structure" then
	iArchDetail = 1																		! Stucco Arch
	if gs_masonry_arch_structure = stMasonryArchStructure[2] then iArchDetail = 2		! Brick Arch
	gs_masonry_arch_structure_int = iArchDetail
	parameters gs_masonry_arch_structure_int = iArchDetail
else
	iArchDetail = min(2, max(1, gs_masonry_arch_structure_int))
endif

if gs_masonry_arch_int = MASONRY_JACK_ARCH_KEYSTONE & (gs_stack_left & gs_stack_right) | (bLeftCornerFunction & bRightCornerFunction) then
	gs_masonry_arch_int = MASONRY_JACK_ARCH
endif

wallIsLeft		= (SYMB_ROTANGLE > EPS) exor WIDO_REVEAL_SIDE
signWallIsLeft	= wallIsleft - not(wallIsleft)

REVEAL_EDGE				= 0
REVEAL_NO				= 1
REVEAL_POSITIVE			= 2
REVEAL_NEGATIVE			= 3
REVEAL_SLANTED			= 4
REVEAL_SPLAYED			= 5
REVEAL_HISTORIC			= 6
REVEAL_DOUBLE			= 7
REVEAL_DOUBLE_SPLAYED	= 8
REVEAL_OUTSIDE_SPLAYED	= 9


! ==============================================================================
! Calculations for Curved Walls
! ==============================================================================

if GLOB_SCRIPT_TYPE = 2 | GLOB_SCRIPT_TYPE = 3 then
	if curvedWall & abs(radSill) > EPS then

		if GLOB_SCRIPT_TYPE <> 2 & GLOB_CONTEXT <> 22 then
			widoOrigDist = -WIDO_ORIG_DIST
		else
			widoOrigDist = WIDO_ORIG_DIST
		endif

		tempWOD = abs(widoOrigDist) - (SYMB_ROTANGLE > EPS) * WIDO_FRAME_THICKNESS

		alfaRefWidth = atn(refWidth / tempWOD)

		alfaLeftOs	= atn((leftWidth  + overSizeLeft)  / tempWOD)
		alfaRightOs	= atn((rightWidth + overSizeRight) / tempWOD)

		alfaLeftJamb	= 180 * leftJamb  / radSill / PI
		alfaRightJamb	= 180 * rightJamb / radSill / PI

		alfaLeftInnJamb = atn((leftWidth  + overSizeLeft - (revealInnerLeft * (iRevealType = REVEAL_DOUBLE))) / tempWOD)
		alfaRightInnJamb = atn((rightWidth  + overSizeRight - (revealInnerRight * (iRevealType = REVEAL_DOUBLE))) / tempWOD)

	endif	! curvedWall
endif


]]>
</Script_1D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_PR SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_PR>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_UI SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
pageStartY = 1

sep1x = 140
sep2x = 298
sep1y = 25 + pageStartY
sep2y = 128 + pageStartY



! --- Flags ---

iTypeFlag = 0
if not(bMasonryArch) then iTypeFlag = 4

iBrickFlag = 0
if iArchDetail < 2 then iBrickFlag = 4

iRiseFlag = 0
if (gs_masonry_arch_int <> MASONRY_SEGMENT_ARCH & gs_masonry_arch_int <> MASONRY_SEGMENT_ARCH_KEYSTONE) | iWindowShape = SHAPE_ARCHED then iRiseFlag = 4

iSkewFlag = 0
if gs_masonry_arch_int <> MASONRY_JACK_ARCH & gs_masonry_arch_int <> MASONRY_JACK_ARCH_KEYSTONE then iSkewFlag = 4

iKeystoneFlag = 0
if gs_masonry_arch_int <> MASONRY_JACK_ARCH_KEYSTONE & gs_masonry_arch_int <> MASONRY_SEGMENT_ARCH_KEYSTONE then iKeystoneFlag = 4

y = pageStartY
dy = 22
x1 = 5
x2 = 140
xsep = 222

ui_separator xsep, y, xsep, 266 - pageStartY
ui_style 0, 0
ui_infield{3} "bMasonryArch", x1, y, xsep-x1-5, 18,
	7, "",
	2,
	1, 20, 20, 20, 20,
	0, stMasonryArchUI[1], 0,	! Masonry Arch
	1, stMasonryArchUI[1], 1	! Masonry Arch

ui_style 0, 0
y = y + dy + 2
ui_infield{3} "gs_masonry_arch_int", x1+30, y-3, x2+75-x1-30, 18,
	8, "",
	1, 1,
	x2+65-x1-30, 18, x2+65-x1-30, 18,
	1,	stMasonryArchTypes[2],	MASONRY_ARCH,
	1,	stMasonryArchTypes[3],	MASONRY_JACK_ARCH,
	1,	stMasonryArchTypes[4],	MASONRY_JACK_ARCH_KEYSTONE,
	1,	stMasonryArchTypes[5],	MASONRY_SEGMENT_ARCH,
	1,	stMasonryArchTypes[6],	MASONRY_SEGMENT_ARCH_KEYSTONE,
	1,	stMasonryArchTypes[7],	MASONRY_BULLSEYE_ARCH

y = y + dy
if not(bEnableOnlyBullseyeArch) then
	ui_outfield stMasonryArchUI[2], x1, y, x2-x1-5, 18, iRiseFlag		! Rise
	ui_infield "gs_masonry_arch_rise", x2, y-2, 75, 18
	y = y + dy
	ui_outfield stMasonryArchUI[3], x1, y, x2-x1-5, 20, iSkewFlag		! Skewback Angle
	ui_infield "gs_masonry_arch_skewback_angle", x2, y-2, 75, 18
	y = y + dy + 2
endif

ui_style 0, 0
ui_outfield stMasonryArchUI[4], x1, y, x2-x1-35, 20, iTypeFlag		! Type
ui_style 0, 0
ui_infield{3} "gs_masonry_arch_structure", x2-30, y-2, 105, 18,
	8, "",
	1, 1,
	105, 18, 105, 18,
	1,	stMasonryArchStructure[1],	stMasonryArchStructure[1],
	1,	stMasonryArchStructure[2],	stMasonryArchStructure[2]
y = y + dy
ui_outfield stMasonryArchUI[5], x1, y, x2-x1-5, 20, iBrickFlag		! Brick Thickness
ui_infield "gs_masonry_arch_brick_thk", x2, y-2, 75, 18
y = y + dy
ui_outfield stMasonryArchUI[6], x1, y, x2-x1-5, 20, iBrickFlag		! Mortar Thickness
ui_infield "gs_masonry_arch_mort_thk", x2, y-2, 75, 18
y = y + dy + 5

if not(bEnableOnlyBullseyeArch) then
	ui_style 0, 1
	ui_outfield stMasonryArchUI[7], x1, y, x2-x1-5, 20, iKeystoneFlag		! Keystone
	ui_style 0, 0
	y = y + dy
	ui_outfield stMasonryArchUI[8], x1, y, x2-x1-5, 20, iKeystoneFlag		! Width
	ui_infield "gs_masonry_arch_keystone_width", x2, y-2, 75, 18
	y = y + dy
	ui_outfield stMasonryArchUI[9], x1, y, x2-x1-5, 20, iKeystoneFlag		! Oversize
	ui_infield "gs_masonry_arch_keystone_osize", x2, y-2, 75, 18
	y = y + dy
	ui_outfield stMasonryArchUI[10], x1, y, x2-x1-5, 20, iKeystoneFlag		! Projection
	ui_infield "gs_masonry_arch_keystone_proj", x2, y-2, 75, 18
	y = y + dy
endif



xpic = xsep + 85
ypic = pageStartY + 41

ui_pict 2, xpic, ypic, 76, 77, 1		! ui_section.png

ui_infield "gs_masonry_arch_depth", xpic-30, ypic-20, 65, 18			ui_tooltip stMasonryArchUI[22]
ui_infield "gs_masonry_arch_rearHoleDepth", xpic+40, ypic-20, 65, 18	ui_tooltip stMasonryArchUI[23]

ui_infield "gs_masonry_arch_height", xpic-68, ypic+13, 65, 18			ui_tooltip stMasonryArchUI[21]
ui_infield "gs_masonry_arch_proj", xpic-68, ypic+35, 65, 18				ui_tooltip stMasonryArchUI[24]

if not(bEnableOnlyBullseyeArch) then
	ysep = ypic + 80

	ui_separator xsep+5, ysep, 439, ysep

	ui_infield{3} "gs_automaticArchHeight", xsep+5, ysep+5, 434-xsep, 18,
			7, "",
			2,
			1, 20, 20, 20, 20,
			0, stMasonryArchUI[11], 0,		! Arch on Header
			1, stMasonryArchUI[11], 1

	ui_infield{3} "gs_nicheBelowArch", xsep+5, ysep+25, 434-xsep, 18,
			7, "",
			2,
			1, 20, 20, 20, 20,
			0, stMasonryArchUI[12], 0,		! Niche below Arch
			1, stMasonryArchUI[12], 1

	xpic = xsep + 75
	ypic = ysep + 48

	if gs_masonry_arch_int = MASONRY_ARCH					then ui_pict 1, xpic, ypic, 74, 82, 1		! ui_view.png
	if gs_masonry_arch_int = MASONRY_JACK_ARCH				then ui_pict 17, xpic, ypic, 74, 82, 1		! ui_view_Jack.png
	if gs_masonry_arch_int = MASONRY_JACK_ARCH_KEYSTONE		then ui_pict 16, xpic, ypic-2, 74, 84, 1		! ui_view_JackKey.png
	if gs_masonry_arch_int = MASONRY_SEGMENT_ARCH			then ui_pict 18, xpic-1, ypic-4, 76, 86, 1	! ui_view_Segm.png
	if gs_masonry_arch_int = MASONRY_SEGMENT_ARCH_KEYSTONE	then ui_pict 19, xpic, ypic-4, 74, 86, 1		! ui_view_SegmKey.png

	ui_infield "gs_masonry_arch_ovhg_left", xpic-68, ypic+25, 65, 18		ui_tooltip stMasonryArchUI[25]
	ui_infield "gs_masonry_arch_ovhg_right", xpic+76, ypic+25, 65, 18		ui_tooltip stMasonryArchUI[26]

	ui_infield "gs_masonryArch_height", xpic+76, ypic+3, 65, 18				ui_tooltip stMasonryArchUI[27]
endif

]]>
</Script_UI>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_VL SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! Contact person: <NJ>

! ==============================================================================
! Masonry Arch macro
! ------------------------------------------------------------------------------
! Input parameters:
!	iWindowShape:			Shape of the window (integer)
!							Note: only the rectangular shape can be a Corner Window
!	gs_masonry_arch_int:		Type of the masonry arch (integer)
!	gs_masonry_arch_structure:	Detauil level of the masonry arch (string)
! ==============================================================================

if gs_stack_top then
	lock	"bMasonryArch",
			"gs_masonry_arch_int",
			"gs_masonry_arch_structure",
			"gs_masonry_arch_ovhg_left",
			"gs_masonry_arch_ovhg_right",
			"gs_masonry_arch_rise",
			"gs_masonry_arch_skewback_angle",
			"gs_masonry_arch_proj",
			"gs_masonry_arch_height",
			"gs_masonry_arch_depth",
			"gs_masonry_arch_rearHoleDepth",
			"gs_masonry_arch_brick_thk",
			"gs_masonry_arch_mort_thk",
			"gs_masonry_arch_keystone_width",
			"gs_masonry_arch_keystone_osize",
			"gs_masonry_arch_keystone_proj",
			"gs_masonry_arch_fill",
			"gs_masonry_arch_pen_fg",
			"gs_masonry_arch_pen_bg",
			"gs_masonry_arch_brick_mat",
			"gs_masonry_arch_mort_mat",
			"gs_masonry_arch_keystone_mat"

	if not(isCurtainWallOpeningSWE) then
		lock	"gs_masonry_arch_pen"
	endif
endif
if gs_stack_left then
	gs_masonry_arch_ovhg_left = 0
	parameters gs_masonry_arch_ovhg_left = gs_masonry_arch_ovhg_left
	hideparameter "gs_masonry_arch_ovhg_left"
	lock "gs_masonry_arch_ovhg_left"
endif
if gs_stack_right then
	gs_masonry_arch_ovhg_right = 0
	parameters gs_masonry_arch_ovhg_right = gs_masonry_arch_ovhg_right
	hideparameter "gs_masonry_arch_ovhg_right"
	lock "gs_masonry_arch_ovhg_right"
endif

! ==============================================================================

if (GLOB_MODPAR_NAME = "gs_reveal_type_new" | GLOB_MODPAR_NAME = "gs_reveal_type_int" | GLOB_MODPAR_NAME = "gs_masonry_arch_int" | GLOB_MODPAR_NAME = "bMasonryArch") & bMasonryArch \
	& (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then

	gs_AutomaticArchHeight = 0
	parameters gs_AutomaticArchHeight = 0
	gs_NicheBelowArch = 0
	parameters gs_NicheBelowArch = 0

	offsetTop = (gs_wido_sill - gs_reveal_outer_jamb_depth) * tan(gs_reveal_top_angle)
	gs_MasonryArch_height		= offsetTop
	if iWindowShape = SHAPE_ARCHED then
		masonrySpan = leftWidth + rightWidth - gs_reveal_left - gs_reveal_right + 2*offsetTop
		nominalMasonrySpan = leftWidth + rightWidth + 2*offsetTop
		Ri = (nominalMasonrySpan / 2) / sin(2 * atn(openingArchHeight / (nominalMasonrySpan / 2))) - gs_reveal_top		! Intrados radius

		if Ri - openingArchHeight + gs_reveal_top > EPS then
			masonryHeight = Ri - sqr(Ri^2 - (masonrySpan / 2)^2 )
			Ri2 = ((leftWidth + rightWidth) / 2) / sin(2 * atn(openingArchHeight / ((leftWidth + rightWidth) / 2))) - gs_reveal_top + offsetTop	! Intrados radius
			masonryHalfSpan = sqr(Ri2^2 - (Ri2 - masonryHeight)^2)
			offsetSide = masonryHalfSpan - (leftWidth + rightWidth - gs_reveal_left - gs_reveal_right) / 2
		else
			offsetSide = offsetTop
		endif

		gs_masonry_arch_ovhg_left	= offsetSide
		gs_masonry_arch_ovhg_right	= offsetSide
	endif
	parameters	gs_MasonryArch_height		= gs_MasonryArch_height,
				gs_masonry_arch_ovhg_left	= gs_masonry_arch_ovhg_left,
				gs_masonry_arch_ovhg_right	= gs_masonry_arch_ovhg_right
endif

! ==============================================================================

values "gs_MasonryArch_height"	range [0,]
values "gs_masonry_arch_rearHoleDepth" range [0,)

if gs_AutomaticArchHeight then
	hideparameter "gs_MasonryArch_height"
	lock "gs_MasonryArch_height"
endif

if (gs_masonry_arch_int = MASONRY_ARCH | gs_masonry_arch_int = MASONRY_JACK_ARCH | gs_masonry_arch_int = MASONRY_JACK_ARCH_KEYSTONE) then
	if gs_AutomaticArchHeight then
		lock "gs_NicheBelowArch"
	else
		if gs_MasonryArch_height < EPS then lock "gs_NicheBelowArch"
	endif
else
	if iWindowShape = SHAPE_RECTANGULAR then
		if gs_AutomaticArchHeight then
			if gs_masonry_arch_rise < EPS then lock "gs_NicheBelowArch"
		else
			if gs_masonry_arch_rise < EPS & gs_MasonryArch_height < EPS then lock "gs_NicheBelowArch"
		endif
	endif
	if iWindowShape = SHAPE_ARCHED then
		if gs_AutomaticArchHeight then
			lock "gs_NicheBelowArch"
		else
			if gs_MasonryArch_height < EPS then lock "gs_NicheBelowArch"
		endif
	endif
	if bEnableOnlyBullseyeArch then
		lock "gs_AutomaticArchHeight", "gs_MasonryArch_height"
		parameters gs_MasonryArch_height = 0
		lock "gs_NicheBelowArch"
	endif
endif

! ==============================================================================

if iWindowShape = SHAPE_RECTANGULAR then
	values{2} "gs_masonry_arch_int" MASONRY_ARCH,					stMasonryArchTypes[2],
									MASONRY_JACK_ARCH,				stMasonryArchTypes[3],
									MASONRY_JACK_ARCH_KEYSTONE, 	stMasonryArchTypes[4], 
									MASONRY_SEGMENT_ARCH,			stMasonryArchTypes[5],
									MASONRY_SEGMENT_ARCH_KEYSTONE,	stMasonryArchTypes[6]
endif
if iWindowShape = SHAPE_ARCHED then
	values{2} "gs_masonry_arch_int"	MASONRY_SEGMENT_ARCH, stMasonryArchTypes[5], 
									MASONRY_SEGMENT_ARCH_KEYSTONE, stMasonryArchTypes[6]
	if bMasonryArch & (gs_masonry_arch_int <> MASONRY_SEGMENT_ARCH | gs_masonry_arch_int <> MASONRY_SEGMENT_ARCH_KEYSTONE) then
		if	gs_masonry_arch_int = MASONRY_ARCH |\
			gs_masonry_arch_int = MASONRY_JACK_ARCH then

			gs_masonry_arch_int = MASONRY_SEGMENT_ARCH
		endif
		if gs_masonry_arch_int = MASONRY_JACK_ARCH_KEYSTONE then
			gs_masonry_arch_int = MASONRY_SEGMENT_ARCH_KEYSTONE
		endif
		parameters gs_masonry_arch_int = gs_masonry_arch_int
	endif
endif
if bEnableOnlyBullseyeArch then
	values{2} "gs_masonry_arch_int" MASONRY_BULLSEYE_ARCH, stMasonryArchTypes[7]
endif

values "gs_masonry_arch_structure"			stMasonryArchStructure
parameters gs_masonry_arch_structure = stMasonryArchStructure[iArchDetail]

values "gs_masonry_arch_ovhg_left"			range [0,]
values "gs_masonry_arch_ovhg_right"			range [0,]
values "gs_masonry_arch_height"				range (0, 1.0]
values "gs_masonry_arch_depth"				range (0,]
values "gs_masonry_arch_brick_thk"			range (0, refWidth / 2]
values "gs_masonry_arch_mort_thk"			range (0,]
values "gs_masonry_arch_skewback_angle"		range (0,90]
values "gs_masonry_arch_keystone_width"		range [0,refWidth]
values "gs_masonry_arch_keystone_osize"		range [0,]

if gs_masonry_arch_keystone_width > refWidth then
	parameters gs_masonry_arch_keystone_width = min(0.100, refWidth)
endif

if bMasonryArch & gs_frame_style_m = FRAME_STYLE_WRAPPED_EXTRUSION then
	gs_AutomaticArchHeight = 0
	if	gs_MasonryArch_height < 0.01 &\
		(GLOB_MODPAR_NAME = "bMasonryArch" |\
		 GLOB_MODPAR_NAME = "gs_masonry_arch_int" |\
		 GLOB_MODPAR_NAME = "gs_frame_style" |\
		 GLOB_MODPAR_NAME = "gs_frame_style_m") then
		gs_MasonryArch_height = 0.01
	endif
	parameters	gs_AutomaticArchHeight	= gs_AutomaticArchHeight,
				gs_MasonryArch_height	= gs_MasonryArch_height
	lock "gs_AutomaticArchHeight"
endif

if not(bMasonryArch) then			! Off
	hideparameter	"gs_masonry_arch_int",
					"gs_masonry_arch_structure",
					"gs_masonry_arch_ovhg_left",
					"gs_masonry_arch_ovhg_right",
					"gs_masonry_arch_rise",
					"gs_masonry_arch_skewback_angle",
					"gs_masonry_arch_proj",
					"gs_masonry_arch_height",
					"gs_masonry_arch_depth",
					"gs_masonry_arch_rearHoleDepth",
					"gs_masonry_arch_brick_thk",
					"gs_masonry_arch_mort_thk",
					"gs_masonry_arch_keystone_width",
					"gs_masonry_arch_keystone_osize",
					"gs_masonry_arch_keystone_proj",
					"gs_masonry_arch_fill",
					"gs_masonry_arch_pen_fg",
					"gs_masonry_arch_pen_bg",
					"gs_masonry_arch_brick_mat",
					"gs_masonry_arch_mort_mat",
					"gs_masonry_arch_keystone_mat",
					"gs_AutomaticArchHeight",
					"gs_MasonryArch_height",
					"gs_NicheBelowArch"

	lock	"gs_masonry_arch_int",
			"gs_masonry_arch_structure",
			"gs_masonry_arch_ovhg_left",
			"gs_masonry_arch_ovhg_right",
			"gs_masonry_arch_rise",
			"gs_masonry_arch_skewback_angle",
			"gs_masonry_arch_proj",
			"gs_masonry_arch_height",
			"gs_masonry_arch_depth",
			"gs_masonry_arch_rearHoleDepth",
			"gs_masonry_arch_brick_thk",
			"gs_masonry_arch_mort_thk",
			"gs_masonry_arch_keystone_width",
			"gs_masonry_arch_keystone_osize",
			"gs_masonry_arch_keystone_proj",
			"gs_masonry_arch_fill",
			"gs_masonry_arch_pen_fg",
			"gs_masonry_arch_pen_bg",
			"gs_masonry_arch_brick_mat",
			"gs_masonry_arch_mort_mat",
			"gs_masonry_arch_keystone_mat",
			"gs_AutomaticArchHeight",
			"gs_MasonryArch_height",
			"gs_NicheBelowArch"

	if not(isCurtainWallOpeningSWE) then
		hideparameter	"gs_masonry_arch_pen"
		lock			"gs_masonry_arch_pen"
	endif
else

	if gs_masonry_arch_int = MASONRY_ARCH then			! Masonry Arch
		hideparameter	"gs_masonry_arch_rise",
						"gs_masonry_arch_skewback_angle",
						"gs_masonry_arch_keystone_width",
						"gs_masonry_arch_keystone_osize",
						"gs_masonry_arch_keystone_proj",
						"gs_masonry_arch_keystone_mat"

		lock	"gs_masonry_arch_rise",
				"gs_masonry_arch_skewback_angle",
				"gs_masonry_arch_keystone_width",
				"gs_masonry_arch_keystone_osize",
				"gs_masonry_arch_keystone_proj",
				"gs_masonry_arch_keystone_mat"

		if iArchDetail = 1 then		! Stucco Arch
			hideparameter	"gs_masonry_arch_brick_thk",
							"gs_masonry_arch_mort_thk",
							"gs_masonry_arch_mort_mat"

			lock	"gs_masonry_arch_brick_thk",
					"gs_masonry_arch_mort_thk",
					"gs_masonry_arch_mort_mat"
		endif
	endif

	if gs_masonry_arch_int = MASONRY_JACK_ARCH then			! Masonry Jack Arch
		hideparameter	"gs_masonry_arch_rise",
						"gs_masonry_arch_keystone_width",
						"gs_masonry_arch_keystone_osize",
						"gs_masonry_arch_keystone_proj",
						"gs_masonry_arch_keystone_mat"

		lock	"gs_masonry_arch_rise",
				"gs_masonry_arch_keystone_width",
				"gs_masonry_arch_keystone_osize",
				"gs_masonry_arch_keystone_proj",
				"gs_masonry_arch_keystone_mat"

		if iArchDetail = 1 then		! Stucco Arch
			hideparameter	"gs_masonry_arch_brick_thk",
							"gs_masonry_arch_mort_thk",
							"gs_masonry_arch_mort_mat"

			lock	"gs_masonry_arch_brick_thk",
					"gs_masonry_arch_mort_thk",
					"gs_masonry_arch_mort_mat"
		endif
	endif

	if gs_masonry_arch_int = MASONRY_JACK_ARCH_KEYSTONE then			! Masonry Jack Arch with Keystone
		hideparameter	"gs_masonry_arch_rise"
		lock	"gs_masonry_arch_rise"
		if iArchDetail = 1 then		! Stucco Arch
			hideparameter	"gs_masonry_arch_brick_thk",
							"gs_masonry_arch_mort_thk",
							"gs_masonry_arch_mort_mat"

			lock	"gs_masonry_arch_brick_thk",
					"gs_masonry_arch_mort_thk",
					"gs_masonry_arch_mort_mat"
		endif
	endif

	if gs_masonry_arch_int = MASONRY_SEGMENT_ARCH then			! Masonry Segmented Arch
		hideparameter	"gs_masonry_arch_skewback_angle",
						"gs_masonry_arch_keystone_width",
						"gs_masonry_arch_keystone_osize",
						"gs_masonry_arch_keystone_proj",
						"gs_masonry_arch_keystone_mat"

		lock	"gs_masonry_arch_skewback_angle",
				"gs_masonry_arch_keystone_width",
				"gs_masonry_arch_keystone_osize",
				"gs_masonry_arch_keystone_proj",
				"gs_masonry_arch_keystone_mat"

		if iWindowShape <> SHAPE_RECTANGULAR | gs_stack_top then
			hideparameter	"gs_masonry_arch_rise"
			lock			"gs_masonry_arch_rise"
		endif

		if iArchDetail = 1 then		! Stucco Arch
			hideparameter	"gs_masonry_arch_brick_thk",
							"gs_masonry_arch_mort_thk",
							"gs_masonry_arch_mort_mat"

			lock	"gs_masonry_arch_brick_thk",
					"gs_masonry_arch_mort_thk",
					"gs_masonry_arch_mort_mat"
		endif
	endif

	if gs_masonry_arch_int = MASONRY_SEGMENT_ARCH_KEYSTONE then			! Masonry Segmented Arch with Keystone
		hideparameter	"gs_masonry_arch_skewback_angle"
		lock			"gs_masonry_arch_skewback_angle"

		if iWindowShape <> SHAPE_RECTANGULAR | gs_stack_top then
			hideparameter	"gs_masonry_arch_rise"
			lock			"gs_masonry_arch_rise"
		endif

		if iArchDetail = 1 then		! Stucco Arch
			hideparameter	"gs_masonry_arch_brick_thk",
							"gs_masonry_arch_mort_thk",
							"gs_masonry_arch_mort_mat"

			lock	"gs_masonry_arch_brick_thk",
					"gs_masonry_arch_mort_thk",
					"gs_masonry_arch_mort_mat"
		endif
	endif

	if gs_masonry_arch_int = MASONRY_BULLSEYE_ARCH then			! Masonry Bullseye Arch
		hideparameter	"gs_masonry_arch_ovhg_left",
						"gs_masonry_arch_ovhg_right",
						"gs_masonry_arch_rise",
						"gs_masonry_arch_skewback_angle",
						"gs_masonry_arch_keystone_width",
						"gs_masonry_arch_keystone_osize",
						"gs_masonry_arch_keystone_proj",
						"gs_masonry_arch_keystone_mat"

		lock	"gs_masonry_arch_ovhg_left",
				"gs_masonry_arch_ovhg_right",
				"gs_masonry_arch_rise",
				"gs_masonry_arch_skewback_angle",
				"gs_masonry_arch_keystone_width",
				"gs_masonry_arch_keystone_osize",
				"gs_masonry_arch_keystone_proj",
				"gs_masonry_arch_keystone_mat"

		if iArchDetail = 1 then		! Stucco Arch
			hideparameter	"gs_masonry_arch_brick_thk",
							"gs_masonry_arch_mort_thk",
							"gs_masonry_arch_mort_mat"

			lock	"gs_masonry_arch_brick_thk",
					"gs_masonry_arch_mort_thk",
					"gs_masonry_arch_mort_mat"
		endif
	endif
endif

]]>
</Script_VL>

<Comment SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Comment>

<ParamSection SectVersion="22" SectionFlags="0" SubIdent="0">
	<ParamSectHeader>
		<AutoHotspots>false</AutoHotspots>
		<StatBits>
			<STBit_FixSize/>
		</StatBits>
		<WDLeftFrame>0</WDLeftFrame>
		<WDRightFrame>0</WDRightFrame>
		<WDTopFrame>0</WDTopFrame>
		<WDBotFrame>0</WDBotFrame>
		<LayFlags>65535</LayFlags>
		<WDMirrorThickness>0</WDMirrorThickness>
		<WDWallInset>0</WDWallInset>
	</ParamSectHeader>
	<Parameters>
		<Length Name="A">
			<Description><![CDATA["Dimension 1"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Length Name="B">
			<Description><![CDATA["Dimension 2"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Length Name="ZZYZX">
			<Description><![CDATA["Height"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Boolean Name="AC_show2DHotspotsIn3D">
			<Description><![CDATA["Show 2D Hotspots in 3D"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Length Name="ac_bottomlevel">
			<Description><![CDATA["Bottom Level"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="ac_toplevel">
			<Description><![CDATA["Top Level"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="isCurtainWallOpeningSWE">
			<Description><![CDATA["SWE Curtain Wall"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Integer Name="gs_macro_version">
			<Description><![CDATA["Macro Version"]]></Description>
			<Value>11</Value>
		</Integer>
		<Length Name="refWidth">
			<Description><![CDATA["Reference Width"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="leftWidth">
			<Description><![CDATA["Left Offset from the Origo"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="rightWidth">
			<Description><![CDATA["Right Offset from the Origo"]]></Description>
			<Value>0</Value>
		</Length>
		<Integer Name="iWindowShape">
			<Description><![CDATA["Window Shape"]]></Description>
			<Value>0</Value>
		</Integer>
		<Length Name="openingArchHeight">
			<Description><![CDATA["Arch Height"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="radBoard">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="radSill">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="WOD">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Integer Name="nArchResolution">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Integer>

		<!-- bMasonryArch: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="bMasonryArch">
			<Description><![CDATA["Masonry Arch"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="gs_masonry_arch_int">
			<Description><![CDATA["Masonry Arch"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="gs_masonry_arch_structure">
			<Description><![CDATA["Masonry Arch Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Кирпичная"]]></Value>
		</String>
		<Integer Name="gs_masonry_arch_structure_int">
			<Description><![CDATA["Masonry Arch Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Boolean Name="gs_AutomaticArchHeight">
			<Description><![CDATA["Arch on Header"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Length Name="gs_MasonryArch_height">
			<Description><![CDATA["Distance between Arch and Window"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.1</Value>
		</Length>
		<Boolean Name="gs_NicheBelowArch">
			<Description><![CDATA["Niche below arch"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Length Name="gs_masonry_arch_ovhg_left">
			<Description><![CDATA["Masonry Arch Overhang Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_masonry_arch_ovhg_right">
			<Description><![CDATA["Masonry Arch Overhang Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_masonry_arch_rise">
			<Description><![CDATA["Masonry Arch Rise"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.03</Value>
		</Length>
		<Angle Name="gs_masonry_arch_skewback_angle">
			<Description><![CDATA["Skewback Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>75</Value>
		</Angle>
		<Length Name="gs_masonry_arch_proj">
			<Description><![CDATA["Masonry Arch Projection"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_masonry_arch_height">
			<Description><![CDATA["Masonry Arch Height"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.25</Value>
		</Length>
		<Length Name="gs_masonry_arch_depth">
			<Description><![CDATA["Masonry Arch Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.12</Value>
		</Length>
		<Length Name="gs_masonry_arch_rearHoleDepth">
			<Description><![CDATA["Rear Hole Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_masonry_arch_brick_thk">
			<Description><![CDATA["Brick Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_masonry_arch_mort_thk">
			<Description><![CDATA["Mortar Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.01</Value>
		</Length>
		<Length Name="gs_masonry_arch_keystone_width">
			<Description><![CDATA["Keystone Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_masonry_arch_keystone_osize">
			<Description><![CDATA["Keystone Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_masonry_arch_keystone_proj">
			<Description><![CDATA["Keystone Projection"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.01</Value>
		</Length>
		<Boolean Name="bCustomMatNicheTop">
			<Description><![CDATA["Custom Niche Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<FillPattern Name="gs_masonry_arch_fill">
			<Description><![CDATA["Arch Section Fill Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>65</Value>
		</FillPattern>
		<PenColor Name="gs_masonry_arch_pen_fg">
			<Description><![CDATA["Arch Section Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>5</Value>
		</PenColor>
		<PenColor Name="gs_masonry_arch_pen_bg">
			<Description><![CDATA["Arch Section Fill Bkg. Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</PenColor>
		<PenColor Name="gs_masonry_arch_pen">
			<Description><![CDATA["3D Contour Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>10</Value>
		</PenColor>
		<Material Name="gs_masonry_arch_brick_mat">
			<Description><![CDATA["Brick Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>56</Value>
		</Material>
		<Material Name="gs_masonry_arch_mort_mat">
			<Description><![CDATA["Mortar Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2</Value>
		</Material>
		<Material Name="gs_masonry_arch_keystone_mat">
			<Description><![CDATA["Masonry Arch Keystone Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>37</Value>
		</Material>
		<Material Name="matNicheTop">
			<Description><![CDATA["Niche Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>101</Value>
		</Material>
		<Boolean Name="bEnableCustomMatNicheTop">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- gs_door_frame: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_door_frame">
			<Description><![CDATA[""]]></Description>
		</Title>
		<Integer Name="gs_frame_style_m">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>

		<!-- gs_reveal_parameters: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_reveal_parameters">
			<Description><![CDATA["Reveal Parameters"]]></Description>
		</Title>
		<Integer Name="iRevealType">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="rightWallholeRevealPnts">
			<Description><![CDATA["Right Reveal Points"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="leftWallholeRevealPnts">
			<Description><![CDATA["Left Reveal Points"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="iRevealPointsIdx">
			<Description><![CDATA["Reveal Points Index"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="20" SecondDimension="0">
				<AVal Row="1">1</AVal>
				<AVal Row="2">1</AVal>
				<AVal Row="3">1</AVal>
				<AVal Row="4">1</AVal>
				<AVal Row="5">1</AVal>
				<AVal Row="6">1</AVal>
				<AVal Row="7">1</AVal>
				<AVal Row="8">1</AVal>
				<AVal Row="9">1</AVal>
				<AVal Row="10">1</AVal>
				<AVal Row="11">1</AVal>
				<AVal Row="12">1</AVal>
				<AVal Row="13">1</AVal>
				<AVal Row="14">1</AVal>
				<AVal Row="15">1</AVal>
				<AVal Row="16">1</AVal>
				<AVal Row="17">1</AVal>
				<AVal Row="18">1</AVal>
				<AVal Row="19">1</AVal>
				<AVal Row="20">1</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="gs_wido_sill">
			<Description><![CDATA["Sill Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Angle Name="gs_reveal_outerLeft_angle">
			<Description><![CDATA["Outer Angle Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_outerRight_angle">
			<Description><![CDATA["Outer Angle Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_outerBottom_angle">
			<Description><![CDATA["Outer Angle Upper Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_outerTop_angle">
			<Description><![CDATA["Outer Angle Bottom Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Length Name="gs_reveal_left">
			<Description><![CDATA["Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_right">
			<Description><![CDATA["Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_top">
			<Description><![CDATA["Head Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Angle Name="gs_reveal_top_angle">
			<Description><![CDATA["Upper Side Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Length Name="gs_reveal_outer_jamb_depth">
			<Description><![CDATA["Outer Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>

		<!-- PlasterGeometry: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="PlasterGeometry">
			<Description><![CDATA["Plaster Geometry"]]></Description>
		</Title>
		<Boolean Name="gs_turn_plaster_show_3D">
			<Description><![CDATA["Show in 3D"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="thkPlasterAtSillLeft">
			<Description><![CDATA["Plaster Thickness at Sill - Left Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtSillRight">
			<Description><![CDATA["Plaster Thickness at Sill - Right Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtSillTop">
			<Description><![CDATA["Plaster Thickness at Sill - Top Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtSillBottom">
			<Description><![CDATA["Plaster Thickness at Sill - Bottom Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- ac_corner_window: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="ac_corner_window">
			<Description><![CDATA["Corner Window Function"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="ac_cw_function">
			<Description><![CDATA["Placement Type (1=CW,0=W)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Angle Name="ac_corner_angle">
			<Description><![CDATA["Corner Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Boolean Name="ac_diff_con_wall_thk">
			<Description><![CDATA["Diff. Conn. Wall Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="ac_con_wall_thk">
			<Description><![CDATA["Connecting Wall Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="bLeftCornerFunction">
			<Description><![CDATA["Left Corner"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Angle Name="leftCornerAngle">
			<Description><![CDATA["Left Corner Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Length Name="leftConnWallThk">
			<Description><![CDATA["Left Connected Wall Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="bRightCornerFunction">
			<Description><![CDATA["Right Corner"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Angle Name="rightCornerAngle">
			<Description><![CDATA["Right Corner Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Length Name="rightConnWallThk">
			<Description><![CDATA["Right Connected Wall Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_oversize: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_oversize">
			<Description><![CDATA["Oversize"]]></Description>
		</Title>
		<Length Name="gs_upper_oversize">
			<Description><![CDATA["Upper Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_window_stack: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_window_stack">
			<Description><![CDATA["Ganging"]]></Description>
		</Title>
		<Boolean Name="gs_stack_top">
			<Description><![CDATA["Connection on the Top"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_stack_left">
			<Description><![CDATA["Connection on the Left"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_stack_right">
			<Description><![CDATA["Connection on the Right"]]></Description>
			<Value>0</Value>
		</Boolean>

		<!-- gs_string_resources: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_string_resources">
			<Description><![CDATA["String Resources"]]></Description>
		</Title>
		<String Name="stMasonryArchTypes">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="7" SecondDimension="0">
				<AVal Row="1"><![CDATA["Откл."]]></AVal>
				<AVal Row="2"><![CDATA["Прямая Перемычка"]]></AVal>
				<AVal Row="3"><![CDATA["Клинчатая Перемычка"]]></AVal>
				<AVal Row="4"><![CDATA["Клинчатая Перемычка с Замковым Камнем"]]></AVal>
				<AVal Row="5"><![CDATA["Лучковая Перемычка"]]></AVal>
				<AVal Row="6"><![CDATA["Лучковая Перемычка с Замковым Камнем"]]></AVal>
				<AVal Row="7"><![CDATA["Декоративная Арка"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stMasonryArchStructure">
			<Description><![CDATA["gs_masonry_arch_structure"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="0">
				<AVal Row="1"><![CDATA["Штукатурная"]]></AVal>
				<AVal Row="2"><![CDATA["Кирпичная"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stMasonryArchUI">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="27" SecondDimension="0">
				<AVal Row="1"><![CDATA["Стиль Перемычки"]]></AVal>
				<AVal Row="2"><![CDATA["Подъем"]]></AVal>
				<AVal Row="3"><![CDATA["Угол Пяты"]]></AVal>
				<AVal Row="4"><![CDATA["Тип"]]></AVal>
				<AVal Row="5"><![CDATA["Толщина Кирпича"]]></AVal>
				<AVal Row="6"><![CDATA["Толщина Раствора"]]></AVal>
				<AVal Row="7"><![CDATA["Замковый Камень"]]></AVal>
				<AVal Row="8"><![CDATA["Ширина"]]></AVal>
				<AVal Row="9"><![CDATA["Допуски"]]></AVal>
				<AVal Row="10"><![CDATA["Проекция"]]></AVal>
				<AVal Row="11"><![CDATA["Без Пространства над Проемом"]]></AVal>
				<AVal Row="12"><![CDATA["Ниша над Проемом"]]></AVal>
				<AVal Row="13"><![CDATA["Покрытия"]]></AVal>
				<AVal Row="14"><![CDATA["Кирпич"]]></AVal>
				<AVal Row="15"><![CDATA["Раствор"]]></AVal>
				<AVal Row="16"><![CDATA["Замковый Камень"]]></AVal>
				<AVal Row="17"><![CDATA["Штриховка Сечения"]]></AVal>
				<AVal Row="18"><![CDATA["Тип Штриховки"]]></AVal>
				<AVal Row="19"><![CDATA["Перо Штриховки"]]></AVal>
				<AVal Row="20"><![CDATA["Перо Фона"]]></AVal>
				<AVal Row="21"><![CDATA["Высота Декоративной Перемычки"]]></AVal>
				<AVal Row="22"><![CDATA["Глубина Декоративной Перемычки"]]></AVal>
				<AVal Row="23"><![CDATA["Зазор за Отливом"]]></AVal>
				<AVal Row="24"><![CDATA["Проекция Декоративной Перемычки"]]></AVal>
				<AVal Row="25"><![CDATA["Выступ Декоративной Перемычки Слева"]]></AVal>
				<AVal Row="26"><![CDATA["Выступ Декоративной Перемычки Справа"]]></AVal>
				<AVal Row="27"><![CDATA["Расстояние Между Перемычкой и Окном"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stSubTabpageToolTip">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Выбор Вкладки: Общие Параметры, Реквизиты"]]></Value>
		</String>
	</Parameters>
</ParamSection>

<CalledMacros SectVersion="2" SectionFlags="0" SubIdent="0">
</CalledMacros>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="1" length_in_bytes="291" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000004A0000
	00520403000000017B5FB400000012504C5445000000AEAEAED5D5D5EFECDDFF
	FFFF000000AF0A5B320000000174524E530040E6D866000000B549444154785E
	ED90C111C2300C04F5B91228810EA002ECBF005FFFAD90389910450E98C98FD1
	3EF4DA59DF5846C03B796A1E9505A447C9E7E6B156585F7F158074316B1FEC71
	17B52745F6B47060D7A156B4404A07D41F77810E1D1000AB79480EAD2D43DBAA
	981637F8962A52B1A59C14302D28078B86C122746EE9487DA094CB8A6BAE1300
	2CC5A9F5BCADC8534BDC2EDB9A77595A2D71B45A227FD88A56B4A215AD68D1B0
	6725C38EC50D6D6BCB018B8EB7F50259E470A592D0B75C0000000049454E44AE
	426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="2" length_in_bytes="348" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000004C0000
	004D08030000003B1572BC00000015504C5445000000010101A9A9A9D7D7D7DE
	DAD3FFFFFF00000082760FD00000000174524E530040E6D866000000EB494441
	5478DAED95810A83300C05535DEFFF3F794C52D0C5DA6AB3C9462E4811CBE3FA
	409535C81E989B3608953004B3A5059D7CD5CCBFB3F633C4997F3163B6509643
	1003F35508B32B669469D361861A1D911FAFA16D061A36E53CED5EB064E56618
	681AD4B2B2356B1FB39695AD593BAC96359D371BEF4CC3A2B3E82C3AFB6867F7
	7FCF00FFCE92CB3FA0CC3862508B32E47774831DC4C0768B0DD30D765885FC9A
	593261A9CF0CC1CD0C04C63A4347503CCCE4D08C42D275A4333ACEDAFD06D071
	5613166661768F99E263362F2417330D733523CCCE9B290965C86CDEAE036636
	2CCCC22CCC8CD913001B479A86BFD6E50000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="16" length_in_bytes="352" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000004A0000
	0054080300000012D251A800000012504C5445FF0000FFFFFF000000EFEFDED6
	D6D6ADADAD886203DD0000000174524E530040E6D866000000F24944415478DA
	ED94D10E82301004CB16FEFF974DDD87F308D73D428D3EDC941435308E17B54D
	81A33D01DB073915001C07779EB87BD5115C767E77EC3B779E6C277C767D590B
	5C599537E92CAFD251E6EA415610D5695AAED2D332959C941EBC1CBA765DAAA4
	89F02B67BB3D3CBF68FBB8EDBDD6E165786260E00A30785E45B07456555555FF
	5B052CFD117E775648D1B8FC5FDFD98B2D01F447C9AB3C611504892A3450354F
	A20A53CF38A8C204AAC0C3196C11AAB61E2DAA88DDEC0B5D550F5DAE2A827259
	25666564AB34E9AA4155555555555555555555555555555555FDB42AE6AE6AC6
	3D9520AF92FC4295E14AF502642614BB39E684530000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="17" length_in_bytes="335" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000004A0000
	00520803000000C48BB2B500000012504C5445FF0000FFFFFF000000EFEFDED6
	D6D6ADADAD886203DD0000000174524E530040E6D866000000E14944415478DA
	ED93D10EC22010048FA5FDFF5F167A21502FB01069EAC34DCDF605C7B1514920
	719EBA7A236B8E4A0121E03874F546D61C15E35ADD6A6259E62D24AABA62E783
	EB988D6A7A4825030BF5C946157191694D86AF5F2099BAB29D56899F14FBF290
	D95425D8FAACBCCAABFEB70AD8FA277CF659610A81481E5D18FD05C204205F66
	5565B15520F02AE82B0412A62A0C3C405AA80A03B2AA9EBE29F492363F5DB177
	A9AA50050DF7AAD875DDAB843D2B5E554E8F98ADE24C575D7895577995577995
	5779955779955779D59B557D565523D654847915E50DD51462F9006916152D37
	28FAD10000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="18" length_in_bytes="545" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000004C0000
	00560803000000520480E400000027504C5445FF0000FFFFFF000000EFEFDEDE
	D6D6101010D6D6CE181818080808D6D6D6DEDED6212121F7F7F74EB8D29F0000
	000174524E530040E6D8660000019E4944415478DAED938B6E83300C45EB3B3B
	09A5FFFFBD0B0E6094012615D3A62A17D5A5799C9E84F0F0C3C86177988F1901
	66104D1523F85D4E842C18AB82D846D4656D0956B4B62C7B99A1752492D98968
	D4BB85EB93904C6A46C4721767ACE9259C91440288123316C46E894A4CB90691
	23542209F54E69D5CF5E47104ABBB8DC4118824A316CA6C10C0356BD3080B2C0
	0E2BC3A69E541940235A2BB1344FA968800C4A43A8387C7066B404286B1060CB
	2211D6FF816E2CB8E25444863E28A8188B1060B0621BC496E81DEB32729D46D8
	9A91C4F02C6A11807B1C8158C49E210AD17606A6DF3204A1979894139657161B
	643259584643568BD6EC06318BC158D6414707DA7F6508753374DDED01083F14
	D0CEB289FF36982F0BDE46DDBF5C4CB9C7CC07B4433FDF0CB8F971FEFA9EE152
	D6936FDF7B66A00BF10F683BCC726C0627BE993643618E5C81E18C04ED4581E1
	240AB3E115A55C4B0A8CBE8EAE025BB302B6A9CC0E5954993DDC3DF3CD96E14E
	2E9A5DC975334D37EB66DDAC9B75B36ED6CDBA5937EB66DDEC83CC8ED30E3B4B
	2BCC490BCCCD5FC1AE6417F60DCF7A16E8C7CB10480000000049454E44AE4260
	82
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="19" length_in_bytes="536" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000004A0000
	005608030000005F1AF0A300000027504C5445FF0000FFFFFF000000EFEFDEDE
	D6D6101010D6D6CE181818080808D6D6D6212121DEDED6F7F7F7B5749E3B0000
	000174524E530040E6D866000001954944415478DAED93016EC3200C45E33F0C
	A4EDFDCF3BC746A2B54281B553A7894F1A45267E792474EB0417C871FCB61713
	402508AF5012F81EC55208F314C9414128AC72059B9920952E3D5F0C75D15AE1
	0FB290AB902ECB507C5F03327A1CE628F766ED48A5CD50059F9497E51C999F81
	3271AC0FAF1EBE0445516EC26492B047150AA8DD55CACAAA167729706C900475
	CC66E7008D93CAE5E61316C0BBB2101D25F8FD61A70825ED0C781231077D12F4
	A52228C5458BD00F03950ACCE45836215A75715B237591A581E0AD8853BC9A56
	02B035032099D4352669F0F7E2A8F11E996E3CB09703DF446AE7C3C0489E05D1
	4AD80682245228241F90DBC2437F0CC2D91474D53301087C3A314BB2963F1AD8
	782CFD2078FB5271E475AB7EF73CF33F5B016FFD84BFFBAE3092BAC5EDA2B171
	6920E82C651A55D3B442270356D8A0A88E98A1F094A387A2F02486821DDEA48C
	AA2FE3AB3514E53EA4377CB06A92E8C1AA15838F59D9CD9D0C5AF5336E255956
	CB6A592DAB65B5AC96D5B25A56CB6A597DD4AA9D59D4B3CCA13A194775F309D4
	48CE50DF9237164DE6E262660000000049454E44AE426082
	]]>
</GDLPict>

<Copyright SectVersion="1" SectionFlags="0" SubIdent="0">
	<Author>GRAPHISOFT</Author>
	<License>
		<Type>CC BY-ND</Type>
		<Version>3.0</Version>
	</License>
</Copyright>

</Symbol>
