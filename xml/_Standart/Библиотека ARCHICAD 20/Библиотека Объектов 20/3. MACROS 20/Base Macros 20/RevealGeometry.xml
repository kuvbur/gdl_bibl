<?xml version="1.0" encoding="UTF-8"?>
<Symbol IsArchivable="false" IsPlaceable="false" MainGUID="1BADC4DE-6D3E-11E1-9330-72D24824019B" MigrationValue="Normal" Owner="1196638531" Signature="1196644685" Version="38">
<Ancestry SectVersion="1" SectionFlags="0" SubIdent="0" Template="false">
	<MainGUID>F938E33A-329D-4A36-BE3E-85E126820996</MainGUID>
	<MainGUID>103E8D2C-8230-42E1-9597-46F84CCE28C0</MainGUID>
	<MainGUID>B2970E4C-8680-4061-8670-2F4B638F3953</MainGUID>
</Ancestry>

<CalledMacros SectVersion="2" SectionFlags="0" SubIdent="0">
</CalledMacros>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_3D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_3D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_2D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_2D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_1D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[

!! === H E L P   F O R   R E V E A L   P O I N T S   V I S U A L I S A T I O N ======================
!
! COLOURS:
!	pen 3  = orange: Left Reveal points
!	pen 4  = green:  Left Plaster points
!	pen 20 = red:    Right Reveal points
!	pen 6  = blue:   Right Plaster points
!
!! === E N D   O F   H E L P ========================================================================



!del top
!if WIDO_REVEAL_SIDE then
!	add2 0,-WIDO_FRAME_THICKNESS
!else
!	mul2 1,-1
!endif

! Contact person: <NJ, KR>

! ==============================================================================
! This macro calculates the 2D reveal points
! ------------------------------------------------------------------------------
! Input parameters:
!	refWidth:				reference width in curved walls (length)
!	leftWidth:				wallhole's side distance from the origin at the left side (length)
!	rightWidth:				wallhole's side distance from the origin at the right side (length)
!	cornerPostX:			width of corner post in case of Add-on controlled corner window
!	bWndCurved:				is the window made of curved panels (0 / 1)
!	bParalellInCurvedWalls:	is the wallhole parallel in curved walls (0 / 1)
!	bShowReveal:			show reveal on symbol
! Reveal -----------------------------------------------------------------------
!	iRevealType:			reveal type (integer)
!								0 = No Reveal - Edge
!								1 = No Reveal
!								2 = Positive Reveal
!								3 = Negative Reveal
!								4 = Slanted Reveal
!								5 = Spalyed Reveal
!								6 = Historic Reveal (Altbau)
!								7 = Custom Reveal
!								8 = Historic Slanted Reveal
!	iSillRevealType:		reveal type at sill side in case of Custom Reveal
!	iBoardRevealType:		reveal type at board side in case of Custom Reveal
!								1 = No Reveal
!								2 = Positive Reveal
!								3 = Negative Reveal
!	gs_reveal_left:			left reveal size (length)
!	gs_reveal_right:		left reveal size (length)
!	gs_reveal_left_angle:	left reveal angle in case of slanted reveal (angle)
!	gs_reveal_right_angle:	right reveal angle in case of slanted reveal (angle)
! Turned Plaster ---------------------------------------------------------------
!	thkPlasterAtSillLeft:
!	thkPlasterAtSillRight:
!	thkPlasterAtBoardLeft:
!	thkPlasterAtBoardRight:
! Corner Function --------------------------------------------------------------
!	bLeftCornerFunction:		Turn macro in Corner Window mode at the left side (0 / 1)
!	leftCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	leftConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
!	bRightCornerFunction:	Turn macro in Corner Window mode at the right side (0 / 1)
!	rightCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	rightConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
! Ganging ----------------------------------------------------------------------
!	bGangingLeft:			Align to door/window on left side (0 / 1)
!	bGangingRight:			Align to door/window on right side (0 / 1)
! ------------------------------------------------------------------------------
! Output parameters:
!	iRevealType:			new reveal type (integer)
!								0 = Sill
!								1 = Reveal
!								2 = Negative Reveal
!								3 = Slanted Reveal
!								4 = Spalyed Reveal
!								5 = Historic Reveal (Altbau)
!								6 = Custom Reveal - Custom Closure
!	iClosureType:			new reveal type (integer)
!								0 = No Closure
!								1 = Traditional Cavity Closure
!								2 = Prefabricated Cavity Closure
!								3 = Custom Closure
!	gs_reveal_left:			new left reveal size (length)
!	gs_reveal_right:		new left reveal size (length)
!	gs_reveal_left_angle:	new left reveal angle in case of slanted reveal (angle)
!	gs_reveal_right_angle:	new right reveal angle in case of slanted reveal (angle)
!	radSill:				wall radius at the sill side (length)
!	radBoard:				wall radius at the board side (length)
!	WOD:					"wido orig dist" in the wallhole coordinate system (length)
!	revealPointsArray[]:	array of point coordinates in wallhole coordinate system (length)
!	iRevealPointsIdx[20]:		array of reveal/plaster sill/frame/board start/end indexes
!			Left					Right
!		iRevealPointsIdx[1],  iRevealPointsIdx[11]:		sill start	- reveal
!		iRevealPointsIdx[2],  iRevealPointsIdx[12]:		sill end	- left reveal
!		iRevealPointsIdx[3],  iRevealPointsIdx[13]:		frame start	- left reveal, plaster
!		iRevealPointsIdx[4],  iRevealPointsIdx[14]:		frame end	- left reveal, plaster
!		iRevealPointsIdx[5],  iRevealPointsIdx[15]:		board start	- left reveal
!		iRevealPointsIdx[6],  iRevealPointsIdx[16]:		board end	- left reveal
!		iRevealPointsIdx[7],  iRevealPointsIdx[17]:		sill start	- left plaster
!		iRevealPointsIdx[8],  iRevealPointsIdx[18]:		sill end	- left plaster
!		iRevealPointsIdx[9],  iRevealPointsIdx[19]:		board start	- left plaster
!		iRevealPointsIdx[10], iRevealPointsIdx[20]:		board end	- left plaster
!		Examples:
!			left reveal points number	= iRevealPointsIdx[6]
!			left frame points munber	= iRevealPointsIdx[4] - iRevealPointsIdx[3]
!			left plaster points number	= iRevealPointsIdx[10] - iRevealPointsIdx[6]
!			left points number  		= iRevealPointsIdx[10]
!			right reveal points number  = iRevealPointsIdx[16]
!			right frame points munber   = iRevealPointsIdx[14] - iRevealPointsIdx[13]
!			right plaster points number = iRevealPointsIdx[20] - iRevealPointsIdx[16]
!			right points number  		= iRevealPointsIdx[20]
!	bAddPoint[4]:		array of reveal/plaster sill/frame/board start/end point adding
!		bAddPoint[1]:	add extra plaster point to Sill Plaster / Left Side
!		bAddPoint[2]:	add extra plaster point to Sill Plaster / Right Side
!		bAddPoint[3]:	add extra plaster point to Board Plaster / Left Side
!		bAddPoint[4]:	add extra plaster point to Board Plaster / Right Side
! ------------------------------------------------------------------------------
!		To visualize points returned in the revealPointsArray[] array,
!		you can use the following script in your caller object:
!
!		call "RevealGeometry" parameters gs_macro_version = 12,
!			refWidth						= A,
!			leftWidth						= A / 2,
!			rightWidth						= A / 2,
!			cornerPostX						= cornerPostX,
!			bWndCurved						= gs_IsCurved,
!			bParalellInCurvedWalls			= bParalellInCurvedWalls,
!			bShowReveal						= bShowReveal,
!			iClosureType					= iClosureType,
!			iRevealType						= iRevealType,
!			iSillRevealType					= iSillRevealType,
!			iBoardRevealType				= iBoardRevealType,
!			gs_reveal_left					= gs_reveal_left,
!			gs_reveal_right					= gs_reveal_right,
!			gs_reveal_top					= gs_reveal_top,
!			gs_reveal_bottom				= gs_reveal_bottom,
!			gs_reveal_splayed_innerLeft		= gs_reveal_splayed_innerLeft,
!			gs_reveal_splayed_innerRight	= gs_reveal_splayed_innerRight,
!			gs_reveal_splayed_innerTop		= gs_reveal_splayed_innerTop,
!			gs_reveal_splayed_innerBottom	= gs_reveal_splayed_innerBottom,
!			gs_reveal_double_innerLeft		= gs_reveal_double_innerLeft,
!			gs_reveal_double_innerRight		= gs_reveal_double_innerRight,
!			gs_reveal_double_innerTop		= gs_reveal_double_innerTop,
!			gs_reveal_double_innerBottom	= gs_reveal_double_innerBottom,
!			gs_reveal_outer_jamb_depth		= gs_reveal_outer_jamb_depth,
!			gs_reveal_left_angle			= gs_reveal_left_angle,
!			gs_reveal_right_angle			= gs_reveal_right_angle,
!			gs_reveal_top_angle				= gs_reveal_top_angle,
!			gs_reveal_bottom_angle			= gs_reveal_bottom_angle,
!			gs_reveal_outerLeft_angle		= gs_reveal_outerLeft_angle,
!			gs_reveal_outerRight_angle		= gs_reveal_outerRight_angle,
!			gs_reveal_outerTop_angle		= gs_reveal_outerTop_angle,
!			gs_reveal_outerBottom_angle		= gs_reveal_outerBottom_angle,
!			thkPlasterAtSillLeft			= thkPlasterAtSillLeft,
!			thkPlasterAtSillRight			= thkPlasterAtSillRight,
!			thkPlasterAtBoardLeft			= thkPlasterAtBoardLeft,
!			thkPlasterAtBoardRight			= thkPlasterAtBoardRight,
!			bLeftCornerFunction				= bLeftCornerFunction,
!			leftCornerAngle					= leftCornerAngle,
!			leftConnWallThk					= leftConnWallThk,
!			bRightCornerFunction			= bRightCornerFunction,
!			rightCornerAngle				= rightCornerAngle,
!			rightConnWallThk				= rightConnWallThk,
!			bGangingLeft					= gs_stack_left,
!			bGangingRight					= gs_stack_right,
!			gs_frame_width					= gs_frame_width,
!			gs_tolerance_left				= gs_tolerance_left,
!			gs_tolerance_right				= gs_tolerance_right,
!			gs_tolerance_upper				= gs_tolerance_upper,
!			gs_tolerance_lower				= gs_tolerance_lower,
!			gs_left_oversize				= gs_left_oversize,
!			gs_right_oversize				= gs_right_oversize,
!			RevealDefWSNum					= RevealDefWSNum,
!			WallSkinsNum					= WallSkinsNum,
!		returned_parameters	iRevealType,
!			iRevealTypeForDisplay,
!			iClosureType,
!			bShowReveal,
!			leftWallholeWidth,
!			rightWallholeWidth,
!			originalOffsWindowX,
!			offsWindowX,
!			gs_reveal_left,
!			gs_reveal_right,
!			revealBoardLeft,
!			revealBoardRight,
!			gs_reveal_top,
!			gs_reveal_bottom,
!			gs_reveal_splayed_innerTop,
!			gs_reveal_splayed_innerBottom,
!			gs_reveal_double_innerTop,
!			gs_reveal_double_innerBottom,
!			gs_reveal_outer_jamb_depth,
!			gs_reveal_left_angle,
!			gs_reveal_right_angle,
!			gs_reveal_top_angle,
!			gs_reveal_bottom_angle,
!			gs_reveal_outerLeft_angle,
!			gs_reveal_outerRight_angle,
!			gs_reveal_outerTop_angle,
!			gs_reveal_outerBottom_angle,
!			radSill,
!			radBoard,
!			WOD,
!			iRevealPointsIdx,
!			bAddPoint,
!			revealPointsArray
!
!		! Transform from window's coordinate system to wallhole's coordinate system
!		del top
!		if WIDO_REVEAL_SIDE then
!			add2 0,-WIDO_FRAME_THICKNESS
!		else
!			mul2 1,-1
!		endif
!
!		numPnts = vardim1(revealPointsArray) / 8
!
!		pen 1	! Black pen -> Left side points
!		for i=1 to numPnts
!			idx = 4 * (i - 1) + 1
!			add2 revealPointsArray[idx], revealPointsArray[idx + 1]
!			RR = i * 0.005
!			circle2 0,0, RR
!			line2 -RR,-RR, RR, RR
!			line2 -RR, RR, RR,-RR
!			del 1
!		next i
!
!		pen 20	! Red pen -> Right side points
!		for i=1 to numPnts
!			idx = 4 * (numPnts + i - 1) + 1
!			add2 revealPointsArray[idx], revealPointsArray[idx + 1]
!			RR = i * 0.005
!			circle2 0,0, RR
!			line2 -RR,-RR, RR, RR
!			line2 -RR, RR, RR,-RR
!			del 1
!		next i
! ==============================================================================


EPS = 0.0001

! ==============================================================================

! iWindowShape:
SHAPE_RECTANGULAR			= 0
SHAPE_ARCHED				= 1
SHAPE_ROUND					= 2
SHAPE_EYEBROWS				= 3
SHAPE_HALFCIRCLE			= 4 	! straight side is horizontal
SHAPE_MULTISIDE				= 5
SHAPE_OCTAGONAL				= 6
SHAPE_HALFARCH				= 7
SHAPE_PENTAGON				= 8
SHAPE_QUARTERROUND			= 9
SHAPE_HALFROUND				= 10 	! straight side is vertical
SHAPE_TRAPEZOID				= 11
SHAPE_TRIANGLE				= 12
SHAPE_GOTHICARCH			= 13
SHAPE_ELLIPSEARCH			= 14
SHAPE_ROMBUS				= 15
SHAPE_HORSESHOE				= 16
SHAPE_OGEECENTERED			= 17
SHAPE_SARACENIC				= 18
SHAPE_T						= 19
SHAPE_HALF_T_LEFT			= 20
SHAPE_ARCHED_T				= 21
SHAPE_ARCHED_HALF_T_LEFT	= 22
SHAPE_PARALLELOGRAM			= 23
SHAPE_ELLIPSE				= 24
SHAPE_CORNER_TRIANGLE		= 25
SHAPE_QUARTERROUND_NOFRAME	= 26
SHAPE_HALF_T_RIGHT			= 27
SHAPE_ARCHED_HALF_T_RIGHT	= 28

! iRevealType:
REVEAL_EDGE				= 0
REVEAL_NO				= 1
REVEAL_POSITIVE			= 2
REVEAL_NEGATIVE			= 3
REVEAL_SLANTED			= 4
REVEAL_SPLAYED			= 5
REVEAL_HISTORIC			= 6
REVEAL_DOUBLE			= 7
REVEAL_DOUBLE_SPLAYED	= 8
REVEAL_OUTSIDE_SPLAYED	= 9

! gs_reveal_type_bottom_int
REVEAL_BOTTOM_UNIFORM	= 1
REVEAL_BOTTOM_NO		= 2
REVEAL_BOTTOM_POSITIVE	= 3
REVEAL_BOTTOM_NEGATIVE	= 4

! iSillRevealType (REVEAL_SPLAYED & REVEAL_HISTORIC):
REVEAL_SILLSPLAYNULL		= 101
REVEAL_SILLSPLAYED			= 102
REVEAL_SILLSPLAYBLIND		= 103
REVEAL_SILLSPLAYBLINDNULL	= 104

! iBoardRevealType (REVEAL_SPLAYED & REVEAL_HISTORIC):
REVEAL_BOARDSPLAYNULL	= 111
REVEAL_BOARDSPLAYNEG	= 112

! iClosureType:
CLOSURE_NO					= 0
CLOSURE_TRADITIONAL			= 1
CLOSURE_PREFABRICATED		= 2
CLOSURE_CUSTOM				= 3
CLOSURE_SOLID_WALL			= 4
CLOSURE_STUD_WALL			= 5
CLOSURE_STUD_WALL_SIDING	= 6
CLOSURE_BRICK_VENEER		= 7
CLOSURE_VARIABLE			= 8
CLOSURE_PLASTER_REVEAL	 			= 9
CLOSURE_INSULATED_REVEAL			= 10
CLOSURE_INSULATED_FOR_RENOVATION	= 11
CLOSURE_FINISH						= 12
CLOSURE_AIR_SPACE					= 13
CLOSURE_DUTCH_VARIABLE				= 14

!bAddPoint
dim bAddPoint[4]

! ==============================================================================

curvedWall		= (abs(WIDO_ORIG_DIST) > EPS)

bRotAngle180	= SYMB_ROTANGLE > EPS
wallIsLeft		= bRotAngle180 exor WIDO_REVEAL_SIDE
signWallIsLeft	= wallIsleft - not(wallIsleft)
bPolygonWall	= (AC_WallType = 2)


! ==============================================================================
! Symbol at Middle
! ==============================================================================

SymbolMid_shiftDy = 0

signrevealside = not(WIDO_REVEAL_SIDE) - WIDO_REVEAL_SIDE

if GLOB_SCRIPT_TYPE = 2 | GLOB_SCRIPT_TYPE = 3 then		! symbol should be modified in these 2 only
	if GLOB_CONTEXT = 2 | GLOB_CONTEXT = 22 | GLOB_CONTEXT = 4 | GLOB_CONTEXT = 24 | GLOB_CONTEXT = 6 then
		SymbolMid_shiftDy = bDWSymbolAtMiddle * (WIDO_SILL - WALL_THICKNESS / 2 + WIDO_FRAME_THICKNESS / 2)
	endif
endif


! ==============================================================================
! Uniform Reveal Widths
! ==============================================================================

if gs_reveal_uniform then
	gs_reveal_left		= gs_reveal_right
	gs_reveal_left_sL	= gs_reveal_right
	gs_reveal_right_sR	= gs_reveal_right
	gs_reveal_bottom_sL	= gs_reveal_bottom
	gs_reveal_bottom_sR	= gs_reveal_bottom
	gs_reveal_double_innerLeft		= gs_reveal_double_innerRight
	gs_reveal_double_innerLeft_sL	= gs_reveal_double_innerRight
	gs_reveal_double_innerRight_sR	= gs_reveal_double_innerRight
	gs_reveal_double_innerBottom_sL	= gs_reveal_double_innerBottom
	gs_reveal_double_innerBottom_sR	= gs_reveal_double_innerBottom
	gs_reveal_splayed_innerLeft		= gs_reveal_splayed_innerRight

	gs_reveal_top				= gs_reveal_right
	gs_reveal_double_innerTop	= gs_reveal_double_innerRight
	gs_reveal_splayed_innerTop	= gs_reveal_splayed_innerRight

	gs_reveal_left_angle = gs_reveal_right_angle
	gs_reveal_top_angle = gs_reveal_right_angle
else
	if	iWindowShape = SHAPE_ARCHED_T | \
		iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | \
		iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then

		gs_reveal_top	= gs_reveal_right
		gs_reveal_left	= gs_reveal_right
		gs_reveal_double_innerTop	= gs_reveal_double_innerRight
		gs_reveal_double_innerLeft	= gs_reveal_double_innerRight
	endif
endif


! ==============================================================================
! Wallhole Shape Related Limitations
! ==============================================================================

if iWindowShape = SHAPE_ARCHED or iWindowShape = SHAPE_HALFARCH or iWindowShape = SHAPE_GOTHICARCH \
	or iWindowShape = SHAPE_PENTAGON or iWindowShape = SHAPE_TRAPEZOID or iWindowShape = SHAPE_ELLIPSEARCH then
	if GLOB_SCRIPT_TYPE = 5 then
		if GLOB_MODPAR_NAME = "gs_reveal_left" then
			gs_reveal_right	= gs_reveal_left
			gs_reveal_top	= gs_reveal_left
			parameters	gs_reveal_top	= gs_reveal_top,
						gs_reveal_right	= gs_reveal_right
		else
			if GLOB_MODPAR_NAME = "gs_reveal_top" then
				gs_reveal_right	= gs_reveal_top
				gs_reveal_left	= gs_reveal_top
				parameters	gs_reveal_left	= gs_reveal_left,
							gs_reveal_right	= gs_reveal_right
			else
				gs_reveal_left	= gs_reveal_right
				gs_reveal_top	= gs_reveal_right
				parameters	gs_reveal_left	= gs_reveal_left,
							gs_reveal_top	= gs_reveal_top
			endif
		endif
		if GLOB_MODPAR_NAME = "gs_reveal_double_innerLeft" then
			gs_reveal_double_innerTop	= gs_reveal_double_innerLeft
			gs_reveal_double_innerRight	= gs_reveal_double_innerLeft
			parameters	gs_reveal_double_innerTop	= gs_reveal_double_innerTop,
						gs_reveal_double_innerRight	= gs_reveal_double_innerRight
		else
			if GLOB_MODPAR_NAME = "gs_reveal_double_innerTop" then
				gs_reveal_double_innerLeft	= gs_reveal_double_innerTop
				gs_reveal_double_innerRight	= gs_reveal_double_innerTop
				parameters	gs_reveal_double_innerLeft	= gs_reveal_double_innerLeft,
							gs_reveal_double_innerRight	= gs_reveal_double_innerRight
			else
				gs_reveal_double_innerLeft	= gs_reveal_double_innerRight
				gs_reveal_double_innerTop	= gs_reveal_double_innerRight
				parameters	gs_reveal_double_innerLeft	= gs_reveal_double_innerLeft,
							gs_reveal_double_innerTop	= gs_reveal_double_innerTop
			endif
		endif

		if (iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
			if GLOB_MODPAR_NAME = "gs_reveal_left_angle" then
				gs_reveal_right_angle	= gs_reveal_left_angle
				gs_reveal_top_angle		= gs_reveal_left_angle
				parameters	gs_reveal_top_angle		= gs_reveal_top_angle,
							gs_reveal_right_angle	= gs_reveal_right_angle
			else
				if GLOB_MODPAR_NAME = "gs_reveal_top_angle" then
					gs_reveal_right_angle	= gs_reveal_top_angle
					gs_reveal_left_angle	= gs_reveal_top_angle
					parameters	gs_reveal_left_angle	= gs_reveal_left_angle,
								gs_reveal_right_angle	= gs_reveal_right_angle
				else
					gs_reveal_left_angle	= gs_reveal_right_angle
					gs_reveal_top_angle		= gs_reveal_right_angle
					parameters	gs_reveal_left_angle	= gs_reveal_left_angle,
								gs_reveal_top_angle		= gs_reveal_top_angle
				endif
			endif
		endif

		if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
			if gs_reveal_angle_edit_by_int = 1 then
				if GLOB_MODPAR_NAME = "gs_reveal_outerLeft_angle" then
					gs_reveal_outerRight_angle	= gs_reveal_outerLeft_angle
					gs_reveal_outerTop_angle	= gs_reveal_outerLeft_angle
					parameters	gs_reveal_outerTop_angle	= gs_reveal_outerTop_angle,
								gs_reveal_outerRight_angle	= gs_reveal_outerRight_angle
				else
					if GLOB_MODPAR_NAME = "gs_reveal_outerTop_angle" then
						gs_reveal_outerRight_angle	= gs_reveal_outerTop_angle
						gs_reveal_outerLeft_angle	= gs_reveal_outerTop_angle
						parameters	gs_reveal_outerLeft_angle	= gs_reveal_outerLeft_angle,
									gs_reveal_outerRight_angle	= gs_reveal_outerRight_angle
					else
						gs_reveal_outerLeft_angle	= gs_reveal_outerRight_angle
						gs_reveal_outerTop_angle	= gs_reveal_outerRight_angle
						parameters	gs_reveal_outerLeft_angle	= gs_reveal_outerLeft_angle,
									gs_reveal_outerTop_angle	= gs_reveal_outerTop_angle
					endif
				endif
			else
				if GLOB_MODPAR_NAME = "gs_reveal_innerLeft_width" then
					gs_reveal_innerRight_width	= gs_reveal_innerLeft_width
					gs_reveal_innerTop_width	= gs_reveal_innerLeft_width
					parameters	gs_reveal_innerTop_width	= gs_reveal_innerTop_width,
								gs_reveal_innerRight_width	= gs_reveal_innerRight_width
				else
					if GLOB_MODPAR_NAME = "gs_reveal_innerTop_width" then
						gs_reveal_innerRight_width	= gs_reveal_innerTop_width
						gs_reveal_innerLeft_width	= gs_reveal_innerTop_width
						parameters	gs_reveal_innerLeft_width	= gs_reveal_innerLeft_width,
									gs_reveal_innerRight_width	= gs_reveal_innerRight_width
					else
						gs_reveal_innerLeft_width	= gs_reveal_innerRight_width
						gs_reveal_innerTop_width	= gs_reveal_innerRight_width
						parameters	gs_reveal_innerLeft_width	= gs_reveal_innerLeft_width,
									gs_reveal_innerTop_width	= gs_reveal_innerTop_width
					endif
				endif
				if GLOB_MODPAR_NAME = "gs_reveal_outerLeft_width" then
					gs_reveal_outerRight_width	= gs_reveal_outerLeft_width
					gs_reveal_outerTop_width	= gs_reveal_outerLeft_width
					parameters	gs_reveal_outerTop_width	= gs_reveal_outerTop_width,
								gs_reveal_outerRight_width	= gs_reveal_outerRight_width
				else
					if GLOB_MODPAR_NAME = "gs_reveal_outerTop_width" then
						gs_reveal_outerRight_width	= gs_reveal_outerTop_width
						gs_reveal_outerLeft_width	= gs_reveal_outerTop_width
						parameters	gs_reveal_outerLeft_width	= gs_reveal_outerLeft_width,
									gs_reveal_outerRight_width	= gs_reveal_outerRight_width
					else
						gs_reveal_outerLeft_width	= gs_reveal_outerRight_width
						gs_reveal_outerTop_width	= gs_reveal_outerRight_width
						parameters	gs_reveal_outerLeft_width	= gs_reveal_outerLeft_width,
									gs_reveal_outerTop_width	= gs_reveal_outerTop_width
					endif
				endif
			endif
		endif
	else
		gs_reveal_left	= gs_reveal_right
		gs_reveal_top	= gs_reveal_right
		gs_reveal_double_innerLeft	= gs_reveal_double_innerRight
		gs_reveal_double_innerTop	= gs_reveal_double_innerRight
		gs_reveal_left_angle		= gs_reveal_right_angle
		gs_reveal_top_angle			= gs_reveal_right_angle
		if gs_reveal_angle_edit_by_int = 1 then
			gs_reveal_outerLeft_angle	= gs_reveal_outerRight_angle
			gs_reveal_outerTop_angle	= gs_reveal_outerRight_angle
		else
			gs_reveal_innerLeft_width	= gs_reveal_innerRight_width
			gs_reveal_innerTop_width	= gs_reveal_innerRight_width
			gs_reveal_outerLeft_width	= gs_reveal_outerRight_width
			gs_reveal_outerTop_width	= gs_reveal_outerRight_width
		endif
		revealDLeft	= revealDRight
	endif
endif

if iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE \
		| iWindowShape = SHAPE_ROMBUS | iWindowShape = SHAPE_OCTAGONAL \
		| iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_HALFROUND then
	if GLOB_SCRIPT_TYPE = 5 then
		if GLOB_MODPAR_NAME = "gs_reveal_left" then
			gs_reveal_right	= gs_reveal_left
			gs_reveal_top	= gs_reveal_left
			gs_reveal_bottom= gs_reveal_left
			parameters	gs_reveal_top	= gs_reveal_top,
						gs_reveal_right	= gs_reveal_right,
						gs_reveal_bottom= gs_reveal_bottom
		else
			if GLOB_MODPAR_NAME = "gs_reveal_top" then
				gs_reveal_right	= gs_reveal_top
				gs_reveal_left	= gs_reveal_top
				gs_reveal_bottom= gs_reveal_top
				parameters	gs_reveal_left	= gs_reveal_left,
							gs_reveal_right	= gs_reveal_right,
							gs_reveal_bottom= gs_reveal_bottom
			else
				if GLOB_MODPAR_NAME = "gs_reveal_bottom" then
					gs_reveal_left	= gs_reveal_bottom
					gs_reveal_right	= gs_reveal_bottom
					gs_reveal_top	= gs_reveal_bottom
					parameters	gs_reveal_left	= gs_reveal_left,
								gs_reveal_right	= gs_reveal_right,
								gs_reveal_top	= gs_reveal_top
				else
					gs_reveal_left	= gs_reveal_right
					gs_reveal_top	= gs_reveal_right
					gs_reveal_bottom= gs_reveal_right
					parameters	gs_reveal_left	= gs_reveal_left,
								gs_reveal_top	= gs_reveal_top,
								gs_reveal_bottom= gs_reveal_bottom
				endif
			endif
		endif
		if GLOB_MODPAR_NAME = "gs_reveal_double_innerLeft" then
			gs_reveal_double_innerTop	= gs_reveal_double_innerLeft
			gs_reveal_double_innerRight	= gs_reveal_double_innerLeft
			gs_reveal_double_innerBottom= gs_reveal_double_innerLeft
			parameters	gs_reveal_double_innerTop	= gs_reveal_double_innerTop,
						gs_reveal_double_innerRight	= gs_reveal_double_innerRight,
						gs_reveal_double_innerBottom= gs_reveal_double_innerBottom
		else
			if GLOB_MODPAR_NAME = "gs_reveal_double_innerTop" then
				gs_reveal_double_innerLeft	= gs_reveal_double_innerTop
				gs_reveal_double_innerRight	= gs_reveal_double_innerTop
				gs_reveal_double_innerBottom= gs_reveal_double_innerTop
				parameters	gs_reveal_double_innerLeft	= gs_reveal_double_innerLeft,
							gs_reveal_double_innerRight	= gs_reveal_double_innerRight,
							gs_reveal_double_innerBottom= gs_reveal_double_innerBottom
			else
				if GLOB_MODPAR_NAME = "gs_reveal_double_innerBottom" then
					gs_reveal_double_innerLeft	= gs_reveal_double_innerBottom
					gs_reveal_double_innerRight	= gs_reveal_double_innerBottom
					gs_reveal_double_innerTop	= gs_reveal_double_innerBottom
					parameters	gs_reveal_double_innerLeft	= gs_reveal_double_innerLeft,
								gs_reveal_double_innerRight	= gs_reveal_double_innerRight,
								gs_reveal_double_innerTop	= gs_reveal_double_innerTop
				else
					gs_reveal_double_innerLeft	= gs_reveal_double_innerRight
					gs_reveal_double_innerTop	= gs_reveal_double_innerRight
					gs_reveal_double_innerBottom= gs_reveal_double_innerRight
					parameters	gs_reveal_double_innerLeft	= gs_reveal_double_innerLeft,
								gs_reveal_double_innerTop	= gs_reveal_double_innerTop,
								gs_reveal_double_innerBottom= gs_reveal_double_innerBottom
				endif
			endif
		endif
	else
		gs_reveal_left	= gs_reveal_right
		gs_reveal_top	= gs_reveal_right
		gs_reveal_bottom= gs_reveal_right
		gs_reveal_double_innerLeft	= gs_reveal_double_innerRight
		gs_reveal_double_innerTop	= gs_reveal_double_innerRight
		gs_reveal_double_innerBottom= gs_reveal_double_innerRight

		revealDLeft	= revealDRight
	endif
endif


! ==============================================================================
! Wallhole Geometry
! ==============================================================================

bWithoutReveal = not(iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | iRevealType = REVEAL_SPLAYED | ((iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) & gs_mountingFrame))

if iRevealType  = REVEAL_NEGATIVE then
	signReveal = -1
else
	signReveal = 1
endif

if bCornerWindow then
	offsX	= -gs_unit_nominal * gs_tolerance_left / 2 - (gs_reveal_nominal & bWithoutReveal) * signReveal * (gs_reveal_left + gs_reveal_right) / 2
	offsX	= offsX - gs_reveal_nominal * (revealDLeft + revealDRight) / 2

	rightWidth	= A / 2
	leftWidth	= leftWidth - offsX
else
	offsX = 0
endif

offsWindowX = offsX + (gs_tolerance_left - gs_tolerance_right * not(bCornerWindow)) / 2 - bCornerWindow * cornerPostX
originalOffsWindowX = offsWindowX


! ==============================================================================
! Simple Detail - Wallhole Display without Reveal
! ==============================================================================

if GLOB_SCRIPT_TYPE <> 2 then	! Hide reveal only in 2D
	bShowReveal = 1
endif

if not(bShowReveal) then
	offsPlanDisplay = 0
	if gs_reveal_nominal then
		offsPlanDisplay = signReveal * (gs_reveal_left - gs_reveal_right) / 2
	endif
	if gs_unit_nominal then
		offsPlanDisplay = (gs_tolerance_left - gs_tolerance_right) / 2
	endif

	if not(bGangingLeft) then
		if bCornerWindow then
			leftWidth	= A/2 + gs_reveal_nominal * (signReveal * bWithoutReveal * gs_reveal_right + revealDRight) + cornerPostX
		else
			if not(bLeftCornerFunction) & not(gs_egress_nominal | gs_leaf_nominal) then
				leftWidth	= A/2 - offsPlanDisplay + gs_left_oversize
			endif
		endif
	endif

	if not(bGangingRight) & not(bRightCornerFunction) & not(gs_egress_nominal | gs_leaf_nominal) then
		rightWidth	= A/2 + offsPlanDisplay + gs_right_oversize
	endif

	if bCornerWindow then
		offsWindowX = -gs_reveal_nominal * signReveal * bWithoutReveal * gs_reveal_right / 2 - gs_reveal_nominal * revealDRight / 2 - cornerPostX
	else
		offsWindowX = offsPlanDisplay
	endif

	if gs_reveal_nominal then
		if not(bCornerWindow) then
			offsWindowX = offsWindowX + (bGangingRight | bRightCornerFunction) * signReveal * (bWithoutReveal * gs_reveal_right + revealDRight) / 2 \
									  - (bGangingLeft  | bLeftCornerFunction)  * signReveal * (bWithoutReveal * gs_reveal_left  + revealDLeft)  / 2
		endif
		if bCornerWindow & (bGangingLeft | bLeftCornerFunction) then
			offsWindowX = offsWindowX - (bWithoutReveal * gs_reveal_left) / 2 - revealDLeft
			leftWidth = A/2 + offsPlanDisplay + (bGangingRight | bRightCornerFunction) * signReveal * (gs_reveal_right + revealDRight) / 2 - (bGangingLeft | bLeftCornerFunction) * signReveal * (gs_reveal_left + revealDLeft) / 2 \
						 + bWithoutReveal * (gs_reveal_left + gs_reveal_right) + revealDLeft + revealDRight
		endif
	endif
	if (gs_unit_nominal | gs_egress_nominal | gs_leaf_nominal) then
		if not(bCornerWindow) then
			offsWindowX = offsWindowX + (bGangingRight | bRightCornerFunction) * gs_tolerance_right / 2 - (bGangingLeft | bLeftCornerFunction) * gs_tolerance_left / 2
		endif
		if bCornerWindow & (bGangingLeft | bLeftCornerFunction) then
			offsWindowX = offsWindowX - gs_tolerance_left / 2
			leftWidth = A/2 + offsPlanDisplay + (bGangingRight | bRightCornerFunction) * gs_tolerance_right / 2 - (bGangingLeft | bLeftCornerFunction) * gs_tolerance_left / 2 + gs_tolerance_left
		endif
	endif
endif

if bShowReveal then
	iRevealTypeForDisplay = iRevealType
else
	iRevealTypeForDisplay = REVEAL_NO
endif


! ==============================================================================
! Reveal parameters
! ==============================================================================

leftSillAngle   = 0
rightSillAngle  = 0
leftBoardAngle  = 0
rightBoardAngle = 0

if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
	if gs_reveal_angle_edit_by_int = 1	| \
		gs_reveal_outerLeft_width < 0	| \
		gs_reveal_outerRight_width < 0	| \
		gs_reveal_outerTop_width < 0	| \
		gs_reveal_outerBottom_width < 0 then

		gs_reveal_outerLeft_width 	= tan(gs_reveal_outerLeft_angle)   * (gs_wido_sill - gs_reveal_outer_jamb_depth)
		gs_reveal_outerRight_width 	= tan(gs_reveal_outerRight_angle)  * (gs_wido_sill - gs_reveal_outer_jamb_depth)
		gs_reveal_outerTop_width 	= tan(gs_reveal_outerTop_angle)    * (gs_wido_sill - gs_reveal_outer_jamb_depth)
		gs_reveal_outerBottom_width = tan(gs_reveal_outerBottom_angle) * (gs_wido_sill - gs_reveal_outer_jamb_depth)
		if GLOB_SCRIPT_TYPE = 5 then
			parameters	gs_reveal_outerLeft_width	= gs_reveal_outerLeft_width,
						gs_reveal_outerRight_width	= gs_reveal_outerRight_width,
						gs_reveal_outerTop_width	= gs_reveal_outerTop_width,
						gs_reveal_outerBottom_width	= gs_reveal_outerBottom_width
		endif
	else
		if gs_wido_sill - gs_reveal_outer_jamb_depth > EPS then
			gs_reveal_outerLeft_angle	= atn(gs_reveal_outerLeft_width   / (gs_wido_sill - gs_reveal_outer_jamb_depth))
			gs_reveal_outerRight_angle	= atn(gs_reveal_outerRight_width  / (gs_wido_sill - gs_reveal_outer_jamb_depth))
			gs_reveal_outerTop_angle	= atn(gs_reveal_outerTop_width    / (gs_wido_sill - gs_reveal_outer_jamb_depth))
			gs_reveal_outerBottom_angle	= atn(gs_reveal_outerBottom_width / (gs_wido_sill - gs_reveal_outer_jamb_depth))
		else
			gs_reveal_outerLeft_angle	= 0
			gs_reveal_outerRight_angle	= 0
			gs_reveal_outerTop_angle	= 0
			gs_reveal_outerBottom_angle	= 0
		endif
		if GLOB_SCRIPT_TYPE = 5 then
			parameters	gs_reveal_outerLeft_angle	= gs_reveal_outerLeft_angle,
						gs_reveal_outerRight_angle	= gs_reveal_outerRight_angle,
						gs_reveal_outerTop_angle	= gs_reveal_outerTop_angle,
						gs_reveal_outerBottom_angle	= gs_reveal_outerBottom_angle
		endif
	endif
endif

if iRevealType = REVEAL_DOUBLE_SPLAYED then
	if gs_reveal_angle_edit_by_int = 1	| \
		gs_reveal_innerLeft_width < 0	| \
		gs_reveal_innerRight_width < 0	| \
		gs_reveal_innerTop_width < 0	| \
		gs_reveal_innerBottom_width < 0 then

		gs_reveal_innerLeft_width 	= tan(gs_reveal_left_angle)   * (WALL_THICKNESS - gs_wido_sill - WIDO_FRAME_THICKNESS)
		gs_reveal_innerRight_width 	= tan(gs_reveal_right_angle)  * (WALL_THICKNESS - gs_wido_sill - WIDO_FRAME_THICKNESS)
		gs_reveal_innerTop_width 	= tan(gs_reveal_top_angle)    * (WALL_THICKNESS - gs_wido_sill - WIDO_FRAME_THICKNESS)
		gs_reveal_innerBottom_width = tan(gs_reveal_bottom_angle) * (WALL_THICKNESS - gs_wido_sill - WIDO_FRAME_THICKNESS)
		if GLOB_SCRIPT_TYPE = 5 then
			parameters	gs_reveal_innerLeft_width	= gs_reveal_innerLeft_width,
						gs_reveal_innerRight_width	= gs_reveal_innerRight_width,
						gs_reveal_innerTop_width	= gs_reveal_innerTop_width,
						gs_reveal_innerBottom_width	= gs_reveal_innerBottom_width
		endif
	else
		if WALL_THICKNESS - gs_wido_sill - WIDO_FRAME_THICKNESS > EPS then
			gs_reveal_left_angle	= atn(gs_reveal_innerLeft_width   / (WALL_THICKNESS - gs_wido_sill - WIDO_FRAME_THICKNESS))
			gs_reveal_right_angle	= atn(gs_reveal_innerRight_width  / (WALL_THICKNESS - gs_wido_sill - WIDO_FRAME_THICKNESS))
			gs_reveal_top_angle		= atn(gs_reveal_innerTop_width    / (WALL_THICKNESS - gs_wido_sill - WIDO_FRAME_THICKNESS))
			gs_reveal_bottom_angle	= atn(gs_reveal_innerBottom_width / (WALL_THICKNESS - gs_wido_sill - WIDO_FRAME_THICKNESS))
		else
			gs_reveal_left_angle	= 0
			gs_reveal_right_angle	= 0
			gs_reveal_top_angle		= 0
			gs_reveal_bottom_angle	= 0
		endif
		if GLOB_SCRIPT_TYPE = 5 then
			parameters	gs_reveal_left_angle	= gs_reveal_left_angle,
						gs_reveal_right_angle	= gs_reveal_right_angle,
						gs_reveal_top_angle		= gs_reveal_top_angle,
						gs_reveal_bottom_angle	= gs_reveal_bottom_angle
		endif
	endif
endif

!if WIDO_REVEAL_ON then

	if (iRevealTypeForDisplay = REVEAL_DOUBLE & iSillRevealType = REVEAL_NO) | \
		iRevealTypeForDisplay = REVEAL_EDGE | \
		iRevealTypeForDisplay = REVEAL_NO | \
		iRevealTypeForDisplay = REVEAL_SPLAYED then

		gs_reveal_left_sL	= 0
		gs_reveal_right_sR	= 0
		gs_reveal_bottom_sL	= 0
		gs_reveal_bottom_sR	= 0
	endif
	if (iRevealTypeForDisplay = REVEAL_DOUBLE & iSillRevealType = REVEAL_NEGATIVE) | \
		iRevealTypeForDisplay = REVEAL_NEGATIVE then
		gs_reveal_left_sL	= -abs(gs_reveal_left_sL)
		gs_reveal_right_sR	= -abs(gs_reveal_right_sR)
		gs_reveal_bottom_sL	= -abs(gs_reveal_bottom_sL)
		gs_reveal_bottom_sR	= -abs(gs_reveal_bottom_sR)
	endif

	if not(iRevealTypeForDisplay = REVEAL_DOUBLE) | (iRevealTypeForDisplay = REVEAL_DOUBLE & iBoardRevealType = REVEAL_NO) then
		gs_reveal_double_innerLeft_sL	= 0
		gs_reveal_double_innerRight_sR	= 0
		gs_reveal_double_innerBottom_sL	= 0
		gs_reveal_double_innerBottom_sR	= 0
	endif
	if iRevealTypeForDisplay = REVEAL_DOUBLE & iBoardRevealType = REVEAL_NEGATIVE then
		gs_reveal_double_innerLeft_sL	= -abs(gs_reveal_double_innerLeft_sL)
		gs_reveal_double_innerRight_sR	= -abs(gs_reveal_double_innerRight_sR)
		gs_reveal_double_innerBottom_sL	= -abs(gs_reveal_double_innerBottom_sL)
		gs_reveal_double_innerBottom_sR	= -abs(gs_reveal_double_innerBottom_sR)
	endif

	if iRevealTypeForDisplay = REVEAL_POSITIVE then
		if SYMB_MIRRORED exor SYMB_ROTANGLE > EPS then
			WIDO_LEFT_JAMB	= gs_reveal_right
			WIDO_RIGHT_JAMB	= gs_reveal_left
		else
			WIDO_LEFT_JAMB	= gs_reveal_left
			WIDO_RIGHT_JAMB	= gs_reveal_right
		endif

		leftJamb	= gs_reveal_left
		rightJamb	= gs_reveal_right
		topJamb		= gs_reveal_top

		if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM | gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
			bottomJamb	= gs_reveal_bottom
		else
			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
				bottomJamb	= -gs_reveal_bottom
			else	! REVEAL_BOTTOM_NO
				bottomJamb	= 0
			endif
		endif

		WIDO_HEAD_DEPTH		= gs_reveal_top
		WIDO_THRES_DEPTH	= bottomJamb
	endif

	if iRevealTypeForDisplay = REVEAL_NEGATIVE then
		if SYMB_MIRRORED exor SYMB_ROTANGLE > EPS then
			WIDO_LEFT_JAMB	= -gs_reveal_right
			WIDO_RIGHT_JAMB	= -gs_reveal_left
		else
			WIDO_LEFT_JAMB	= -gs_reveal_left
			WIDO_RIGHT_JAMB	= -gs_reveal_right
		endif

		leftJamb	= -gs_reveal_left
		rightJamb	= -gs_reveal_right
		topJamb		= -gs_reveal_top

		if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM | gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
			bottomJamb	= -gs_reveal_bottom
		else
			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
				bottomJamb = gs_reveal_bottom
			else	! REVEAL_BOTTOM_NO
				bottomJamb = 0
			endif
		endif

		WIDO_HEAD_DEPTH		= -gs_reveal_top
		WIDO_THRES_DEPTH	= bottomJamb
	endif

	if iRevealTypeForDisplay = REVEAL_NO then
		leftJamb	= 0
		rightJamb	= 0
		topJamb		= 0
		bottomJamb	= 0

		if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
			iRevealTypeForDisplay = REVEAL_NEGATIVE
			bottomJamb	= -gs_reveal_bottom

			WIDO_HEAD_DEPTH		= -gs_reveal_top
			WIDO_THRES_DEPTH	= bottomJamb
		endif

		if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
			iRevealTypeForDisplay = REVEAL_POSITIVE
			bottomJamb	= gs_reveal_bottom

			WIDO_HEAD_DEPTH		= gs_reveal_top
			WIDO_THRES_DEPTH	= bottomJamb
		endif
	endif

	if iRevealTypeForDisplay = REVEAL_SLANTED then
		if SYMB_MIRRORED exor SYMB_ROTANGLE > EPS then
			WIDO_LEFT_JAMB	= gs_reveal_right
			WIDO_RIGHT_JAMB	= gs_reveal_left
		else
			WIDO_LEFT_JAMB	= gs_reveal_left
			WIDO_RIGHT_JAMB	= gs_reveal_right
		endif

		leftJamb		= gs_reveal_left
		rightJamb		= gs_reveal_right
		topJamb			= gs_reveal_top

		if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM | gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
			bottomJamb		= gs_reveal_bottom
		else
			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
				bottomJamb	= -gs_reveal_bottom
			else	! REVEAL_BOTTOM_NO
				bottomJamb	= 0
			endif
		endif
		if gs_reveal_type_bottom_int <> REVEAL_BOTTOM_UNIFORM then
			gs_reveal_bottom_angle = 0
		endif

		leftBoardAngle	= gs_reveal_left_angle
		rightBoardAngle	= gs_reveal_right_angle

		WIDO_HEAD_DEPTH		= gs_reveal_top
		WIDO_THRES_DEPTH	= bottomJamb
	endif

	if iRevealTypeForDisplay = REVEAL_SPLAYED then
		WIDO_LEFT_JAMB	= 0
		WIDO_RIGHT_JAMB	= 0

		leftJamb			= 0
		rightJamb			= 0
		topJamb				= 0
		bottomJamb			= 0
		revealBoardLeft		= -gs_reveal_splayed_innerLeft
		revealBoardRight	= -gs_reveal_splayed_innerRight
		revealBoardTop		= -gs_reveal_splayed_innerTop
		revealBoardBottom	= -gs_reveal_splayed_innerBottom
		leftBoardAngle		= gs_reveal_left_angle
		rightBoardAngle		= gs_reveal_right_angle

		WIDO_HEAD_DEPTH		= 0
		WIDO_THRES_DEPTH	= 0
	endif

	if iRevealTypeForDisplay = REVEAL_HISTORIC then
		if SYMB_MIRRORED exor SYMB_ROTANGLE > EPS then
			WIDO_LEFT_JAMB	= gs_reveal_right
			WIDO_RIGHT_JAMB	= gs_reveal_left
		else
			WIDO_LEFT_JAMB	= gs_reveal_left
			WIDO_RIGHT_JAMB	= gs_reveal_right
		endif

		leftJamb			= gs_reveal_left
		rightJamb			= gs_reveal_right
		topJamb				= gs_reveal_top

		if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM | gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
			bottomJamb		= gs_reveal_bottom
		else
			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
				bottomJamb	= -gs_reveal_bottom
			else	! REVEAL_BOTTOM_NO
				bottomJamb	= 0
			endif
		endif
		if gs_reveal_type_bottom_int <> REVEAL_BOTTOM_UNIFORM then
			gs_reveal_bottom_angle = 0
		endif

		revealBoardLeft		= -gs_reveal_splayed_innerLeft
		revealBoardRight	= -gs_reveal_splayed_innerRight
		revealBoardTop		= -gs_reveal_splayed_innerTop

		if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
			revealBoardBottom	= -gs_reveal_splayed_innerBottom
		else
			revealBoardBottom	= 0
		endif

		leftBoardAngle		= gs_reveal_left_angle
		rightBoardAngle		= gs_reveal_right_angle

		WIDO_HEAD_DEPTH		= gs_reveal_top
		WIDO_THRES_DEPTH	= bottomJamb
	endif

	if iRevealTypeForDisplay = REVEAL_DOUBLE_SPLAYED | iRevealTypeForDisplay = REVEAL_OUTSIDE_SPLAYED then
		if gs_mountingFrame then
			gs_reveal_left   = 0
			gs_reveal_right  = 0
			gs_reveal_top    = 0
			gs_reveal_bottom = 0
		else
			gs_mountingFrame_depth = 0
		endif

		if SYMB_MIRRORED exor SYMB_ROTANGLE > EPS then
			WIDO_LEFT_JAMB	= gs_reveal_right
			WIDO_RIGHT_JAMB	= gs_reveal_left
		else
			WIDO_LEFT_JAMB	= gs_reveal_left
			WIDO_RIGHT_JAMB	= gs_reveal_right
		endif

		leftJamb			= gs_reveal_left
		rightJamb			= gs_reveal_right
		topJamb				= gs_reveal_top
		bottomJamb			= gs_reveal_bottom
		revealBoardLeft		= 0
		revealBoardRight	= 0
		revealBoardTop		= 0
		revealBoardBottom	= 0

		if (gs_wido_sill - gs_reveal_outer_jamb_depth) < EPS & gs_wido_sill > EPS then
			gs_reveal_outer_jamb_depth = gs_wido_sill
			leftSillAngle	= 0
			rightSillAngle	= 0
		else
			leftSillAngle	= gs_reveal_outerLeft_angle
			rightSillAngle	= gs_reveal_outerRight_angle
		endif

		if iRevealTypeForDisplay = REVEAL_OUTSIDE_SPLAYED then
			leftBoardAngle	= 0
			rightBoardAngle	= 0
		else
			leftBoardAngle	= gs_reveal_left_angle
			rightBoardAngle	= gs_reveal_right_angle
		endif

		WIDO_HEAD_DEPTH		= gs_reveal_top
		WIDO_THRES_DEPTH	= gs_reveal_bottom
	else
		gs_mountingFrame = 0
	endif

	if iRevealTypeForDisplay = REVEAL_DOUBLE then
		if iSillRevealType = REVEAL_NEGATIVE then
			leftJamb	= -gs_reveal_left
			rightJamb	= -gs_reveal_right
			topJamb		= -gs_reveal_top
			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM | gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
				bottomJamb	= -gs_reveal_bottom
			else
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
					bottomJamb	= gs_reveal_bottom
				else
					bottomJamb	= 0
				endif
			endif
		else
			if iSillRevealType = REVEAL_POSITIVE then
				leftJamb	= gs_reveal_left
				rightJamb	= gs_reveal_right
				topJamb		= gs_reveal_top
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM | gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
					bottomJamb	= gs_reveal_bottom
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
						bottomJamb	= -gs_reveal_bottom
					else
						bottomJamb	= 0
					endif
				endif
			else
				leftJamb	= gs_reveal_left
				rightJamb	= gs_reveal_right
				topJamb		= gs_reveal_top
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM | gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					bottomJamb	= 0
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
						bottomJamb	= -gs_reveal_bottom
					else
						bottomJamb	= gs_reveal_bottom
					endif
				endif
			endif
		endif

		if iBoardRevealType = REVEAL_NEGATIVE then
			revealBoardLeft		= -gs_reveal_double_innerLeft
			revealBoardRight	= -gs_reveal_double_innerRight
			revealBoardTop		= -gs_reveal_double_innerTop
			revealBoardBottom	= -gs_reveal_double_innerBottom
		else
			if iBoardRevealType = REVEAL_POSITIVE then
				revealBoardLeft		= gs_reveal_double_innerLeft
				revealBoardRight	= gs_reveal_double_innerRight
				revealBoardTop		= gs_reveal_double_innerTop
				revealBoardBottom	= gs_reveal_double_innerBottom
			else
				revealBoardLeft		= 0
				revealBoardRight	= 0
				revealBoardTop		= 0
				revealBoardBottom	= 0
			endif
		endif

		if  gs_reveal_type_bottom_int <> REVEAL_BOTTOM_UNIFORM then
			revealBoardBottom = 0
		endif

		if SYMB_MIRRORED exor SYMB_ROTANGLE > EPS then
			WIDO_LEFT_JAMB	= rightJamb
			WIDO_RIGHT_JAMB	= leftJamb
		else
			WIDO_LEFT_JAMB	= leftJamb
			WIDO_RIGHT_JAMB	= rightJamb
		endif

		if iSillRevealType = REVEAL_NO then
			WIDO_HEAD_DEPTH		= 0
		else
			WIDO_HEAD_DEPTH		= topJamb
		endif
		WIDO_THRES_DEPTH	= bottomJamb
	endif

!else
!!!	if WIDO_REVEAL_ON then
!!!		iRevealTypeForDisplay = REVEAL_POSITIVE
!!!	else
!		iRevealTypeForDisplay = REVEAL_NO
!!!	endif
!endif

! ==============================================================================
! Ganging
! ==============================================================================

if bGangingLeft then
	thkPlasterAtSillLeft	= 0
	thkPlasterAtBoardLeft	= 0
endif

if bGangingRight then
	thkPlasterAtSillRight	= 0
	thkPlasterAtBoardRight	= 0
endif

! ==============================================================================
! SillReveal types
! ==============================================================================

iSillRevealTypeLeft		= REVEAL_NO
iSillRevealTypeRight 	= REVEAL_NO
iSillRevealTypeTop		= REVEAL_NO
iSillRevealTypeBottom 	= REVEAL_NO

if iRevealTypeForDisplay = REVEAL_POSITIVE | \
 iRevealTypeForDisplay = REVEAL_SLANTED | iRevealTypeForDisplay = REVEAL_HISTORIC | \
 (iRevealTypeForDisplay = REVEAL_DOUBLE & iSillRevealType = REVEAL_POSITIVE) then
	if gs_reveal_left < EPS then
		iSillRevealTypeLeft = REVEAL_NO
	else
		iSillRevealTypeLeft = REVEAL_POSITIVE
	endif

	if gs_reveal_right < EPS then
		iSillRevealTypeRight = REVEAL_NO
	else
		iSillRevealTypeRight = REVEAL_POSITIVE
	endif

	if gs_reveal_top < EPS then
		iSillRevealTypeTop = REVEAL_NO
	else
		iSillRevealTypeTop = REVEAL_POSITIVE
	endif

	if gs_reveal_bottom < EPS then
		iSillRevealTypeBottom = REVEAL_NO
	else
		iSillRevealTypeBottom = REVEAL_POSITIVE
	endif
endif

if iRevealTypeForDisplay = REVEAL_DOUBLE_SPLAYED | iRevealTypeForDisplay = REVEAL_OUTSIDE_SPLAYED then
	if leftSillAngle < EPS then
		if gs_reveal_left < EPS then
			iSillRevealTypeLeft = REVEAL_NO
		else
			iSillRevealTypeLeft = REVEAL_POSITIVE
		endif
	else
		if gs_reveal_left < EPS then
			iSillRevealTypeLeft = REVEAL_SILLSPLAYNULL
		else
			iSillRevealTypeLeft = REVEAL_SILLSPLAYED
		endif
	endif

	if rightSillAngle < EPS then
		if gs_reveal_right < EPS then
			iSillRevealTypeRight = REVEAL_NO
		else
			iSillRevealTypeRight = REVEAL_POSITIVE
		endif
	else
		if gs_reveal_right < EPS then
			iSillRevealTypeRight = REVEAL_SILLSPLAYNULL
		else
			iSillRevealTypeRight = REVEAL_SILLSPLAYED
		endif
	endif

	if gs_reveal_outerTop_angle < EPS then
		if gs_reveal_top < EPS then
			iSillRevealTypeTop = REVEAL_NO
		else
			iSillRevealTypeTop = REVEAL_POSITIVE
		endif
	else
		if gs_reveal_top < EPS then
			iSillRevealTypeTop = REVEAL_SILLSPLAYNULL
		else
			iSillRevealTypeTop = REVEAL_SILLSPLAYED
		endif
	endif

	if gs_reveal_outerBottom_angle < EPS then
		if gs_reveal_bottom < EPS then
			iSillRevealTypeBottom = REVEAL_NO
		else
			iSillRevealTypeBottom = REVEAL_POSITIVE
		endif
	else
		if gs_reveal_bottom < EPS then
			iSillRevealTypeBottom = REVEAL_SILLSPLAYNULL
		else
			iSillRevealTypeBottom = REVEAL_SILLSPLAYED
		endif
	endif
endif

if iRevealTypeForDisplay = REVEAL_NEGATIVE | \
 (iRevealTypeForDisplay = REVEAL_DOUBLE & iSillRevealType = REVEAL_NEGATIVE) then
	if gs_reveal_left < EPS then
		iSillRevealTypeLeft = REVEAL_NO
	else
		iSillRevealTypeLeft = REVEAL_NEGATIVE
	endif

	if gs_reveal_right < EPS then
		iSillRevealTypeRight = REVEAL_NO
	else
		iSillRevealTypeRight = REVEAL_NEGATIVE
	endif

	if gs_reveal_top < EPS then
		iSillRevealTypeTop = REVEAL_NO
	else
		iSillRevealTypeTop = REVEAL_NEGATIVE
	endif

	if gs_reveal_bottom < EPS then
		iSillRevealTypeBottom = REVEAL_NO
	else
		iSillRevealTypeBottom = REVEAL_NEGATIVE
	endif
endif

if gs_wido_sill < -9998 then
	testWidoSill = WIDO_SILL
else
	testWidoSill = gs_wido_sill
endif
if testWidoSill < EPS then
	iSillRevealTypeLeft		= REVEAL_NO
	iSillRevealTypeRight 	= REVEAL_NO
	iSillRevealTypeTop		= REVEAL_NO
	iSillRevealTypeBottom 	= REVEAL_NO
endif

if iSillRevealTypeLeft = REVEAL_NO then
	gs_reveal_left = 0
	leftJamb = 0
endif

if iSillRevealTypeRight = REVEAL_NO then
	gs_reveal_right = 0
	rightJamb = 0
endif

if iSillRevealTypeTop = REVEAL_NO then
	gs_reveal_top = 0
	topJamb = 0
endif

if iSillRevealTypeBottom = REVEAL_NO then
	gs_reveal_bottom = 0
	bottomJamb = 0
endif

! --- for TurnPlaster macro ------------

if iSillRevealTypeLeft = REVEAL_NEGATIVE then
	bAddPoint[1] = 1
else
	bAddPoint[1] = 0
endif

if iSillRevealTypeRight = REVEAL_NEGATIVE then
	bAddPoint[2] = 1
else
	bAddPoint[2] = 0
endif


! ==============================================================================
! BoardReveal types
! ==============================================================================

iBoardRevealTypeLeft	= REVEAL_NO
iBoardRevealTypeRight	= REVEAL_NO
iBoardRevealTypeTop		= REVEAL_NO
iBoardRevealTypeBottom	= REVEAL_NO

if iRevealTypeForDisplay = REVEAL_SLANTED then
	if gs_reveal_left_angle < EPS then
		iBoardRevealTypeLeft	= REVEAL_NO
	else
		iBoardRevealTypeLeft	= REVEAL_SLANTED
	endif

	if gs_reveal_right_angle < EPS then
		iBoardRevealTypeRight	= REVEAL_NO
	else
		iBoardRevealTypeRight	= REVEAL_SLANTED
	endif

	if gs_reveal_top_angle < EPS then
		iBoardRevealTypeTop	= REVEAL_NO
	else
		iBoardRevealTypeTop	= REVEAL_SLANTED
	endif

	if gs_reveal_bottom_angle < EPS then
		iBoardRevealTypeBottom	= REVEAL_NO
	else
		iBoardRevealTypeBottom	= REVEAL_SLANTED
	endif
endif

if iRevealTypeForDisplay = REVEAL_SPLAYED | iRevealTypeForDisplay = REVEAL_HISTORIC | iRevealTypeForDisplay = REVEAL_DOUBLE_SPLAYED  then
	if gs_reveal_left_angle < EPS then
		if ABS(revealBoardLeft) < EPS then
			iBoardRevealTypeLeft	= REVEAL_NO
		else
			iBoardRevealTypeLeft	= REVEAL_NEGATIVE
		endif
	else
		if ABS(revealBoardLeft) < EPS then
			iBoardRevealTypeLeft	= REVEAL_BOARDSPLAYNULL
		else
			iBoardRevealTypeLeft	= REVEAL_BOARDSPLAYNEG
		endif
	endif

	if gs_reveal_right_angle < EPS then
		if ABS(revealBoardRight) < EPS then
			iBoardRevealTypeRight	= REVEAL_NO
		else
			iBoardRevealTypeRight	= REVEAL_NEGATIVE
		endif
	else
		if ABS(revealBoardRight) < EPS then
			iBoardRevealTypeRight	= REVEAL_BOARDSPLAYNULL
		else
			iBoardRevealTypeRight	= REVEAL_BOARDSPLAYNEG
		endif
	endif

	if gs_reveal_top_angle < EPS then
		if ABS(revealBoardTop) < EPS then
			iBoardRevealTypeTop	= REVEAL_NO
		else
			iBoardRevealTypeTop	= REVEAL_NEGATIVE
		endif
	else
		if ABS(revealBoardTop) < EPS then
			iBoardRevealTypeTop	= REVEAL_BOARDSPLAYNULL
		else
			iBoardRevealTypeTop	= REVEAL_BOARDSPLAYNEG
		endif
	endif

	if gs_reveal_bottom_angle < EPS then
		if ABS(revealBoardBottom) < EPS then
			iBoardRevealTypeBottom	= REVEAL_NO
		else
			iBoardRevealTypeBottom	= REVEAL_NEGATIVE
		endif
	else
		if ABS(revealBoardBottom) < EPS then
			iBoardRevealTypeBottom	= REVEAL_BOARDSPLAYNULL
		else
			iBoardRevealTypeBottom	= REVEAL_BOARDSPLAYNEG
		endif
	endif
endif

if iRevealTypeForDisplay = REVEAL_DOUBLE then
	if ABS(revealBoardLeft) < EPS then
		iBoardRevealTypeLeft	= REVEAL_NO
	else
		iBoardRevealTypeLeft	= iBoardRevealType
	endif

	if ABS(revealBoardRight) < EPS then
		iBoardRevealTypeRight	= REVEAL_NO
	else
		iBoardRevealTypeRight	= iBoardRevealType
	endif

	if ABS(revealBoardTop) < EPS then
		iBoardRevealTypeTop	= REVEAL_NO
	else
		iBoardRevealTypeTop	= iBoardRevealType
	endif

	if ABS(revealBoardBottom) < EPS then
		iBoardRevealTypeBottom	= REVEAL_NO
	else
		iBoardRevealTypeBottom	= iBoardRevealType
	endif
endif

if abs(WALL_INCL) < EPS & WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS < EPS then
	iBoardRevealTypeLeft	= REVEAL_NO
	iBoardRevealTypeRight	= REVEAL_NO
	iBoardRevealTypeTop		= REVEAL_NO
	iBoardRevealTypeBottom	= REVEAL_NO
endif

if iBoardRevealTypeLeft = REVEAL_NO then
	revealBoardLeft = 0
endif

if iBoardRevealTypeRight = REVEAL_NO then
	revealBoardRight = 0
endif

if iBoardRevealTypeTop = REVEAL_NO then
	revealBoardTop = 0
endif

if iBoardRevealTypeBottom = REVEAL_NO then
	revealBoardBottom = 0
endif


! --- for TurnPlaster macro ------------

if iBoardRevealTypeLeft = REVEAL_NEGATIVE | iBoardRevealTypeLeft = REVEAL_BOARDSPLAYNEG then
	bAddPoint[3] = 1
else
	bAddPoint[3] = 0
endif

if iBoardRevealTypeRight = REVEAL_NEGATIVE | iBoardRevealTypeRight = REVEAL_BOARDSPLAYNEG then
	bAddPoint[4] = 1
else
	bAddPoint[4] = 0
endif


! ==============================================================================
! Parameter Restrictions - only for the 2D and 3D scripts
! ==============================================================================

if GLOB_SCRIPT_TYPE = 2 | GLOB_SCRIPT_TYPE = 3 then
	if iRevealTypeForDisplay = REVEAL_EDGE | \
		iRevealTypeForDisplay = REVEAL_NO | \
		iRevealTypeForDisplay = REVEAL_SPLAYED then

		gs_reveal_left		= 0
		gs_reveal_right		= 0
		gs_reveal_top		= 0
		gs_reveal_bottom	= 0
		bottomJamb			= 0
		topJamb				= 0
	endif

	if	iRevealTypeForDisplay = REVEAL_EDGE | \
		iRevealTypeForDisplay = REVEAL_NO | \
		iRevealTypeForDisplay = REVEAL_POSITIVE | \
		iRevealTypeForDisplay = REVEAL_NEGATIVE | \
		iRevealTypeForDisplay = REVEAL_DOUBLE | \
		iRevealTypeForDisplay = REVEAL_OUTSIDE_SPLAYED then

		gs_reveal_left_angle	= 0
		gs_reveal_right_angle	= 0
		gs_reveal_top_angle		= 0
		gs_reveal_bottom_angle	= 0
	endif

	if iRevealTypeForDisplay = REVEAL_EDGE | \
		iRevealTypeForDisplay = REVEAL_NO | \
		iRevealTypeForDisplay = REVEAL_POSITIVE | \
		iRevealTypeForDisplay = REVEAL_NEGATIVE | \
		iRevealTypeForDisplay = REVEAL_SLANTED | \
		iRevealTypeForDisplay = REVEAL_DOUBLE_SPLAYED | \
		iRevealTypeForDisplay = REVEAL_OUTSIDE_SPLAYED then

		revealBoardLeft					= 0
		revealBoardRight				= 0
		revealBoardTop					= 0
		revealBoardBottom				= 0
		gs_reveal_splayed_innerTop		= 0
		gs_reveal_splayed_innerBottom	= 0
		gs_reveal_double_innerTop		= 0
		gs_reveal_double_innerBottom	= 0
	endif

	if WIDO_SILL < EPS & (iRevealTypeForDisplay = REVEAL_POSITIVE | iRevealTypeForDisplay = REVEAL_NEGATIVE) then
		iRevealTypeForDisplay = REVEAL_NO
	endif
endif


! ==============================================================================
! Calculations for Trapezoid Walls
! ==============================================================================

if abs(WALL_INCL) > EPS then
	bInclinedWall = 1
	bInclDir = SYMB_MIRRORED exor (SYMB_ROTANGLE > EPS)	! (0 / 1)
	iInclDir = not(bInclDir) - bInclDir					! (1 / -1)

	incH = cos(WALL_INCL)
	incV = sin(WALL_INCL) * iInclDir

	incHor = tan(WALL_INCL)
else
	bInclinedWall = 0

	bInclDir	= 0
	iInclDir	= 0
	incH		= 0
	incV		= 0
	incHor		= 0
endif


! ==============================================================================
! Calculations for Curved Walls
! ==============================================================================

ySign = 1

if curvedWall then
	signRotangle = not(bRotAngle180) - bRotAngle180

	WOD = abs(WIDO_ORIG_DIST) - (SYMB_ROTANGLE > EPS) * WIDO_FRAME_THICKNESS

	leftAlfa	= atn(leftWidth  / WOD)
	rightAlfa	= atn(rightWidth / WOD)

	bArchSign = (WIDO_REVEAL_SIDE exor SYMB_ROTANGLE > EPS)
	iArchSign = bArchSign - not(bArchSign)		! 1 / -1

	WOD = abs(WIDO_ORIG_DIST) + iArchSign * WIDO_REVEAL_SIDE * WIDO_FRAME_THICKNESS

	if WIDO_REVEAL_SIDE exor SYMB_ROTANGLE < EPS then
		ySign = 1
		radSill = sqr(refWidth^2 / 4 + WOD^2) - WIDO_SILL
		radBoard = radSill + WALL_THICKNESS
	else
		ySign = -1
		radSill = sqr(refWidth^2 / 4 + WOD^2) + WIDO_SILL
		radBoard = radSill - WALL_THICKNESS
	endif

	radSillLine = radSill - iArchSign * (WIDO_SILL - SymbolMid_shiftDy)	! Radius of the reveal at the Sill depth
	radBoardLine = radSillLine - iArchSign * WIDO_FRAME_THICKNESS

	ArcLengthSillToAngle	= 180 / radSill / PI
	ArcLengthBoardToAngle	= 180 / radBoard / PI

	alfaLeftJamb	= leftJamb  * ArcLengthSillToAngle
	alfaRightJamb	= rightJamb * ArcLengthSillToAngle

	! Ganging
	if bGangingLeft then
		leftJamb	= 0
		leftBoardAngle	= -signWallIsLeft * leftAlfa
	endif
	if bGangingRight then
		rightJamb	= 0
		rightBoardAngle	= -signWallIsLeft * rightAlfa
	endif

	! Jamb arch length projection onto the X axis
	if bParalellInCurvedWalls then
		dxLeftJamb	= leftJamb - bGangingLeft * wallIsLeft * WIDO_FRAME_THICKNESS * tan(leftAlfa)
		dxRightJamb	= rightJamb - bGangingRight * wallIsLeft * WIDO_FRAME_THICKNESS * tan(rightAlfa)
		dxLeft		= 0
		dxRight		= 0
	else
		dxLeftJamb	= leftWidth  - abs(WOD * tan(leftAlfa  - alfaLeftJamb * not(bGangingLeft)))
		dxRightJamb	= rightWidth - abs(WOD * tan(rightAlfa - alfaRightJamb * not(bGangingRight)))
		dxLeft		= bArchSign * (iRevealTypeForDisplay <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS * tan(leftAlfa)
		dxRight		= bArchSign * (iRevealTypeForDisplay <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS * tan(rightAlfa)
	endif

	! --- Calculations for Curved Windows ---

	if bWndCurved then
		WndCx1 = -radSillLine * sin(leftAlfa)
		WndCy1 = iArchSign * (WOD - radSillLine * cos(leftAlfa))
		WndCx2 = -leftWidth - not(bArchSign) * WIDO_FRAME_THICKNESS * tan(leftAlfa)
		WndCy2 = WIDO_FRAME_THICKNESS
		dr = WIDO_FRAME_THICKNESS - SQR((WndCx1 - WndCx2)^2 + (WndCy1 - WndCy2)^2)
		drx = dr * sin(leftAlfa)
		dry = dr * cos(leftAlfa)

		ArcLengthSillLineToAngle	= 180 / radSillLine / PI
		alfaLeftPlasterAtSillLineAdd	= thkPlasterAtSillLeft * ArcLengthSillLineToAngle
		alfaRightPlasterAtSillLineAdd	= thkPlasterAtSillRight * ArcLengthSillLineToAngle

		ArcLengthBoardLineToAngle	= 180 / radBoardLine  / PI
		alfaLeftBoardLineReveal		= abs(revealBoardLeft * ArcLengthBoardLineToAngle)
		alfaRightBoardLineReveal	= abs(revealBoardRight * ArcLengthBoardLineToAngle)
	endif
else
	iArchSign = 0

	radSill		= 0
	radBoard	= 0
	bArchSign	= 0
	iArchSign	= 0
	WOD			= 0

	leftAlfa		= 0
	rightAlfa		= 0
	alfaLeftJamb	= 0
	alfaRightJamb	= 0

	dxLeftJamb	= leftJamb
	dxRightJamb	= rightJamb - bCornerWindow * 2.0		! 2.0 m is large enough
	dxLeft 		= 0
	dxRight		= bCornerWindow * 2.0					! 2.0 m is large enough
endif


! ==============================================================================
! Calculations for Corner Window
! ==============================================================================

if bRightCornerFunction & abs(rightCornerAngle) > EPS then
	rx = 1 / tan(rightCornerAngle / 2)

	if rightCornerAngle > 180 then
		rightCwDx = WIDO_FRAME_THICKNESS / tan(-rightCornerAngle / 2)
	else
		rightCwDx = 0
	endif

	rightCwDx2 = 0
	if abs(WALL_THICKNESS - rightConnWallThk) > EPS then
		rightCwDx2 = (WALL_THICKNESS - rightConnWallThk) / cos(rightCornerAngle - 90)
	endif
!!!	bFitMode = (rightConnWallThk > WALL_THICKNESS + EPS)
endif

if bLeftCornerFunction & abs(leftCornerAngle) > EPS then
	lx = 1 / tan(leftCornerAngle / 2)

	if leftCornerAngle > 180 then
		leftCwDx = WIDO_FRAME_THICKNESS / tan(-leftCornerAngle / 2)
	else
		leftCwDx = 0
	endif

	leftCwDx2 = 0
	if abs(WALL_THICKNESS - leftConnWallThk) > EPS then
		leftCwDx2 = (WALL_THICKNESS - leftConnWallThk) / cos(leftCornerAngle - 90)
	endif
!!!	bFitMode = (leftConnWallThk > WALL_THICKNESS + EPS)
endif



! ==============================================================================
!
!  R E V E A L   P O I N T S   C A L C U L A T I O N
!
! ==============================================================================

! --- Initialization --------------------------------

sxL     = 0 : syL   = 0		: sxR     = 0 : syR   = 0
smxL    = 0 : smyL  = 0		: smxR    = 0 : smyR  = 0
psxL    = 0 : psyL  = 0		: psxR    = 0 : psyR  = 0
psmxL   = 0 : psmyL = 0		: psmxR   = 0 : psmyR = 0
psfxL   = 0 : psfyL = 0		: psfxR   = 0 : psfyR = 0
bPmOutOfWallLeft = 0		: bPmOutOfWallRight = 0


! ==============================================================================
! = = =  L E F T    S I D E  = = = = = = = = = = = = = = = = = = = = = = = = = =
! ==============================================================================


! ==============================================================================
! Reveal & Plaster Points - Corner Window
! ==============================================================================

if bLeftCornerFunction & abs(leftCornerAngle) > EPS then

	sfxL = -leftWidth - leftCwDx - WIDO_FRAME_THICKNESS * lx - SymbolMid_shiftDy / tan(leftCornerAngle/2)
	sfyL = -SymbolMid_shiftDy
	sxL = sfxL
	syL = sfyL
	if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) & gs_mountingFrame then
		sfMFrxL = -leftWidth - leftCwDx - (WIDO_FRAME_THICKNESS + gs_mountingFrame_depth) * lx - SymbolMid_shiftDy / tan(leftCornerAngle/2)
		sfMFryL = -SymbolMid_shiftDy - gs_mountingFrame_depth
		smxL = sfMFrxL
		smyL = sfMFryL
		psfxL = sfMFrxL
		psfyL = sfMFryL
		psmxL = sfMFrxL
		psmyL = sfMFryL
	else
		smxL = sfxL
		smyL = sfyL
		psxL = sfxL
		psyL = sfyL
		psfxL = sfxL
		psfyL = sfyL
		psmxL = sfxL
		psmyL = sfyL
	endif

	swxL = -leftWidth - leftCwDx - (WIDO_FRAME_THICKNESS + WIDO_SILL) * lx
	swyL = -WIDO_SILL
	pswxL = swxL
	pswyL = swyL

	bwxL = -leftWidth - leftCwDx - leftCwDx2 + (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS) * lx
	bwyL = -WIDO_SILL + WALL_THICKNESS
	pbwxL = bwxL
	pbwyL = bwyL

	bfxL = -leftWidth - leftCwDx - SymbolMid_shiftDy / tan(leftCornerAngle/2)
	bfyL = WIDO_FRAME_THICKNESS - SymbolMid_shiftDy
	bxL = bfxL
	byL = bfyL
	pbxL = bfxL
	pbyL = bfyL
	pbfxL = bfxL
	pbfyL = bfyL
	pbexL = bfxL
	pbeyL = bfyL

else

	! =====================================================================================
	! Left Sill Reveal & Plaster Points for all wall & reveal types
	! =====================================================================================

	! --- LEFT SILL - ALL REVEAL TYPES - "sf" point ---------------------------------------

	if curvedWall then
		if bWndCurved then
			sfxL = -radSillLine * sin(leftAlfa)
			sfyL = iArchSign * (WOD - (radSillLine) * cos(leftAlfa))
		else
			if bGangingLeft then
				sfxL = -leftWidth - wallIsLeft * WIDO_FRAME_THICKNESS * tan(leftAlfa) - signWallIsLeft * SymbolMid_shiftDy * tan(leftAlfa)
			else
				sfxL = -leftWidth - dxLeft - signWallIsLeft * SymbolMid_shiftDy * tan(leftAlfa) * (iBoardRevealTypeLeft <> REVEAL_SLANTED)
			endif
			sfyL = -SymbolMid_shiftDy
		endif
	else
		sfxL = -leftWidth - dxLeft
		sfyL = -SymbolMid_shiftDy
	endif

	if gs_mountingFrame then
		sfMFrxL = sfxL - gs_mountingFrame_depth * tan(leftAlfa)	* (not(bParalellInCurvedWalls) | bGangingLeft) * iArchSign
		sfMFryL = sfyL - gs_mountingFrame_depth
	endif


	! --- LEFT SILL - REVEAL POSITIVE & NEGATIVE & SPLAYED - "s" point --------------------

	if iSillRevealTypeLeft = REVEAL_POSITIVE | iSillRevealTypeLeft = REVEAL_NEGATIVE | iSillRevealTypeLeft = REVEAL_SILLSPLAYED then
		if curvedWall & bWndCurved then
			sxL = -radSillLine * sin(leftAlfa - alfaLeftJamb * not(bGangingLeft))
			syL = iArchSign * (WOD - (radSillLine) * cos(leftAlfa  - alfaLeftJamb * not(bGangingLeft)))
		else
			if curvedWall & bParalellInCurvedWalls then
				sxL = -leftWidth + dxLeftJamb ! - bGangingLeft * wallIsLeft * WIDO_FRAME_THICKNESS * tan(leftAlfa)
				syL = 0
			else
				sxL = -leftWidth + dxLeftJamb * MIN(1, (not(bGangingLeft) + curvedWall))  - SymbolMid_shiftDy * tan(leftAlfa-(alfaLeftJamb * not(bGangingLeft))) * signWallIsLeft
				syL = -SymbolMid_shiftDy
			endif
		endif
	endif


	! --- LEFT SILL - REVEAL SPLAYED & SPLAYNULL - "sm" point -----------------------------

	if iSillRevealTypeLeft = REVEAL_SILLSPLAYED | iSillRevealTypeLeft = REVEAL_SILLSPLAYNULL then
		if curvedWall & not(bParalellInCurvedWalls & not(bGangingLeft)) then
			if iSillRevealTypeLeft = REVEAL_SILLSPLAYED & not(bGangingLeft) then
				smxL = sxL + iArchSign * gs_reveal_outer_jamb_depth * sxL  / WOD
			else
				smxL = sfxL + iArchSign * gs_reveal_outer_jamb_depth * sfxL  / WOD
			endif
			smyL = -gs_reveal_outer_jamb_depth
		else
			smxL = -leftWidth  + dxLeftJamb * not(bGangingLeft)
			smyL = -gs_reveal_outer_jamb_depth
		endif
	endif


	! --- LEFT SILL - REVEAL NO - "sw" & "psw" points -------------------------------------

	if iSillRevealTypeLeft = REVEAL_NO then
		if curvedWall then
			if bParalellInCurvedWalls & not(bGangingLeft) then
				swxL = -leftWidth
				swyL = ySign * (sqr(radSill^2 - swxL^2) - WOD)

				pswxL = swxL + thkPlasterAtSillLeft
				pswyL = swyL
			else
				swxL = -radSill * sin(leftAlfa)
				swyL = ySign * (radSill * cos(leftAlfa) - WOD)

				if thkPlasterAtSillLeft > EPS & not(bGangingLeft) then
					x1 = swxL + thkPlasterAtSillLeft * cos(leftAlfa)
					y1 = swyL - iArchSign * thkPlasterAtSillLeft * sin(leftAlfa)
					x2 = x1 - radSill * sin(leftAlfa)
					y2 = y1 - iArchSign * radSill * cos(leftAlfa)

					ro = radSill
					xo = 0
					yo = iArchSign * WOD

					gosub 101	! Circle - Line intersection
					gosub 102	! Select good intersection point

					pswxL = cx
					pswyL = cy
				else
					pswxL = swxL
					pswyL = swyL
				endif
			endif
		else
			swxL = -leftWidth
			swyL = -WIDO_SILL
			pswxL = swxL + not(bGangingLeft) * thkPlasterAtSillLeft
			pswyL = swyL
		endif
	endif


	! --- LEFT SILL - REVEAL POSITIVE & NEGATIVE - "sw" point -----------------------------

	if iSillRevealTypeLeft = REVEAL_POSITIVE | iSillRevealTypeLeft = REVEAL_NEGATIVE then
		if curvedWall then
			if bParalellInCurvedWalls & not(bGangingLeft) then
				swxL = -leftWidth + dxLeftJamb
				swyL = ySign * (sqr(radSill^2 - swxL^2) - WOD)
			else
				swxL = -radSill * sin(leftAlfa - alfaLeftJamb * not(bGangingLeft))
				swyL = ySign * (radSill * cos(leftAlfa - alfaLeftJamb * not(bGangingLeft)) - WOD)
			endif
		else
			swxL = -leftWidth + dxLeftJamb * not(bGangingLeft)
			swyL = -WIDO_SILL
		endif
	endif


	! --- LEFT SILL - REVEAL SPLAYED & REVEAL SPLAYNULL - "sw" point ----------------------

	if iSillRevealTypeLeft = REVEAL_SILLSPLAYED | iSillRevealTypeLeft = REVEAL_SILLSPLAYNULL then
		if curvedWall then
			swAlpha = atn(smxL/(WOD+gs_reveal_outer_jamb_depth*iArchSign)) * not(bParalellInCurvedWalls & not(bGangingLeft)) * iArchSign - leftSillAngle * not(bGangingLeft)

			x1 = smxL
			y1 = smyL
			x2 = smxL - sin(swAlpha)
			y2 = smyL + cos(swAlpha)

			ro = radSill
			xo = 0
			yo = iArchSign * WOD

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point

			swxL = cx
			swyL = cy
		else
			swyL = -WIDO_SILL
			swxL = smxL - not(bGangingLeft) * (smyL - swyL) * tan(leftSillAngle)
		endif
	endif


	! --- LEFT SILL - REVEAL NO & POSITIVE & NEGATIVE - all plaster points ----------------

	if iSillRevealTypeLeft = REVEAL_NO | iSillRevealTypeLeft = REVEAL_POSITIVE | iSillRevealTypeLeft = REVEAL_NEGATIVE then
		if curvedWall then
			x1 = swxL : y1 = swyL
			if iSillRevealTypeLeft = REVEAL_NO then
				x2 = sfxL  : y2 = sfyL
			else
				x2 = sxL  : y2 = syL
			endif
			nv		= thkPlasterAtSillLeft
			iDrag	= signWallIsLeft * ySign

			gosub 103	! Line dragging with a normal vector

			if bParalellInCurvedWalls then
				psxL = x4
				psyL = y4
			else
				if bWndCurved then
					x1 = x3	: y1 = y3
					x2 = x4	: y2 = y4

					ro = radSillLine
					xo = 0
					yo = iArchSign * WOD

					gosub 101	! Circle - Line intersection
					gosub 102	! Select good intersection point

					psxL = cx
					psyL = cy
				else
					x11 = x3	: y11 = y3
					x12 = x4	: y12 = y4
					x21 = 0		: y21 = -SymbolMid_shiftDy
					x22 = -1	: y22 = -SymbolMid_shiftDy

					gosub 100	! Line - Line intersection

					if state = 1 & cx < 0 then
						psxL = cx
						psyL = cy
					else
						psxL = 0
						psyL = 0
					endif
				endif
			endif

			x1 = x3
			y1 = y3
			x2 = x4
			y2 = y4

			ro = radSill
			xo = 0
			yo = iArchSign * WOD

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point

			pswxL = cx
			pswyL = cy
		else
			pswxL = swxL + thkPlasterAtSillLeft
			pswyL = swyL

			if iSillRevealTypeLeft = REVEAL_NO then
				psxL = sfxL + thkPlasterAtSillLeft
				psyL = sfyL
			else
				psxL = sxL + thkPlasterAtSillLeft
				psyL = syL
			endif
		endif


		! --- LEFT SILL - REVEAL NEGATIVE, additional plaster points ----------------------

		if iSillRevealTypeLeft = REVEAL_NEGATIVE then
			if curvedWall & bWndCurved then
				x1 = pswxL	: y1 = pswyL
				x2 = psxL	: y2 = psyL

				ro = radSillLine + thkPlasterAtSillLeft * iArchSign
				xo = 0
				yo = iArchSign * WOD

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point

				psxL = cx
				psyL = cy

				psfxL = -radSillLine * sin(leftAlfa  - alfaLeftPlasterAtSillLineAdd)
				psfyL = iArchSign * (WOD - radSillLine * cos(leftAlfa  - alfaLeftPlasterAtSillLineAdd))

				psmxL = -(radSillLine + thkPlasterAtSillLeft * iArchSign) * sin(leftAlfa  - alfaLeftPlasterAtSillLineAdd)
				psmyL = iArchSign * (WOD - (radSillLine + thkPlasterAtSillLeft * iArchSign) * cos(leftAlfa  - alfaLeftPlasterAtSillLineAdd))
			else
				psfxL = sfxL + thkPlasterAtSillLeft
				psfyL = sfyL

				psmxL = psfxL
				psmyL = psfyL - thkPlasterAtSillLeft

				if curvedWall & not(bParalellInCurvedWalls) then
					x11 = pswxL		: y11 = pswyL
					x12 = psxL		: y12 = psyL
					x21 = psmxL		: y21 = psmyL
					x22 = psmxL - 1	: y22 = psmyL

					gosub 100	! Line - Line intersection

					if state = 1 & cx < 0 then
						psxL = cx
						psyL = cy
					else
						psxL = 0
						psyL = 0
					endif
				else
					psxL = psxL
					psyL = psyL - thkPlasterAtSillLeft
				endif
			endif
		endif
	endif


	! --- LEFT SILL - REVEAL SILLSPLAYED & SILLSPLAYNULL - all plaster points -------------

	if iSillRevealTypeLeft = REVEAL_SILLSPLAYED | iSillRevealTypeLeft = REVEAL_SILLSPLAYNULL then
		if bGangingLeft then
			if iSillRevealTypeLeft = REVEAL_SILLSPLAYED then
				psxL = sxL
				psyL = syL
			else
				if gs_mountingFrame then
					psfxL = sfMFrxL
					psfyL = sfMFryL
				else
					psfxL = sfxL
					psfyL = sfyL
				endif
			endif

			psmxL = smxL
			psmyL = smyL
			pswxL = swxL
			pswyL = swyL
		else
			if curvedWall then
				x1 = smxL : y1 = smyL
				if iSillRevealTypeLeft = REVEAL_SILLSPLAYED then
					x2 = sxL  : y2 = syL
				else
					x2 = sfxL  : y2 = sfyL
				endif
				nv		= thkPlasterAtSillLeft
				iDrag	= signWallIsLeft * ySign

				gosub 103	! Line dragging with a normal vector

				x11 = x3	: y11 = y3
				x12 = x4	: y12 = y4
				x21 = 0		: y21 = -gs_mountingFrame * gs_mountingFrame_depth
				x22 = -1	: y22 = -gs_mountingFrame * gs_mountingFrame_depth

				gosub 100	! Line - Line intersection

				if state = 1 & cx < 0 then
					if iSillRevealTypeLeft = REVEAL_SILLSPLAYED then
						psxL = cx
						psyL = cy
					else
						psfxL = cx
						psfyL = cy
					endif
				else
					if iSillRevealTypeLeft = REVEAL_SILLSPLAYED then
						psxL = 0
						psyL = 0
					else
						psfxL = 0
						psfyL = 0
					endif
				endif

				x1 = swxL : y1 = swyL
				x2 = smxL : y2 = smyL
				nv		= thkPlasterAtSillLeft
				iDrag	= signWallIsLeft * ySign

				gosub 103	! Line dragging with a normal vector

				x21 = x3 : y21 = y3
				x22 = x4 : y22 = y4

				gosub 100	! Line - Line intersection

				if state = 1 & cx < 0 then
					psmxL = cx
					psmyL = cy
				else
					psmxL = 0
					psmyL = 0
				endif


				! --- checking wrong (outside of wall) points

				if iSillRevealTypeLeft = REVEAL_SILLSPLAYED then
					x1 = psxL	: y1 = psyL
				else
					x1 = psfxL	: y1 = psfyL
				endif

				x2 = psmxL : y2 = psmyL

				ro = radSill
				xo = 0
				yo = iArchSign * WOD

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point

				pxWallEdgeL = cx
				pyWallEdgeL = cy

				if psmyL - pyWallEdgeL < EPS then
					bPmOutOfWallLeft = 1
				endif

				! --- end of checking wrong (outside of wall) points


				x1 = x3 : y1 = y3
				x2 = x4 : y2 = y4

				ro = radSill
				xo = 0
				yo = iArchSign * WOD

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point

				if bPmOutOfWallLeft then
					pswxL = pxWallEdgeL
					pswyL = pyWallEdgeL
				else
					pswxL = cx
					pswyL = cy
				endif
			else
				if iSillRevealTypeLeft = REVEAL_SILLSPLAYED then
					psxL = sxL + thkPlasterAtSillLeft
					psyL = syL
				else
					psfxL = sfxL + thkPlasterAtSillLeft
					psfyL = sfyL - gs_mountingFrame * gs_mountingFrame_depth
				endif

				x1 = swxL	: y1 = swyL
				x2 = smxL	: y2 = smyL
				nv		=  thkPlasterAtSillLeft
				iDrag   = -1

				gosub 103	! Line dragging with a normal vector

				x11 = x3	: y11 = y3
				x12 = x4	: y12 = y4

				if iSillRevealTypeLeft = REVEAL_SILLSPLAYED then
					x21 = psxL	: y21 = psyL
					x22 = psxL	: y22 = psyL + 1
				else
					x21 = psfxL	: y21 = psfyL
					x22 = psfxL	: y22 = psfyL + 1
				endif

				gosub 100	! Line - Line intersection

				if state = 1 & cx < 0 then
					if cy + WIDO_SILL < EPS then
						bPmOutOfWallLeft = 1
						psmxL = cx
						psmyL = -WIDO_SILL
					else
						psmxL = cx
						psmyL = cy
					endif
				else
					psmxL = 0
					psmyL = 0
				endif

				pswyL = -WIDO_SILL
				pswxL = psmxL - not(bGangingLeft) * (WIDO_SILL + psmyL) * tan(leftSillAngle)
			endif
		endif
	endif


	! =====================================================================================
	! Left Board Reveal & Plaster Points for all wall & reveal types
	! =====================================================================================

	! --- LEFT BOARD - ALL REVEAL TYPES - "bf" & "pb" points ------------------------------

	if iBoardRevealTypeLeft = REVEAL_SLANTED then
		if curvedWall & bWndCurved then
			x1 = sfxL
			y1 = sfyL
			x2 = sfxL - sin(leftBoardAngle)
			y2 = sfyL + cos(leftBoardAngle)

			ro = radBoardLine
			xo = 0
			yo = iArchSign * WOD

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point

			bfxL = cx
			bfyL = cy
		else
			if curvedWall then
				bfxL = -leftWidth - not(bGangingLeft & wallIsLeft) * WIDO_FRAME_THICKNESS * tan(leftBoardAngle) + bGangingLeft * SymbolMid_shiftDy * tan(leftBoardAngle)
			else
				bfxL = -leftWidth - not(bGangingLeft) * WIDO_FRAME_THICKNESS * tan(leftBoardAngle)
			endif
			bfyL = WIDO_FRAME_THICKNESS - SymbolMid_shiftDy

		endif
	else
		if curvedWall & (not(bParalellInCurvedWalls) | bGangingLeft) then
			if bWndCurved then
				bfxL = sfxL + iArchSign * WIDO_FRAME_THICKNESS * sin(leftAlfa)
				bfyL = sfyL + WIDO_FRAME_THICKNESS * cos(leftAlfa)

				if thkPlasterAtBoardLeft > EPS & not(bGangingLeft) then
					x1 = bfxL + thkPlasterAtBoardLeft * cos(leftAlfa)
					y1 = bfyL - iArchSign * thkPlasterAtBoardLeft * sin(leftAlfa)
					x2 = x1 - sin(leftAlfa)
					y2 = y1 - iArchSign * cos(leftAlfa)

					ro = radSillLine - SQR((sfyL - bfyL)^2 + (sfxL - bfxL)^2) * iArchSign
					xo = 0
					yo = iArchSign * WOD

					gosub 101	! Circle - Line intersection
					gosub 102	! Select good intersection point

					pbxL = cx
					pbyL = cy
				else
					pbxL = bfxL
					pbyL = bfyL
				endif
			else
				bfxL = -leftWidth - not(bArchSign) * WIDO_FRAME_THICKNESS * tan(leftAlfa) - signWallIsLeft * SymbolMid_shiftDy * tan(leftAlfa)
				bfyL = WIDO_FRAME_THICKNESS - SymbolMid_shiftDy

				pbxL = bfxL + not(bGangingLeft) * thkPlasterAtBoardLeft / cos(leftAlfa)
				pbyL = bfyL
			endif
		else
			bfxL = -leftWidth
			bfyL = WIDO_FRAME_THICKNESS - SymbolMid_shiftDy
			pbxL = bfxL + not(bGangingLeft) * thkPlasterAtBoardLeft
			pbyL = bfyL
		endif
	endif


	! --- LEFT BOARD - REVEAL POSITIVE & NEGATIVE & SPLAYNULL & SPLAYNEG - "b" point ------

	if iBoardRevealTypeLeft = REVEAL_POSITIVE | iBoardRevealTypeLeft = REVEAL_NEGATIVE | \
	 iBoardRevealTypeLeft = REVEAL_BOARDSPLAYNULL | iBoardRevealTypeLeft = REVEAL_BOARDSPLAYNEG then
		if curvedWall & bWndCurved then
			bxL = -radBoardLine * sin(leftAlfa + alfaLeftBoardLineReveal * not(bGangingLeft))
			byL = iArchSign * (WOD - radBoardLine * cos(leftAlfa  + alfaLeftBoardLineReveal * not(bGangingLeft)))
		else
			bxL = bfxL + revealBoardLeft * not(bGangingLeft)
			byL = bfyL
		endif
	endif


	! --- LEFT BOARD - REVEAL NO - "bw" & "pbw" points ------------------------------------

	if iBoardRevealTypeLeft = REVEAL_NO then
		if curvedWall then
			if bParalellInCurvedWalls & not(bGangingLeft) then
				bwxL = -leftWidth
				bwyL = ySign * (sqr(radBoard^2 - bwxL^2) - WOD)
			else
				bwxL = -radBoard * sin(leftAlfa)
				bwyL = ySign * (radBoard * cos(leftAlfa) - WOD)
			endif

			if thkPlasterAtBoardLeft > EPS & not(bGangingLeft) then
				if bParalellInCurvedWalls & not(bGangingLeft) then
					x1 = bwxL + thkPlasterAtBoardLeft
					y1 = bwyL
					x2 = bwxL + thkPlasterAtBoardLeft
					y2 = bwyL + 1
				else
					x1 = bwxL + thkPlasterAtBoardLeft * cos(leftAlfa)
					y1 = bwyL - iArchSign * thkPlasterAtBoardLeft * sin(leftAlfa)
					x2 = x1 - radBoard * sin(leftAlfa)
					y2 = y1 - iArchSign * radBoard * cos(leftAlfa)
				endif

				ro = radBoard
				xo = 0
				yo = iArchSign * WOD

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point

				pbwxL = cx
				pbwyL = cy
			else
				pbwxL = bwxL
				pbwyL = bwyL
			endif
		else
			bwxL = -leftWidth
			bwyL = -WIDO_SILL + WALL_THICKNESS + bwxL * incHor * iInclDir * bInclinedWall
			pbwxL = bwxL + not(bGangingLeft) * thkPlasterAtBoardLeft
			pbwyL = bwyL + not(bGangingLeft) * thkPlasterAtBoardLeft * incHor * iInclDir * bInclinedWall
		endif
	endif


	! --- LEFT BOARD - REVEAL SLANTED &  SPLAYNULL &  SPLAYNEG - "bw" point ---------------

	if iBoardRevealTypeLeft = REVEAL_SLANTED | iBoardRevealTypeLeft = REVEAL_BOARDSPLAYNULL | \
	 iBoardRevealTypeLeft = REVEAL_BOARDSPLAYNEG then
		if curvedWall then
			if iBoardRevealTypeLeft = REVEAL_SLANTED then
				x1 = sfxL
			else
				x1 = bxL + WIDO_FRAME_THICKNESS * tan(leftBoardAngle)
			endif
			y1 = sfyL
			x2 = x1 - tan(leftBoardAngle)
			y2 = 1 - SymbolMid_shiftDy

			xo = 0
			yo = -ySign * WOD
			ro = radBoard

			gosub 101	! Circle - Line intersection

			if state = 0 then
				bwxL = x1 - WOD * tan(leftBoardAngle)
				bwyL = -ySign * WOD
			endif
			if state = 1 then
				bwxL = xa
				bwyL = ya
			endif
			if state = 2 then
				if ya > yb exor bArchSign then
					bwxL = xa
					bwyL = ya
				else
					bwxL = xb
					bwyL = yb
				endif
			endif
		else
			if bInclinedWall then
				x11 = 0
				y11 = -WIDO_SILL + WALL_THICKNESS
				x12 = 1
				y12 = y11 + iInclDir * incHor

				if iBoardRevealTypeLeft = REVEAL_SLANTED then
					x21 = sfxL
				else
					x21 = bxL + not(bGangingLeft) * WIDO_FRAME_THICKNESS * tan(leftBoardAngle)
				endif
				y21 = sfyL
				x22 = x21 - not(bGangingLeft) * tan(leftBoardAngle)
				y22 = 1 - SymbolMid_shiftDy

				gosub 100	! Line - Line intersection

				if state = 1 & cx < 0 then
					bwxL = cx
					bwyL = cy
					bDoneL = 1
				else
					bwxL = 0
					bwyL = 0
					bDoneL = 0
				endif

				if iBoardRevealTypeLeft = REVEAL_SLANTED then
					x21 = sfxL
				else
					x21 = bxL + not(bGangingLeft) * WIDO_FRAME_THICKNESS * tan(leftBoardAngle)
				endif
				y21 = sfyR
				x22 = x21 - not(bGangingLeft) * tan(leftBoardAngle)
				y22 = 1 - SymbolMid_shiftDy

				gosub 100	! Line - Line intersection

				if state = 1 & cx > 0 then
					bwxR2 = cx
					bDoneR = 1
				else
					bwxR2 = 0
					bDoneR = 0
				endif

				if not(bDoneL) & bDoneR then
					bwyL = bwyR2
					bwxL = -leftWidth - bwyL * tan(leftBoardAngle)
				endif
			else
				bwyL = -WIDO_SILL + WALL_THICKNESS
				if iBoardRevealTypeLeft = REVEAL_SLANTED then
					bwxL = -leftWidth - not(bGangingLeft) * (bwyL + SymbolMid_shiftDy) * tan(leftBoardAngle)
				else
					bwxL = bxL - not(bGangingLeft) * (bwyL - WIDO_FRAME_THICKNESS + SymbolMid_shiftDy) * tan(leftBoardAngle)
				endif
			endif
		endif
	endif


	! --- LEFT BOARD - REVEAL POSITIVE & NEGATIVE - "bw" point ----------------------------

	if iBoardRevealTypeLeft = REVEAL_POSITIVE | iBoardRevealTypeLeft = REVEAL_NEGATIVE then
		if curvedWall then
			if bParalellInCurvedWalls & not(bGangingLeft) then
				bwxL = bxL
				bwyL = ySign * (sqr(radBoard^2 - bxL^2) - WOD)
			else
				xo = 0
				yo = -ySign * (WOD)
				ro = radBoard
				x1 = bxL
				y1 = byL
				x2 = 0
				y2 = -ySign * WOD

				gosub 101	! Circle - Line intersection

				if state = 0 then
					bwxL = x1 - WOD * tan(leftBoardAngle)
					bwyL = -ySign * WOD
				endif
				if state = 1 then
					bwxL = xa
					bwyL = ya
				endif
				if state = 2 then
					if ya > yb exor bArchSign then
						bwxL = xa
						bwyL = ya
					else
						bwxL = xb
						bwyL = yb
					endif
				endif
			endif
		else
			if bInclinedWall then
				bwxL = bxL
				bwyL = -WIDO_SILL + WALL_THICKNESS + bwxL * incHor * iInclDir
			else
				bwxL = bxL
				bwyL = -WIDO_SILL + WALL_THICKNESS
			endif
		endif
	endif


	! --- LEFT BOARD - REVEAL_POS, NEG, SLANTED, SPLAYNULL & SPLAYNEG - plaster points ----

	if iBoardRevealTypeLeft = REVEAL_POSITIVE | iBoardRevealTypeLeft = REVEAL_NEGATIVE | \
	 iBoardRevealTypeLeft = REVEAL_SLANTED | iBoardRevealTypeLeft = REVEAL_BOARDSPLAYNULL | \
	 iBoardRevealTypeLeft = REVEAL_BOARDSPLAYNEG then
		if iBoardRevealTypeLeft = REVEAL_SLANTED | iBoardRevealTypeLeft = REVEAL_BOARDSPLAYNULL then
			x1	= bfxL
			y1	= bfyL
		else
			x1	= bxL
			y1	= byL
		endif
		x2		= bwxL
		y2		= bwyL
		nv		= thkPlasterAtBoardLeft
		iDrag   = -1

		gosub 103	! Line dragging with a normal vector

		if bInclinedWall then
			x11 = 0
			y11 = -WIDO_SILL + WALL_THICKNESS
			x12 = 1
			y12 = y11 + iInclDir * incHor

			x21 = x3	: y21 = y3
			x22 = x4	: y22 = y4

			gosub 100	! Line - Line intersection

			if state = 1 & cx < 0 then
				pbwxL = cx
				pbwyL = cy
				bDoneL = 1
			else
				pbwxL = 0
				pbwyL = 0
				bDoneL = 0
			endif

			if iBoardRevealTypeLeft = REVEAL_SLANTED | iBoardRevealTypeLeft = REVEAL_BOARDSPLAYNULL then
				pbxL = bfxL + thkPlasterAtBoardLeft / cos(leftBoardAngle)
				pbyL = bfyL
			else
				pbxL = x3
				pbyL = y3
			endif
		else
			if curvedWall then
				if bWndCurved then
					xo = 0
					yo = -ySign * (WOD)
					ro = radSillLine - iArchSign * WIDO_FRAME_THICKNESS
					x1 = x3	: y1 = y3
					x2 = x4	: y2 = y4

					gosub 101	! Circle - Line intersection

					if state = 0 then
						pbxL = x1 - WOD * tan(leftBoardAngle)
						pbyL = -ySign * WOD
					endif
					if state = 1 then
						pbxL = xa
						pbyL = ya
					endif
					if state = 2 then
						if ya > yb exor bArchSign then
							pbxL = xa
							pbyL = ya
						else
							pbxL = xb
							pbyL = yb
						endif
					endif
				else
					if iBoardRevealTypeLeft = REVEAL_SLANTED | iBoardRevealTypeLeft = REVEAL_BOARDSPLAYNULL then
						pbxL = bfxL + thkPlasterAtBoardLeft / cos(leftBoardAngle)
						pbyL = bfyL
					else
						pbxL = x3
						pbyL = y3
					endif
				endif

				xo = 0
				yo = -ySign * (WOD)
				ro = radBoard
				x1 = x3	: y1 = y3
				x2 = x4	: y2 = y4

				gosub 101	! Circle - Line intersection

				if state = 0 then
					pbwxL = x1 - WOD * tan(leftBoardAngle)
					pbwyL = -ySign * WOD
				endif
				if state = 1 then
					pbwxL = xa
					pbwyL = ya
				endif
				if state = 2 then
					if ya > yb exor bArchSign then
						pbwxL = xa
						pbwyL = ya
					else
						pbwxL = xb
						pbwyL = yb
					endif
				endif
			else 				! straight wall
				if iBoardRevealTypeLeft = REVEAL_SLANTED | iBoardRevealTypeLeft = REVEAL_BOARDSPLAYNULL then
					pbxL = bfxL - tt
					pbyL = bfyL
				else
					pbxL = bxL - tt
					pbyL = byL
				endif

				pbwxL = bwxL - tt
				pbwyL = bwyL
			endif
		endif

		! --- LEFT BOARD - REVEAL NEGATIVE & SPLAYNEG - additional plaster points ---------

		if iBoardRevealTypeLeft = REVEAL_NEGATIVE | iBoardRevealTypeLeft = REVEAL_BOARDSPLAYNEG then
			if curvedWall & not(bParalellInCurvedWalls) & bWndCurved then

				x1 = pbwxL	: y1 = pbwyL
				x2 = pbxL	: y2 = pbyL

				ro = radBoardLine - thkPlasterAtBoardLeft * iArchSign
				xo = 0
				yo = iArchSign * WOD

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point

				pbxL = cx
				pbyL = cy

				alfaLeftPlasterAtBoardLineAdd		= thkPlasterAtBoardLeft * ArcLengthBoardLineToAngle

				pbfxL = -radBoardLine * sin(leftAlfa - alfaLeftPlasterAtBoardLineAdd)
				pbfyL = iArchSign * (WOD - radBoardLine * cos(leftAlfa - alfaLeftPlasterAtBoardLineAdd))

				pbexL = -(radBoardLine - iArchSign * thkPlasterAtBoardLeft) * sin(leftAlfa - alfaLeftPlasterAtBoardLineAdd)
				pbeyL = iArchSign * (WOD - (radBoardLine - iArchSign * thkPlasterAtBoardLeft) * cos(leftAlfa - alfaLeftPlasterAtBoardLineAdd))
			else
				pbfxL = bfxL + thkPlasterAtBoardLeft
				pbfyL = bfyL

				pbexL = pbfxL
				pbeyL = pbfyL + thkPlasterAtBoardLeft

				if iBoardRevealTypeLeft = REVEAL_BOARDSPLAYNEG | curvedWall & not(bParalellInCurvedWalls) then
					x11 = pbwxL		: y11 = pbwyL
					x12 = pbxL		: y12 = pbyL
					x21 = pbexL		: y21 = pbeyL
					x22 = pbexL - 1	: y22 = pbeyL

					gosub 100	! Line - Line intersection

					if state = 1 & cx < 0 then
						pbxL = cx
						pbyL = cy
					else
						pbxL = 0
						pbyL = 0
					endif
				else
					pbxL = bxL + thkPlasterAtBoardLeft
					pbyL = pbeyL
				endif
			endif
		endif
	endif
endif



! ==============================================================================
! = = =  R I G H T    S I D E  = = = = = = = = = = = = = = = = = = = = = = = = =
! ==============================================================================


! ==============================================================================
! Reveal & Plaster Points - Corner Window
! ==============================================================================

if bRightCornerFunction & abs(rightCornerAngle) > EPS then

	sfxR = rightWidth + rightCwDx + WIDO_FRAME_THICKNESS * rx + SymbolMid_shiftDy / tan(rightCornerAngle/2)
	sfyR = -SymbolMid_shiftDy
	sxR = sfxR
	syR = sfyR
	if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) & gs_mountingFrame then
		sfMFrxR = rightWidth + rightCwDx + (WIDO_FRAME_THICKNESS + gs_mountingFrame_depth) * rx + SymbolMid_shiftDy / tan(rightCornerAngle/2)
		sfMFryR = -SymbolMid_shiftDy - gs_mountingFrame_depth
		smxR = sfMFrxR
		smyR = sfMFryR
		psfxR = sfMFrxR
		psfyR = sfMFryR
		psmxR = sfMFrxR
		psmyR = sfMFryR
	else
		smxR = sfxR
		smyR = sfyR
		psxR = sfxR
		psyR = sfyR
		psfxR = sfxR
		psfyR = sfyR
		psmxR = sfxR
		psmyR = sfyR
	endif

	swxR =  rightWidth + rightCwDx + (WIDO_FRAME_THICKNESS + WIDO_SILL) * rx
	swyR = -WIDO_SILL
	pswxR = swxR
	pswyR = swyR

	bwxR =  rightWidth + rightCwDx + rightCwDx2 - (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS) * rx
	bwyR = -WIDO_SILL + WALL_THICKNESS
	pbwxR = bwxR
	pbwyR = bwyR

	bfxR = rightWidth + rightCwDx + SymbolMid_shiftDy / tan(rightCornerAngle/2)
	bfyR = WIDO_FRAME_THICKNESS - SymbolMid_shiftDy
	bxR = bfxR
	byR = bfyR
	pbxR = bfxR
	pbyR = bfyR
	pbfxR = bfxR
	pbfyR = bfyR
	pbexR = bfxR
	pbeyR = bfyR

else

	! =====================================================================================
	! Right Sill Reveal & Plaster Points for all wall & reveal types
	! =====================================================================================

	! --- RIGHT SILL - ALL REVEAL TYPES - "sf" point --------------------------------------

	if curvedWall then
		if bWndCurved then
			sfxR = radSillLine * sin(rightAlfa)
			sfyR = iArchSign * (WOD - radSillLine * cos(rightAlfa))
		else
			if bGangingRight then
				sfxR = rightWidth + wallIsLeft * WIDO_FRAME_THICKNESS * tan(rightAlfa) + signWallIsLeft * SymbolMid_shiftDy * tan(rightAlfa)
			else
				sfxR = rightWidth + dxRight + signWallIsLeft * SymbolMid_shiftDy * tan(rightAlfa) * (iBoardRevealTypeRight <> REVEAL_SLANTED)
			endif
			sfyR = -SymbolMid_shiftDy
		endif
	else
		sfxR = rightWidth + dxRight
		sfyR = -SymbolMid_shiftDy
	endif

	if gs_mountingFrame then
		sfMFrxR = sfxR + gs_mountingFrame_depth * tan(rightAlfa) * (not(bParalellInCurvedWalls) | bGangingRight) * iArchSign
		sfMFryR = sfyR - gs_mountingFrame_depth
	endif


	! --- RIGHT SILL - REVEAL POSITIVE & NEGATIVE & SPLAYED - "s" point -------------------

	if iSillRevealTypeRight = REVEAL_POSITIVE | iSillRevealTypeRight = REVEAL_NEGATIVE | iSillRevealTypeRight = REVEAL_SILLSPLAYED then
		if curvedWall & bWndCurved then
			sxR = radSillLine * sin(rightAlfa  - alfaRightJamb * not(bGangingRight))
			syR = iArchSign * (WOD - radSillLine * cos(rightAlfa  - alfaRightJamb * not(bGangingRight)))
		else
			if curvedWall & bParalellInCurvedWalls then
				sxR = rightWidth - dxRightJamb !+ bGangingRight * wallIsLeft * WIDO_FRAME_THICKNESS * tan(rightAlfa)
				syR = 0
			else
				sxR = rightWidth - dxRightJamb * MIN(1, (not(bGangingRight) + curvedWall))  + SymbolMid_shiftDy * tan(rightAlfa-(alfaRightJamb * not(bGangingRight))) * signWallIsLeft
				syR = -SymbolMid_shiftDy
			endif
		endif
	endif


	! --- RIGHT SILL - REVEAL SPLAYED & SPLAYNULL - "sm" point ----------------------------

	if iSillRevealTypeRight = REVEAL_SILLSPLAYED | iSillRevealTypeRight = REVEAL_SILLSPLAYNULL then
		if curvedWall & not(bParalellInCurvedWalls & not(bGangingRight)) then
			if iSillRevealTypeRight = REVEAL_SILLSPLAYED & not(bGangingRight) then
				smxR = sxR + iArchSign * gs_reveal_outer_jamb_depth * sxR  / WOD
			else
				smxR = sfxR + iArchSign * gs_reveal_outer_jamb_depth * sfxR  / WOD
			endif
			smyR = -gs_reveal_outer_jamb_depth
		else
			smxR = rightWidth - dxRightJamb * not(bGangingRight)
			smyR = -gs_reveal_outer_jamb_depth
		endif
	endif


	! --- RIGHT SILL - REVEAL NO - "sw" & "psw" points ------------------------------------

	if iSillRevealTypeRight = REVEAL_NO then
		if curvedWall then
			if bParalellInCurvedWalls & not(bGangingRight) then
				swxR =  rightWidth
				swyR = ySign * (sqr(radSill^2 - swxR^2) - WOD)

				pswxR = swxR - thkPlasterAtSillRight
				pswyR = swyR
			else
				swxR =  radSill * sin(rightAlfa)
				swyR = ySign * (radSill * cos(rightAlfa) - WOD)

				if thkPlasterAtSillRight > EPS & not(bGangingRight) then
					x1 = swxR - thkPlasterAtSillRight * cos(rightAlfa)
					y1 = swyR - iArchSign * thkPlasterAtSillRight * sin(rightAlfa)
					x2 = x1 + radSill * sin(rightAlfa)
					y2 = y1 - iArchSign * radSill * cos(rightAlfa)

					ro = radSill
					xo = 0
					yo = iArchSign * WOD

					gosub 101	! Circle - Line intersection
					gosub 102	! Select good intersection point

					pswxR = cx
					pswyR = cy
				else
					pswxR = swxR
					pswyR = swyR
				endif
			endif
		else
			swxR =  rightWidth
			swyR = -WIDO_SILL
			pswxR = swxR - not(bGangingRight) * thkPlasterAtSillRight
			pswyR = swyR
		endif
	endif


	! --- RIGHT SILL - REVEAL POSITIVE & NEGATIVE - "sw" point ----------------------------

	if iSillRevealTypeRight = REVEAL_POSITIVE | iSillRevealTypeRight = REVEAL_NEGATIVE then
		if curvedWall then
			if bParalellInCurvedWalls & not(bGangingRight) then
				swxR = rightWidth - dxRightJamb
				swyR = ySign * (sqr(radSill^2 - swxR^2) - WOD)
			else
				swxR =  radSill * sin(rightAlfa - alfaRightJamb * not(bGangingRight))
				swyR = ySign * (radSill * cos(rightAlfa - alfaRightJamb * not(bGangingRight)) - WOD)
			endif
		else
			swxR =  rightWidth - dxRightJamb * not(bGangingRight)
			swyR = -WIDO_SILL
		endif
	endif


	! --- RIGHT SILL - REVEAL SPLAYED & REVEAL SPLAYNULL - "sw" point ---------------------

	if iSillRevealTypeRight = REVEAL_SILLSPLAYED | iSillRevealTypeRight = REVEAL_SILLSPLAYNULL then
		if curvedWall then
			swAlpha = atn(smxR/(WOD+gs_reveal_outer_jamb_depth*iArchSign)) * not(bParalellInCurvedWalls & not(bGangingRight)) * iArchSign + rightSillAngle * not(bGangingRight)

			x1 = smxR
			y1 = smyR
			x2 = smxR - sin(swAlpha)
			y2 = smyR + cos(swAlpha)

			ro = radSill
			xo = 0
			yo = iArchSign * WOD

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point

			swxR = cx
			swyR = cy
		else
			swyR = -WIDO_SILL
			swxR =  smxR + not(bGangingRight) * (smyR - swyR) * tan(rightSillAngle)
		endif
	endif


	! --- RIGHT SILL - REVEAL NO & POSITIVE & NEGATIVE - all plaster points ---------------

	if iSillRevealTypeRight = REVEAL_NO | iSillRevealTypeRight = REVEAL_POSITIVE | iSillRevealTypeRight = REVEAL_NEGATIVE then
		if curvedWall then
			x1 = swxR	: y1 = swyR
			if iSillRevealTypeRight = REVEAL_NO then
				x2 = sfxR	: y2 = sfyR
			else
				x2 = sxR	: y2 = syR
			endif
			nv		= thkPlasterAtSillRight
			iDrag	= -signWallIsLeft * ySign

			gosub 103	! Line dragging with a normal vector

			if bParalellInCurvedWalls then
				psxR = x4
				psyR = y4
			else
				if bWndCurved then
					x1 = x3	: y1 = y3
					x2 = x4	: y2 = y4

					ro = radSillLine
					xo = 0
					yo = iArchSign * WOD

					gosub 101	! Circle - Line intersection
					gosub 102	! Select good intersection point

					psxR = cx
					psyR = cy
				else
					x11 = x3	: y11 = y3
					x12 = x4	: y12 = y4
					x21 = 0		: y21 = -SymbolMid_shiftDy
					x22 = -1	: y22 = -SymbolMid_shiftDy

					gosub 100	! Line - Line intersection

					if state = 1 & cx > 0 then
						psxR = cx
						psyR = cy
					else
						psxR = 0
						psyR = 0
					endif
				endif
			endif

			if iSillRevealTypeRight <> REVEAL_SILLSPLAYED & iSillRevealTypeRight <> REVEAL_SILLSPLAYNULL then
				x1 = x3
				y1 = y3
				x2 = x4
				y2 = y4

				ro = radSill
				xo = 0
				yo = iArchSign * WOD

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point

				pswxR = cx
				pswyR = cy
			endif
		else
			pswxR = swxR - thkPlasterAtSillRight
			pswyR = swyR

			if iSillRevealTypeRight = REVEAL_NO then
				psxR = sfxR - thkPlasterAtSillRight
				psyR = sfyR
			else
				psxR = sxR - thkPlasterAtSillRight
				psyR = syR
			endif
		endif


		! --- RIGHT SILL - REVEAL NEGATIVE, additional plaster points ---------------------

		if iSillRevealTypeRight = REVEAL_NEGATIVE then
			if curvedWall & not(bParalellInCurvedWalls) & bWndCurved then
				x1 = pswxR	: y1 = pswyR
				x2 = psxR	: y2 = psyR

				ro = radSillLine + thkPlasterAtSillRight * iArchSign
				xo = 0
				yo = iArchSign * WOD

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point

				psxR = cx
				psyR = cy

				psfxR = radSillLine * sin(rightAlfa  - alfaRightPlasterAtSillLineAdd)
				psfyR = iArchSign * (WOD - radSillLine * cos(rightAlfa  - alfaRightPlasterAtSillLineAdd))

				psmxR = (radSillLine + thkPlasterAtSillRight * iArchSign) * sin(rightAlfa  - alfaRightPlasterAtSillLineAdd)
				psmyR = iArchSign * (WOD - (radSillLine + thkPlasterAtSillRight * iArchSign) * cos(rightAlfa  - alfaRightPlasterAtSillLineAdd))
			else
				psfxR = sfxR - thkPlasterAtSillRight
				psfyR = sfyR

				psmxR = psfxR
				psmyR = psfyR - thkPlasterAtSillRight

				if curvedWall & not(bParalellInCurvedWalls) then
					x11 = pswxR		: y11 = pswyR
					x12 = psxR		: y12 = psyR
					x21 = psmxR		: y21 = psmyR
					x22 = psmxR - 1	: y22 = psmyR

					gosub 100	! Line - Line intersection

					if state = 1 & cx > 0 then
						psxR = cx
						psyR = cy
					else
						psxR = 0
						psyR = 0
					endif
				else
					psxR = psxR
					psyR = psyR - thkPlasterAtSillRight
				endif
			endif
		endif
	endif


	! --- RIGHT SILL - REVEAL SILLSPLAYED & SILLSPLAYNULL - all plaster points ------------

	if iSillRevealTypeRight = REVEAL_SILLSPLAYED | iSillRevealTypeRight = REVEAL_SILLSPLAYNULL then
		if bGangingRight then
			if iSillRevealTypeRight = REVEAL_SILLSPLAYED then
				psxR = sxR
				psyR = syR
			else
				if gs_mountingFrame then
					psfxR = sfMFrxR
					psfyR = sfMFryR
				else
					psfxR = sfxR
					psfyR = sfyR
				endif
			endif

			psmxR = smxR
			psmyR = smyR
			pswxR = swxR
			pswyR = swyR
		else
			if curvedWall then
				x1 = smxR : y1 = smyR
				if iSillRevealTypeRight = REVEAL_SILLSPLAYED then
					x2 = sxR  : y2 = syR
				else
					x2 = sfxR  : y2 = sfyR
				endif
				nv		= thkPlasterAtSillRight
				iDrag	= -signWallIsLeft * ySign

				gosub 103	! Line dragging with a normal vector

				x11 = x3	: y11 = y3
				x12 = x4	: y12 = y4
				x21 = 0		: y21 = -gs_mountingFrame * gs_mountingFrame_depth
				x22 = -1	: y22 = -gs_mountingFrame * gs_mountingFrame_depth

				gosub 100	! Line - Line intersection

				if state = 1 & cx > 0 then
					if iSillRevealTypeRight = REVEAL_SILLSPLAYED then
						psxR = cx
						psyR = cy
					else
						psfxR = cx
						psfyR = cy
					endif
				else
					if iSillRevealTypeRight = REVEAL_SILLSPLAYED then
						psxR = 0
						psyR = 0
					else
						psfxR = 0
						psfyR = 0
					endif
				endif

				x1 = swxR : y1 = swyR
				x2 = smxR : y2 = smyR
				nv		= thkPlasterAtSillRight
				iDrag	= -signWallIsLeft * ySign

				gosub 103	! Line dragging with a normal vector

				x21 = x3 : y21 = y3
				x22 = x4 : y22 = y4

				gosub 100	! Line - Line intersection

				if state = 1 & cx > 0 then
					psmxR = cx
					psmyR = cy
				else
					psmxR = 0
					psmyR = 0
				endif


				! --- checking wrong (outside of wall) points

				if iSillRevealTypeRight = REVEAL_SILLSPLAYED then
					x1 = psxR	: y1 = psyR
				else
					x1 = psfxR	: y1 = psfyR
				endif

				x2 = psmxR : y2 = psmyR

				ro = radSill
				xo = 0
				yo = iArchSign * WOD

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point

				pxWallEdgeR = cx
				pyWallEdgeR = cy

				if psmyL - pyWallEdgeR < EPS then
					bPmOutOfWallRight = 1
				endif

				! --- end of checking wrong (outside of wall) points


				x1 = x3 : y1 = y3
				x2 = x4 : y2 = y4

				ro = radSill
				xo = 0
				yo = iArchSign * WOD

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point

				if bPmOutOfWallRight then
					pswxR = pxWallEdgeR
					pswyR = pyWallEdgeR
				else
					pswxR = cx
					pswyR = cy
				endif
			else
				if iSillRevealTypeRight = REVEAL_SILLSPLAYED then
					psxR = sxR - thkPlasterAtSillRight
					psyR = syR
				else
					psfxR = sfxR - thkPlasterAtSillRight
					psfyR = sfyR - gs_mountingFrame * gs_mountingFrame_depth
				endif

				x1 = swxR	: y1 = swyR
				x2 = smxR	: y2 = smyR
				nv		= thkPlasterAtSillRight
				iDrag   = 1

				gosub 103	! Line dragging with a normal vector

				x11 = x3	: y11 = y3
				x12 = x4	: y12 = y4

				if iSillRevealTypeRight = REVEAL_SILLSPLAYED then
					x21 = psxR	: y21 = psyR
					x22 = psxR	: y22 = psyR + 1
				else
					x21 = psfxR	: y21 = psfyR
					x22 = psfxR	: y22 = psfyR + 1
				endif

				gosub 100	! Line - Line intersection

				if state = 1 & cx > 0 then
					if cy + WIDO_SILL < EPS then
						bPmOutOfWallRight = 1
						psmxR = cx
						psmyR = -WIDO_SILL
					else
						psmxR = cx
						psmyR = cy
					endif
				else
					psmxR = 0
					psmyR = 0
				endif

				pswyR = -WIDO_SILL
				pswxR = psmxR + not(bGangingRight) * (WIDO_SILL + psmyR) * tan(rightSillAngle)
			endif
		endif
	endif


	! =====================================================================================
	! Right Board Reveal & Plaster Points for all wall & reveal types
	! =====================================================================================

	! --- RIGHT BOARD - ALL REVEAL TYPES - "bf" & "pb" points -----------------------------

	if iBoardRevealTypeRight = REVEAL_SLANTED then
		if curvedWall & bWndCurved then
			x1 = sfxR
			y1 = sfyR
			x2 = sfxR + sin(rightBoardAngle)
			y2 = sfyR + cos(rightBoardAngle)

			ro = radBoardLine
			xo = 0
			yo = iArchSign * WOD

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point

			bfxR = cx
			bfyR = cy
		else
			if curvedWall then
				bfxR = rightWidth + not(bGangingRight & wallIsLeft) * WIDO_FRAME_THICKNESS * tan(rightBoardAngle) - SymbolMid_shiftDy * tan(rightBoardAngle) * bGangingRight
			else
				bfxR = rightWidth + not(bGangingRight) * WIDO_FRAME_THICKNESS * tan(rightBoardAngle)
			endif
			bfyR = WIDO_FRAME_THICKNESS - SymbolMid_shiftDy

		endif
	else
		if curvedWall & (not(bParalellInCurvedWalls) | bGangingRight) then
			if bWndCurved then
				bfxR = sfxR - iArchSign * WIDO_FRAME_THICKNESS * sin(rightAlfa)
				bfyR = sfyR + WIDO_FRAME_THICKNESS * cos(rightAlfa)

				if thkPlasterAtBoardRight > EPS & not(bGangingRight) then
					x1 = bfxR - thkPlasterAtBoardRight * cos(rightAlfa)
					y1 = bfyR - iArchSign * thkPlasterAtBoardRight * sin(rightAlfa)
					x2 = x1 + sin(rightAlfa)
					y2 = y1 - iArchSign * cos(rightAlfa)

					ro = radSillLine - SQR((sfyR - bfyR)^2 + (sfxR - bfxR)^2) * iArchSign
					xo = 0
					yo = iArchSign * WOD

					gosub 101	! Circle - Line intersection
					gosub 102	! Select good intersection point

					pbxR = cx
					pbyR = cy
				else
					pbxR = bfxR
					pbyR = bfyR
				endif
			else
				bfxR = rightWidth + not(bArchSign) * WIDO_FRAME_THICKNESS * tan(rightAlfa) + signWallIsLeft * SymbolMid_shiftDy * tan(rightAlfa)
				bfyR = WIDO_FRAME_THICKNESS  - SymbolMid_shiftDy

				pbxR = bfxR - not(bGangingRight) * thkPlasterAtBoardRight / cos(rightAlfa)
				pbyR = bfyR
			endif
		else
			bfxR = rightWidth
			bfyR = WIDO_FRAME_THICKNESS - SymbolMid_shiftDy
			pbxR = bfxR - not(bGangingRight) * thkPlasterAtBoardRight
			pbyR = bfyR
		endif
	endif


	! --- RIGHT BOARD - REVEAL POSITIVE & NEGATIVE & SPLAYNULL & SPLAYNEG - "b" point -----

	if iBoardRevealTypeRight = REVEAL_POSITIVE | iBoardRevealTypeRight = REVEAL_NEGATIVE | \
	 iBoardRevealTypeRight = REVEAL_BOARDSPLAYNULL | iBoardRevealTypeRight = REVEAL_BOARDSPLAYNEG then
		if curvedWall & bWndCurved then
			bxR = radBoardLine * sin(rightAlfa + alfaRightBoardLineReveal * not(bGangingRight))
			byR = iArchSign * (WOD - radBoardLine * cos(rightAlfa + alfaRightBoardLineReveal * not(bGangingRight)))
		else
			bxR = bfxR - revealBoardRight * not(bGangingRight)
			byR = bfyR
		endif
	endif


	! --- RIGHT BOARD - REVEAL NO - "bw" & "pbw" points -----------------------------------

	if iBoardRevealTypeRight = REVEAL_NO then
		if curvedWall then
			if bParalellInCurvedWalls & not(bGangingRight) then
				bwxR =  rightWidth
				bwyR = ySign * (sqr(radBoard^2 - bwxR^2) - WOD)
			else
				bwxR =  radBoard * sin(rightAlfa)
				bwyR = ySign * (radBoard * cos(rightAlfa) - WOD)
			endif

			if thkPlasterAtBoardRight > EPS & not(bGangingRight) then
				if bParalellInCurvedWalls & not(bGangingRight) then
					x1 = bwxR - thkPlasterAtBoardRight
					y1 = bwyR
					x2 = bwxR - thkPlasterAtBoardRight
					y2 = bwyR + 1
				else
					x1 = bwxR - thkPlasterAtBoardRight * cos(rightAlfa)
					y1 = bwyR - iArchSign * thkPlasterAtBoardRight * sin(rightAlfa)
					x2 = x1 + radBoard * sin(rightAlfa)
					y2 = y1 - iArchSign * radBoard * cos(rightAlfa)
				endif

				ro = radBoard
				xo = 0
				yo = iArchSign * WOD

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point

				pbwxR = cx
				pbwyR = cy
			else
				pbwxR = bwxR
				pbwyR = bwyR
			endif
		else
			bwxR =  rightWidth
			bwyR = -WIDO_SILL + WALL_THICKNESS + bwxR * incHor * iInclDir * bInclinedWall
			pbwxR = bwxR - not(bGangingRight) * thkPlasterAtBoardRight
			pbwyR = bwyR - not(bGangingRight) * thkPlasterAtBoardRight * incHor * iInclDir * bInclinedWall
		endif
	endif


	! --- RIGHT BOARD - REVEAL SLANTED &  SPLAYNULL &  SPLAYNEG - "bw" point --------------

	if iBoardRevealTypeRight = REVEAL_SLANTED | iBoardRevealTypeRight = REVEAL_BOARDSPLAYNULL | \
	 iBoardRevealTypeRight = REVEAL_BOARDSPLAYNEG then
		if curvedWall then
			if iBoardRevealTypeRight = REVEAL_SLANTED then
				x1 = sfxR
			else
				x1 = bxR - WIDO_FRAME_THICKNESS * tan(rightBoardAngle)
			endif
			y1 = sfyR
			x2 = x1 + tan(rightBoardAngle)
			y2 = 1 - SymbolMid_shiftDy

			xo = 0
			yo = -ySign * WOD
			ro = radBoard

			gosub 101	! Circle - Line intersection

			if state = 0 then
				bwxR = x1 + WOD * tan(rightBoardAngle)
				bwyR = -ySign * WOD
			endif
			if state = 1 then
				bwxR = xa
				bwyR = ya
			endif
			if state = 2 then
				if ya > yb exor bArchSign then
					bwxR = xa
					bwyR = ya
				else
					bwxR = xb
					bwyR = yb
				endif
			endif
		else
			if bInclinedWall then
				x11 = 0
				y11 = -WIDO_SILL + WALL_THICKNESS
				x12 = 1
				y12 = y11 + iInclDir * incHor

				if iBoardRevealTypeRight = REVEAL_SLANTED then
					x21 = sfxR
				else
					x21 = bxR - not(bGangingRight) * WIDO_FRAME_THICKNESS * tan(rightBoardAngle)
				endif
				y21 = sfyR
				x22 = x21 + not(bGangingRight) * tan(rightBoardAngle)
				y22 = 1 - SymbolMid_shiftDy

				gosub 100	! Line - Line intersection

				if state = 1 & cx > 0 then
					bwyR2 = cy
					bDoneR = 1
				else
					bwyR2 = 0
					bDoneR = 0
				endif

				if iBoardRevealTypeRight = REVEAL_SLANTED then
					x21 = sfxR
				else
					x21 = bxR - not(bGangingRight) * WIDO_FRAME_THICKNESS * tan(rightBoardAngle)
				endif
				y21 = sfyR
				x22 = x21 + not(bGangingRight) * tan(rightBoardAngle)
				y22 = 1 - SymbolMid_shiftDy

				gosub 100	! Line - Line intersection

				if state = 1 & cx > 0 then
					bwxR = cx
					bwyR = cy
					bDoneR = 1
				else
					bwxR = 0
					bwyR = 0
					bDoneR = 0
				endif

				if not(bDoneR) & bDoneL then
					bwyR = bwyL2
					bwxR = rightWidth + not(bGangingRight) * bwyR * tan(rightBoardAngle)
				endif
			else
				bwyR = -WIDO_SILL + WALL_THICKNESS
				if iBoardRevealTypeRight = REVEAL_SLANTED then
					bwxR =  rightWidth + not(bGangingRight) * (bwyR + SymbolMid_shiftDy) * tan(rightBoardAngle)
				else
					bwxR =  bxR + not(bGangingRight) * (bwyR - WIDO_FRAME_THICKNESS + SymbolMid_shiftDy) * tan(rightBoardAngle)
				endif
			endif
		endif
	endif

	! --- RIGHT BOARD - REVEAL POSITIVE & NEGATIVE - "bw" point ---------------------------

	if iBoardRevealTypeRight = REVEAL_POSITIVE | iBoardRevealTypeRight = REVEAL_NEGATIVE then
		if curvedWall then
			if bParalellInCurvedWalls & not(bGangingRight) then
				bwxR = bxR
				bwyR = ySign * (sqr(radBoard^2 - bxR^2) - WOD)
			else
				xo = 0
				yo = -ySign * (WOD)
				ro = radBoard
				x1 = bxR
				y1 = byR
				x2 = 0
				y2 = -ySign * WOD

				gosub 101	! Circle - Line intersection

				if state = 0 then
					bwxR = x1 - WOD * tan(leftBoardAngle)
					bwyR = -ySign * WOD
				endif
				if state = 1 then
					bwxR = xa
					bwyR = ya
				endif
				if state = 2 then
					if ya > yb exor bArchSign then
						bwxR = xa
						bwyR = ya
					else
						bwxR = xb
						bwyR = yb
					endif
				endif
			endif
		else
			if bInclinedWall then
				bwxR =  bxR
				bwyR = -WIDO_SILL + WALL_THICKNESS + bwxR * incHor * iInclDir
			else
				bwyR = -WIDO_SILL + WALL_THICKNESS
				bwxR =  bxR
			endif
		endif
	endif


	! --- RIGHT BOARD - REVEAL_POS, NEG, SLANTED, SPLAYNULL & SPLAYNEG - plaster points ---

	if iBoardRevealTypeRight = REVEAL_POSITIVE | iBoardRevealTypeRight = REVEAL_NEGATIVE | \
	 iBoardRevealTypeRight = REVEAL_SLANTED | iBoardRevealTypeRight = REVEAL_BOARDSPLAYNULL | \
	 iBoardRevealTypeRight = REVEAL_BOARDSPLAYNEG then
		if iBoardRevealTypeRight = REVEAL_SLANTED| iBoardRevealTypeRight = REVEAL_BOARDSPLAYNULL  then
			x1	= bfxR
			y1	= bfyR
		else
			x1	= bxR
			y1	= byR
		endif
		x2		= bwxR
		y2		= bwyR
		nv		= thkPlasterAtBoardRight
		iDrag	= 1

		gosub 103	! Line dragging with a normal vector

		if bInclinedWall then

			x11 = 0
			y11 = -WIDO_SILL + WALL_THICKNESS
			x12 = 1
			y12 = y11 + iInclDir * incHor

			x21 = x3	: y21 = y3
			x22 = x4	: y22 = y4

			gosub 100	! Line - Line intersection

			if state = 1 & cx > 0 then
				pbwxR = cx
				pbwyR = cy
				bDoneL = 1
			else
				pbwxR = 0
				pbwyR = 0
				bDoneL = 0
			endif

			if iBoardRevealTypeRight = REVEAL_SLANTED | iBoardRevealTypeRight = REVEAL_BOARDSPLAYNULL then
				pbxR = bfxR - thkPlasterAtBoardRight / cos(rightBoardAngle)
				pbyR = bfyR
			else
				pbxR = x3
				pbyR = y3
			endif
		else
			if curvedWall then
				if bWndCurved then
					xo = 0
					yo = -ySign * (WOD)
					ro = radSillLine - iArchSign * WIDO_FRAME_THICKNESS
					x1 = x3	: y1 = y3
					x2 = x4	: y2 = y4

					gosub 101	! Circle - Line intersection

					if state = 0 then
						pbxR = x1 - WOD * tan(rightBoardAngle)
						pbyR = -ySign * WOD
					endif
					if state = 1 then
						pbxR = xa
						pbyR = ya
					endif
					if state = 2 then
						if ya > yb exor bArchSign then
							pbxR = xa
							pbyR = ya
						else
							pbxR = xb
							pbyR = yb
						endif
					endif
				else
					if iBoardRevealTypeRight = REVEAL_SLANTED | iBoardRevealTypeRight = REVEAL_BOARDSPLAYNULL then
						pbxR = bfxR - thkPlasterAtBoardRight / cos(rightBoardAngle)
						pbyR = bfyR
					else
						pbxR = x3
						pbyR = y3
					endif
				endif

				xo = 0
				yo = -ySign * (WOD)
				ro = radBoard
				x1 = x3	: y1 = y3
				x2 = x4	: y2 = y4

				gosub 101	! Circle - Line intersection

				if state = 0 then
					pbwxR = x1 + WOD * tan(rightBoardAngle)
					pbwyR = -ySign * WOD
				endif
				if state = 1 then
					pbwxR = xa
					pbwyR = ya
				endif
				if state = 2 then
					if ya > yb exor bArchSign then
						pbwxR = xa
						pbwyR = ya
					else
						pbwxR = xb
						pbwyR = yb
					endif
				endif
			else 				! straight wall
				if iBoardRevealTypeRight = REVEAL_SLANTED | iBoardRevealTypeRight = REVEAL_BOARDSPLAYNULL then
					pbxR = bfxR + tt
					pbyR = bfyR
				else
					pbxR = bxR + tt
					pbyR = byR
				endif

				pbwxR = bwxR + tt
				pbwyR = bwyR
			endif
		endif

		! --- RIGHT BOARD - REVEAL NEGATIVE & SPLAYNEG - additional plaster points --------

		if iBoardRevealTypeRight = REVEAL_NEGATIVE | iBoardRevealTypeRight = REVEAL_BOARDSPLAYNEG then
			if curvedWall & not(bParalellInCurvedWalls) & bWndCurved then

				x1 = pbwxR	: y1 = pbwyR
				x2 = pbxR	: y2 = pbyR

				ro = radBoardLine - thkPlasterAtBoardRight * iArchSign
				xo = 0
				yo = iArchSign * WOD

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point

				pbxR = cx
				pbyR = cy

				alfaRightPlasterAtBoardLineAdd		= thkPlasterAtBoardRight * ArcLengthBoardLineToAngle

				pbfxR = radBoardLine * sin(rightAlfa - alfaRightPlasterAtBoardLineAdd)
				pbfyR = iArchSign * (WOD - radBoardLine * cos(rightAlfa - alfaRightPlasterAtBoardLineAdd))

				pbexR = (radBoardLine - iArchSign * thkPlasterAtBoardRight) * sin(rightAlfa - alfaRightPlasterAtBoardLineAdd)
				pbeyR = iArchSign * (WOD - (radBoardLine - iArchSign * thkPlasterAtBoardRight) * cos(rightAlfa - alfaRightPlasterAtBoardLineAdd))
			else
				pbfxR = bfxR - thkPlasterAtBoardRight
				pbfyR = bfyR

				pbexR = pbfxR
				pbeyR = pbfyR + thkPlasterAtBoardRight

				if iBoardRevealTypeRight = REVEAL_BOARDSPLAYNEG | curvedWall & not(bParalellInCurvedWalls) then
					x11 = pbwxR		: y11 = pbwyR
					x12 = pbxR		: y12 = pbyR
					x21 = pbexR		: y21 = pbeyR
					x22 = pbexR - 1	: y22 = pbeyR

					gosub 100	! Line - Line intersection

					if state = 1 & cx > 0 then
						pbxR = cx
						pbyR = cy
					else
						pbxR = 0
						pbyR = 0
					endif
				else
					pbxR = bxR - thkPlasterAtBoardRight
					pbyR = pbeyR
				endif
			endif
		endif
	endif
endif



! ==============================================================================
! = = =  Reveal Points Array - new system  = = = = = = = = = = = = = = = = = = =
! ==============================================================================

dim revealPointsArray[]
idx = 1

! Left Side Points -------------------------------------------------------------

revealPointsArray[idx]		= swxL
revealPointsArray[idx + 1]	= swyL
idx = idx + 2

if iSillRevealTypeLeft = REVEAL_SILLSPLAYED | iSillRevealTypeLeft = REVEAL_SILLSPLAYNULL then
	revealPointsArray[idx]		= smxL
	revealPointsArray[idx + 1]	= smyL
	idx = idx + 2
endif

if iSillRevealTypeLeft = REVEAL_POSITIVE | iSillRevealTypeLeft = REVEAL_NEGATIVE | iSillRevealTypeLeft = REVEAL_SILLSPLAYED then
	revealPointsArray[idx]		= sxL
	revealPointsArray[idx + 1]	= syL
	idx = idx + 2
endif

if gs_mountingFrame then
	revealPointsArray[idx]		= sfMFrxL
	revealPointsArray[idx + 1]	= sfMFryL
else
	revealPointsArray[idx]		= sfxL
	revealPointsArray[idx + 1]	= sfyL
endif
idx = idx + 2

revealPointsArray[idx]		= bfxL
revealPointsArray[idx + 1]	= bfyL
idx = idx + 2

if iBoardRevealTypeLeft = REVEAL_POSITIVE | iBoardRevealTypeLeft = REVEAL_NEGATIVE | \
 iBoardRevealTypeLeft = REVEAL_BOARDSPLAYNEG then
	revealPointsArray[idx]		= bxL
	revealPointsArray[idx + 1]	= byL
	idx = idx + 2
endif

revealPointsArray[idx]		= bwxL
revealPointsArray[idx + 1]	= bwyL
idx = idx + 2

! --- Left Plaster -------------------------

revealPointsArray[idx]		= pswxL
revealPointsArray[idx + 1]	= pswyL
idx = idx + 2

if (iSillRevealTypeLeft = REVEAL_SILLSPLAYED | iSillRevealTypeLeft = REVEAL_SILLSPLAYNULL) & not(bPmOutOfWallLeft) then
	revealPointsArray[idx]		= psmxL
	revealPointsArray[idx + 1]	= psmyL
	idx = idx + 2
endif

if iSillRevealTypeLeft = REVEAL_SILLSPLAYNULL then
	revealPointsArray[idx]		= psfxL
	revealPointsArray[idx + 1]	= psfyL
	idx = idx + 2
else
	revealPointsArray[idx]		= psxL
	revealPointsArray[idx + 1]	= psyL
	idx = idx + 2
endif

if bAddPoint[1] = 1 & iSillRevealTypeLeft <> REVEAL_SILLSPLAYED & iSillRevealTypeLeft <> REVEAL_SILLSPLAYNULL then
	revealPointsArray[idx]		= psmxL
	revealPointsArray[idx + 1]	= psmyL
	idx = idx + 2

	revealPointsArray[idx]		= psfxL
	revealPointsArray[idx + 1]	= psfyL
	idx = idx + 2
endif

if bAddPoint[3] = 1 then
	revealPointsArray[idx]		= pbfxL
	revealPointsArray[idx + 1]	= pbfyL
	idx = idx + 2

	revealPointsArray[idx]		= pbexL
	revealPointsArray[idx + 1]	= pbeyL
	idx = idx + 2
endif

revealPointsArray[idx]		= pbxL
revealPointsArray[idx + 1]	= pbyL
idx = idx + 2

revealPointsArray[idx]		= pbwxL
revealPointsArray[idx + 1]	= pbwyL
idx = idx + 2


! Right Side Points -------------------------------------------------------------

revealPointsArray[idx]		= swxR
revealPointsArray[idx + 1]	= swyR
idx = idx + 2

if iSillRevealTypeRight = REVEAL_SILLSPLAYED | iSillRevealTypeRight = REVEAL_SILLSPLAYNULL then
	revealPointsArray[idx]		= smxR
	revealPointsArray[idx + 1]	= smyR
	idx = idx + 2
endif

if iSillRevealTypeRight = REVEAL_POSITIVE | iSillRevealTypeRight = REVEAL_NEGATIVE | iSillRevealTypeRight = REVEAL_SILLSPLAYED then
	revealPointsArray[idx]		= sxR
	revealPointsArray[idx + 1]	= syR
	idx = idx + 2
endif

if gs_mountingFrame then
	revealPointsArray[idx]		= sfMFrxR
	revealPointsArray[idx + 1]	= sfMFryR
else
	revealPointsArray[idx]		= sfxR
	revealPointsArray[idx + 1]	= sfyR
endif
idx = idx + 2

revealPointsArray[idx]		= bfxR
revealPointsArray[idx + 1]	= bfyR
idx = idx + 2

if iBoardRevealTypeRight = REVEAL_POSITIVE | iBoardRevealTypeRight = REVEAL_NEGATIVE | \
 iBoardRevealTypeRight = REVEAL_BOARDSPLAYNEG then
	revealPointsArray[idx]		= bxR
	revealPointsArray[idx + 1]	= byR
	idx = idx + 2
endif

revealPointsArray[idx]		= bwxR
revealPointsArray[idx + 1]	= bwyR
idx = idx + 2

! --- Right Plaster ------------------------

revealPointsArray[idx]		= pswxR
revealPointsArray[idx + 1]	= pswyR
idx = idx + 2

if (iSillRevealTypeRight = REVEAL_SILLSPLAYED | iSillRevealTypeRight = REVEAL_SILLSPLAYNULL) & not(bPmOutOfWallRight) then
	revealPointsArray[idx]		= psmxR
	revealPointsArray[idx + 1]	= psmyR
	idx = idx + 2
endif

if iSillRevealTypeRight = REVEAL_SILLSPLAYNULL then
	revealPointsArray[idx]		= psfxR
	revealPointsArray[idx + 1]	= psfyR
	idx = idx + 2
else
	revealPointsArray[idx]		= psxR
	revealPointsArray[idx + 1]	= psyR
	idx = idx + 2
endif

if bAddPoint[2] = 1 & iSillRevealTypeRight <> REVEAL_SILLSPLAYED & iSillRevealTypeRight <> REVEAL_SILLSPLAYNULL then
	revealPointsArray[idx]		= psmxR
	revealPointsArray[idx + 1]	= psmyR
	idx = idx + 2

	revealPointsArray[idx]		= psfxR
	revealPointsArray[idx + 1]	= psfyR
	idx = idx + 2
endif

if bAddPoint[4] = 1 then
	revealPointsArray[idx]		= pbfxR
	revealPointsArray[idx + 1]	= pbfyR
	idx = idx + 2

	revealPointsArray[idx]		= pbexR
	revealPointsArray[idx + 1]	= pbeyR
	idx = idx + 2
endif

revealPointsArray[idx]		= pbxR
revealPointsArray[idx + 1]	= pbyR
idx = idx + 2

revealPointsArray[idx]		= pbwxR
revealPointsArray[idx + 1]	= pbwyR
idx = idx + 2


! ==============================================================================
! = = =  iRevealPointsIdx  = = = = = = = = = = = = = = = = = = = = = = = = = = =
! ==============================================================================

dim iRevealPointsIdx[20]

! --- Left ---------------------------------------------------------------------

iRevealPointsIdx[1] = 1									! sill start - reveal

if iSillRevealTypeLeft = REVEAL_NO | iSillRevealTypeLeft = REVEAL_POSITIVE then
	iRevealPointsIdx[2] = iRevealPointsIdx[1] + 1		! sill end - reveal
else
	iRevealPointsIdx[2] = iRevealPointsIdx[1] + 2		! sill end - reveal
endif

if iSillRevealTypeLeft = REVEAL_NO | iSillRevealTypeLeft = REVEAL_NEGATIVE | \
 iSillRevealTypeLeft = REVEAL_SILLSPLAYNULL then
	iRevealPointsIdx[3] = iRevealPointsIdx[2]			! frame start - reveal, plaster
else
	iRevealPointsIdx[3] = iRevealPointsIdx[2] + 1		! frame start - reveal, plaster
endif

iRevealPointsIdx[4] = iRevealPointsIdx[3] + 1			! frame end	- reveal, plaster

if iBoardRevealTypeLeft <> REVEAL_POSITIVE then
	iRevealPointsIdx[5] = iRevealPointsIdx[4]			! board start - reveal
else
	iRevealPointsIdx[5] = iRevealPointsIdx[4] + 1		! board start - reveal
endif

if iBoardRevealTypeLeft = REVEAL_NO | iBoardRevealTypeLeft = REVEAL_POSITIVE | \
 iBoardRevealTypeLeft = REVEAL_SLANTED | iBoardRevealTypeLeft = REVEAL_BOARDSPLAYNULL then
	iRevealPointsIdx[6] = iRevealPointsIdx[5] + 1		! board end	- reveal
else
	iRevealPointsIdx[6] = iRevealPointsIdx[5] + 2		! board end	- reveal
endif

iRevealPointsIdx[7] = iRevealPointsIdx[6] + 1			! sill start - plaster

if iSillRevealTypeLeft = REVEAL_SILLSPLAYED | iSillRevealTypeLeft = REVEAL_SILLSPLAYNULL then
	if bPmOutOfWallLeft then
		iRevealPointsIdx[8] = iRevealPointsIdx[7] + 1		! sill end - plaster
	else
		iRevealPointsIdx[8] = iRevealPointsIdx[7] + 2		! sill end - plaster
	endif
else
	if bAddPoint[1] = 0 then
		iRevealPointsIdx[8] = iRevealPointsIdx[7] + 1	! sill end - plaster
	else
		iRevealPointsIdx[8] = iRevealPointsIdx[7] + 3	! sill end - plaster
	endif
endif

iRevealPointsIdx[9] = iRevealPointsIdx[8] + 1			! board start - plaster

if bAddPoint[3] = 0 then
	iRevealPointsIdx[10] = iRevealPointsIdx[9] + 1		! board end- plaster
else
	iRevealPointsIdx[10] = iRevealPointsIdx[9] + 3		! board end- plaster
endif

! --- Right --------------------------------------------------------------------

iRevealPointsIdx[11] = 1								! sill start - reveal

if iSillRevealTypeRight = REVEAL_NO | iSillRevealTypeRight = REVEAL_POSITIVE then
	iRevealPointsIdx[12] = iRevealPointsIdx[11] + 1		! sill end - reveal
else
	iRevealPointsIdx[12] = iRevealPointsIdx[11] + 2		! sill end - reveal
endif

if iSillRevealTypeRight = REVEAL_NO | iSillRevealTypeRight = REVEAL_NEGATIVE | \
 iSillRevealTypeRight = REVEAL_SILLSPLAYNULL then
	iRevealPointsIdx[13] = iRevealPointsIdx[12]			! frame start - reveal, plaster
else
	iRevealPointsIdx[13] = iRevealPointsIdx[12] + 1		! frame start - reveal, plaster
endif

iRevealPointsIdx[14] = iRevealPointsIdx[13] + 1			! frame end	- reveal, plaster

if iBoardRevealTypeRight <> REVEAL_POSITIVE then
	iRevealPointsIdx[15] = iRevealPointsIdx[14]			! board start - reveal
else
	iRevealPointsIdx[15] = iRevealPointsIdx[14] + 1		! board start - reveal
endif

if iBoardRevealTypeRight = REVEAL_NO | iBoardRevealTypeRight = REVEAL_POSITIVE | \
 iBoardRevealTypeRight = REVEAL_SLANTED | iBoardRevealTypeRight = REVEAL_BOARDSPLAYNULL then
	iRevealPointsIdx[16] = iRevealPointsIdx[15] + 1		! board end	- reveal
else
	iRevealPointsIdx[16] = iRevealPointsIdx[15] + 2		! board end	- reveal
endif

iRevealPointsIdx[17] = iRevealPointsIdx[16] + 1			! sill start - plaster

if iSillRevealTypeRight = REVEAL_SILLSPLAYED | iSillRevealTypeRight = REVEAL_SILLSPLAYNULL then
	if bPmOutOfWallRight then
		iRevealPointsIdx[18] = iRevealPointsIdx[17] + 1		! sill end - plaster
	else
		iRevealPointsIdx[18] = iRevealPointsIdx[17] + 2		! sill end - plaster
	endif
else
	if bAddPoint[2] = 0 then
		iRevealPointsIdx[18] = iRevealPointsIdx[17] + 1	! sill end - plaster
	else
		iRevealPointsIdx[18] = iRevealPointsIdx[17] + 3	! sill end - plaster
	endif
endif

iRevealPointsIdx[19] = iRevealPointsIdx[18] + 1			! board start - plaster

if bAddPoint[4] = 0 then
	iRevealPointsIdx[20] = iRevealPointsIdx[19] + 1		! board end- plaster
else
	iRevealPointsIdx[20] = iRevealPointsIdx[19] + 3		! board end- plaster
endif



! ==============================================================================
! Returned Parameters
! ==============================================================================

end	iRevealType,
	iRevealTypeForDisplay,
	iClosureType,
	bShowReveal,
	leftWidth,
	rightWidth,
	originalOffsWindowX,
	offsWindowX,
	leftJamb,
	rightJamb,
	revealBoardLeft,
	revealBoardRight,
	topJamb,
	bottomJamb,
	revealBoardTop,
	revealBoardBottom,
	revealBoardLeft,
	revealBoardRight,
	revealBoardTop,
	revealBoardBottom,
	gs_reveal_outer_jamb_depth,
	gs_reveal_left_angle,
	gs_reveal_right_angle,
	gs_reveal_top_angle,
	gs_reveal_bottom_angle,
	gs_reveal_outerLeft_angle,
	gs_reveal_outerRight_angle,
	gs_reveal_outerTop_angle,
	gs_reveal_outerBottom_angle,
	gs_reveal_left_sL,
	gs_reveal_right_sR,
	gs_reveal_bottom_sL,
	gs_reveal_bottom_sR,
	gs_reveal_double_innerLeft_sL,
	gs_reveal_double_innerRight_sR,
	gs_reveal_double_innerBottom_sL,
	gs_reveal_double_innerBottom_sR,
	radSill,
	radBoard,
	iArchSign * WOD,
	iRevealPointsIdx,
	bAddPoint,
	revealPointsArray



! ===============================================================================
! = = =  S U B R O U T I N E S  = = = = = = = = = = = = = = = = = = = = = = = = =
! ===============================================================================


! ===============================================================================
! Line - Line intersection
! -------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12	line #1
!	x21,y21, x22,y22	line #2
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = valid intersection point
!	cx, cy:				intersection point
! ===============================================================================

100:
	lliDiv = (x11-x12) * (y21-y22) - (y11-y12) * (x21-x22)

	if abs(lliDiv) > EPS then
		! Intersection

		temp1 = x11 * y12 - y11 * x12
		temp2 = x21 * y22 - y21 * x22

		tempx = temp1 * (x21-x22) - (x11-x12) * temp2
		tempy = temp1 * (y21-y22) - (y11-y12) * temp2

		state = 1
		cx = (tempx / lliDiv)
		cy = (tempy / lliDiv)
	else
		! No Intersection
		state = 0
		cx = 0
		cy = 0

		bPointL1 = (abs(x11 - x12) < EPS & abs(y11 - y11) < EPS)
		bPointL2 = (abs(x21 - x22) < EPS & abs(y21 - y21) < EPS)

		if bPointL1 & bPointL2 & abs(x11 - x21) < EPS & abs(y11 - y21) < EPS then
			state = 1
			cx = x11
			cy = y11
		endif
		if bPointL1 & not(bPointL2) then
			if (abs((y22-y21) * (x11-x21) - (x22-x21) * (y11-y21)) / sqr((x22-x21)^2 + (y22-y21)^2)) < EPS then
				state = 1
				cx = x11
				cy = y11
			endif
		endif
		if not(bPointL1) & bPointL2 then
			if (abs((y12-y11) * (x21-x11) - (x12-x11) * (y21-y11)) / sqr((x12-x11)^2 + (y12-y11)^2)) < EPS then
				state = 1
				cx = x11
				cy = y11
			endif
		endif
	endif
return


! ==============================================================================
! Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	xo,yo,ro:			circle
!	x1,y1, x2,y2		line
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = one intersection point (tangential line)
!						2 = two intersection points
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
! ==============================================================================

101:
	tempX1 = x1 - xo: tempY1 = y1 - yo
	tempX2 = x2 - xo: tempY2 = y2 - yo

	if abs(tempX2 - tempX1) < EPS then
		if abs(ro - abs(tempX1)) < EPS then
			state = 1
			xa = tempX1
			ya = 0
			xb = tempX1
			yb = 0
		else
			if abs(ro) - abs(tempX1) < 0 then
				state = 0: xa = 0: ya = 0: xb = 0: yb = 0
			else
				state = 2
				xa = tempX1
				ya = sqr(ro^2 - tempX1^2)
				xb = tempX1
				yb = -sqr(ro^2 - tempX1^2)
			endif
		endif
	else
		kf = (tempY2 - tempY1) / (tempX2 - tempX1)
		ad = 1 + kf^2
		bd = 2 * tempY1 * kf - 2 * tempX1 * kf^2
		cd = tempY1^2 - 2 * tempX1 * tempY1 * kf + tempX1^2 * kf^2 - ro^2

		if bd^2 - 4 * ad * cd < 0 then
			state = 0: xa = 0: ya = 0: xb = 0: yb = 0
		else
			xa = (-bd + sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			ya = tempY1 + (xa - tempX1) * kf
			xb = (-bd - sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			yb = tempY1 + (xb - tempX1) * kf

			if abs(xa - xb) < EPS then state = 1 else state = 2
		endif
	endif

	if state = 2 then
		da = sqr((tempX1 - xa)^2 + (tempY1 - ya)^2)
		db = sqr((tempX1 - xb)^2 + (tempY1 - yb)^2)

		if db < da then
			xxo = xa: yyo = ya
			xa = xb:  ya = yb
			xb = xxo: yb = yyo
		endif
	endif

	xa = xa + xo: ya = ya + yo
	xb = xb + xo: yb = yb + yo
return


! ==============================================================================
! Select good intersection point after Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	state:				intersection status
!	wallIsLeft:
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
!
! Returned variables:
!	cx, cy:				selected intersection point
! ==============================================================================

102:
	cx = 0
	cy = 0
	if state = 1 then
		cx = xa
		cy = ya
	endif
	if state = 2 then
		if wallIsLeft then
			if ya > yb then
				cx = xb
				cy = yb
			else
				cx = xa
				cy = ya
			endif
		else
			if ya < yb then
				cx = xb
				cy = yb
			else
				cx = xa
				cy = ya
			endif
		endif
	endif
return


! ==============================================================================
! Line dragging with a normal vector
! ------------------------------------------------------------------------------
! Input variables:
!	x1, y1, x2, y2		line #1
!	nv					length of the vector (normalvector)
!	iDrag				-1 / +1 (poz. dir. of drag = x poz. dir.)
!						gyk: left: -1, right +1 !!! :o)
! Returned variables:
!	x3, y3, x4, y4		new - dragged - line #2
! ==============================================================================

103:
	aa = sqr((x1 - x2)^2 + (y1 - y2)^2)
	if abs(aa) > EPS then
		tx = nv * (y1 - y2) / aa
		ty = nv * (x1 - x2) / aa
		if curvedWall | bInclinedWall then
			x3 = x1 + tx * iDrag
			y3 = y1 - ty * iDrag
			x4 = x2 + tx * iDrag
			y4 = y2 - ty * iDrag
		else
			x3 = x1 + tx * iDrag
			y3 = y1 - ty * iDrag
			x4 = x2 + tx * iDrag
			y4 = y2 - ty * iDrag

			if abs(tx) > EPS then
				tt = tx + (ty^2) / tx
			else
				tt = 0
			endif
		endif
	else
		x3 = x1
		y3 = y1
		x4 = x2
		y4 = y2

		tt = 0
	endif
return

]]>
</Script_1D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_PR SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_PR>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_UI SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_UI>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_VL SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_VL>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Comment SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Comment>

<ParamSection SectVersion="26" SectionFlags="0" SubIdent="0">
	<ParamSectHeader>
		<Version>26</Version>
		<AutoHotspots>false</AutoHotspots>
		<StatBits>
			<STBit_FixSize/>
		</StatBits>
		<WDLeftFrame>0</WDLeftFrame>
		<WDRightFrame>0</WDRightFrame>
		<WDTopFrame>0</WDTopFrame>
		<WDBotFrame>0</WDBotFrame>
		<LayFlags>65535</LayFlags>
		<WDMirrorThickness>0</WDMirrorThickness>
		<WDWallInset>0</WDWallInset>
		<SymbolColor>0</SymbolColor>
	</ParamSectHeader>
	<Parameters>
		<Length Name="A">
			<Description><![CDATA["Dimension 1"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="B">
			<Description><![CDATA["Dimension 2"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="ZZYZX">
			<Description><![CDATA["Height"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Boolean Name="AC_show2DHotspotsIn3D">
			<Description><![CDATA["Show 2D Hotspots in 3D"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="ac_bottomlevel">
			<Description><![CDATA["Bottom Level"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="ac_toplevel">
			<Description><![CDATA["Top Level"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Integer Name="AC_WallType">
			<Description><![CDATA["Wall Type"]]></Description>
			<Value>1</Value>
		</Integer>
		<Integer Name="AC_WindowInWallContour">
			<Description><![CDATA["Window in Wall Contour"]]></Description>
			<ArrayValues FirstDimension="4" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="AC_WallContourPolygon">
			<Description><![CDATA["Wall Contour Polygon"]]></Description>
			<ArrayValues FirstDimension="1" SecondDimension="3">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="gs_macro_version">
			<Description><![CDATA["Macro Version"]]></Description>
			<Value>12</Value>
		</Integer>
		<Integer Name="iWindowShape">
			<Description><![CDATA["Window Shape"]]></Description>
			<Value>0</Value>
		</Integer>
		<Boolean Name="bDoorWithSidelightSupport">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<Length Name="refWidth">
			<Description><![CDATA["Reference Width"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="leftWidth">
			<Description><![CDATA["Left Offset from the Origo"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="rightWidth">
			<Description><![CDATA["Right Offset from the Origo"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="cornerPostX">
			<Description><![CDATA["Corner Post Width"]]></Description>
			<Value>0</Value>
		</Length>
		<Boolean Name="bWndCurved">
			<Description><![CDATA["Curved Window"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bParalellInCurvedWalls">
			<Description><![CDATA["Parallel Opening in Curved Walls"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bShowReveal">
			<Description><![CDATA["Show Reveal on Symbol"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bDWSymbolAtMiddle">
			<Description><![CDATA["Symbol at Middle"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Integer Name="iClosureType">
			<Description><![CDATA["Closure Type"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="iRevealType">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="gs_reveal_type_bottom_int">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Integer>
		<Integer Name="iSillRevealType">
			<Description><![CDATA["Outer Reveal Type - Custom Reveal"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Integer>

		<!-- iBoardRevealType: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Integer Name="iBoardRevealType">
			<Description><![CDATA["Inner Reveal Type - Custom Reveal"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="gs_wido_sill">
			<Description><![CDATA["Reveal Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="gs_reveal_uniform">
			<Description><![CDATA["Uniform Jamb Depth"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_reveal_left">
			<Description><![CDATA["Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_right">
			<Description><![CDATA["Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_top">
			<Description><![CDATA["Head Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_bottom">
			<Description><![CDATA["Sill Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_reveal_splayed_innerLeft">
			<Description><![CDATA["Reveal Width Inner Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_splayed_innerRight">
			<Description><![CDATA["Reveal Width Inner Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerLeft">
			<Description><![CDATA["Reveal Width Inner Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerRight">
			<Description><![CDATA["Reveal Width Inner Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_splayed_innerTop">
			<Description><![CDATA["Reveal Width Inner Top"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_splayed_innerBottom">
			<Description><![CDATA["Reveal Width Inner Bottom"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerTop">
			<Description><![CDATA["Reveal Width Inner Top"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerBottom">
			<Description><![CDATA["Reveal Width Inner Bottom"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_left_sL">
			<Description><![CDATA["Lower Jamb Depth Side 2"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_right_sR">
			<Description><![CDATA["Lower Jamb Depth Side 1"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_bottom_sL">
			<Description><![CDATA["Sill Depth Side 2"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_bottom_sR">
			<Description><![CDATA["Sill Depth Side 1"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerLeft_sL">
			<Description><![CDATA["Inner Lower Jamb Depth Side 2"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerRight_sR">
			<Description><![CDATA["Inner Lower Jamb Depth Side 1"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerBottom_sL">
			<Description><![CDATA["Inner Sill Depth Side 2"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerBottom_sR">
			<Description><![CDATA["Inner Sill Depth Side 1"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_outer_jamb_depth">
			<Description><![CDATA["Outer Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<String Name="gs_reveal_angle_edit_by">
			<Description><![CDATA["Edit Jamb by"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Угол и Глубина"]]></Value>
		</String>
		<Integer Name="gs_reveal_angle_edit_by_int">
			<Description><![CDATA["Edit Jamb by"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Angle Name="gs_reveal_left_angle">
			<Description><![CDATA["Angle Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Angle Name="gs_reveal_right_angle">
			<Description><![CDATA["Angle Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Angle Name="gs_reveal_top_angle">
			<Description><![CDATA["Upper Side Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Angle Name="gs_reveal_bottom_angle">
			<Description><![CDATA["Bottom Side Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Length Name="gs_reveal_innerLeft_width">
			<Description><![CDATA["Splay Width Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Length Name="gs_reveal_innerRight_width">
			<Description><![CDATA["Splay Width Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Length Name="gs_reveal_innerTop_width">
			<Description><![CDATA["Upper Side Splay Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Length Name="gs_reveal_innerBottom_width">
			<Description><![CDATA["Bottom Side Splay Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Angle Name="gs_reveal_outerLeft_angle">
			<Description><![CDATA["Outer Angle Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_outerRight_angle">
			<Description><![CDATA["Outer Angle Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_outerTop_angle">
			<Description><![CDATA["Outer Angle Upper Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_outerBottom_angle">
			<Description><![CDATA["Outer Angle Bottom Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Length Name="gs_reveal_outerLeft_width">
			<Description><![CDATA["Outer Splay Width Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Length Name="gs_reveal_outerRight_width">
			<Description><![CDATA["Outer Splay Width Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Length Name="gs_reveal_outerTop_width">
			<Description><![CDATA["Outer Splay Width Upper Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Length Name="gs_reveal_outerBottom_width">
			<Description><![CDATA["Outer Splay Width Bottom Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Boolean Name="gs_mountingFrame">
			<Description><![CDATA["Mounting Frame"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_mountingFrame_depth">
			<Description><![CDATA["Mounting Frame Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_mountingFrame_width_left">
			<Description><![CDATA["Mounting Frame Width Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_mountingFrame_width_right">
			<Description><![CDATA["Mounting Frame Width Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_mountingFrame_width_top">
			<Description><![CDATA["Mounting Frame Width Upper"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_mountingFrame_width_bottom">
			<Description><![CDATA["Mounting Frame Width Bottom"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="revealDLeft">
			<Description><![CDATA["Extra Reveal Left"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="revealDRight">
			<Description><![CDATA["Extra Reveal Right"]]></Description>
			<Value>0</Value>
		</Length>

		<!-- PlasterGeometry: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="PlasterGeometry">
			<Description><![CDATA["Plaster Geometry"]]></Description>
		</Title>
		<Length Name="thkPlasterAtSillLeft">
			<Description><![CDATA["Plaster Thickness at Sill - Left Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtSillRight">
			<Description><![CDATA["Plaster Thickness at Sill - Right Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardLeft">
			<Description><![CDATA["Plaster Thickness at Board - Left Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardRight">
			<Description><![CDATA["Plaster Thickness at Board - Right Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- CornerWindowFunction: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="CornerWindowFunction">
			<Description><![CDATA["Corner Window Function"]]></Description>
		</Title>
		<Boolean Name="bLeftCornerFunction">
			<Description><![CDATA["Left Corner"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Angle Name="leftCornerAngle">
			<Description><![CDATA["Left Corner Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Length Name="leftConnWallThk">
			<Description><![CDATA["Left Connected Wall Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="bRightCornerFunction">
			<Description><![CDATA["Right Corner"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Angle Name="rightCornerAngle">
			<Description><![CDATA["Right Corner Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Length Name="rightConnWallThk">
			<Description><![CDATA["Right Connected Wall Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="bCornerWindow">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- Ganging: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="Ganging">
			<Description><![CDATA["Ganging"]]></Description>
		</Title>
		<Boolean Name="bGangingLeft">
			<Description><![CDATA["Connection on the Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bGangingRight">
			<Description><![CDATA["Connection on the Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- OpeningSizes: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="OpeningSizes">
			<Description><![CDATA["Opening Sizes"]]></Description>
		</Title>
		<Boolean Name="gs_reveal_nominal">
			<Description><![CDATA["Set Reveal Size as Nominal Size"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_unit_nominal">
			<Description><![CDATA["Set Unit Size as Nominal"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_egress_nominal">
			<Description><![CDATA["Set Egress Size as Nominal"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_leaf_nominal">
			<Description><![CDATA["Set Leaf Size as Nominal"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- Frame: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="Frame">
			<Description><![CDATA["Frame"]]></Description>
		</Title>
		<Length Name="gs_frame_width">
			<Description><![CDATA["Frame Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- Tolerance: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="Tolerance">
			<Description><![CDATA["Tolerance"]]></Description>
		</Title>
		<Length Name="gs_tolerance_left">
			<Description><![CDATA["Tolerance Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_tolerance_right">
			<Description><![CDATA["Tolerance Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_tolerance_upper">
			<Description><![CDATA["Tolerance Upper"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_tolerance_lower">
			<Description><![CDATA["Tolerance Lower"]]></Description>
			<Value>0</Value>
		</Length>

		<!-- Oversize: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="Oversize">
			<Description><![CDATA["Oversize"]]></Description>
		</Title>
		<Length Name="gs_left_oversize">
			<Description><![CDATA["Left Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_right_oversize">
			<Description><![CDATA["Right Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- SpecialReveal: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="SpecialReveal">
			<Description><![CDATA["Special Reveal"]]></Description>
		</Title>
		<Boolean Name="RevealDefWSNum">
			<Description><![CDATA["Reveal Depth Definition With WSNum"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="WallSkinsNum">
			<Description><![CDATA["Wall Skins Number"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
	</Parameters>
</ParamSection>

<Copyright SectVersion="1" SectionFlags="0" SubIdent="0">
	<Author>GRAPHISOFT</Author>
	<License>
		<Type>CC BY-ND</Type>
		<Version>3.0</Version>
	</License>
</Copyright>

</Symbol>
