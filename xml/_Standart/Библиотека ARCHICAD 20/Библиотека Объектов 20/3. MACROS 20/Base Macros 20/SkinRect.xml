<?xml version="1.0" encoding="UTF-8"?>
<Symbol IsArchivable="false" IsPlaceable="false" MainGUID="2B0688E1-BE95-4F94-AC6A-DD76D21592D3" MigrationValue="Normal" Owner="1196638531" Signature="1196644685" Version="38">
<Ancestry SectVersion="1" SectionFlags="0" SubIdent="0" Template="false">
	<MainGUID>F938E33A-329D-4A36-BE3E-85E126820996</MainGUID>
	<MainGUID>103E8D2C-8230-42E1-9597-46F84CCE28C0</MainGUID>
	<MainGUID>B2970E4C-8680-4061-8670-2F4B638F3953</MainGUID>
</Ancestry>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_3D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! Contact person: <TZs>
! =============================================================================
! The macro draws a rectangular (or ring-sector-part) wall block in 3D
! considering the possible distortions caused by trapeze or curved walls.
! -----------------------------------------------------------------------------
! Input Parameters:
!	startX:				diagonal corner 1
!	startY:				(at bottom)	must be lower than yEnd
!	endX:				diagonal corner 2
!	endY:				(at top)	must be greater than yStart
!	trapType:			type of rectangular block	(integer)
!							(0 = rectangle, 1 = trapeze, 2 = parallelogram)
!	bDoCut:				do wallhole or generate wallblock (0 / 1)
!	matVert:			materials
!	innerRadius:		inner radius of the wall (length)
!	incAngle:			inclination angle of trapeze wall sides (angle)
!	mirrorArcs:			wall position (0 / 1)
!	edge1 ... edge4:	edge masks for XWALL (integer)
!
! Remark:
!	The generated shapes are:
!		rectangle (used in straight and trapeze walls)
!		trapeze (in trapeze walls)
!		parallelogram (in trapeze walls)
!		ring-sector (in curved walls)
! -----------------------------------------------------------------------------

if abs(startX - endX) < EPS | (abs (startY - endY) < EPS & (abs(incAngle) < EPS | trapType <> 1)) then	! NJ, #38133
	end
endif

! queuw saving omitted - assuming it is not used outside

resol WALL_RESOL

if bDoCut < EPS then

	material matVert

endif

if innerRadius < EPS then

!*** straight ***!

	if abs(incAngle) < EPS or trapType = 0 then
		!--- rectangle ---

		if bDoCut then
			if abs(ac_wall_slant_angle1 - ac_wall_slant_angle2) < EPS then
				heightModifier = 0
!				if abs(ac_wall_slant_angle1 - 90) > EPS then
!					heightModifier = WALL_THICKNESS * cos (ac_wall_slant_angle1)
!				endif
				addz -heightModifier
				wallniche 4, 1, 1,
					0, 0, 1, height + 2*heightModifier,
					startX, startY,	0,
					startX, endY, 0,
					endX, endY, 0,
					endX, startY, 0
				del 1
			endif
		else
			if abs(90 - ac_wall_slant_angle1) < EPS then
				xwall_ matLeft, matRight, matVert, matHoriz,
						height, startX, endX, endX, startX,
						startY, startY, endY, endY,
						endY - startY, 0, 0, 0,
						edge1, edge2, edge3, edge4, 0, 0, 0
			else
				if abs(ac_wall_slant_angle1 - ac_wall_slant_angle2) < EPS then
					slantAngle = -(ac_wall_slant_angle1 - 90)
					if SYMB_MIRRORED then
						slantAngle = -slantAngle
					endif
					zCoordModif = 0
					if SYMB_MIRRORED and abs(ac_wall_slant_angle1)> EPS then
						zCoordModif = -WALL_THICKNESS / tan(ac_wall_slant_angle1)
					endif
					SPRISM_{2} matHoriz, matHoriz, matVert,
							4,
							0, 0, 1, 0, height + zCoordModif, slantAngle,
							0, 0, 1, 0, 0 + zCoordModif, slantAngle,
							startX, startY,	15, matRight,
							startX, endY,	15, matLeft,
							endX, endY,	15, matLeft,
							endX, startY,	15, matLeft
				else
					roty 90
					addz startX-EPS
					angle1 = -(90-ac_wall_slant_angle1)
					if SYMB_MIRRORED then
						angle1 = 90-ac_wall_slant_angle1
					endif
					angle2 = angle1
					if (trapType = 1) then		! trapeze
						angle1 = -(90-ac_wall_slant_angle1)
						angle2 = -(90-ac_wall_slant_angle2)
						if SYMB_MIRRORED then
							angle1 = 90-ac_wall_slant_angle2
							angle2 = 90-ac_wall_slant_angle1
						endif
					else
						if (trapType = 2) then	! parallelogram
							angle1 = -(90-ac_wall_slant_angle2)
							if SYMB_MIRRORED then
								angle1 = 90-ac_wall_slant_angle2
							endif
							angle2 = angle1
						endif
					endif
					height2 = -height
					endY2 = endY - height2 * tan(angle2)
					startY2 = startY - height2 * tan(angle1)
					if (startY - endY) * (startY2 - endY2) < 0 then
						tmp = height2 / ((startY - endY) + (startY2 - endY2))
						height2 = -tmp * (startY - endY) - EPS
						endY2 = endY - height2 * tan(angle2)
						startY2 = endY2
					endif
					SPRISM_{2} matVert, matVert, matHoriz,
							4,
							0, 0, 1, 0, endX - startX, 0,
							0, 0, 1, 0, 0, 0,
							0, startY,	15, matHoriz,
							0, endY,	15, matLeft,
							height2, endY2,		15, matHoriz,
							height2, startY2,	15, matLeft
					del 2
				endif
			endif

			gosub "wallTextureCoor"	! fix the texture coordite system
		endif

	else
		diff0 = startX * tan(incAngle)
		diff1 = endX * tan(incAngle)
		if trapType = 1 then
			!--- trapeze ---
			if SYMB_MIRRORED then
				if bDoCut then
					wallniche 4, 1, 1,
						0, 0, 1, height,
						startX, startY + diff0, 0,
						startX, endY, 0,
						endX, endY, 0,
						endX, startY + diff1, 0
				else
					xwall_ matLeft, matRight, matVert, matHoriz,
						height, startX, endX, endX, startX,
						startY + diff0, startY + diff1, endY, endY,
						endY - startY, 0, 0, 0,
						edge1, edge2, edge3, edge4, 0, 0, 0

					gosub "wallTextureCoor"	! fix the texture coordite system
				endif

			else
				if bDoCut > EPS then
					wallniche 4, 1, 1,
						0, 0, 1, height,
						startX, startY, 0,
						endX, startY, 0,
						endX, endY + diff1, 0,
						startX, endY + diff0, 0
				else
					xwall_ matLeft, matRight, matVert, matHoriz,
						height, startX, endX, endX, startX,
						startY, startY, endY + diff1, endY + diff0,
						endY - startY, 0, 0, 0,
						edge1, edge2, edge3, edge4, 0, 0, 0

					gosub "wallTextureCoor"	! fix the texture coordite system
				endif

			endif
		else
			!--- parallelogram ---
			if bDoCut then
				wallniche 4, 1, 1,
					0, 0, 1, height,
					startX, startY + diff0, 0,
					startX, endY + diff0, 0,
					endX, endY + diff1, 0,
					endX, startY + diff1, 0
			else
				xwall_ matLeft, matRight, matVert, matHoriz,
					height, startX, endX, endX, startX,
					startY + diff0, startY + diff1, endY + diff1, endY + diff0,
					endY - startY, 0, 0, 0,
					edge1, edge2, edge3, edge4, 0, 0, 0

				gosub "wallTextureCoor"	! fix the texture coordite system
			endif

		endif
	endif

else

!*** curved ***!

	if mirrorArcs < EPS then

		if bDoCut then

			putAngle = abs(WIDO_POSITION) - startAngle
			putY = startY
			flags = 0
			gosub 22
			iStart = int((abs(WIDO_POSITION) - endAngle) / (180 / WALL_RESOL)) + 1
			iEnd = int((abs(WIDO_POSITION) - startAngle) / (180 / WALL_RESOL))
			for i = 1 to iEnd - iStart
				putAngle = (iEnd - i + 1) * (180 / WALL_RESOL)
				putY = startY
				flags = 0
				gosub 22
			next i
			putAngle = abs(WIDO_POSITION) - endAngle
			putY = startY
			flags = 0
			gosub 22
			putAngle = abs(WIDO_POSITION) - endAngle
			putY = endY
			flags = edge3
			gosub 22
			for i = iStart to iEnd
				putAngle = i * (180 / WALL_RESOL)
				putY = endY
				flags = 0
				gosub 22
			next i
			putAngle = abs(WIDO_POSITION) - startAngle
			putY = endY
			flags = 0
			gosub 22

			wallniche NSP/3, 1, 1,
				0, 0, 1, height,
				get(NSP)

		else

			if bittest(edge1, 0) > EPS then
				edge1_ = bitset(edge1_, 2)
			endif
			if bittest(edge1, 1) > EPS then
				edge2_ = bitset(edge2_, 1)
			endif
			if bittest(edge1, 2) > EPS then
				edge1_ = bitset(edge1_, 0)
			endif
			if bittest(edge1, 3) > EPS then
				edge1_ = bitset(edge1_, 3)
			endif
			if bittest(edge2, 0) > EPS then
				edge4_ = bitset(edge4_, 2)
			endif
			if bittest(edge2, 1) > EPS then
				edge1_ = bitset(edge1_, 1)
			endif
			if bittest(edge2, 2) > EPS then
				edge4_ = bitset(edge4_, 0)
			endif
			if bittest(edge2, 3) > EPS then
				edge4_ = bitset(edge4_, 3)
			endif
			if bittest(edge3, 0) > EPS then
				edge3_ = bitset(edge3_, 2)
			endif
			if bittest(edge3, 1) > EPS then
				edge4_ = bitset(edge4_, 1)
			endif
			if bittest(edge3, 2) > EPS then
				edge3_ = bitset(edge3_, 0)
			endif
			if bittest(edge3, 3) > EPS then
				edge3_ = bitset(edge3_, 3)
			endif
			if bittest(edge4, 0) > EPS then
				edge2_ = bitset(edge2_, 2)
			endif
			if bittest(edge4, 1) > EPS then
				edge3_ = bitset(edge3_, 1)
			endif
			if bittest(edge4, 2) > EPS then
				edge2_ = bitset(edge2_, 0)
			endif
			if bittest(edge4, 3) > EPS then
				edge2_ = bitset(edge2_, 3)
			endif

			lengthMul = (innerRadius + endY) / (outerRadius - WALL_THICKNESS/2)
			addy startY

			addy -(innerRadius + startY)
			rotz -endAngle
			roty 90
			mul -1, 1, 1
			if (abs(WIDO_POSITION) - endAngle) < 180 then
				cutformwidth = (innerRadius + startY) * cos(WIDO_POSITION - endAngle)
				cutformwidth2 = (innerRadius + endY) * cos(WIDO_POSITION - endAngle) - WALL_THICKNESS
				if cutformwidth2 < cutformwidth then
					cutformwidth = cutformwidth2
				endif
			else
				cutformwidth = -(innerRadius + endY) * 1.1
				mulz -1
				cutform 4, 1, 3+192,
					0, 0, 1, -(innerRadius + endY) * 1.1 * sin(WIDO_POSITION - endAngle),
					-0.1, (innerRadius + startY) * cos(WIDO_POSITION - endAngle) * 0.9, 1,
					height+0.1, (innerRadius + startY) * cos(WIDO_POSITION - endAngle) * 0.9, 1,
					height+0.1, -(innerRadius + endY) * 1.1, 1,
					-0.1, -(innerRadius + endY) * 1.1, 1
				del 1
			endif
			cutform 4, 1, 3+192,
				0, 0, 1, (innerRadius + endY) * 1.1,
				-0.1, cutformwidth, 1,
				height+0.1, cutformwidth, 1,
				height+0.1, (innerRadius + endY) * 1.1, 1,
				-0.1, (innerRadius + endY) * 1.1, 1
			del 4

			addy -(innerRadius + startY)
			rotz -startAngle
			roty 90
			mul -1, 1, -1
			cutform 4, 1, 3+192,
				0, 0, 1, innerRadius + endY,
				-EPS, 0, 1,
				height+EPS, 0, 1,
				height+EPS, (innerRadius + endY) * 1.2, 1,
				-EPS, (innerRadius + endY) * 1.2, 1
			del 4
			del 1

			segmentSafetyAdd = 3 * (innerRadius + endY) * (2 * PI / WALL_RESOL)
			if abs (endAngle) > EPS then
				add 0, -innerRadius, 0
				rotz -abs(WIDO_POSITION)
				add 0, innerRadius + endY, 0
				wallLength = (innerRadius + endY) * abs(WIDO_POSITION) * PI / 180
			else
				add 0, endY, 0
			endif
			rotz 180
			if abs (startX) > EPS then
				wallLength = wallLength + segmentSafetyAdd - startX * lengthMul
			endif

			xwall_ matRight, matLeft, matVert, matHoriz,
					height, 0, wallLength, wallLength, 0,
					0, 0, endY - startY, endY - startY,
					endY - startY, innerRadius + endY,
					0, 0,
					edge1_, edge2_, edge3_, edge4_, 0, 0, 0

			if abs(endAngle) > EPS then
				del 2
			endif
			del 2

			cutend
			cutend
			if not((abs(WIDO_POSITION) - endAngle) < 180) then
				cutend
			endif

			putAngle = abs(WIDO_POSITION) - endAngle
			putY = startY
			flags = 0
			gosub 22
			xInner = get(1)
			yInner = get(1)
			dummy = get(1)
			putY = endY
			flags = 0
			gosub 22
			xOuter = get(1)
			yOuter = get(1)
			dummy = get(1)
			if bittest(edge2, 0) > EPS then
				lin_ xInner, yInner, 0, xInner, yInner, height
			endif
			if bittest(edge2, 2) > EPS then
				lin_ xOuter, yOuter, 0, xOuter, yOuter, height
			endif
			if bittest(edge2, 1) > EPS then
				lin_ xInner, yInner, 0, xOuter, yOuter, 0
			endif
			if bittest(edge3, 1) > EPS then
				lin_ xInner, yInner, height, xOuter, yOuter, height
			endif

			putAngle = abs(WIDO_POSITION) - startAngle
			putY = startY
			flags = 0
			gosub 22
			xInner = get(1)
			yInner = get(1)
			dummy = get(1)
			putY = endY
			flags = 0
			gosub 22
			xOuter = get(1)
			yOuter = get(1)
			dummy = get(1)
			if bittest(edge4, 0) > EPS then
				lin_ xInner, yInner, 0, xInner, yInner, height
			endif
			if bittest(edge4, 2) > EPS then
				lin_ xOuter, yOuter, 0, xOuter, yOuter, height
			endif
			if bittest(edge1, 1) > EPS then
				lin_ xInner, yInner, 0, xOuter, yOuter, 0
			endif
			if bittest(edge4, 1) > EPS then
				lin_ xInner, yInner, height, xOuter, yOuter, height
			endif

		endif

	else

		if bDoCut then

			putAngle = startAngle
			putY = startY
			flags = 0
			gosub 23
			iStart = int(startAngle / (180 / WALL_RESOL)) + 1
			iEnd = int(endAngle / (180 / WALL_RESOL))
			for i = iStart to iEnd
				putAngle = i * (180 / WALL_RESOL)
				putY = startY
				flags = 0
				gosub 23
			next i
			putAngle = endAngle
			putY = startY
			flags = 0
			gosub 23
			putAngle = endAngle
			putY = endY
			flags = 0
			gosub 23
			for i = iStart to iEnd
				putAngle = (iEnd + iStart - i) * (180 / WALL_RESOL)
				putY = endY
				flags = 0
				gosub 23
			next i
			putAngle = startAngle
			putY = endY
			flags = 0
			gosub 23

			wallniche NSP/3, 1, 1,
				0, 0, 1, height,
				get(NSP)

		else

			lengthMul = (outerRadius - startY) / (outerRadius - WALL_THICKNESS/2)
			segmentSafetyAdd = 3 * (outerRadius - startY) * (2 * PI / WALL_RESOL)
			addy startY

			addy (outerRadius - startY)
			rotz endAngle
			roty 90
			mul -1, -1, 1
			cutform 4, 1, 3+192,
				0, 0, 1, segmentSafetyAdd * lengthMul,
				-EPS, 0, 1,
				height+EPS, 0, 1,
				height+EPS, (outerRadius - startY) * 1.2, 1,
				-EPS, (outerRadius - startY) * 1.2, 1
			del 4

			addy (outerRadius - startY)
			rotz startAngle
			roty -90
			mul 1, -1, 1
			cutform 4, 1, 3+192,
				0, 0, 1, segmentSafetyAdd * lengthMul,
				-EPS, 0, 1,
				height+EPS, 0, 1,
				height+EPS, (outerRadius - startY) * 1.2, 1,
				-EPS, (outerRadius - startY) * 1.2, 1
			del 4

			xStartWall = 0
			if startX < -EPS then
				xStartWall = (startX - segmentSafetyAdd) * lengthMul
			endif
			if abs(endX) < EPS then
				xEndWall = 0
			else
				xEndWall = (endX + segmentSafetyAdd) * lengthMul
			endif
			xwall_ matLeft, matRight, matVert, matHoriz,
					height, xStartWall, xEndWall, xEndWall, xStartWall,
					0, 0, endY - startY, endY - startY,
					endY - startY, outerRadius - startY,
					0, 0,
					edge1, edge2, edge3, edge4, 0, 0, 0
			cutend
			cutend
			del 1

			putAngle = endAngle
			putY = startY
			flags = 0
			gosub 23
			xInner = get(1)
			yInner = get(1)
			dummy = get(1)
			putY = endY
			flags = 0
			gosub 23
			xOuter = get(1)
			yOuter = get(1)
			dummy = get(1)
			if bittest(edge2, 0) > EPS then
				lin_ xInner, yInner, 0, xInner, yInner, height
			endif
			if bittest(edge2, 2) > EPS then
				lin_ xOuter, yOuter, 0, xOuter, yOuter, height
			endif
			if bittest(edge2, 1) > EPS then
				lin_ xInner, yInner, 0, xOuter, yOuter, 0
			endif
			if bittest(edge3, 1) > EPS then
				lin_ xInner, yInner, height, xOuter, yOuter, height
			endif

			putAngle = startAngle
			putY = startY
			flags = 0
			gosub 23
			xInner = get(1)
			yInner = get(1)
			dummy = get(1)
			putY = endY
			flags = 0
			gosub 23
			xOuter = get(1)
			yOuter = get(1)
			dummy = get(1)
			if bittest(edge4, 0) > EPS then
				lin_ xInner, yInner, 0, xInner, yInner, height
			endif
			if bittest(edge4, 2) > EPS then
				lin_ xOuter, yOuter, 0, xOuter, yOuter, height
			endif
			if bittest(edge1, 1) > EPS then
				lin_ xInner, yInner, 0, xOuter, yOuter, 0
			endif
			if bittest(edge4, 1) > EPS then
				lin_ xInner, yInner, height, xOuter, yOuter, height
			endif

		endif

	endif

endif

! queue restoring omitted - assuming it is not used outside

end


!**************************** SUBROUTINES ***********************************!

! ===== set the texture coordinate system to match the wall =====
"wallTextureCoor":
	if gs_useWallMat then
		for iTrafo = numTrafo to 1 step -1
			if abs(trafo_array[iTrafo][1] - TRAFO_ADD_X) < EPS then
				addx -trafo_array[iTrafo][2]
			endif
			if abs(trafo_array[iTrafo][1] - TRAFO_ADD_Y) < EPS then
				addy -trafo_array[iTrafo][2]
			endif
			if abs(trafo_array[iTrafo][1] - TRAFO_ADD_Z) < EPS then
				addz -trafo_array[iTrafo][2]
			endif
			if abs(trafo_array[iTrafo][1] - TRAFO_ROT_X) < EPS then
				rotx -trafo_array[iTrafo][2]
			endif
			if abs(trafo_array[iTrafo][1] - TRAFO_ROT_Y) < EPS then
				roty -trafo_array[iTrafo][2]
			endif
			if abs(trafo_array[iTrafo][1] - TRAFO_ROT_Z) < EPS then
				rotz -trafo_array[iTrafo][2]
			endif
			if abs(trafo_array[iTrafo][1] - TRAFO_MUL_X) < EPS then
				mulx 1/trafo_array[iTrafo][2]
			endif
			if abs(trafo_array[iTrafo][1] - TRAFO_MUL_Y) < EPS then
				muly 1/trafo_array[iTrafo][2]
			endif
			if abs(trafo_array[iTrafo][1] - TRAFO_MUL_Z) < EPS then
				mulz 1/trafo_array[iTrafo][2]
			endif
		next iTrafo

		base
		vert WALL_TEXTURE_WRAP[3], WALL_TEXTURE_WRAP[4], WALL_TEXTURE_WRAP[5]
		vert WALL_TEXTURE_WRAP[6], WALL_TEXTURE_WRAP[7], WALL_TEXTURE_WRAP[8]
		vert WALL_TEXTURE_WRAP[9], WALL_TEXTURE_WRAP[10], WALL_TEXTURE_WRAP[11]
		vert WALL_TEXTURE_WRAP[12], WALL_TEXTURE_WRAP[13], WALL_TEXTURE_WRAP[14]
		coor{2} WALL_TEXTURE_WRAP[1], WALL_TEXTURE_WRAP[2], -1, -2, -3, -4
		body 1

		for iTrafo = 1 to numTrafo
			if (trafo_array[iTrafo][1] > 0) and (trafo_array[iTrafo][1] < 10) then
				del 1
			endif
		next iTrafo
	else
		!	only straight and trapeze walls
		if abs(WIDO_POSITION) > EPS then
			if SYMB_MIRRORED then
				base
				vert WIDO_POSITION, WALL_END_THICKNESS - WALL_START_THICKNESS, 0
				vert 0, 0, 0
				vert WIDO_POSITION, WALL_THICKNESS, 0
				vert WIDO_POSITION, WALL_END_THICKNESS - WALL_START_THICKNESS, 1
				coor 21, -1, -2, -3, -4
				body 1
			else
				base
				vert WIDO_POSITION, WALL_START_THICKNESS, 0
				vert WIDO_POSITION-1, WALL_START_THICKNESS - tan(incAngle), 0
				vert WIDO_POSITION, 0, 0
				vert WIDO_POSITION, WALL_START_THICKNESS, 1
				coor 21, -1, -2, -3, -4
				body 1
			endif
		endif
	endif
return

! ===== calculate the segmentation-correct position of a point =====
22:
	!	innerRadius > EPS and mirrorArcs < EPS assumed

	n = int(putAngle / (180 / WALL_RESOL))
	frag = fra(putAngle / (180 / WALL_RESOL)) * (180 / WALL_RESOL)

	if abs(putAngle - abs(WIDO_POSITION)) > EPS then
		if n % 2 < EPS then
			tanIncl = abs(WIDO_POSITION) - n * (180 / WALL_RESOL)
			put (innerRadius + putY) * (sin(tanIncl) - tan(frag) * cos(tanIncl)), putY - (innerRadius + putY) * (1 - cos(tanIncl) - tan(frag) * sin(tanIncl)), flags
		else
			tanIncl = abs(WIDO_POSITION) - (n + 1) * (180 / WALL_RESOL)
			frag = 180 / WALL_RESOL - frag
			put (innerRadius + putY) * (sin(tanIncl) + tan(frag) * cos(tanIncl)), putY - (innerRadius + putY) * (1 - cos(tanIncl) + tan(frag) * sin(tanIncl)), flags
		endif
	else
		put 0, putY, flags
	endif

return

! ===== calculate the segmentation-correct position of a point =====
23:
	!	innerRadius > EPS and mirrorArcs > EPS assumed

	n = int(putAngle / (180 / WALL_RESOL))
	frag = fra(putAngle / (180 / WALL_RESOL)) * (180 / WALL_RESOL)

	if n % 2 < EPS then
		tanIncl = n * (180 / WALL_RESOL)
		put (outerRadius - putY) * (sin(tanIncl) + tan(frag) * cos(tanIncl)), putY + (outerRadius - putY) * (1 - cos(tanIncl) + tan(frag) * sin(tanIncl)), flags
	else
		tanIncl = (n + 1) * (180 / WALL_RESOL)
		frag = 180 / WALL_RESOL - frag
		put (outerRadius - putY) * (sin(tanIncl) - tan(frag) * cos(tanIncl)), putY + (outerRadius - putY) * (1 - cos(tanIncl) - tan(frag) * sin(tanIncl)), flags
	endif

return
]]>
</Script_3D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_2D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! Contact person: <TZs>

! =============================================================================
! The macro draws a rectangular (or ring-sector-part) wall block in 2D
! considering the possible distortions caused by trapeze or curved walls.
! -----------------------------------------------------------------------------
! Input Parameters:
!	startX:				diagonal corner 1
!	startY:				(at bottom)	must be lower than yEnd
!	endX:				diagonal corner 2
!	endY:				(at top)	must be greater than yStart
!	trapType:			type of rectangular block	(integer)
!							(0 = rectangle, 1 = trapeze, 2 = parallelogram)
!	innerRadius:		inner radius of curved wall (length)
!	outerRadius:		outer radius of curved wall (if 0, it will be computed)
!	incAngle:			signed inclination angle of trapeze vall (angle)
!	fillPen:			fill pattern foreground pen
!	fillBGPen:			fill pattern background pen
!	fillType:			fill generator command: poly / wallhole / wallblock
!	bLocalFill:			use local hatching (0 / 1)
!	bCoverFill:			place cover fill (not cut) (0 / 1)
!	shContour:			draw the contour lines of the rectangle (0 / 1)
!	startLinepen:		start line (x = xStart) pen
!	startLineLineType:	start line (x = xStart) linetype
!	startLineCont:		start line (x = xStart) is contour (0 / 1)
!	endLinePen:			end line (x = xEnd) pen
!	endLineLineType:	end line (x = xEnd) linetype
!	endLineCont:		end line (x = xEnd) is contour (0 / 1)
!	topLinePen:			top line (y = yEnd) pen
!	topLineLineType:	top line (y = yEnd) linetype
!	topLineCont:		top line (y = yEnd) is contour (0 / 1)
!	bottomLinePen:		bottom line (y = yStart) pen
!	bottomLineLineType:	bottom line (y = yStart) linetype
!	bottomLineCont:		bottom line (y = yStart) is contour (0 / 1)
!
! Remark:
!	The generated shapes are:
!		rectangle (used in straight and trapeze walls)
!		trapeze (in trapeze walls)
!		parallelogram (in trapeze walls)
!		ring-sector (in curved walls)

if fillPattern >= 0 then
	set fill fillPattern
else
	fillPattern = 1
endif

if bFitToSkinFill then
	if bChangeFitToSkinFillOrient then
		skinThick = abs(startY-endY)

		FillOrientXx = 1
		FillOrientXy = 0
		FillOrientYx = 0
		FillOrientYy = skinThick
	else
		skinThick = abs(startX-endX)

		FillOrientXx = 0
		FillOrientXy = 1
		FillOrientYx = skinThick
		FillOrientYy = 0
	endif
endif

if innerRadius < EPS then

!*** straight ***!

	if abs(incAngle) < EPS or trapType = 0 then
		!--- rectangle ---
		if abs(startX - endX) > EPS and (fillPattern > 0 or fillBGPen <> 0 or shContour)  then
			if bFitToSkinFill then
				put 4, shContour + 2 + 4, 1 + bCoverFill, 8 + 32,
						fillPen, fillBGPen,
						startX, startY,
						FillOrientXx, FillOrientXy, FillOrientYx, FillOrientYy,
						0,
						startX, startY, 1,
						startX, endY, 1,
						endX, endY, 1,
						endX, startY, 1

				if fillType = 0 then
					poly2_b{5} get (NSP)
				else
					if fillType = 1 then
						wallhole2{2} get (NSP)
					else
						wallblock2{2} get (NSP)
					endif
				endif
			else
				put 4, shContour + 2 + 4 + (8 + 16) * bLocalFill + 32 + 32 * bCoverFill, fillPen, fillBGPen,
						0, 0, 0,
						startX, startY, 1,
						startX, endY, 1,
						endX, endY, 1,
						endX, startY, 1

				if fillType = 0 then
					poly2_b{2} get (NSP)
				else
					if fillType = 1 then
						wallhole2 get (NSP)
					else
						wallblock2 get (NSP)
					endif
				endif
			endif
		endif

		if startLinePen > 0 then
			pen startLinePen
			line_type startLineLineType
			line_property (startLineCont + 1)
			line2 startX, endY, startX, startY
		endif

		if endLinePen > 0 then
			pen endLinePen
			line_type endLineLineType
			line_property (endLineCont + 1)
			line2 endX, startY, endX, endY
		endif

		if topLinePen > 0 then
			pen topLinePen
			line_type topLineLineType
			line_property (topLineCont + 1)
			line2 startX, startY, endX, startY
		endif

		if bottomLinePen > 0 then
			pen bottomLinePen
			line_type bottomLineLineType
			line_property (bottomLineCont + 1)
			line2 startX, endY, endX, endY
		endif
	else
		diff0 = startX * tan(incAngle)
		diff1 = endX * tan(incAngle)
		if trapType = 1 then
			!--- trapeze ---
			if SYMB_MIRRORED then
				if abs(startX - endX) > EPS and (fillPattern > 0 or fillBGPen <> 0 or shContour)  then
					if bFitToSkinFill then
						put 4, shContour + 2 + 4, 1 + bCoverFill, 8 + 32,
								fillPen, fillBGPen,
								startX, startY + diff0,
								FillOrientXx, FillOrientXy, FillOrientYx, FillOrientYy,
								0,
								startX, startY + diff0, 1,
								startX, endY, 1,
								endX, endY, 1,
								endX, startY + diff1, 1

						if fillType = 0 then
							poly2_b{5} get (NSP)
						else
							if fillType = 1 then
								wallhole2{2} get (NSP)
							else
								wallblock2{2} get (NSP)
							endif
						endif
					else
						put 4, shContour + 2 + 4 + (8 + 16) * bLocalFill + 32 + 32 * bCoverFill, fillPen, fillBGPen,
								0, 0, 0,
								startX, startY + diff0, 1,
								startX, endY, 1,
								endX, endY, 1,
								endX, startY + diff1, 1

						if fillType = 0 then
							poly2_b{2} get (NSP)
						else
							if fillType = 1 then
								wallhole2 get (NSP)
							else
								wallblock2 get (NSP)
							endif
						endif
					endif
				endif

				if startLinePen > 0 then
					pen startLinePen
					line_type startLineLineType
					line_property (startLineCont + 1)
					line2 startX, endY, startX, startY + diff0
				endif

				if endLinePen > 0 then
					pen endLinePen
					line_type endLineLineType
					line_property (endLineCont + 1)
					line2 endX, startY + diff1, endX, endY
				endif

				if topLinePen > 0 then
					pen topLinePen
					line_type topLineLineType
					line_property (topLineCont + 1)
					line2 startX, startY + diff0, endX, startY + diff1
				endif

				if bottomLinePen > 0 then
					pen bottomLinePen
					line_type bottomLineLineType
					line_property (bottomLineCont + 1)
					line2 startX, endY, endX, endY
				endif
			else
				if abs(startX - endX) > EPS and (fillPattern > 0 or fillBGPen <> 0 or shContour)  then
					if bFitToSkinFill then
						put 4, shContour + 2 + 4, 1 + bCoverFill, 8 + 32,
								fillPen, fillBGPen,
								startX, startY,
								FillOrientXx, FillOrientXy, FillOrientYx, FillOrientYy,
								0,
								startX, startY, 1,
								startX, endY + diff0, 1,
								endX, endY + diff1, 1,
								endX, startY, 1

						if fillType = 0 then
							poly2_b{5} get (NSP)
						else
							if fillType = 1 then
								wallhole2{2} get (NSP)
							else
								wallblock2{2} get (NSP)
							endif
						endif
					else
						put 4, shContour + 2 + 4 + (8 + 16) * bLocalFill + 32 + 32 * bCoverFill, fillPen, fillBGPen,
								0, 0, 0,
								startX, startY, 1,
								startX, endY + diff0, 1,
								endX, endY + diff1, 1,
								endX, startY, 1

						if fillType = 0 then
							poly2_b{2} get (NSP)
						else
							if fillType = 1 then
								wallhole2 get (NSP)
							else
								wallblock2 get (NSP)
							endif
						endif
					endif
				endif

				if startLinePen > 0 then
					pen startLinePen
					line_type startLineLineType
					line_property (startLineCont + 1)
					line2 startX, endY + diff0, startX, startY
				endif

				if endLinePen > 0 then
					pen endLinePen
					line_type endLineLineType
					line_property (endLineCont + 1)
					line2 endX, startY, endX, endY + diff1
				endif

				if topLinePen > 0 then
					pen topLinePen
					line_type topLineLineType
					line_property (topLineCont + 1)
					line2 startX, startY, endX, startY
				endif

				if bottomLinePen > 0 then
					pen bottomLinePen
					line_type bottomLineLineType
					line_property (bottomLineCont + 1)
					line2 startX, endY + diff0, endX, endY + diff1
				endif
			endif
		else
			!--- parallelogram ---
			if abs(startX - endX) > EPS and (fillPattern > 0 or fillBGPen <> 0 or shContour) then
				if bFitToSkinFill then
					put 4, shContour + 2 + 4, 1 + bCoverFill, 8 + 32,
							fillPen, fillBGPen,
							startX, startY + diff0,
							FillOrientXx, FillOrientXy, FillOrientYx, FillOrientYy,
							0,
							startX, startY + diff0, 1,
							startX, endY + diff0, 1,
							endX, endY + diff1, 1,
							endX, startY + diff1, 1

					if fillType = 0 then
						poly2_b{5} get (NSP)
					else
						if fillType = 1 then
							wallhole2{2} get (NSP)
						else
							wallblock2{2} get (NSP)
						endif
					endif
				else
					put 4, shContour + 2 + 4 + (8 + 16) * bLocalFill + 32 + 32 * bCoverFill, fillPen, fillBGPen,
							0, 0, 0,
							startX, startY + diff0, 1,
							startX, endY + diff0, 1,
							endX, endY + diff1, 1,
							endX, startY + diff1, 1

					if fillType = 0 then
						poly2_b{2} get (NSP)
					else
						if fillType = 1 then
							wallhole2 get (NSP)
						else
							wallblock2 get (NSP)
						endif
					endif
				endif
			endif

			if startLinePen > 0 then
				pen startLinePen
				line_type startLineLineType
				line_property (startLineCont + 1)
				line2 startX, endY + diff0, startX, startY + diff0
			endif

			if endLinePen > 0 then
				pen endLinePen
				line_type endLineLineType
				line_property (endLineCont + 1)
				line2 endX, startY + diff1, endX, endY + diff1
			endif

			if topLinePen > 0 then
				pen topLinePen
				line_type topLineLineType
				line_property (topLineCont + 1)
				line2 startX, startY + diff0, endX, startY + diff1
			endif

			if bottomLinePen > 0 then
				pen bottomLinePen
				line_type bottomLineLineType
				line_property (bottomLineCont + 1)
				line2 startX, endY + diff0, endX, endY + diff1
			endif
		endif
	endif

else

!*** curved ***!

	if mirrorArcs then
		add2 0, outerRadius
		rot2 +startAngle
		add2 0, -outerRadius
	else
		add2 0, -innerRadius
		rot2 -startAngle
		add2 0, innerRadius
	endif
	if abs(startX - endX) > EPS and (fillPattern > 0 or fillBGPen <> 0 or shContour)  then
		if mirrorArcs then
			if bFitToSkinFill then
				put 6, shContour + 2 + 4, 1 + bCoverFill, 4*bCircularDistortion + 8 + 32,
						fillPen, fillBGPen,
						0, startY,
						FillOrientXx, FillOrientXy, FillOrientYx, FillOrientYy,
						-outerRadius+startY,
						0, startY, 1,
						0, outerRadius, 900,
						outerRadius+startY, (endAngle-startAngle), 4001,
						endY-startY, 90+(endAngle-startAngle), 201,
						0, outerRadius, 900,
						outerRadius+endX, -(endAngle-startAngle), 4001

				if fillType = 0 then
					poly2_b{5} get (NSP)
				else
					if fillType = 1 then
						wallhole2{2} get (NSP)
					else
						wallblock2{2} get (NSP)
					endif
				endif
			else
				put 6, shContour + 2 + 4 + (8 + 16) * bLocalFill + 32 + 32 * bCoverFill, fillPen, fillBGPen,
						0, 0, 90 + WALL_DIRECTION - startAngle,
						0, startY, 1,
						0, outerRadius, 900,
						outerRadius+startY, (endAngle-startAngle), 4001,
						endY-startY, 90+(endAngle-startAngle), 201,
						0, outerRadius, 900,
						outerRadius+endX, -(endAngle-startAngle), 4001

				if fillType = 0 then
					poly2_b{2} get (NSP)
				else
					if fillType = 1 then
						wallhole2 get (NSP)
					else
						wallblock2 get (NSP)
					endif
				endif
			endif
		else
			if bFitToSkinFill then
				put 6, shContour + 2 + 4, 1 + bCoverFill, 4*bCircularDistortion + 8 + 32,
						fillPen, fillBGPen,
						0, startY,
						FillOrientXx, FillOrientXy, FillOrientYx, FillOrientYy,
						innerRadius+startY,
						0, startY, 1,
						0, -innerRadius, 900,
						innerRadius+startY, -(endAngle-startAngle), 4001,
						endY-startY, 90-(endAngle-startAngle), 201,
						0, -(innerRadius), 900,
						innerRadius+endX, endAngle-startAngle, 4001

				if fillType = 0 then
					poly2_b{5} get (NSP)
				else
					if fillType = 1 then
						wallhole2{2} get (NSP)
					else
						wallblock2{2} get (NSP)
					endif
				endif
			else
				put 6, shContour + 2 + 4 + (8 + 16) * bLocalFill + 32 + 32 * bCoverFill, fillPen, fillBGPen,
						0, 0, 90 + WALL_DIRECTION + startAngle,
						0, startY, 1,
						0, -innerRadius, 900,
						innerRadius+startY, -(endAngle-startAngle), 4001,
						endY-startY, 90-(endAngle-startAngle), 201,
						0, -(innerRadius), 900,
						innerRadius+endX, endAngle-startAngle, 4001

				if fillType = 0 then
					poly2_b{2} get (NSP)
				else
					if fillType = 1 then
						wallhole2 get (NSP)
					else
						wallblock2 get (NSP)
					endif
				endif
			endif
		endif
	endif

	if startLinePen > 0 then
		pen startLinePen
		line_type startLineLineType
		line_property (startLineCont + 1)
		line2 0, endY, 0, startY
	endif

	del 3
	if endLinePen > 0 then
		if mirrorArcs < EPS then
			add2 0, -innerRadius
			rot2 -endAngle
			add2 0, innerRadius
		else
			add2 0, outerRadius
			rot2 +endAngle
			add2 0, -outerRadius
		endif
		pen endLinePen
		line_type endLineLineType
		line_property (endLineCont + 1)
		line2 0, startY, 0, endY
		del 3
	endif

	if topLinePen > 0 then
		pen topLinePen
		line_type topLineLineType
		line_property (topLineCont + 1)
		if mirrorArcs then
			arc2 0, outerRadius, outerRadius - startY, 270+startAngle, 270+endAngle
		else
			arc2 0, -innerRadius, innerRadius + startY, 90-endAngle, 90-startAngle
		endif
	endif

	if bottomLinePen > 0 then
		pen bottomLinePen
		line_type bottomLineLineType
		line_property (bottomLineCont + 1)
		if mirrorArcs then
			arc2 0, outerRadius, outerRadius - endY, 270+startAngle, 270+endAngle
		else
			arc2 0, -innerRadius, innerRadius + endY, 90-endAngle, 90-startAngle
		endif
	endif

endif
]]>
</Script_2D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_1D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! Contact person: <TZs>

! const values for parameter: trafo_array
TRAFO_ADD_X = 1
TRAFO_ADD_Y = 2
TRAFO_ADD_Z = 3
TRAFO_ROT_X = 4
TRAFO_ROT_Y = 5
TRAFO_ROT_Z = 6
TRAFO_MUL_X = 7
TRAFO_MUL_Y = 8
TRAFO_MUL_Z = 9

EPS = 0.001

if innerRadius > EPS then

	startAngle = (startX / (innerRadius + WALL_THICKNESS/2)) / PI * 180
	endAngle = (endX / (innerRadius + WALL_THICKNESS/2)) / PI * 180

	if outerRadius < EPS then
		outerRadius = innerRadius + WALL_THICKNESS
	endif

	mirrorArcs = 0
	if abs(WIDO_POSITION) < EPS then
		mirrorArcs = 1
	endif

endif
]]>
</Script_1D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_PR SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_PR>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_UI SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_UI>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_VL SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_VL>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Comment SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Comment>

<ParamSection SectVersion="26" SectionFlags="0" SubIdent="0">
	<ParamSectHeader>
		<Version>26</Version>
		<AutoHotspots>false</AutoHotspots>
		<StatBits>
			<STBit_FixSize/>
		</StatBits>
		<WDLeftFrame>0</WDLeftFrame>
		<WDRightFrame>0</WDRightFrame>
		<WDTopFrame>0</WDTopFrame>
		<WDBotFrame>0</WDBotFrame>
		<LayFlags>65535</LayFlags>
		<WDMirrorThickness>0</WDMirrorThickness>
		<WDWallInset>0</WDWallInset>
		<SymbolColor>0</SymbolColor>
	</ParamSectHeader>
	<Parameters>
		<Length Name="A">
			<Description><![CDATA["Dimension 1"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Length Name="B">
			<Description><![CDATA["Dimension 2"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Length Name="ZZYZX">
			<Description><![CDATA["Height"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Boolean Name="AC_show2DHotspotsIn3D">
			<Description><![CDATA["Show 2D Hotspots in 3D"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="ac_bottomlevel">
			<Description><![CDATA["Bottom Level"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="ac_toplevel">
			<Description><![CDATA["Top Level"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Integer Name="gs_macro_version">
			<Description><![CDATA["Macro Version"]]></Description>
			<Value>9</Value>
		</Integer>
		<Integer Name="numTrafo">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Integer>
		<Length Name="trafo_array">
			<Description><![CDATA[""]]></Description>
			<ArrayValues FirstDimension="1" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Boolean Name="gs_useWallMat">
			<Description><![CDATA[""]]></Description>
			<Value>1</Value>
		</Boolean>
		<Length Name="startX">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="startY">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="endX">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="endY">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="innerRadius">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="outerRadius">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Length>
		<Angle Name="incAngle">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Angle>
		<Angle Name="ac_wall_slant_angle1">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Angle>
		<Angle Name="ac_wall_slant_angle2">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Angle>
		<Integer Name="trapType">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Integer>

		<!-- SkinRect_sp0: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="SkinRect_sp0">
			<Description><![CDATA["2D"]]></Description>
		</Title>
		<FillPattern Name="fillPattern">
			<Description><![CDATA[""]]></Description>
			<Value>-1</Value>
		</FillPattern>
		<PenColor Name="fillPen">
			<Description><![CDATA[""]]></Description>
			<Value>1</Value>
		</PenColor>
		<PenColor Name="fillBGPen">
			<Description><![CDATA[""]]></Description>
			<Value>19</Value>
		</PenColor>
		<Integer Name="fillType">
			<Description><![CDATA["Object / Wallhole / Wallblock"]]></Description>
			<Value>0</Value>
		</Integer>
		<Boolean Name="bLocalFill">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bFitToSkinFill">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bChangeFitToSkinFillOrient">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bCircularDistortion">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bCoverFill">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="shContour">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<PenColor Name="startLinePen">
			<Description><![CDATA["0 for none"]]></Description>
			<Value>0</Value>
		</PenColor>
		<LineType Name="startLineLineType">
			<Description><![CDATA[""]]></Description>
			<Value>1</Value>
		</LineType>
		<Boolean Name="startLineCont">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<PenColor Name="endLinePen">
			<Description><![CDATA["0 for none"]]></Description>
			<Value>0</Value>
		</PenColor>
		<LineType Name="endLineLineType">
			<Description><![CDATA[""]]></Description>
			<Value>1</Value>
		</LineType>
		<Boolean Name="endLineCont">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<PenColor Name="bottomLinePen">
			<Description><![CDATA["0 for none"]]></Description>
			<Value>0</Value>
		</PenColor>
		<LineType Name="bottomLineLineType">
			<Description><![CDATA[""]]></Description>
			<Value>1</Value>
		</LineType>
		<Boolean Name="bottomLineCont">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<PenColor Name="topLinePen">
			<Description><![CDATA["0 for none"]]></Description>
			<Value>0</Value>
		</PenColor>
		<LineType Name="topLineLineType">
			<Description><![CDATA[""]]></Description>
			<Value>1</Value>
		</LineType>
		<Boolean Name="topLineCont">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>

		<!-- SkinRect_sp1: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="SkinRect_sp1">
			<Description><![CDATA["3D"]]></Description>
		</Title>
		<Boolean Name="bDoCut">
			<Description><![CDATA["Cut or Place Block"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Length Name="height">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Length>
		<Integer Name="edge1">
			<Description><![CDATA[""]]></Description>
			<Value>15</Value>
		</Integer>
		<Integer Name="edge2">
			<Description><![CDATA[""]]></Description>
			<Value>15</Value>
		</Integer>
		<Integer Name="edge3">
			<Description><![CDATA[""]]></Description>
			<Value>15</Value>
		</Integer>
		<Integer Name="edge4">
			<Description><![CDATA[""]]></Description>
			<Value>15</Value>
		</Integer>
		<Material Name="matLeft">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Material>
		<Material Name="matRight">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Material>
		<Material Name="matVert">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Material>
		<Material Name="matHoriz">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Material>
	</Parameters>
</ParamSection>

<CalledMacros SectVersion="2" SectionFlags="0" SubIdent="0">
</CalledMacros>

<Copyright SectVersion="1" SectionFlags="0" SubIdent="0">
	<Author>GRAPHISOFT</Author>
	<License>
		<Type>CC BY-ND</Type>
		<Version>3.0</Version>
	</License>
</Copyright>

</Symbol>
