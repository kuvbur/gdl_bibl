<?xml version="1.0" encoding="UTF-8"?>
<Symbol IsArchivable="false" IsPlaceable="false" MainGUID="077DDB07-098E-4DF5-B57F-6FE2ADD2426F" MigrationValue="Normal" Owner="0" Signature="1465080141" Version="43">
<Ancestry SectVersion="1" SectionFlags="0" SubIdent="0" Template="false">
	<MainGUID>F938E33A-329D-4A36-BE3E-85E126820996</MainGUID>
	<MainGUID>103E8D2C-8230-42E1-9597-46F84CCE28C0</MainGUID>
	<MainGUID>B2970E4C-8680-4061-8670-2F4B638F3953</MainGUID>
</Ancestry>

<CalledMacros SectVersion="2" SectionFlags="0" SubIdent="0">
</CalledMacros>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_3D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_3D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_2D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! Contact person: <SzL>

! ==============================================================================
! This macro draws the turned plasters
! ------------------------------------------------------------------------------
! Input parameters:
!	refWidth:				reference width in curved walls (length)
!	leftWidth:				wallhole's side distance from the origin at the left side (length)
!	rightWidth:				wallhole's side distance from the origin at the right side (length)
!	bWndCurved:				is the window made of curved panels (0 / 1)
!	bParalellInCurvedWalls:	is the wallhole parallel in curved walls (0 / 1)
!	bDrawObjContourIn:
!	bDrawObjContourOut:
!	bDrawFrameContourLeft:	Draw the wall contour border on window frame at the left side (0 / 1)
!	bDrawFrameContourRight:	Draw the wall contour border on window frame at the left side (0 / 1)
!	bWindowSymbolAtMiddle:	Is the window symbol appears always on the middle of the wall (CHI special) (0 / 1)
! Corner Window Parameters -----------------------------------------------------
!	bCornerWindow:			is the hole a corner window? (0 / 1)
! Reveal Parameters ------------------------------------------------------------
!	iRevealType:			reveal type (integer)
!								0 = no Reveal
!								1 = Positive Reveal
!								2 = Negative Reveal
!								3 = Slanted Reveal
!								4 =
!	gs_reveal_left:			left reveal size (length)
!	gs_reveal_right:		left reveal size (length)
!	gs_reveal_left_angle:	left reveal angle in case of slanted reveal (angle)
!	gs_reveal_right_angle:	right reveal angle in case of slanted reveal (angle)
! Stacked Window Parameters ----------------------------------------------------
!	gs_stack_left:			align to door/window on left side (0 / 1)
!	gs_stack_right:			align to door/window on right side (0 / 1)
! Cavity Closure Parameters ----------------------------------------------------
!	gs_useWallFinishSkin:	use wall finish component (0 / 1)
!	gs_maxPlasterThk:		wall skin classification parameter (length)
!							consider Skin as Plaster if it is thinner this
!	gs_bAutoTurnIn:			automatic plaster return at Outside Face (0 / 1)
!	gs_bAutoTurnOut:		automatic plaster return at Inside Face (0 / 1)
!	gs_bOverIn:				number of turned plaster skins at Outside Face (integer)
!	gs_bOverOut:			number of turned plaster skins at Inside Face (integer)
!	gs_bJoint:				is there an insulation strip at the front
!							 side of the turned skins (0 / 1) [MODE1]
!	gs_thkJoint:			strip thickness (length)
!	gs_penJoint:			strip contour pen (pen)
!	gs_ltJoint:				strip contour linetype (line type)
!	gs_fillJoint:			strip fill type (fill)
!	gs_penJointFg:			strip fill pen (pen)
!	gs_penJointBg:			strip fill background pen (pen)
!	gs_widthPlug:			heat insulation profile width (length) [MODE2]
!	gs_penPlug:				profile contour pen (pen)
!	gs_ltPlug:				profile contour linetype (line type)
!	gs_fillPlug:			profile fill type (fill)
!	gs_penPlugFg:			profile fill pen (pen)
!	gs_penPlugBg:			profile fill background pen (pen)
! ==============================================================================



if WIDO_REVEAL_SIDE then
	mul2 1,-1
	add2 0,WIDO_FRAME_THICKNESS
endif



if wallIsLeft then mul2 1, -1
yShift = -(wallIsLeft * WIDO_SILL) - (not(wallIsLeft) * (-WIDO_SILL+WALL_THICKNESS))
add2 0, yShift



! ==============================================================================
! Calculations and reordering
! ==============================================================================


!!! Changing the order and directions (No 1 point is always on the Inside Face)
dim RevealPnts[][]

dim TempLeftRevealPnts[][]
TempLeftRevealPnts = leftRevealPnts

for i = 1 to MaxNumPointsLeft
	TempLeftRevealPnts[i][2] = leftRevealPnts[i][2]+WIDO_SILL
next i
for kk = 1 to MaxNumPointsLeft
	if wallIsLeft then
		leftRevealPnts[kk][1] = TempLeftRevealPnts[MaxNumPointsLeft-(kk-1)][1]
		leftRevealPnts[kk][2] = TempLeftRevealPnts[MaxNumPointsLeft-(kk-1)][2]
	else
		leftRevealPnts[kk][1] = TempLeftRevealPnts[kk][1]
		leftRevealPnts[kk][2] = WALL_THICKNESS-1*TempLeftRevealPnts[kk][2]
	endif
next kk




dim TempRightRevealPnts[][]
TempRightRevealPnts = rightRevealPnts

for i = 1 to MaxNumPointsRight
	TempRightRevealPnts[i][2] = rightRevealPnts[i][2]+WIDO_SILL
next i
for kk = 1 to MaxNumPointsRight
	if wallIsLeft then
		rightRevealPnts[kk][1] = TempRightRevealPnts[MaxNumPointsRight-(kk-1)][1]
		rightRevealPnts[kk][2] = TempRightRevealPnts[MaxNumPointsRight-(kk-1)][2]
	else
		rightRevealPnts[kk][1] = TempRightRevealPnts[kk][1]
		rightRevealPnts[kk][2] = WALL_THICKNESS-1*TempRightRevealPnts[kk][2]
	endif
next kk




!!! Angles of segments---------------------------------------------

dim SegmentAngles[]

dim TempLeftSegmentAngles[]
dim LeftSegmentAngles[]
for i = 1 to MaxNumPointsLeft-1
	if abs(leftRevealPnts[i][1] - leftRevealPnts[i+1][1]) > EPS then
		if abs(leftRevealPnts[i][2] - leftRevealPnts[i+1][2]) > EPS then
			ActAng = atn( (leftRevealPnts[i+1][2] - leftRevealPnts[i][2]) / (leftRevealPnts[i+1][1] - leftRevealPnts[i][1]) )
			if (leftRevealPnts[i+1][1] - leftRevealPnts[i][1]) > EPS then
				LeftSegmentAngles[i] = 180 - ActAng
			else
				LeftSegmentAngles[i] =  360 - ActAng
			endif
		else
			if (leftRevealPnts[i][1] - leftRevealPnts[i+1][1]) > EPS then
				LeftSegmentAngles[i] = 0
			else
				LeftSegmentAngles[i] = 180
			endif
		endif
	else
		LeftSegmentAngles[i] = 270
	endif
next i


dim TempRightSegmentAngles[]
dim RightSegmentAngles[]
for i = 1 to MaxNumPointsRight-1
	if abs(rightRevealPnts[i][1] - rightRevealPnts[i+1][1]) > EPS then
		if abs(rightRevealPnts[i][2] - rightRevealPnts[i+1][2]) > EPS then
			ActAng = atn( (rightRevealPnts[i+1][2] - rightRevealPnts[i][2]) / (rightRevealPnts[i+1][1] - rightRevealPnts[i][1]) )
			if (rightRevealPnts[i+1][1] - rightRevealPnts[i][1]) > EPS then
				RightSegmentAngles[i] = 180 - ActAng
			else
				RightSegmentAngles[i] =  360 - ActAng
			endif
		else
			if (rightRevealPnts[i][1] - rightRevealPnts[i+1][1]) > EPS then
				RightSegmentAngles[i] = 0
			else
				RightSegmentAngles[i] = 180
			endif
		endif
	else
		RightSegmentAngles[i] = 270
	endif
next i



! ==============================================================================
! Drawing Plasters
! ==============================================================================

if wallIsLeft then
	bDrawPlasterRefSide = (abs(WIDO_SILL) > EPS)
	bDrawPlasterOppSide = (abs(WIDO_SILL - (WALL_THICKNESS - WIDO_FRAME_THICKNESS)) > EPS)
else
	bDrawPlasterRefSide = (abs(WIDO_SILL - (WALL_THICKNESS - WIDO_FRAME_THICKNESS)) > EPS)
	bDrawPlasterOppSide = (abs(WIDO_SILL) > EPS)
endif

if not(gs_stack_left) & not(bLeftCornerFunction) & bDrawPlasterOppSide then
	RevealPnts		= leftRevealPnts
	SegmentAngles	= LeftSegmentAngles
	WallOppDir		= 0
	sideSign		= 1
	alpha			= leftAlfa
	AddOppPoint		= AddOppPointLeft
	NumPoints_Opp	= NumPointsLeft_Opp
	gosub 1000
endif

if not(gs_stack_right) & not(bCornerWindow) & bDrawPlasterOppSide then
	RevealPnts		= rightRevealPnts
	SegmentAngles	= RightSegmentAngles
	WallOppDir		= 180
	sideSign		= -1
	alpha			= rightAlfa
	AddOppPoint		= AddOppPointRight
	NumPoints_Opp	= NumPointsRight_Opp
	gosub 1000
endif

if not(gs_stack_left) & not(bLeftCornerFunction) & bDrawPlasterRefSide then
	RevealPnts		= leftRevealPnts
	SegmentAngles	= LeftSegmentAngles
	WallOppDir		= 0
	sideSign		= 1
	alpha			= 0
	MaxNumPoints	= MaxNumPointsLeft
	AddRefPoint		= AddRefPointLeft
	NumPoints_Ref	= NumPointsLeft_Ref
	gosub 2000
endif

if not(gs_stack_right) & not(bCornerWindow) & bDrawPlasterRefSide then
	RevealPnts		= rightRevealPnts
	SegmentAngles	= RightSegmentAngles
	WallOppDir		= 180
	sideSign		= -1
	alpha			= 0
	MaxNumPoints	= MaxNumPointsRight
	AddRefPoint		= AddRefPointRight
	NumPoints_Ref	= NumPointsRight_Ref
	gosub 2000
endif

end


! ==============================================================================
! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
! ==============================================================================



1000:
! ==============================================================================
! Turn Plaster - at Inside Face
! ==============================================================================


ActSummThk = 0

if nSkinTurnOut then

!!! Offset on the beginning -----------------------------------------------

	OutSkinsOffset = 0
	OutSkinsOffsetx = 0
	OutSkinsOffsety = 0
	for i= 1 to nSkinTurnOut
		SkinIndex = WALL_SKINS_NUMBER - (i-1)
		OutSkinsOffset = OutSkinsOffset + WALL_SKINS_PARAMS[SkinIndex][SKIN_THICKNESS]
	next i

	if curvedWall then
		OutSkinOffsAtf = OutSkinsOffset / cos(SegmentAngles[1] - 270 - alpha)
		OutSkinsOffsety = OutSkinOffsAtf * cos(SegmentAngles[1] - 270)
		OutSkinsOffsetx = OutSkinOffsAtf * sin(SegmentAngles[1] - 270)
	else
		OutSkinOffsAtf = OutSkinsOffset / cos(SegmentAngles[1] - 270 - (InclWallyCorrSign * WALL_INCL) * not(reorder))
		OutSkinsOffsety = OutSkinOffsAtf * cos(SegmentAngles[1] - 270)
		OutSkinsOffsetx = OutSkinOffsAtf * sin(SegmentAngles[1] - 270)
	endif


!!! First (inner) skin inner points-----------------------------------------

	dim ActSkinInnerPoints[][3]
	for i = 1 to NumPoints_Opp + 1 + AddOppPoint
		ActSkinInnerPoints[i][1] = RevealPnts[i][1]
		ActSkinInnerPoints[i][2] = RevealPnts[i][2]
		if vardim1(SegmentAngles) >= i then
			ActSkinInnerPoints[i][3] = SegmentAngles[i]
		else
			ActSkinInnerPoints[i][3] = 0
		endif
	next i

!!! First (inner) skin first point-----------------------------------------

	if curvedWall then
		x1 = RevealPnts[1][1]: y1 = RevealPnts[1][2]
		x2 = RevealPnts[1][1] - 1 * cos(SegmentAngles[1]) : y2 = RevealPnts[1][2] + 1 * sin(SegmentAngles[1])
		xo = 0
		yo = RevSignCorr * WOD - yShift
		ro = abs(yo) - WALL_THICKNESS + (rSillLine-(RevSignCorr * WOD)) + OutSkinsOffset

		gosub 101	! Circle - Line intersection
		gosub 102	! Select good intersection point

		ActSkinInnerPoints[1][1] = cx
		ActSkinInnerPoints[1][2] = cy
	else
		ActSkinInnerPoints[1][1] = RevealPnts[1][1] - OutSkinsOffsetx
		ActSkinInnerPoints[1][2] = RevealPnts[1][2] - OutSkinsOffsety
	endif

	if abs(RevealPnts[1][2] - RevealPnts[2][2]) > EPS then
		dirAngle = atn((RevealPnts[1][1] - RevealPnts[2][1]) / (RevealPnts[1][2] - RevealPnts[2][2]))
	else
		dirAngle = 0
	endif

	RevDepy = ActSkinInnerPoints[NumPoints_Opp][2]
	BegX = RevealPnts[1][1]

	bShowPrevSkin = 0

	for i = 1 to nSkinTurnOut

!!! Actual skin properties--------------------------------------------------

		SkinIndex				= WALL_SKINS_NUMBER - nSkinTurnOut + (i)
		ActSkinThk				= WALL_SKINS_PARAMS[SkinIndex][SKIN_THICKNESS]
		ActSkinFill				= WALL_SKINS_PARAMS[SkinIndex][SKIN_FILL]
		ActSkinFillPen			= WALL_SKINS_PARAMS[SkinIndex][SKIN_FILL_PEN]
		ActSkinFillBkgPen		= WALL_SKINS_PARAMS[SkinIndex][SKIN_FILL_BACK_PEN]
		bLocalFill				= round_int(WALL_SKINS_PARAMS[SkinIndex][SKIN_FILL_ORIENTATION])
		bFitToSkinFill			= round_int(WALL_SKINS_PARAMS[SkinIndex][SKIN_FILL_FIT_TO_SKIN])
		if reorder then
			ActSkinUppLinePen	= WALL_SKINS_PARAMS[SkinIndex][SKIN_LOWER_LINE_PEN]
			ActSkinUppLineType	= WALL_SKINS_PARAMS[SkinIndex][SKIN_LOWER_LINE_TYPE]
		else
			ActSkinUppLinePen	= WALL_SKINS_PARAMS[SkinIndex][SKIN_UPPER_LINE_PEN]
			ActSkinUppLineType	= WALL_SKINS_PARAMS[SkinIndex][SKIN_UPPER_LINE_TYPE]
		endif
		ActFacePen				= WALL_SKINS_PARAMS[SkinIndex][SKIN_END_FACE_PEN]

		ActSummThk				= ActSummThk + ActSkinThk

		bShowSkin = (abs(ActSkinThk) > EPS) & (GLOB_STRUCTURE_DISPLAY = STRUCTURE_ENTIRE_STRUCTURE | (GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[SkinIndex][SKIN_FINISH_STATUS] - 1) > EPS))


!!! Last outer point--------------------------------------------------------

		if curvedWall then
			x1 = RevealPnts[1][1]: y1 = RevealPnts[1][2]
			x2 = RevealPnts[1][1] - 1 * cos(SegmentAngles[1]) : y2 = RevealPnts[1][2] + 1 * sin(SegmentAngles[1])
			xo = 0
			yo = RevSignCorr * WOD - yShift
			ro = abs(yo) - WALL_THICKNESS + (rSillLine-(RevSignCorr * WOD)) + OutSkinsOffset - ActSummThk

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point

			OutLinePx1 = cx
			OutLinePy1 = cy
		else
			OutLinePx1 = BegX
			OutLinePy1 = ActSkinInnerPoints[1][2] + InclWallyCorrSign * TAN(WALL_INCL) * not(reorder) * (ActSkinInnerPoints[1][1] - BegX) +  ActSkinThk / cos(WALL_INCL)
		endif

		put OutLinePx1, OutLinePy1, 0

!!! First inner point-------------------------------------------------------

		if curvedWall then
			x1 = RevealPnts[1][1]: y1 = RevealPnts[1][2]
			x2 = RevealPnts[1][1] - 1 * cos(SegmentAngles[1]) : y2 = RevealPnts[1][2] + 1 * sin(SegmentAngles[1])
			xo = 0
			yo = RevSignCorr * WOD - yShift
			ro = abs(yo) - WALL_THICKNESS + (rSillLine-(RevSignCorr * WOD)) + OutSkinsOffset - ActSummThk + ActSkinThk

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point

			InnLinePx1 = cx
			InnLinePy1 = cy
		else
			InnLinePx1 = BegX
			InnLinePy1 = ActSkinInnerPoints[1][2] + InclWallyCorrSign * TAN(WALL_INCL) * not(reorder) * (ActSkinInnerPoints[1][1] - BegX)
		endif

		if i > 1 then
			put InnLinePx1, InnLinePy1, 0
		endif


!!!Plaster inner points-------------------------------------------------------

		dim FinalSkinInnerPoints[][2]
		idx = 1

		NumPoints = NumPoints_Opp + AddOppPoint * (i > 1)

		for ij = 1 to numPoints

			px = ActSkinInnerPoints[ij][1]
			py = ActSkinInnerPoints[ij][2]

			if ij <= numPoints - 2 then

				x11 = ActSkinInnerPoints[ij][1]
				y11 = ActSkinInnerPoints[ij][2]
				if ij = 1 then
					x12 = InnLinePx1
					y12 = InnLinePy1
				else
					x12 = ActSkinInnerPoints[ij - 1][1]
					y12 = ActSkinInnerPoints[ij - 1][2]
				endif

				x21 = ActSkinInnerPoints[ij + 1][1]
				y21 = ActSkinInnerPoints[ij + 1][2]

				x22 = ActSkinInnerPoints[ij + 2][1]
				y22 = ActSkinInnerPoints[ij + 2][2]

				gosub 103	! Segment - Segment intersection
				if state = 3 then	! Intersection point lies on both segments
					px = cx
					py = cy

					ij = ij + 1		! Skip next point
				endif
			endif

			FinalSkinInnerPoints[idx][1] = px
			FinalSkinInnerPoints[idx][2] = py
			idx = idx + 1

			put px, py, 0
			if ij = numPoints then
				FacePointInnx = ActSkinInnerPoints[ij][1]
				FacePointInny = ActSkinInnerPoints[ij][2]
			endif
		next ij

		InnLinePx2 = FinalSkinInnerPoints[1][1]
		InnLinePy2 = FinalSkinInnerPoints[1][2]

		if FacePointInny >= InnLinePy1 then
			bShowSkin = 0
		endif

!!!Plaster outer points - Offset ---------------------------------------------

		dim ActSkinOuterPoints[][3]

		numPoints = NumPoints_Opp + AddOppPoint

		for ij = numPoints to 1 step -1

			ActisArc = 0
			PrevisArc = 0
			ro = 0

			if ij = 1 then
				if curvedWall then
					xo = 0
					yo = RevSignCorr * WOD - yShift
					ro = abs(yo) - WALL_THICKNESS + (rSillLine-(RevSignCorr * WOD)) + OutSkinsOffset - ActSummThk
					PrevisArc = 1
					originalSegmentAngle = 0
				else
					x11 = ActSkinInnerPoints[1][1]
					y11 = ActSkinInnerPoints[1][2] + ActSkinThk / cos(WALL_INCL * not(reorder))
					x12 = ActSkinInnerPoints[1][1] - 0.1 * cos(WALL_INCL)
					y12 = ActSkinInnerPoints[1][2] + ActSkinThk / cos(WALL_INCL * not(reorder)) + InclWallyCorrSign * 0.1 * sin(WALL_INCL) * not(reorder)
					originalSegmentAngle = ActSkinInnerPoints[1][3]
				endif
			else
				if AddOppPoint & ij = numPoints & ( (curvedWall & not(bWndCurved)) | not(curvedWall) ) then
					x11 = ActSkinInnerPoints[ij-1][1] + ActSkinThk * sideSign
					y11 = ActSkinInnerPoints[ij-1][2]
					x12 = ActSkinInnerPoints[ij-1][1] + ActSkinThk * sideSign
					y12 = ActSkinInnerPoints[ij-1][2] - 0.1
					originalSegmentAngle = ActSkinInnerPoints[ij-1][3]
				else
					x11 = ActSkinInnerPoints[ij-1][1] + ActSkinThk * cos(SegmentAngles[ij-1] + 90) * sideSign
					y11 = ActSkinInnerPoints[ij-1][2] - ActSkinThk * sin(SegmentAngles[ij-1] + 90) * sideSign
					x12 = ActSkinInnerPoints[ij][1]   + ActSkinThk * cos(SegmentAngles[ij-1] + 90) * sideSign
					y12 = ActSkinInnerPoints[ij][2]   - ActSkinThk * sin(SegmentAngles[ij-1] + 90) * sideSign
					originalSegmentAngle = ActSkinInnerPoints[ij-1][3]
				endif
			endif

			if ij = numPoints then
				if abs(sin(SegmentAngles[ij-1])) < EPS then
					x21 = ActSkinInnerPoints[ij][1]
					y21 = ActSkinInnerPoints[ij][2] - ActSkinThk * sideSign
					x22 = ActSkinInnerPoints[ij][1] + 0.1 * sideSign
					y22 = ActSkinInnerPoints[ij][2] - ActSkinThk * sideSign
				else
					if curvedWall & bWndCurved then
						gosub 800
						xo = 0
						yo = RevSignCorr * WOD - yShift
						ro = sqr( (abs(yo) - RevealPnts[NumPoints_Opp][2]) ^ 2 + RevealPnts[NumPoints_Opp][1] ^ 2 )

						ActisArc = 1
					else
						x21 = ActSkinInnerPoints[ij-AddOppPoint][1]
						y21 = RevDepy
						x22 = ActSkinInnerPoints[ij-AddOppPoint][1]+ 0.1 * sideSign
						y22 = RevDepy
					endif
				endif
			else
				x21 = ActSkinInnerPoints[ij][1] + ActSkinThk * cos(SegmentAngles[ij] + 90) * sideSign
				y21 = ActSkinInnerPoints[ij][2] - ActSkinThk * sin(SegmentAngles[ij] + 90) * sideSign
				x22 = ActSkinInnerPoints[ij+1][1] + ActSkinThk * cos(SegmentAngles[ij] + 90) * sideSign
				y22 = ActSkinInnerPoints[ij+1][2] - ActSkinThk * sin(SegmentAngles[ij] + 90) * sideSign

				if abs(x21 - x22) < EPS & abs(y21 - y22) < EPS then
					x22 = x21 - ActSkinThk * sin(SegmentAngles[ij] + 90) !* sideSign
					y22 = y21 - ActSkinThk * cos(SegmentAngles[ij] + 90)
				endif
			endif

			if ij = NumPoints_Opp & AddOppPoint = 1 then
				if curvedWall & bWndCurved & not(bParalellInCurvedWalls) then
					if abs(ActSkinInnerPoints[ij][1] - ActSkinInnerPoints[ij+1][1]) < EPS then
						x21 = ActSkinInnerPoints[ij][1] - ActSkinThk * sin(SegmentAngles[ij]) * sideSign
						y21 = ActSkinInnerPoints[ij][2] - ActSkinThk * cos(SegmentAngles[ij]) * sideSign
						x22 = ActSkinInnerPoints[ij+1][1] - 0.1 * cos(SegmentAngles[ij]) * sideSign - ActSkinThk * sin(SegmentAngles[ij]) * sideSign
						y22 = ActSkinInnerPoints[ij+1][2] + 0.1 * sin(SegmentAngles[ij]) * sideSign - ActSkinThk * cos(SegmentAngles[ij]) * sideSign
					else
						x21 = ActSkinInnerPoints[ij][1] - ActSkinThk * sin(SegmentAngles[ij]) * sideSign
						y21 = ActSkinInnerPoints[ij][2] - ActSkinThk * cos(SegmentAngles[ij]) * sideSign
						x22 = ActSkinInnerPoints[ij+1][1] - ActSkinThk * sin(SegmentAngles[ij]) * sideSign
						y22 = ActSkinInnerPoints[ij+1][2] - ActSkinThk * cos(SegmentAngles[ij]) * sideSign
					endif
				else
					x21 = ActSkinInnerPoints[ij][1] + ActSkinThk * sideSign
					y21 = ActSkinInnerPoints[ij][2]
					x22 = ActSkinInnerPoints[ij][1] + ActSkinThk * sideSign
					y22 = ActSkinInnerPoints[ij][2] + 0.1 * sideSign
				endif
			endif

			if abs(x11 - x12) < EPS & abs(y11 - y12) < EPS then
				x12 = x11 + cos(originalSegmentAngle) * sideSign
				y12 = y11 - sin(originalSegmentAngle) * sideSign
			endif

!!! Finding the intersected points-----------------------------------------

			if ActisArc | PrevisArc then
				if ActisArc then
					x1 = x11: y1 = y11
					x2 = x12: y2 = y12
				else
					x1 = x21: y1 = y21
					x2 = x22: y2 = y22
				endif
				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
			else
				gosub 100	! Line - Line intersection
			endif

			if state then
				ActSkinOuterPoints[ij][1] = cx
				ActSkinOuterPoints[ij][2] = cy
			else
				ActSkinOuterPoints[ij][1] = x12
				ActSkinOuterPoints[ij][2] = y12
			endif
			ActSkinOuterPoints[ij][3] = originalSegmentAngle

			if ij = numPoints then
				FacePointOutx = cx
				FacePointOuty = cy
			endif
		next ij


!!!Plaster outer points-------------------------------------------------------

		dim FinalSkinOuterPoints[][2]
		idx = 1

		for ij = numPoints to 1 step -1
			px = ActSkinOuterPoints[ij][1]
			py = ActSkinOuterPoints[ij][2]

			if ij < numPoints & ij >= 2 then
				x11 = ActSkinOuterPoints[ij][1]
				y11 = ActSkinOuterPoints[ij][2]
				x12 = ActSkinOuterPoints[ij + 1][1]
				y12 = ActSkinOuterPoints[ij + 1][2]

				x21 = ActSkinOuterPoints[ij - 1][1]
				y21 = ActSkinOuterPoints[ij - 1][2]
				if ij <= 2 then
					x22 = OutLinePx1
					y22 = OutLinePy1
				else
					x22 = ActSkinOuterPoints[ij - 2][1]
					y22 = ActSkinOuterPoints[ij - 2][2]
				endif

				gosub 103	! Segment - Segment intersection
				if state = 3 then	! Intersection point lies on both segments
					px = cx
					py = cy

					ij = ij - 1		! Skip next point
				endif
			endif

			if idx = 1 then
				FinalSkinOuterPoints[1][1] = px
				FinalSkinOuterPoints[1][2] = py
				idx = idx + 1

				put px, py, 0
			else
				if	not(abs(FinalSkinOuterPoints[idx-1][1] - px) < EPS) |\ 		! Skip current point if it is equal to previous point
					not(abs(FinalSkinOuterPoints[idx-1][2] - py) < EPS) then

					FinalSkinOuterPoints[idx][1] = px
					FinalSkinOuterPoints[idx][2] = py
					idx = idx + 1

					put px, py, 0
				endif
			endif
		next ij


!!! Drawing the plaster and inner line-------------------------------------------------

		if bShowSkin then

			fill ActSkinFill

			wallblock2{2} nsp/3, 2, 2,8 * (bLocalFill | bFitToSkinFill) + 32 * bFitToSkinFill + 128 * (bLocalFill & not(bFitToSkinFill)),
				ActSkinFillPen, ActSkinFillBkgPen,
				use(2),
				-sin(dirAngle),-cos(dirAngle), -ActSkinThk*cos(dirAngle),ActSkinThk*sin(dirAngle),
				0,
				get(nsp)
		else
			for kk= 1 to nsp
				ClearStack = get(1)
			next kk
		endif

		if bShowSkin | (bShowPrevSkin & not(bShowSkin)) then
			!!! Inner skin lines

			if ActSkinUppLinePen > 0 then
				pen ActSkinUppLinePen
				line_type ActSkinUppLineType
				if bShowSkin then
					line_property LINE_PROPERTY_INNER
				else
					line_property LINE_PROPERTY_CONTOUR
				endif

				for ij = 1 to vardim1(FinalSkinInnerPoints) - 1
					wallline2	FinalSkinInnerPoints[ij][1],	FinalSkinInnerPoints[ij][2],
								FinalSkinInnerPoints[ij+1][1],	FinalSkinInnerPoints[ij+1][2]
				next ij

				if i > 1 then
					wallline2	InnLinePx1, InnLinePy1,
								InnLinePx2, InnLinePy2
				endif
			endif

			if bShowSkin & ActFacePen > 0 then
				pen ActFacePen
				wallline2 FacePointInnx, FacePointInny, FacePointOutx, FacePointOuty
			endif
		endif


!!! Outer contour line-----------------------------------------------

		if i = nSkinTurnOut & bShowSkin then
			if reorder then
				WallCotourLinePen = WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][SKIN_UPPER_LINE_PEN]
				line_type WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][SKIN_UPPER_LINE_TYPE]
			else
				WallCotourLinePen = WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][SKIN_LOWER_LINE_PEN]
				line_type WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][SKIN_LOWER_LINE_TYPE]
			endif

			if WallCotourLinePen > 0 then
				pen WallCotourLinePen
				line_property LINE_PROPERTY_CONTOUR
				if (GLOB_PREVIEW_MODE = 0) then
					line2	RevealPnts[1][1], RevealPnts[1][2],
							ActSkinOuterPoints[1][1], ActSkinOuterPoints[1][2]

					for ij = 1 to vardim1(FinalSkinOuterPoints) - 1
						line2	FinalSkinOuterPoints[ij][1],	FinalSkinOuterPoints[ij][2],
								FinalSkinOuterPoints[ij+1][1],	FinalSkinOuterPoints[ij+1][2]
					next ij
				endif
				wallline2	RevealPnts[1][1], RevealPnts[1][2],
							ActSkinOuterPoints[1][1], ActSkinOuterPoints[1][2]

				for ij = 1 to vardim1(FinalSkinOuterPoints) - 1
					wallline2	FinalSkinOuterPoints[ij][1],	FinalSkinOuterPoints[ij][2],
								FinalSkinOuterPoints[ij+1][1],	FinalSkinOuterPoints[ij+1][2]
				next ij
			endif
		endif

		!!! Changing the outer points to next plasters' inner points
		ActSkinInnerPoints = ActSkinOuterPoints

		bShowPrevSkin = bShowSkin

	next i

endif

return


2000:
! ==============================================================================
! Turn Plaster - at Outside Face
! ==============================================================================


ActSummThk = 0

if nSkinTurnIn then

!!! Offset on the beginning --------------------------------------------------

	InSkinsOffset = 0
	InSkinsOffsetx = 0
	InSkinsOffsety = 0
	for i= 1 to nSkinTurnIn
		SkinIndex = i
		InSkinsOffset = InSkinsOffset + WALL_SKINS_PARAMS[SkinIndex][SKIN_THICKNESS]
	next i

	if curvedWall then
		InSkinsOffsetAtf = InSkinsOffset / cos(SegmentAngles[MaxNumPoints-1] - 270 - alpha)
		InSkinsOffsety = InSkinsOffsetAtf * cos(SegmentAngles[MaxNumPoints-1] - 270)
		InSkinsOffsetx = InSkinsOffsetAtf * sin(SegmentAngles[MaxNumPoints-1] - 270)
	else
		InSkinsOffsetAtf = InSkinsOffset / cos(SegmentAngles[MaxNumPoints-1] - 270 - (InclWallyCorrSign * WALL_INCL) * reorder)
		InSkinsOffsety = InSkinsOffsetAtf * cos(SegmentAngles[MaxNumPoints-1] - 270)
		InSkinsOffsetx = InSkinsOffsetAtf * sin(SegmentAngles[MaxNumPoints-1] - 270)
	endif


!!! First (inner) skin inner points-----------------------------------------------

	dim ActRefSkinInnerPoints[][3]
	for i = 1 to NumPoints_Ref + 1 + AddRefPoint
		ActRefSkinInnerPoints[i][1] = RevealPnts[MaxNumPoints-(i-1)][1]
		ActRefSkinInnerPoints[i][2] = RevealPnts[MaxNumPoints-(i-1)][2]
		if vardim1(SegmentAngles) >= MaxNumPoints-(i-1) then
			ActRefSkinInnerPoints[i][3] = SegmentAngles[MaxNumPoints-(i-1)]
		else
			ActRefSkinInnerPoints[i][3] = 0
		endif
	next i

!!! First (inner) skin first point------------------------------------------------

	if curvedWall then
		x1 = RevealPnts[MaxNumPoints][1]: y1 = RevealPnts[MaxNumPoints][2]
		x2 = RevealPnts[MaxNumPoints][1] - 1 * cos(SegmentAngles[MaxNumPoints-1]) : y2 = RevealPnts[MaxNumPoints][2] + 1 * sin(SegmentAngles[MaxNumPoints-1])
		xo = 0
		yo = RevSignCorr * WOD - yShift
		ro = abs(yo) + (rSillLine-(RevSignCorr * WOD)) - InSkinsOffset

		dirAngle = atn((x1 - x2) / (y1 - y2))

		gosub 101	! Circle - Line intersection
		gosub 102	! Select good intersection point

		ActRefSkinInnerPoints[1][1] = cx
		ActRefSkinInnerPoints[1][2] = cy
	else
		ActRefSkinInnerPoints[1][1] = RevealPnts[MaxNumPoints][1] + InSkinsOffsetx
		ActRefSkinInnerPoints[1][2] = RevealPnts[MaxNumPoints][2] + InSkinsOffsety

		dirAngle = 0
	endif

	RevDepy = RevealPnts[MaxNumPoints - NumPoints_Ref + 1][2]
	BegX = RevealPnts[MaxNumPoints][1]

	bShowPrevSkin = 0

	for i = 1 to nSkinTurnIn

!!! Actual skin properties--------------------------------------------------

		SkinIndex				= nSkinTurnIn - (i-1)
		ActSkinThk				= WALL_SKINS_PARAMS[SkinIndex][SKIN_THICKNESS]
		ActSkinFill				= WALL_SKINS_PARAMS[SkinIndex][SKIN_FILL]
		ActSkinFillPen			= WALL_SKINS_PARAMS[SkinIndex][SKIN_FILL_PEN]
		ActSkinFillBkgPen		= WALL_SKINS_PARAMS[SkinIndex][SKIN_FILL_BACK_PEN]
		bLocalFill				= round_int(WALL_SKINS_PARAMS[SkinIndex][SKIN_FILL_ORIENTATION])
		bFitToSkinFill			= round_int(WALL_SKINS_PARAMS[SkinIndex][SKIN_FILL_FIT_TO_SKIN])
		if reorder then
			ActSkinUppLinePen	= WALL_SKINS_PARAMS[SkinIndex][SKIN_UPPER_LINE_PEN]
			ActSkinUppLineType	= WALL_SKINS_PARAMS[SkinIndex][SKIN_UPPER_LINE_TYPE]
		else
			ActSkinUppLinePen	= WALL_SKINS_PARAMS[SkinIndex][SKIN_LOWER_LINE_PEN]
			ActSkinUppLineType	= WALL_SKINS_PARAMS[SkinIndex][SKIN_LOWER_LINE_TYPE]
		endif
		ActFacePen				= WALL_SKINS_PARAMS[SkinIndex][SKIN_END_FACE_PEN]

		ActSummThk				= ActSummThk + ActSkinThk

		bShowSkin = (abs(ActSkinThk) > EPS) & (GLOB_STRUCTURE_DISPLAY = STRUCTURE_ENTIRE_STRUCTURE | (GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[SkinIndex][SKIN_FINISH_STATUS] - 1) > EPS))


!!! Last outer point--------------------------------------------------------

		if curvedWall then
			x1 = RevealPnts[MaxNumPoints][1]: y1 = RevealPnts[MaxNumPoints][2]
			x2 = RevealPnts[MaxNumPoints][1] - 1 * cos(SegmentAngles[MaxNumPoints-1]) : y2 = RevealPnts[MaxNumPoints][2] + 1 * sin(SegmentAngles[MaxNumPoints-1])
			xo = 0
			yo = RevSignCorr * WOD - yShift
			ro = abs(yo) + (rSillLine-(RevSignCorr * WOD)) - InSkinsOffset + ActSummThk

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point

			OutLinePx1 = cx
			OutLinePy1 = cy
		else
			OutLinePx1 = BegX
			OutLinePy1 = ActRefSkinInnerPoints[1][2] + InclWallyCorrSign * TAN(WALL_INCL) * reorder * (ActRefSkinInnerPoints[1][1] - BegX) -  ActSkinThk / cos(WALL_INCL)
		endif

		put OutLinePx1, OutLinePy1, 0

!!! First inner point-------------------------------------------------------

		if curvedWall then
			x1 = RevealPnts[MaxNumPoints][1]: y1 = RevealPnts[MaxNumPoints][2]
			x2 = RevealPnts[MaxNumPoints][1] - 1 * cos(SegmentAngles[MaxNumPoints-1]) : y2 = RevealPnts[MaxNumPoints][2] + 1 * sin(SegmentAngles[MaxNumPoints-1])
			xo = 0
			yo = RevSignCorr * WOD - yShift
			ro = abs(yo) + (rSillLine-(RevSignCorr * WOD)) - InSkinsOffset + ActSummThk - ActSkinThk

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point

			InnLinePx1 = cx
			InnLinePy1 = cy
		else
			InnLinePx1 = BegX
			InnLinePy1 = ActRefSkinInnerPoints[1][2] + InclWallyCorrSign * TAN(WALL_INCL) * reorder * (ActRefSkinInnerPoints[1][1] - BegX)
		endif

		if i > 1 then
			put InnLinePx1, InnLinePy1, 0
		endif


!!!Plaster inner points-------------------------------------------------------

		dim FinalRefSkinInnerPoints[][2]
		idx = 1

		numPoints = NumPoints_Ref + AddRefPoint * (i > 1)

		for ij = 1 to numPoints

			px = ActRefSkinInnerPoints[ij][1]
			py = ActRefSkinInnerPoints[ij][2]

			if ij <= numPoints - 2 then

				x11 = ActRefSkinInnerPoints[ij][1]
				y11 = ActRefSkinInnerPoints[ij][2]
				if ij = 1 then
					x12 = InnLinePx1
					y12 = InnLinePy1
				else
					x12 = ActRefSkinInnerPoints[ij - 1][1]
					y12 = ActRefSkinInnerPoints[ij - 1][2]
				endif

				x21 = ActRefSkinInnerPoints[ij + 1][1]
				y21 = ActRefSkinInnerPoints[ij + 1][2]

				x22 = ActRefSkinInnerPoints[ij + 2][1]
				y22 = ActRefSkinInnerPoints[ij + 2][2]

				gosub 103	! Segment - Segment intersection
				if state = 3 then	! Intersection point lies on both segments
					px = cx
					py = cy

					ij = ij + 1		! Skip next point
				endif
			endif

			FinalRefSkinInnerPoints[idx][1] = px
			FinalRefSkinInnerPoints[idx][2] = py
			idx = idx + 1

			put px, py, 0
			if ij = numPoints then
				FacePointInnx = ActRefSkinInnerPoints[ij][1]
				FacePointInny = ActRefSkinInnerPoints[ij][2]
			endif
		next ij

		InnLinePx2 = FinalRefSkinInnerPoints[1][1]
		InnLinePy2 = FinalRefSkinInnerPoints[1][2]

		if FacePointInny <= InnLinePy1 then
			bShowSkin = 0
		endif

!!!Plaster outer points - Offset ---------------------------------------------

		dim ActRefSkinOuterPoints[][3]

		numPoints = NumPoints_Ref + AddRefPoint

		for ij = numPoints to 1 step -1

			ActisArc = 0
			PrevisArc = 0
			ro = 0

			if ij = 1 then
				if curvedWall then
					xo = 0
					yo = RevSignCorr * WOD - yShift
					ro = abs(yo) + (rSillLine-(RevSignCorr * WOD)) - InSkinsOffset + ActSummThk
					PrevisArc = 1
					originalSegmentAngle = 0
				else
					x11 = ActRefSkinInnerPoints[1][1]
					y11 = ActRefSkinInnerPoints[1][2] - ActSkinThk / cos(WALL_INCL * reorder)
					x12 = ActRefSkinInnerPoints[1][1] - 0.1 * cos(WALL_INCL)
					y12 = ActRefSkinInnerPoints[1][2] - ActSkinThk / cos(WALL_INCL * reorder) + InclWallyCorrSign * 0.1 * sin(WALL_INCL) * reorder
					originalSegmentAngle = ActRefSkinInnerPoints[1][3]
				endif
			else
				if AddRefPoint & ij = numPoints & ( (curvedWall & not(bWndCurved)) | not(curvedWall) ) then
					x11 = ActRefSkinInnerPoints[ij-1][1] + ActSkinThk * sideSign
					y11 = ActRefSkinInnerPoints[ij-1][2]
					x12 = ActRefSkinInnerPoints[ij-1][1] + ActSkinThk * sideSign
					y12 = ActRefSkinInnerPoints[ij-1][2] - 0.1
					originalSegmentAngle = ActRefSkinInnerPoints[ij-1][3]
				else
					x11 = ActRefSkinInnerPoints[ij-1][1] + ActSkinThk * cos(SegmentAngles[MaxNumPoints-ij+1] + 90) * sideSign
					y11 = ActRefSkinInnerPoints[ij-1][2] - ActSkinThk * sin(SegmentAngles[MaxNumPoints-ij+1] + 90) * sideSign
					x12 = ActRefSkinInnerPoints[ij][1] + ActSkinThk * cos(SegmentAngles[MaxNumPoints-ij+1] + 90) * sideSign
					y12 = ActRefSkinInnerPoints[ij][2] - ActSkinThk * sin(SegmentAngles[MaxNumPoints-ij+1] + 90) * sideSign
					originalSegmentAngle = ActRefSkinInnerPoints[ij][3]
				endif
			endif

			if ij = numPoints then
				if abs(sin(SegmentAngles[MaxNumPoints-ij+1])) < EPS then
					x21 = ActRefSkinInnerPoints[ij][1]
					y21 = ActRefSkinInnerPoints[ij][2] - ActSkinThk * sideSign
					x22 = ActRefSkinInnerPoints[ij][1] + 0.1 * sideSign
					y22 = ActRefSkinInnerPoints[ij][2] - ActSkinThk * sideSign
				else
					if curvedWall & bWndCurved then
						gosub 801
						xo = 0
						yo = RevSignCorr * WOD - yShift
						ro = sqr( (abs(yo) - RevealPnts[MaxNumPoints - NumPoints_Ref + 1][2]) ^ 2 + RevealPnts[MaxNumPoints - NumPoints_Ref + 1][1] ^ 2 )

						ActisArc = 1
					else
						x21 = ActRefSkinInnerPoints[ij-AddRefPoint][1]
						y21 = RevDepy
						x22 = ActRefSkinInnerPoints[ij-AddRefPoint][1]+ 0.1 * sideSign
						y22 = RevDepy
					endif
				endif
			else
				x21 = ActRefSkinInnerPoints[ij][1] + ActSkinThk * cos(SegmentAngles[MaxNumPoints-ij] + 90) * sideSign
				y21 = ActRefSkinInnerPoints[ij][2] - ActSkinThk * sin(SegmentAngles[MaxNumPoints-ij] + 90) * sideSign
				x22 = ActRefSkinInnerPoints[ij+1][1] + ActSkinThk * cos(SegmentAngles[MaxNumPoints-ij] + 90) * sideSign
				y22 = ActRefSkinInnerPoints[ij+1][2] - ActSkinThk * sin(SegmentAngles[MaxNumPoints-ij] + 90) * sideSign

				if abs(x21 - x22) < EPS & abs(y21 - y22) < EPS then
					x22 = x21 - ActSkinThk * sin(SegmentAngles[MaxNumPoints-ij] + 90) !* sideSign
					y22 = y21 - ActSkinThk * cos(SegmentAngles[MaxNumPoints-ij] + 90)
				endif
			endif

			if ij = NumPoints_Ref & AddRefPoint = 1 then
				if curvedWall & bWndCurved & not(bParalellInCurvedWalls) then
					if abs(ActRefSkinInnerPoints[ij][1] - ActRefSkinInnerPoints[ij+1][1]) < EPS then
						x21 = ActRefSkinInnerPoints[ij+1][1] - ActSkinThk * sin(SegmentAngles[MaxNumPoints-ij]) * sideSign
						y21 = ActRefSkinInnerPoints[ij+1][2] - ActSkinThk * cos(SegmentAngles[MaxNumPoints-ij]) * sideSign
						x22 = ActRefSkinInnerPoints[ij+1][1] - 0.1 * cos(SegmentAngles[MaxNumPoints-ij]) * sideSign - ActSkinThk * sin(SegmentAngles[MaxNumPoints-ij]) * sideSign
						y22 = ActRefSkinInnerPoints[ij+1][2] + 0.1 * sin(SegmentAngles[MaxNumPoints-ij]) * sideSign - ActSkinThk * cos(SegmentAngles[MaxNumPoints-ij]) * sideSign
					else
						x21 = ActRefSkinInnerPoints[ij][1] - ActSkinThk * sin(SegmentAngles[MaxNumPoints-ij]) * sideSign
						y21 = ActRefSkinInnerPoints[ij][2] - ActSkinThk * cos(SegmentAngles[MaxNumPoints-ij]) * sideSign
						x22 = ActRefSkinInnerPoints[ij+1][1] - ActSkinThk * sin(SegmentAngles[MaxNumPoints-ij]) * sideSign
						y22 = ActRefSkinInnerPoints[ij+1][2] - ActSkinThk * cos(SegmentAngles[MaxNumPoints-ij]) * sideSign
					endif
				else
					x21 = ActRefSkinInnerPoints[ij][1] + ActSkinThk * sideSign
					y21 = ActRefSkinInnerPoints[ij][2]
					x22 = ActRefSkinInnerPoints[ij][1] + ActSkinThk * sideSign
					y22 = ActRefSkinInnerPoints[ij][2] + 0.1 * sideSign
				endif
			endif

			if abs(x11 - x12) < EPS & abs(y11 - y12) < EPS then
				x12 = x11 + cos(originalSegmentAngle) * sideSign
				y12 = y11 - sin(originalSegmentAngle) * sideSign
			endif

!!! Finding the intersected points-----------------------------------------

			if ActisArc | PrevisArc then
				if ActisArc then
					x1 = x11: y1 = y11
					x2 = x12: y2 = y12
				else
					x1 = x21: y1 = y21
					x2 = x22: y2 = y22
				endif
				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
			else
				gosub 100	! Line - Line intersection
			endif

			if state then
				ActRefSkinOuterPoints[ij][1] = cx
				ActRefSkinOuterPoints[ij][2] = cy
			else
				ActRefSkinOuterPoints[ij][1] = x12
				ActRefSkinOuterPoints[ij][2] = y12
			endif
			ActRefSkinOuterPoints[ij][3] = originalSegmentAngle

			if ij = numPoints then
				FacePointOutx = cx
				FacePointOuty = cy
			endif
		next ij


!!!Plaster outer points-------------------------------------------------------

		dim FinalRefSkinOuterPoints[][2]
		idx = 1

		for ij = numPoints to 1 step -1
			px = ActRefSkinOuterPoints[ij][1]
			py = ActRefSkinOuterPoints[ij][2]

			if ij < numPoints & ij >= 2 then
				x11 = ActRefSkinOuterPoints[ij][1]
				y11 = ActRefSkinOuterPoints[ij][2]
				x12 = ActRefSkinOuterPoints[ij + 1][1]
				y12 = ActRefSkinOuterPoints[ij + 1][2]

				x21 = ActRefSkinOuterPoints[ij - 1][1]
				y21 = ActRefSkinOuterPoints[ij - 1][2]
				if ij <= 2 then
					x22 = OutLinePx1
					y22 = OutLinePy1
				else
					x22 = ActRefSkinOuterPoints[ij - 2][1]
					y22 = ActRefSkinOuterPoints[ij - 2][2]
				endif

				gosub 103	! Segment - Segment intersection
				if state = 3 then	! Intersection point lies on both segments
					px = cx
					py = cy

					ij = ij - 1		! Skip next point
				endif
			endif

			if idx = 1 then
				FinalRefSkinOuterPoints[1][1] = px
				FinalRefSkinOuterPoints[1][2] = py
				idx = idx + 1

				put px, py, 0
			else
				if	not(abs(FinalRefSkinOuterPoints[idx-1][1] - px) < EPS) |\		! Skip current point if it is equal to previous point
					not(abs(FinalRefSkinOuterPoints[idx-1][2] - py) < EPS) then

					FinalRefSkinOuterPoints[idx][1] = px
					FinalRefSkinOuterPoints[idx][2] = py
					idx = idx + 1

					put px, py, 0
				endif
			endif
		next ij


!!! Drawing the plaster and inner line---------------------------------------

		if bShowSkin then

			fill ActSkinFill

			wallblock2{2} nsp/3, 2, 2,8 * (bLocalFill | bFitToSkinFill) + 32 * bFitToSkinFill + 128 * (bLocalFill & not(bFitToSkinFill)),
				ActSkinFillPen, ActSkinFillBkgPen,
				use(2),
				-sin(dirAngle),-cos(dirAngle), -ActSkinThk*cos(dirAngle),ActSkinThk*sin(dirAngle),
				0,
				get(nsp)
		else
			for kk= 1 to nsp
				ClearStack = get(1)
			next kk
		endif

		if bShowSkin | (bShowPrevSkin & not(bShowSkin)) then
			!!! Inner skin lines

			if ActSkinUppLinePen > 0 then
				pen ActSkinUppLinePen
				line_type ActSkinUppLineType
				if bShowSkin then
					line_property LINE_PROPERTY_INNER
				else
					line_property LINE_PROPERTY_CONTOUR
				endif

				for ij = 1 to vardim1(FinalRefSkinInnerPoints) - 1
					wallline2	FinalRefSkinInnerPoints[ij][1],		FinalRefSkinInnerPoints[ij][2],
								FinalRefSkinInnerPoints[ij+1][1],	FinalRefSkinInnerPoints[ij+1][2]
				next ij

				if i > 1 then
					wallline2	InnLinePx1, InnLinePy1,
								InnLinePx2, InnLinePy2
				endif
			endif

			if bShowSkin & ActFacePen > 0 then
				pen ActFacePen
				wallline2 FacePointInnx, FacePointInny, FacePointOutx, FacePointOuty
			endif
		endif


!!! Outer contour line-----------------------------------------------

		if i = nSkinTurnIn & bShowSkin then
			if reorder then
				WallCotourLinePen = WALL_SKINS_PARAMS[1][SKIN_LOWER_LINE_PEN]
				line_type WALL_SKINS_PARAMS[1][SKIN_LOWER_LINE_TYPE]
			else
				WallCotourLinePen = WALL_SKINS_PARAMS[1][SKIN_UPPER_LINE_PEN]
				line_type WALL_SKINS_PARAMS[1][SKIN_UPPER_LINE_TYPE]
			endif

			if WallCotourLinePen > 0 then
				pen WallCotourLinePen
				line_property LINE_PROPERTY_CONTOUR
				if (GLOB_PREVIEW_MODE = 0) then
					line2	RevealPnts[MaxNumPoints][1], RevealPnts[MaxNumPoints][2],
							ActRefSkinOuterPoints[1][1], ActRefSkinOuterPoints[1][2]

					for ij = 1 to vardim1(FinalRefSkinOuterPoints) - 1
						line2	FinalRefSkinOuterPoints[ij][1],		FinalRefSkinOuterPoints[ij][2],
								FinalRefSkinOuterPoints[ij+1][1],	FinalRefSkinOuterPoints[ij+1][2]
					next ij
				endif
				wallline2	RevealPnts[MaxNumPoints][1], RevealPnts[MaxNumPoints][2],
							ActRefSkinOuterPoints[1][1], ActRefSkinOuterPoints[1][2]

				for ij = 1 to vardim1(FinalRefSkinOuterPoints) - 1
					wallline2	FinalRefSkinOuterPoints[ij][1],		FinalRefSkinOuterPoints[ij][2],
								FinalRefSkinOuterPoints[ij+1][1],	FinalRefSkinOuterPoints[ij+1][2]
				next ij
			endif
		endif

		!!! Changing the outer points to next plasters' inner points
		ActRefSkinInnerPoints = ActRefSkinOuterPoints

		bShowPrevSkin = bShowSkin
	next i

endif

return


! ==============================================================================
! Line - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12	line #1
!	x21,y21, x22,y22	line #2
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = valid intersection point
!	cx, cy:				intersection point
! ==============================================================================

100:
	lliDiv = (x11-x12) * (y21-y22) - (y11-y12) * (x21-x22)

	if abs(lliDiv) > smallEPS then
		! Intersection

		temp1 = x11 * y12 - y11 * x12
		temp2 = x21 * y22 - y21 * x22

		tempx = temp1 * (x21-x22) - (x11-x12) * temp2
		tempy = temp1 * (y21-y22) - (y11-y12) * temp2

		state = 1
		cx = (tempx / lliDiv)
		cy = (tempy / lliDiv)
	else
		! No Intersection
		state = 0
		cx = 0
		cy = 0

		bPointL1 = (abs(x11 - x12) < EPS & abs(y11 - y11) < EPS)
		bPointL2 = (abs(x21 - x22) < EPS & abs(y21 - y21) < EPS)

		if bPointL1 & bPointL2 & abs(x11 - x21) < EPS & abs(y11 - y21) < EPS then
			state = 1
			cx = x11
			cy = y11
		endif
		if bPointL1 & not(bPointL2) then
			if (abs((y22-y21) * (x11-x21) - (x22-x21) * (y11-y21)) / sqr((x22-x21)^2 + (y22-y21)^2)) < EPS then
				state = 1
				cx = x11
				cy = y11
			endif
		endif
		if not(bPointL1) & bPointL2 then
			if (abs((y12-y11) * (x21-x11) - (x12-x11) * (y21-y11)) / sqr((x12-x11)^2 + (y12-y11)^2)) < EPS then
				state = 1
				cx = x11
				cy = y11
			endif
		endif
	endif
return


! ==============================================================================
! Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	xo,yo,ro:			circle
!	x1,y1, x2,y2		line
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = one intersection point (tangential line)
!						2 = two intersection points
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
! ==============================================================================

101:
	tempX1 = x1 - xo: tempY1 = y1 - yo
	tempX2 = x2 - xo: tempY2 = y2 - yo

	if abs(tempX2 - tempX1) < smallEPS then
		if abs(ro - abs(tempX1)) < smallEPS then
			state = 1
			xa = tempX1
			ya = 0
			xb = tempX1
			yb = 0
		else
			if abs(ro) - abs(tempX1) < 0 then
				state = 0: xa = 0: ya = 0: xb = 0: yb = 0
			else
				state = 2
				xa = tempX1
				ya = sqr(ro^2 - tempX1^2)
				xb = tempX1
				yb = -sqr(ro^2 - tempX1^2)
			endif
		endif
	else
		kf = (tempY2 - tempY1) / (tempX2 - tempX1)
		ad = 1 + kf^2
		bd = 2 * tempY1 * kf - 2 * tempX1 * kf^2
		cd = tempY1^2 - 2 * tempX1 * tempY1 * kf + tempX1^2 * kf^2 - ro^2

		if bd^2 - 4 * ad * cd < 0 then
			state = 0: xa = 0: ya = 0: xb = 0: yb = 0
		else
			xa = (-bd + sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			ya = tempY1 + (xa - tempX1) * kf
			xb = (-bd - sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			yb = tempY1 + (xb - tempX1) * kf

			if abs(xa - xb) < smallEPS then state = 1 else state = 2
		endif
	endif

	if state = 2 then
		da = sqr((tempX1 - xa)^2 + (tempY1 - ya)^2)
		db = sqr((tempX1 - xb)^2 + (tempY1 - yb)^2)

		if db < da then
			xxo = xa: yyo = ya
			xa = xb:  ya = yb
			xb = xxo: yb = yyo
		endif
	endif

	xa = xa + xo: ya = ya + yo
	xb = xb + xo: yb = yb + yo
return


! ==============================================================================
! Select good intersection point after Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	state:				intersection status
!	wallIsLeft:
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
!
! Returned variables:
!	cx, cy:				selected intersection point
! ==============================================================================

102:
	cx = 0
	cy = 0
	if state = 1 then
		cx = xa
		cy = ya
	endif
	if state = 2 then
!		if wallIsLeft then

!			if ya > yb then
!				cx = xa
!				cy = ya
!			else
!				cx = xb
!				cy = yb
!			endif
!		else
			if ya < yb then
				cx = xa
				cy = ya
			else
				cx = xb
				cy = yb
			endif
!		endif
	endif
return


! ==============================================================================
! Segment - Segment intersection
! ==============================================================================
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12	segment #1
!	x21,y21, x22,y22	segment #2
!
! Returned variables:
!	state:				output status
!							-1: no intersection, segments is not parallel
!							 0: no intersection, parallel segments
!							 1: intersection point lies on S1 segment, but not lies on S2
!							 2: intersection point lies on S2 segment, but not lies on S1
!							 3: intersection point lies on both segments
!	cx, cy:				intersection point
! ==============================================================================

103:
	gosub 100	! Line - Line intersection

	if state then
		state = 0

		if abs(x11 - x12) < EPS then
			if (y11 - EPS <= cy & cy <= y12 + EPS) | (y11 + EPS >= cy & cy >= y12 - EPS) then state = 1
		else
			if (x11 - EPS <= cx & cx <= x12 + EPS) | (x11 + EPS >= cx & cx >= x12 - EPS) then state = 1
		endif
		if abs(x21 - x22) < EPS then
			if (y21 - EPS <= cy & cy <= y22 + EPS) | (y21 + EPS >= cy & cy >= y22 - EPS) then state = state + 2
		else
			if (x21 - EPS <= cx & cx <= x22 + EPS) | (x21 + EPS >= cx & cx >= x22 - EPS) then state = state + 2
		endif

		if state = 0 then
			state = -1
		else
			if abs(x11 - cx) < EPS & abs(y11 - cy) < EPS then state = state + 10
			if abs(x12 - cx) < EPS & abs(y12 - cy) < EPS then state = state + 10
		endif
	endif
return


800:
! ==============================================================================
! Select the reveal point index until the Inside Face plasters have to run in curved panel case
! ------------------------------------------------------------------------------
! Input variables:
!	RevealPnts:				reveal points
!	NumPoints_Opp:			number of points on Inside Face
!
! Returned variables:
!	OppLimIndex:			index of the reveal point
! ==============================================================================

if RevealPnts[NumPoints_Opp][2] < RevealPnts[NumPoints_Opp + 1][2] then
	OppLimIndex = NumPoints_Opp + 1
else
	OppLimIndex = NumPoints_Opp
endif



return


801:
! ==============================================================================
! Select the reveal point index until the Outside Face plasters have to run in curved panel case
! ------------------------------------------------------------------------------
! Input variables:
!	RevealPnts:				reveal points
!	NumPoints_Ref:			number of points on Outside Face
!
! Returned variables:
!	RefLimIndex:			index of the reveal point
! ==============================================================================

if RevealPnts[MaxNumPoints-NumPoints_Ref + 1][2] > RevealPnts[MaxNumPoints-NumPoints_Ref][2] then
	RefLimIndex = MaxNumPoints - NumPoints_Ref + 1
else
	RefLimIndex = MaxNumPoints - NumPoints_Ref + 1
endif


return







]]>
</Script_2D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_1D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
EPS = 0.0001
smallEPS = 0.0000001

! ==============================================================================

curvedWall	= abs(WIDO_ORIG_DIST) > EPS

bRotAngle180 = SYMB_ROTANGLE > EPS
wallIsLeft	= bRotAngle180 exor WIDO_REVEAL_SIDE
signWallIsLeft	= wallIsleft - not(wallIsleft)


! ==============================================================================

REVEAL_EDGE				= 0
REVEAL_NO				= 1
REVEAL_POSITIVE			= 2
REVEAL_NEGATIVE			= 3
REVEAL_SLANTED			= 4
REVEAL_SPLAYED			= 5
REVEAL_HISTORIC			= 6
REVEAL_DOUBLE			= 7
REVEAL_DOUBLE_SPLAYED	= 8
REVEAL_OUTSIDE_SPLAYED	= 9


! ==============================================================================
! Reveal Points Indexes
! ==============================================================================

idxSillStartRevealLeft		= iRevealPointsIdx[1]
idxSillEndRevealLeft		= iRevealPointsIdx[2]
idxBoardStartRevealLeft		= iRevealPointsIdx[5]
idxBoardEndRevealLeft		= iRevealPointsIdx[6]

idxSillStartRevealRight		= iRevealPointsIdx[11]
idxSillEndRevealRight		= iRevealPointsIdx[12]
idxBoardStartRevealRight	= iRevealPointsIdx[15]
idxBoardEndRevealRight		= iRevealPointsIdx[16]

! ==============================================================================

if not(wallIsLeft) then
	SignCorr = 1
	RevSignCorr = -1
	AddOppPoint = bSillAddPoint
	AddRefPoint = bBoardAddPoint
else
	SignCorr = -1
	RevSignCorr = 1
	AddOppPoint = bBoardAddPoint
	AddRefPoint = bSillAddPoint
endif



if SYMB_MIRRORED then
	InclWallyCorrSign = -1
else
	InclWallyCorrSign = 1
endif
if WIDO_REVEAL_SIDE then InclWallyCorrSign = -1 * InclWallyCorrSign


reorder = (AC_Wall_Direction_Type <> 1 & AC_Wall_Direction_Type <> 3)
signReorder = -1 * (not(reorder) - reorder)


MaxNumPointsLeft = idxBoardEndRevealLeft
MaxNumPointsRight = idxBoardEndRevealRight

if wallIsLeft then
	NumPointsLeft_Ref = abs(idxSillStartRevealLeft - idxSillEndRevealLeft) + 1
	NumPointsLeft_Opp = abs(idxBoardStartRevealLeft - idxBoardEndRevealLeft) + 1

	NumPointsRight_Ref = abs(idxSillStartRevealRight - idxSillEndRevealRight) + 1
	NumPointsRight_Opp = abs(idxBoardStartRevealRight - idxBoardEndRevealRight) + 1

	AddOppPointLeft		= bAddPoint[3]
	AddRefPointLeft		= bAddPoint[1]
	AddOppPointRight	= bAddPoint[4]
	AddRefPointRight	= bAddPoint[2]
else
	NumPointsLeft_Opp = abs(idxSillStartRevealLeft - idxSillEndRevealLeft) + 1
	NumPointsLeft_Ref = abs(idxBoardStartRevealLeft - idxBoardEndRevealLeft) + 1

	NumPointsRight_Opp = abs(idxSillStartRevealRight - idxSillEndRevealRight) + 1
	NumPointsRight_Ref = abs(idxBoardStartRevealRight - idxBoardEndRevealRight) + 1

	AddOppPointLeft		= bAddPoint[1]
	AddRefPointLeft		= bAddPoint[3]
	AddOppPointRight	= bAddPoint[2]
	AddRefPointRight	= bAddPoint[4]
endif


! ==============================================================================
! Cavity Closure
! ==============================================================================

SKIN_FILL				=  1
SKIN_THICKNESS			=  2
SKIN_CONT_PEN			=  3	! Obsolete (old contour pen)
SKIN_FILL_PEN			=  4
SKIN_FILL_BACK_PEN		=  5
SKIN_CORE_STATUS		=  6
SKIN_UPPER_LINE_PEN		=  7 + 2 * reorder
SKIN_UPPER_LINE_TYPE	=  8 + 2 * reorder
SKIN_LOWER_LINE_PEN		=  9 - 2 * reorder
SKIN_LOWER_LINE_TYPE	= 10 - 2 * reorder
SKIN_END_FACE_PEN		= 11
SKIN_FILL_ORIENTATION	= 12	! 0 - global, 1 - local
SKIN_TYPE				= 13	! 0 - cut, 1 - below cutplane, 2 - above cutplane (all skin types are 0 for simple walls)
!	For D/W in complex walls on the floor plan this variable contains the data of all cut skins, for wall ends on the floor plan the data of all skins.
!	For D/W and wall ends in the 3D window contains the data of the skins actually cut by the D/W or wall end
SKIN_END_LINE_TYPE		= 14
SKIN_FINISH_STATUS		= 15
SKIN_FILL_FIT_TO_SKIN	= 16
SKIN_THICKEN_TRAPEZOID	= 17


! Line Property defines:
LINE_PROPERTY_GENERIC	= 0
LINE_PROPERTY_INNER		= 1
LINE_PROPERTY_CONTOUR	= 2


! Partial Stucture Display defines:
STRUCTURE_ENTIRE_STRUCTURE	= 0
STRUCTURE_CORE_ONLY			= 1
STRUCTURE_WITHOUT_FINISHES	= 2



if reorder then
	temp = nskinTurnOut
	nskinTurnOut = nskinTurnIn
	nskinTurnIn = temp
endif

! ==============================================================================
! Calculations for Curved Walls
! ==============================================================================

leftAlfa	= 0
rightAlfa	= 0

if GLOB_SCRIPT_TYPE = 2 | GLOB_SCRIPT_TYPE = 3 then
	if curvedWall then

		if GLOB_SCRIPT_TYPE <> 2 & GLOB_CONTEXT <> 22 then
			widoOrigDist = -WIDO_ORIG_DIST
		else
			widoOrigDist =  WIDO_ORIG_DIST
		endif

		tempWOD = abs(widoOrigDist) - (SYMB_ROTANGLE > EPS) * WIDO_FRAME_THICKNESS

		leftAlfa	= atn(leftWidth / tempWOD)
		rightAlfa	= atn(rightWidth / tempWOD)

		bArchSign = (WIDO_REVEAL_SIDE exor SYMB_ROTANGLE > EPS)
		iArchSign = bArchSign - not(bArchSign)		! 1 / -1

		rSillLine = radSill - iArchSign * WIDO_SILL	! Radius of the reveal at the Sill depth
	else
		iArchSign = 0
	endif
endif


]]>
</Script_1D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_PR SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_PR>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_UI SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
bDefaultElem		= (GLOB_INTGUID = "" | GLOB_INTGUID = "{00000000-0000-0000-0000-000000000000}")
bShowCavityClosure	= (bDefaultElem | WALL_SKINS_NUMBER > 0)
bShowTurnPlaster	= (bDefaultElem | WALL_SKINS_NUMBER > 1)

bShowTurnPlasterIn	= bShowTurnPlaster & (bEnablePlasterLeftIn  | bEnablePlasterRightIn)
bShowTurnPlasterOut	= bShowTurnPlaster & (bEnablePlasterLeftOut | bEnablePlasterRightOut)

x = 0
if bStandaloneOnPage then
	y = 70 + pageStartY
else
	y = 122 + pageStartY
endif
x2 = 227

if not(bStandaloneOnPage) then
	ui_separator 0, y, 444, y
endif
y = y + 2



ui_style 0, 1

iFlag = 4 * (not(bShowTurnPlasterIn) & not(bShowTurnPlasterOut) & not(bShowCavityClosure))

if bStandaloneOnPage then
	yTitle = 40 + pageStartY
else
	yTitle = y+1
endif
ui_outfield stTitlePrefix + stCavityClosureUI[33], x, yTitle, 300, 16, iFlag		! Plaster Skin Definition
y = y + 19
ui_style 0, 0

ui_infield{3} "gs_useWallFinishSkin", x, y, 215, 16,
				7, "",
				2,
				1, 20, 20, 20, 20,
				0, stCavityClosureUI[23], 0,	! Use Wall Finish Component
				1, stCavityClosureUI[23], 1		! Use Wall Finish Component

iFlag = 4 * ((not(bShowTurnPlasterIn) & not(bShowTurnPlasterOut) & not(bShowCavityClosure)) | gs_useWallFinishSkin)

ui_outfield stCavityClosureUI[22], x2, y, 122, 16, iFlag		! Plaster Thickness Limit
ui_infield "gs_maxPlasterThk", x2+123, y-3, 90, 20  ui_tooltip stCavityClosureUI[32]

y = y + 19

ui_separator 0, y, 444, y

y = y + 2

iFlag = 4 * (not(bShowTurnPlasterIn) & not(bShowTurnPlasterOut) & not(bShowCavityClosure))

ui_style 0, 1
ui_outfield stCavityClosureUI[17], x, y+1, 160, 16, iFlag		! Turn Plaster
ui_style 0, 0

y = y + 19

iFlag = 4 * not(bShowTurnPlasterIn)

ui_outfield stCavityClosureUI[18], x, y+2, 120, 16, iFlag	! Outside Face

ui_infield{3} "gs_bAutoTurnIn", x+122, y-1, x2-x-124, 20,
				7, "",
				2,
				1, 20, 20, 20, 20,
				0, stCavityClosureUI[20], 0,	! Automatically
				1, stCavityClosureUI[20], 1		! Automatically

iFlag = 4 * not(bShowTurnPlasterIn)

ui_outfield stCavityClosureUI[21], x2, y+1, 160, 16, iFlag		! Number of Skins to Turn

ui_infield "gs_bOverIn", 440-40, y, 40, 16

y = y + 19


iFlag = 4 * not(bShowTurnPlasterOut)

ui_outfield stCavityClosureUI[19], x, y+2, 120, 16, iFlag	! Inside Face

ui_infield{3} "gs_bAutoTurnOut", x+122, y-1, x2-x-124, 20,
				7, "",
				2,
				1, 20, 20, 20, 20,
				0, stCavityClosureUI[20], 0,	! Automatically
				1, stCavityClosureUI[20], 1		! Automatically

iFlag = 4 * not(bShowTurnPlasterOut)

ui_outfield stCavityClosureUI[21], x2, y+1, 160, 16, iFlag		! Number of Skins to Turn


ui_infield "gs_bOverOut", 440-40, y, 40, 16

y = y + 20

ui_infield{3} "gs_turn_plaster_dim_2D", x, y, 215, 20,
				7, "",
				2,
				1, 20, 20, 20, 20,
				0, stCavityClosureUI[60], 0,	! Dimensionable on 2D
				1, stCavityClosureUI[60], 1		! Dimensionable on 2D

ui_infield{3} "gs_turn_plaster_show_3D", x2, y, 140, 20,
				7, "",
				2,
				1, 20, 20, 20, 20,
				0, stCavityClosureUI[34], 0,	! Show in 3D
				1, stCavityClosureUI[34], 1		! Show in 3D

y = y + 20

iFlag = 4 * (not(bShowTurnPlasterIn) & not(bShowTurnPlasterOut) & not(bShowCavityClosure))

ui_outfield stCavityClosureUI[35], x, y+1, 440, 16, iFlag
!Note: Plaster is turned outside the wall contour defined in the reveal settings




]]>
</Script_UI>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_VL SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! Contact person: <JT, TZs>

! ==============================================================================
! This macro draws the cavity closure and turned plasters
! ------------------------------------------------------------------------------
! Input parameters:
!	gs_maxPlasterThk:	wall skin classification parameter (length)
!						consider Skin as Plaster if it is thinner this
!	gs_bAutoTurnIn:		automatic plaster return at Outside Face (0 / 1)
!	gs_bAutoTurnOut:	automatic plaster return at Inside Face (0 / 1)
!	gs_bOverIn:			number of turned plaster skins at Outside Face (integer)
!	gs_bOverOut:		number of turned plaster skins at Inside Face (integer)
! ==============================================================================


bDefaultElem = (GLOB_INTGUID = "" | GLOB_INTGUID = "{00000000-0000-0000-0000-000000000000}")


! ==============================================================================
! Auto Turn Plaster
! ==============================================================================

values "gs_maxPlasterThk" range [0,]

if gs_useWallFinishSkin then
	lock "gs_maxPlasterThk"
	hideparameter "gs_maxPlasterThk"
endif

if gs_bAutoTurnIn then
	lock "gs_bOverIn"
	hideparameter "gs_bOverIn"
	parameters gs_bOverIn = maxSkinTurnIn
else
	if bDefaultElem then
		values "gs_bOverIn" range[0, ]
	else
!		for i=0 to maxSkinTurnIn		! INFO: A Settings Dialogban nem mukodik, mert a
!			put i						! SYMB_MIRRORED, WIDO_REVEAL_SIDE es SYMB_ROTANGLE
!		next i							! mindig nulla
!		values "gs_bOverIn" get(nsp)
		values "gs_bOverIn" range[0, ]
	endif
endif

if gs_bAutoTurnOut then
	lock "gs_bOverOut"
	hideparameter "gs_bOverOut"
	parameters gs_bOverOut = maxSkinTurnOut
else
	if bDefaultElem then
		values "gs_bOverOut" range[0, ]
	else
!		for i=0 to maxSkinTurnOut
!			put i
!		next i
!		values "gs_bOverOut" get(nsp)
		values "gs_bOverOut" range[0, ]
	endif
endif


! ==============================================================================
! Show / Hide Parameters
! ==============================================================================

bShowCavityClosure	= (bDefaultElem | WALL_SKINS_NUMBER > 0)
bShowTurnPlaster	= (bDefaultElem | WALL_SKINS_NUMBER > 1)

bShowTurnPlasterIn	= bShowTurnPlaster & (bEnablePlasterLeftIn  | bEnablePlasterRightIn  | bEnablePlasterTopIn  | bEnablePlasterBottomIn)
bShowTurnPlasterOut	= bShowTurnPlaster & (bEnablePlasterLeftOut | bEnablePlasterRightOut | bEnablePlasterTopOut | bEnablePlasterBottomOut)

if not(bShowTurnPlasterIn) then
	hideparameter	"gs_bAutoTurnIn",
					"gs_bOverIn"
	lock	"gs_bAutoTurnIn",
			"gs_bOverIn"
endif
if not(bShowTurnPlasterOut) then
	hideparameter	"gs_bAutoTurnOut",
					"gs_bOverOut"
	lock	"gs_bAutoTurnOut",
			"gs_bOverOut"
endif
if not(bShowTurnPlasterIn) & not(bShowTurnPlasterOut) then
	hideparameter	"gs_turn_plaster_dim_2D", "gs_turn_plaster_show_3D"
	lock			"gs_turn_plaster_dim_2D", "gs_turn_plaster_show_3D"
endif

if not(bShowTurnPlasterIn) & not(bShowTurnPlasterOut) & not(bShowCavityClosure) then
	hideparameter	"gs_maxPlasterThk",
					"gs_useWallFinishSkin"
	lock	"gs_maxPlasterThk",
			"gs_useWallFinishSkin"
endif

! --- WIDO_REVEAL_SIDE and WIDO_ORIG_DIST globals don't working in the settings dialog


]]>
</Script_VL>

<Comment SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Comment>

<ParamSection SectVersion="22" SectionFlags="0" SubIdent="0">
	<ParamSectHeader>
		<AutoHotspots>false</AutoHotspots>
		<StatBits>
			<STBit_FixSize/>
		</StatBits>
		<WDLeftFrame>0</WDLeftFrame>
		<WDRightFrame>0</WDRightFrame>
		<WDTopFrame>0</WDTopFrame>
		<WDBotFrame>0</WDBotFrame>
		<LayFlags>65532</LayFlags>
		<WDMirrorThickness>0</WDMirrorThickness>
		<WDWallInset>0</WDWallInset>
	</ParamSectHeader>
	<Parameters>
		<Length Name="A">
			<Description><![CDATA["Dimension 1"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Length Name="B">
			<Description><![CDATA["Dimension 2"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Length Name="ZZYZX">
			<Description><![CDATA["Height"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Boolean Name="AC_show2DHotspotsIn3D">
			<Description><![CDATA["Show 2D Hotspots in 3D"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Length Name="ac_bottomlevel">
			<Description><![CDATA["Bottom Level"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="ac_toplevel">
			<Description><![CDATA["Top Level"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Integer Name="gs_macro_version">
			<Description><![CDATA["Macro Version"]]></Description>
			<Value>11</Value>
		</Integer>
		<Integer Name="AC_Hole_Display_Option">
			<Description><![CDATA["Floor Plan Display Option"]]></Description>
			<Value>3</Value>
		</Integer>
		<Integer Name="AC_WallType">
			<Description><![CDATA["Wall Type"]]></Description>
			<Value>0</Value>
		</Integer>
		<Length Name="AC_WallContourPolygon">
			<Description><![CDATA["Wall Contour Polygon"]]></Description>
			<ArrayValues FirstDimension="1" SecondDimension="3">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="AC_Wall_Direction_Type">
			<Description><![CDATA["Wall Direction Type"]]></Description>
			<Value>0</Value>
		</Integer>

		<!-- gs_wallhole_geometry: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_wallhole_geometry">
			<Description><![CDATA["Wallhole Geometry"]]></Description>
		</Title>
		<Length Name="refWidth">
			<Description><![CDATA["Curved Wall - Reference Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="leftWidth">
			<Description><![CDATA["Left Offset from the Origo"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="rightWidth">
			<Description><![CDATA["Right Offset from the Origo"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="radSill">
			<Description><![CDATA["Curved Wall - Sill Radius"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="radBoard">
			<Description><![CDATA["Curved Wall - Board Radius"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="WOD">
			<Description><![CDATA["Curved Wall - Wall Center Distance"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="offsetSill">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="offsetBoard">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Integer Name="possibleSkinTurnOut">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Integer>
		<Integer Name="possibleSkinTurnIn">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Integer>
		<Integer Name="maxSkinTurnIn">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Integer>
		<Integer Name="maxSkinTurnOut">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Integer>
		<Integer Name="nSkinTurnIn">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Integer>
		<Integer Name="nSkinTurnOut">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Integer>
		<Integer Name="iRevealType">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_BoldName/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Length Name="leftRevealPnts">
			<Description><![CDATA["Left Reveal Points"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="rightRevealPnts">
			<Description><![CDATA["Right Reveal Points"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="iRevealPointsIdx">
			<Description><![CDATA["Reveal Points Index"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="20" SecondDimension="0">
				<AVal Row="1">1</AVal>
				<AVal Row="2">1</AVal>
				<AVal Row="3">1</AVal>
				<AVal Row="4">1</AVal>
				<AVal Row="5">1</AVal>
				<AVal Row="6">1</AVal>
				<AVal Row="7">1</AVal>
				<AVal Row="8">1</AVal>
				<AVal Row="9">1</AVal>
				<AVal Row="10">1</AVal>
				<AVal Row="11">1</AVal>
				<AVal Row="12">1</AVal>
				<AVal Row="13">1</AVal>
				<AVal Row="14">1</AVal>
				<AVal Row="15">1</AVal>
				<AVal Row="16">1</AVal>
				<AVal Row="17">1</AVal>
				<AVal Row="18">1</AVal>
				<AVal Row="19">1</AVal>
				<AVal Row="20">1</AVal>
			</ArrayValues>
		</Integer>
		<Boolean Name="bAddPoint">
			<Description><![CDATA["Additional Plaster Points"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="4" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
			</ArrayValues>
		</Boolean>
		<Length Name="gs_reveal_left">
			<Description><![CDATA["Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.05</Value>
		</Length>
		<Length Name="gs_reveal_right">
			<Description><![CDATA["Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.1</Value>
		</Length>
		<Angle Name="gs_reveal_left_angle">
			<Description><![CDATA["Angle Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_right_angle">
			<Description><![CDATA["Angle Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>40</Value>
		</Angle>

		<!-- gs_macro_control_parameters: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_macro_control_parameters">
			<Description><![CDATA["Macro Control Parameters"]]></Description>
		</Title>
		<Boolean Name="bWndCurved">
			<Description><![CDATA["Curved Window"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bParalellInCurvedWalls">
			<Description><![CDATA["Parallel Opening in Curved Walls"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bDrawObjContourIn">
			<Description><![CDATA["Draw Wall Contour With LINE2 at Ref. Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bDrawObjContourOut">
			<Description><![CDATA["Draw Wall Contour With LINE2 at Opp. Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bDrawFrameContourLeft">
			<Description><![CDATA["Draw Frame Contour at Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bDrawFrameContourRight">
			<Description><![CDATA["Draw Frame Contour at Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bCornerWindow">
			<Description><![CDATA["Is Corner Window"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bLeftCornerFunction">
			<Description><![CDATA["Corner on Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bWindowSymbolAtMiddle">
			<Description><![CDATA["Window in the Middle of the Wall (CHI Special)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bEnablePlasterLeftIn">
			<Description><![CDATA["Enable/Disable Left Inner Plaster Turn"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bEnablePlasterLeftOut">
			<Description><![CDATA["Enable/Disable Left Outer Plaster Turn"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bEnablePlasterRightIn">
			<Description><![CDATA["Enable/Disable Right Inner Plaster Turn"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bEnablePlasterRightOut">
			<Description><![CDATA["Enable/Disable Right Outer Plaster Turn"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bEnablePlasterTopIn">
			<Description><![CDATA["Enable/Disable Top Inner Plaster Turn"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bEnablePlasterTopOut">
			<Description><![CDATA["Enable/Disable Top Outer Plaster Turn"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bEnablePlasterBottomIn">
			<Description><![CDATA["Enable/Disable Bottom Inner Plaster Turn"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bEnablePlasterBottomOut">
			<Description><![CDATA["Enable/Disable Bottom Outer Plaster Turn"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bStandaloneOnPage">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- StackedWindow: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="StackedWindow">
			<Description><![CDATA["Ganging"]]></Description>
		</Title>
		<Boolean Name="gs_stack_left">
			<Description><![CDATA["Connection on the Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_stack_right">
			<Description><![CDATA["Connection on the Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- gs_turn_plaster: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_turn_plaster">
			<Description><![CDATA["Turn Plaster"]]></Description>
		</Title>
		<Boolean Name="gs_useWallFinishSkin">
			<Description><![CDATA["Use Wall Finish Component"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_maxPlasterThk">
			<Description><![CDATA["Plaster Thickness Limit"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.04</Value>
		</Length>
		<Boolean Name="gs_bAutoTurnOut">
			<Description><![CDATA["Auto Turn Inside Face Plaster"]]></Description>
			<Value>1</Value>
		</Boolean>
		<Integer Name="gs_bOverOut">
			<Description><![CDATA["Turn Inside Face Plaster"]]></Description>
			<Value>0</Value>
		</Integer>
		<Boolean Name="gs_bAutoTurnIn">
			<Description><![CDATA["Auto Turn Outside Face Plaster"]]></Description>
			<Value>1</Value>
		</Boolean>
		<Integer Name="gs_bOverIn">
			<Description><![CDATA["Turn Outside Face Plaster"]]></Description>
			<Value>0</Value>
		</Integer>
		<Boolean Name="gs_turn_plaster_dim_2D">
			<Description><![CDATA["Dimensionable on 2D"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_turn_plaster_show_3D">
			<Description><![CDATA["Show in 3D"]]></Description>
			<Value>0</Value>
		</Boolean>

		<!-- gs_string_resources: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_string_resources">
			<Description><![CDATA["String Resources"]]></Description>
		</Title>
		<String Name="stCavityClosureUI">
			<Description><![CDATA[""]]></Description>
			<ArrayValues FirstDimension="60" SecondDimension="0">
				<AVal Row="1"><![CDATA["Замыкание Слоев"]]></AVal>
				<AVal Row="2"><![CDATA["Способ Замыкания"]]></AVal>
				<AVal Row="3"><![CDATA["Сторона Проема"]]></AVal>
				<AVal Row="4"><![CDATA["Наружных Слоев"]]></AVal>
				<AVal Row="5"><![CDATA["Поворачивающих Слоев"]]></AVal>
				<AVal Row="6"><![CDATA["Начало Нумерации"]]></AVal>
				<AVal Row="7"><![CDATA["Поворот на Четверти"]]></AVal>
				<AVal Row="8"><![CDATA["Термовкладыш"]]></AVal>
				<AVal Row="9"><![CDATA["Толщина"]]></AVal>
				<AVal Row="10"><![CDATA["Перо Контура"]]></AVal>
				<AVal Row="11"><![CDATA["Тип Линии"]]></AVal>
				<AVal Row="12"><![CDATA["Тип Штриховки"]]></AVal>
				<AVal Row="13"><![CDATA["Перо Штриховки"]]></AVal>
				<AVal Row="14"><![CDATA["Перо Фона Штриховки"]]></AVal>
				<AVal Row="15"><![CDATA["Профиль"]]></AVal>
				<AVal Row="16"><![CDATA["Ширина"]]></AVal>
				<AVal Row="17"><![CDATA["Поворот Штукатурки"]]></AVal>
				<AVal Row="18"><![CDATA["Снаружи"]]></AVal>
				<AVal Row="19"><![CDATA["Внутри"]]></AVal>
				<AVal Row="20"><![CDATA["Автоматически"]]></AVal>
				<AVal Row="21"><![CDATA["Поворачивающих Слоев"]]></AVal>
				<AVal Row="22"><![CDATA["Предел Толщины Штукатурки"]]></AVal>
				<AVal Row="23"><![CDATA["Использовать Отделку Стены"]]></AVal>
				<AVal Row="24"><![CDATA["Выбор Редактируемого Слоя"]]></AVal>
				<AVal Row="25"><![CDATA["Продлить Слой до Термовкладыша"]]></AVal>
				<AVal Row="26"><![CDATA["1. Толщина Поворота"]]></AVal>
				<AVal Row="27"><![CDATA["Специальная Толщина"]]></AVal>
				<AVal Row="28"><![CDATA["Ориентация Штриховки"]]></AVal>
				<AVal Row="29"><![CDATA["Разделитель при Повороте Внутрь"]]></AVal>
				<AVal Row="30"><![CDATA["Перо Разделительной Линии"]]></AVal>
				<AVal Row="31"><![CDATA["2. Продление Слоя за Коробку"]]></AVal>
				<AVal Row="32"><![CDATA["Считать Слой Штукатуркой, если он Тоньше или Равен"]]></AVal>
				<AVal Row="33"><![CDATA["Настройка Слоя Штукатурки"]]></AVal>
				<AVal Row="34"><![CDATA["Показ в 3D"]]></AVal>
				<AVal Row="35"><![CDATA["Прим: Ширина Четверти определяет толщину повернутого слоя Штукатурки."]]></AVal>
				<AVal Row="36"><![CDATA["Реквизиты Термовкладыша"]]></AVal>
				<AVal Row="37"><![CDATA["Реквизиты"]]></AVal>
				<AVal Row="38"><![CDATA[""]]></AVal>
				<AVal Row="39"><![CDATA[""]]></AVal>
				<AVal Row="40"><![CDATA["1. Считать Слой Штукатуркой"]]></AVal>
				<AVal Row="41"><![CDATA["Размеры Ширины Четверти определяют толщину повернутого слоя Штукатурки."]]></AVal>
				<AVal Row="42"><![CDATA["Несущий слой не может быть повернут."]]></AVal>
				<AVal Row="43"><![CDATA[""]]></AVal>
				<AVal Row="44"><![CDATA[""]]></AVal>
				<AVal Row="45"><![CDATA["Вкладыш для"]]></AVal>
				<AVal Row="46"><![CDATA["от"]]></AVal>
				<AVal Row="47"><![CDATA["Сторона Проема"]]></AVal>
				<AVal Row="48"><![CDATA["Сторона Проема"]]></AVal>
				<AVal Row="49"><![CDATA["Продлить Слой до Термовкладыша"]]></AVal>
				<AVal Row="50"><![CDATA["1. Слой"]]></AVal>
				<AVal Row="51"><![CDATA["2. Слой"]]></AVal>
				<AVal Row="52"><![CDATA["3. Слой"]]></AVal>
				<AVal Row="53"><![CDATA["4. Слой"]]></AVal>
				<AVal Row="54"><![CDATA[""]]></AVal>
				<AVal Row="55"><![CDATA[""]]></AVal>
				<AVal Row="56"><![CDATA[""]]></AVal>
				<AVal Row="57"><![CDATA[""]]></AVal>
				<AVal Row="58"><![CDATA[""]]></AVal>
				<AVal Row="59"><![CDATA[""]]></AVal>
				<AVal Row="60"><![CDATA["Размеры в 2D"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stTitlePrefix">
			<Description><![CDATA[""]]></Description>
			<Value><![CDATA[""]]></Value>
		</String>

		<!-- gs_transom_display: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="gs_transom_display">
			<Description><![CDATA["Display as Transom"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<PenColor Name="gs_transom_display_pen">
			<Description><![CDATA["Wall End Line Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<LineType Name="gs_transom_display_linetype">
			<Description><![CDATA["Wall End Line Line Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</LineType>
		<Boolean Name="bSillAddPoint">
			<Description><![CDATA["Additional Point at Sill"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bBoardAddPoint">
			<Description><![CDATA["Additional Point at Board"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Integer Name="revealPointsIdx">
			<Description><![CDATA["Reveal \points Indexes"]]></Description>
			<ArrayValues FirstDimension="10" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="pageStartY">
			<Description><![CDATA["Page Start Y"]]></Description>
			<Value>0</Value>
		</Integer>
	</Parameters>
</ParamSection>

<Copyright SectVersion="1" SectionFlags="0" SubIdent="0">
	<Author>GRAPHISOFT</Author>
	<License>
		<Type>CC BY-ND</Type>
		<Version>3.0</Version>
	</License>
</Copyright>

</Symbol>
