<?xml version="1.0" encoding="UTF-8"?>
<Symbol IsArchivable="false" IsPlaceable="false" MainGUID="BA0CCE14-A656-4D31-900A-BC11F46EEC5C" MigrationValue="Normal" Owner="1196638531" Signature="1196644685" Version="43">
<Ancestry SectVersion="1" SectionFlags="0" SubIdent="0" Template="false">
	<MainGUID>F938E33A-329D-4A36-BE3E-85E126820996</MainGUID>
	<MainGUID>103E8D2C-8230-42E1-9597-46F84CCE28C0</MainGUID>
	<MainGUID>B2970E4C-8680-4061-8670-2F4B638F3953</MainGUID>
</Ancestry>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_3D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! Contact person: <NJ>

! ==============================================================================
! This macro cuts the wallhole
! ------------------------------------------------------------------------------
! Input parameters:
! Geometry ---------------------------------------------------------------------
!	A:						Window nominal width (length)
!	B:						Window nominal height (length)
!	archHeight:				Height of the arc (length)
!	nArchResolution:		Arc resolution for arched windows (integer)
!								if nArchResolution < 3 then WALL_RESOL used instead
! Functions --------------------------------------------------------------------
!	iWindowShape:			Shape of the window (integer)
!								0 = rectangular (default)
!								1 = arched
!							Note: only the rectangular shape can be a Corner Window
!	AC_Hole_Hotspot_Control:
!	AC_HoleSideMaterial:
!	AC_HoleMaterialCurved:
! Reveal -----------------------------------------------------------------------
!	iRevealType:
!	gs_reveal_left_angle:
!	gs_reveal_right_angle:
!	gs_reveal_top_angle:
!	gs_reveal_bottom_angle:
! Corner Function --------------------------------------------------------------
!	bLeftCornerFunction:		Turn macro in Corner Window mode at the left side (0 / 1)
!	leftCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	leftConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
!	bRightCornerFunction:	Turn macro in Corner Window mode at the right side (0 / 1)
!	rightCornerAngle:		Angle between connected walls in case of Corner Window (angle)
!	rightConnWallThk:		Thickness of the connected wall in case of Corner Window (length)
!	bCornerWindow:			Traditional Corner Window
! Oversize ---------------------------------------------------------------------
!	gs_left_oversize:		Left opening oversize (length)
!	gs_right_oversize:		Right opening oversize (length)
!	gs_upper_oversize:		Upper opening oversize (length)
!	gs_lower_oversize:		Lower opening oversize (length)
! Ganging ----------------------------------------------------------------------
!	gs_stack_left:			Align to door/window on left side (0 / 1)
!	gs_stack_right:			Align to door/window on right side (0 / 1)
!	gs_stack_top:			Align to door/window on upper side (0 / 1)
!	gs_stack_bottom:		Align to door/window on bottom side (0 / 1)
! Parapet ----------------------------------------------------------------------
!	gs_parapet_wall_inset:	Switch on / off the Wall Inset function. (0 / 1)
!	gs_parapet_inset_thk:	Depth of Wall Inset. (length)
!	gs_parapet_width:		Parapet width (length)
!	gs_parapet_height:		Parapet height (length)
!
! Related Global Variables:
!	WALL_THICKNESS
!	WALL_VIEW_PEN
!	WIDO_FRAME_THICKNESS
!	WIDO_SILL
!	WIDO_ORIG_DIST
!	WIDO_REVEAL_SIDE
!	SYMB_MIRRORED
!	SYMB_ROTANGLE
! ==============================================================================

_bCustomMatNicheTop		= 0

! === Turn Plaster in 3D ===[

thkPlasterAtSillLeft	= thkPlasterAtSillLeft		* gs_turn_plaster_show_3D
thkPlasterAtSillRight	= thkPlasterAtSillRight		* gs_turn_plaster_show_3D
thkPlasterAtSillTop		= thkPlasterAtSillTop		* gs_turn_plaster_show_3D
thkPlasterAtSillBottom	= thkPlasterAtSillBottom	* gs_turn_plaster_show_3D

thkPlasterAtSillSlLeft			= thkPlasterAtSillSlLeft		* gs_turn_plaster_show_3D
thkPlasterAtSillSlLeftBottom	= thkPlasterAtSillSlLeftBottom	* gs_turn_plaster_show_3D
thkPlasterAtSillSlRight			= thkPlasterAtSillSlRight		* gs_turn_plaster_show_3D
thkPlasterAtSillSlRightBottom	= thkPlasterAtSillSlRightBottom	* gs_turn_plaster_show_3D

thkPlasterAtBoardLeft	= thkPlasterAtBoardLeft		* gs_turn_plaster_show_3D
thkPlasterAtBoardRight	= thkPlasterAtBoardRight	* gs_turn_plaster_show_3D
thkPlasterAtBoardTop	= thkPlasterAtBoardTop		* gs_turn_plaster_show_3D
thkPlasterAtBoardBottom	= thkPlasterAtBoardBottom	* gs_turn_plaster_show_3D

thkPlasterAtBoardSlLeft			= thkPlasterAtBoardSlLeft		* gs_turn_plaster_show_3D
thkPlasterAtBoardSlLeftBottom	= thkPlasterAtBoardSlLeftBottom	* gs_turn_plaster_show_3D
thkPlasterAtBoardSlRight		= thkPlasterAtBoardSlRight		* gs_turn_plaster_show_3D
thkPlasterAtBoardSlRightBottom	= thkPlasterAtBoardSlRightBottom* gs_turn_plaster_show_3D

thkPlasterAtSill	= max(thkPlasterAtSillLeft, thkPlasterAtSillRight, thkPlasterAtSillTop, thkPlasterAtSillBottom)
thkPlasterAtBoard	= max(thkPlasterAtBoardLeft, thkPlasterAtBoardRight, thkPlasterAtBoardTop, thkPlasterAtBoardBottom)

SillPlasterAtFrame	= thkPlasterAtSill  * (iRevealType = REVEAL_NEGATIVE | (iRevealType = REVEAL_DOUBLE & iSillRevealType = REVEAL_NEGATIVE))
BoardPlasterAtFrame	= thkPlasterAtBoard * (iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | (iRevealType = REVEAL_DOUBLE & iBoardRevealType = REVEAL_NEGATIVE))

if not(bCut3DWallhole) then

	! void cut if no wallhole is needed
	addz -2 * WALL_THICKNESS - 1
	wallniche 4, 1, 2+16,
		0,0,1,	0.1,
		-0.1,	0,		31,
		-0.1,	0.1,	31,
		 0.1,	0.1,	31,
		 0.1,	0,		31
	del 1
	end
endif

!!! Chinese
signRevealSide = not(WIDO_REVEAL_SIDE) - WIDO_REVEAL_SIDE
SymbolMid_shiftDy = bDWSymbolAtMiddle * (WIDO_SILL - WALL_THICKNESS / 2 + WIDO_FRAME_THICKNESS / 2) * signRevealSide

addz -SymbolMid_shiftDy

! === Window Shape related definitions ===[

bNeedMiddleCut = 0

if iRevealType = REVEAL_DOUBLE then
	CustRevealOffsetDepth	= WIDO_FRAME_THICKNESS
	CustRevealLeftJamb		= revealInnerLeft
	CustRevealRightJamb		= revealInnerRight
	CustRevealTopJamb		= gs_reveal_double_innerTop
	CustRevealBottJamb		= gs_reveal_double_innerBottom
else
	CustRevealOffsetDepth	= 0
	CustRevealLeftJamb		= 0
	CustRevealRightJamb		= 0
	CustRevealTopJamb		= 0
	CustRevealBottJamb		= 0
endif

if thkPlasterAtBoardLeft > EPS | thkPlasterAtBoardRight > EPS | thkPlasterAtBoardTop > EPS | thkPlasterAtBoardBottom > EPS then
	bNeedMiddleCut = 1
	CustRevealOffsetDepth	= WIDO_FRAME_THICKNESS
endif
if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE | iRevealType = REVEAL_DOUBLE_SPLAYED then
	bNeedMiddleCut = 1
endif


if iWindowShape <> SHAPE_MULTISIDE then
	if nArchResolution < 3 then nArchResolution = WALL_RESOL
endif

if iWindowShape = SHAPE_ARCHED then
	if archHeight < EPS then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		if archHeight > (openingWidth / 2 - EPS) then
			archHeight = openingWidth / 2
			arcR = archHeight
			bHalfCircle = 1
		else
			arcR = (openingWidth / 2) / sin(2 * atn(archHeight / (openingWidth / 2)))
			bHalfCircle = 0
		endif
	endif
endif

if iWindowShape = SHAPE_HALFARCH then
	if archHeight < EPS then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		arcR = (openingWidth * openingWidth + archHeight * archHeight) / (2 * archHeight)
		shoulder_angle	= ACS(openingWidth / arcR)

		!Sill
		if curvedWall & not(bParalellInCurvedWalls) then
			thkPlasterAtSillLeft_distx	= thkPlasterAtSillLeft  / cos(alfaLeftOs  - alfaLeftJamb)
			thkPlasterAtSillRight_distx	= thkPlasterAtSillRight / cos(alfaRightOs - alfaRightJamb)
			offLeft		= leftWidth  - abs(WOD) * tan(alfaLeftOs  - alfaLeftJamb)  + gs_left_oversize  + thkPlasterAtSillLeft_distx  + SillPlasterAtFrame * tan(alfaLeftOs  - alfaLeftJamb)
			offRight	= rightWidth - abs(WOD) * tan(alfaRightOs - alfaRightJamb) + gs_right_oversize + thkPlasterAtSillRight_distx + SillPlasterAtFrame * tan(alfaRightOs - alfaRightJamb)
		else
			offLeft	 = leftJamb  + thkPlasterAtSillLeft
			offRight = rightJamb + thkPlasterAtSillRight
		endif
		offTop = upperJamb + thkPlasterAtSillTop
		x1 = rightWidth + overSizeRight * not(bRightCornerFunction) - offRight
		y1 = 0
		x2 = x1
		y2 = openingHeight+1
		xo = rightWidth + overSizeRight * not(bRightCornerFunction)
		yo = B + overSizeUpper - arcR
		ro = arcR - offTop

		GOSUB 101	! Circle - Line intersection
		if ya > yb then
			SillTopy	= ya
		else
			SillTopy	= yb
		endif
		SillTopx	= x1

		x1 = -leftWidth - overSizeLeft + offLeft
		x2 = x1
		GOSUB 101	! Circle - Line intersection
		if ya > yb then
			SillShouldy	= ya
		else
			SillShouldy	= yb
		endif
		SillShouldx	= x1

		!Board
		if curvedWall & not(bParalellInCurvedWalls) then
			thkPlasterAtBoardLeft_distx	 = thkPlasterAtBoardLeft  / cos(alfaLeftInnJamb)
			thkPlasterAtBoardRight_distx = thkPlasterAtBoardRight / cos(alfaRightInnJamb)
			if iRevealType = REVEAL_DOUBLE exor wallIsLeft then
				dxL = WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
				dxR = WIDO_FRAME_THICKNESS * tan(alfaRightOs)
			else
				dxL = 0
				dxR = 0
			endif

			offLeft		= CustRevealLeftJamb  + thkPlasterAtBoardLeft_distx  + BoardPlasterAtFrame * tan(alfaLeftInnJamb)  - dxL
			offRight	= CustRevealRightJamb + thkPlasterAtBoardRight_distx + BoardPlasterAtFrame * tan(alfaRightInnJamb) - dxR
		else
			offLeft		= CustRevealLeftJamb   + thkPlasterAtBoardLeft
			offRight	= CustRevealRightJamb  + thkPlasterAtBoardRight
		endif
		offTop = CustRevealTopJamb + thkPlasterAtBoardTop
		x1 = rightWidth + overSizeRight * not(bRightCornerFunction) - offRight
		y1 = 0
		x2 = x1
		y2 = openingHeight+1
		ro = arcR - offTop

		GOSUB 101	! Circle - Line intersection
		if ya > yb then
			BoardTopy	= ya
		else
			BoardTopy	= yb
		endif
		BoardTopx	= x1

		x1 = -leftWidth - overSizeLeft + offLeft
		x2 = x1
		GOSUB 101	! Circle - Line intersection
		if ya > yb then
			BoardShouldy	= ya
		else
			BoardShouldy	= yb
		endif
		BoardShouldx	= x1

		!Frame
		if curvedWall & not(bParalellInCurvedWalls) & wallIsLeft then
			offLeft		= -WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
			offRight	= -WIDO_FRAME_THICKNESS * tan(alfaRightOs)
		else
			offLeft		= 0
			offRight	= 0
		endif
		offTop = 0

		x1 = rightWidth + overSizeRight * not(bRightCornerFunction) - offRight
		y1 = 0
		x2 = x1
		y2 = openingHeight+1
		ro = arcR - offTop

		GOSUB 101	! Circle - Line intersection
		if ya > yb then
			FrameTopy	= ya
		else
			FrameTopy	= yb
		endif
		FrameTopx	= x1

		x1 = -leftWidth - overSizeLeft + offLeft
		x2 = x1
		GOSUB 101	! Circle - Line intersection
		if ya > yb then
			FrameShouldy	= ya
		else
			FrameShouldy	= yb
		endif
		FrameShouldx	= x1

		opWidth = openingWidth - leftJamb - rightJamb
		arcR_revealSide = (opWidth * opWidth + archHeight * archHeight) / (2 * archHeight)
		bFullArc = (abs(openingWidth - archHeight) < EPS)
	endif
endif

if iWindowShape = SHAPE_HALFROUND then

	ang_segm = 360 / nArchResolution

	offSillRight = rightJamb + thkPlasterAtSillRight

	xa = openingWidth * cos(-90)
	ya = openingHeight / 2 * sin(-90)
	if ABS(ya) < EPS then
		ang_cent = -90
	else
		ang_cent = ATN(xa/ya)
	endif

	xa_el = openingWidth * cos(-90 - ang_segm)
	ya_el = openingHeight / 2 * sin(-90 - ang_segm)
	if ABS(ya_el) < EPS then
		ang_cent_el = -90
	else
		ang_cent_el = ATN(xa_el/ya_el)
	endif

	xa_ut = openingWidth * cos(-90 + ang_segm)
	ya_ut = openingHeight / 2 * sin(-90 + ang_segm)
	if ABS(ya_ut) < EPS then
		ang_cent_ut = -90
	else
		ang_cent_ut = ATN(xa_ut/ya_ut)
	endif

	if xa_ut - ABS( offSillRight * sin(ang_cent_ut)) > offSillRight then
		x11 = offSillRight
		y11 = -openingHeight
		x12 = offSillRight
		y12 = openingHeight
		x21 = xa 	- ABS( offSillRight * sin(ang_cent))
		y21 = ya 	+ ( offSillRight * cos(ang_cent))
		x22 = xa_ut - ABS( offSillRight * sin(ang_cent_ut))
		y22 = ya_ut + ( offSillRight * cos(ang_cent_ut))
		GOSUB 100

		sillArcoffs = openingHeight/2 - ABS(cy)
	else
		sillArcoffs = 0
	endif


	offBoardRight = CustRevealRightJamb + thkPlasterAtBoardRight

	xa = openingWidth * cos(-90)
	ya = openingHeight / 2 * sin(-90)
	if ABS(ya) < EPS then
		ang_cent = -90
	else
		ang_cent = ATN(xa/ya)
	endif

	xa_el = openingWidth * cos(-90 - ang_segm)
	ya_el = openingHeight / 2 * sin(-90 - ang_segm)
	if ABS(ya_el) < EPS then
		ang_cent_el = -90
	else
		ang_cent_el = ATN(xa_el/ya_el)
	endif

	xa_ut = openingWidth * cos(-90 + ang_segm)
	ya_ut = openingHeight / 2 * sin(-90 + ang_segm)
	if ABS(ya_ut) < EPS then
		ang_cent_ut = -90
	else
		ang_cent_ut = ATN(xa_ut/ya_ut)
	endif

	if xa_ut - ABS( offBoardRight * sin(ang_cent_ut)) > offBoardRight then
		x11 = offBoardRight
		y11 = -openingHeight
		x12 = offBoardRight
		y12 = openingHeight
		x21 = xa 	- ABS( offBoardRight * sin(ang_cent))
		y21 = ya 	+ ( offBoardRight * cos(ang_cent))
		x22 = xa_ut - ABS( offBoardRight * sin(ang_cent_ut))
		y22 = ya_ut + ( offBoardRight * cos(ang_cent_ut))
		GOSUB 100

		boardArcoffs = openingHeight/2 - ABS(cy)
	else
		boardArcoffs = 0
	endif
endif

if iWindowShape = SHAPE_GOTHICARCH then
	if archHeight < EPS then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		arcR = (openingWidth / 4) + (archHeight * archHeight / openingWidth)
		centSillArcoffs		= archHeight - SQR((arcR - rightJamb - thkPlasterAtSillRight)^2 - (arcR - openingWidth/2)^2)
		centBoardArcoffs	= archHeight - SQR((arcR - CustRevealRightJamb - thkPlasterAtBoardRight)^2 - (arcR - openingWidth/2)^2)
	endif
endif

if iWindowShape = SHAPE_PENTAGON then
	if archHeight < EPS then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		tan_topAngle = archHeight / (openingWidth / 2)
	endif
endif

if iWindowShape = SHAPE_ELLIPSEARCH then
	if archHeight < EPS then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		middleRadiusEllips = (openingWidth * openingWidth / 4 - openingWidth * smallRadiusEllips + archHeight * archHeight) / (2 * archHeight - 2 * smallRadiusEllips)
		smallRadiusEllips_reveal = smallRadiusEllips - rightJamb - thkPlasterAtSillRight
		middleRadiusEllips_reveal = middleRadiusEllips - rightJamb - thkPlasterAtSillRight

		smallRadiusEllips_Innreveal = smallRadiusEllips - CustRevealRightJamb - thkPlasterAtBoardRight
		middleRadiusEllips_Innreveal = middleRadiusEllips - CustRevealRightJamb - thkPlasterAtBoardRight

		if abs(openingWidth / 2 - smallRadiusEllips) > EPS then
			alphaSide = atn ((middleRadiusEllips - archHeight) / (openingWidth / 2 - smallRadiusEllips))
		else
			alphaSide = 0
		endif
		alphaMiddle = (90 - alphaSide) * 2

		if abs((openingWidth - 2 * rightJamb) / 2 - smallRadiusEllips_reveal) > EPS then
			alphaSide_reveal = atn((middleRadiusEllips_reveal - (archHeight - rightJamb)) / ((openingWidth - 2 * rightJamb) / 2 - smallRadiusEllips_reveal))
		else
			alphaSide_reveal = 0
		endif
		alphaMiddle_reveal = 90 - alphaSide_reveal

		if abs((openingWidth - 2 * CustRevealRightJamb) / 2 - smallRadiusEllips_Innreveal) > EPS then
			alphaSide_Innreveal = atn((middleRadiusEllips_Innreveal - (archHeight - CustRevealRightJamb)) / ((openingWidth - 2 * CustRevealRightJamb) / 2 - smallRadiusEllips_Innreveal))
		else
			alphaSide_Innreveal = 0
		endif
		alphaMiddle_Innreveal = 90 - alphaSide_Innreveal
	endif
endif

if iWindowShape = SHAPE_TRAPEZOID then
	if archHeight < EPS then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		tan_topAngle = archHeight / ac_wallhole_width
		archHeight_reveal =  ((openingWidth + oversizeRight - leftJamb - rightJamb) * archHeight)  / (openingWidth + oversizeRight)
		archHeight_Innreveal =  ((openingWidth + oversizeRight - CustRevealLeftJamb - CustRevealRightJamb) * archHeight)  / (openingWidth + oversizeRight)

	endif
endif

if iWindowShape = SHAPE_TRIANGLE then
	tan_LeftSide = ac_wallhole_height / (ac_wallhole_width / 2 + gs_posTopEdge_triangle)
	tan_RightSide = ac_wallhole_height / (ac_wallhole_width / 2 - gs_posTopEdge_triangle)
endif

if iWindowShape = SHAPE_PARALLELOGRAM then
	if archHeight < EPS then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		tan_topAngle = archHeight / openingWidth
		upperJambModify =  (1 / cos(atn(archHeight / (openingWidth + oversizeRight))))
		archHeight_reveal =  ((openingWidth + oversizeRight - leftJamb - rightJamb) * archHeight)  / (openingWidth + oversizeRight)
		archHeight_Innreveal =  ((openingWidth + oversizeRight - CustRevealLeftJamb - CustRevealRightJamb) * archHeight)  / (openingWidth + oversizeRight)
	endif
endif

if iWindowShape = SHAPE_ROMBUS then
	upperJambModify	= (1 / cos(atn(openingHeight / openingWidth)))
	sideJambModify	= (1 / cos(atn(openingWidth / openingHeight)))
endif

if iWindowShape = SHAPE_MULTISIDE then
	if gs_numOfSides = 4 then
		iWindowShape = SHAPE_RECTANGULAR		! Switch back to rectangular shape
	else
		if (gs_numOfSides MOD 2) = 0 then
			if (gs_numOfSides MOD 4) = 0 then
				normalRadius = (openingWidth / 2) / (cos (180 / gs_numOfSides))
			else
				normalRadius = openingWidth / 2
			endif
		else
			if gs_numOfSides = 3 then
				normalRadius = (openingWidth / 2) / (cos (30))
			else
				normalRadius = (openingWidth / 2) / (sin (((gs_numOfSides - 1) * 90) / gs_numOfSides))
			endif
		endif
		revealRadius	= normalRadius - rightJamb / cos (180 / gs_numOfSides)
		innrevealRadius	= normalRadius - CustRevealRightJamb / cos (180 / gs_numOfSides)
		plasterOffs		= thkPlasterAtSillRight		/ cos (180 / gs_numOfSides)
		innplasterOffs	= thkPlasterAtBoardRight	/ cos (180 / gs_numOfSides)
	endif
endif

if iWindowShape = SHAPE_OCTAGONAL then
	normalRadius	= openingHeight / (2 * cos (22.5))
	revealRadius	= (openingHeight - 2 * rightJamb) / (2 * cos (22.5))
	innrevealRadius	= (openingHeight - 2 * CustRevealRightJamb) / (2 * cos (22.5))
	plasterOffs		= (2 * thkPlasterAtSillRight) / (2 * cos (22.5))
	innplasterOffs	= (2 * thkPlasterAtBoardRight) / (2 * cos (22.5))
endif

if iWindowShape = SHAPE_HALFCIRCLE then
	archHeight = openingWidth / 2
	arcR = archHeight
endif

if iWindowShape = SHAPE_ARCHED_T then
	if archHeight < EPS then
		iWindowShape = SHAPE_T		! Switch back to rectangular T shape
	else
		if archHeight > (openingWidth / 2 - EPS) then
			archHeight = openingWidth / 2
			arcR = archHeight
			bHalfCircle = 1
		else
			arcR = (openingWidth / 2) / sin(2 * atn(archHeight / (openingWidth / 2)))
			bHalfCircle = 0
		endif
	endif
endif

if iWindowShape = SHAPE_T then
	if gs_sidelight_parapet_hgt_left < EPS & gs_sidelight_parapet_hgt_right < EPS then iWindowShape = SHAPE_RECTANGULAR
	if gs_sidelight_parapet_hgt_left < EPS & gs_sidelight_parapet_hgt_right > EPS then iWindowShape = SHAPE_HALF_T_RIGHT
	if gs_sidelight_parapet_hgt_left > EPS & gs_sidelight_parapet_hgt_right < EPS then iWindowShape = SHAPE_HALF_T_LEFT
endif

if iWindowShape = SHAPE_ARCHED_T then
	if gs_sidelight_parapet_hgt_left < EPS & gs_sidelight_parapet_hgt_right < EPS then iWindowShape = SHAPE_ARCHED
	if gs_sidelight_parapet_hgt_left < EPS & gs_sidelight_parapet_hgt_right > EPS then iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT
	if gs_sidelight_parapet_hgt_left > EPS & gs_sidelight_parapet_hgt_right < EPS then iWindowShape = SHAPE_ARCHED_HALF_T_LEFT
endif

if iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then
	if archHeight < EPS then
		if iWindowShape = SHAPE_ARCHED_HALF_T_LEFT then
			iWindowShape = SHAPE_HALF_T_LEFT	! Switch back to rectangular half - T shape
		else
			iWindowShape = SHAPE_HALF_T_RIGHT	! Switch back to rectangular half - T shape
		endif
	else
		if archHeight > (openingWidth / 2 - EPS) then
			archHeight = openingWidth / 2
			arcR = archHeight
			bHalfCircle = 1
		else
			arcR = (openingWidth / 2) / sin(2 * atn(archHeight / (openingWidth / 2)))
			bHalfCircle = 0
		endif
	endif
endif

if iWindowShape = SHAPE_HORSESHOE then
	RadArch = ((ArchHeight - gs_lowerArchHeight)^2 +(openingWidth/2)^2) / openingWidth

	x1 = 0
	y1 = 0
	x2 = 0
	y2 = openingHeight + 1
	xo = openingWidth / 2 - RadArch
	yo = openingHeight - (ArchHeight - gs_lowerArchHeight)
	ro = RadArch - rightJamb - thkPlasterAtSillRight

	gosub 101	! Circle - Line intersection

	if ya > yb then
		SillHighArcoffs = ya
	else
		SillHighArcoffs = yb
	endif

	ro = RadArch
	gosub 101	! Circle - Line intersection

	if ya > yb then
		FrameHighArcoffs = ya
	else
		FrameHighArcoffs = yb
	endif

	ro = RadArch - CustRevealRightJamb - thkPlasterAtBoardRight
	gosub 101	! Circle - Line intersection

	if ya > yb then
		BoardHighArcoffs = ya
	else
		BoardHighArcoffs = yb
	endif


	x1 = -openingWidth / 2
	y1 = openingHeight - ArchHeight - rightJamb - thkPlasterAtSillRight
	x2 = openingWidth / 2
	y2 = openingHeight - ArchHeight - rightJamb - thkPlasterAtSillRight
	xo = openingWidth / 2 - RadArch
	yo = openingHeight - (ArchHeight - gs_lowerArchHeight)
	ro = RadArch - rightJamb - thkPlasterAtSillRight

	gosub 101	! Circle - Line intersection

	if state then
		SillLowArcoffsy = ya

		if xa < xb then
			SillLowArcoffsx = xb
		else
			SillLowArcoffsx = xa
		endif
	else
		SillLowArcoffsx = openingWidth / 2 - RadArch
		SillLowArcoffsy = openingHeight - ArchHeight - rightJamb - thkPlasterAtSillRight
	endif

	y1 = openingHeight - ArchHeight
	y2 = openingHeight - ArchHeight
	ro = RadArch

	gosub 101	! Circle - Line intersection

	FrameLowArcoffsy = ya

	if xa < xb then
		FrameLowArcoffsx = xb
	else
		FrameLowArcoffsx = xa
	endif


	y1 = openingHeight - ArchHeight - CustRevealRightJamb - thkPlasterAtBoardRight
	y2 = openingHeight - ArchHeight - CustRevealRightJamb - thkPlasterAtBoardRight
	ro = RadArch - CustRevealRightJamb - thkPlasterAtBoardRight

	gosub 101	! Circle - Line intersection

	if state then
		BoardLowArcoffsy = ya

		if xa < xb then
			BoardLowArcoffsx = xb
		else
			BoardLowArcoffsx = xa
		endif
	else
		BoardLowArcoffsx = openingWidth / 2 - RadArch
		BoardLowArcoffsy = openingHeight - ArchHeight - CustRevealRightJamb - thkPlasterAtBoardRight
	endif
endif

if iWindowShape = SHAPE_OGEECENTERED then
	gs_shoulder_height	= openingHeight - ArchHeight

	RadArc = ((ArchHeight / 2)^2 + (openingWidth / 4)^2) / (openingWidth / 2)

	x1 = 0
	y1 = 0
	x2 = 0
	y2 = openingHeight
	xo = RadArc
	yo = openingHeight
	ro = RadArc + rightJamb + thkPlasterAtSillRight

	if thkPlasterAtSillRight | rightJamb then

		gosub 101	! Circle - Line intersection

		if ya < yb then
			centSillArcoffs = ya
		else
			centSillArcoffs = yb
		endif
	else
		centSillArcoffs = openingHeight
	endif


	ro = RadArc + CustRevealRightJamb + thkPlasterAtBoardRight

	if thkPlasterAtBoardRight | CustRevealRightJamb then

		gosub 101	! Circle - Line intersection

		if ya < yb then
			centBoardArcoffs = ya
		else
			centBoardArcoffs = yb
		endif
	else
		centBoardArcoffs = openingHeight
	endif
endif

if iWindowShape = SHAPE_SARACENIC then
	gs_shoulder_height	= openingHeight - ArchHeight
	rOrigArc = (ArchHeight)*COS(30)

	radArch = (openingWidth / 2 * tan(30) - ArchHeight) / (tan(30) - cos(60) * tan(30) - sin(60))

	FrametangArcx 	= openingWidth / 2 - radArch + (radArch) * cos(60)
	FrametangArcy 	= openingHeight - ArchHeight + (radArch) * sin(60)

	SilltangArcx = openingWidth / 2 - radArch + (radArch - rightJamb - thkPlasterAtSillRight) * cos(60)
	SilltangArcy = openingHeight - ArchHeight + (radArch - rightJamb - thkPlasterAtSillRight) * sin(60)
	centSillArcoffs = openingHeight - (rightJamb + thkPlasterAtSillRight) / cos(30)

	BoardtangArcx = openingWidth / 2 - radArch + (radArch - CustRevealRightJamb - thkPlasterAtBoardRight) * cos(60)
	BoardtangArcy = openingHeight - ArchHeight + (radArch - CustRevealRightJamb - thkPlasterAtBoardRight) * sin(60)
	centBoardArcoffs = openingHeight - (CustRevealRightJamb + thkPlasterAtBoardRight) / cos(30)

endif


! ]=== Window Shape related definitions ===

pen WALL_VIEW_PEN
if nArchResolution > 3 then resol nArchResolution

if AC_HoleSideMaterial then
	if WIDO_REVEAL_SIDE then
		matRevealSide	= WALL_MAT_A
		matOppositeSide = WALL_MAT_B
	else
		matRevealSide	= WALL_MAT_B
		matOppositeSide = WALL_MAT_A
	endif
else
	matRevealSide	= WALL_MAT_EDGE
	matOppositeSide = WALL_MAT_EDGE
endif


leftDx	= 0
rightDx	= 0
if bSlantedInnerSide then
	if curvedWall then

			if gs_stack_left  then
			gs_reveal_left_angle  = alfaLeftOs
!			rightDx = WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
			endif
			if gs_stack_right then
			gs_reveal_right_angle  = alfaRightOs
!			leftDx = WIDO_FRAME_THICKNESS * tan(alfaRightOs)
		endif

		if not(wallIsLeft) then
			leftDx	= 0
			rightDx	= 0
		endif
	endif
endif


if iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC then
	offsetInsideDepth	= WIDO_FRAME_THICKNESS
	offsetInsideLeft	= revealInnerLeft
	offsetInsideRight	= revealInnerRight
	offsetInsideTop		= gs_reveal_splayed_innerTop
	offsetInsideBott	= gs_reveal_splayed_innerBottom
else
	offsetInsideDepth	= 0
	offsetInsideRight	= 0
	offsetInsideLeft	= 0
	offsetInsideTop		= 0
	offsetInsideBott	= 0
endif
if iRevealType = REVEAL_DOUBLE_SPLAYED then
	offsetInsideDepth	= WIDO_FRAME_THICKNESS
	offsetOutsideDepth	= 0
endif

bSillIsHorizontal	= ( iWindowShape = SHAPE_RECTANGULAR			| \
						iWindowShape = SHAPE_ARCHED					| \
						iWindowShape = SHAPE_HALFARCH				| \
						iWindowShape = SHAPE_ELLIPSEARCH			| \
						iWindowShape = SHAPE_EYEBROWS				| \
						iWindowShape = SHAPE_PENTAGON				| \
						iWindowShape = SHAPE_TRAPEZOID				| \
						iWindowShape = SHAPE_TRIANGLE				| \
						iWindowShape = SHAPE_CORNER_TRIANGLE		| \
						iWindowShape = SHAPE_PARALLELOGRAM			| \
						iWindowShape = SHAPE_GOTHICARCH				| \
						iWindowShape = SHAPE_HALFCIRCLE				| \
						iWindowShape = SHAPE_QUARTERROUND			| \
						iWindowShape = SHAPE_QUARTERROUND_NOFRAME )


! ==============================================================================
! Wallhole Hotspots
! ==============================================================================

gs_wallhole_width_half = 0
gs_reveal_width_half = 0

if WIDO_REVEAL_SIDE then
	addz WIDO_FRAME_THICKNESS
	mulz -1
endif

unID = 11100

! Board side offsets
dxBL = leftRevealPnts[idxBoardEndRevealLeft][1]
dxBR = rightRevealPnts[idxBoardEndRevealRight][1]

! Reveal side offsets
dxSL = leftRevealPnts[idxSillStartRevealLeft][1]
dxSR = rightRevealPnts[idxSillStartRevealRight][1]

! Slanted and Splayed reveal offsets - at the Top
if bSlantedInnerSide & not(gs_stack_top) then
	dyBLT =  ((leftRevealPnts[idxBoardEndRevealLeft][2]  - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_top_angle) - (iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_SPLAYED) * gs_reveal_splayed_InnerTop)	! Top Left
	dyBRT = ((rightRevealPnts[idxBoardEndRevealRight][2] - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_top_angle) - (iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_SPLAYED) * gs_reveal_splayed_InnerTop)	! Top Right
else
	dyBLT = 0
	dyBRT = 0
endif

! Slanted and Splayed reveal offsets - at the Bottom
if bSlantedInnerSide & not(gs_stack_bottom) & isWindow then
	dyBLB =  ((leftRevealPnts[idxBoardEndRevealLeft][2]  - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_bottom_angle) - (iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_SPLAYED) * gs_reveal_splayed_InnerBottom)	! Bottom Left
	dyBRB = ((rightRevealPnts[idxBoardEndRevealRight][2] - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_bottom_angle) - (iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_SPLAYED) * gs_reveal_splayed_InnerBottom)	! Bottom Right
else
	dyBLB = 0
	dyBRB = 0
endif

if	iWindowShape = SHAPE_RECTANGULAR			| \
	iWindowShape = SHAPE_ARCHED					| \
	iWindowShape = SHAPE_ELLIPSEARCH			| \
	iWindowShape = SHAPE_EYEBROWS				| \
	iWindowShape = SHAPE_HALFCIRCLE				| \
	iWindowShape = SHAPE_HALFARCH				| \
	iWindowShape = SHAPE_PENTAGON				| \
	iWindowShape = SHAPE_QUARTERROUND			| \
	iWindowShape = SHAPE_QUARTERROUND_NOFRAME	| \
	iWindowShape = SHAPE_TRIANGLE				| \
	iWindowShape = SHAPE_GOTHICARCH				| \
	iWindowShape = SHAPE_CORNER_TRIANGLE		| \
	iWindowShape = SHAPE_TRAPEZOID then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0,-dyBLB,						0, unID
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0,-dyBRB,						0, unID
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | ((iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) & gs_mountingFrame) then
		if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
			hptsYL = -elevationOffset - (bSlantedOuterSide & not(gs_stack_bottom)) * ( -leftRevealPnts[idxSillStartRevealLeft][2]  - gs_mountingFrame_depth) * tan(gs_reveal_outerBottom_angle)
			hptsYR = -elevationOffset - (bSlantedOuterSide & not(gs_stack_bottom)) * (-rightRevealPnts[idxSillStartRevealRight][2] - gs_mountingFrame_depth) * tan(gs_reveal_outerBottom_angle)
		else
			hptsYL = -elevationOffset + gs_reveal_bottom + original_gs_reveal_bottom * not(bShowRevealSE)
			hptsYR = hptsYL
		endif

		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,hptsYL,	0, unID
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0,hptsYR,	0, unID
		del 1
		unID = unID + 2
	else
		if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
			hptsYL = -(bSlantedOuterSide & not(gs_stack_bottom)) * ( -leftRevealPnts[idxSillStartRevealLeft][2]  - gs_mountingFrame * gs_mountingFrame_depth) * tan(gs_reveal_outerBottom_angle) + gs_reveal_bottom * not(gs_stack_bottom)
			hptsYR = -(bSlantedOuterSide & not(gs_stack_bottom)) * (-rightRevealPnts[idxSillStartRevealRight][2] - gs_mountingFrame * gs_mountingFrame_depth) * tan(gs_reveal_outerBottom_angle) + gs_reveal_bottom * not(gs_stack_bottom)
		else
			hptsYL = -elevationOffset + gs_reveal_bottom * not(gs_stack_bottom)
			hptsYR = -elevationOffset + gs_reveal_bottom * not(gs_stack_bottom)
		endif

		if iWindowShape = SHAPE_TRIANGLE then
			_oleft = -(leftJamb + thkPlasterAtSillLeft) / sin(atn(tan_LeftSide))
			add -ac_wallhole_width / 2 - _oleft,			 0, leftRevealPnts[idxSillStartRevealLeft][2]
		else
			add leftRevealPnts[idxSillStartRevealLeft][1],	 0, leftRevealPnts[idxSillStartRevealLeft][2]
		endif
		hotspot 0,hptsYL,	0, unID
		del 1
		unID = unID + 2

		if iWindowShape = SHAPE_TRIANGLE then
			_oright = -(rightJamb + thkPlasterAtSillRight) / sin(atn(tan_RightSide))
			add ac_wallhole_width / 2 + _oright,			 0, rightRevealPnts[idxSillStartRevealRight][2]
		else
			add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		endif
		hotspot 0,hptsYR,	0, unID
		del 1
		unID = unID + 2

		if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
			hptsYL = gs_reveal_bottom * not(gs_stack_bottom)
			hptsYR = gs_reveal_bottom * not(gs_stack_bottom)
		else
			hptsYL = -elevationOffset + gs_reveal_bottom * not(gs_stack_bottom)
			hptsYR = -elevationOffset + gs_reveal_bottom * not(gs_stack_bottom)
		endif

		add leftRevealPnts[idxSillEndRevealLeft][1], 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,hptsYL,	0, unID
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0,hptsYR,	0, unID
		del 1
		unID = unID + 2

		if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
			hptsYL = 0
			hptsYR = 0
		else
			hptsYL = -elevationOffset
			hptsYR = -elevationOffset
		endif

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0,hptsYL,	0, unID
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0,hptsYR,	0, unID
		del 1
		unID = unID + 2
	endif
endif

if	iWindowShape = SHAPE_ARCHED_T				| \
	iWindowShape = SHAPE_T						| \
	iWindowShape = SHAPE_ARCHED_HALF_T_LEFT		| \
	iWindowShape = SHAPE_HALF_T_LEFT			| \
	iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT	| \
	iWindowShape = SHAPE_HALF_T_RIGHT then

	gs_sidelight_WHole_width_left 	= gs_sidelight_WHole_width_left * (iWindowShape = SHAPE_ARCHED_T | iWindowShape = SHAPE_T | iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | iWindowShape = SHAPE_HALF_T_LEFT)
	gs_sidelight_parapet_hgt_left 	= gs_sidelight_parapet_hgt_left * (iWindowShape = SHAPE_ARCHED_T | iWindowShape = SHAPE_T | iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | iWindowShape = SHAPE_HALF_T_LEFT)
	gs_sidelight_WHole_width_right 	= gs_sidelight_WHole_width_right * (iWindowShape = SHAPE_ARCHED_T | iWindowShape = SHAPE_T | iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT | iWindowShape = SHAPE_HALF_T_RIGHT)
	gs_sidelight_parapet_hgt_right 	= gs_sidelight_parapet_hgt_right * (iWindowShape = SHAPE_ARCHED_T | iWindowShape = SHAPE_T | iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT | iWindowShape = SHAPE_HALF_T_RIGHT)

	revealDiffLeft	= (gs_reveal_double_innerLeft_sL  - gs_reveal_double_innerLeft)
	revealDiffRight	= (gs_reveal_double_innerRight_sR - gs_reveal_double_innerRight)

! Board Side Hotspots ----------------------------------------------------------

	if	iWindowShape = SHAPE_ARCHED_T				| \
		iWindowShape = SHAPE_T						| \
		iWindowShape = SHAPE_ARCHED_HALF_T_LEFT		| \
		iWindowShape = SHAPE_HALF_T_LEFT then

		hptsYM = -dyBLB + (isWindow | gs_reveal_double_innerBottom > EPS) * gs_reveal_double_innerBottom
		hptsYL = -dyBLB + gs_sidelight_parapet_hgt_left  + gs_reveal_double_innerBottom_sL

		px = -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_double_innerLeft_sL
		if curvedWall then
			pz = WOD - signWallIsLeft * sqr(radBoard^2 - px^2)
		else
			pz = leftRevealPnts[idxBoardEndRevealLeft][2] + incX * px
		endif
		hotspot px, hptsYM, pz, unID
		unID = unID + 2
		if gs_sidelight_WHole_width_left > EPS & gs_sidelight_parapet_hgt_left > EPS then
			hotspot px, hptsYL, pz, unID
			unID = unID + 2
			hotspot leftRevealPnts[idxBoardEndRevealLeft][1], hptsYL, leftRevealPnts[idxBoardEndRevealLeft][2], unID
			unID = unID + 2
		else
			unID = unID + 4
		endif
	else
		unID = unID + 6
	endif

	if	iWindowShape = SHAPE_ARCHED_T				| \
		iWindowShape = SHAPE_T						| \
		iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT	| \
		iWindowShape = SHAPE_HALF_T_RIGHT then

		hptsYM = -dyBRB + (isWindow | gs_reveal_double_innerBottom > EPS) * gs_reveal_double_innerBottom
		hptsYR = -dyBRB + gs_sidelight_parapet_hgt_right + gs_reveal_double_innerBottom_sR

		px = rightWidth - gs_sidelight_WHole_width_right - gs_reveal_double_innerRight_sR
		if curvedWall then
			pz = WOD - signWallIsLeft * sqr(radBoard^2 - px^2)
		else
			pz = leftRevealPnts[idxBoardEndRevealRight][2] + incX * px
		endif
		hotspot px, hptsYM, pz, unID
		unID = unID + 2
		if gs_sidelight_WHole_width_right > EPS & gs_sidelight_parapet_hgt_right > EPS then
			hotspot px, hptsYR, pz, unID
			unID = unID + 2
			hotspot rightRevealPnts[idxBoardEndRevealRight][1], hptsYR, rightRevealPnts[idxBoardEndRevealRight][2], unID
			unID = unID + 2
		else
			unID = unID + 4
		endif
	else
		unID = unID + 6
	endif

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		hptsYM = -elevationOffset
		hptsYL = -elevationOffset
		hptsYR = -elevationOffset

		if	iWindowShape = SHAPE_ARCHED_T				| \
			iWindowShape = SHAPE_T						| \
			iWindowShape = SHAPE_ARCHED_HALF_T_LEFT		| \
			iWindowShape = SHAPE_HALF_T_LEFT then

			px = -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_double_innerLeft_sL
			if curvedWall then
				pz = WOD - signWallIsLeft * sqr(radSill^2 - px^2)
			else
				pz = leftRevealPnts[idxSillStartRevealLeft][2] + incX * px
			endif
			hotspot px, hptsYM, pz, unID
			unID = unID + 2
			if gs_sidelight_WHole_width_left > EPS & gs_sidelight_parapet_hgt_left > EPS then
				hotspot px, hptsYL + gs_sidelight_parapet_hgt_left, pz, unID
				unID = unID + 2
				hotspot leftRevealPnts[idxSillStartRevealLeft][1], hptsYL + gs_sidelight_parapet_hgt_left, leftRevealPnts[idxSillStartRevealLeft][2], unID
				unID = unID + 2
			else
				unID = unID + 4
			endif
		else
			unID = unID + 6
		endif

		if	iWindowShape = SHAPE_ARCHED_T				| \
			iWindowShape = SHAPE_T						| \
			iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT	| \
			iWindowShape = SHAPE_HALF_T_RIGHT then

			px = rightWidth - gs_sidelight_WHole_width_right - gs_reveal_double_innerRight_sR
			if curvedWall then
				pz = WOD - signWallIsLeft * sqr(radSill^2 - px^2)
			else
				pz = leftRevealPnts[idxSillStartRevealRight][2] + incX * px
			endif
			hotspot px, hptsYM, pz, unID
			unID = unID + 2
			if gs_sidelight_WHole_width_right > EPS & gs_sidelight_parapet_hgt_right > EPS then
				hotspot px, hptsYR + gs_sidelight_parapet_hgt_right, pz, unID
				unID = unID + 2
				hotspot rightRevealPnts[idxSillStartRevealRight][1], hptsYR + gs_sidelight_parapet_hgt_right, rightRevealPnts[idxSillStartRevealRight][2], unID
				unID = unID + 2
			else
				unID = unID + 4
			endif
		else
			unID = unID + 6
		endif
	else
		bNegativeReveal = (iRevealType = REVEAL_NEGATIVE | (iRevealType = REVEAL_DOUBLE & iSillRevealType = REVEAL_NEGATIVE))

		hptsYM = -elevationOffset + (isWindow | gs_reveal_bottom > EPS) * gs_reveal_bottom
		hptsYL = -elevationOffset + gs_reveal_bottom_sL
		hptsYR = -elevationOffset + gs_reveal_bottom_sL

		revealDiffLeft	= (gs_reveal_left_sL  - gs_reveal_left)
		revealDiffRight	= (gs_reveal_right_sR - gs_reveal_right)

		px = -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_left_sL
		if curvedWall then
			pz = WOD - signWallIsLeft * sqr(radSill^2 - px^2)
		else
			pz = leftRevealPnts[idxSillStartRevealLeft][2] + incX * px
		endif
		hotspot px, hptsYM, pz, unID
		unID = unID + 2
		if gs_sidelight_WHole_width_left > EPS & gs_sidelight_parapet_hgt_left > EPS then
			hotspot px, hptsYL + gs_sidelight_parapet_hgt_left, pz, unID
			unID = unID + 2
			hotspot leftRevealPnts[idxSillStartRevealLeft][1], hptsYL + gs_sidelight_parapet_hgt_left, leftRevealPnts[idxSillStartRevealLeft][2], 	unID
			unID = unID + 2
		else
			unID = unID + 4
		endif

		hptsYL = -elevationOffset + gs_reveal_bottom_sR
		hptsYR = -elevationOffset + gs_reveal_bottom_sR

		px = rightWidth - gs_sidelight_WHole_width_right - gs_reveal_right_sR
		if curvedWall then
			pz = WOD - signWallIsLeft * sqr(radSill^2 - px^2)
		else
			pz = leftRevealPnts[idxSillStartRevealRight][2] + incX * px
		endif
		hotspot px, hptsYM, pz, unID
		unID = unID + 2
		if gs_sidelight_WHole_width_right > EPS & gs_sidelight_parapet_hgt_right > EPS then
			hotspot px, hptsYR + gs_sidelight_parapet_hgt_right, pz, unID
			unID = unID + 2
			hotspot rightRevealPnts[idxSillStartRevealRight][1], hptsYR + gs_sidelight_parapet_hgt_right, rightRevealPnts[idxSillStartRevealRight][2], unID
			unID = unID + 2
		else
			unID = unID + 4
		endif

		hptsYL = -elevationOffset + gs_reveal_bottom_sL
		hptsYR = -elevationOffset + gs_reveal_bottom_sL

		add leftRevealPnts[idxSillEndRevealLeft][1], 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot gs_sidelight_WHole_width_left + not(bNegativeReveal) * revealDiffLeft, hptsYM, 0, 	unID
		unID = unID + 2
		if gs_sidelight_WHole_width_left > EPS & gs_sidelight_parapet_hgt_left > EPS then
			hotspot gs_sidelight_WHole_width_left + not(bNegativeReveal) * revealDiffLeft,	hptsYL + gs_sidelight_parapet_hgt_left - bNegativeReveal * gs_reveal_bottom_sL,	0, 	unID
			unID = unID + 2
			hotspot 0, hptsYL + gs_sidelight_parapet_hgt_left - bNegativeReveal * gs_reveal_bottom_sL,	0, 	unID
			unID = unID + 2
		else
			unID = unID + 4
		endif
		del 1

		hptsYL = -elevationOffset + gs_reveal_bottom_sR
		hptsYR = -elevationOffset + gs_reveal_bottom_sR

		add rightRevealPnts[idxSillEndRevealRight][1], 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot -gs_sidelight_WHole_width_right - not(bNegativeReveal) * revealDiffRight, hptsYM,										0, unID
		unID = unID + 2
		if gs_sidelight_WHole_width_right > EPS & gs_sidelight_parapet_hgt_right > EPS then
			hotspot -gs_sidelight_WHole_width_right - not(bNegativeReveal) * revealDiffRight, hptsYR + gs_sidelight_parapet_hgt_right - bNegativeReveal * gs_reveal_bottom_sR,	0, unID
			unID = unID + 2
			hotspot 0, hptsYR + gs_sidelight_parapet_hgt_right - bNegativeReveal * gs_reveal_bottom_sR,	0, unID
			unID = unID + 2
		else
			unID = unID + 4
		endif
		del 1

		hptsYL = -elevationOffset
		hptsYR = -elevationOffset

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot gs_sidelight_WHole_width_left, 	hptsYL,									0, 	unID
		unID = unID + 2
		if gs_sidelight_WHole_width_left > EPS & gs_sidelight_parapet_hgt_left > EPS then
			hotspot gs_sidelight_WHole_width_left,	hptsYL + gs_sidelight_parapet_hgt_left,	0, 	unID
			unID = unID + 2
			hotspot 0,								hptsYL + gs_sidelight_parapet_hgt_left,	0, 	unID
			unID = unID + 2
		else
			unID = unID + 4
		endif
		del 1

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot -gs_sidelight_WHole_width_right, hptsYR,										0, unID
		unID = unID + 2
		if gs_sidelight_WHole_width_right > EPS & gs_sidelight_parapet_hgt_right > EPS then
			hotspot -gs_sidelight_WHole_width_right,	hptsYR + gs_sidelight_parapet_hgt_right,	0, unID
			unID = unID + 2
			hotspot 0, 									hptsYR + gs_sidelight_parapet_hgt_right,	0, unID
			unID = unID + 2
		else
			unID = unID + 4
		endif
		del 1

	endif
endif

if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_T | iWindowShape = SHAPE_HALF_T_LEFT | iWindowShape = SHAPE_HALF_T_RIGHT then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, B + dyBLT - gs_reveal_double_innerTop * (iRevealType = REVEAL_DOUBLE) - overSizeLower + overSizeUpper,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, B + dyBRT - gs_reveal_double_innerTop * (iRevealType = REVEAL_DOUBLE) - overSizeLower + overSizeUpper,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | ((iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) & gs_mountingFrame) then
		if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
			hptsYL = B + overSizeUpper + (bSlantedOuterSide & not(gs_stack_top)) * ( -leftRevealPnts[idxSillStartRevealLeft][2]  - gs_reveal_outer_jamb_depth) * tan(gs_reveal_outerTop_angle)
			hptsYR = B + overSizeUpper + (bSlantedOuterSide & not(gs_stack_top)) * (-rightRevealPnts[idxSillStartRevealRight][2] - gs_reveal_outer_jamb_depth) * tan(gs_reveal_outerTop_angle)
		else
			hptsYL = gs_reveal_bottom + ac_reveal_height + overSizeLowerOriginal - elevationOffset + original_gs_reveal_bottom * not(bShowRevealSE)
			hptsYR = hptsYL
		endif

		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,hptsYL,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0,hptsYR,	0, unID+1
		del 1
		unID = unID + 2

![#COMPATIBILITY] - START
!		unID = unID + 8
![#COMPATIBILITY] - END
	else
		if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
			hptsY = B + overSizeUpper - gs_reveal_top
		else
			hptsY = gs_reveal_bottom + ac_reveal_height + overSizeLowerOriginal - elevationOffset
		endif

		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,hptsY,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0,hptsY,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillEndRevealLeft][1], 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,hptsY,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0,hptsY,	0, unID+1
		del 1
		unID = unID + 2

		if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
			hptsY = B + overSizeUpper
		else
			if ac_wallhole_height_original > EPS then
				hptsY = ac_wallhole_height_original + overSizeLowerOriginal - elevationOffset
			else
				hptsY = ac_wallhole_height + overSizeLowerOriginal - elevationOffset
			endif
		endif

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0,hptsY,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0,hptsY,	0, unID+1
		del 1
		unID = unID + 2
	endif
endif

if iWindowShape = SHAPE_ARCHED | iWindowShape = SHAPE_ARCHED_T | iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, openingHeight - archHeight + dyBLT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight - archHeight + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2
	else

		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2


		add leftRevealPnts[idxSillEndRevealLeft][1], 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2
	endif

	add 0, gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
	hotspot 0,ac_reveal_height + overSizeLowerOriginal - elevationOffset,	0, unID+1
	del 1
	unID = unID + 2

	add 0, gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
	hotspot 0,ac_reveal_height + overSizeLowerOriginal - elevationOffset,	0, unID+1
	del 1
	unID = unID + 2

	if bShowAddHotspotsForIS then

		add 0, gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2

		add 0, gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2
	endif

endif

if iWindowShape = SHAPE_EYEBROWS | iWindowShape = SHAPE_ELLIPSEARCH then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, openingHeight - archHeight + dyBLT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight - archHeight + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

![#COMPATIBILITY] - START
!		unID = unID + 8
![#COMPATIBILITY] - END
	else
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillEndRevealLeft][1], 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2
	endif

	add 0, 0, leftRevealPnts[idxSillStartRevealLeft][2]
	hotspot 0,ac_reveal_height + overSizeLowerOriginal - elevationOffset,	0, unID+1
	del 1
	unID = unID + 2

	add 0, 0, leftRevealPnts[idxSillEndRevealLeft][2]
	hotspot 0,ac_reveal_height + overSizeLowerOriginal - elevationOffset,	0, unID+1
	del 1
	unID = unID + 2

	if bShowAddHotspotsForIS then

		add 0, 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2
	else
![#COMPATIBILITY] - START
!		unID = unID + 4
![#COMPATIBILITY] - END
	endif

endif

if iWindowShape = SHAPE_TRIANGLE then
	_oleft = -leftJamb / sin(atn(tan_LeftSide))
	_oright = -rightJamb / sin(atn(tan_RightSide))
	_xTop = (ac_wallhole_width + _oleft + _oright) / (tan_LeftSide / tan_RightSide + 1)
	_yTop = _xTop * tan_LeftSide
	addx -ac_wallhole_width / 2 - _oleft + _xTop

	add 0, 0, leftRevealPnts[idxSillStartRevealLeft][2]
	hotspot 0, _yTop,	0, unID+1
	del 1
	unID = unID + 2

	add 0, 0, leftRevealPnts[idxSillEndRevealLeft][2]
	hotspot 0, _yTop,	0, unID+1
	del 1
	unID = unID + 2

	if bShowAddHotspotsForIS then

		add 0, 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2
	endif

	del 1
endif

if iWindowShape = SHAPE_HALFCIRCLE then

	add 0, 0, leftRevealPnts[idxSillStartRevealLeft][2]
	hotspot 0, ac_reveal_height + overSizeLowerOriginal - elevationOffset,	0, unID+1
	del 1
	unID = unID + 2

	add 0, 0, leftRevealPnts[idxSillEndRevealLeft][2]
	hotspot 0, ac_reveal_height + overSizeLowerOriginal - elevationOffset,	0, unID+1
	del 1
	unID = unID + 2

	if bShowAddHotspotsForIS then

		add 0, 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2
	endif

endif

if iWindowShape = SHAPE_HALFARCH then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, openingHeight - archHeight + CustRevealRightJamb + dyBLT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight + CustRevealRightJamb + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight,	0, unID+1
		del 1
		unID = unID + 2

		unID = unID + 8
	else
		add leftRevealPnts[idxSillStartRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, SillShouldy - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, SillTopy - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillEndRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, SillShouldy - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, SillTopy - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight,	0, unID+1
		del 1
		unID = unID + 2
	endif

endif

if iWindowShape = SHAPE_PENTAGON then

! Board Side Hotspots ----------------------------------------------------------

	_hCenter = B + overSizeUpper - (CustRevealTopJamb + thkPlasterAtBoardTop) / cos(atn(tan_topAngle))

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, _hCenter + leftRevealPnts[idxBoardEndRevealLeft][1] * tan_topAngle,	0, unID+1

	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, _hCenter - rightRevealPnts[idxBoardEndRevealRight][1] * tan_topAngle,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	_hCenter = B + overSizeUpper - (upperJamb + thkPlasterAtSillTop) / cos(atn(tan_topAngle))

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, _hCenter + leftRevealPnts[idxSillStartRevealLeft][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, _hCenter - rightRevealPnts[idxSillStartRevealRight][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, _hCenter,	0, unID+1
		del 1
		unID = unID + 2

	else
		add leftRevealPnts[idxSillStartRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, _hCenter + leftRevealPnts[idxSillStartRevealLeft][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, _hCenter - rightRevealPnts[idxSillStartRevealRight][1] * tan_topAngle, 0, unID+1
		del 1
		unID = unID + 2

		add 0, gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, _hCenter, 0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillEndRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, _hCenter + leftRevealPnts[idxSillEndRevealLeft][1] * tan_topAngle, 0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, _hCenter - rightRevealPnts[idxSillEndRevealRight][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add 0, gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, _hCenter, 0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight,	0, unID+1
		del 1
		unID = unID + 2
	endif

	add 0, 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight + CustRevealRightJamb + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

	if bShowAddHotspotsForIS then

		add 0, gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2

		add 0, gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2
	endif

endif

if iWindowShape = SHAPE_HALFROUND then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, openingHeight/2 + CustRevealRightJamb + dyBLT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight/2 + CustRevealRightJamb + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight + CustRevealRightJamb + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, CustRevealRightJamb + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight/2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight/2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, 0,	0, unID+1
		del 1
		unID = unID + 2

		unID = unID + 16
	else
		add leftRevealPnts[idxSillStartRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight/2 - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight/2 - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - sillArcoffs - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, sillArcoffs - lowerJamb, 0, unID+1
		del 1
		unID = unID + 2


		add leftRevealPnts[idxSillEndRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, openingHeight/2 - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight/2 - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight - sillArcoffs - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, sillArcoffs - lowerJamb, 0, unID+1
		del 1
		unID = unID + 2


		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, openingHeight/2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight/2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, 0,	0, unID+1
		del 1
		unID = unID + 2
	endif

endif

if iWindowShape = SHAPE_TRAPEZOID then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, B + dyBLT + not(bMirroredOpening) * (-archHeight + CustRevealRightJamb),	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, B + dyBRT + bMirroredOpening * (-archHeight + CustRevealRightJamb),	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	_hCenter = B + overSizeUpper - overSizeLower - archHeight / 2 - (upperJamb + thkPlasterAtSillTop) / cos(atn(tan_topAngle))
	_dirWin = not(bMirroredOpening) * 2 - 1		!mirrored: -1  nonmirrored: 1

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight - not(bMirroredOpening) * archHeight_reveal,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, _hCenter + _dirWin * rightRevealPnts[idxSillStartRevealRight][1] * tan_topAngle, 0, unID+1
		del 1
		unID = unID + 2
	else

		add leftRevealPnts[idxSillStartRevealLeft][1], overSizeLower, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, _hCenter + _dirWin * leftRevealPnts[idxSillStartRevealLeft][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], overSizeLower, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, _hCenter + _dirWin * rightRevealPnts[idxSillStartRevealRight][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillEndRevealLeft][1], overSizeLower , leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, _hCenter + _dirWin * leftRevealPnts[idxSillEndRevealLeft][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], overSizeLower , rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, _hCenter + _dirWin * rightRevealPnts[idxSillEndRevealRight][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		_hCenter = B + overSizeUpper - overSizeLower - archHeight / 2 - thkPlasterAtSillTop / cos(atn(tan_topAngle))

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, _hCenter + _dirWin * leftRevealPnts[idxFrameStartRevealLeft][1] * tan_topAngle,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight - bMirroredOpening * archHeight,	0, unID+1
		del 1
		unID = unID + 2
	endif
endif

if iWindowShape = SHAPE_GOTHICARCH then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, openingHeight - archHeight + CustRevealRightJamb + dyBLT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight - archHeight + CustRevealRightJamb + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

	add 0, 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight + CustRevealRightJamb + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight,	0, unID+1
		del 1
		unID = unID + 2

		unID = unID + 12
	else
		add leftRevealPnts[idxSillStartRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight- archHeight - lowerJamb ,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - archHeight - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add 0, gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - centSillArcoffs - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillEndRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, openingHeight - archHeight - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight - archHeight - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add 0, gs_reveal_bottom, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight - centSillArcoffs - lowerJamb,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight - archHeight,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight,	0, unID+1
		del 1
		unID = unID + 2
	endif

	if bShowAddHotspotsForIS then

		add 0, gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2

		add 0, gs_reveal_bottom, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0,overSizeLowerOriginal - elevationOffset,						0, unID+1
		del 1
		unID = unID + 2
	else
		unID = unID + 4
	endif

endif

if iWindowShape = SHAPE_ROMBUS then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, openingHeight / 2,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight / 2,	0, unID+1
	del 1
	unID = unID + 2

	add 0, 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, - overSizeLower + CustRevealBottJamb,	0, unID+1
	del 1
	unID = unID + 2

	add 0, 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, openingHeight + oversizeUpper + CustRevealTopJamb,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, - overSizeLower,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight + oversizeUpper,	0, unID+1
		del 1
		unID = unID + 2

![#COMPATIBILITY] - START
!		unID = unID + 16
![#COMPATIBILITY] - END
	else
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, lowerJamb - overSizeLower,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, openingHeight - upperJamb + oversizeUpper,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillEndRevealLeft][1], 0, leftRevealPnts[idxSillEndRevealLeft][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillEndRevealRight][1], 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, lowerJamb - overSizeLower,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxSillEndRevealRight][2]
		hotspot 0, openingHeight - upperJamb + oversizeUpper,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxFrameStartRevealLeft][1], 0, leftRevealPnts[idxFrameStartRevealLeft][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxFrameStartRevealRight][1], 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight / 2,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, - overSizeLower,	0, unID+1
		del 1
		unID = unID + 2

		add 0, 0, rightRevealPnts[idxFrameStartRevealRight][2]
		hotspot 0, openingHeight + oversizeUpper,	0, unID+1
		del 1
		unID = unID + 2
	endif
endif

if iWindowShape = SHAPE_PARALLELOGRAM then

! Board Side Hotspots ----------------------------------------------------------

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, archHeight - dyBLB,	0, unID
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, - dyBRB, 	0, unID
	del 1
	unID = unID + 2

	add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
	hotspot 0, B + dyBLT,	0, unID+1
	del 1
	unID = unID + 2

	add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
	hotspot 0, B - archHeight + dyBRT,	0, unID+1
	del 1
	unID = unID + 2

! Sill Side Hotspots -----------------------------------------------------------

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, archHeight_reveal - elevationOffset,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, - elevationOffset,	0, unID+1
		del 1
		unID = unID + 2

		add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
		hotspot 0, B - elevationOffset,	0, unID+1
		del 1
		unID = unID + 2

		add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
		hotspot 0, B - archHeight_reveal - elevationOffset,	0, unID+1
		del 1
		unID = unID + 2
	else
![#COMPATIBILITY] - START
!		unID = unID + 8
![#COMPATIBILITY] - END
	endif
endif

if iWindowShape = SHAPE_OCTAGONAL then
	addy openingHeight/2
	mulx openingWidth / openingHeight

	alpha_rotation = 22.5

	! Reveal Hotspots --------------------------------------------------------------
	for i = 1 to 8
		gosub 3000

		alpha_rotation = alpha_rotation + 45
	next i


	! Wallhole Hotspots ------------------------------------------------------------
	unID=11000

	for i = 1 to 8
		gosub 4000

		alpha_rotation = alpha_rotation + 45
	next i

	del 2
endif

if iWindowShape = SHAPE_MULTISIDE then
	addy normalRadius * cos (180 / gs_numOfSides)

	! Reveal Hotspots --------------------------------------------------------------
	alpha_rotation = 0
	if (gs_numOfSides mod 2) = 0 then
		alpha_rotation = 180 / gs_numOfSides
	endif

	unID = unID + 1

	for i = 1 to gs_numOfSides

		if (gs_numOfSides mod 2) <> 0 then

			if	i = 1 then
				gosub 3000
			endif
			if	i = int(gs_numOfSides / 2) + 1 or\
				i = int(gs_numOfSides / 2) + 2 then
				gosub 3000
			endif
			if i = int(gs_numOfSides / 2) + 1 then
				if bShowAddHotspotsForIS then
					gosub 3000
				endif
			endif

			if ((gs_numOfSides + 1) mod 4) <> 0 then
				if	i = (gs_numOfSides + 3) / 4 or\
					i = (gs_numOfSides + 3) / 4 + ((gs_numOfSides + 1) / 2) then
					gosub 3000
				endif
			else
				if	i = (gs_numOfSides + 5) / 4 or\
					i = (gs_numOfSides + 5) / 4 + ((gs_numOfSides - 1) / 2) then
					gosub 3000
				endif
			endif

		else

			if	i = 1 or\
				i = gs_numOfSides or\
				i = gs_numOfSides / 2 or\
				i = gs_numOfSides / 2 + 1 then
				gosub 3000
			endif

			if (gs_numOfSides mod 4) <> 0 then
				if	i = (gs_numOfSides + 2) / 4 or\
					i = (gs_numOfSides + 2) / 4 + gs_numOfSides / 2 then
					gosub 3000
				endif
			else
				if	i = gs_numOfSides / 4 or\
					i = gs_numOfSides / 4 + 1 or\
					i = gs_numOfSides / 4 + gs_numOfSides / 2 or\
					i = gs_numOfSides / 4 + gs_numOfSides / 2 + 1 then
					gosub 3000
				endif
			endif

		endif

		alpha_rotation = alpha_rotation + 360 / gs_numOfSides
	next i


	! Wallhole Hotspots ------------------------------------------------------------
	unID = 11000

	alpha_rotation = 0
	if (gs_numOfSides mod 2) = 0 then
		alpha_rotation = 180 / gs_numOfSides
	endif

	for i = 1 to gs_numOfSides

		if (gs_numOfSides mod 2) <> 0 then

			if	i = 1 then
				gosub 4000
			endif
			if	i = int(gs_numOfSides / 2) + 1 or\
				i = int(gs_numOfSides / 2) + 2 then
				gosub 4000
			endif
			if i = int(gs_numOfSides / 2) + 1 then
				if bShowAddHotspotsForIS then
					gosub 4000
				endif
			endif

			if ((gs_numOfSides + 1) mod 4) <> 0 then
				if	i = (gs_numOfSides + 3) / 4 or\
					i = (gs_numOfSides + 3) / 4 + ((gs_numOfSides + 1) / 2) then
					gosub 4000
				endif
			else
				if	i = (gs_numOfSides + 5) / 4 or\
					i = (gs_numOfSides + 5) / 4 + ((gs_numOfSides - 1) / 2) then
					gosub 4000
				endif
			endif

		else

			if	i = 1 or\
				i = gs_numOfSides or\
				i = gs_numOfSides / 2 or\
				i = gs_numOfSides / 2 + 1 then
				gosub 4000
			endif

			if (gs_numOfSides mod 4) <> 0 then
				if	i = (gs_numOfSides + 2) / 4 or\
					i = (gs_numOfSides + 2) / 4 + gs_numOfSides / 2 then
					gosub 4000
				endif
			else
				if	i = gs_numOfSides / 4 or\
					i = gs_numOfSides / 4 + 1 or\
					i = gs_numOfSides / 4 + gs_numOfSides / 2 or\
					i = gs_numOfSides / 4 + gs_numOfSides / 2 + 1 then
					gosub 4000
				endif
			endif

		endif

		alpha_rotation = alpha_rotation + 360 / gs_numOfSides
	next i

	del 1
endif

if iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then

	addy openingHeight / 2
	muly openingHeight / openingWidth

	! Reveal Hotspots --------------------------------------------------------------
	if iRevealType > REVEAL_NO then
		hotspot 0,  openingWidth/2 - rightJamb, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 1
		hotspot 0, -openingWidth/2 + rightJamb, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 2
		hotspot  openingWidth/2 - rightJamb, 0, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 3
		hotspot -openingWidth/2 + rightJamb, 0, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 4
		unID = unID + 4

		hotspot 0,  openingWidth/2 - rightJamb, leftRevealPnts[idxSillEndRevealLeft][2],	unID + 1
		hotspot 0, -openingWidth/2 + rightJamb, leftRevealPnts[idxSillEndRevealLeft][2],	unID + 2
		hotspot  openingWidth/2 - rightJamb, 0, leftRevealPnts[idxSillEndRevealLeft][2],	unID + 3
		hotspot -openingWidth/2 + rightJamb, 0, leftRevealPnts[idxSillEndRevealLeft][2],	unID + 4
		unID = unID + 4
	endif


	! Wallhole Hotspots ------------------------------------------------------------
	unID=11000

	! Board Side Hotspots ----------------------------------------------------------
	hotspot 0,  openingWidth/2, leftRevealPnts[idxBoardEndRevealLeft][2],	unID + 1
	hotspot 0, -openingWidth/2, leftRevealPnts[idxBoardEndRevealLeft][2],	unID + 2
	hotspot  openingWidth/2, 0, leftRevealPnts[idxBoardEndRevealLeft][2],	unID + 3
	hotspot -openingWidth/2, 0, leftRevealPnts[idxBoardEndRevealLeft][2],	unID + 4
	unID = unID + 4

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		hotspot 0,  openingWidth/2, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 1
		hotspot 0, -openingWidth/2, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 2
		hotspot  openingWidth/2, 0, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 3
		hotspot -openingWidth/2, 0, leftRevealPnts[idxSillStartRevealLeft][2],	unID + 4
		unID = unID + 4
	else
		hotspot 0,  openingWidth/2, leftRevealPnts[idxFrameStartRevealLeft][2],	unID + 1
		hotspot 0, -openingWidth/2, leftRevealPnts[idxFrameStartRevealLeft][2],	unID + 2
		hotspot  openingWidth/2, 0, leftRevealPnts[idxFrameStartRevealLeft][2],	unID + 3
		hotspot -openingWidth/2, 0, leftRevealPnts[idxFrameStartRevealLeft][2],	unID + 4
		unID = unID + 4
	endif

	del 2
endif


if bSillIsHorizontal & \
	( iRevealType = REVEAL_SLANTED	| \
	  iRevealType = REVEAL_SPLAYED	| \
	  iRevealType = REVEAL_HISTORIC	| \
	 (iRevealType = REVEAL_DOUBLE & abs(gs_reveal_double_innerBottom) > EPS) ) then

! Board Side Hotspots ----------------------------------------------------------

	if bSlantedInnerSide & not(gs_stack_bottom) & isWindow then
		dyBLB =  ((leftRevealPnts[idxBoardEndRevealLeft - 1][2]  - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_bottom_angle)) - (iRevealType <> REVEAL_SLANTED) * gs_reveal_splayed_innerBottom	! Bottom Left
		dyBRB = ((rightRevealPnts[idxBoardEndRevealRight - 1][2] - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_bottom_angle)) - (iRevealType <> REVEAL_SLANTED) * gs_reveal_splayed_innerBottom	! Bottom Right
	else
		dyBLB = -(iRevealType = REVEAL_DOUBLE) * gs_reveal_double_innerBottom
		dyBRB = -(iRevealType = REVEAL_DOUBLE) * gs_reveal_double_innerBottom
	endif

	add leftRevealPnts[idxBoardEndRevealLeft - 1][1], 0, leftRevealPnts[idxBoardEndRevealLeft - 1][2]
	hotspot 0,-dyBLB,						0, unID
	del 1
	unID = unID + 1

	add rightRevealPnts[idxBoardEndRevealRight - 1][1], 0, rightRevealPnts[idxBoardEndRevealRight - 1][2]
	hotspot 0,-dyBRB,						0, unID
	del 1
	unID = unID + 1
endif

if iWindowShape = SHAPE_RECTANGULAR & \
	( iRevealType = REVEAL_SLANTED	| \
	  iRevealType = REVEAL_SPLAYED	| \
	  iRevealType = REVEAL_HISTORIC	| \
	 (iRevealType = REVEAL_DOUBLE & abs(gs_reveal_double_innerTop) > EPS) ) then

	if bSlantedInnerSide & not(gs_stack_top) then
		dyBLT =  ((leftRevealPnts[idxBoardEndRevealLeft - 1][2]  - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_top_angle) - (iRevealType <> REVEAL_SLANTED) * gs_reveal_splayed_InnerTop)	! Top Left
		dyBRT = ((rightRevealPnts[idxBoardEndRevealRight - 1][2] - (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS) * tan(gs_reveal_top_angle) - (iRevealType <> REVEAL_SLANTED) * gs_reveal_splayed_InnerTop)	! Top Right
	else
		dyBLT = -(iRevealType = REVEAL_DOUBLE) * gs_reveal_double_innerTop
		dyBRT = -(iRevealType = REVEAL_DOUBLE) * gs_reveal_double_innerTop
	endif

	add leftRevealPnts[idxBoardEndRevealLeft - 1][1], 0, leftRevealPnts[idxBoardEndRevealLeft - 1][2]
	hotspot 0, B + dyBLT - overSizeLower + overSizeUpper,	0, unID
	del 1
	unID = unID + 1

	add rightRevealPnts[idxBoardEndRevealRight - 1][1], 0, rightRevealPnts[idxBoardEndRevealRight - 1][2]
	hotspot 0, B + dyBRT - overSizeLower + overSizeUpper,	0, unID
	del 1
	unID = unID + 1
endif


!! Horizontal editing -----------------------------------------------------------
!
!		add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
!		hotspot  0,0,					0, unID,   ac_wallhole_width, 1+256, ac_wallhole_width	! Base
!		hotspot -ac_wallhole_width,0,	0, unID+1, ac_wallhole_width, 2,		ac_wallhole_width	! Moving
!		hotspot  1,0,					0, unID+2, ac_wallhole_width, 3,		ac_wallhole_width	! Reference
!		del 1
!		unID = unID + 3
!
!		if abs(gs_wallhole_width_half) > EPS then
!			add dxBR, 0, rightRevealPnts[idxBoardEndRevealRight][2]
!			hotspot  0,0,						0, unID,   gs_wallhole_width_half, 1+128, ac_wallhole_width	! Base
!			hotspot  gs_wallhole_width_half,0,	0, unID+1, gs_wallhole_width_half, 2,		ac_wallhole_width	! Moving
!			hotspot -1,0,						0, unID+2, gs_wallhole_width_half, 3,		ac_wallhole_width	! Reference
!			del 1
!		endif
!		unID = unID + 3
!
!		if abs(gs_wallhole_width_half) > EPS then
!			add dxBL, 0, leftRevealPnts[idxBoardEndRevealLeft][2]
!			hotspot  0,0,						0, unID,   gs_wallhole_width_half, 1+128,	ac_wallhole_width	! Base
!			hotspot -gs_wallhole_width_half,0,	0, unID+1, gs_wallhole_width_half, 2,		ac_wallhole_width	! Moving
!			hotspot  1,0,						0, unID+2, gs_wallhole_width_half, 3,		ac_wallhole_width	! Reference
!			del 1
!		endif
!		unID = unID + 3
!
!		if abs(gs_wallhole_width_half) > EPS then
!			add dxBR, openingHeight, rightRevealPnts[idxBoardEndRevealRight][2]
!			hotspot  0,0,						0, unID,   gs_wallhole_width_half, 1+128, ac_wallhole_width	! Base
!			hotspot  gs_wallhole_width_half,0,	0, unID+1, gs_wallhole_width_half, 2,		ac_wallhole_width	! Moving
!			hotspot -1,0,						0, unID+2, gs_wallhole_width_half, 3,		ac_wallhole_width	! Reference
!			del 1
!		endif
!		unID = unID + 3
!
!		if abs(gs_wallhole_width_half) > EPS then
!			add dxBL, openingHeight, leftRevealPnts[idxBoardEndRevealLeft][2]
!			hotspot  0,0,						0, unID,   gs_wallhole_width_half, 1+128,	ac_wallhole_width	! Base
!			hotspot -gs_wallhole_width_half,0,	0, unID+1, gs_wallhole_width_half, 2,		ac_wallhole_width	! Moving
!			hotspot  1,0,						0, unID+2, gs_wallhole_width_half, 3,		ac_wallhole_width	! Reference
!			del 1
!		endif
!		unID = unID + 3
!
!		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
!		else
!			if abs(gs_reveal_width_half) > EPS then
!				add dxSR, gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
!				hotspot  0,0,					0, unID,   gs_reveal_width_half, 1+128, ac_reveal_width	! Base
!				hotspot  gs_reveal_width_half,0,0, unID+1, gs_reveal_width_half, 2,	  ac_reveal_width	! Moving
!				hotspot -1,0,					0, unID+2, gs_reveal_width_half, 3,	  ac_reveal_width	! Reference
!				del 1
!			endif
!			unID = unID + 3
!
!			if abs(gs_reveal_width_half) > EPS then
!				add dxSL, gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
!				hotspot  0,0,					0, unID,   gs_reveal_width_half, 1+128, ac_reveal_width	! Base
!				hotspot -gs_reveal_width_half,0,0, unID+1, gs_reveal_width_half, 2,	  ac_reveal_width	! Moving
!				hotspot  1,0,					0, unID+2, gs_reveal_width_half, 3,	  ac_reveal_width	! Reference
!				del 1
!			endif
!			unID = unID + 3
!
!			if abs(gs_reveal_width_half) > EPS then
!				add dxSR, openingHeight - gs_reveal_top, rightRevealPnts[idxSillStartRevealRight][2]
!				hotspot  0,0,					0, unID,   gs_reveal_width_half, 1+128, ac_reveal_width	! Base
!				hotspot  gs_reveal_width_half,0,0, unID+1, gs_reveal_width_half, 2,	  ac_reveal_width	! Moving
!				hotspot -1,0,					0, unID+2, gs_reveal_width_half, 3,	  ac_reveal_width	! Reference
!				del 1
!			endif
!			unID = unID + 3
!
!			if abs(gs_reveal_width_half) > EPS then
!				add dxSL, openingHeight - gs_reveal_top, leftRevealPnts[idxSillStartRevealLeft][2]
!				hotspot  0,0,					0, unID,   gs_reveal_width_half, 1+128, ac_reveal_width	! Base
!				hotspot -gs_reveal_width_half,0,0, unID+1, gs_reveal_width_half, 2,	  ac_reveal_width	! Moving
!				hotspot  1,0,					0, unID+2, gs_reveal_width_half, 3,	  ac_reveal_width	! Reference
!				del 1
!			endif
!			unID = unID + 3
!		endif
!
!! Vertical editing -------------------------------------------------------------
!
!		add leftRevealPnts[idxBoardEndRevealLeft][1], 0, leftRevealPnts[idxBoardEndRevealLeft][2]
!		hotspot 0,0,					0, unID,   ac_wallhole_height, 1	! Base
!		hotspot 0,ac_wallhole_height,	0, unID+1, ac_wallhole_height, 2	! Moving
!		hotspot 0,-1,					0, unID+2, ac_wallhole_height, 3	! Reference
!		del 1
!		unID = unID + 3
!
!		add rightRevealPnts[idxBoardEndRevealRight][1], 0, rightRevealPnts[idxBoardEndRevealRight][2]
!		hotspot 0,0,					0, unID,   ac_wallhole_height, 1	! Base
!		hotspot 0,ac_wallhole_height,	0, unID+1, ac_wallhole_height, 2	! Moving
!		hotspot 0,-1,					0, unID+2, ac_wallhole_height, 3	! Reference
!		del 1
!		unID = unID + 3
!
!		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
!			add leftRevealPnts[idxSillStartRevealLeft][1], 0, leftRevealPnts[idxSillStartRevealLeft][2]
!			hotspot 0,0,				0, unID,   ac_wallhole_height, 1	! Base
!			hotspot 0,ac_reveal_height,	0, unID+1, ac_wallhole_height, 2	! Moving
!			hotspot 0,-1,				0, unID+2, ac_wallhole_height, 3	! Reference
!			del 1
!			unID = unID + 3
!
!			add rightRevealPnts[idxSillStartRevealRight][1], 0, rightRevealPnts[idxSillStartRevealRight][2]
!			hotspot 0,0,				0, unID,   ac_wallhole_height, 1	! Base
!			hotspot 0,ac_reveal_height,	0, unID+1, ac_wallhole_height, 2	! Moving
!			hotspot 0,-1,				0, unID+2, ac_wallhole_height, 3	! Reference
!			del 1
!			unID = unID + 3
!		else
!			add leftRevealPnts[idxSillStartRevealLeft][1], gs_reveal_bottom, leftRevealPnts[idxSillStartRevealLeft][2]
!			hotspot 0,0,				0, unID,   ac_reveal_height, 1	! Base
!			hotspot 0,ac_reveal_height,	0, unID+1, ac_reveal_height, 2	! Moving
!			hotspot 0,-1,				0, unID+2, ac_reveal_height, 3	! Reference
!			del 1
!			unID = unID + 3
!
!			add rightRevealPnts[idxSillStartRevealRight][1], gs_reveal_bottom, rightRevealPnts[idxSillStartRevealRight][2]
!			hotspot 0,0,				0, unID,   ac_reveal_height, 1	! Base
!			hotspot 0,ac_reveal_height,	0, unID+1, ac_reveal_height, 2	! Moving
!			hotspot 0,-1,				0, unID+2, ac_reveal_height, 3	! Reference
!			del 1
!			unID = unID + 3
!		endif
!	endif

if WIDO_REVEAL_SIDE then
	del 2
endif

! ==============================================================================
! Cut Default Wallhole
! ==============================================================================

if not(curvedWall) | (curvedWall & bParalellInCurvedWalls) then

	if WIDO_REVEAL_SIDE then
		addz WIDO_SILL - WALL_THICKNESS + WIDO_FRAME_THICKNESS    ! Flip
	else
		addz -WIDO_SILL
	endif

	if WIDO_REVEAL_SIDE then
		mulz -1
		addz -WALL_THICKNESS
	endif

	if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
		MulRat = 1
	endif

! =============================================================================
! Outer Side Cut - Straight Wall
! =============================================================================

	if WIDO_SILL > EPS then
		material matRevealSide

		_bCustomMatNicheTop			= bCustomMatNicheTop
		_wallNicheSurfaceLeft		= matRevealSide
		_wallNicheSurfaceRight		= matRevealSide
		_wallNicheSurfaceBottom		= matRevealSide
		_wallNicheSurfaceTop		= matNicheTop

		cutMethod	= 1
		if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then
			cutStatus	= 2 + 16 + 256 * _bCustomMatNicheTop
		else
			cutStatus	= 2 + 16
		endif
		cutVectX	= 0
		cutVectY	= 0
		cutVectZ	= 1
		cutDepth	= WIDO_SILL

		sideRight	= rightWidth + overSizeRight
		sideLeft	= leftWidth  + overSizeLeft
		sideBottom	= overSizeLower
		sideTop		= B + overSizeUpper

		offLeft		= leftJamb  + thkPlasterAtSillLeft
		offRight	= rightJamb + thkPlasterAtSillRight
		offTop		= upperJamb + thkPlasterAtSillTop
		offBottom	= lowerJamb + thkPlasterAtSillBottom

		if iWindowShape = SHAPE_ELLIPSEARCH then
			smallRadiusEllips_offset	= smallRadiusEllips_reveal
			middleRadiusEllips_offset	= middleRadiusEllips_reveal
		endif

		if iWindowShape = SHAPE_GOTHICARCH then
			centArcoffs		= centSillArcoffs
		endif

		if iWindowShape = SHAPE_OGEECENTERED then
			centArcoffs		= centSillArcoffs
		endif

		if iWindowShape = SHAPE_SARACENIC then
			tangArcx		= SilltangArcx
			tangArcy		= SilltangArcy
			centArcoffs		= centSillArcoffs
		endif

		if iWindowShape = SHAPE_HORSESHOE then
			LowArcoffsy		= SillLowArcoffsy
			LowArcoffsx		= SillLowArcoffsx
			HighArcoffs		= SillHighArcoffs
		endif

		if iWindowShape = SHAPE_HALFARCH then
			Topx	= SillTopx
			Topy	= SillTopy
			Shouldx	= SillShouldx
			Shouldy	= SillShouldy
		endif

		if bTShapedOpening then
			offSlLeft			= gs_reveal_left_sL   + thkPlasterAtSillSLLeft
			offSlRight			= gs_reveal_right_sR  + thkPlasterAtSillSLRight
			offSlLeftBottom		= gs_reveal_bottom_sL + thkPlasterAtSillSlLeftBottom
			offSlRightBottom	= gs_reveal_bottom_sR + thkPlasterAtSillSlRightBottom
		endif

		addz -SillPlasterAtFrame
		gosub 2000
		del 1

	endif


! =============================================================================
! Plaster Layer Outer Side Cut - Straight Wall
! =============================================================================

	if WIDO_SILL > EPS & SillPlasterAtFrame > EPS then
		cutMethod	= 1
		cutStatus	= 2 + 16
		cutVectX	= 0
		cutVectY	= 0
		cutVectZ	= 1
		cutDepth	= WIDO_SILL

		sideRight	= rightWidth + overSizeRight
		sideLeft	= leftWidth  + overSizeLeft
		sideBottom	= overSizeLower - bSillIsHorizontal * bBoardElevUsa
		sideTop		= B + overSizeUpper

		offLeft		= thkPlasterAtSillLeft
		offRight	= thkPlasterAtSillRight
		offTop		= thkPlasterAtSillTop	 + (thkPlasterAtSillTop		< EPS) * gs_reveal_top
		offBottom	= thkPlasterAtSillBottom + (thkPlasterAtSillBottom	< EPS) * gs_reveal_bottom

		if iWindowShape = SHAPE_ELLIPSEARCH then
			smallRadiusEllips_offset	= smallRadiusEllips - offLeft
			middleRadiusEllips_offset	= middleRadiusEllips - offLeft
		endif

		if bTShapedOpening then
			offSlLeft			= thkPlasterAtSillSlLeft
			offSlRight			= thkPlasterAtSillSlRight
			offSlLeftBottom		= thkPlasterAtSillSlLeftBottom  + (thkPlasterAtSillSlLeftBottom	 < EPS) * gs_reveal_bottom
			offSlRightBottom	= thkPlasterAtSillSlRightBottom + (thkPlasterAtSillSlRightBottom < EPS) * gs_reveal_bottom
		endif

		gosub 2000
	endif


! =============================================================================
! Inner Side Cut - Straight Wall
! =============================================================================

	material matOppositeSide

	addz WALL_THICKNESS

	isParIns = 0

	if not(bSlantedInnerSide) then
		cutMethod	= 1
		cutStatus	= 2 + 8 * (WIDO_SILL < EPS) + 16
		cutVectX	= 0
		cutVectY	= 0
		cutVectZ	= -1
		cutDepth	= WALL_THICKNESS - WIDO_SILL - CustRevealOffsetDepth - BoardPlasterAtFrame

		sideRight	= rightWidth + overSizeRight
		sideLeft	= leftWidth  + overSizeLeft
		sideBottom	= overSizeLower
		sideTop		= B + overSizeUpper

		offLeft		= CustRevealLeftJamb  + thkPlasterAtBoardLeft
		offRight	= CustRevealRightJamb + thkPlasterAtBoardRight
		offTop		= CustRevealTopJamb   + thkPlasterAtBoardTop
		offBottom	= CustRevealBottJamb  + thkPlasterAtBoardBottom + bSillIsHorizontal * bBoardElevUsa

		if iWindowShape = SHAPE_ELLIPSEARCH then
			smallRadiusEllips_offset	= smallRadiusEllips_Innreveal
			middleRadiusEllips_offset	= middleRadiusEllips_Innreveal
		endif

		if iWindowShape = SHAPE_GOTHICARCH then
			centArcoffs		= centBoardArcoffs
		endif

		if iWindowShape = SHAPE_OGEECENTERED then
			centArcoffs		= centBoardArcoffs
		endif

		if iWindowShape = SHAPE_SARACENIC then
			tangArcx		= BoardtangArcx
			tangArcy		= BoardtangArcy
			centArcoffs		= centBoardArcoffs
		endif

		if iWindowShape = SHAPE_HORSESHOE then
			LowArcoffsy		= BoardLowArcoffsy
			LowArcoffsx		= BoardLowArcoffsx
			HighArcoffs		= BoardHighArcoffs
		endif

		if iWindowShape = SHAPE_HALFARCH then
			Topx	= BoardTopx
			Topy	= BoardTopy
			Shouldx	= BoardShouldx
			Shouldy	= BoardShouldy
		endif

		if bTShapedOpening then
			offSlLeft			= gs_reveal_double_innerLeft_sL   + thkPlasterAtBoardSlLeft
			offSlRight			= gs_reveal_double_innerRight_sR  + thkPlasterAtBoardSlRight
			offSlLeftBottom		= gs_reveal_double_innerBottom_sL + thkPlasterAtBoardSlLeftBottom
			offSlRightBottom	= gs_reveal_double_innerBottom_sR + thkPlasterAtBoardSlRightBottom
		endif

		gosub 2000
	endif


! =============================================================================
! Plaster Layer Inner Side Cut - Straight Wall
! =============================================================================

	if not(bSlantedInnerSide) & BoardPlasterAtFrame > EPS then
		cutMethod	= 1
		cutStatus	= 2 + 16
		cutVectX	= 0
		cutVectY	= 0
		cutVectZ	= -1
		cutDepth	= WALL_THICKNESS - WIDO_SILL - CustRevealOffsetDepth

		sideRight	= rightWidth + overSizeRight
		sideLeft	= leftWidth  + overSizeLeft
		sideBottom	= overSizeLower - bSillIsHorizontal * bBoardElevUsa
		sideTop		= B + overSizeUpper

		offLeft		= thkPlasterAtBoardLeft
		offRight	= thkPlasterAtBoardRight
		offTop		= thkPlasterAtBoardTop	  + (thkPlasterAtBoardTop	 < EPS) * (CustRevealTopJamb  + offsetInsideTop)
		offBottom	= thkPlasterAtBoardBottom + (thkPlasterAtBoardBottom < EPS) * (CustRevealBottJamb + offsetInsideBott)

		if iWindowShape = SHAPE_ELLIPSEARCH then
			smallRadiusEllips_offset	= smallRadiusEllips - offLeft
			middleRadiusEllips_offset	= middleRadiusEllips - offLeft
		endif

		if bTShapedOpening then
			offSlLeft			= thkPlasterAtBoardSlLeft
			offSlRight			= thkPlasterAtBoardSlRight
			offSlLeftBottom		= thkPlasterAtBoardSlLeftBottom  + (thkPlasterAtBoardSlLeftBottom  < EPS) * (CustRevealBottJamb + offsetInsideBott)
			offSlRightBottom	= thkPlasterAtBoardSlRightBottom + (thkPlasterAtBoardSlRightBottom < EPS) * (CustRevealBottJamb + offsetInsideBott)
		endif

		gosub 2000
	endif


! =============================================================================
! Slanted Inner Side Cut - Straight Wall
! =============================================================================

	if bSlantedInnerSide then
		if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then
			gs_slanted_left_angle		= gs_reveal_left_angle
			gs_slanted_right_angle		= gs_reveal_right_angle
			gs_slanted_bottom_angle		= gs_reveal_bottom_angle
			gs_slanted_top_angle		= gs_reveal_top_angle
			thkPlasterAtSlantedLeft		= thkPlasterAtBoardLeft
			thkPlasterAtSlantedRight	= thkPlasterAtBoardRight
			thkPlasterAtSlantedBottom	= thkPlasterAtBoardBottom
			thkPlasterAtSlantedTop		= thkPlasterAtBoardTop
			thkPlasterAtSlanted			= thkPlasterAtBoard
			HalfInfiniteCut				= 1
			slantedDepth		= (WALL_THICKNESS - WIDO_SILL - offsetInsideDepth - not(iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) * thkPlasterAtBoard)
			slantedDepthBottom	= slantedDepth
			slantedCutDepth		= slantedDepth
			offsetDepth		= offsetInsideDepth
			offsetRight		= offsetInsideRight
			offsetLeft		= offsetInsideLeft
			offsetTop		= offsetInsideTop
			offsetBott		= offsetInsideBott + bSillIsHorizontal * bBoardElevUsa
			bWallInsetCut	= 1

			gosub 1000	! Slanted Reveal cutting body
		endif
	endif


! =============================================================================
! Slanted Outer Side Cut - Straight Wall
! =============================================================================

	if bSlantedOuterSide then
		if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then

			gs_slanted_left_angle		= gs_reveal_outerLeft_angle
			gs_slanted_right_angle		= gs_reveal_outerRight_angle
			gs_slanted_bottom_angle		= gs_reveal_outerBottom_angle
			gs_slanted_top_angle		= gs_reveal_outerTop_angle
			thkPlasterAtSlantedLeft		= thkPlasterAtSillLeft
			thkPlasterAtSlantedRight	= thkPlasterAtSillRight
			thkPlasterAtSlantedBottom	= thkPlasterAtSillBottom
			thkPlasterAtSlantedTop		= thkPlasterAtSillTop
			thkPlasterAtSlanted			= 0
			HalfInfiniteCut				= 1
			slantedDepth		= WIDO_SILL - gs_reveal_outer_jamb_depth
			slantedDepthBottom	= WIDO_SILL - bHaveMountingFrame * (gs_mountingFrame_depth)
			slantedCutDepth		= slantedDepth
			offsetDepth		= offsetOutsideDepth
			offsetRight		= gs_reveal_right
			offsetLeft		= gs_reveal_left
			offsetTop		= gs_reveal_top
			offsetBott		= gs_reveal_bottom - (not(bHaveMountingFrame) * gs_reveal_outer_jamb_depth + bHaveMountingFrame * (gs_reveal_outer_jamb_depth - gs_mountingFrame_depth)) * tan(gs_reveal_outerBottom_angle)
			bWallInsetCut	= 0

			mulz -1
			addz WALL_THICKNESS
			gosub 1000	! Slanted Reveal cutting body
			del 2
		endif
	endif


! =============================================================================
! Middle cut at window range - Straight Wall
! =============================================================================

	if WIDO_FRAME_THICKNESS > EPS & bNeedMiddleCut then

		cutMethod	= 1
		cutStatus	= 2
		cutVectX	= 0
		cutVectY	= 0
		cutVectZ	= 1
		cutDepth	= WIDO_FRAME_THICKNESS

		sideRight	= rightWidth + overSizeRight
		sideLeft	= leftWidth  + overSizeLeft
		sideBottom	= overSizeLower
		sideTop		= B + overSizeUpper

		offLeft		= 0
		offRight	= 0
		offTop		= 0
		offBottom	= 0

		if iWindowShape = SHAPE_ELLIPSEARCH then
			smallRadiusEllips_offset	= smallRadiusEllips
			middleRadiusEllips_offset	= middleRadiusEllips
		endif

		if iWindowShape = SHAPE_GOTHICARCH then
			centArcoffs		= 0
		endif

		if iWindowShape = SHAPE_OGEECENTERED then
			centArcoffs		= sideTop
		endif

		if iWindowShape = SHAPE_SARACENIC then
			tangArcx		= FrametangArcx
			tangArcy		= FrametangArcy
			centArcoffs		= sideTop
		endif

		if iWindowShape = SHAPE_HORSESHOE then
			LowArcoffsy		= FrameLowArcoffsy
			LowArcoffsx		= FrameLowArcoffsx
			HighArcoffs		= FrameHighArcoffs
		endif

		if iWindowShape = SHAPE_HALFARCH then
			Topx	= FrameTopx
			Topy	= FrameTopy
			Shouldx	= FrameShouldx
			Shouldy	= FrameShouldy
		endif

		if bTShapedOpening then
			offSlLeft			= 0
			offSlRight			= 0
			offSlLeftBottom		= 0
			offSlRightBottom	= 0
		endif

		addz WIDO_SILL - WALL_THICKNESS

		if iRevealType = REVEAL_SLANTED then
			gs_slanted_left_angle		= gs_reveal_left_angle
			gs_slanted_right_angle		= gs_reveal_right_angle
			gs_slanted_bottom_angle		= gs_reveal_bottom_angle
			gs_slanted_top_angle		= gs_reveal_top_angle
			thkPlasterAtSlantedLeft		= 0
			thkPlasterAtSlantedRight	= 0
			thkPlasterAtSlantedBottom	= 0
			thkPlasterAtSlantedTop		= 0
			thkPlasterAtSlanted			= 0
			HalfInfiniteCut				= 0
			slantedDepth		= WIDO_FRAME_THICKNESS
			slantedDepthBottom	= slantedDepth
			slantedCutDepth		= slantedDepth
			offsetDepth		= offsetInsideDepth
			offsetRight		= offsetInsideRight
			offsetLeft		= offsetInsideLeft
			offsetTop		= offsetInsideTop
			offsetBott		= offsetInsideBott
			bWallInsetCut	= 0

			addz WIDO_FRAME_THICKNESS
			gosub 1000
			del 1
		else
			gosub 2000
		endif
		del 1

	endif

	if WIDO_FRAME_THICKNESS > EPS & abs(bBoardElevUsa) > EPS then
		addz WIDO_SILL - WALL_THICKNESS
		if	iWindowShape = SHAPE_RECTANGULAR | \
			iWindowShape = SHAPE_ELLIPSEARCH |\
			iWindowShape = SHAPE_HALFCIRCLE |\
			iWindowShape = SHAPE_PENTAGON |\
			iWindowShape = SHAPE_QUARTERROUND |\
			iWindowShape = SHAPE_TRAPEZOID |\
			iWindowShape = SHAPE_ARCHED then

			wallniche 4, 1, 2,
				0,0,1,	WIDO_FRAME_THICKNESS,
				 rightWidth + overSizeRight,	-overSizeLower + bBoardElevUsa,	31,
				 rightWidth + overSizeRight,	-overSizeLower,					31,
				-leftWidth  - overSizeLeft,		-overSizeLower,					31,
				-leftWidth  - overSizeLeft,		-overSizeLower + bBoardElevUsa,	31
		endif
		del 1
	endif

	del 2 + WIDO_REVEAL_SIDE * 2


! =============================================================================
! Cut Wall Inset - Straight Wall
! =============================================================================

	if bParapetWallInset & SYMB_POS_Y > overSizeLower & not(isParIns) & parapet_height > EPS & (SYMB_POS_Y - act_st_pos) > EPS then
		if not(curvedWall) then

			if WIDO_REVEAL_SIDE then
				addz WIDO_SILL - WALL_THICKNESS + WIDO_FRAME_THICKNESS    ! Flip
			else
				addz -WIDO_SILL
			endif
			if WIDO_REVEAL_SIDE then
				mulz -1
				addz -WALL_THICKNESS
			endif
			addz WALL_THICKNESS

			rotx 90
			addz SYMB_POS_Y - act_st_pos

			dx = parapetWallInsetDepth * sin(WALL_INCL)
			dy = parapetWallInsetDepth * cos(WALL_INCL)

			if gs_parapet_autodim then
				revSlantYRight	= revSlantYRight + gs_parapet_autodim * thkPlasterAtBoardRight * incV
				revSlantYLeft	= revSlantYLeft  - gs_parapet_autodim * thkPlasterAtBoardLeft  * incV
				wallniche 4, 1, 2,
					0,0,-1,	parapet_height + gs_parapet_autodim * thkPlasterAtBoardBottom,
					 rightWidth + overSizeRight + revYR - gs_parapet_autodim * thkPlasterAtBoardRight + parapetExtendRight * cos(WALL_INCL) + revSlantXRight,	-py1p - revSlantYRight,	31,
					 rightWidth + overSizeRight + revYR - gs_parapet_autodim * thkPlasterAtBoardRight + parapetExtendRight * cos(WALL_INCL),					-py1p + 1.0,			31,
					-leftWidth  - overSizeLeft  - revYL + gs_parapet_autodim * thkPlasterAtBoardLeft  - parapetExtendLeft  * cos(WALL_INCL),					-py2p + 1.0,			31,
					-leftWidth  - overSizeLeft  - revYL + gs_parapet_autodim * thkPlasterAtBoardLeft  - parapetExtendLeft  * cos(WALL_INCL) + revSlantXLeft,	-py2p - revSlantYLeft,	31
			else
				wallniche 4, 1, 2,
					0,0,-1,	parapet_height + gs_parapet_autodim * thkPlasterAtBoardBottom,
					 rightWidth + overSizeRight + revYR - gs_parapet_autodim * thkPlasterAtBoardRight + parapetExtendRight * cos(WALL_INCL) + dx*incFactor,	-py1p - dy,		31,
					 rightWidth + overSizeRight + revYR - gs_parapet_autodim * thkPlasterAtBoardRight + parapetExtendRight * cos(WALL_INCL),					-py1p + 1.0,	31,
					-leftWidth  - overSizeLeft  - revYL + gs_parapet_autodim * thkPlasterAtBoardLeft  - parapetExtendLeft  * cos(WALL_INCL),					-py2p + 1.0,	31,
					-leftWidth  - overSizeLeft  - revYL + gs_parapet_autodim * thkPlasterAtBoardLeft  - parapetExtendLeft  * cos(WALL_INCL) + dx*incFactor,	-py2p - dy,		31
			endif

			del 2
			del 2 + WIDO_REVEAL_SIDE * 2

		else			! if bParalellInCurvedWalls, curved walls

			if parapet_height > EPS & (SYMB_POS_Y - act_st_pos) > EPS then
				if wallIsLeft then

					dy = WOD - radBoard - parapetWallInsetDepth

					angd = asn( (parapet_width/2) / radBoard )
					dx2 = (radBoard + parapetWallInsetDepth) * tan(angd)

					dyrad = radBoard - sqr(radBoard^2 - (parapet_width/2)^2)
					dy2 = dyrad + parapetWallInsetDepth

					vyLeftIn =  dy
					vyRightIn =  dy

					vxLeft =  -parapet_width/2
					vyLeft =  dy + dy2
					vxRight =  parapet_width/2
					vyRight =  dy + dy2

					rotx 90
					addz SYMB_POS_Y - act_st_pos - parapet_height

					wallniche 6, 1, 2,
						0,0, 1,	parapet_height,
						 vxRight, vyRightIn,	31,
						 vxRight, vyLeft,	31,
						 vxRight, 1,	31,
						 vxLeft, 1,	31,
						 vxLeft, vyRight,	31,
						 vxLeft, vyLeftIn,	31

					del 2
				else

					angd = atn( (parapet_width/2) / radBoard )
					dy = radBoard + WOD

					vyLeftIn =  dy - parapetWallInsetDepth * cos(angd)
					vyRightIn =  dy - parapetWallInsetDepth * cos(angd)

					vxLeft = -parapet_width/2
					vyLeft =  dy
					vxRight =  parapet_width/2
					vyRight =  dy

					rotx 90
					addz SYMB_POS_Y - act_st_pos - parapet_height

					wallniche 6, 1, 2,
						0,0, 1,	parapet_height,
						 vxRight, vyRightIn,	31,
						 vxRight, vyLeft,	31,
						 vxRight, 1,	31,
						 vxLeft, 1,	31,
						 vxLeft, vyRight,	31,
						 vxLeft,	vyLeftIn,	31

					del 2
				endif
			endif
		endif
	endif
endif


! =============================================================================
! Curved Wall
! =============================================================================

if curvedWall & not(bParalellInCurvedWalls) then

	isParIns = 0

	bReveal = WIDO_REVEAL_ON | WIDO_SILL > EPS | not(gs_IsCurved)
	bUniformSideMats	= (matRevealSide = matOppositeSide)
	bOneCut				= (bUniformSideMats & WIDO_SILL < 0.005 & thkPlasterAtSill < EPS & thkPlasterAtBoard < EPS)	! Cut the hole with only one wallniche

	if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC then
		bOneCut = 0
	endif

	if SYMB_ROTANGLE > EPS then addz WIDO_FRAME_THICKNESS
	if WIDO_REVEAL_SIDE then mulz -1

	if wallIsLeft then

		material matRevealSide

		addz -WIDO_FRAME_THICKNESS

! =============================================================================
! Outer Side Cut - Curved Left Wall
! =============================================================================

		if (WIDO_SILL > EPS | not(gs_IsCurved)) & not(bOneCut) then

			leftJamb	= leftWidth  + WOD * tan(alfaLeftOs - alfaLeftJamb) + gs_left_oversize
			rightJamb	= rightWidth + WOD * tan(alfaRightOs - alfaRightJamb) + gs_right_oversize

			thkPlasterAtSillLeft_distx = thkPlasterAtSillLeft / cos(alfaLeftOs - alfaLeftJamb)
			thkPlasterAtSillRight_distx = thkPlasterAtSillRight / cos(alfaRightOs - alfaRightJamb)

			px1 =  leftWidth  - leftJamb  + overSizeLeft + thkPlasterAtSillLeft_distx - SillPlasterAtFrame * tan(alfaLeftOs - alfaLeftJamb)
			px2 = -rightWidth + rightJamb - overSizeRight - thkPlasterAtSillRight_distx + SillPlasterAtFrame * tan(alfaRightOs - alfaRightJamb)

			! Searching for new plaster offset centerpoint
			x11 = px1
			y11 = WOD + SillPlasterAtFrame
			x12 = thkPlasterAtSillLeft_distx
			y12 = 0

			x21 = px2
			y21 = WOD + SillPlasterAtFrame
			x22 = -thkPlasterAtSillRight_distx
			y22 = 0

			gosub 100			! Line - Line intersection

			_bCustomMatNicheTop			= bCustomMatNicheTop
			_wallNicheSurfaceLeft		= matRevealSide
			_wallNicheSurfaceRight		= matRevealSide
			_wallNicheSurfaceBottom		= matRevealSide
			_wallNicheSurfaceTop		= matNicheTop

			cutMethod	= 3
			if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then
				cutStatus	= 2 + 16 + 256 * _bCustomMatNicheTop
			else
				cutStatus	= 2 + 16
			endif
			cutVectX	= cx
			cutVectY	= 0
			cutVectZ	= WOD - cy + SillPlasterAtFrame
			cutDepth	= 0

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower
			sideTop		= B + overSizeUpper

			offLeft		= leftWidth  - WOD * tan(alfaLeftOs  - alfaLeftJamb)  + gs_left_oversize  + thkPlasterAtSillLeft_distx  - SillPlasterAtFrame * tan(alfaLeftOs - alfaLeftJamb)
			offRight	= rightWidth - WOD * tan(alfaRightOs - alfaRightJamb) + gs_right_oversize + thkPlasterAtSillRight_distx - SillPlasterAtFrame * tan(alfaRightOs - alfaRightJamb)
			offTop		= upperJamb + thkPlasterAtSillTop
			offBottom	= lowerJamb + thkPlasterAtSillBottom

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if iWindowShape = SHAPE_GOTHICARCH then
				centArcoffs		= centSillArcoffs
			endif

			if iWindowShape = SHAPE_OGEECENTERED then
				centArcoffs		= centSillArcoffs
			endif

			if iWindowShape = SHAPE_SARACENIC then
				tangArcx		= SilltangArcx
				tangArcy		= SilltangArcy
				centArcoffs		= centSillArcoffs
			endif

			if iWindowShape = SHAPE_HORSESHOE then
				LowArcoffsy		= SillLowArcoffsy
				LowArcoffsx		= SillLowArcoffsx
				HighArcoffs		= SillHighArcoffs
			endif

			if iWindowShape = SHAPE_HALFARCH then
				Topx	= SillTopx
				Topy	= SillTopy
				Shouldx	= SillShouldx
				Shouldy	= SillShouldy
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = 1
			endif

			if bTShapedOpening then
				offSlLeft			= gs_reveal_left_sL   + thkPlasterAtSillSLLeft
				offSlRight			= gs_reveal_right_sR  + thkPlasterAtSillSLRight
				offSlLeftBottom		= gs_reveal_bottom_sL + thkPlasterAtSillSlLeftBottom
				offSlRightBottom	= gs_reveal_bottom_sR + thkPlasterAtSillSlRightBottom
			endif

			addz -SillPlasterAtFrame
			gosub 2000
			del 1
		endif


! =============================================================================
! Plaster Layer Outer Side Cut - Curved Left Wall
! =============================================================================

		if SillPlasterAtFrame > EPS then
			cutMethod	= 1
			cutStatus	= 2 + 16
			cutVectX	= 0
			cutVectY	= 0
			cutVectZ	= 1
			cutDepth	= 0

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower !- bSillIsHorizontal * bBoardElevUsa
			sideTop		= B + overSizeUpper

			offLeft		= thkPlasterAtSillLeft  - (WIDO_FRAME_THICKNESS + (gs_stack_left  | bLeftCornerFunction)  * SillPlasterAtFrame) * tan(alfaLeftOs)
			offRight	= thkPlasterAtSillRight - (WIDO_FRAME_THICKNESS + (gs_stack_right | bRightCornerFunction) * SillPlasterAtFrame) * tan(alfaRightOs)
			offTop		= thkPlasterAtSillTop	  + (thkPlasterAtSillTop    < EPS) * gs_reveal_top
			offBottom	= thkPlasterAtSillBottom  + (thkPlasterAtSillBottom < EPS) * gs_reveal_bottom

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = 1
			endif

			if bTShapedOpening then
				offSlLeft			= thkPlasterAtSillSlLeft
				offSlRight			= thkPlasterAtSillSlRight
				offSlLeftBottom		= thkPlasterAtSillSlLeftBottom  + (thkPlasterAtSillSlLeftBottom	 < EPS) * gs_reveal_bottom
				offSlRightBottom	= thkPlasterAtSillSlRightBottom + (thkPlasterAtSillSlRightBottom < EPS) * gs_reveal_bottom
			endif

			gosub 2000
		endif


! =============================================================================
! Inner Side Cut - Curved Left Wall
! =============================================================================

		material matOppositeSide

		thkPlasterAtBoardLeft_distx	 = thkPlasterAtBoardLeft  / cos(alfaLeftInnJamb)
		thkPlasterAtBoardRight_distx = thkPlasterAtBoardRight / cos(alfaRightInnJamb)

		if not(bSlantedInnerSide) then
			if iRevealType = REVEAL_DOUBLE then
				dxL = 0
				dxR = 0
			else
				dxL = WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
				dxR = WIDO_FRAME_THICKNESS * tan(alfaRightOs)
			endif

			px1 =  rightWidth + overSizeRight - CustRevealRightJamb - thkPlasterAtBoardRight_distx - BoardPlasterAtFrame * tan(alfaRightInnJamb) + dxR
			px2 = -leftWidth  - overSizeLeft  + CustRevealLeftJamb  + thkPlasterAtBoardLeft_distx  + BoardPlasterAtFrame * tan(alfaLeftInnJamb)  - dxL

			! Searching for new plaster offset centerpoint
			x11 = px1
			y11 = tempWOD - BoardPlasterAtFrame + (WIDO_FRAME_THICKNESS * (iRevealType <> REVEAL_DOUBLE))
			x12 = -thkPlasterAtBoardRight_distx
			y12 = 0

			x21 = px2
			y21 = tempWOD - BoardPlasterAtFrame + (WIDO_FRAME_THICKNESS * (iRevealType <> REVEAL_DOUBLE))
			x22 = thkPlasterAtBoardLeft_distx
			y22 = 0

			gosub 100			! Line - Line intersection

			cutZ = WOD - (iRevealType = REVEAL_DOUBLE) * WIDO_FRAME_THICKNESS - cy - BoardPlasterAtFrame

			cutMethod	= 3
			cutStatus	= 2 + (8 + 16) * (not(bReveal) | bOneCut)
			cutVectX	= cx
			cutVectY	= 0
			cutVectZ	= cutZ
			cutDepth	= cutZ

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower - bSillIsHorizontal * bBoardElevUsa
			sideTop		= B + overSizeUpper

			offLeft		= CustRevealLeftJamb  + thkPlasterAtBoardLeft_distx  + BoardPlasterAtFrame * tan(alfaLeftInnJamb)  - dxL
			offRight	= CustRevealRightJamb + thkPlasterAtBoardRight_distx + BoardPlasterAtFrame * tan(alfaRightInnJamb) - dxR
			offTop		= CustRevealTopJamb   + thkPlasterAtBoardTop
			offBottom	= CustRevealBottJamb  + thkPlasterAtBoardBottom

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if iWindowShape = SHAPE_GOTHICARCH then
				centArcoffs		= centBoardArcoffs
			endif

			if iWindowShape = SHAPE_OGEECENTERED then
				centArcoffs		= centBoardArcoffs
			endif

			if iWindowShape = SHAPE_SARACENIC then
				tangArcx		= BoardtangArcx
				tangArcy		= BoardtangArcy
				centArcoffs		= centBoardArcoffs
			endif

			if iWindowShape = SHAPE_HORSESHOE then
				LowArcoffsy		= BoardLowArcoffsy
				LowArcoffsx		= BoardLowArcoffsx
				HighArcoffs		= BoardHighArcoffs
			endif

			if iWindowShape = SHAPE_HALFARCH then
				Topx	= BoardTopx
				Topy	= BoardTopy
				Shouldx	= BoardShouldx
				Shouldy	= BoardShouldy
			endif

			if bTShapedOpening then
				offSlLeft			= gs_reveal_double_innerLeft_sL   + thkPlasterAtBoardSlLeft
				offSlRight			= gs_reveal_double_innerRight_sR  + thkPlasterAtBoardSlRight
				offSlLeftBottom		= gs_reveal_double_innerBottom_sL + thkPlasterAtBoardSlLeftBottom
				offSlRightBottom	= gs_reveal_double_innerBottom_sR + thkPlasterAtBoardSlRightBottom
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = openingHeight / (openingHeight + (2 * WIDO_FRAME_THICKNESS * tan(alfaRightOs)))
			endif

			addz (iRevealType = REVEAL_DOUBLE) * WIDO_FRAME_THICKNESS + BoardPlasterAtFrame
			gosub 2000
			del 1
		endif


! =============================================================================
! Plaster Layer Inner Side Cut - Curved Left Wall
! =============================================================================

		if not(bSlantedInnerSide) & BoardPlasterAtFrame > EPS then
			cutMethod	= 1
			cutStatus	= 2	! Finite cut
			cutVectX	= 0
			cutVectY	= 0
			cutVectZ	= -1
			cutDepth	= -BoardPlasterAtFrame - EPS

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower - bSillIsHorizontal * bBoardElevUsa
			sideTop		= B + overSizeUpper

			offLeft		= thkPlasterAtBoardLeft
			offRight	= thkPlasterAtBoardRight
			offTop		= thkPlasterAtBoardTop	  + (thkPlasterAtBoardTop    < EPS) * (CustRevealTopJamb  + offsetInsideTop)
			offBottom	= thkPlasterAtBoardBottom + (thkPlasterAtBoardBottom < EPS) * (CustRevealBottJamb + offsetInsideBott)

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if bTShapedOpening then
				offSlLeft			= thkPlasterAtBoardSlLeft
				offSlRight			= thkPlasterAtBoardSlRight
				offSlLeftBottom		= thkPlasterAtBoardSlLeftBottom  + (thkPlasterAtBoardSlLeftBottom  < EPS) * (CustRevealBottJamb + offsetInsideBott)
				offSlRightBottom	= thkPlasterAtBoardSlRightBottom + (thkPlasterAtBoardSlRightBottom < EPS) * (CustRevealBottJamb + offsetInsideBott)
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = openingHeight / (openingHeight + (2 * WIDO_FRAME_THICKNESS * tan(alfaRightOs)))
			endif

			addz WIDO_FRAME_THICKNESS
			gosub 2000
			del 1
		endif


! =============================================================================
! Slanted Inner Side Cut - Curved Left Wall
! =============================================================================


		if bSlantedInnerSide then
			addz WALL_THICKNESS - WIDO_SILL

			if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then
				gs_slanted_left_angle		= gs_reveal_left_angle
				gs_slanted_right_angle		= gs_reveal_right_angle
				gs_slanted_bottom_angle		= gs_reveal_bottom_angle
				gs_slanted_top_angle		= gs_reveal_top_angle
				thkPlasterAtSlantedLeft		= thkPlasterAtBoardLeft
				thkPlasterAtSlantedRight	= thkPlasterAtBoardRight
				thkPlasterAtSlantedBottom	= thkPlasterAtBoardBottom
				thkPlasterAtSlantedTop		= thkPlasterAtBoardTop
				thkPlasterAtSlanted			= thkPlasterAtBoard
				HalfInfiniteCut				= 1
				slantedDepth		= (WALL_THICKNESS - WIDO_SILL - offsetInsideDepth - not(iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) * thkPlasterAtBoard)
				slantedDepthBottom	= slantedDepth
				slantedCutDepth		= slantedDepth
				offsetDepth	= offsetInsideDepth
				offsetRight	= offsetInsideRight
				offsetLeft	= offsetInsideLeft
				offsetTop	= offsetInsideTop
				offsetBott	= offsetInsideBott + bSillIsHorizontal * bBoardElevUsa
				bWallInsetCut	= 1

				gosub 1000	! Slanted Reveal cutting body
			endif

			del 1
		endif


! =============================================================================
! Slanted Outer Side Cut - Curved Left Wall
! =============================================================================

		if bSlantedOuterSide then
			if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then

				gs_slanted_left_angle		= gs_reveal_outerLeft_angle	 + alfaLeftOs  - alfaLeftJamb
				gs_slanted_right_angle		= gs_reveal_outerRight_angle + alfaRightOs - alfaRightJamb
				gs_slanted_bottom_angle		= gs_reveal_outerBottom_angle
				gs_slanted_top_angle		= gs_reveal_outerTop_angle
				thkPlasterAtSlantedLeft		= thkPlasterAtSillLeft
				thkPlasterAtSlantedRight	= thkPlasterAtSillRight
				thkPlasterAtSlantedBottom	= thkPlasterAtSillBottom
				thkPlasterAtSlantedTop		= thkPlasterAtSillTop
				thkPlasterAtSlanted			= 0
				HalfInfiniteCut				= 1
				slantedDepth		= WIDO_SILL - gs_reveal_outer_jamb_depth
				slantedDepthBottom	= WIDO_SILL - bHaveMountingFrame * (gs_mountingFrame_depth)
				slantedCutDepth		= slantedDepth
				offsetDepth		= offsetOutsideDepth
				offsetRight		= rightWidth - (abs(WOD) + gs_reveal_outer_jamb_depth) * tan(alfaRightOs - alfaRightJamb)
				offsetLeft		= leftWidth  - (abs(WOD) + gs_reveal_outer_jamb_depth) * tan(alfaLeftOs  - alfaLeftJamb)
				offsetTop		= gs_reveal_top
				offsetBott		= gs_reveal_bottom - (not(bHaveMountingFrame) * gs_reveal_outer_jamb_depth + bHaveMountingFrame * (gs_reveal_outer_jamb_depth - gs_mountingFrame_depth)) * tan(gs_reveal_outerBottom_angle)
				bWallInsetCut	= 0

				mulz -1
				addz WIDO_SILL
				gosub 1000	! Slanted Reveal cutting body
				del 2
			endif
		endif


! =============================================================================
! Middle cut at window range - Curved Left Wall
! =============================================================================

		if WIDO_FRAME_THICKNESS > EPS & bNeedMiddleCut then
			cutMethod	= 3
			cutStatus	= 2
			cutVectX	= 0
			cutVectY	= 0
			cutVectZ	= WOD
			cutDepth	= WIDO_FRAME_THICKNESS

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower
			sideTop		= B + overSizeUpper

			offLeft		= -WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
			offRight	= -WIDO_FRAME_THICKNESS * tan(alfaRightOs)
			offTop		= 0
			offBottom	= 0

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if iWindowShape = SHAPE_HALFARCH then
				Topx	= FrameTopx
				Topy	= FrameTopy
				Shouldx	= FrameShouldx
				Shouldy	= FrameShouldy
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = openingHeight / (openingHeight + (2 * WIDO_FRAME_THICKNESS * tan(alfaRightOs)))
			endif

			if iWindowShape = SHAPE_HORSESHOE then
				LowArcoffsy		= FrameLowArcoffsy
				LowArcoffsx		= FrameLowArcoffsx
				HighArcoffs		= FrameHighArcoffs
			endif

			if bTShapedOpening then
				offSlLeft			= 0
				offSlRight			= 0
				offSlLeftBottom		= 0
				offSlRightBottom	= 0
			endif

			if iRevealType = REVEAL_SLANTED then
				gs_slanted_left_angle		= gs_reveal_left_angle
				gs_slanted_right_angle		= gs_reveal_right_angle
				gs_slanted_bottom_angle		= gs_reveal_bottom_angle
				gs_slanted_top_angle		= gs_reveal_top_angle
				thkPlasterAtSlantedLeft		= 0
				thkPlasterAtSlantedRight	= 0
				thkPlasterAtSlantedBottom	= 0
				thkPlasterAtSlantedTop		= 0
				thkPlasterAtSlanted			= 0
				HalfInfiniteCut				= 0
				slantedDepth		= WIDO_FRAME_THICKNESS
				slantedDepthBottom	= slantedDepth
				slantedCutDepth		= slantedDepth
				offsetDepth		= offsetInsideDepth
				offsetRight		= offsetInsideRight
				offsetLeft		= offsetInsideLeft
				offsetTop		= offsetInsideTop
				offsetBott		= offsetInsideBott
				bWallInsetCut	= 0

				addz WIDO_FRAME_THICKNESS
				gosub 1000	! Slanted Reveal cutting body
				del 1
			else
				gosub 2000
			endif
		endif


! =============================================================================
! Cut Wall Inset - Curved Left Wall
! =============================================================================

		if bParapetWallInset & SYMB_POS_Y > overSizeLower & not(isParIns) & parapet_height > EPS & (SYMB_POS_Y - act_st_pos) > EPS then

			insetY = WOD - signWallIsLeft * radBoard - parapetWallInsetDepth

			if gs_parapet_autodim & thkPlasterAtBoardLeft > EPS then
				x1 = cx - opInner / 2 - parapetExtendLeft
				y1 = WOD - signWallIsLeft * sqr(radBoard^2 - x1^2) - thkPlasterAtBoardLeft * sin(alfaLeftInnJamb)
				x1 = x1 + thkPlasterAtBoardLeft * cos(alfaLeftInnJamb)
				x2 = x1 - thkPlasterAtBoardLeft * sin(alfaLeftInnJamb)
				y2 = y1 - thkPlasterAtBoardLeft * cos(alfaLeftInnJamb)
				xo = 0
				yo = WOD
				ro = radBoard

				gosub 101	! Circle - Line intersection

				if ya > yb then
					pxL1 = xa
					pyL1 = ya
				else
					pxL1 = xb
					pyL1 = yb
				endif

				alpha = alfaLeftInnJamb
			else
				pxL1 = cx - opInner / 2 - parapetExtendLeft
				pyL1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxL1^2)

				alpha = abs(asn(pxL1 / radBoard))
			endif
			pxL2 = pxL1 - signWallIsLeft * tan(alpha) * abs(pyL1 - insetY)
			pyL2 = insetY

			if gs_parapet_autodim & thkPlasterAtBoardRight > EPS then
				x1 = cx + opInner / 2 + parapetExtendRight
				y1 = WOD - signWallIsLeft * sqr(radBoard^2 - x1^2) - thkPlasterAtBoardRight * sin(alfaRightInnJamb)
				x1 = x1 - thkPlasterAtBoardRight * cos(alfaRightInnJamb)
				x2 = x1 + thkPlasterAtBoardRight * sin(alfaRightInnJamb)
				y2 = y1 - thkPlasterAtBoardRight * cos(alfaRightInnJamb)
				xo = 0
				yo = WOD
				ro = radBoard

				gosub 101	! Circle - Line intersection

				if ya > yb then
					pxR1 = xa
					pyR1 = ya
				else
					pxR1 = xb
					pyR1 = yb
				endif

				alpha = alfaRightInnJamb
			else
				pxR1 = cx + opInner / 2 + parapetExtendRight
				pyR1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxR1^2)

				alpha = abs(asn(pxR1 / radBoard))
			endif
			pxR2 = pxR1 + signWallIsLeft * tan(alpha) * abs(pyR1 - insetY)
			pyR2 = insetY

			rotx 90
			addz SYMB_POS_Y - act_st_pos - parapet_height - thkPlasterAtBoardBottom * gs_parapet_autodim

			wallniche 6, 1, 2,
				0,0, 1,	parapet_height + thkPlasterAtBoardBottom * gs_parapet_autodim,
				 pxR2, pyR2,	31,
				 pxR1, pyR1,	31,
				 pxR1, 1,		31,
				 pxL1, 1,		31,
				 pxL1, pyL1,	31,
				 pxL2, pyL2,	31
			del 2
		endif

		del 1
	endif

	if not(wallIsLeft) then

		material matRevealSide

! =============================================================================
! Outer Side Cut - Curved NonLeft Wall
! =============================================================================

		if (WIDO_SILL > EPS | not(gs_IsCurved)) & not(bOneCut) then

			leftJamb	= leftWidth  + WOD * tan(alfaLeftOs  - alfaLeftJamb)  + gs_left_oversize
			rightJamb	= rightWidth + WOD * tan(alfaRightOs - alfaRightJamb) + gs_right_oversize

			if gs_stack_left	then leftJamb	= 0
			if gs_stack_right	then rightJamb	= 0

			thkPlasterAtSillLeft_distx	= thkPlasterAtSillLeft  / cos(alfaLeftOs  - alfaLeftJamb)
			thkPlasterAtSillRight_distx	= thkPlasterAtSillRight / cos(alfaRightOs - alfaRightJamb)

			px1 =  leftWidth  - leftJamb  + overSizeLeft  + thkPlasterAtSillLeft_distx  - SillPlasterAtFrame * tan(alfaLeftOs  - alfaLeftJamb)
			px2 = -rightWidth + rightJamb - overSizeRight - thkPlasterAtSillRight_distx + SillPlasterAtFrame * tan(alfaRightOs - alfaRightJamb)

			! Searching for new plaster offset centerpoint
			x11 = px1
			y11 = WOD + SillPlasterAtFrame
			x12 = thkPlasterAtSillLeft_distx
			y12 = 0

			x21 = px2
			y21 = WOD + SillPlasterAtFrame
			x22 = -thkPlasterAtSillRight_distx
			y22 = 0

			gosub 100			! Line - Line intersection

			cutMethod	= 3

			_bCustomMatNicheTop			= bCustomMatNicheTop
			_wallNicheSurfaceLeft		= matRevealSide
			_wallNicheSurfaceRight		= matRevealSide
			_wallNicheSurfaceBottom		= matRevealSide
			_wallNicheSurfaceTop		= matNicheTop

			if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then
				cutStatus	= 2 + 256 * _bCustomMatNicheTop
			else
				cutStatus	= 2
			endif

			cutVectX	= cx
			cutVectY	= 0
			cutVectZ	= WOD + cy + SillPlasterAtFrame
			cutDepth	= abs(WOD)

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower
			sideTop		= B + overSizeUpper

			offLeft		= leftWidth  - abs(WOD) * tan(alfaLeftOs  - alfaLeftJamb)  + gs_left_oversize  + thkPlasterAtSillLeft_distx  + SillPlasterAtFrame * tan(alfaLeftOs  - alfaLeftJamb)
			offRight	= rightWidth - abs(WOD) * tan(alfaRightOs - alfaRightJamb) + gs_right_oversize + thkPlasterAtSillRight_distx + SillPlasterAtFrame * tan(alfaRightOs - alfaRightJamb)
			offTop		= upperJamb + thkPlasterAtSillTop
			offBottom	= lowerJamb + thkPlasterAtSillBottom

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if iWindowShape = SHAPE_GOTHICARCH then
				centArcoffs		= centSillArcoffs
			endif

			if iWindowShape = SHAPE_OGEECENTERED then
				centArcoffs		= centSillArcoffs
			endif

			if iWindowShape = SHAPE_SARACENIC then
				tangArcx		= SilltangArcx
				tangArcy		= SilltangArcy
				centArcoffs		= centSillArcoffs
			endif

			if iWindowShape = SHAPE_HORSESHOE then
				LowArcoffsy		= SillLowArcoffsy
				LowArcoffsx		= SillLowArcoffsx
				HighArcoffs		= SillHighArcoffs
			endif

			if iWindowShape = SHAPE_HALFARCH then
				Topx	= SillTopx
				Topy	= SillTopy
				Shouldx	= SillShouldx
				Shouldy	= SillShouldy
			endif

			if bTShapedOpening then
				offSlLeft			= gs_reveal_left_sL   + thkPlasterAtSillSLLeft
				offSlRight			= gs_reveal_right_sR  + thkPlasterAtSillSLRight
				offSlLeftBottom		= gs_reveal_bottom_sL + thkPlasterAtSillSlLeftBottom
				offSlRightBottom	= gs_reveal_bottom_sR + thkPlasterAtSillSlRightBottom
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = 1
			endif

			addz -SillPlasterAtFrame
			gosub 2000
			del 1
		endif


! =============================================================================
! Plaster Layer Outer Side Cut - Curved NonLeft Wall
! =============================================================================

		if SillPlasterAtFrame > EPS then
			cutMethod	= 1
			cutStatus	= 2	! Finite cut
			cutVectX	= 0
			cutVectY	= 0
			cutVectZ	= -1
			cutDepth	= SillPlasterAtFrame

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower						 !- bSillIsHorizontal * bBoardElevUsa
			sideTop		= B + overSizeUpper

			offLeft		= thkPlasterAtSillLeft  - ((gs_stack_left  | bLeftCornerFunction)  * SillPlasterAtFrame) * tan(alfaLeftOs)
			offRight	= thkPlasterAtSillRight - ((gs_stack_right | bRightCornerFunction) * SillPlasterAtFrame) * tan(alfaRightOs)
			offTop		= thkPlasterAtSillTop	  + (thkPlasterAtSillTop    < EPS) * gs_reveal_top
			offBottom	= thkPlasterAtSillBottom  + (thkPlasterAtSillBottom < EPS) * gs_reveal_bottom

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if bTShapedOpening then
				offSlLeft			= thkPlasterAtSillSlLeft
				offSlRight			= thkPlasterAtSillSlRight
				offSlLeftBottom		= thkPlasterAtSillSlLeftBottom  + (thkPlasterAtSillSlLeftBottom  < EPS) * gs_reveal_bottom
				offSlRightBottom	= thkPlasterAtSillSlRightBottom + (thkPlasterAtSillSlRightBottom < EPS) * gs_reveal_bottom
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = 1
			endif

			gosub 2000
		endif


! =============================================================================
! Inner Side Cut - Curved NonLeft Wall
! =============================================================================

		material matOppositeSide

		if not(bSlantedInnerSide) then
			thkPlasterAtBoardLeft_distx	 = thkPlasterAtBoardLeft  / cos(alfaLeftInnJamb)
			thkPlasterAtBoardRight_distx = thkPlasterAtBoardRight / cos(alfaRightInnJamb)

			if iRevealType = REVEAL_DOUBLE then
				dxL = WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
				dxR = WIDO_FRAME_THICKNESS * tan(alfaRightOs)
			else
				dxL = 0
				dxR = 0
			endif

			px1 =  rightWidth + overSizeRight - CustRevealRightJamb - thkPlasterAtBoardRight_distx - BoardPlasterAtFrame * tan(alfaRightInnJamb) + dxR
			px2 = -leftWidth  - overSizeLeft  + CustRevealLeftJamb  + thkPlasterAtBoardLeft_distx  + BoardPlasterAtFrame * tan(alfaLeftInnJamb)  - dxL

			! Searching for new plaster offset centerpoint
			x11 = px1
			y11 = tempWOD + BoardPlasterAtFrame + (WIDO_FRAME_THICKNESS * (iRevealType = REVEAL_DOUBLE))
			x12 = -thkPlasterAtBoardRight_distx
			y12 = 0

			x21 = px2
			y21 = tempWOD + BoardPlasterAtFrame + (WIDO_FRAME_THICKNESS * (iRevealType = REVEAL_DOUBLE))
			x22 = thkPlasterAtBoardLeft_distx
			y22 = 0

			gosub 100			! Line - Line intersection

			cutZ = WOD - (iRevealType = REVEAL_DOUBLE) * WIDO_FRAME_THICKNESS + cy - BoardPlasterAtFrame

			cutMethod	= 3
			cutStatus	= 2 + 8 * (not(bReveal) | bOneCut) + 16
			cutVectX	= cx
			cutVectY	= 0
			cutVectZ	= cutZ
			cutDepth	= 0

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower - bSillIsHorizontal * bBoardElevUsa
			sideTop		= B + overSizeUpper

			offLeft		= CustRevealLeftJamb  + thkPlasterAtBoardLeft_distx  - BoardPlasterAtFrame * tan(alfaLeftInnJamb)  - dxL
			offRight	= CustRevealRightJamb + thkPlasterAtBoardRight_distx - BoardPlasterAtFrame * tan(alfaRightInnJamb) - dxR
			offTop		= CustRevealTopJamb   + thkPlasterAtBoardTop
			offBottom	= CustRevealBottJamb  + thkPlasterAtBoardBottom

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if iWindowShape = SHAPE_GOTHICARCH then
				centArcoffs		= centBoardArcoffs
			endif

			if iWindowShape = SHAPE_OGEECENTERED then
				centArcoffs		= centBoardArcoffs
			endif

			if iWindowShape = SHAPE_SARACENIC then
				tangArcx		= BoardtangArcx
				tangArcy		= BoardtangArcy
				centArcoffs		= centBoardArcoffs
			endif

			if iWindowShape = SHAPE_HORSESHOE then
				LowArcoffsy		= BoardLowArcoffsy
				LowArcoffsx		= BoardLowArcoffsx
				HighArcoffs		= BoardHighArcoffs
			endif

			if iWindowShape = SHAPE_HALFARCH then
				Topx	= BoardTopx
				Topy	= BoardTopy
				Shouldx	= BoardShouldx
				Shouldy	= BoardShouldy
			endif

			if bTShapedOpening then
				offSlLeft			= gs_reveal_double_innerLeft_sL   + thkPlasterAtBoardSlLeft
				offSlRight			= gs_reveal_double_innerRight_sR  + thkPlasterAtBoardSlRight
				offSlLeftBottom		= gs_reveal_double_innerBottom_sL + thkPlasterAtBoardSlLeftBottom
				offSlRightBottom	= gs_reveal_double_innerBottom_sR + thkPlasterAtBoardSlRightBottom
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = openingHeight / (openingHeight + (2 * WIDO_FRAME_THICKNESS * tan(alfaRightOs)))
			endif

			addz (iRevealType = REVEAL_DOUBLE) * WIDO_FRAME_THICKNESS + BoardPlasterAtFrame
			gosub 2000
			del 1
		endif


! =============================================================================
! Plaster Layer Inner Side Cut - Curved NonLeft Wall
! =============================================================================

		if not(bSlantedInnerSide) & BoardPlasterAtFrame > EPS then

			if iRevealType = REVEAL_DOUBLE then
				dxL = WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
				dxR = WIDO_FRAME_THICKNESS * tan(alfaRightOs)
			else
				dxL = 0
				dxR = 0
			endif

			cutMethod	= 1
			cutStatus	= 2 + 16
			cutVectX	= 0
			cutVectY	= 0
			cutVectZ	= -1
			cutDepth	= -WIDO_FRAME_THICKNESS

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower - bSillIsHorizontal * bBoardElevUsa
			sideTop		= B + overSizeUpper

			offLeft		= thkPlasterAtBoardLeft  - dxL
			offRight	= thkPlasterAtBoardRight - dxR
			offTop		= thkPlasterAtBoardTop	  + (thkPlasterAtBoardTop    < EPS) * (CustRevealTopJamb  + offsetInsideTop)
			offBottom	= thkPlasterAtBoardBottom + (thkPlasterAtBoardBottom < EPS) * (CustRevealBottJamb + offsetInsideBott)

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if bTShapedOpening then
				offSlLeft			= thkPlasterAtBoardSlLeft
				offSlRight			= thkPlasterAtBoardSlRight
				offSlLeftBottom		= thkPlasterAtBoardSlLeftBottom  + (thkPlasterAtBoardSlLeftBottom  < EPS) * (CustRevealBottJamb + offsetInsideBott)
				offSlRightBottom	= thkPlasterAtBoardSlRightBottom + (thkPlasterAtBoardSlRightBottom < EPS) * (CustRevealBottJamb + offsetInsideBott)
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = openingHeight / (openingHeight + (2 * WIDO_FRAME_THICKNESS * tan(alfaRightOs)))
			endif

			gosub 2000
		endif


! =============================================================================
! Slanted Inner Side Cut - Curved NonLeft Wall
! =============================================================================

		if bSlantedInnerSide then
			addz WALL_THICKNESS - WIDO_SILL

			if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then
				gs_slanted_left_angle		= gs_reveal_left_angle
				gs_slanted_right_angle		= gs_reveal_right_angle
				gs_slanted_bottom_angle		= gs_reveal_bottom_angle
				gs_slanted_top_angle		= gs_reveal_top_angle
				thkPlasterAtSlantedLeft		= thkPlasterAtBoardLeft
				thkPlasterAtSlantedRight	= thkPlasterAtBoardRight
				thkPlasterAtSlantedBottom	= thkPlasterAtBoardBottom
				thkPlasterAtSlantedTop		= thkPlasterAtBoardTop
				thkPlasterAtSlanted			= thkPlasterAtBoard
				HalfInfiniteCut				= 1
				slantedDepth		= (WALL_THICKNESS - WIDO_SILL - offsetInsideDepth - not(iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) * thkPlasterAtBoard)
				slantedDepthBottom	= slantedDepth
				slantedCutDepth		= slantedDepth
				offsetDepth		= offsetInsideDepth
				offsetRight		= offsetInsideRight - (iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC) * WIDO_FRAME_THICKNESS * tan(alfaRightOs)
				offsetLeft		= offsetInsideLeft  - (iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC) * WIDO_FRAME_THICKNESS * tan(alfaLeftOs)
				offsetTop		= offsetInsideTop
				offsetBott		= offsetInsideBott + bSillIsHorizontal * bBoardElevUsa
				bWallInsetCut	= 1

				gosub 1000	! Slanted Reveal cutting body
			endif

			del 1
		endif


! =============================================================================
! Slanted Outer Side Cut - Straight Wall
! =============================================================================

		if bSlantedOuterSide then
			if iWindowShape = SHAPE_RECTANGULAR | iWindowShape = SHAPE_ARCHED then

				gs_slanted_left_angle		= gs_reveal_outerLeft_angle  - (alfaLeftOs  - alfaLeftJamb)
				gs_slanted_right_angle		= gs_reveal_outerRight_angle - (alfaRightOs - alfaRightJamb)
				gs_slanted_bottom_angle		= gs_reveal_outerBottom_angle
				gs_slanted_top_angle		= gs_reveal_outerTop_angle
				thkPlasterAtSlantedLeft		= thkPlasterAtSillLeft
				thkPlasterAtSlantedRight	= thkPlasterAtSillRight
				thkPlasterAtSlantedBottom	= thkPlasterAtSillBottom
				thkPlasterAtSlantedTop		= thkPlasterAtSillTop
				thkPlasterAtSlanted			= 0
				HalfInfiniteCut				= 1
				slantedDepth		= WIDO_SILL - gs_reveal_outer_jamb_depth
				slantedDepthBottom	= WIDO_SILL - bHaveMountingFrame * (gs_mountingFrame_depth)
				slantedCutDepth		= WIDO_SILL
				offsetDepth		= offsetOutsideDepth
				offsetRight		= rightWidth - (abs(WOD) - gs_reveal_outer_jamb_depth) * tan(alfaRightOs - alfaRightJamb)
				offsetLeft		= leftWidth  - (abs(WOD) - gs_reveal_outer_jamb_depth) * tan(alfaLeftOs  - alfaLeftJamb)
				offsetTop		= gs_reveal_top
				offsetBott		= gs_reveal_bottom - (not(bHaveMountingFrame) * gs_reveal_outer_jamb_depth + bHaveMountingFrame * (gs_reveal_outer_jamb_depth - gs_mountingFrame_depth)) * tan(gs_reveal_outerBottom_angle)
				bWallInsetCut	= 0

				mulz -1
				addz WIDO_SILL
				gosub 1000	! Slanted Reveal cutting body
				del 2
			endif
		endif


! =============================================================================
! Middle cut at window range - Curved NonLeft Wall
! =============================================================================

		if WIDO_FRAME_THICKNESS > EPS & bNeedMiddleCut then

			cutMethod	= 3
			cutStatus	= 2
			cutVectX	= 0
			cutVectY	= 0
			cutVectZ	= WOD - (iRevealType = REVEAL_SLANTED) * WIDO_FRAME_THICKNESS
			if iRevealType = REVEAL_SLANTED then
				cutDepth	= WIDO_FRAME_THICKNESS
			else
				cutDepth	= -WIDO_FRAME_THICKNESS
			endif

			sideRight	= rightWidth + overSizeRight
			sideLeft	= leftWidth  + overSizeLeft
			sideBottom	= overSizeLower
			sideTop		= B + overSizeUpper

			offLeft		= -WIDO_FRAME_THICKNESS * tan(alfaLeftOs)  * (iRevealType = REVEAL_SLANTED)
			offRight	= -WIDO_FRAME_THICKNESS * tan(alfaRightOs) * (iRevealType = REVEAL_SLANTED)
			offTop		= 0
			offBottom	= 0

			if iWindowShape = SHAPE_ELLIPSEARCH then
				smallRadiusEllips_offset	= smallRadiusEllips - offLeft
				middleRadiusEllips_offset	= middleRadiusEllips - offLeft
			endif

			if iWindowShape = SHAPE_HALFARCH then
				Topx	= FrameTopx
				Topy	= FrameTopy
				Shouldx	= FrameShouldx
				Shouldy	= FrameShouldy
			endif

			if iWindowShape = SHAPE_MULTISIDE | iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
				MulRat = openingHeight / (openingHeight + (2 * WIDO_FRAME_THICKNESS * tan(alfaRightOs)))
			endif

			if iWindowShape = SHAPE_HORSESHOE then
				LowArcoffsy		= FrameLowArcoffsy
				LowArcoffsx		= FrameLowArcoffsx
				HighArcoffs		= FrameHighArcoffs
			endif

			if bTShapedOpening then
				offSlLeft			= 0
				offSlRight			= 0
				offSlLeftBottom		= 0
				offSlRightBottom	= 0
			endif

			if iRevealType = REVEAL_SLANTED then
				gs_slanted_left_angle		= gs_reveal_left_angle
				gs_slanted_right_angle		= gs_reveal_right_angle
				gs_slanted_bottom_angle		= gs_reveal_bottom_angle
				gs_slanted_top_angle		= gs_reveal_top_angle
				thkPlasterAtSlantedLeft		= 0
				thkPlasterAtSlantedRight	= 0
				thkPlasterAtSlantedBottom	= 0
				thkPlasterAtSlantedTop		= 0
				thkPlasterAtSlanted			= 0
				HalfInfiniteCut				= 0
				slantedDepth		= WIDO_FRAME_THICKNESS
				slantedDepthBottom	= slantedDepth
				slantedCutDepth		= slantedDepth
				offsetDepth		= offsetInsideDepth
				offsetRight		= offsetInsideRight
				offsetLeft		= offsetInsideLeft
				offsetTop		= offsetInsideTop
				offsetBott		= offsetInsideBott
				bWallInsetCut	= 0

				addz WIDO_FRAME_THICKNESS
				gosub 1000	! Slanted Reveal cutting body
				del 1
			else
				gosub 2000
			endif
		endif


! =============================================================================
! Cut Wall Inset - Curved NonLeft Wall
! =============================================================================

		if bParapetWallInset & SYMB_POS_Y > overSizeLower & not(isParIns) & parapet_height > EPS & (SYMB_POS_Y - act_st_pos) > EPS then

			insetY = WOD - signWallIsLeft * radBoard - parapetWallInsetDepth

			if gs_parapet_autodim & thkPlasterAtBoardLeft > EPS then
				x1 = cx - opInner / 2 - parapetExtendLeft
				y1 = WOD - signWallIsLeft * sqr(radBoard^2 - x1^2) + thkPlasterAtBoardLeft * sin(alfaLeftInnJamb)
				x1 = x1 + thkPlasterAtBoardLeft * cos(alfaLeftInnJamb)
				x2 = x1 + thkPlasterAtBoardLeft * sin(alfaLeftInnJamb)
				y2 = y1 - thkPlasterAtBoardLeft * cos(alfaLeftInnJamb)
				xo = 0
				yo = WOD
				ro = radBoard

				gosub 101	! Circle - Line intersection

				if ya > yb then
					pxL1 = xa
					pyL1 = ya
				else
					pxL1 = xb
					pyL1 = yb
				endif

				alpha = alfaLeftInnJamb
			else
				pxL1 = cx - opInner / 2 - parapetExtendLeft
				pyL1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxL1^2)

				alpha = abs(asn(pxL1 / radBoard))
			endif
			pxL2 = pxL1 - signWallIsLeft * tan(alpha) * abs(pyL1 - insetY)
			pyL2 = insetY
			pxL1 = pxL1 - sin(alfaLeftInnJamb)
			pyL1 = pyL1 + cos(alfaLeftInnJamb)

			if gs_parapet_autodim & thkPlasterAtBoardRight > EPS then
				x1 = cx + opInner / 2 + parapetExtendRight
				y1 = WOD - signWallIsLeft * sqr(radBoard^2 - x1^2) + thkPlasterAtBoardRight * sin(alfaRightInnJamb)
				x1 = x1 - thkPlasterAtBoardRight * cos(alfaRightInnJamb)
				x2 = x1 - thkPlasterAtBoardRight * sin(alfaRightInnJamb)
				y2 = y1 - thkPlasterAtBoardRight * cos(alfaRightInnJamb)
				xo = 0
				yo = WOD
				ro = radBoard

				gosub 101	! Circle - Line intersection

				if ya > yb then
					pxR1 = xa
					pyR1 = ya
				else
					pxR1 = xb
					pyR1 = yb
				endif

				alpha = alfaRightInnJamb
			else
				pxR1 = cx + opInner / 2 + parapetExtendRight
				pyR1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxR1^2)

				alpha = abs(asn(pxR1 / radBoard))
			endif
			pxR2 = pxR1 + signWallIsLeft * tan(alpha) * abs(pyR1 - insetY)
			pyR2 = insetY
			pxR1 = pxR1 + sin(alfaRightInnJamb)
			pyR1 = pyR1 + cos(alfaRightInnJamb)

			rotx 90
			addz SYMB_POS_Y - act_st_pos - parapet_height - gs_parapet_autodim * thkPlasterAtBoardRight

			wallniche 6, 1, 2,
				0,0, 1,	parapet_height + gs_parapet_autodim * thkPlasterAtBoardRight,
				 pxR2, pyR2,	31,
				 pxR1, pyR1,	31,
				 pxR1, 1,		31,
				 pxL1, 1,		31,
				 pxL1, pyL1,	31,
				 pxL2, pyL2,	31
			del 2

		endif

	endif

	del (SYMB_ROTANGLE > EPS) + WIDO_REVEAL_SIDE
endif

del 1	! addz -SymbolMid_shiftDy


! ==============================================================================
! Mounting Frame
! ==============================================================================

if bHaveMountingFrame & lod3D_MountingFrame > 0 then
	if iWindowShape = SHAPE_ARCHED then
		gs_stack_left 	= 0
		gs_stack_right 	= 0
		gs_stack_bottom = 0
		gs_stack_top	= 0
	endif

	material gs_mountingFrame_mat
	pen gs_mountingFrame_pen_view
	sect_fill gs_mountingFrame_fill, gs_mountingFrame_pen_bg, gs_mountingFrame_pen_fg, gs_mountingFrame_pen_cont

	pxL1 = -leftWidth - (bLeftCornerFunction | gs_stack_left) * (lx * gs_mountingFrame_depth + 1.0)
	pxL2 = pxL1 + gs_mountingFrame_width_left
	pxR1 = rightWidth + (bRightCornerFunction | gs_stack_right) * (rx * gs_mountingFrame_depth + 1.0)
	pxR2 = pxR1- gs_mountingFrame_width_right

	pyB1 = -overSizeLower - (gs_stack_bottom * 1.0) + (ac_wallhole_height - ac_wallhole_height_original)*(ac_wallhole_height_original > EPS)
	pyB2 = pyB1 + gs_mountingFrame_width_bottom
	pyT1 = openingHeight + overSizeUpper + (gs_stack_top * 1.0)
	pyT2 = pyT1 - gs_mountingFrame_width_top

	if WIDO_REVEAL_SIDE then
		addz WIDO_FRAME_THICKNESS
	else
		mulz -1
	endif

	numCuts = 0

	if bRightCornerFunction then
		add rightRevealPnts[idxSillStartRevealRight][1], 0, -rightRevealPnts[idxSillStartRevealRight][2]
		roty -rightCornerAngle / 2
		cutplane 180
		numCuts = 1
		del 2
	endif

	if bLeftCornerFunction then
		add leftRevealPnts[idxSillStartRevealLeft][1], 0, -leftRevealPnts[idxSillStartRevealLeft][2]
		roty leftCornerAngle / 2
		cutplane 180
		numCuts = numCuts + 1
		del 2
	endif

	if gs_stack_left then
		cutpolya 4, 2, 0,
			-leftWidth, pyB1-0.01,	13,
			pxL1-0.01,  pyB1-0.01,	15,
			pxL1-0.01,	pyT1+0.01,	15,
			-leftWidth,	pyT1+0.01,	8
		numCuts = numCuts + 1
	endif

	if gs_stack_right then
		cutpolya 4, 2, 0,
			rightWidth, pyB1-0.01,	13,
			pxR1+0.01,  pyB1-0.01,	15,
			pxR1+0.01,	pyT1+0.01,	15,
			rightWidth,	pyT1+0.01,	8
		numCuts = numCuts + 1
	endif

	if gs_stack_bottom then
		cutpolya 4, 2, 0,
			pxL1-0.01,	-overSizeLower,	8,
			pxR1+0.01,  -overSizeLower,	13,
			pxR1+0.01,	pyB1-0.01,		15,
			pxL1-0.01,	pyB1-0.01,		15
		numCuts = numCuts + 1
	endif

	if gs_stack_top then
		cutpolya 4, 2, 0,
			pxL1-0.01,	openingHeight + overSizeUpper, 8,
			pxR1+0.01,	openingHeight + overSizeUpper, 13,
			pxR1+0.01,	pyT1+0.01,		15,
			pxL1-0.01,	pyT1+0.01,		15
		numCuts = numCuts + 1
	endif

	if iWindowShape = SHAPE_ARCHED then
		hs = openingHeight - archHeight
		rr = (archHeight^2 + (leftWidth)^2) / 2 / archHeight

		! Cut space for mounting frame in the turned plaster layer
		if thkPlasterAtSill > EPS | (curvedWall & not(wallIsLeft)) then
			wallniche 5, 1, 2,
				0,0, 1,	gs_mountingFrame_depth,
				 -leftWidth, 	0,					31,
				 -leftWidth, 	hs, 				31,
				 0, 			openingHeight-rr, 	931,
				 rightWidth,	hs, 				3031,
				 rightWidth,	0,					31
		endif

		archHeight2 = rr-(rr-gs_mountingFrame_width_left) * sin( acs( (leftWidth-gs_mountingFrame_width_left)/(rr-gs_mountingFrame_width_left)))

		if not(gs_stack_bottom) then
			hotspot pxL2, pyB2, 0, 11050
		endif
		if not(gs_stack_bottom) then
			hotspot pxR2, pyB2, 0, 11051
		endif

		hotspot pxL2, pyT1-archHeight2, 0, 11052
		hotspot pxR2, pyT1-archHeight2, 0, 11053
		hotspot 0, pyT2, 0, 11054

		if GLOB_CONTEXT = 4 then
			poly_ 13,
				pxL1,	pyB1, 1,
				pxL1,	pyT1-archHeight, 1,
				0, 	openingHeight-rr, 901,
				pxR1,	pyT1-archHeight, 3001,
				pxR1,	pyB1, 1,
				pxL1,	pyB1, -1,

				pxL2,	pyB2, 1,
				pxL2,	pyT1-archHeight2-EPS, 1,
				pxL2,	pyT1-archHeight2, 1,
				0, 	openingHeight-rr, 901,
				pxR2,	pyT1-archHeight2, 3001,
				pxR2,	pyB2, 1,
				pxL2,	pyB2, -1
		endif
		prism_ 13, gs_mountingFrame_depth,
			 pxL1,	pyB1, 15,
			 pxL1,	pyT1-archHeight, 79,
			 0, 	openingHeight-rr, 915,
			 pxR1,	pyT1-archHeight, 3015,
			 pxR1,	pyB1, 15,
			 pxL1,	pyB1, -1,

			 pxL2,	pyB2, 15,
			 pxL2,	pyT1-archHeight2-EPS, 13,
			 pxL2,	pyT1-archHeight2, 79,
			 0, 	openingHeight-rr, 915,
			 pxR2,	pyT1-archHeight2, 3015,
			 pxR2,	pyB2, 15,
			 pxL2,	pyB2, -1
	else
		! Cut space for mounting frame in the turned plaster layer
		if thkPlasterAtSill > EPS | (curvedWall & not(wallIsLeft)) then
			wallniche 4, 1, 2,
				0,0, 1,	gs_mountingFrame_depth,
				 -leftWidth, -overSizeLower,				 31,
				 -leftWidth,  openingHeight + overSizeUpper, 31,
				 rightWidth,  openingHeight + overSizeUpper, 31,
				 rightWidth, -overSizeLower,				 31
		endif

		if not(gs_stack_left | bLeftCornerFunction | gs_stack_bottom) then
			hotspot pxL2, pyB2, 0, 11050
		endif
		if not(gs_stack_right | bRightCornerFunction | gs_stack_bottom) then
			hotspot pxR2, pyB2, 0, 11051
		endif

		if not(gs_stack_left | bLeftCornerFunction | gs_stack_top) then
			hotspot pxL2, pyT2, 0, 11052
		endif
		if not(gs_stack_right | bRightCornerFunction | gs_stack_top) then
			hotspot pxR2, pyT2, 0, 11053
		endif

		if GLOB_CONTEXT = 4 then
			plane_ 10,
				 pxL1,	pyB1, 0, 1,
				 pxL1,	pyT1, 0, 1,
				 pxR1,	pyT1, 0, 1,
				 pxR1,	pyB1, 0, 1,
				 pxL1,	pyB1, 0, -1,

				 pxL2,	pyB2, 0, 1,
				 pxL2,	pyT2, 0, 1,
				 pxR2,	pyT2, 0, 1,
				 pxR2,	pyB2, 0, 1,
				 pxL2,	pyB2, 0, -1
		endif

		prism_ 10,gs_mountingFrame_depth,
			 pxL1,	pyB1, 15,
			 pxL1,	pyT1, 15,
			 pxR1,	pyT1, 15,
			 pxR1,	pyB1, 15,
			 pxL1,	pyB1, -1,

			 pxL2,	pyB2, 15,
			 pxL2,	pyT2, 15,
			 pxR2,	pyT2, 15,
			 pxR2,	pyB2, 15,
			 pxL2,	pyB2, -1
	endif

	del 1

	for i=1 to numCuts
		cutend
	next i
endif


! ==============================================================================
 end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
! ==============================================================================



1000:
! ==============================================================================
! Slanted Reveal cutting body
! ==============================================================================

! Similar as in MasonryArch macro

	if gs_stack_top		then gs_slanted_top_angle	 = 0
	if gs_stack_bottom	then gs_slanted_bottom_angle = 0

	! 3D turn plaster offsets
	if iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED then
		offsetSlantedLeft	= offsetLeft  + not(bLeftCornerFunction  | gs_stack_left)  * (thkPlasterAtSlantedLeft  / cos(gs_slanted_left_angle))
		offsetSlantedRight	= offsetRight + not(bRightCornerFunction | gs_stack_right) * (thkPlasterAtSlantedRight / cos(gs_slanted_right_angle))
		offsetSlantedBott	= offsetBott  + not(gs_stack_bottom) * (thkPlasterAtSlantedBottom / cos(gs_slanted_bottom_angle))
		offsetSlantedTop	= offsetTop   + not(gs_stack_top)    * (thkPlasterAtSlantedTop    / cos(gs_slanted_top_angle))
	else
		offsetSlantedLeft	= offsetLeft  - not(bLeftCornerFunction  | gs_stack_left)  * (thkPlasterAtSlanted * tan(gs_slanted_left_angle)  - thkPlasterAtSlantedLeft  / cos(gs_slanted_left_angle))
		offsetSlantedRight	= offsetRight - not(bRightCornerFunction | gs_stack_right) * (thkPlasterAtSlanted * tan(gs_slanted_right_angle) - thkPlasterAtSlantedRight / cos(gs_slanted_right_angle))
		offsetSlantedBott	= offsetBott  - not(gs_stack_bottom) * (thkPlasterAtSlanted * tan(gs_slanted_bottom_angle) - thkPlasterAtSlantedBottom / cos(gs_slanted_bottom_angle))
		offsetSlantedTop	= offsetTop   - not(gs_stack_top)    * (thkPlasterAtSlanted * tan(gs_slanted_top_angle)    - thkPlasterAtSlantedTop    / cos(gs_slanted_top_angle))
	endif

	if abs(SYMB_POS_Y) < EPS then
		offsetSlantedBott = offsetSlantedBott - EPS
	endif

	dxl = (not(bLeftCornerFunction  | gs_stack_left)  | curvedWall) * slantedDepth * tan(gs_slanted_left_angle)		! --- Left
	dxr = (not(bRightCornerFunction | gs_stack_right) | curvedWall) * slantedDepth * tan(gs_slanted_right_angle)	! --- Right
	dxt = not(gs_stack_top)    * slantedDepth * tan(gs_slanted_top_angle)											! --- Top
	dxb = not(gs_stack_bottom) * slantedDepth * tan(gs_slanted_bottom_angle)										! --- Bottom

	if bLeftCornerFunction	then gs_slanted_left_angle	= 0
	if bRightCornerFunction	then gs_slanted_right_angle	= 0

	if iWindowShape = SHAPE_ARCHED then
		if bHalfCircle then
			arcRComponentY = 0
		else
			arcRComponentY = sqr(arcR^2 - rightWidth^2)
		endif
		if arcR + dxr - offsetSlantedRight > rightWidth + dxl - offsetSlantedRight then
			shm = sqr((arcR + dxr - offsetSlantedRight)^2 - (rightWidth + dxl - offsetSlantedRight)^2) - arcRComponentY
		else
			shm = 0
		endif
	endif

! Plaster Layer Cut ------------------------------------------------------------

	if not(iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) & thkPlasterAtSlanted > EPS then
		if iWindowShape = SHAPE_RECTANGULAR then
			if bLeftCornerFunction  then
				pxL = -leftWidth  - 10
			else
				pxL = -leftWidth  + thkPlasterAtSlantedLeft
			endif
			if bRightCornerFunction  then
				pxR = rightWidth + 10
			else
				pxR = rightWidth - thkPlasterAtSlantedRight
			endif
			wallniche 4, 1, 2 + 16,
				0,0,-slantedDepth-thkPlasterAtSlanted, slantedDepth + thkPlasterAtSlanted,
				pxR,	thkPlasterAtSlantedBottom + (thkPlasterAtSlantedBottom < EPS) * (CustRevealBottJamb + offsetInsideBott),	31,
				pxL,	thkPlasterAtSlantedBottom + (thkPlasterAtSlantedBottom < EPS) * (CustRevealBottJamb + offsetInsideBott),	31,
				pxL,	B - thkPlasterAtSlantedTop,	31,
				pxR,	B - thkPlasterAtSlantedTop,	31
		endif
		if iWindowShape = SHAPE_ARCHED then
			if bHalfCircle then
				wallniche 5, 1, 2 + 16,
					0,0,-slantedDepth-thkPlasterAtSlanted, slantedDepth + thkPlasterAtSlanted,
					 rightWidth - thkPlasterAtSlantedRight,	thkPlasterAtSlantedBottom,	31,
					 rightWidth - thkPlasterAtSlantedRight,	B - archHeight,				95,
					 0,								 		1,							895,
					-leftWidth  + thkPlasterAtSlantedLeft,	B - archHeight,				1095,
					-leftWidth  + thkPlasterAtSlantedLeft,	thkPlasterAtSlantedBottom,	31
			else
				wallniche 5, 1, 2 + 16,
					0,0,-slantedDepth-thkPlasterAtSlanted, slantedDepth + thkPlasterAtSlanted,
					(rightWidth - leftWidth) / 2,			B - arcR,					900,
					 rightWidth - thkPlasterAtSlantedRight,	thkPlasterAtSlantedBottom,	31,
					 rightWidth - thkPlasterAtSlantedRight,	B - archHeight,				95,
					-leftWidth  + thkPlasterAtSlantedLeft,	B - archHeight,				3095,
					-leftWidth  + thkPlasterAtSlantedLeft,	thkPlasterAtSlantedBottom,	31
			endif
		endif
	endif

! Cut type selection -----------------------------------------------------------

	slantedOpeningWidth	 = openingWidth  - offsetSlantedRight - offsetSlantedLeft	! Width at frame
	slantedOpeningHeight = openingHeight - offsetSlantedBott  - offsetSlantedTop	! Height at frame

	slantedOpeningWidthSide	 = slantedOpeningWidth  + dxr + dxl	! Width at wall side
	slantedOpeningHeightSide = slantedOpeningHeight + dxb + dxt	! Height at wall side

	magicRatioH = 0.95
	magicRatioV = 0.95

	wallBodyThkHorizontal = slantedDepth * (tan(gs_slanted_left_angle) + tan(gs_slanted_right_angle)) - slantedOpeningWidth
	wallBodyThkVertical   = slantedDepth * (tan(gs_slanted_top_angle) + tan(gs_slanted_bottom_angle)) - slantedOpeningHeight
	bCutEdgesOnly = ((wallBodyThkHorizontal < EPS & wallBodyThkVertical < EPS) & not(curvedWall))

! Horizontal Cutting Body ------------------------------------------------------

	if gs_slanted_left_angle > EPS | gs_slanted_right_angle > EPS then
		if gs_slanted_left_angle > EPS & gs_slanted_right_angle > EPS then
			m = ((tan(gs_slanted_right_angle) / tan(gs_slanted_left_angle)) * ((rightWidth + leftWidth) + dxr  + dxl - (offsetSlantedRight + offsetSlantedLeft))) / (1 + (tan(gs_slanted_right_angle) / tan(gs_slanted_left_angle)))
		else
			m = (rightWidth + leftWidth)/2 + dxr - offsetSlantedRight
		endif

		rxh = m - (rightWidth + leftWidth)/2 - dxr + offsetSlantedRight
		ryh = 0
		if gs_slanted_right_angle > EPS then
			rzh = -m / tan(gs_slanted_right_angle)
		else
			rzh = -m / tan(gs_slanted_left_angle)
		endif

!!!		dh = -sqr(rxh^2 + rzh^2) * slantedCutDepth / rzh	! for method = 2
		dh = slantedCutDepth								! for method = 3
		method = 3
	else
		rxh = 0
		ryh = 0
		rzh = -slantedDepth
		dh	=  slantedCutDepth

		method = 1
	endif

	if abs(rxh^2 + ryh^2 + rzh^2) > EPS then
		if iWindowShape = SHAPE_RECTANGULAR & not(bCutEdgesOnly) then
			addy B/2
			wallniche 4, method, 2 + HalfInfiniteCut * 16,
				-rxh,ryh,rzh, dh,
				 rightWidth + dxr - offsetSlantedRight,	-B/2 + offsetSlantedBott,	24,
				-leftWidth  - dxl + offsetSlantedLeft,	-B/2 + offsetSlantedBott,	31-2,
				-leftWidth  - dxl + offsetSlantedLeft,	 B/2 - offsetSlantedTop,	24,
				 rightWidth + dxr - offsetSlantedRight,	 B/2 - offsetSlantedTop,	31-2
			del 1
		endif
		if iWindowShape = SHAPE_ARCHED & slantedDepth > EPS then

			if gs_slanted_right_angle > EPS then
				method = 2
				shm2 = sqr((arcR - offsetSlantedRight)^2 - (rightWidth - offsetSlantedRight)^2) - arcRComponentY
				rxh = 0
				rzh = -(rightWidth + dxr - offsetSlantedRight) / tan(gs_slanted_right_angle)
				ryh = (shm - shm2) * (rzh / slantedDepth)

				dh	=  slantedCutDepth * ((sqr(ryh^2 + rzh^2))/abs(rzh))
			else
				method = 1
				rxh = 0
				ryh = 0
				rzh = -1
				dh	=  slantedCutDepth
			endif

			py = max(EPS, (B - archHeight - offsetSlantedBott) + XXshm)
			addy (B - archHeight)+shm
			wallniche 4, method, 2 + HalfInfiniteCut * 16,
				-rxh,ryh,rzh, dh,
				 rightWidth + dxr - offsetSlantedRight,	 -py,		31,
				-leftWidth  - dxl + offsetSlantedLeft,	 -py,		31,
				-leftWidth  - dxl + offsetSlantedLeft,	 0,	31,
				 rightWidth + dxr - offsetSlantedRight,	 0,	31
			del 1
		endif
	endif

! Vertical Cutting Body --------------------------------------------------------

	if gs_slanted_top_angle > EPS | gs_slanted_bottom_angle > EPS then
		if iWindowShape = SHAPE_RECTANGULAR then
			if gs_slanted_bottom_angle > EPS & gs_slanted_top_angle > EPS then
				m = ((tan(gs_slanted_top_angle) / tan(gs_slanted_bottom_angle)) * (B + dxt + dxb - (offsetSlantedTop + offsetSlantedBott))) / (1 + (tan(gs_slanted_top_angle) / tan(gs_slanted_bottom_angle)))
			else
				m = B/2 + dxt - offsetSlantedTop
			endif
			method = 1

			rxv = m - B/2 - dxt + offsetSlantedTop
			ryv = 0
			if gs_slanted_top_angle > EPS then
				rzv = -m / tan(gs_slanted_top_angle)
			else
				rzv = -m / tan(gs_slanted_bottom_angle)
			endif

			dv = -sqr(rxv^2 + rzv^2) * slantedCutDepth / rzv
		endif
		if iWindowShape = SHAPE_ARCHED then
			if gs_slanted_bottom_angle > EPS then m = (B - archHeight + dxb - offsetSlantedBott) / tan(gs_slanted_bottom_angle)

			rxv = (B - archHeight)
			ryv = 0
			rzv = -m
			dv = slantedCutDepth
		endif

		method = 2
	else
		rxv = 0
		ryv = 0
		rzv = -slantedDepth
		dv	=  slantedCutDepth

		method = 1
	endif

	if abs(rxh^2 + ryh^2 + rzh^2) > EPS then
		if iWindowShape = SHAPE_RECTANGULAR then
			addy B/2
			rotz 90
			xL =  leftWidth  - not(bLeftCornerFunction  | gs_stack_left)  * (offsetLeft  + thkPlasterAtSlantedLeft)  + bLeftCornerFunction  * overSizeLeft
			xR = -rightWidth + not(bRightCornerFunction | gs_stack_right) * (offsetRight + thkPlasterAtSlantedRight) - bRightCornerFunction * overSizeRight
			if slantedDepthBottom > slantedDepth & gs_slanted_bottom_angle > EPS then
				wallniche 4, method, 2 + HalfInfiniteCut * 16,
					-rxv,ryv,rzv, dv,
					 B/2+dxt - offsetSlantedTop,	xR,	24,
					 0,								xR,	31-2,
					 0,								xL,	24,
					 B/2+dxt - offsetSlantedTop,	xL,	31-2
				if not(curvedWall) | bParalellInCurvedWalls then
!					add -rxv,ryv,rzv
!					roty atn((B/2 + dxb - offsetSlantedBott - rxv) / rzv) + 180
!					wallniche 4, 1, 2 + HalfInfiniteCut * 16,
!						0,0,1, 0,
!						0,		xR,	31,
!						-0.1,	xR,	31,
!						-0.1,	xL,	31,
!						0,		xL,	31
!					del 2

					add -B/2-dxb + offsetSlantedBott, 0, 0
					wallniche 4, 1, 2 + 16,
						sin(gs_slanted_bottom_angle),0,-cos(gs_slanted_bottom_angle), slantedDepthBottom / cos(gs_slanted_bottom_angle),
						0,		xR,	31,
						gs_reveal_outer_jamb_depth * tan(gs_slanted_bottom_angle),	xR,	31,
						gs_reveal_outer_jamb_depth * tan(gs_slanted_bottom_angle),	xL,	31,
						0,		xL,	31
					del 1

!					wallniche 4, 3, 2 + HalfInfiniteCut * 16,
!						-rxv,ryv,rzv, slantedDepthBottom,
!						 0,								xR,	31,
!						-B/2-dxb + offsetSlantedBott,	xR,	31,
!						-B/2-dxb + offsetSlantedBott,	xL,	31,
!						 0,								xL,	31
				endif
			else
				if not(bCutEdgesOnly) & abs(xR - xL) > EPS  then
					wallniche 4, method, 2 + HalfInfiniteCut * 16,
						-rxv,ryv,rzv, dv,
						 B/2+dxt - offsetSlantedTop,	xR,	24,
						-B/2-dxb + offsetSlantedBott,	xR,	31-2,
						-B/2-dxb + offsetSlantedBott,	xL,	24,
						 B/2+dxt - offsetSlantedTop,	xL,	31-2
				endif
			endif
			del 2
		endif
		if iWindowShape = SHAPE_ARCHED & gs_slanted_bottom_angle > EPS then
			rotz 90
			method = 3
			xL =  leftWidth  - (offsetLeft  + thkPlasterAtSlantedLeft)
			xR = -rightWidth + (offsetRight + thkPlasterAtSlantedRight)
!			wallniche 4, method, 2 + HalfInfiniteCut * 16,
!				 rxv, ryv, rzv, dv,
!				 (B - archHeight),			 xL,		24,
!				 -dxb + offsetSlantedBott,	 xL,		31-2,
!				 -dxb + offsetSlantedBott,	 xR,	24,
!				 (B - archHeight),			 xR,	31-2

			if slantedDepthBottom > slantedDepth & gs_slanted_bottom_angle > EPS then
				add -dxb + offsetSlantedBott, 0, 0
				wallniche 4, 1, 2 + 16,
					sin(gs_slanted_bottom_angle),0,-cos(gs_slanted_bottom_angle), slantedDepthBottom / cos(gs_slanted_bottom_angle),
					0,		xR,	31,
					gs_reveal_outer_jamb_depth * tan(gs_slanted_bottom_angle),	xR,	31,
					gs_reveal_outer_jamb_depth * tan(gs_slanted_bottom_angle),	xL,	31,
					0,		xL,	31
				del 1
			endif
			del 1
		endif
	endif

! Top - Right Corner Cutting Body ----------------------------------------------

	if iWindowShape = SHAPE_RECTANGULAR then
		if abs(gs_slanted_top_angle) > EPS then
			ratioTL = tan(gs_slanted_right_angle) / tan(gs_slanted_top_angle)
			if openingWidth > B * ratioTL then
				rytl = 2 * B / 3
				rxtl = rytl * ratioTL
			else
				rxtl = 2 * openingWidth / 3
				rytl = rxtl / ratioTL
			endif

			if abs(gs_slanted_right_angle) > EPS then
				rztl = rxtl / tan(gs_slanted_right_angle)
			else
				rztl = rytl / tan(gs_slanted_top_angle)
			endif
		else
			if abs(gs_slanted_right_angle) > EPS then
				rxtl = 3 * openingWidth / 4
				rytl = 0
				rztl = rxtl / tan(gs_slanted_right_angle)
			else
				rxtl = 0
				rytl = 0
				rztl = 1
			endif
		endif

		vx = (slantedDepth) * tan(gs_slanted_right_angle)
		vy = (slantedDepth) * tan(gs_slanted_top_angle)
		vz = (slantedCutDepth)
		dtl = sqr(vx*vx + vy*vy + vz*vz)

		ratioV = max(1, dtl / sqr(rxtl^2 + rytl^2 + rztl^2) * 2)
		rxtl = rxtl * ratioV
		rytl = rytl * ratioV
		rztl = rztl * ratioV

		if bCutEdgesOnly then
			add rightWidth + gs_right_oversize - offsetSlantedRight, B + gs_upper_oversize - offsetSlantedTop, -slantedDepth
			if bRightCornerFunction then
				pxR = 10
			else
				pxR = 0
			endif
			wallniche 4, 1, 2 + HalfInfiniteCut * 16,
				-rxtl,-rytl,-rztl, -not(HalfInfiniteCut) * dtl,
				 pxR,					 0,						31,
				-slantedOpeningWidth,	 0,						31,
				-slantedOpeningWidth,	-slantedOpeningHeight,	31,
				 pxR,					-slantedOpeningHeight,	31
			del 1
		else
			add rightWidth + gs_right_oversize + dxr - offsetSlantedRight, B + gs_upper_oversize + dxt - offsetSlantedTop, 0
			wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
				-rxtl,-rytl,-rztl, dtl,
				leftDx,											 0,				31,
				magicRatioH * (-slantedOpeningWidthSide + dxl),	 0,				31,
				magicRatioH * (-slantedOpeningWidthSide + dxl),	magicRatioV * (-slantedOpeningHeightSide + dxb),	31,
				leftDx,											magicRatioV * (-slantedOpeningHeightSide + dxb),	31
			del 1
		endif

! Top - Left Corner Cutting Body -----------------------------------------------

		if abs(gs_slanted_top_angle) > EPS then
			ratioTR = tan(gs_slanted_left_angle) / tan(gs_slanted_top_angle)
			if openingWidth > B * ratioTR then
				rytr = 2 * B / 3
				rxtr = rytr * ratioTR
			else
				rxtr = 2 * openingWidth / 3
				rytr = rxtr / ratioTR
			endif

			if abs(gs_slanted_left_angle) > EPS then
				rztr = rxtr / tan(gs_slanted_left_angle)
			else
				rztr = rytr / tan(gs_slanted_top_angle)
			endif
		else
			if abs(gs_slanted_left_angle) > EPS then
				rxtr = 3 * openingWidth / 4
				rytr = 0
				rztr = rxtr / tan(gs_slanted_left_angle)
			else
				rxtr = 0
				rytr = 0
				rztr = 1
			endif
		endif

		vx = (slantedDepth) * tan(gs_slanted_left_angle)
		vy = (slantedDepth) * tan(gs_slanted_top_angle)
		vz = (slantedCutDepth)
		dtr = sqr(vx*vx + vy*vy + vz*vz)

		ratioV = max(1, dtr / sqr(rxtr^2 + rytr^2 + rztr^2) * 2)
		rxtr = rxtr * ratioV
		rytr = rytr * ratioV
		rztr = rztr * ratioV

		if bCutEdgesOnly then
			add -leftWidth - gs_left_oversize + offsetSlantedLeft, B + gs_upper_oversize - offsetSlantedTop, -slantedDepth
			if bLeftCornerFunction then
				pxL = -10
			else
				pxL = 0
			endif
			wallniche 4, 1, 2 + HalfInfiniteCut * 16,
				rxtr,-rytr,-rztr, -not(HalfInfiniteCut) * dtr,
				pxL,				 0,						31,
				slantedOpeningWidth, 0,						31,
				slantedOpeningWidth, -slantedOpeningHeight,	31,
				pxL,				 -slantedOpeningHeight,	31
			del 1
		else
			add -leftWidth - gs_left_oversize - dxl + offsetSlantedLeft, B + gs_upper_oversize + dxt - offsetSlantedTop, 0
			if bRightCornerFunction then
				wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
					rxtr,-rytr,-rztr, dtr,
					rightDx,			 0,				31,
					openingWidth + 10,	 0,				31,
					openingWidth + 10,	-3*B/4 - dxt,	31,
					rightDx,			-3*B/4 - dxt,	31
			else
				wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
					rxtr,-rytr,-rztr, dtr,
					rightDx,										 0,				31,
					magicRatioH * (slantedOpeningWidthSide - dxr),	 0,				31,
					magicRatioH * (slantedOpeningWidthSide - dxr),	magicRatioV * (-slantedOpeningHeightSide + dxb),	31,
					rightDx,										magicRatioV * (-slantedOpeningHeightSide + dxb),	31
			endif
			del 1
		endif
	endif

	if iWindowShape = SHAPE_ARCHED & slantedDepth > EPS then
		! --- Top Arched Cut ---

		if gs_slanted_right_angle > EPS then
			shm2 = sqr((arcR - offsetSlantedRight)^2 - (rightWidth - offsetSlantedRight)^2) - arcRComponentY
			rxh = 0
			rzh = -(rightWidth + dxr - offsetSlantedRight) / tan(gs_slanted_right_angle)
			ryh = (shm - shm2) * (rzh / slantedDepth)

			dh	=  slantedCutDepth * ((sqr(ryh^2 + rzh^2))/abs(rzh))

			x11 = 0
			y11 = 0
			x12 = rzh
			y12 = ryh
			x21 = 0
			y21 = archHeight - offsetSlantedTop + dxt - shm
			x22 = -cos(gs_slanted_right_angle)
			y22 = -sin(gs_slanted_right_angle) + y21
			gosub 100	! Line - Line intersection

!addy (B - archHeight) + shm
!roty -90
!lin_ x11,y11,0, x12,y12,0
!lin_ x21,y21,0, x22,y22,0
!del 2

			rxh2 = 0
			rzh2 = cx
			ryh2 = cy

			dh	=  slantedCutDepth * ((sqr(ryh2^2 + rzh2^2))/abs(rzh2))
			cutMethod = 2	! Pyramidal
		else
			rxh2 = 0
			ryh2 = 0
			rzh2 = -1

			dh	=  slantedCutDepth
			cutMethod = 1	! Prism shaped
		endif

		addy (B - archHeight) + shm
		wallniche 3, cutMethod, 2 + HalfInfiniteCut * 16,
			rxh2, ryh2, rzh2, dh,
			(-leftWidth - dxr + offsetSlantedLeft),		openingHeight - B,								95,
			0, 											openingHeight - arcR - ((B - archHeight) + shm),995,
			(rightWidth + dxl - offsetSlantedRight),	openingHeight - B,								3095
		del 1
	endif

	if abs(gs_slanted_bottom_angle) < EPS then	! Space for Board
		dxb = dxb + overSizeLower
	endif

! Bottom - Right Corner Cutting Body -------------------------------------------

	if abs(gs_slanted_bottom_angle) > EPS then
		ratioBL = tan(gs_slanted_right_angle) / tan(gs_slanted_bottom_angle)
		if openingWidth > B * ratioBL then
			rybl = 2 * B / 3
			rxbl = rybl * ratioBL
		else
			rxbl = 2 * openingWidth / 3
			rybl = rxbl / ratioBL
		endif

		if abs(gs_slanted_right_angle) > EPS then
			rzbl = rxbl / tan(gs_slanted_right_angle)
		else
			rzbl = rybl / tan(gs_slanted_bottom_angle)
		endif
	else
		if abs(gs_slanted_right_angle) > EPS then
			rxbl = 3 * openingWidth / 4
			rybl = 0
			rzbl = rxbl / tan(gs_slanted_right_angle)
		else
			rxbl = 0
			rybl = 0
			rzbl = 1
		endif
	endif

	vx = (slantedDepth) * tan(gs_slanted_right_angle)
	vy = (slantedDepth) * tan(gs_slanted_bottom_angle)
	vz = (slantedCutDepth)
	dbl = sqr(vx*vx + vy*vy + vz*vz)

	ratioV = max(1, dbl / sqr(rxbl^2 + rybl^2 + rzbl^2) * 2)
	rxbl = rxbl * ratioV
	rybl = rybl * ratioV
	rzbl = rzbl * ratioV

	if bCutEdgesOnly then
		add rightWidth + gs_right_oversize - offsetSlantedRight, -gs_lower_oversize + offsetSlantedBott, -slantedDepth
		if bRightCornerFunction then
			pxR = 10
		else
			pxR = 0
		endif
		py = max(EPS, slantedOpeningHeight - (iWindowShape = SHAPE_ARCHED) * (archHeight - offsetSlantedTop) - not(bWallInsetCut) * gs_reveal_outer_jamb_depth)	! not(bWallInsetCut) -> Outside
		wallniche 4, 1, 2 + HalfInfiniteCut * 16,
			-rxbl, rybl,-rzbl, -not(HalfInfiniteCut) * dbl,
			 pxR,				  0,	31,
			-slantedOpeningWidth, 0,	31,
			-slantedOpeningWidth, py,	31,
			 pxR,				  py,	31
		del 1
	else
		add rightWidth + gs_right_oversize + dxr - offsetSlantedRight, -dxb - gs_lower_oversize + offsetSlantedBott, 0
		wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
				-rxbl, rybl,-rzbl, dbl,
				leftDx,											0,																31,
				magicRatioH * (-slantedOpeningWidthSide + dxl), 0,																31,
				magicRatioH * (-slantedOpeningWidthSide + dxl), magicRatioV * (slantedOpeningHeightSide - dxt) - archHeight,	31,
				leftDx,											magicRatioV * (slantedOpeningHeightSide - dxt) - archHeight,	31
		del 1
	endif

! Wall Inset cutting body for Slanted Reveal - Right Side --------------

	if bWallInsetCut & bParapetWallInset & SYMB_POS_Y > overSizeLower & not(WALL_INCL > EPS) & gs_parapet_autodim & parapet_height > EPS then

		if curvedWall & wallIsLeft then
			dy = WOD - radBoard
		else
			dy = radBoard + WOD
		endif
		dd = (dy - (WALL_THICKNESS - WIDO_SILL)) * curvedWall
		vx = (parapetWallInsetDepth - dd) * tan(gs_slanted_right_angle)
		vy = (parapetWallInsetDepth - dd) * tan(gs_slanted_bottom_angle)
		vz = (parapetWallInsetDepth - dd)
		dbl = sqr(vx*vx + vy*vy + vz*vz)

		if abs(gs_slanted_right_angle) > EPS then
			rxbl = 3 * openingWidth / 4
			rzbl = rxbl / tan(gs_slanted_right_angle)
		else
			rxbl = 0
			rzbl = 1
		endif
		rybl = rzbl * tan(gs_slanted_bottom_angle)

		add rightWidth + gs_right_oversize + dxr - offsetSlantedRight, -dxb - gs_lower_oversize + offsetSlantedBott, 0
		wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
			-rxbl, rybl,-rzbl, dbl,
			 leftDx,					-parapet_height*3/4,	31,
			-3 * openingWidth/4 - dxl,	-parapet_height*3/4,	31,
			-3 * openingWidth/4 - dxl,	 0,						31,
			 leftDx,					 0,						31
		del 1

		db2 = sqr(vx*vx + vz*vz)

		add rightWidth + gs_right_oversize + dxr - offsetSlantedRight, -parapet_height, 0
		wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
			-rxbl, 0,-rzbl, db2,
			 leftDx,					 parapet_height*3/4,	31,
			-3 * openingWidth/4 - dxl,	 parapet_height*3/4,	31,
			-3 * openingWidth/4 - dxl,	 0,						31,
			 leftDx,					 0,						31
		del 1

		isParIns = 1

	endif

! Bottom - Left Corner Cutting Body --------------------------------------------

	if abs(gs_slanted_bottom_angle) > EPS then
		ratioBR = tan(gs_slanted_left_angle) / tan(gs_slanted_bottom_angle)
		if openingWidth > B * ratioBR then
			rybr = 2 * B / 3
			rxbr = rybr * ratioBR
		else
			rxbr = 2 * openingWidth / 3
			rybr = rxbr / ratioBR
		endif

		if abs(gs_slanted_left_angle) > EPS then
			rzbr = rxbr / tan(gs_slanted_left_angle)
		else
			rzbr = rybr / tan(gs_slanted_bottom_angle)
		endif
	else
		if abs(gs_slanted_left_angle) > EPS then
			rxbr = 3 * openingWidth / 4
			rybr = 0
			rzbr = rxbr / tan(gs_slanted_left_angle)
		else
			rxbr = 0
			rybr = 0
			rzbr = 1
		endif
	endif

	vx = (slantedDepth) * tan(gs_slanted_left_angle)
	vy = (slantedDepth) * tan(gs_slanted_bottom_angle)
	vz = (slantedCutDepth)
	dbr = sqr(vx*vx + vy*vy + vz*vz)

	ratioV = max(1, dbr / sqr(rxbr^2 + rybr^2 + rzbr^2) * 2)
	rxbr = rxbr * ratioV
	rybr = rybr * ratioV
	rzbr = rzbr * ratioV

	if bCutEdgesOnly then
		add -leftWidth - gs_left_oversize + offsetSlantedLeft, -gs_lower_oversize + offsetSlantedBott, -slantedDepth
		if bLeftCornerFunction then
			pxL = -10
		else
			pxL = 0
		endif
		py = max(EPS, slantedOpeningHeight - (iWindowShape = SHAPE_ARCHED) * (archHeight - offsetSlantedTop) - not(bWallInsetCut) * gs_reveal_outer_jamb_depth)	! not(bWallInsetCut) -> Outside
		wallniche 4, 1, 2 + HalfInfiniteCut * 16,
			rxbr, rybr,-rzbr, -not(HalfInfiniteCut) * dbr,
			pxL,				 0,		31,
			slantedOpeningWidth, 0,		31,
			slantedOpeningWidth, py,	31,
			pxL,				 py,	31
		del 1
	else
		add -leftWidth - gs_left_oversize - dxl + offsetSlantedLeft, -dxb - gs_lower_oversize + offsetSlantedBott, 0
		if bRightCornerFunction then
			wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
				 rxbr, rybr,-rzbr, dbr,
				 rightDx,			 0,								31,
				 openingWidth + 10,	 0,								31,
				 openingWidth + 10,	 3/4*(B - archHeight) + dxt,	31,
				 rightDx,			 3/4*(B - archHeight) + dxt,	31
		else
			wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
				 rxbr, rybr,-rzbr, dbr,
				 rightDx,										0,																31,
				 magicRatioH * (slantedOpeningWidthSide - dxr), 0,																31,
				 magicRatioH * (slantedOpeningWidthSide - dxr), magicRatioV * (slantedOpeningHeightSide - dxt) - archHeight,	31,
				 rightDx,										magicRatioV * (slantedOpeningHeightSide - dxt) - archHeight,	31
		endif
		del 1
	endif

! Wall Inset cutting body for Slanted Reveal - Left Side ---------------

	if bWallInsetCut & bParapetWallInset & SYMB_POS_Y > overSizeLower & not(WALL_INCL > EPS) & gs_parapet_autodim & parapet_height > EPS then

		if curvedWall & wallIsLeft then
			dy = WOD - radBoard
		else
			dy = radBoard + WOD
		endif
		dd = (dy - (WALL_THICKNESS - WIDO_SILL)) * curvedWall
		vx = (parapetWallInsetDepth - dd) * tan(gs_slanted_left_angle)
		vy = (parapetWallInsetDepth - dd) * tan(gs_slanted_bottom_angle)
		vz = (parapetWallInsetDepth - dd)
		dbl = sqr(vx*vx + vy*vy + vz*vz)

		if abs(gs_slanted_left_angle) > EPS then
			rxbr = 3 * openingWidth / 4
			rzbr = rxbr / tan(gs_slanted_left_angle)
		else
			rxtr = 0
			rztr = 1
		endif
		rybr = rzbr * tan(gs_slanted_bottom_angle)

		add -leftWidth - gs_left_oversize - dxl + offsetSlantedLeft, -dxb - gs_lower_oversize + offsetSlantedBott, 0
		wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
			 rxbr, rybr, -rzbr, dbl,
			 rightDx,					-parapet_height*3/4,	31,
			 3 * openingWidth/4 + dxl,	-parapet_height*3/4,	31,
			 3 * openingWidth/4 + dxl,	 0,						31,
			 rightDx,					 0,						31
		del 1

		db2 = sqr(vx*vx + vz*vz)

		add -leftWidth - gs_left_oversize - dxl + offsetSlantedLeft, -parapet_height, 0
		wallniche 4, 2, 2 + HalfInfiniteCut * 16 + 128,
			 rxbr, 0, -rzbr, db2,
			 rightDx,					 parapet_height*3/4,	31,
			 3 * openingWidth/4 + dxl,	 parapet_height*3/4,	31,
			 3 * openingWidth/4 + dxl,	 0,						31,
			 rightDx,					 0,						31
		del 1

	endif

return


2000:
! ==============================================================================
! Shape cut body with offset
! ------------------------------------------------------------------------------
! Input variables:
! Offsets:
!	offLeft:			offset left
!	offRight:			offset right
!	offTop:				offset top
!	offBottom:			offset bottom
! Cutting body parameters:
!	cutMethod:			method parameters of the wallniche
!	cutStatus:			status parameters of the wallniche
!	cutVectX:			x component of the cutting direction vector
!	cutVectY:			y component of the cutting direction vector
!	cutVectZ:			z component of the cutting direction vector
!	cutDepth:			depth of cut
! Shape geometrty:
!	sideRight:			right side
!	sideLeft:			left side
!	sideBottom:			bottom side
!	sideTop:			top side
!	archHeight:
!	arcR:
!	tan_topAngle:		SHAPE_TRAPEZOID upper side tan(angle)
! ==============================================================================

	if iWindowShape = SHAPE_RECTANGULAR then
		if _bCustomMatNicheTop then
			wallniche 4, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,	-sideBottom + offBottom,	31, _wallNicheSurfaceRight,
				 sideRight - offRight,	 sideTop    - offTop,		31, _wallNicheSurfaceTop,
				-sideLeft  + offLeft,	 sideTop    - offTop,		31, _wallNicheSurfaceLeft,
				-sideLeft  + offLeft,	-sideBottom + offBottom,	31, _wallNicheSurfaceBottom
		else
			wallniche 4, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,	-sideBottom + offBottom,	31,
				 sideRight - offRight,	 sideTop    - offTop,		31,
				-sideLeft  + offLeft,	 sideTop    - offTop,		31,
				-sideLeft  + offLeft,	-sideBottom + offBottom,	31
		endif
	endif

	if iWindowShape = SHAPE_ARCHED then
		if bHalfCircle then
			archDistortion = (archHeight - offTop) / ((sideRight - offRight + sideLeft - offLeft) / 2)

			addy sideTop - archHeight
			muly archDistortion
			if _bCustomMatNicheTop then
				wallniche 6, cutMethod, cutStatus,
					cutVectX,cutVectY,cutVectZ, cutDepth,
					 sideRight - offRight,	(-sideBottom + offBottom - sideTop + archHeight) / archDistortion,	31, _wallNicheSurfaceRight,
					 sideRight - offRight,	 0,		95, _wallNicheSurfaceTop,
					 0,							1,			 				895, _wallNicheSurfaceTop,
					 0,		(archHeight - offTop) / archDistortion,		1095, _wallNicheSurfaceTop,
					-sideLeft  + offLeft,	 0,		1095, _wallNicheSurfaceLeft,
					-sideLeft  + offLeft,	(-sideBottom + offBottom - sideTop + archHeight) / archDistortion,	31, _wallNicheSurfaceBottom
			else
				wallniche 6, cutMethod, cutStatus,
					cutVectX,cutVectY,cutVectZ, cutDepth,
					 sideRight - offRight,	(-sideBottom + offBottom - sideTop + archHeight) / archDistortion,	31,
					 sideRight - offRight,	 0,		95,
					 0,							1,			 				895,
					 0,		(archHeight - offTop) / archDistortion,		1095,
					-sideLeft  + offLeft,	 0,		1095,
					-sideLeft  + offLeft,	(-sideBottom + offBottom - sideTop + archHeight) / archDistortion,	31
			endif
			del 2
		else
			midOffset = (sideRight - offRight - sideLeft + offLeft) / 2
			if arcR - offTop > sideRight - offRight then
				shoulder_offset = sqr((arcR - offTop)^2 - (sideRight - offRight)^2)
			else
				shoulder_offset = 0
			endif

			if _bCustomMatNicheTop then
				wallniche 6, cutMethod, cutStatus,
					cutVectX,cutVectY,cutVectZ, cutDepth,
					 midOffset,				 sideTop - arcR,					900, _wallNicheSurfaceRight,
					 sideRight - offRight,	-sideBottom + offBottom,			31, _wallNicheSurfaceRight,
					 sideRight - offRight,	 sideTop - arcR + shoulder_offset,	95, _wallNicheSurfaceTop,
					0,	 sideTop - offTop,										3095, _wallNicheSurfaceTop,
					-sideLeft  + offLeft,	 sideTop - arcR + shoulder_offset,	1095, _wallNicheSurfaceLeft,
					-sideLeft  + offLeft,	-sideBottom + offBottom,			31, _wallNicheSurfaceBottom
			else
				wallniche 6, cutMethod, cutStatus,
					cutVectX,cutVectY,cutVectZ, cutDepth,
					 midOffset,				 sideTop - arcR,					900,
					 sideRight - offRight,	-sideBottom + offBottom,			31,
					 sideRight - offRight,	 sideTop - arcR + shoulder_offset,	95,
					0,	 sideTop - offTop,										3095,
					-sideLeft  + offLeft,	 sideTop - arcR + shoulder_offset,	1095,
					-sideLeft  + offLeft,	-sideBottom + offBottom,			31
			endif
		endif
	endif

	if iWindowShape = SHAPE_HALFARCH then

		if bRightCornerFunction then
			put -sideLeft + offLeft,-sideBottom + offBottom,			31,
				sideRight,		-sideBottom + offBottom,	31,
				sideRight,		Topy,	31,
				Topx,						Topy,						95,

				sideRight - overSizeRight, 		sideTop - Arcr,		900,
				Shouldx,		Shouldy,			3031 + bFullArc * 64
		else
			put -sideLeft + offLeft,-sideBottom + offBottom,			31,
				sideRight - offRight,		-sideBottom + offBottom,	31,
				Topx,						 Topy,						95,

				sideRight,		sideTop - Arcr,		900,
				Shouldx,		Shouldy,			3031 + bFullArc * 64
		endif

		wallniche nsp/3, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			get(nsp)
	endif

	if iWindowShape = SHAPE_ELLIPSEARCH then

		if curvedWall then
			ratio = (archHeight - offTop) / (archHeight - offLeft)
		else
			ratio = 1
		endif
		addy sideTop - archHeight
		muly ratio
		wallniche 7, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			 sideRight - offRight,			-sideBottom + offBottom + (archHeight - sideTop) / ratio,	31,
			 sideRight - offRight,			 0,		95,
			 smallRadiusEllips_offset,		 alphaSide,					2095,
			 middleRadiusEllips_offset,		 alphaMiddle/2,				2095,
			 middleRadiusEllips_offset,		 alphaMiddle/2,				2095,
			 smallRadiusEllips_offset,		 alphaSide,					2095,
			-sideLeft  + offLeft,			-sideBottom + offBottom + (archHeight - sideTop) / ratio,	31
		del 2
	endif

	if iWindowShape = SHAPE_PENTAGON then
		_hCenter = sideTop - offTop / cos(atn(tan_topAngle))
		wallniche 5, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			 sideRight - offRight,	-sideBottom + offBottom,	  							31,
			 sideRight - offRight,	 _hCenter - (sideRight - offRight) * tan_topAngle,		31,
			 0,						 _hCenter,												31,
			-sideLeft  + offLeft,	 _hCenter - (sideLeft - offLeft) * tan_topAngle,		31,
			-sideLeft  + offLeft,	-sideBottom + offBottom,	  							31
	endif

	if iWindowShape = SHAPE_TRAPEZOID then
		_dirWin = not(bMirroredOpening) * 2 - 1		!mirrored: -1  nonmirrored: 1
		_hCenter = sideTop - archHeight / 2 - offTop / cos(atn(tan_topAngle))
		py1 = _hCenter + _dirWin * (sideRight - offRight) * tan_topAngle
		py2 = _hCenter - _dirWin * (sideLeft - offLeft) * tan_topAngle

		wallniche 4, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,	-sideBottom + offBottom,	31,
				 sideRight - offRight,	py1,	31,
				-sideLeft  + offLeft,	py2,	31,
				-sideLeft  + offLeft,	-sideBottom + offBottom,	31
	endif

	if iWindowShape = SHAPE_TRIANGLE then
		_oleft = -offLeft / sin(atn(tan_LeftSide))
		_oright = -offRight / sin(atn(tan_RightSide))
		_xTop = (sideLeft + sideRight + _oleft + _oright) / (tan_LeftSide / tan_RightSide + 1)
		_yTop = _xTop * tan_LeftSide
		px1 = (sideLeft + sideRight) / 2 + _oright - (offBottom / tan_RightSide) * not(gs_stack_bottom)
		px2 = -(sideLeft + sideRight) / 2 - _oleft + (offBottom / tan_LeftSide) * not(gs_stack_bottom)

		wallniche 3, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			px1,	-sideBottom + offBottom,	31,
			-(sideLeft + sideRight) / 2 - _oleft + _xTop,						_yTop,						31,
			px2,	-sideBottom + offBottom,	31
	endif

	if iWindowShape = SHAPE_CORNER_TRIANGLE then
		if bRightCornerFunction then
			angleLeft	= atn((sideTop + sideBottom) / 2 / (sideLeft - (leftWidth - rightWidth) / 2))
			px2 = -sideLeft  + offBottom / tan(angleLeft)  + offLeft  / sin(angleLeft)
			CornerHeight = (sideRight - offRight - px2) * tan(angleLeft)

			wallniche 3, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				sideRight - offRight,	-sideBottom + offBottom,	31,
				sideRight - offRight,	 CornerHeight,				31,
				px2,					-sideBottom + offBottom,	31
		else
			angleLeft	= atn((sideTop + sideBottom) / 2 / sideLeft)
			px2 = -sideLeft  + offBottom / tan(angleLeft)  + offLeft  / sin(angleLeft)
			upperJambModify = 1 / tan((90-angleLeft)/2)

			wallniche 3, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				sideRight - offRight,	-sideBottom + offBottom,				31,
				sideRight - offRight,	 sideTop    - offTop * upperJambModify,	31,
				px2,					-sideBottom + offBottom,				31
		endif
	endif

	if iWindowShape = SHAPE_PARALLELOGRAM then
		if bMirroredOpening then
			wallniche 4, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,	-sideBottom + offBottom * upperJambModify + offRight * tan_topAngle,				31,
				 sideRight - offRight, 	 sideTop    - offTop * upperJambModify + offRight * tan_topAngle - archHeight,		31,
				-sideLeft  + offLeft,	 sideTop    - offTop * upperJambModify - offLeft  * tan_topAngle,							31,
				-sideLeft  + offLeft,	-sideBottom + offBottom * upperJambModify - offLeft * tan_topAngle + archHeight,	31
		else
			wallniche 4, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,	-sideBottom + offBottom * upperJambModify + offRight * tan_topAngle + archHeight,	31,
				 sideRight - offRight, 	 sideTop   - offTop * upperJambModify + offRight * tan_topAngle - archHeight,							31,
				-sideLeft  + offLeft,	 sideTop    - offTop * upperJambModify + offRight * tan_topAngle,		31,
				-sideLeft  + offLeft,	-sideBottom + offBottom * upperJambModify + offRight * tan_topAngle,				31
		endif
	endif


	if iWindowShape = SHAPE_GOTHICARCH then

		wallniche 7, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			 sideRight - offRight,					-sideBottom + offBottom,	  		31,
			 sideRight - offRight,					sideTop - archHeight,				95,
			 sideRight - arcR,						sideTop - archHeight,				900,
			(sideRight - sideLeft) / 2,				sideTop - centArcoffs,				3095,
			-sideLeft + arcR,						sideTop - archHeight,				900,
			-sideLeft  + offLeft,					sideTop - archHeight,				3095,
			-sideLeft  + offLeft,					-sideBottom + offBottom,	  		31

	endif

	if iWindowShape = SHAPE_HORSESHOE then

		wallniche 12, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
				sideRight - offRight,		-sideBottom,     		31,
				sideRight - offRight,		LowArcoffsy,			31,
				LowArcoffsx+EPS,			LowArcoffsy,			31,
				LowArcoffsx,				LowArcoffsy,			95,
				sideRight - RadArch,		sideTop - (ArchHeight - gs_lowerArchHeight), 900, 
				0,							HighArcoffs,			3000 +63,
				-EPS/2,						HighArcoffs,			95,
				-sideLeft + RadArch,		sideTop - (ArchHeight - gs_lowerArchHeight), 900,
				-LowArcoffsx,				LowArcoffsy,			3000 +31,
				-LowArcoffsx-EPS,			LowArcoffsy,			31,
				-sideLeft  + offLeft,		LowArcoffsy,			31,
				-sideLeft  + offLeft,		-sideBottom,			31
	endif

	if iWindowShape = SHAPE_OGEECENTERED then

		wallniche 11, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			sideRight - offRight,	-sideBottom,			31,
			sideRight - offRight,	sideTop - archHeight,	95,
			sideRight - RadArc,		sideTop - archHeight,	995,
			sideRight/2,			sideTop - archHeight/2,	3095,
			0 + RadArc,				sideTop,				995,
			0,						centArcoffs,			3095,
			0 - RadArc,				sideTop,				995,
			-sideLeft/2,			sideTop - archHeight/2,	3095,
			-sideLeft + RadArc,		sideTop - archHeight,	995,
			-sideLeft  + offLeft,	sideTop - archHeight,	3095,
			-sideLeft  + offLeft,	-sideBottom,			31
	endif


	if iWindowShape = SHAPE_SARACENIC then

		wallniche 10, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			sideRight - offRight,	-sideBottom,			31,
			sideRight - offRight,	sideTop - ArchHeight,	31+64,
			sideRight - RadArch,	sideTop - ArchHeight,	931+64,
			0,						60,						4031+64,
			0,						centArcoffs,			31,
			-tangArcx,				tangArcy,				31+64,
			-sideLeft + RadArch,	sideTop - ArchHeight,	931+64,
			0,						60,						4031+64,
			-sideLeft  + offLeft,	-sideBottom,			31,
			sideRight - offRight,	-sideBottom,			-1

	endif

	if iWindowShape = SHAPE_ROMBUS then
		addy openingHeight / 2
		wallniche 4, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			-openingWidth / 2 + offRight, 	 0, 							31,
			 0,								 openingHeight / 2 - offRight,	31,
			 openingWidth / 2 - offRight,	 0, 							31,
			 0,								-openingHeight / 2 + offRight,	31
!		wallniche 4, cutMethod, cutStatus,
!			cutVectX,cutVectY,cutVectZ, cutDepth,
!			-openingWidth / 2 + offRight * sideJambModify, 	 0, 												31,
!			 0,												 openingHeight / 2 - offRight * upperJambModify,	31,
!			 openingWidth / 2 - offRight * sideJambModify,	 0, 												31,
!			 0,												-openingHeight / 2 + offRight * upperJambModify,	31
		del 1
	endif

	if iWindowShape = SHAPE_OCTAGONAL then
		alpha_rotation	= 22.5
		offEdge			= (2 * offRight) / (2 * cos(22.5))
		cornerRadius	= openingHeight / (2 * cos(22.5))

		for i = 1 to 8
!!!			put (cornerRadius - offEdge / mulRatio) * sin(alpha_rotation), (cornerRadius - offEdge) * cos(alpha_rotation) * MulRat, 31
			put (cornerRadius - offEdge) * sin(alpha_rotation), (cornerRadius - offEdge) * cos(alpha_rotation) * MulRat, 31
			alpha_rotation = alpha_rotation + 45
		next i

		addy openingHeight/2
		wallniche nsp/3, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			get (nsp)
		del 1
	endif

	if iWindowShape = SHAPE_MULTISIDE then
		addy normalRadius * cos (180 / gs_numOfSides)

		alpha_rotation = 0
		if (gs_numOfSides mod 2) = 0 then
			alpha_rotation = 180 / gs_numOfSides
		endif

		cornerRadius = normalRadius - offRight / cos (180 / gs_numOfSides)

		for i = 1 to gs_numOfSides
			put cornerRadius * sin (alpha_rotation), cornerRadius * cos (alpha_rotation) * MulRat, 31 + (nArchResolution = 0) * 64
			alpha_rotation = alpha_rotation + 360 / gs_numOfSides
		next i

		wallniche nsp/3, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			get (nsp)
		del 1
	endif

	if iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_ELLIPSE then
		addy openingHeight / 2
		muly openingHeight / openingWidth * MulRat
		wallniche 2, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			0, 0, 995,
			openingWidth/2 - offRight,	360, 4095
		del 2
	endif

	if iWindowShape = SHAPE_HALFCIRCLE then
		if sideTop - archHeight > -sideBottom + offBottom then
			archDistortion = (archHeight - offTop) / ((sideRight - offRight + sideLeft - offLeft) / 2)
			addy sideTop - archHeight
			muly archDistortion
			wallniche 6, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,	(-sideBottom + offBottom - sideTop + archHeight) / archDistortion,	31,
				 sideRight - offRight,	0,																	95,
				 0,						1, 																	895,
				 0,	 					(sideTop - offTop - sideTop + archHeight) / archDistortion,			1095,
				-sideLeft  + offLeft,	0,																	1095,
				-sideLeft  + offLeft,	(-sideBottom + offBottom - sideTop + archHeight) / archDistortion,	31
			del 2
		else
			pxR = sqr((sideRight - offRight)^2 - (-sideBottom + offBottom - (sideTop - archHeight))^2)
			pxL = sqr((sideLeft  - offLeft)^2  - (-sideBottom + offBottom - (sideTop - archHeight))^2)
			alpha = atn((-sideBottom + offBottom - (sideTop - archHeight)) / pxR)
			wallniche 5, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 pxR,			-sideBottom + offBottom,	95,
				 -sin(alpha),	 cos(alpha), 				895,
				 0,				 sideTop - offTop,			1031,
				-pxL,			-sideBottom + offBottom,	1031,
				 pxR,			-sideBottom + offBottom,	31
		endif
	endif

	if iWindowShape = SHAPE_HALFROUND then

		mulx -1
		add - openingWidth / 2, openingHeight / 2, 0

		diffx = (leftWidth - rightWidth) / 2
		ang_segm = 360 / nArchResolution
		kezd_veg = 0

		for kk= 0 to nArchResolution/2

			xa = openingWidth * cos(-90 + (kk) * ang_segm)
			ya = openingHeight / 2 * sin(-90 + (kk) * ang_segm)
			if ABS(ya) < EPS then
				ang_cent = -90
			else
				ang_cent = ATN(xa/ya)
			endif

			xa_el = openingWidth * cos(-90 + (kk-1) * ang_segm)
			ya_el = openingHeight / 2 * sin(-90 + (kk-1) * ang_segm)
			if ABS(ya_el) < EPS then
				ang_cent_el = -90
			else
				ang_cent_el = ATN(xa_el/ya_el)
			endif

			xa_ut = openingWidth * cos(-90 + (kk+1) * ang_segm)
			ya_ut = openingHeight / 2 * sin(-90 + (kk+1) * ang_segm)
			if ABS(ya_ut) < EPS then
				ang_cent_ut = -90
			else
				ang_cent_ut = ATN(xa_ut/ya_ut)
			endif

			bFirstPoint	= (kk = 0)
			bLastPoint	= (kk = nArchResolution / 2)

			if bFirstPoint & not(bRightCornerFunction) & offLeft < -EPS then
				put diffx + offLeft, -openingHeight / 2 + offLeft, 31
			endif

			if xa - abs(offLeft * sin(ang_cent)) >= offLeft then
				! between points
				if (bFirstPoint | bLastPoint) & not(bRightCornerFunction) & offLeft > -EPS then
					mask = 31
				else
					mask = 95
				endif
				if kk>nArchResolution/4 then
					put diffx + xa - (offLeft * sin(ang_cent)), ya - (offLeft * cos(ang_cent)), mask
				else
					put diffx + xa + (offLeft * sin(ang_cent)), ya + (offLeft * cos(ang_cent)), mask
				endif
			else
				if not(bRightCornerFunction) then
					mask = 31
				else
					mask = 95
				endif

				! first point
				if kezd_veg = 0 & xa_ut - ABS( offLeft * sin(ang_cent_ut)) > offLeft then
					x11 = offLeft
					y11 = -openingHeight
					x12 = offLeft
					y12 = openingHeight
					x21 = xa 	- ABS( offLeft * sin(ang_cent))
					y21 = ya 	+ ( offLeft * cos(ang_cent))
					x22 = xa_ut - ABS( offLeft * sin(ang_cent_ut))
					y22 = ya_ut + ( offLeft * cos(ang_cent_ut))
					GOSUB 100

					put diffx + cx, cy, mask

					kezd_veg = 1
				endif

				! last point
				if kezd_veg = 1  & xa_el - ABS( offLeft * sin(ang_cent_el)) > offLeft then
					x11 = offLeft
					y11 = -openingHeight
					x12 = offLeft
					y12 = openingHeight
					x21 = xa 	- ABS( offLeft * sin(ang_cent))
					y21 = ya 	- ( offLeft * cos(ang_cent))
					x22 = xa_el - ABS( offLeft * sin(ang_cent_el))
					y22 = ya_el - ( offLeft * cos(ang_cent_el))
					GOSUB 100

					put diffx + cx, cy, mask

					kezd_veg = 2
				endif
			endif

			if bLastPoint & not(bRightCornerFunction) & offLeft < -EPS then
				put diffx + offLeft, openingHeight / 2 - offLeft, 31
			endif


		next kk

		if bRightCornerFunction then
			wallniche 2+nsp/3, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-1,		-openingHeight/2 + offLeft,	95,
				get(nsp),
				-1,		openingHeight/2 - offLeft,	95
		else
			wallniche nsp/3, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				get(nsp)
		endif

		del 2
	endif

	if iWindowShape = SHAPE_T then
		if curvedWall then
			midleLine = (-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left + sideRight - offSlRight - gs_sidelight_WHole_width_right) / 2
			wallniche 6, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
				 sideRight - offRight,	 sideTop    - offTop,												31,
				-sideLeft  + offLeft,	 sideTop    - offTop,												31,
				-sideLeft  + offLeft,	-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				 midleLine,				-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				 midleLine,				-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31
			cutHeight = (sideTop - offTop) + (-sideBottom + max(gs_sidelight_parapet_hgt_left + offSlLeftBottom, gs_sidelight_parapet_hgt_right + offSlRightBottom) - sideTop + offTop) / 2
			wallniche 4, 1, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	 cutHeight,					31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	 cutHeight,					31
		else
			wallniche 9, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 sideRight - offRight,										-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
				 sideRight - offRight,										 sideTop    - offTop,												31,
				-sideLeft  + offLeft,										 sideTop    - offTop,												31,
				-sideLeft  + offLeft,										-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offBottom,											31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offBottom,											31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
				 sideRight - offRight,										-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	-1
		endif
	endif

	if iWindowShape = SHAPE_HALF_T_LEFT then
		if curvedWall then
			midleLine = (-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left + sideRight - offRight) / 2
			cutHeight = (sideTop - offTop) + (-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left - sideTop + offTop) / 2
			wallniche 4, 1, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	 cutHeight,					31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offBottom,	31,
				 midleLine + 0.1,											-sideBottom + offBottom,	31,
				 midleLine + 0.1,											 cutHeight,					31
		else
			midleLine = -sideLeft  + offSlLeft + gs_sidelight_WHole_width_left
		endif
		wallniche 7, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			 sideRight - offRight,	-sideBottom + offBottom,										31,
			 sideRight - offRight,	 sideTop    - offTop,											31,
			-sideLeft  + offLeft,	 sideTop    - offTop,											31,
			-sideLeft  + offLeft,	-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,	31,
			 midleLine,				-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,	31,
			 midleLine,				-sideBottom + offBottom,										31,
			sideRight - offRight,	-sideBottom + offBottom,										-1
	endif

	if iWindowShape = SHAPE_HALF_T_RIGHT then
		if curvedWall then
			midleLine = (-sideLeft  + offLeft + sideRight - offSlRight - gs_sidelight_WHole_width_right) / 2
			cutHeight = (sideTop - offTop) + (-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right - sideTop + offTop) / 2
			wallniche 4, 1, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 midleLine - 0.1,											 cutHeight,					31,
				 midleLine - 0.1,											-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	 cutHeight,					31
		else
			midleLine = sideRight - offSlRight - gs_sidelight_WHole_width_right
		endif
		wallniche 7, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			 sideRight - offRight,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
			 sideRight - offRight,	 sideTop    - offTop,												31,
			-sideLeft  + offLeft,	 sideTop    - offTop,												31,
			-sideLeft  + offLeft,	-sideBottom + offBottom,											31,
			 midleLine,				-sideBottom + offBottom,											31,
			 midleLine,				-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
			 sideRight - offRight,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	-1
	endif

	if iWindowShape = SHAPE_ARCHED_T then
		if arcR - offTop > sideRight - offRight then
			shoulder_offset = sqr((arcR - offTop)^2 - (sideRight - offRight)^2)
			mask = 0
		else
			shoulder_offset = 0
			mask = 64
		endif

		if curvedWall then
			midleLine = (-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left + sideRight - offSlRight - gs_sidelight_WHole_width_right) / 2
			wallniche 11, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				(sideRight - offRight - sideLeft + offLeft) / 2,	 sideTop - arcR,						900,
				 sideRight - offRight,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
				 sideRight - offRight,	 sideTop    - arcR + shoulder_offset - EPS,							31+mask,
				 sideRight - offRight,	 sideTop    - arcR + shoulder_offset,								95,
				 0,	 					 sideTop - offTop,													3031+mask,
				-sideLeft  + offLeft,	 sideTop    - arcR + shoulder_offset,								3031+mask,
				-sideLeft  + offLeft,	 sideTop    - arcR + shoulder_offset - EPS,							31+mask,
				-sideLeft  + offLeft,	-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				midleLine,				-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				midleLine,				-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
				 sideRight - offRight,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	-1
			cutHeight = (sideTop - offTop) + (-sideBottom + max(gs_sidelight_parapet_hgt_left + offSlLeftBottom, gs_sidelight_parapet_hgt_right + offSlRightBottom) - sideTop + offTop) / 2
			wallniche 4, 1, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	 cutHeight,					31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	 cutHeight,					31
		else
			wallniche 13, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				(sideRight - offRight - sideLeft + offLeft) / 2,			 sideTop 	- arcR,				 									900,
				 sideRight - offRight,										-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
				 sideRight - offRight,										 sideTop    - arcR + shoulder_offset - EPS,							31+mask,
				 sideRight - offRight,										 sideTop    - arcR + shoulder_offset,								95,
				 0,															 sideTop - offTop,													3031+mask,
				-sideLeft  + offLeft,										 sideTop    - arcR + shoulder_offset,								3031+mask,
				-sideLeft  + offLeft,										 sideTop    - arcR + shoulder_offset - EPS,							31+mask,
				-sideLeft  + offLeft,										-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,		31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offBottom,											31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offBottom,											31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
				 sideRight - offRight,										-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	-1
		endif
	endif

	if iWindowShape = SHAPE_ARCHED_HALF_T_LEFT then
		if arcR - offTop > sideRight - offRight then
			shoulder_offset = sqr((arcR - offTop)^2 - (sideRight - offRight)^2)
			mask = 0
		else
			shoulder_offset = 0
			mask = 64
		endif

		if curvedWall then
			midleLine = (-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left + sideRight - offRight) / 2
			cutHeight = (sideTop - offTop) + (-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left - sideTop + offTop) / 2
			wallniche 4, 1, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	 cutHeight,					31,
				-sideLeft  + offSlLeft  + gs_sidelight_WHole_width_left,	-sideBottom + offBottom,	31,
				 midleLine + 0.1,											-sideBottom + offBottom,	31,
				 midleLine + 0.1,											 cutHeight,					31
		else
			midleLine = -sideLeft  + offSlLeft + gs_sidelight_WHole_width_left
		endif
		wallniche 11, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			(sideRight - offRight - sideLeft + offLeft) / 2,	sideTop - arcR,						900,
			 sideRight - offRight,	-sideBottom + offBottom,										31,
			 sideRight - offRight,	 sideTop    - arcR + shoulder_offset - EPS,						31+mask,
			 sideRight - offRight,	 sideTop    - arcR + shoulder_offset,							95,
			 0,						 sideTop - offTop,												3031+mask,
			-sideLeft  + offLeft,	 sideTop    - arcR + shoulder_offset,							3031+mask,
			-sideLeft  + offLeft,	 sideTop    - arcR + shoulder_offset - EPS,						31+mask,
			-sideLeft  + offLeft,	-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,	31,
			 midleLine,				-sideBottom + offSlLeftBottom + gs_sidelight_parapet_hgt_left,	31,
			 midleLine,				-sideBottom + offBottom,										31,
			 sideRight - offRight,	-sideBottom + offBottom,										-1
	endif

	if iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then
		if arcR - offTop > sideRight - offRight then
			shoulder_offset = sqr((arcR - offTop)^2 - (sideRight - offRight)^2)
			mask = 0
		else
			shoulder_offset = 0
			mask = 64
		endif

		if curvedWall then
			midleLine = (-sideLeft  + offLeft + sideRight - offSlRight - gs_sidelight_WHole_width_right) / 2
			cutHeight = (sideTop - offTop) + (-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right - sideTop + offTop) / 2
			wallniche 4, 1, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				 midleLine - 0.1,											 cutHeight,					31,
				 midleLine - 0.1,											-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	-sideBottom + offBottom,	31,
				 sideRight - offSlRight - gs_sidelight_WHole_width_right,	 cutHeight,					31
		else
			midleLine = sideRight - offSlRight - gs_sidelight_WHole_width_right
		endif
		wallniche 11, cutMethod, cutStatus,
			cutVectX,cutVectY,cutVectZ, cutDepth,
			(sideRight - offRight - sideLeft + offLeft) / 2,	sideTop - arcR,							900,
			 sideRight - offRight,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
			 sideRight - offRight,	 sideTop    - arcR + shoulder_offset - EPS,							31+mask,
			 sideRight - offRight,	 sideTop    - arcR + shoulder_offset,								95,
			 0,						 sideTop - offTop,													3031+mask,
			-sideLeft  + offLeft,	 sideTop    - arcR + shoulder_offset,								3031+mask,
			-sideLeft  + offLeft,	 sideTop    - arcR + shoulder_offset - EPS,							31+mask,
			-sideLeft  + offLeft,	-sideBottom + offBottom,											31,
			 midleLine,				-sideBottom + offBottom,											31,
			 midleLine,				-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	31,
			 sideRight - offRight,	-sideBottom + offSlRightBottom + gs_sidelight_parapet_hgt_right,	-1
	endif

	if iWindowShape = SHAPE_QUARTERROUND then
		if offLeft > holeSideOffset | offBottom > holeBottomOffset then
			px = sqr((openingWidth - offRight)^2 - (offBottom - holeBottomOffset)^2)
			py = sqr((openingHeight - offTop)^2 - (offLeft - holeSideOffset)^2)
			wallniche 6, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-openingWidth / 2 + offLeft,		offBottom,					31,
				-openingWidth / 2 + px,				offBottom,					95,
				-openingWidth / 2 + holeSideOffset,	holeBottomOffset,			900,
				-openingWidth / 2 + offLeft,		py,							3031,
				-openingWidth / 2 + offLeft,		py - EPS,					31,
				-openingWidth / 2 + offLeft,		offBottom,					-1
		else
			wallniche 7, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-openingWidth / 2 + offLeft,		offBottom,					31,
				 openingWidth / 2 - offRight,		offBottom,					95,
				 openingWidth / 2 - offRight,		holeBottomOffset,			95,
				 0,									1,							800,
				-openingWidth / 2 + holeSideOffset,	openingHeight - offTop,		1031,
				-openingWidth / 2 + offLeft,		openingHeight - offTop,		31,
				-openingWidth / 2 + offLeft,		offBottom,					-1
		endif
	endif

	if iWindowShape = SHAPE_QUARTERROUND_NOFRAME then
		if bMirroredOpening then
			openingHeight = openingWidth
			px = sqr((openingWidth - offLeft)^2 - offBottom^2)
			py = sqr((openingHeight - offTop)^2 - offLeft^2)

			if bRightCornerFunction then
				diffx = -(leftWidth - rightWidth) / 2
				wallniche 6, cutMethod, cutStatus,
					cutVectX,cutVectY,cutVectZ, cutDepth,
					 diffx + openingWidth / 2 + 1.0,	offBottom,				31,
					 diffx + openingWidth / 2 - px,		offBottom,				95,
					 diffx + openingWidth / 2,			0,						900,
					 diffx + openingWidth / 2,			openingHeight - offTop,	3095,
					 diffx + openingWidth / 2 + 1.0,	openingHeight - offTop, 31,
					 diffx + openingWidth / 2 + 1.0,	offBottom,				-1
			else
				if px > py then
					wallniche 6, cutMethod, cutStatus,
						cutVectX,cutVectY,cutVectZ, cutDepth,
						 openingWidth / 2 - offRight,	offBottom,	31,
						 openingWidth / 2 - px,			offBottom,	95,
						 openingWidth / 2,				0,			900,
						 openingWidth / 2 - offRight,	py,			3031,
						 openingWidth / 2 - offRight,	py - EPS,	31,
						 openingWidth / 2 - offRight,	offBottom,	-1
				else
					wallniche 6, cutMethod, cutStatus,
						cutVectX,cutVectY,cutVectZ, cutDepth,
						 openingWidth / 2 - offRight,	offBottom,	31,
						 openingWidth / 2 - px,			offBottom,	95,
						 openingWidth / 2,				0,			900,
						 openingWidth / 2,				px,			3095,
						 openingWidth / 2 - offRight,	px - EPS,	31,
						 openingWidth / 2 - offRight,	offBottom,	-1
				endif
			endif
		else
			px = sqr((openingWidth - offRight)^2 - offBottom^2)
			py = sqr((openingHeight - offTop)^2 - offLeft^2)

			wallniche 6, cutMethod, cutStatus,
				cutVectX,cutVectY,cutVectZ, cutDepth,
				-openingWidth / 2 + offLeft,	offBottom,	31,
				-openingWidth / 2 + px,			offBottom,	95,
				-openingWidth / 2,				0,			900,
				-openingWidth / 2 + offLeft,	py,			3031,
				-openingWidth / 2 + offLeft,	py - EPS,	31,
				-openingWidth / 2 + offLeft,	offBottom,	-1
		endif
	endif

	_bCustomMatNicheTop		= 0
return


! ==============================================================================
! Line - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12	line #1
!	x21,y21, x22,y22	line #2
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = valid intersection point
!	cx, cy:				intersection point
! ==============================================================================

100:
	lliDiv = (x11-x12) * (y21-y22) - (y11-y12) * (x21-x22)

	if abs(lliDiv) > EPS then
		! Intersection

		temp1 = x11 * y12 - y11 * x12
		temp2 = x21 * y22 - y21 * x22

		tempx = temp1 * (x21-x22) - (x11-x12) * temp2
		tempy = temp1 * (y21-y22) - (y11-y12) * temp2

		state = 1
		cx = (tempx / lliDiv)
		cy = (tempy / lliDiv)
	else
		! No Intersection
		state = 0
		cx = 0
		cy = 0
	endif
return



! ==============================================================================
! Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	xo,yo,ro:			circle
!	x1,y1, x2,y2		line
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = one intersection point (tangential line)
!						2 = two intersection points
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
! ==============================================================================

101:
	tempX1 = x1 - xo: tempY1 = y1 - yo
	tempX2 = x2 - xo: tempY2 = y2 - yo

	if abs(tempX2 - tempX1) < EPS then
		if abs(ro - abs(tempX1)) < EPS then
			state = 1
			xa = tempX1
			ya = 0
			xb = tempX1
			yb = 0
		else
			if abs(ro) - abs(tempX1) < 0 then
				state = 0: xa = 0: ya = 0: xb = 0: yb = 0
			else
				state = 2
				xa = tempX1
				ya = sqr(ro^2 - tempX1^2)
				xb = tempX1
				yb = -ya
			endif
		endif
	else
		kf = (tempY2 - tempY1) / (tempX2 - tempX1)
		ad = 1 + kf^2
		bd = 2 * tempY1 * kf - 2 * tempX1 * kf^2
		cd = tempY1^2 - 2 * tempX1 * tempY1 * kf + tempX1^2 * kf^2 - ro^2

		if bd^2 - 4 * ad * cd < 0 then
			state = 0: xa = 0: ya = 0: xb = 0: yb = 0
		else
			xa = (-bd + sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			ya = tempY1 + (xa - tempX1) * kf
			xb = (-bd - sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			yb = tempY1 + (xb - tempX1) * kf

			if abs(xa - xb) < EPS then state = 1 else state = 2
		endif
	endif

	if state = 2 then
		da = sqr((tempX1 - xa)^2 + (tempY1 - ya)^2)
		db = sqr((tempX1 - xb)^2 + (tempY1 - yb)^2)

		if db < da then
			xxo = xa: yyo = ya
			xa = xb:  ya = yb
			xb = xxo: yb = yyo
		endif
	endif

	xa = xa + xo: ya = ya + yo
	xb = xb + xo: yb = yb + yo
return

205:

!!! ***** Direction Angle of Vector


IF vx=0 AND vy=0 THEN PRINT "Error: Null Vector !"

IF vx=0 THEN
	IF vy>0 THEN
		anglex = 90
	ELSE
		anglex = 270
	ENDIF
ELSE

	anglex = ATN (vy/vx)

	IF vx>=0 THEN
		IF anglex>=0 THEN
			anglex = anglex
		ELSE
			anglex = 360 + anglex
		ENDIF

	ELSE

		IF anglex>0 THEN
			anglex = 180 + anglex
		ELSE
			anglex = 180 + anglex
		ENDIF
	ENDIF
ENDIF

RETURN


209:

!!! ***** Circle - Circle Intersection

vx =	x2-x1
vy =	y2-y1
GOSUB 205

angle = anglex


d = SQR( (vx)^2+(vy)^2 )

IF d>(r1+r2) OR ABS(d)<EPS THEN ! No Intersection
	state = 0
	RETURN
ENDIF

IF ABS(d-(r1+r2))<EPS THEN ! One Intersection

	state =  1
	ccx1 = x1 + ((x2-x1)*r1)/(r1+r2)
	ccy1 = y1 + ((y2-y1)*r1)/(r1+r2)

	ccx2 = ccx1
	ccy2 = ccy1
	RETURN
ENDIF


! Check if one circle inside the another !!!!!!!!!!!!!!!!!!!!!!!!!!!

x = (d^2 - r2^2 + r1^2) / (2*d)
y = SQR(4*d^2*r1^2-(d^2-r2^2+r1^2)^2)/(d*2)
ccx1 = x1 + y*SIN(-angle) + x*COS(-angle)
ccy1 = y1 + y*COS(-angle) - x*SIN(-angle)
ccx2 = x1 - y*SIN(-angle) + x*COS(-angle)
ccy2 = y1 - y*COS(-angle) - x*SIN(-angle)

state =	2


RETURN



3000:
! ==============================================================================
! --- Reveal Hotspots ---
! ==============================================================================
if iRevealType > REVEAL_NO then
	hotspot revealRadius * sin (alpha_rotation), revealRadius * cos (alpha_rotation), leftRevealPnts[idxSillStartRevealLeft][2],	unID : unID = unID + 1
	hotspot revealRadius * sin (alpha_rotation), revealRadius * cos (alpha_rotation), leftRevealPnts[idxSillEndRevealLeft][2],	unID : unID = unID + 1
endif
return



4000:
! ==============================================================================
! --- Wallhole Hotspots ---
! ==============================================================================

! Board Side Hotspots ----------------------------------------------------------
hotspot normalRadius * sin (alpha_rotation), normalRadius * cos (alpha_rotation), leftRevealPnts[idxBoardEndRevealLeft][2],	unID : unID = unID + 1

! Sill Side Hotspots ----------------------------------------------------------
if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
	hotspot normalRadius * sin (alpha_rotation), normalRadius * cos (alpha_rotation), leftRevealPnts[idxSillStartRevealLeft][2],	unID : unID = unID + 1
else
	hotspot normalRadius * sin (alpha_rotation), normalRadius * cos (alpha_rotation), leftRevealPnts[idxFrameStartRevealLeft][2],	unID : unID = unID + 1
endif

return



]]>
</Script_3D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_2D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! Contact person: <NJ>

_bValidPoly = 1

! ==============================================================================
! This macro cuts the wallhole
! ------------------------------------------------------------------------------
! Input parameters:
!
! Hotspot IDs:
!	11040:			Wall Inset left edge (at the inset depth)
!	11041:			Wall Inset right edge (at the inset depth)
!	11042:			Wall Inset left edge (at the wall side)
!	11043:			Wall Inset right edge (at the wall side)
!	11000:			Frame start left
!	11001:			Frame start right
!	11002:			Frame end left
!	11003:			Frame end right
!	11100-11199:	Reveal hotspots
!	11200-:			Polygonal wall corner points
! ==============================================================================


LINE_BEG_X		= 1
LINE_BEG_Y		= 2
LINE_END_X		= 3
LINE_END_Y		= 4
LINE_ATTRIBUTES	= 5	! bitfield, look at LINE_ATTRIBUTES_xxx for available values
LINE_PEN_IDX	= 6
LINE_LTYPE_IDX	= 7

LINE_ATTRIBUTES_GDLLINE		= 0			! Draw GDL Line in the section
LINE_ATTRIBUTES_WALLLINE	= 1			! Draw WallLine in the section
LINE_ATTRIBUTES_WALLSIDE	= 2			! The section is on the wall side (it is an arc in curved wall)
LINE_ATTRIBUTES_DRAWCC		= 3			! The section is drawn by CavityClosure macro (otherwise the WallHoleCut macro)
LINE_ATTRIBUTES_CONTOUR		= 4			! The section is contour or inner line
!!!	LINE_ATTRIBUTES_WALLEDGE	= 0			! The section is on the wall edge (always a line)


! ==============================================================================

if WIDO_REVEAL_SIDE then
	add2 0,-WIDO_FRAME_THICKNESS
else
	mul2 1,-1
endif


! ==============================================================================
! Wallhole (Frame) Hotspots
! ==============================================================================

!if gs_wallhole_hotspots then
!	hotspot2 leftRevealPnts[idxFrameStartRevealLeft][1],	leftRevealPnts[idxFrameStartRevealLeft][2],	 11000
!	hotspot2 rightRevealPnts[idxFrameStartRevealRight][1],	rightRevealPnts[idxFrameStartRevealRight][2],11001
!
!	if iRevealType <> REVEAL_SLANTED then
!		hotspot2 leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2],	11002
!		hotspot2 rightRevealPnts[idxFrameEndRevealRight][1],rightRevealPnts[idxFrameEndRevealRight][2],	11003
!	endif
!endif

if iRevealType > REVEAL_NO then
	hotspot2 leftRevealPnts[idxFrameStartRevealLeft][1],	leftRevealPnts[idxFrameStartRevealLeft][2],	 11000
	hotspot2 rightRevealPnts[idxFrameStartRevealRight][1],	rightRevealPnts[idxFrameStartRevealRight][2],11001
endif



! ==============================================================================
! Reveal Hotspots
! ------------------------------------------------------------------------------
! It skips hotspots on wall contour in case of polygonal walls (AC_WallType = 2).
! Skipped points will be drawn in the polygon operations section
! ==============================================================================

if gs_reveal_hotspots & AC_WallType <> 2 then

	unID = 11100
	for ii = idxSillStartRevealLeft - (AC_WallType = 2) to idxFrameStartRevealLeft - 1
		hotspot2 leftRevealPnts[ii][1], leftRevealPnts[ii][2], unID : unID = unID + 2
	next ii

	unID = 11101
	for ii = idxSillStartRevealRight - (AC_WallType = 2) to idxFrameStartRevealRight - 1
		hotspot2 rightRevealPnts[ii][1], rightRevealPnts[ii][2], unID : unID = unID + 2
	next ii

	! Show hotspot at frame
	bShowLastHpts = not(iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE | iRevealType = REVEAL_SLANTED)

	unID = 11150
	for ii = idxFrameEndRevealLeft + 1 to idxBoardEndRevealLeft - (AC_WallType = 2)
		hotspot2 leftRevealPnts[ii][1], leftRevealPnts[ii][2], unID : unID = unID + 2
	next ii
![#COMPATIBILITY] - START
!	for ii = idxFrameEndRevealLeft + not(bShowLastHpts) to idxBoardEndRevealLeft - (AC_WallType = 2)
!		hotspot2 leftRevealPnts[ii][1], leftRevealPnts[ii][2], unID : unID = unID + 2
!	next ii
	if bShowLastHpts then
		ii = idxFrameEndRevealLeft
		hotspot2 leftRevealPnts[ii][1], leftRevealPnts[ii][2], unID : unID = unID + 2
	endif
![#COMPATIBILITY] - END

	unID = 11151
	for ii = idxFrameEndRevealRight + 1 to idxBoardEndRevealRight - (AC_WallType = 2)
		hotspot2 rightRevealPnts[ii][1], rightRevealPnts[ii][2], unID : unID = unID + 2
	next ii
![#COMPATIBILITY] - START
!	for ii = idxFrameEndRevealRight + not(bShowLastHpts) to idxBoardEndRevealRight - (AC_WallType = 2)
!		hotspot2 rightRevealPnts[ii][1], rightRevealPnts[ii][2], unID : unID = unID + 2
!	next ii
	if bShowLastHpts then
		ii = idxFrameEndRevealRight
		hotspot2 rightRevealPnts[ii][1], rightRevealPnts[ii][2], unID : unID = unID + 2
	endif
![#COMPATIBILITY] - END

	! Show hotspot at corner of turned last plaster skin

	if gs_turn_plaster_dim_2D then

		unID = 11201
		if ((abs(leftRevealPnts[idxSillStartPlasterLeft][1] - leftRevealPnts[idxSillStartRevealLeft][1]) > EPS) |\
			(abs(leftRevealPnts[idxSillStartPlasterLeft][2] - leftRevealPnts[idxSillStartRevealLeft][2]) > EPS)) then

			hotspot2 leftRevealPnts[idxSillStartPlasterLeft][1], leftRevealPnts[idxSillStartPlasterLeft][2], unID : unID = unID + 2
!!!			circle2 leftRevealPnts[idxSillStartPlasterLeft][1], leftRevealPnts[idxSillStartPlasterLeft][2], 0.02
		else
			unID = unID + 2
		endif

		if ((abs(leftRevealPnts[idxBoardEndPlasterLeft][1] - leftRevealPnts[idxBoardEndRevealLeft][1]) > EPS) |\
			(abs(leftRevealPnts[idxBoardEndPlasterLeft][2] - leftRevealPnts[idxBoardEndRevealLeft][2]) > EPS)) then

			hotspot2 leftRevealPnts[idxBoardEndPlasterLeft][1], leftRevealPnts[idxBoardEndPlasterLeft][2], unID : unID = unID + 2
!!!			circle2 leftRevealPnts[idxBoardEndPlasterLeft][1], leftRevealPnts[idxBoardEndPlasterLeft][2], 0.02
		else
			unID = unID + 2
		endif

		unID = 11251
		if ((abs(rightRevealPnts[idxSillStartPlasterRight][1] - rightRevealPnts[idxSillStartRevealRight][1]) > EPS) |\
			(abs(rightRevealPnts[idxSillStartPlasterRight][2] - rightRevealPnts[idxSillStartRevealRight][2]) > EPS)) then

			hotspot2 rightRevealPnts[idxSillStartPlasterRight][1], rightRevealPnts[idxSillStartPlasterRight][2], unID : unID = unID + 2
!!!			circle2 rightRevealPnts[idxSillStartPlasterRight][1], rightRevealPnts[idxSillStartPlasterRight][2], 0.02
		else
			unID = unID + 2
		endif

		if ((abs(rightRevealPnts[idxBoardEndPlasterRight][1] - rightRevealPnts[idxBoardEndRevealRight][1]) > EPS) |\
			(abs(rightRevealPnts[idxBoardEndPlasterRight][2] - rightRevealPnts[idxBoardEndRevealRight][2]) > EPS)) then

			hotspot2 rightRevealPnts[idxBoardEndPlasterRight][1], rightRevealPnts[idxBoardEndPlasterRight][2], unID : unID = unID + 2
!!!			circle2 rightRevealPnts[idxBoardEndPlasterRight][1], rightRevealPnts[idxBoardEndPlasterRight][2], 0.02
		else
			unID = unID + 2
		endif

	endif
endif

polyUnID = 11200	! Hotspot unID for polygonal wall corner points


! ==============================================================================



bNeedToOffsetSkins		= (offsetSill > EPS | offsetBoard > EPS)

if isWindow then
	drawindex 30	! Draw parapet contour lines at the bottom
else
	drawindex 20	! Draw parapet contour lines at the bottom
endif


! ==============================================================================
! Cut corners in case of corner window function
! ==============================================================================

if not(curvedWall) & not(bInclinedWall) & AC_WallType <> 2 & not(gs_transom_display) then	! Not drawn when Display as Transom is ON
	if bLeftCornerFunction then
		fill 0
		if GLOB_CONTEXT = 5 then
			poly2_b 4, 2+4+64, 0, -1,
				leftRevealPnts[idxBoardEndPlasterLeft][1],  leftRevealPnts[idxBoardEndPlasterLeft][2],  0,
				leftRevealPnts[idxSillStartPlasterLeft][1], leftRevealPnts[idxSillStartPlasterLeft][2], 0,
				0, leftRevealPnts[idxSillStartPlasterLeft][2], 0,
				0, leftRevealPnts[idxBoardEndPlasterLeft][2],  0
		else
			wallhole2 4, 2 + 64, 0, -1,
				0, 0, 0,
				leftRevealPnts[idxBoardEndPlasterLeft][1],  leftRevealPnts[idxBoardEndPlasterLeft][2],  0,
				leftRevealPnts[idxSillStartPlasterLeft][1], leftRevealPnts[idxSillStartPlasterLeft][2], 0,
				0, leftRevealPnts[idxSillStartPlasterLeft][2], 0,
				0, leftRevealPnts[idxBoardEndPlasterLeft][2],  0
		endif
	endif
	if bRightCornerFunction then
		fill 0
		if GLOB_CONTEXT = 5 then
			poly2_b 4, 2+4+64, 0, -1,
				rightRevealPnts[idxBoardEndPlasterRight][1],  rightRevealPnts[idxBoardEndPlasterRight][2],  0,
				rightRevealPnts[idxSillStartPlasterRight][1], rightRevealPnts[idxSillStartPlasterRight][2], 0,
				0, rightRevealPnts[idxSillStartPlasterRight][2], 0,
				0, rightRevealPnts[idxBoardEndPlasterRight][2],  0
		else
			wallhole2 4, 2 + 64, 0, -1,
				0, 0, 0,
				rightRevealPnts[idxBoardEndPlasterRight][1],  rightRevealPnts[idxBoardEndPlasterRight][2],  0,
				rightRevealPnts[idxSillStartPlasterRight][1], rightRevealPnts[idxSillStartPlasterRight][2], 0,
				0, rightRevealPnts[idxSillStartPlasterRight][2], 0,
				0, rightRevealPnts[idxBoardEndPlasterRight][2],  0
		endif
	endif
endif


! =============================================================================
! Change visible contour line to hidden contour line
! =============================================================================

if bEnableWallContourHiddenLine then
	if bWallContHiddenLineIn then
		gs_wcont_line_in	= gs_wcont_hidden_line_in
	endif
	if bWallContHiddenLineOut then
		gs_wcont_line_out	= gs_wcont_hidden_line_out
	endif

	if bWallContHiddenLineInLeftSl then
		_wcont_line_left_sl_in	= gs_wcont_hidden_line_sl_in
	else
		_wcont_line_left_sl_in	= gs_wcont_line_sl_in
	endif
	if bWallContHiddenLineOutLeftSl then
		_wcont_line_left_sl_out	= gs_wcont_hidden_line_sl_out
	else
		_wcont_line_left_sl_out	= gs_wcont_line_sl_out
	endif

	if bWallContHiddenLineInRightSl then
		_wcont_line_right_sl_in		= gs_wcont_hidden_line_sl_in
	else
		_wcont_line_right_sl_in		= gs_wcont_line_sl_in
	endif
	if bWallContHiddenLineOutRightSl then
		_wcont_line_right_sl_out	= gs_wcont_hidden_line_sl_out
	else
		_wcont_line_right_sl_out	= gs_wcont_line_sl_out
	endif
endif


! ==============================================================================
! Cut 2D Wallhole and Draw Background Fills
! ==============================================================================

bUseOneBackgroundFill		= (bDrawSillFill = bDrawBoardFill)	! 1 - 1 or 0 - 0
bVisibleWallInsetIn2D		= (bParapetWallInset & ((bParapetWallInsetFullHeight & (bDrawBoardFill | gs_parapet_2D)) | (not(bParapetWallInsetFullHeight) & gs_parapet_2D)))
bHiddenParapetWallInsetIn2D	= (bParapetWallInset & (not(bParapetWallInsetFullHeight) | not(bDrawBoardFill)))

bSkipSillFill = (abs(WIDO_SILL) < EPS & AC_WallType <> 2 & (not(curvedWall) | (curvedWall & gs_IsCurved)))

if vardim1(leftRevealPnts) > 1 & not(gs_transom_display) then	! Not drawn when Display as Transom is ON

	if bHasSidelightLeft | bHasSidelightRight then
		wallholeFill	= gs_wallhole_fill_sl
		wallholePen_fg	= gs_wallhole_pen_sl_fg
		wallholePen_bg	= gs_wallhole_pen_sl_bg

		if bHasSidelightLeft then
			wcontLineIn			= _wcont_line_left_sl_in  * (iWallContourLineSl = 2 | iWallContourLineSl = 4)
			wcontLineOut		= _wcont_line_left_sl_out * (iWallContourLineSl = 3 | iWallContourLineSl = 4)
			sidelightCutLeft	= 0
			sidelightCutRight	= 1
			sidelightCutPosSillRight	= -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_left_sL + thkPlasterAtSillSlLeft
			sidelightCutPosMiddleRight	= -leftWidth + gs_sidelight_WHole_width_left
			sidelightCutPosBoardRight	= -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_double_innerLeft_sL + thkPlasterAtBoardSlLeft
			gosub "DrawWallholeFill"
		endif

		if bHasSidelightRight then
			wcontLineIn			= _wcont_line_right_sl_in  * (iWallContourLineSl = 2 | iWallContourLineSl = 4)
			wcontLineOut		= _wcont_line_right_sl_out * (iWallContourLineSl = 3 | iWallContourLineSl = 4)
			sidelightCutLeft 	= 1
			sidelightCutRight 	= 0
			sidelightCutPosSillLeft		= rightWidth - gs_sidelight_WHole_width_right - gs_reveal_right_sR - thkPlasterAtSillSlRight
			sidelightCutPosMiddleLeft	= rightWidth - gs_sidelight_WHole_width_right
			sidelightCutPosBoardLeft	= rightWidth - gs_sidelight_WHole_width_right - gs_reveal_double_innerRight_sR - thkPlasterAtBoardSlRight
			gosub "DrawWallholeFill"
		endif

		wallholeFill	= gs_wallhole_fill
		wallholePen_fg	= gs_wallhole_pen_fg
		wallholePen_bg	= gs_wallhole_pen_bg
		wcontLineIn		= gs_wcont_line_in  * (iWallContourLine = 2 | iWallContourLine = 4)
		wcontLineOut	= gs_wcont_line_out * (iWallContourLine = 3 | iWallContourLine = 4)

		sidelightCutLeft  = 2 * bHasSidelightLeft
		sidelightCutRight = 2 * bHasSidelightRight
		sidelightCutPosSillLeft		= -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_left_sL + thkPlasterAtSillSlLeft
		sidelightCutPosMiddleLeft	= -leftWidth + gs_sidelight_WHole_width_left
		sidelightCutPosBoardLeft	= -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_double_innerLeft_sL + thkPlasterAtBoardSlLeft
		sidelightCutPosSillRight	= rightWidth - gs_sidelight_WHole_width_right - gs_reveal_right_sR - thkPlasterAtSillSlRight
		sidelightCutPosMiddleRight	= rightWidth - gs_sidelight_WHole_width_right
		sidelightCutPosBoardRight	= rightWidth - gs_sidelight_WHole_width_right - gs_reveal_double_innerRight_sR - thkPlasterAtBoardSlRight
		gosub "DrawWallholeFill"
	else
		wallholeFill	= gs_wallhole_fill
		wallholePen_fg	= gs_wallhole_pen_fg
		wallholePen_bg	= gs_wallhole_pen_bg
		wcontLineIn		= gs_wcont_line_in  * (iWallContourLine = 2 | iWallContourLine = 4)
		wcontLineOut	= gs_wcont_line_out * (iWallContourLine = 3 | iWallContourLine = 4)

		sidelightCutLeft  = 0
		sidelightCutRight = 0
		gosub "DrawWallholeFill"
	endif
endif


! Draw Parapet Contours Outside ------------------------------------------------

bWallContourLine	= (iWallContourLine = 3 | iWallContourLine = 4)							! Outside, Both Sides
bWallContourLineSl	= ((iWallContourLineSl = 3 | iWallContourLineSl = 4) & bTShapedOpening)	! Outside, Both Sides

if AC_WallType <> 2 & (bWallContourLine | bWallContourLineSl) & not(gs_transom_display) then
	gosub "DrawContourLinesOutside"
endif


! Draw Parapet Contour Inside --------------------------------------------------

bWallContourLine	= (iWallContourLine = 2 | iWallContourLine = 4)							! Inside, Both Sides
bWallContourLineSl	= ((iWallContourLineSl = 2 | iWallContourLineSl = 4) & bTShapedOpening)	! Inside, Both Sides

if not(bVisibleWallInsetIn2D) & AC_WallType <> 2 & (bWallContourLine | bWallContourLineSl) & not(gs_transom_display) then
	gosub "DrawContourLinesInside"
endif


! Head / Threshold Plan Symbol -------------------------------------------------

if iRevealType > REVEAL_NO & gs_head_symbol & (abs(gs_reveal_top) > EPS | abs(gs_reveal_bottom) > EPS) & not(gs_transom_display) then
	gosub "DrawHeadThresholdPlanSymbol"
endif


! Drawing the wall contour lines -----------------------------------------------

drawindex 50	! Draw wall contour lines at the top
bListView = (GLOB_CONTEXT = 6 | GLOB_CONTEXT = 46)
if not(bListView) then
	gosub "DrawWallContourLines"
endif


! Draw New Wallhole Symbol (SWE symbol) -----------------------------------------

if gs_bShowNewOnCC & (iTypeDemolitionFill = RENOVATION_FILL_NEW | iTypeDemolitionFill = RENOVATION_FILL_NEW_FULL) then
	gosub "DrawSWENewWallholeSymbol"
endif


! Drawing Mounting Frame -------------------------------------------------------

if bHaveMountingFrame & lod2D_MountingFrame > 0 then
	gosub "DrawMountingFrame"
endif


! ==============================================================================
end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
! ==============================================================================


"DrawWallholeFill":

! Cut 2D Wallhole - Straight, Trapezoid and Arched Walls ----------------------

	if (bUseOneBackgroundFill | bVisibleWallInsetIn2D | bNeedToOffsetSkins) then
		gosub "DrawWallholeFillBothSides"
	endif


! Draw Sill Side Background Fill and Parapet Contours -------------------------

	bUsePolygonOperations	= 0
	bCutWallInsetWithPolyOp	= 0
	bAutoParapetInset		= 0

	if (not(bUseOneBackgroundFill) | bVisibleWallInsetIn2D | bNeedToOffsetSkins) & not(bSkipSillFill) then
		gosub "DrawWallholeFillOutside"
	endif


! Draw Board Side Background Fill and Parapet Contours ------------------------

	gosub "DrawWallholeFillInside"
return



! ==============================================================================
! Cut wallhole - both sides
! ==============================================================================

"DrawWallholeFillBothSides":

	if AC_WallType <> 2 then

		bDrawFill = ((bDrawSillFill & bDrawBoardFill) & not(bVisibleWallInsetIn2D | bNeedToOffsetSkins))

		if curvedWall then put 0,WOD,900

		if sidelightCutLeft then
			if curvedWall then
				put sidelightCutPosSillLeft, WOD - signWallIsLeft * sqr(radSill^2 - sidelightCutPosSillLeft^2), 0
			else
				put sidelightCutPosSillLeft, leftRevealPnts[idxSillStartPlasterLeft][2], 0
			endif
			if abs(sidelightCutPosSillLeft - sidelightCutPosMiddleLeft) > EPS then
				put sidelightCutPosSillLeft,	0, 0,
					sidelightCutPosMiddleLeft,	0, 0
			endif
			if abs(sidelightCutPosMiddleLeft - sidelightCutPosBoardLeft) > EPS then
				put sidelightCutPosMiddleLeft,	WIDO_FRAME_THICKNESS, 0,
					sidelightCutPosBoardLeft,	WIDO_FRAME_THICKNESS, 0
			endif
			if curvedWall then
				put sidelightCutPosBoardLeft, WOD - signWallIsLeft * sqr(radBoard^2 - sidelightCutPosBoardLeft^2), 0
			else
				if bInclinedWall then
					put sidelightCutPosBoardLeft,
						leftRevealPnts[idxBoardEndPlasterLeft][2] + (leftRevealPnts[idxBoardEndPlasterLeft][1] - sidelightCutPosBoardLeft) * \
						(leftRevealPnts[idxBoardEndPlasterLeft][2] - rightRevealPnts[idxBoardEndPlasterRight][2]) / (-leftRevealPnts[idxBoardEndPlasterLeft][1] + rightRevealPnts[idxBoardEndPlasterRight][1]),
						0
				else
					put sidelightCutPosBoardLeft, leftRevealPnts[idxBoardEndPlasterLeft][2], 0
				endif
			endif
		else
			if bLeftCornerFunction then
				put leftRevealPnts[idxSillStartPlasterLeft][1],	leftRevealPnts[idxSillStartPlasterLeft][2],	0,
					leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2],	0,
					leftRevealPnts[idxBoardEndPlasterLeft][1],	leftRevealPnts[idxBoardEndPlasterLeft][2],	0
			else
				if	(( (iRevealType = REVEAL_EDGE) | (iRevealType = REVEAL_NO) ) &\
					 ( abs(thkPlasterAtSillLeft) < EPS ) &\
					 ( abs(thkPlasterAtBoardLeft) < EPS )) then

					put leftRevealPnts[idxSillStartPlasterLeft][1], leftRevealPnts[idxSillStartPlasterLeft][2], 0
					put leftRevealPnts[idxBoardEndPlasterLeft][1], leftRevealPnts[idxBoardEndPlasterLeft][2], 0
				else
					for i=idxSillStartPlasterLeft to idxSillEndPlasterLeft
						put leftRevealPnts[i][1], leftRevealPnts[i][2], 0
					next i

					if	(abs(leftRevealPnts[idxFrameStartRevealLeft][1] - leftRevealPnts[idxSillEndPlasterLeft][1]) > EPS) | \
						(abs(leftRevealPnts[idxFrameStartRevealLeft][2] - leftRevealPnts[idxSillEndPlasterLeft][2]) > EPS) then
							put leftRevealPnts[idxFrameStartRevealLeft][1],	leftRevealPnts[idxFrameStartRevealLeft][2], 0
					endif
					if	(abs(leftRevealPnts[idxFrameEndRevealLeft][1] - leftRevealPnts[idxBoardStartPlasterLeft][1]) > EPS) | \
						(abs(leftRevealPnts[idxFrameEndRevealLeft][2] - leftRevealPnts[idxBoardStartPlasterLeft][2]) > EPS) then
							put leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2], 0
					endif

					for i=idxBoardStartPlasterLeft to idxBoardEndPlasterLeft
						put leftRevealPnts[i][1], leftRevealPnts[i][2], 0
					next i
				endif
			endif
		endif

		if sidelightCutRight then
			if curvedWall then
				put sidelightCutPosBoardRight, WOD - signWallIsLeft * sqr(radBoard^2 - sidelightCutPosBoardRight^2), 3000 * bDrawFill
			else
				if bInclinedWall then
					put sidelightCutPosBoardRight,
						rightRevealPnts[idxBoardEndPlasterRight][2] + (rightRevealPnts[idxBoardEndPlasterRight][1] - sidelightCutPosBoardRight) * \
						(leftRevealPnts[idxBoardEndPlasterLeft][2] - rightRevealPnts[idxBoardEndPlasterRight][2]) / (-leftRevealPnts[idxBoardEndPlasterLeft][1] + rightRevealPnts[idxBoardEndPlasterRight][1]),
						0
				else
					put sidelightCutPosBoardRight, rightRevealPnts[idxBoardEndPlasterRight][2], 0
				endif
			endif
			if abs(sidelightCutPosBoardRight - sidelightCutPosMiddleRight) > EPS then
				put sidelightCutPosBoardRight,	WIDO_FRAME_THICKNESS, 0,
					sidelightCutPosMiddleRight,	WIDO_FRAME_THICKNESS, 0
			endif
			if abs(sidelightCutPosMiddleRight - sidelightCutPosSillRight) > EPS then
				put sidelightCutPosMiddleRight,	0, 0,
					sidelightCutPosSillRight,	0, 0
			endif
			if curvedWall then
				put sidelightCutPosSillRight, WOD - signWallIsLeft * sqr(radSill^2 - sidelightCutPosSillRight^2), 0
			else
				put sidelightCutPosSillRight, rightRevealPnts[idxSillStartPlasterRight][2], 0
			endif
		else
			if bRightCornerFunction then
				put rightRevealPnts[idxBoardEndPlasterRight][1],  rightRevealPnts[idxBoardEndPlasterRight][2],	0,
					rightRevealPnts[idxFrameEndRevealRight][1],   rightRevealPnts[idxFrameEndRevealRight][2],	0,
					rightRevealPnts[idxSillStartPlasterRight][1], rightRevealPnts[idxSillStartPlasterRight][2],	0
			else
				if	(( (iRevealType = REVEAL_EDGE) | (iRevealType = REVEAL_NO) ) &\
					 ( abs(thkPlasterAtSillRight) < EPS ) &\
					 ( abs(thkPlasterAtBoardRight) < EPS )) then

					put rightRevealPnts[idxBoardEndPlasterRight][1], rightRevealPnts[idxBoardEndPlasterRight][2]
					if curvedWall then
						put 3000 * (bDrawFill | not(wallIsLeft))
					else
						put 0
					endif
					put rightRevealPnts[idxSillStartPlasterRight][1], rightRevealPnts[idxSillStartPlasterRight][2], 0
				else
					for i = idxBoardEndPlasterRight to idxBoardStartPlasterRight step -1
						put rightRevealPnts[i][1], rightRevealPnts[i][2]
						if curvedWall & i = idxBoardEndPlasterRight then
							put 3000 * (bDrawFill | not(wallIsLeft))
						else
							put 0
						endif
					next i

					if	(abs(rightRevealPnts[idxFrameEndRevealLeft][1] - rightRevealPnts[idxBoardStartPlasterRight][1]) > EPS) | \
						(abs(rightRevealPnts[idxFrameEndRevealLeft][2] - rightRevealPnts[idxBoardStartPlasterRight][2]) > EPS) then
							put rightRevealPnts[idxFrameEndRevealLeft][1],	rightRevealPnts[idxFrameEndRevealLeft][2], 0
					endif
					if	(abs(rightRevealPnts[idxFrameStartRevealLeft][1] - rightRevealPnts[idxSillEndPlasterRight][1]) > EPS) | \
						(abs(rightRevealPnts[idxFrameStartRevealLeft][2] - rightRevealPnts[idxSillEndPlasterRight][2]) > EPS) then
							put rightRevealPnts[idxFrameStartRevealLeft][1],	rightRevealPnts[idxFrameStartRevealLeft][2], 0
					endif

					for i = idxSillEndPlasterRight to idxSillStartPlasterRight step -1
						put rightRevealPnts[i][1], rightRevealPnts[i][2], 0
					next i
				endif
			endif
		endif

		if curvedWall then
			if sidelightCutLeft then
				put sidelightCutPosSillLeft, leftRevealPnts[idxSillStartPlasterLeft][2], 3000 * (bDrawFill | wallIsLeft)
			else
				put leftRevealPnts[idxSillStartPlasterLeft][1], leftRevealPnts[idxSillStartPlasterLeft][2], 3000 * (bDrawFill | wallIsLeft)
			endif
		endif


		! Ignore point if location of previous point is same, contour bit is always zero
!!!		define style "text01" "arial", 0.3, 5, 0
!!!		set style "text01"
!!!		line_type 1

		_num = nsp/3
		dim temp_coord[][]
		for i = 1 to _num
			temp_x = get(1)
			temp_y = get(1)
			temp_s = get(1)

!!!			text2 temp_x, temp_y, i
!!!			circle2 temp_x, temp_y, 0.01

			temp_coord[i][1] = temp_x
			temp_coord[i][2] = temp_y
			temp_coord[i][3] = temp_s
		next i

		for i = 1 to _num
			if i > 1 then
				if not((abs(temp_coord[i-1][1] - temp_coord[i][1]) < EPS) & (abs(temp_coord[i-1][2] - temp_coord[i][2]) < EPS)) then
					put temp_coord[i][1]
					put temp_coord[i][2]
					put temp_coord[i][3]

!!!					text2 temp_coord[i][1], temp_coord[i][2], i
!!!					circle2 temp_coord[i][1], temp_coord[i][2], 0.01
				endif
			else
				put temp_coord[i][1]
				put temp_coord[i][2]
				put temp_coord[i][3]
			endif
		next i

		if nsp > 8 then
			if bDrawFill then
				fill wallholeFill
				if GLOB_CONTEXT = 5 then
					poly2_b nsp/3, 2 + 4 + 64, wallholePen_fg,wallholePen_bg,
						get(nsp)
				else
					wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
						0, 0, 0, get(nsp)
				endif
			else
				fill 0
				if GLOB_CONTEXT = 5 then
					poly2_b nsp/3, 2 + 4 + 64, 0, -1,
						get(nsp)
				else
					wallhole2 nsp/3, 2 + 64, 0, -1,
						0, 0, 0, get(nsp)
				endif
			endif
		else
			for i = 1 to nsp
				temp_param = get(1)
			next i
		endif
	endif


! ==============================================================================
! Cut 2D Wallhole - Polygonal Walls
! ==============================================================================

	if AC_WallType = 2 then

		ch = initaddonscope ("PolyOperations", "", "")

		preparefunction ch, "CreateContainer", "mySourceContainer", ""
		preparefunction ch, "CreateContainer", "myDestinationContainer", ""

		preparefunction ch, "SetSourceContainer",	 	"mySourceContainer", ""
		preparefunction ch, "SetDestinationContainer",	"myDestinationContainer", ""

! Store wallhole polygon -------------------------------------------------------

		if sidelightCutLeft then
			put sidelightCutPosSillLeft, leftRevealPnts[idxSillStartPlasterLeft][2],  3 * (sidelightCutLeft = 1),
				sidelightCutPosSillLeft, 0, 0
			if abs(sidelightCutPosSillLeft - sidelightCutPosMiddleLeft) > EPS then
				put	sidelightCutPosMiddleLeft,	0, 0
			endif
			if abs(sidelightCutPosMiddleLeft - sidelightCutPosBoardLeft) > EPS then
				put sidelightCutPosMiddleLeft,	0, 0
			endif
			put	sidelightCutPosBoardLeft, 0, 2 * (sidelightCutLeft = 1),
				sidelightCutPosBoardLeft, leftRevealPnts[idxBoardEndPlasterLeft][2], -1
		else
			bHasAnySillPoint = 0
			lastSillPointX = leftRevealPnts[idxSillStartRevealLeft][1]
			lastSillPointY = leftRevealPnts[idxSillStartRevealLeft][2]
			for i=idxSillStartRevealLeft to idxSillEndRevealLeft
				if leftRevealPnts[i][2] <= 0 then
					distFromLast = abs((leftRevealPnts[i][1] - lastSillPointX)^2 + (leftRevealPnts[i][2] - lastSillPointY)^2)
					if not(bHasAnySillPoint) | distFromLast > EPS then
						put leftRevealPnts[i][1], leftRevealPnts[i][2], not(gs_stack_left)
						lastSillPointX = leftRevealPnts[i][1]
						lastSillPointY = leftRevealPnts[i][2]
						bHasAnySillPoint = 1
					endif
				endif
			next i
			if idxFrameStartRevealLeft <> idxSillEndRevealLeft | not(bHasAnySillPoint) then
				put leftRevealPnts[idxFrameStartRevealLeft][1],	leftRevealPnts[idxFrameStartRevealLeft][2],	not(gs_stack_left)
			endif
			put leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2]
			bStatusSet = 0
			bHasAnyBoardPoint = 0
			lastBoardPointX = leftRevealPnts[idxBoardStartRevealLeft + (idxFrameEndRevealLeft = idxBoardStartRevealLeft)][1]
			lastBoardPointY = leftRevealPnts[idxBoardStartRevealLeft + (idxFrameEndRevealLeft = idxBoardStartRevealLeft)][2]
			for i=idxBoardStartRevealLeft + (idxFrameEndRevealLeft = idxBoardStartRevealLeft) to idxBoardEndRevealLeft
				if leftRevealPnts[i][2] >= WIDO_FRAME_THICKNESS then
					distFromLast = abs((leftRevealPnts[i][1] - lastBoardPointX)^2 + (leftRevealPnts[i][2] - lastBoardPointY)^2)
					if not(bHasAnyBoardPoint) | distFromLast > EPS then
						if not(bStatusSet) then
							put not(gs_stack_left)
							bStatusSet = 1
						endif
						put leftRevealPnts[i][1], leftRevealPnts[i][2]
						if i = idxBoardEndRevealLeft then
							put -1
						else
							put not(gs_stack_left)
						endif
						lastBoardPointX = leftRevealPnts[i][1]
						lastBoardPointY = leftRevealPnts[i][2]
						bHasAnyBoardPoint = 1
					endif
				endif
			next i
			if not(bStatusSet) then
				put -1
				bStatusSet = 1
			endif
		endif

		if sidelightCutRight then
			put sidelightCutPosBoardRight, rightRevealPnts[idxBoardEndPlasterRight][2], 2 * (sidelightCutRight = 1),
				sidelightCutPosBoardRight,	0, 0
			if abs(sidelightCutPosBoardRight - sidelightCutPosMiddleRight) > EPS then
				put	sidelightCutPosMiddleRight,	0, 0
			endif
			if abs(sidelightCutPosMiddleRight - sidelightCutPosSillRight) > EPS then
				put sidelightCutPosMiddleRight,	0, 0
			endif
			put	sidelightCutPosSillRight, 0, 3 * (sidelightCutRight = 1),
				sidelightCutPosSillRight, rightRevealPnts[idxSillStartPlasterRight][2], -1
		else
			bHasAnyBoardPoint = 0
			for i = idxBoardEndRevealRight to idxBoardStartRevealRight step -1
				if rightRevealPnts[i][2] >= WIDO_FRAME_THICKNESS then
					distFromLast = abs((rightRevealPnts[i][1] - lastBoardPointX)^2 + (rightRevealPnts[i][2] - lastBoardPointY)^2)
					if not(bHasAnyBoardPoint) | distFromLast > EPS then
						put rightRevealPnts[i][1], rightRevealPnts[i][2], not(gs_stack_right)
						lastBoardPointX = rightRevealPnts[i][1]
						lastBoardPointY = rightRevealPnts[i][2]
						bHasAnyBoardPoint = 1
					endif
				endif
			next i
			if idxFrameEndRevealRight <> idxBoardStartRevealRight | not(bHasAnyBoardPoint) then
				put rightRevealPnts[idxFrameEndRevealRight][1],	 rightRevealPnts[idxFrameEndRevealRight][2],	not(gs_stack_right)
			endif
			put rightRevealPnts[idxFrameStartRevealRight][1],rightRevealPnts[idxFrameStartRevealRight][2],	not(gs_stack_right)
			bHasAnySillPoint = 0
			lastSillPointX = rightRevealPnts[idxFrameStartRevealRight][1]
			lastSillPointY = rightRevealPnts[idxFrameStartRevealRight][2]
			for i = idxSillEndRevealRight - (idxFrameStartRevealRight = idxSillEndRevealRight) to idxSillStartRevealRight step -1
				if rightRevealPnts[i][2] <= 0 then
					distFromLast = abs((rightRevealPnts[i][1] - lastSillPointX)^2 + (rightRevealPnts[i][2] - lastSillPointY)^2)
					if distFromLast > EPS then
						put rightRevealPnts[i][1], rightRevealPnts[i][2]
						if i = idxSillStartRevealRight then
							put -1
						else
							put not(gs_stack_right)
						endif
						lastSillPointX = rightRevealPnts[i][1]
						lastSillPointY = rightRevealPnts[i][2]
						bHasAnySillPoint = 1
					endif
				endif
			next i
		endif

		nVertices1 = nsp/3
		dim vertArr1[][3]

		defaultInhEdgeInfo = 0
		dim inhEdgeInfos1[]

		for i=1 to nVertices1
			vertarr1[i][1]	 = get(1)
			vertarr1[i][2]	 = get(1)
			vertarr1[i][3]	 = 0
			inhEdgeInfos1[i] = get(1)	! Mark wallhole edges
		next i

		nContours1 = 1
		dim contArr1[]
		contArr1[1] = nVertices1 + 1

		preparefunction ch, "Store", "wallHolePoly", nVertices1, nContours1, vertArr1, contArr1, defaultInhEdgeInfo, inhEdgeInfos1

		prevSourceContainer	= ""
		lastDestContainer	= "mySourceContainer"
		preparefunction ch, "SetDestinationContainer", lastDestContainer, ""


! Offset sill side edge --------------------------------------------------------

		if prevSourceContainer <> "" then
			preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
		endif
		preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
		prevSourceContainer	= lastDestContainer
		lastDestContainer	= "myDestContainer1"
		preparefunction ch, "CreateContainer",			lastDestContainer, ""
		preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

		preparefunction ch, "OffsetParams", "", 1, 2.00

		dim srcPolyIDArr[]
		numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

		dim tempResPolyIDArr[]
		for i=1 to numPoly
			tempNumPoly = callfunction (ch, "OffsetEdge", srcPolyIDArr[i], tempResPolyIDArr)
		next i

!!!dim resPolyIDArr[]
!!!numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!for i = 1 to numPoly
!!!	polygonID = resPolyIDArr[i]
!!!	gosub 1000	! Get GDL Polygon
!!!
!!!	ccc=0
!!!	for j=1 to nsp/3
!!!		xx=get(1)
!!!		yy=get(1)
!!!		ss=get(1)
!!!		ccc=ccc+0.003
!!!		circle2 xx,yy,ccc
!!!		text2 xx,yy,j
!!!	next j
!!!next i
!!!end

! Offset board side edge -------------------------------------------------------

		dim dstPolyIDArr[]
		numPoly = callfunction (ch, "GetDestinationPolygons", "", dstPolyIDArr)

		dim edgeIds[]
		edgeIds[numPoly] = 0
		for i=1 to numPoly

			dim inhEdgeInfos[]
			numEdges = callfunction(ch, "GetInhEdgeInfos", dstPolyIDArr[i], inhEdgeInfos)

			for j=1 to numEdges
				if inhEdgeInfos[j] = -1 then edgeIds[i] = j
			next j
		next i

		if prevSourceContainer <> "" then
			preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
		endif
		preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
		prevSourceContainer	= lastDestContainer
		lastDestContainer	= "myDestContainer2"
		preparefunction ch, "CreateContainer",			lastDestContainer, ""
		preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

		dim srcPolyIDArr[]
		numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

		dim tempResPolyIDArr[]
		for i=1 to numPoly

			preparefunction ch, "OffsetParams", "", edgeIds[i], 2.00

			tempNumPoly = callfunction (ch, "OffsetEdge", srcPolyIDArr[i], tempResPolyIDArr)
		next i

!!!dim resPolyIDArr[]
!!!numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!for i = 1 to numPoly
!!!	polygonID = resPolyIDArr[i]
!!!	gosub 1000	! Get GDL Polygon
!!!
!!!	ccc=0
!!!	for j=1 to nsp/3
!!!		xx=get(1)
!!!		yy=get(1)
!!!		ss=get(1)
!!!		ccc=ccc+0.003
!!!		circle2 xx,yy,ccc
!!!		text2 xx,yy,j
!!!	next j
!!!next i
!!!end

! Store wall contour polygon in wallhole coordinate system ---------------------

		if prevSourceContainer <> "" then
			preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
		endif
		preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
		prevSourceContainer	= lastDestContainer
		lastDestContainer	= "myDestContainer3"
		preparefunction ch, "CreateContainer",			lastDestContainer, ""
		preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

		nVertices2 = vardim1(AC_WallContourPolygon)
		dim vertArr2[][3]

		dim srcPolyIDArr[]
		numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

		defaultInhEdgeInfo = 0
		dim inhEdgeInfos2[]

		for i=1 to nVertices2
			vertarr2[i][1] = AC_WallContourPolygon[i][1]
			if WIDO_REVEAL_SIDE then
				vertarr2[i][2] = AC_WallContourPolygon[i][2] + WIDO_FRAME_THICKNESS
				vertarr2[i][3] = AC_WallContourPolygon[i][3]
			else
				vertarr2[i][2] = -AC_WallContourPolygon[i][2]
				vertarr2[i][3] = -AC_WallContourPolygon[i][3]
			endif

			inhEdgeInfos2[i] = 2 + (vertarr2[i][2] < EPS)
		next i

		nContours2 = 1
		dim contArr2[]
		contArr2[1] = nVertices2 + 1

		preparefunction ch, "Store", "wallContourPoly", nVertices2, nContours2, vertArr2, contArr2, defaultInhEdgeInfo, inhEdgeInfos2

! Intersect polygons -----------------------------------------------------------

		dim tempResPolyIDArr[]
		for i = 1 to numPoly
			tempNumPoly = callfunction (ch, "wallContourPoly / " + srcPolyIDArr[i], "", tempResPolyIDArr)
		next i

! Draw polygons ----------------------------------------------------------------

		dim resPolyIDArr[]
		numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)

		if not(gs_transom_display) then 	! Not drawn when Display as Transom is ON
			for i = 1 to numPoly
				polygonID = resPolyIDArr[i]
				gosub 1000	! Get GDL Polygon

				if _bValidPoly then
					if bDrawSillFill & bDrawBoardFill & not(bVisibleWallInsetIn2D) then
						fill wallholeFill
						if GLOB_CONTEXT = 5 then
							poly2_b nsp/3, 2+4+64, wallholePen_fg,wallholePen_bg,
								get(nsp)
						else
							wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
								0, 0, 0, get(nsp)
						endif
					else
						fill 0
						if GLOB_CONTEXT = 5 then
							poly2_b nsp/3, 2+4+64, 0, -1,
								get(nsp)
						else
							wallhole2 nsp/3, 2 + 64, 0, -1,
								0, 0, 0, get(nsp)
						endif
					endif
				endif
			next i
		endif

! Draw wall contour lines ------------------------------------------------------

		dim lineAttributes[3][4]
		lineAttributes[1][1] = WALL_SECT_PEN
		lineAttributes[1][2] = WALL_LINETYPE
		lineAttributes[1][3] = LINE_PROPERTY_CONTOUR
		lineAttributes[1][4] = bitset(0, LINE_ATTRIBUTES_WALLLINE)

		lineAttributes[2][1] = gs_wcont_line_pen * (wcontLineIn > 0) * not(bVisibleWallInsetIn2D)	! Inside, Both Sides
		lineAttributes[2][2] = wcontLineIn
		lineAttributes[2][3] = LINE_PROPERTY_GENERIC
		lineAttributes[2][4] = bitset(0, LINE_ATTRIBUTES_GDLLINE)

		lineAttributes[3][1] = gs_wcont_line_pen * (wcontLineOut > 0)	! Outside, Both Sides
		lineAttributes[3][2] = wcontLineOut
		lineAttributes[3][3] = LINE_PROPERTY_GENERIC
		lineAttributes[3][4] = bitset(0, LINE_ATTRIBUTES_GDLLINE)

		bPutHotsopts	= (AC_WallType = 2)

		for i = 1 to numPoly
			polygonID = resPolyIDArr[i]
			gosub 1001	! Draw one polygon contour line
		next i

! Close channel ----------------------------------------------------------------

		closeaddonscope ch
	endif	! if AC_WallType = 2 then

return


! =============================================================================
! Draw Sill side background fill and parapet contours
! =============================================================================

"DrawWallholeFillOutside":

	if AC_WallType = 2 then
		bUsePolygonOperations	= 1
	else
		bUsePolygonOperations	= (offsetSill > EPS & offsetSill > WIDO_SILL)

! Draw Sill Side Fill or Wallhole ----------------------------------------------

		if curvedWall then put 0,WOD,900

		if sidelightCutLeft then
			if curvedWall then
				startX = sidelightCutPosSillLeft
				startY = WOD - signWallIsLeft * sqr(radSill^2 - sidelightCutPosSillLeft^2)
				put sidelightCutPosSillLeft, WOD - signWallIsLeft * sqr(radSill^2 - sidelightCutPosSillLeft^2), 0
			else
				put sidelightCutPosSillLeft, leftRevealPnts[idxSillStartPlasterLeft][2], 0
			endif
			put sidelightCutPosSillLeft, 0, 0
		else
			if bLeftCornerFunction then
				put leftRevealPnts[idxSillStartPlasterLeft][1],	leftRevealPnts[idxSillStartPlasterLeft][2] + (bNeedToOffsetSkins & not(bUsePolygonOperations)) * offsetSill, 0,
					leftRevealPnts[idxSillEndPlasterLeft][1],	leftRevealPnts[idxSillEndPlasterLeft][2], 0
			else
				if bNeedToOffsetSkins & not(bUsePolygonOperations) then
					idx = idxSillStartPlasterLeft
					if curvedWall then
						if bParalellInCurvedWalls then
							R = radSill - offsetSill * signWallIsLeft
							startX = leftRevealPnts[idx][1]
							startY = -signWallIsLeft * sqr(R^2 - startX^2) + WOD
						else
							alpha = abs(asn(leftRevealPnts[idx][1] / radSill))
							startX = -(radSill - signWallIsLeft * offsetSill) * sin(alpha)
							startY = -signWallIsLeft * (radSill - signWallIsLeft * offsetSill) * cos(alpha) + WOD
						endif
					else
						startX = leftRevealPnts[idx][1]
						startY = leftRevealPnts[idx][2] + offsetSill
					endif

					put startX, startY, 0
					for i=idxSillStartPlasterLeft + 1 to idxSillEndPlasterLeft
						put leftRevealPnts[i][1], leftRevealPnts[i][2], 0
					next i
				else
					startX = leftRevealPnts[idxSillStartPlasterLeft][1]
					startY = leftRevealPnts[idxSillStartPlasterLeft][2]

					for i=idxSillStartPlasterLeft to idxSillEndPlasterLeft
						put leftRevealPnts[i][1], leftRevealPnts[i][2], 0
					next i
				endif
			endif
		endif

		if sidelightCutRight then
			put	sidelightCutPosSillRight,	0, 0
			if curvedWall then
				put sidelightCutPosSillRight, WOD - signWallIsLeft * sqr(radSill^2 - sidelightCutPosSillRight^2), 0
			else
				put sidelightCutPosSillRight, rightRevealPnts[idxSillStartPlasterRight][2], 0
			endif
		else
			if bRightCornerFunction then
				put rightRevealPnts[idxSillEndPlasterRight][1],		rightRevealPnts[idxSillEndPlasterRight][2], 0,
					rightRevealPnts[idxSillStartPlasterRight][1],	rightRevealPnts[idxSillStartPlasterRight][2] + (bNeedToOffsetSkins & not(bUsePolygonOperations)) * offsetSill, 0
			else
				if bNeedToOffsetSkins & not(bUsePolygonOperations) then
					for i = idxSillEndPlasterRight to idxSillStartPlasterRight + 1 step -1
						put rightRevealPnts[i][1], rightRevealPnts[i][2]
						if curvedWall & gs_IsCurved & i = idxSillEndPlasterRight then
							put 3000
						else
							put 0
						endif
					next i

					idx = idxSillStartPlasterRight
					if curvedWall then
						if bParalellInCurvedWalls then
							R = radSill - offsetSill * signWallIsLeft
							put rightRevealPnts[idx][1], -signWallIsLeft * sqr(R^2 - rightRevealPnts[idx][1]^2) + WOD, 0
						else
							alpha = abs(asn(rightRevealPnts[idx][1] / radSill))
							put  (radSill - signWallIsLeft * offsetSill) * sin(alpha),
								-signWallIsLeft * (radSill - signWallIsLeft * offsetSill) * cos(alpha) + WOD, 0
						endif
					else
						put rightRevealPnts[idx][1], rightRevealPnts[idx][2] + offsetSill, 0
					endif
				else
					for i = idxSillEndPlasterRight to idxSillStartPlasterRight step -1
						put rightRevealPnts[i][1], rightRevealPnts[i][2]
						if curvedWall & gs_IsCurved & i = idxSillEndPlasterRight then
							put 3000
						else
							put 0
						endif
					next i
				endif
			endif
		endif

		if curvedWall then
			put startX, startY, 3000
		endif
	endif

	if bUsePolygonOperations then

		ch = initaddonscope ("PolyOperations", "", "")

		preparefunction ch, "CreateContainer", "mySourceContainer", ""
		preparefunction ch, "CreateContainer", "myDestinationContainer", ""

		preparefunction ch, "SetSourceContainer",	 	"mySourceContainer", ""
		preparefunction ch, "SetDestinationContainer",	"myDestinationContainer", ""

! Store wallhole polygon -------------------------------------------------------

		dim vertArr1[][3]
		dim inhEdgeInfos1[]
		defaultInhEdgeInfo = 0

		if AC_WallType = 2 then

			if sidelightCutLeft then
				put sidelightCutPosSillLeft, leftRevealPnts[idxSillStartPlasterLeft][2],  2 * (sidelightCutLeft = 1),
					sidelightCutPosSillLeft, 0,	-1
			else
				bHasAnySillPoint = 0
				for i=idxSillStartRevealLeft to idxSillEndRevealLeft
					if leftRevealPnts[i][2] <= 0 then
						distFromLast = abs((leftRevealPnts[i][1] - lastSillPointX)^2 + (leftRevealPnts[i][2] - lastSillPointY)^2)
						if not(bHasAnySillPoint) | distFromLast > EPS then
							if bHasAnySillPoint then
								put not(gs_stack_left)	! status of the previous point
							endif
							put leftRevealPnts[i][1], leftRevealPnts[i][2]
							lastSillPointX = leftRevealPnts[i][1]
							lastSillPointY = leftRevealPnts[i][2]
							bHasAnySillPoint = 1
						endif
					endif
				next i
				if bHasAnySillPoint then
					put -1	! last status
				endif
			endif

			if sidelightCutRight then
				put	sidelightCutPosSillRight, 0, 2 * (sidelightCutRight = 1),
					sidelightCutPosSillRight, rightRevealPnts[idxSillStartPlasterRight][2], -1
			else
				bHasAnySillPoint = 0
				for i = idxSillEndRevealRight to idxSillStartRevealRight step -1
					if rightRevealPnts[i][2] <= 0 then
						distFromLast = abs((rightRevealPnts[i][1] - lastSillPointX)^2 + (rightRevealPnts[i][2] - lastSillPointY)^2)
						if not(bHasAnySillPoint) | distFromLast > EPS then
							if bHasAnySillPoint then
								put not(gs_stack_right)	! status of the previous point
							endif
							put rightRevealPnts[i][1], rightRevealPnts[i][2]
							lastSillPointX = rightRevealPnts[i][1]
							lastSillPointY = rightRevealPnts[i][2]
							bHasAnySillPoint = 1
						endif
					endif
				next i
				if bHasAnySillPoint then
					put -1	! last status
				endif
			endif

			nVertices1 = nsp/3
			for i=1 to nVertices1
				vertarr1[i][1]	 = get(1)
				vertarr1[i][2]	 = get(1)
				vertarr1[i][3]	 = 0
				inhEdgeInfos1[i] = get(1)	! Mark wallhole edges
			next i
		else

			idx = 1
			inhEdgeInfosLast = 0

			for i=1 to nsp/3
				px = get(1)
				py = get(1)
				ps = round_int (get(1))

				if idx > 1 then
					bSkipThisVertex = (abs(px - vertarr1[1][1]) < EPS & abs(py - vertarr1[1][2]) < EPS)	! Skip this vertex if this is a closing one
				else
					bSkipThisVertex = 0
				endif

				if ps < 900 | ps >= 1000 then	! Skip state '900'
					if not(bSkipThisVertex) then
						vertarr1[idx][1] = px
						vertarr1[idx][2] = py
					endif
					if ps >= 3000 & ps < 4000 then
						if idx > 1 then
							vx = vertarr1[idx-1][1] - 0
							vy = vertarr1[idx-1][2] - WOD
							gosub 103	! Direction Angle
							savedAngle = angle

							vx = px - 0
							vy = py - WOD
							gosub 103	! Direction Angle

							vertarr1[idx-1][3] = angle - savedAngle
							if not(bSkipThisVertex) then
								inhEdgeInfos1[idx] = bittest(ps, 0)
							endif
						endif
					else
						if not(bSkipThisVertex) then
							vertarr1[idx][3] = 0
							inhEdgeInfos1[idx] = bittest(ps, 0)
						endif
					endif
					if not(bSkipThisVertex) then
						idx = idx + 1
					endif
				endif
			next i
			nVertices1 = vardim1(vertarr1)
		endif

		nContours1 = 1
		dim contArr1[]
		contArr1[1] = nVertices1 + 1

		if nVertices1 >= 2 then
			preparefunction ch, "Store", "wallHolePoly", nVertices1, nContours1, vertArr1, contArr1, defaultInhEdgeInfo, inhEdgeInfos1
		endif

		prevSourceContainer	= ""
		lastDestContainer	= "mySourceContainer"
		preparefunction ch, "SetDestinationContainer", lastDestContainer, ""

!!!ccc = 0
!!!for i=1 to vardim1(vertarr1)
!!!	ccc = ccc + 0.002
!!!	circle2 vertarr1[i][1], vertarr1[i][2], ccc
!!!next i

! Offset sill side edge --------------------------------------------------------

		if AC_WallType = 2 then
			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer1"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			preparefunction ch, "OffsetParams", "", 1, 0.50

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

			dim tempResPolyIDArr[]
			for i=1 to numPoly
				tempNumPoly = callfunction (ch, "OffsetEdge", srcPolyIDArr[i], tempResPolyIDArr)
			next i

!!!dim resPolyIDArr[]
!!!numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!for i = 1 to numPoly
!!!	polygonID = resPolyIDArr[i]
!!!	gosub 1000	! Get GDL Polygon
!!!
!!!	ccc=0
!!!	for j=1 to nsp/3
!!!		xx=get(1)
!!!		yy=get(1)
!!!		ss=get(1)
!!!		ccc=ccc+0.003
!!!		circle2 xx,yy,ccc
!!!		text2 xx,yy,j
!!!	next j
!!!next i
!!!end
		endif

! Store wall contour polygon in wallhole coordinate system ---------------------

		if AC_WallType = 2 then
			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer3"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			nVertices2 = vardim1(AC_WallContourPolygon)
			dim vertArr2[][3]

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

			defaultInhEdgeInfo = 0
			dim inhEdgeInfos2[]
!!!ccc=0
			for i=1 to nVertices2
				vertarr2[i][1] = AC_WallContourPolygon[i][1]
				if WIDO_REVEAL_SIDE then
					vertarr2[i][2] = AC_WallContourPolygon[i][2] + WIDO_FRAME_THICKNESS
					vertarr2[i][3] = AC_WallContourPolygon[i][3]
				else
					vertarr2[i][2] = -AC_WallContourPolygon[i][2]
					vertarr2[i][3] = -AC_WallContourPolygon[i][3]
				endif

				inhEdgeInfos2[i] = 2
!!!ccc=ccc+0.003
!!!circle2 vertarr2[i][1], vertarr2[i][2], ccc
!!!text2 vertarr2[i][1], vertarr2[i][2], i
			next i

			nContours2 = 1
			dim contArr2[]
			contArr2[1] = nVertices2 + 1

			preparefunction ch, "Store", "wallContourPoly", nVertices2, nContours2, vertArr2, contArr2, defaultInhEdgeInfo, inhEdgeInfos2

! Intersect polygons -----------------------------------------------------------

			dim tempResPolyIDArr[]
			for i = 1 to numPoly
				tempNumPoly = callfunction (ch, "wallContourPoly / " + srcPolyIDArr[i], "", tempResPolyIDArr)
			next i
		endif

! Regularize polygon(s) --------------------------------------------------------

		if curvedWall then

			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer1"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

			dim tempResPolyIDArr[]
			for i=1 to numPoly
				tempNumPoly = callfunction (ch, "Regularize", srcPolyIDArr[i], tempResPolyIDArr)
			next i


			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer2"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			preparefunction ch, "HalfPlaneParams", "", 0, 1, 0

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

			dim tempResPolyIDArr[]
			for i = 1 to numPoly
				tempNumPoly = callfunction (ch, "PolyCut", srcPolyIDArr[i], tempResPolyIDArr)
			next i
		endif

! Cut hidden wall skins polygon ------------------------------------------------

		if AC_WallType <> 2 then

			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer3"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

! Store hidden wall skins polygon ----------------------------------------------

			if curvedWall then
				pxL1 = -radSill - signWallIsLeft * 0.1
				pyL1 = WOD

				pxL2 = -radSill + signWallIsLeft * offsetSill
				pyL2 = WOD

				pxR1 = radSill + signWallIsLeft * 0.1
				pyR1 = WOD

				pxR2 = radSill - signWallIsLeft * offsetSill
				pyR2 = WOD
			else
				pxL1 = -leftWidth - 1.0
				pyL1 = -WIDO_SILL - 0.1

				pxL2 = pxL1
				pyL2 = -WIDO_SILL + offsetSill

				pxR1 = rightWidth + 1.0
				pyR1 = -WIDO_SILL - 0.1

				pxR2 = pxR1
				pyR2 = -WIDO_SILL + offsetSill
			endif

!!!text2 0,0.2, WALL_THICKNESS
!!!circle2 0,0, 0.01
!!!fill 1
!!!pen 1
!!!poly2_b 4, 1+2+4+64, 1,0,
!!!	pxL1, pyL1, 1,
!!!	pxL2, pyL2, 1,
!!!	pxR2, pyR2, 1,
!!!	pxR1, pyR1, 1
!!!fill wallholeFill
!!!end
			nVertices2 = 4
			dim vertArr2[][3]
			vertarr2[1][1] = pxL1
			vertarr2[1][2] = pyL1
			vertarr2[1][3] = 0

			vertarr2[2][1] = pxL2
			vertarr2[2][2] = pyL2
			vertarr2[2][3] = curvedWall * signWallIsLeft * (180)

			vertarr2[3][1] = pxR2
			vertarr2[3][2] = pyR2
			vertarr2[3][3] = 0

			vertarr2[4][1] = pxR1
			vertarr2[4][2] = pyR1
			vertarr2[4][3] = curvedWall * signWallIsLeft * (-180)

			nContours2 = 1
			dim contArr2[]
			contArr2[1] = nVertices2 + 1

			preparefunction ch, "Store", "wallSkinPoly", nVertices2, nContours2, vertArr2, contArr2

! Substract polygons -----------------------------------------------------------

			dim tempResPolyIDArr[]
			for i = 1 to numPoly
				tempNumPoly = callfunction(ch, srcPolyIDArr[i] + " - wallSkinPoly", "", tempResPolyIDArr)
			next i
		endif

! Draw resulting polygons ------------------------------------------------------

		dim resPolyIDArr[]
		numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)

		for i = 1 to numPoly
			polygonID = resPolyIDArr[i]
			gosub 1000	! Get GDL Polygon

			if _bValidPoly then
				if bDrawSillFill then
					fill wallholeFill
					if GLOB_CONTEXT = 5 then
						poly2_b nsp/3, 2+4+64, wallholePen_fg,wallholePen_bg,
							get(nsp)
					else
						wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
							0,0,0, get(nsp)
					endif
				else
					fill 0
					if GLOB_CONTEXT = 5 then
						poly2_b nsp/3, 2+4+64, 0,-1,
							get(nsp)
					else
						wallhole2 nsp/3, 2 + 64, 0,-1,
							0,0,0, get(nsp)
					endif
				endif
			endif
		next i

! Draw wall contour lines ------------------------------------------------------

		if AC_WallType = 2 then
			dim lineAttributes[2][4]
			lineAttributes[1][1] = WALL_SECT_PEN
			lineAttributes[1][2] = WALL_LINETYPE
			lineAttributes[1][3] = LINE_PROPERTY_CONTOUR
			lineAttributes[1][4] = bitset(0, LINE_ATTRIBUTES_WALLLINE)

			lineAttributes[2][1] = gs_wcont_line_pen * (wcontLineOut > 0)	! Outside, Both Sides
			lineAttributes[2][2] = wcontLineOut
			lineAttributes[2][3] = LINE_PROPERTY_GENERIC
			lineAttributes[2][4] = bitset(0, LINE_ATTRIBUTES_GDLLINE)

			bPutHotsopts	= (AC_WallType = 2)

			for i = 1 to numPoly
				polygonID = resPolyIDArr[i]
				gosub 1001	! Draw one polygon contour line
			next i
		endif

! Close channel ----------------------------------------------------------------

		closeaddonscope ch
	endif	! if bUsePolygonOperations then

! Draw polygons without polygon operations -------------------------------------

	if not(bUsePolygonOperations) then
		if bDrawSillFill then
			fill wallholeFill
			if GLOB_CONTEXT = 5 then
				poly2_b nsp/3, 2+4+64, wallholePen_fg,wallholePen_bg,
					get(nsp)
			else
				wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
					0,0,0, get(nsp)
			endif
		else
			fill 0
			if GLOB_CONTEXT = 5 then
				poly2_b nsp/3, 2+4+64, 0,-1,
					get(nsp)
			else
				wallhole2 nsp/3, 2 + 64, 0,-1,
					0,0,0, get(nsp)
			endif
		endif
	endif
return


! =============================================================================
! Draw Board side background fill and parapet contours
! =============================================================================

"DrawWallholeFillInside":

	if not(bUseOneBackgroundFill) | bVisibleWallInsetIn2D | bNeedToOffsetSkins then

! Draw Board Side Fill or Wallhole =============================================

		bAutoParapetInset = (gs_parapet_autodim)

		if AC_WallType = 2 then
			bUsePolygonOperations	= 1
			bCutWallInsetWithPolyOp	= bVisibleWallInsetIn2D
		else
			bUsePolygonOperations	= (offsetBoard > EPS)

			if curvedWall then put 0,WOD,900

			if curvedWall then
				insetY = WOD - signWallIsLeft * radBoard - parapetWallInsetDepth
			endif

			if sidelightCutLeft then
				put sidelightCutPosMiddleLeft,	0, 0
				if abs(sidelightCutPosMiddleLeft - sidelightCutPosBoardLeft) > EPS then
					put sidelightCutPosMiddleLeft,	WIDO_FRAME_THICKNESS, 0,
						sidelightCutPosBoardLeft,	WIDO_FRAME_THICKNESS, 0
				endif
				if curvedWall then
					put sidelightCutPosBoardLeft, WOD - signWallIsLeft * sqr(radBoard^2 - sidelightCutPosBoardLeft^2), 0
				else
					if bInclinedWall then
						put sidelightCutPosBoardLeft,
							leftRevealPnts[idxBoardEndPlasterLeft][2] + (leftRevealPnts[idxBoardEndPlasterLeft][1] - sidelightCutPosBoardLeft) * \
							(leftRevealPnts[idxBoardEndPlasterLeft][2] - rightRevealPnts[idxBoardEndPlasterRight][2]) / (-leftRevealPnts[idxBoardEndPlasterLeft][1] + rightRevealPnts[idxBoardEndPlasterRight][1]),
							0
					else
						put sidelightCutPosBoardLeft, leftRevealPnts[idxBoardEndPlasterLeft][2], 0
					endif
				endif
			else
				if bLeftCornerFunction then
					startPointIdx = idxFrameStartRevealLeft
					put leftRevealPnts[idxFrameStartRevealLeft][1], leftRevealPnts[idxFrameStartRevealLeft][2], 0
					if bVisibleWallInsetIn2D then
						put leftRevealPnts[idxBoardEndPlasterLeft][1] - parapetWallInsetDepth * lx, leftRevealPnts[idxBoardEndPlasterLeft][2] - parapetWallInsetDepth,  1
						if gs_reveal_hotspots then
							hotspot2 leftRevealPnts[idxBoardEndPlasterLeft][1] - parapetWallInsetDepth * lx,
									 leftRevealPnts[idxBoardEndPlasterLeft][2] - parapetWallInsetDepth,
									 11040
						endif
					else
						put leftRevealPnts[idxBoardEndPlasterLeft][1], leftRevealPnts[idxBoardEndPlasterLeft][2],  1
					endif
				else
					if bAutoParapetInset & bVisibleWallInsetIn2D then
						startPointIdx = idxFrameStartRevealLeft
						put leftRevealPnts[idxFrameStartRevealLeft][1],	leftRevealPnts[idxFrameStartRevealLeft][2], 0
						put leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2], 0
						for i = idxBoardStartPlasterLeft to idxBoardEndPlasterLeft - 1
							put leftRevealPnts[i][1], leftRevealPnts[i][2], 0
						next i

						idx = idxBoardEndPlasterLeft
						if not(gs_stack_left) & (iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC) then
							if curvedWall then
								pxInsetLeft	= leftRevealPnts[idx][1] + abs(leftRevealPnts[idx][2] - insetY) * tan(gs_reveal_left_angle)
								pyInsetLeft	= insetY
							else
								pxInsetLeft	= leftRevealPnts[idx][1] + parapetWallInsetDepth * sin(gs_reveal_left_angle)
								pyInsetLeft	= leftRevealPnts[idx][2] - parapetWallInsetDepth
							endif
						else
							if curvedWall then
								if bParalellInCurvedWalls then
									pxInsetLeft	= leftRevealPnts[idx][1]
									pyInsetLeft	= insetY
								else
									alpha = abs(asn(leftRevealPnts[idx][1] / radBoard))
									pxInsetLeft	= -abs(tan(alpha) * (WOD - insetY))
									pyInsetLeft	= insetY
								endif
							else
								pxInsetLeft	= leftRevealPnts[idx][1]
								pyInsetLeft	= leftRevealPnts[idx][2] - parapetWallInsetDepth
							endif
						endif
						if curvedWall & not(wallIsLeft) & pyInsetLeft > leftRevealPnts[idx][2] then
							pxInsetLeft	= leftRevealPnts[idx][1]
							pyInsetLeft	= leftRevealPnts[idx][2]
						endif

						if not(curvedWall) | wallIsLeft then
							if gs_reveal_hotspots then
								hotspot2 pxInsetLeft, pyInsetLeft, 11040
							endif
						endif

						put pxInsetLeft, pyInsetLeft, 1

						if curvedWall then
							if not(wallIsLeft) & insetY > pyInsetLeft + EPS then
								put -sqr(radBoard^2 - (insetY - WOD)^2), insetY, 3001
								if gs_reveal_hotspots then
									hotspot2 -sqr(radBoard^2 - (insetY - WOD)^2), insetY, 11040
								endif
							endif
						endif
					else
						if WIDO_FRAME_THICKNESS > EPS then
						startPointIdx = idxFrameStartRevealLeft
							put leftRevealPnts[idxFrameStartRevealLeft][1], leftRevealPnts[idxFrameStartRevealLeft][2], 0
							put leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2], 0
						else
							startPointIdx = idxBoardStartPlasterLeft
						endif
						for i = idxBoardStartPlasterLeft to idxBoardEndPlasterLeft
							put leftRevealPnts[i][1], leftRevealPnts[i][2], (i = idxBoardEndPlasterLeft & bUseOneBackgroundFill)
						next i
					endif
				endif
			endif

! Draw not full width wall inset recess -------------------------------------- [

			bCutWallInsetWithPolyOp = 0

			if not(bAutoParapetInset) & bVisibleWallInsetIn2D then
				cx = 0
				cy = WALL_THICKNESS - WIDO_SILL

				if curvedWall then
					if bParalellInCurvedWalls then
						pxL1 = cx - opInner / 2 - parapetExtendLeft
						pyL1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxL1^2)

						pxL2 = pxL1
						pyL2 = insetY

						pxR1 = cx + opInner / 2 + parapetExtendRight
						pyR1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxR1^2)

						pxR2 = pxR1
						pyR2 = insetY

						if parapet_width > leftWidth + rightWidth then
							bUsePolygonOperations	= 1	! Lets cut it with polygon operations
							bCutWallInsetWithPolyOp	= 1
						endif
					else
						pxL1 = cx - opInner / 2 - parapetExtendLeft
						pyL1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxL1^2)

						alpha = abs(asn(pxL1 / radBoard))
						pxL2 = pxL1 - signWallIsLeft * tan(alpha) * abs(pyL1 - insetY)
						pyL2 = insetY

						pxR1 = cx + opInner / 2 + parapetExtendRight
						pyR1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxR1^2)

						alpha = abs(asn(pxR1 / radBoard))
						pxR2 = pxR1 + signWallIsLeft * tan(alpha) * abs(pyR1 - insetY)
						pyR2 = insetY

						if wallIsLeft | (bParapetWallInset & not(bAutoParapetInset)) then
							bUsePolygonOperations	= 1	! Lets cut it with polygon operations
							bCutWallInsetWithPolyOp	= 1
						endif
					endif

					if gs_reveal_hotspots then	! Show wall inset hotspot
						if pyL1 > pyL2 then
							hotspot2 pxL2, pyL2, 11040
							hotspot2 pxL1, pyL1, 11042
						else
							hotspot2 -sqr(radBoard^2 - (insetY - WOD)^2), insetY, 11040
						endif

						if pyR1 > pyR2 then
							hotspot2 pxR2, pyR2, 11041
							hotspot2 pxR1, pyR1, 11043
						else
							hotspot2 sqr(radBoard^2 - (insetY - WOD)^2), insetY, 11041
						endif
					endif

					if not(bCutWallInsetWithPolyOp) then
						if pyL1 > pyL2 then
							put pxL1, pyL1, 3001,
								pxL2, pyL2, 1
						else
							put -sqr(radBoard^2 - (insetY - WOD)^2), insetY, 3001
						endif
						if pyR1 > pyR2 then
							put pxR2, pyR2, 1,
								pxR1, pyR1, 1
							if gs_reveal_hotspots then	! Show wall inset hotspot
								hotspot2 pxR2, pyR2, 11041
								hotspot2 pxR1, pyR1, 11043
							endif
						else
							put sqr(radBoard^2 - (insetY - WOD)^2), insetY, 1
							if gs_reveal_hotspots then	! Show wall inset hotspot
								hotspot2 sqr(radBoard^2 - (insetY - WOD)^2), insetY, 11041
							endif
						endif
					endif
				else
					if bInclinedWall then
						pxL1 = -leftWidth  - overSizeLeft - revYL - parapetExtendLeft * cos(WALL_INCL)
						pyL1 = WALL_THICKNESS - WIDO_SILL - py2p

						pxL2 = pxL1 + parapetWallInsetDepth * incV
						pyL2 = pyL1 - parapetWallInsetDepth * incH

						pxR1 = rightWidth + overSizeRight + revYR + parapetExtendRight * cos(WALL_INCL)
						pyR1 = WALL_THICKNESS - WIDO_SILL - py1p

						pxR2 = pxR1 + parapetWallInsetDepth * incV
						pyR2 = pyR1 - parapetWallInsetDepth * incH
					else
						pxL1 = cx - opInner / 2 - parapetExtendLeft
						pyL1 = cy

						pxL2 = pxL1
						pyL2 = pyL1 - parapetWallInsetDepth

						pxR1 = cx + opInner / 2 + parapetExtendRight
						pyR1 = cy

						pxR2 = pxR1
						pyR2 = pyR1 - parapetWallInsetDepth
					endif

					if parapet_width > leftWidth + rightWidth then
						bUsePolygonOperations	= 1	! Lets cut it with polygon operations
						bCutWallInsetWithPolyOp	= 1
					endif

					if not(bLeftCornerFunction) then
						if not(bCutWallInsetWithPolyOp) then
							put pxL1, pyL1, 1,
								pxL2, pyL2, 1
						endif
						if gs_reveal_hotspots then	! Show wall inset hotspot
							hotspot2 pxL2, pyL2, 11040
							hotspot2 pxL1, pyL1, 11042
						endif
					endif
					if not(bRightCornerFunction) then
						if not(bCutWallInsetWithPolyOp) then
							put pxR2, pyR2, 1,
								pxR1, pyR1, 1
						endif
						if gs_reveal_hotspots then	! Show wall inset hotspot
							hotspot2 pxR2, pyR2, 11041
							hotspot2 pxR1, pyR1, 11043
						endif
					endif
				endif

!!!circle2 pxL1, pyL1, 0.005
!!!circle2 pxL2, pyL2, 0.010
!!!circle2 pxR2, pyR2, 0.015
!!!circle2 pxR1, pyR1, 0.020

			endif

! ] Draw not full width wall inset recess --------------------------------------

			if sidelightCutRight then
				if curvedWall then
					put sidelightCutPosBoardRight, WOD - signWallIsLeft * sqr(radBoard^2 - sidelightCutPosBoardRight^2), 3000
				else
					if bInclinedWall then
						put sidelightCutPosBoardRight,
							rightRevealPnts[idxBoardEndPlasterRight][2] + (rightRevealPnts[idxBoardEndPlasterRight][1] - sidelightCutPosBoardRight) * \
							(leftRevealPnts[idxBoardEndPlasterLeft][2] - rightRevealPnts[idxBoardEndPlasterRight][2]) / (-leftRevealPnts[idxBoardEndPlasterLeft][1] + rightRevealPnts[idxBoardEndPlasterRight][1]),
							0
					else
						put sidelightCutPosBoardRight, rightRevealPnts[idxBoardEndPlasterRight][2], 0
					endif
				endif
				if abs(sidelightCutPosBoardRight - sidelightCutPosMiddleRight) > EPS then
					put sidelightCutPosBoardRight,	WIDO_FRAME_THICKNESS, 0,
						sidelightCutPosMiddleRight,	WIDO_FRAME_THICKNESS, 0
				endif
				put sidelightCutPosMiddleRight,	0, 0
			else
				if bRightCornerFunction then
					if bVisibleWallInsetIn2D then
						put rightRevealPnts[idxBoardEndPlasterRight][1] + parapetWallInsetDepth * rx, rightRevealPnts[idxBoardEndPlasterRight][2] - parapetWallInsetDepth,  0
						put rightRevealPnts[idxBoardEndPlasterRight][1] + parapetWallInsetDepth * rx, rightRevealPnts[idxBoardEndPlasterRight][2] - parapetWallInsetDepth,  0

						if gs_reveal_hotspots then
							hotspot2 rightRevealPnts[idxBoardEndPlasterRight][1] + parapetWallInsetDepth * rx,
									 rightRevealPnts[idxBoardEndPlasterRight][2] - parapetWallInsetDepth,
									 11041
						endif
					else
						put rightRevealPnts[idxBoardEndPlasterRight][1], rightRevealPnts[idxBoardEndPlasterRight][2],  0
					endif
					put rightRevealPnts[idxFrameStartRevealRight][1], rightRevealPnts[idxFrameStartRevealRight][2], 0
				else
					if bAutoParapetInset & bVisibleWallInsetIn2D then
						idx = idxBoardEndPlasterRight
						psInsetRight = 0

						if not(gs_stack_right) & (iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC) then
							if curvedWall then
								pxInsetRight	= rightRevealPnts[idx][1] - abs(rightRevealPnts[idx][2] - insetY) * tan(gs_reveal_right_angle)
								pyInsetRight	= insetY
							else
								pxInsetRight	= rightRevealPnts[idx][1] - parapetWallInsetDepth * sin(gs_reveal_right_angle)
								pyInsetRight	= rightRevealPnts[idx][2] - parapetWallInsetDepth
							endif
						else
							if curvedWall then
								if bParalellInCurvedWalls then
									alpha = abs(asn(rightRevealPnts[idx][1] / radBoard))
									pxInsetRight	= rightRevealPnts[idx][1]
									pyInsetRight	= insetY
								else
									alpha = abs(asn(rightRevealPnts[idx][1] / radBoard))
									pxInsetRight	= abs(tan(alpha) * (WOD - insetY))
									pyInsetRight	= insetY
								endif
							else
								pxInsetRight	= rightRevealPnts[idx][1]
								pyInsetRight	= rightRevealPnts[idx][2] - parapetWallInsetDepth
							endif
						endif
						if curvedWall & not(wallIsLeft) & pyInsetRight > rightRevealPnts[idx][2] then
							pxInsetRight	= rightRevealPnts[idx][1]
							pyInsetRight	= rightRevealPnts[idx][2]
						endif

						if not(curvedWall) | wallIsLeft then
							if gs_reveal_hotspots then
								hotspot2 pxInsetRight, pyInsetRight, 11041
							endif
						endif

						if curvedWall then
							if not(wallIsLeft) & insetY > pyInsetRight + EPS then
								put sqr(radBoard^2 - (insetY - WOD)^2), insetY, 1
								psInsetRight = 3000
								if gs_reveal_hotspots then
									hotspot2 sqr(radBoard^2 - (insetY - WOD)^2), insetY, 11041
								endif
							endif
						endif

						put pxInsetRight, pyInsetRight, psInsetRight

						for i = idxBoardEndPlasterRight - 1 to idxBoardStartPlasterRight step -1
							put rightRevealPnts[i][1], rightRevealPnts[i][2], 0
						next i
						put rightRevealPnts[idxFrameEndRevealRight][1],		rightRevealPnts[idxFrameEndRevealRight][2], 0
						put rightRevealPnts[idxFrameStartRevealRight][1],	rightRevealPnts[idxFrameStartRevealRight][2], 0
					else
						for i = idxBoardEndPlasterRight to idxBoardStartPlasterRight step -1
							put rightRevealPnts[i][1], rightRevealPnts[i][2]
							if curvedWall & i = idxBoardEndPlasterRight then
								put 3000
							else
								put 0
							endif
						next i
						if WIDO_FRAME_THICKNESS > EPS then
							put rightRevealPnts[idxFrameEndRevealRight][1],		rightRevealPnts[idxFrameEndRevealRight][2], 0
							put rightRevealPnts[idxFrameStartRevealRight][1],	rightRevealPnts[idxFrameStartRevealRight][2], 0
						endif
					endif
				endif
			endif

			if curvedWall & gs_IsCurved then
				put leftRevealPnts[startPointIdx][1], leftRevealPnts[startPointIdx][2], 3000
			endif
		endif	! if not(AC_WallType = 2) then

		if bUsePolygonOperations then
			! If there is hidden wall skins because of actual partial structure display settings
			! If we have custom size wall inset in curved wall

			ch = initaddonscope ("PolyOperations", "", "")

			preparefunction ch, "CreateContainer",	 "mySourceContainer", ""
			preparefunction ch, "SetSourceContainer", "mySourceContainer", ""

! Store original wallhole polygon ----------------------------------------------

			dim vertArr1[][3]

			defaultInhEdgeInfo = -1
			dim inhEdgeInfos1[]

			if AC_WallType = 2 then

				if sidelightCutLeft then
					put sidelightCutPosMiddleLeft,	0, 0
					if abs(sidelightCutPosSillLeft - sidelightCutPosMiddleLeft) > EPS then
						put	sidelightCutPosMiddleLeft,	0, 0
					endif
					if abs(sidelightCutPosMiddleLeft - sidelightCutPosBoardLeft) > EPS then
						put sidelightCutPosMiddleLeft,	WIDO_FRAME_THICKNESS, 0
					endif
					put	sidelightCutPosBoardLeft, WIDO_FRAME_THICKNESS, 2 * (sidelightCutLeft = 1),
						sidelightCutPosBoardLeft, leftRevealPnts[idxBoardEndPlasterLeft][2], -1
				else
					put leftRevealPnts[idxFrameStartRevealLeft][1],	leftRevealPnts[idxFrameStartRevealLeft][2],	not(gs_stack_left)
					put leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2]

					lastBoardPointX = leftRevealPnts[idxFrameEndRevealLeft][1]
					lastBoardPointY = leftRevealPnts[idxFrameEndRevealLeft][2]
					for i=idxBoardStartRevealLeft to idxBoardEndRevealLeft
						if leftRevealPnts[i][2] >= WIDO_FRAME_THICKNESS then
							distFromLast = abs((leftRevealPnts[i][1] - lastBoardPointX)^2 + (leftRevealPnts[i][2] - lastBoardPointY)^2)
							if distFromLast > EPS then
								put not(gs_stack_left)	! previous pont status
								put leftRevealPnts[i][1], leftRevealPnts[i][2]
								lastBoardPointX = leftRevealPnts[i][1]
								lastBoardPointY = leftRevealPnts[i][2]
								bHasAnyBoardPoint = 1
							endif
						endif
					next i
					put -1	! last pont status
				endif

				if sidelightCutRight then
					put sidelightCutPosBoardRight, rightRevealPnts[idxBoardEndPlasterRight][2], 2 * (sidelightCutRight = 1),
						sidelightCutPosBoardRight,	WIDO_FRAME_THICKNESS, 0
					if abs(sidelightCutPosBoardRight - sidelightCutPosMiddleRight) > EPS then
						put	sidelightCutPosMiddleRight,	WIDO_FRAME_THICKNESS, 0
					endif
					if abs(sidelightCutPosMiddleRight - sidelightCutPosSillRight) > EPS then
						put sidelightCutPosMiddleRight,	0, 0
					endif
					put sidelightCutPosMiddleRight,	0, 0
				else
					bHasAnyBoardPoint = 0
					for i = idxBoardEndRevealRight to idxBoardStartRevealRight step -1
						if rightRevealPnts[i][2] >= WIDO_FRAME_THICKNESS then
							distFromLast = abs((rightRevealPnts[i][1] - lastBoardPointX)^2 + (rightRevealPnts[i][2] - lastBoardPointY)^2)
							if not(bHasAnyBoardPoint) | distFromLast > EPS then
								put rightRevealPnts[i][1], rightRevealPnts[i][2], not(gs_stack_right)
								lastBoardPointX = rightRevealPnts[i][1]
								lastBoardPointY = rightRevealPnts[i][2]
								bHasAnyBoardPoint = 1
							endif
						endif
					next i
					if idxBoardStartRevealRight <> idxFrameEndRevealRight then
						put rightRevealPnts[idxFrameEndRevealRight][1],	rightRevealPnts[idxFrameEndRevealRight][2],	not(gs_stack_right)
					endif
					put rightRevealPnts[idxFrameStartRevealRight][1],rightRevealPnts[idxFrameStartRevealRight][2],	0
				endif

				nVertices1 = nsp/3
				for i=1 to nVertices1
					vertarr1[i][1]	 = get(1)
					vertarr1[i][2]	 = get(1)
					vertarr1[i][3]	 = 0
					inhEdgeInfos1[i] = get(1)	! Mark wallhole edges
				next i
			else

				idx = 1
				inhEdgeInfosLast = 0

				for i=1 to nsp/3
					px = get(1)
					py = get(1)
					ps = round_int (get(1))

					if idx > 1 then
						bSkipThisVertex = (abs(px - vertarr1[1][1]) < EPS & abs(py - vertarr1[1][2]) < EPS)	! Skip this vertex if this is a closing one
						if not(bSkipThisVertex) then
							bSkipThisVertex = (abs(px - vertarr1[idx-1][1]) < EPS & abs(py - vertarr1[idx-1][2]) < EPS)
						endif
					else
						bSkipThisVertex = 0
					endif

					if ps < 900 | ps >= 1000 then	! Skip state '900'
						if not(bSkipThisVertex) then
							vertarr1[idx][1] = px
							vertarr1[idx][2] = py
						endif
						if ps >= 3000 & ps < 4000 then
							if idx > 1 then
								vx = vertarr1[idx-1][1] - 0
								vy = vertarr1[idx-1][2] - WOD
								gosub 103	! Direction Angle
								savedAngle = angle

								vx = px - 0
								vy = py - WOD
								gosub 103	! Direction Angle

								vertarr1[idx-1][3] = angle - savedAngle
								if not(bSkipThisVertex) then
									inhEdgeInfos1[idx] = 2 * bittest(ps, 0)
								endif
							endif
						else
							if not(bSkipThisVertex) then
								vertarr1[idx][3] = 0
								inhEdgeInfos1[idx] = 2 * bittest(ps, 0)
							endif
						endif
						if not(bSkipThisVertex) then
							idx = idx + 1
						endif
					endif
				next i
				nVertices1 = vardim1(vertarr1)
			endif	! if not(AC_WallType = 2) then

			nContours1 = 1
			dim contArr1[]
			contArr1[1] = nVertices1 + 1

			if nVertices1 >= 2 then
				preparefunction ch, "Store", "poly1", nVertices1, nContours1, vertArr1, contArr1, defaultInhEdgeInfo, inhEdgeInfos1
			endif

			prevSourceContainer	= ""
			lastDestContainer	= "mySourceContainer"
			preparefunction ch, "SetDestinationContainer", lastDestContainer, ""

! Offset board side edge -------------------------------------------------------

			if AC_WallType = 2 then
				dim dstPolyIDArr[]
				numPoly = callfunction (ch, "GetDestinationPolygons", "", dstPolyIDArr)

				dim edgeIds[]
				edgeIds[numPoly] = 0
				for i=1 to numPoly

					dim inhEdgeInfos[]
					numEdges = callfunction(ch, "GetInhEdgeInfos", dstPolyIDArr[i], inhEdgeInfos)

					for j=1 to numEdges
						if inhEdgeInfos[j] = -1 then edgeIds[i] = j
					next j
				next i

				if prevSourceContainer <> "" then
					preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
				endif
				preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
				prevSourceContainer	= lastDestContainer
				lastDestContainer	= "myDestContainer2"
				preparefunction ch, "CreateContainer",			lastDestContainer, ""
				preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

				dim srcPolyIDArr[]
				numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

				dim tempResPolyIDArr[]
				for i=1 to numPoly

					preparefunction ch, "OffsetParams", "", edgeIds[i], 0.50

					tempNumPoly = callfunction (ch, "OffsetEdge", srcPolyIDArr[i], tempResPolyIDArr)
				next i

!!!dim resPolyIDArr[]
!!!numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!for i = 1 to numPoly
!!!	polygonID = resPolyIDArr[i]
!!!	gosub 1000	! Get GDL Polygon
!!!
!!!	ccc=0
!!!	for j=1 to nsp/3
!!!		xx=get(1)
!!!		yy=get(1)
!!!		ss=get(1)
!!!		ccc=ccc+0.003
!!!		circle2 xx,yy,ccc
!!!		text2 xx,yy,j
!!!	next j
!!!next i
!!!end
			endif	! if AC_WallType = 2 then

! Regularize polygon(s) - avoid generating invalid polygons --------------------

			if curvedWall | WIDO_SILL + WIDO_FRAME_THICKNESS >= WALL_THICKNESS | bVisibleWallInsetIn2D | abs(WIDO_FRAME_THICKNESS) < EPS then

				if prevSourceContainer <> "" then
					preparefunction ch, "DeleteContainer",			prevSourceContainer, ""
				endif
				preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
				prevSourceContainer	= lastDestContainer
				lastDestContainer	= "myDestContainer1"
				preparefunction ch, "CreateContainer",			lastDestContainer, ""
				preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

				dim srcPolyIDArr[]
				numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

				dim tempResPolyIDArr[]
				for i=1 to numPoly
					tempNumPoly = callfunction (ch, "Regularize", srcPolyIDArr[i], tempResPolyIDArr)
				next i
			endif

			if curvedWall then

				if prevSourceContainer <> "" then
					preparefunction ch, "DeleteContainer",			prevSourceContainer, ""
				endif
				preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
				prevSourceContainer	= lastDestContainer
				lastDestContainer	= "myDestContainer2"
				preparefunction ch, "CreateContainer",			lastDestContainer, ""
				preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

				preparefunction ch, "HalfPlaneParams", "", 0, -1, 0

				dim srcPolyIDArr[]
				numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

				dim tempResPolyIDArr[]
				for i = 1 to numPoly
					tempNumPoly = callfunction (ch, "PolyCut", srcPolyIDArr[i], tempResPolyIDArr)
				next i
			endif

!!!	dim resPolyIDArr[]
!!!	numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!	text2 0,0, numPoly
!!!
!!!	for i = 1 to numPoly
!!!		polygonID = resPolyIDArr[i]
!!!		gosub 1000	! Get GDL Polygon
!!!
!!!		if bDrawBoardFill then
!!!			fill wallholeFill
!!!			wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
!!!				0,0,0, get(nsp)
!!!		else
!!!			fill 0
!!!			wallhole2 nsp/3, 2 + 64, 0,-1,
!!!				0,0,0, get(nsp)
!!!		endif
!!!	next i
!!!end

!!!ccc = 0
!!!for i=1 to vardim1(vertarr1)
!!!	ccc = ccc + 0.002
!!!	circle2 vertarr1[i][1], vertarr1[i][2], ccc
!!!next i


! Cut hidden wall skins polygon ------------------------------------------------

			if (offsetBoard > EPS) then

				if prevSourceContainer <> "" then
					preparefunction ch, "DeleteContainer",			prevSourceContainer, ""
				endif
				preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
				prevSourceContainer	= lastDestContainer
				lastDestContainer	= "myDestContainer3"
				preparefunction ch, "CreateContainer",			lastDestContainer, ""
				preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

				dim srcPolyIDArr[]
				numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

! Store hidden wall skins polygon ----------------------------------------------

				if curvedWall then
					pxL1 = -radBoard + signWallIsLeft * 0.1
					pyL1 = WOD

					pxL2 = -radBoard - signWallIsLeft * offsetBoard
					pyL2 = WOD

					pxR1 = radBoard - signWallIsLeft * 0.1
					pyR1 = WOD

					pxR2 = radBoard + signWallIsLeft * offsetBoard
					pyR2 = WOD
				else
					if bInclinedWall then
						pxL1 = -leftWidth - 1.0
						pyL1 = WALL_THICKNESS - WIDO_SILL + pxL1 * incX + 0.1

						pxL2 = pxL1
						pyL2 = WALL_THICKNESS - WIDO_SILL - offsetBoard * incFactor * incY + pxL2 * incX

						pxR1 = rightWidth + 1.0
						pyR1 = WALL_THICKNESS - WIDO_SILL + pxR1 * incX + 0.1

						pxR2 = pxR1
						pyR2 = WALL_THICKNESS - WIDO_SILL - offsetBoard * incFactor * incY + pxR2 * incX
					else
						pxL1 = -leftWidth - 1.0
						pyL1 = WALL_THICKNESS - WIDO_SILL + 0.1

						pxL2 = pxL1
						pyL2 = WALL_THICKNESS - WIDO_SILL - offsetBoard

						pxR1 = rightWidth + 1.0
						pyR1 = WALL_THICKNESS - WIDO_SILL + 0.1

						pxR2 = pxR1
						pyR2 = WALL_THICKNESS - WIDO_SILL - offsetBoard
					endif
				endif

!!!text2 0,0.2, WALL_THICKNESS
!!!circle2 0,0, 0.01
!!!fill 1
!!!pen 1
!!!poly2_b 4, 1+2+4+64, 1,0,
!!!	pxL1, pyL1, 1,
!!!	pxL2, pyL2, 1,
!!!	pxR2, pyR2, 1,
!!!	pxR1, pyR1, 1
!!!fill wallholeFill

				nVertices2 = 4
				dim vertArr2[][3]

				defaultInhEdgeInfo = -1
				dim inhEdgeInfos2[]

				vertarr2[1][1] = pxL1
				vertarr2[1][2] = pyL1
				vertarr2[1][3] = 0
				inhEdgeInfos2[1] = 2

				vertarr2[2][1] = pxL2
				vertarr2[2][2] = pyL2
				vertarr2[2][3] = curvedWall * signWallIsLeft * 180
				inhEdgeInfos2[2] = 2

				vertarr2[3][1] = pxR2
				vertarr2[3][2] = pyR2
				vertarr2[3][3] = 0
				inhEdgeInfos2[3] = 2

				vertarr2[4][1] = pxR1
				vertarr2[4][2] = pyR1
				vertarr2[4][3] = curvedWall * signWallIsLeft * (-180)
				inhEdgeInfos2[4] = 2

				nContours2 = 1
				dim contArr2[]
				contArr2[1] = nVertices2 + 1

				preparefunction ch, "Store", "poly2", nVertices2, nContours2, vertArr2, contArr2, defaultInhEdgeInfo, inhEdgeInfos2

! Substract polygons -----------------------------------------------------------

				dim tempResPolyIDArr[]
				for i = 1 to numPoly
					tempNumPoly = callfunction(ch, srcPolyIDArr[i] + " - poly2", "", tempResPolyIDArr)
				next i
			endif


!!!	dim resPolyIDArr[]
!!!	numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!	text2 0,0, numPoly
!!!
!!!	for i = 1 to numPoly
!!!		polygonID = resPolyIDArr[i]
!!!		gosub 1000	! Get GDL Polygon
!!!
!!!		if bDrawBoardFill then
!!!			fill wallholeFill
!!!			wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
!!!				0,0,0, get(nsp)
!!!		else
!!!			fill 0
!!!			wallhole2 nsp/3, 2 + 64, 0,-1,
!!!				0,0,0, get(nsp)
!!!		endif
!!!	next i
!!!end


! Store wall inset polygon -----------------------------------------------------

			if bCutWallInsetWithPolyOp then

				if prevSourceContainer <> "" then
					preparefunction ch, "DeleteContainer",			prevSourceContainer, ""
				endif
				preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
				prevSourceContainer	= lastDestContainer
				lastDestContainer	= "myDestContainer4"
				preparefunction ch, "CreateContainer",			lastDestContainer, ""
				preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

				dim srcPolyIDArr[]
				numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

				if curvedWall then
					if bParalellInCurvedWalls then
						pxL1 = cx - opInner / 2 - parapetExtendLeft
						pyL1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxL1^2)

						pxL2 = pxL1
						pyL2 = insetY

						pxR1 = cx + opInner / 2 + parapetExtendRight
						pyR1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxR1^2)

						pxR2 = pxR1
						pyR2 = insetY
					else
						pxL1 = cx - opInner / 2 - parapetExtendLeft
						pyL1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxL1^2)

						alpha = abs(asn(pxL1 / radBoard))
						pxL2 = pxL1 - signWallIsLeft * tan(alpha) * abs(pyL1 - insetY)
						pyL2 = insetY

						pxR1 = cx + opInner / 2 + parapetExtendRight
						pyR1 = WOD - signWallIsLeft * sqr(radBoard^2 - pxR1^2)

						alpha = abs(asn(pxR1 / radBoard))
						pxR2 = pxR1 + signWallIsLeft * tan(alpha) * abs(pyR1 - insetY)
						pyR2 = insetY

						if not(wallIsLeft) then
							if pyL1 < pyL2 then
								pxL2 = -sqr(radBoard^2 - (insetY - WOD)^2)
								pyL2 = insetY

								pxL1 = pxL2
								pyL1 = pyL2
							endif
							if pyR1 < pyR2 then
								pxR2 = sqr(radBoard^2 - (insetY - WOD)^2)
								pyR2 = insetY

								pxR1 = pxR2
								pyR1 = pyR2
							endif
						endif
					endif
				else
					if bInclinedWall then
						pxL1 = -leftWidth  - overSizeLeft - revYL - parapetExtendLeft * incH
						pyL1 = WALL_THICKNESS - WIDO_SILL - py2p

						pxL2 = pxL1 + parapetWallInsetDepth * incV
						pyL2 = pyL1 - parapetWallInsetDepth * incH

						pxR1 = rightWidth + overSizeRight + revYR + parapetExtendRight * incH
						pyR1 = WALL_THICKNESS - WIDO_SILL - py1p

						pxR2 = pxR1 + parapetWallInsetDepth * incV
						pyR2 = pyR1 - parapetWallInsetDepth * incH
					else
						pxL1 = -opInner / 2 - parapetExtendLeft - 1.0 * gs_parapet_autodim
						pyL1 = WALL_THICKNESS - WIDO_SILL + 1.0 * (AC_WallType = 2)

						pxL2 = pxL1
						pyL2 = WALL_THICKNESS - WIDO_SILL - parapetWallInsetDepth

						pxR1 = opInner / 2 + parapetExtendRight + 1.0 * gs_parapet_autodim
						pyR1 = WALL_THICKNESS - WIDO_SILL + 1.0 * (AC_WallType = 2)

						pxR2 = pxR1
						pyR2 = WALL_THICKNESS - WIDO_SILL - parapetWallInsetDepth
					endif
				endif

!!!circle2 pxL1, pyL1, 0.005
!!!circle2 pxL2, pyL2, 0.010
!!!circle2 pxR2, pyR2, 0.015
!!!circle2 pxR1, pyR1, 0.020

				nVertices4 = 4 + (curvedWall & not(wallIsLeft))
				dim vertArr4[][3]

				defaultInhEdgeInfo = -1
				dim inhEdgeInfos4[]

				vertarr4[1][1] = pxL1
				vertarr4[1][2] = pyL1
				vertarr4[1][3] = 0
				inhEdgeInfos4[1] = 2

				vertarr4[2][1] = pxL2
				vertarr4[2][2] = pyL2
				vertarr4[2][3] = 0
				inhEdgeInfos4[2] = 2

				vertarr4[3][1] = pxR2
				vertarr4[3][2] = pyR2
				vertarr4[3][3] = 0
				inhEdgeInfos4[3] = 2

				vertarr4[4][1] = pxR1
				vertarr4[4][2] = pyR1
				vertarr4[4][3] = 0
				inhEdgeInfos4[4] = 2

				if curvedWall & not(wallIsLeft) then
					vertarr4[5][1] = 0
					vertarr4[5][2] = pyR1 + WALL_THICKNESS
					vertarr4[5][3] = 0
					inhEdgeInfos4[5] = -1
				endif

				nContours4 = 1
				dim contArr4[]
				contArr4[1] = nVertices4 + 1

				preparefunction ch, "Store", "WallInset", nVertices4, nContours4, vertArr4, contArr4, defaultInhEdgeInfo, inhEdgeInfos4

! Substract polygons -----------------------------------------------------------

				dim tempResPolyIDArr[]
				for i = 1 to numPoly
					tempNumPoly = callfunction(ch, srcPolyIDArr[i] + " - WallInset", "", tempResPolyIDArr)
				next i
			endif

! Store wall contour polygon in wallhole coordinate system ---------------------

			if AC_WallType = 2 then
				if prevSourceContainer <> "" then
					preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
				endif
				preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
				prevSourceContainer	= lastDestContainer
				lastDestContainer	= "myDestContainer3"
				preparefunction ch, "CreateContainer",			lastDestContainer, ""
				preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

				nVertices2 = vardim1(AC_WallContourPolygon)
				dim vertArr2[][3]

				dim srcPolyIDArr[]
				numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

				defaultInhEdgeInfo = 0
				dim inhEdgeInfos2[]
!!!ccc=0
				for i=1 to nVertices2
					vertarr2[i][1] = AC_WallContourPolygon[i][1]
					if WIDO_REVEAL_SIDE then
						vertarr2[i][2] = AC_WallContourPolygon[i][2] + WIDO_FRAME_THICKNESS
						vertarr2[i][3] = AC_WallContourPolygon[i][3]
					else
						vertarr2[i][2] = -AC_WallContourPolygon[i][2]
						vertarr2[i][3] = -AC_WallContourPolygon[i][3]
					endif

					inhEdgeInfos2[i] = 2
!!!ccc=ccc+0.003
!!!circle2 vertarr2[i][1], vertarr2[i][2], ccc
!!!text2 vertarr2[i][1], vertarr2[i][2], i
				next i

				nContours2 = 1
				dim contArr2[]
				contArr2[1] = nVertices2 + 1

				preparefunction ch, "Store", "wallContourPoly", nVertices2, nContours2, vertArr2, contArr2, defaultInhEdgeInfo, inhEdgeInfos2

! Intersect polygons -----------------------------------------------------------

				dim tempResPolyIDArr[]
				for i = 1 to numPoly
					tempNumPoly = callfunction (ch, "wallContourPoly / " + srcPolyIDArr[i], "", tempResPolyIDArr)
				next i
			endif

! Draw resulting polygons ------------------------------------------------------

			dim resPolyIDArr[]
			numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)

!!!text2 0,0, numPoly

			for i = 1 to numPoly
				polygonID = resPolyIDArr[i]
				gosub 1000	! Get GDL Polygon

				if _bValidPoly then
					if bDrawBoardFill then
						fill wallholeFill
						if GLOB_CONTEXT = 5 then
							poly2_b nsp/3, 2+64, wallholePen_fg,wallholePen_bg,
								get(nsp)
						else
							wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
								0,0,0, get(nsp)
						endif
					else
						fill 0
						if GLOB_CONTEXT = 5 then
							poly2_b nsp/3, 2+64, 0,-1,
								get(nsp)
						else
							wallhole2 nsp/3, 2 + 64, 0,-1,
								0,0,0, get(nsp)
						endif
					endif
				endif
			next i

! Draw resulting contours ------------------------------------------------------

			if ( (AC_WallType = 2) & not(bNeedToOffsetSkins) ) | bVisibleWallInsetIn2D then
				dim lineAttributes[2][4]
				lineAttributes[1][1] = WALL_SECT_PEN
				lineAttributes[1][2] = WALL_LINETYPE
				lineAttributes[1][3] = LINE_PROPERTY_CONTOUR
				lineAttributes[1][4] = bitset(0, LINE_ATTRIBUTES_WALLLINE)

				lineAttributes[2][1] = gs_wcont_line_pen * (wcontLineIn > 0)	! Inside, Both Sides
				if bHiddenParapetWallInsetIn2D then
					lineAttributes[2][2] = gs_parapet_line
				else
					lineAttributes[2][2] = wcontLineIn
				endif
				lineAttributes[2][3] = LINE_PROPERTY_GENERIC
				lineAttributes[2][4] = bitset(0, LINE_ATTRIBUTES_GDLLINE)

				bPutHotsopts	= (AC_WallType = 2)

				for i = 1 to numPoly
					polygonID = resPolyIDArr[i]
					gosub 1001	! Draw one polygon contour line
				next i
			endif
		endif	! if bUsePolygonOperations then

		if not(bUsePolygonOperations) then
			if (wcontLineIn > 0) then		! Inside, Both Sides
				pen gs_wcont_line_pen
				line_property 0
				if bHiddenParapetWallInsetIn2D then
					line_type gs_parapet_line
				else
					line_type wcontLineIn
				endif

				poly2_ nsp/3, 1,use(nsp)
			endif

			if bDrawBoardFill then
				fill wallholeFill
				if GLOB_CONTEXT = 5 then
					poly2_b nsp/3, 2+4+64, wallholePen_fg,wallholePen_bg,
						get(nsp)
				else
					wallhole2 nsp/3, 2 + 64, wallholePen_fg,wallholePen_bg,
						0,0,0, get(nsp)
				endif
			else
				fill 0
				if GLOB_CONTEXT = 5 then
					poly2_b nsp/3, 2+4+64, 0, -1,
						get(nsp)
				else
					wallhole2 nsp/3, 2 + 64, 0,-1,
						0,0,0, get(nsp)
				endif
			endif

		endif

	endif

!-------------------------------------------------------------------------------
! Draw hidden parts of Wall Inset
!-------------------------------------------------------------------------------

	if gs_parapet_2D & bUsePolygonOperations & bParapetWallInset & bCutWallInsetWithPolyOp & not(bAutoParapetInset) & \
		not((gs_stack_left | bLeftCornerFunction) & (gs_stack_right | bRightCornerFunction)) then

		if prevSourceContainer <> "" then
			preparefunction ch, "DeleteContainer", prevSourceContainer, ""
		endif
		if lastDestContainer <> "" then
			preparefunction ch, "DeleteContainer", lastDestContainer, ""
		endif

		preparefunction ch, "CreateContainer",	 "mySourceContainer", ""
		preparefunction ch, "SetSourceContainer", "mySourceContainer", ""

		prevSourceContainer	= ""
		lastDestContainer	= "mySourceContainer"
		preparefunction ch, "SetDestinationContainer", lastDestContainer, ""

! Store wallhole polygon -------------------------------------------------------

		bHasAnySillPoint = 0
		for i=idxSillStartPlasterLeft to idxSillEndPlasterLeft
			if leftRevealPnts[i][2] <= 0 then
				distFromLast = abs((leftRevealPnts[i][1] - lastSillPointX)^2 + (leftRevealPnts[i][2] - lastSillPointY)^2)
				if not(bHasAnySillPoint) | distFromLast > EPS then
					put leftRevealPnts[i][1], leftRevealPnts[i][2], not(gs_stack_left)
					lastSillPointX = leftRevealPnts[i][1]
					lastSillPointY = leftRevealPnts[i][2]
					bHasAnySillPoint = 1
				endif
			endif
		next i
		if idxFrameStartRevealLeft <> idxSillEndPlasterLeft | not(bHasAnySillPoint) then
			put leftRevealPnts[idxFrameStartRevealLeft][1],	leftRevealPnts[idxFrameStartRevealLeft][2],	not(gs_stack_left)
		endif
		put leftRevealPnts[idxFrameEndRevealLeft][1],	leftRevealPnts[idxFrameEndRevealLeft][2],	not(gs_stack_left)
		bHasAnyBoardPoint = 0
		for i=idxBoardStartPlasterLeft + (idxFrameEndRevealLeft = idxBoardStartPlasterLeft) to idxBoardEndPlasterLeft
			if leftRevealPnts[i][2] >= WIDO_FRAME_THICKNESS then
				distFromLast = abs((leftRevealPnts[i][1] - lastBoardPointX)^2 + (leftRevealPnts[i][2] - lastBoardPointY)^2)
				if not(bHasAnyBoardPoint) | distFromLast > EPS then
					put leftRevealPnts[i][1], leftRevealPnts[i][2]
					if i = idxBoardEndPlasterLeft then
						put -1
					else
						put not(gs_stack_left)
					endif
					lastBoardPointX = leftRevealPnts[i][1]
					lastBoardPointY = leftRevealPnts[i][2]
					bHasAnyBoardPoint = 1
				endif
			endif
		next i

		bHasAnyBoardPoint = 0
		for i = idxBoardEndPlasterRight to idxBoardStartPlasterRight step -1
			if rightRevealPnts[i][2] >= WIDO_FRAME_THICKNESS then
				distFromLast = abs((rightRevealPnts[i][1] - lastBoardPointX)^2 + (rightRevealPnts[i][2] - lastBoardPointY)^2)
				if not(bHasAnyBoardPoint) | distFromLast > EPS then
					put rightRevealPnts[i][1], rightRevealPnts[i][2], not(gs_stack_right)
					lastBoardPointX = rightRevealPnts[i][1]
					lastBoardPointY = rightRevealPnts[i][2]
					bHasAnyBoardPoint = 1
				endif
			endif
		next i
		if idxFrameEndRevealRight <> idxBoardStartPlasterRight | not(bHasAnyBoardPoint) then
			put rightRevealPnts[idxFrameEndRevealRight][1],	 rightRevealPnts[idxFrameEndRevealRight][2],	not(gs_stack_right)
		endif
		put rightRevealPnts[idxFrameStartRevealRight][1],rightRevealPnts[idxFrameStartRevealRight][2],	not(gs_stack_right)
		bHasAnySillPoint = 0
		lastSillPointX = rightRevealPnts[idxFrameStartRevealRight][1]
		lastSillPointY = rightRevealPnts[idxFrameStartRevealRight][2]
		for i = idxSillEndPlasterRight - (idxFrameStartRevealRight = idxSillEndPlasterRight) to idxSillStartPlasterRight step -1
			if rightRevealPnts[i][2] <= 0 then
				distFromLast = abs((rightRevealPnts[i][1] - lastSillPointX)^2 + (rightRevealPnts[i][2] - lastSillPointY)^2)
				if distFromLast > EPS then
					put rightRevealPnts[i][1], rightRevealPnts[i][2]
					if i = idxSillStartPlasterRight then
						put -1
					else
						put not(gs_stack_right)
					endif
					lastSillPointX = rightRevealPnts[i][1]
					lastSillPointY = rightRevealPnts[i][2]
					bHasAnySillPoint = 1
				endif
			endif
		next i

		nVertices1 = nsp/3
		dim vertArr1[][3]

		defaultInhEdgeInfo = 0
		dim inhEdgeInfos1[]

		idx = 1
		for i=1 to nVertices1
			px = get(1)
			py = get(1)
			ps = get(1)
			if i = 1 then
				bSkipThisPoint = 0
			else
				bSkipThisPoint = (abs(px - vertarr1[idx-1][1]) < EPS & abs(py - vertarr1[idx-1][2]) < EPS)
			endif
			if not(bSkipThisPoint) then
				vertarr1[idx][1]	 = px
				vertarr1[idx][2]	 = py
				vertarr1[idx][3]	 = 0
				inhEdgeInfos1[idx] = ps	! Mark wallhole edges
				idx = idx + 1
			endif
		next i
		nVertices1 = idx - 1

		nContours1 = 1
		dim contArr1[]
		contArr1[1] = nVertices1 + 1

		preparefunction ch, "Store", "wallHolePoly", nVertices1, nContours1, vertArr1, contArr1, defaultInhEdgeInfo, inhEdgeInfos1

! Regularize polygon(s) - avoid generating invalid polygons --------------------

		if curvedWall then

			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer1"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

			dim tempResPolyIDArr[]
			for i=1 to numPoly
				tempNumPoly = callfunction (ch, "Regularize", srcPolyIDArr[i], tempResPolyIDArr)
			next i
		endif

! Offset board side edge -------------------------------------------------------

		dim srcPolyIDArr2[]
		numPoly = callfunction (ch, "GetDestinationPolygons", "", srcPolyIDArr2)

		dim edgeIds[]
		edgeIds[numPoly] = 0
		for i=1 to numPoly
			dim inhEdgeInfos[]
			numEdges = callfunction(ch, "GetInhEdgeInfos", srcPolyIDArr2[i], inhEdgeInfos)

			for j=1 to numEdges
				if inhEdgeInfos[j] = -1 then edgeIds[i] = j
			next j
		next i

		if prevSourceContainer <> "" then
			preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
		endif
		preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
		prevSourceContainer	= lastDestContainer
		lastDestContainer	= "myDestContainer2"
		preparefunction ch, "CreateContainer",			lastDestContainer, ""
		preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

		dim srcPolyIDArr[]
		numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

		dim tempResPolyIDArr[]
		for i=1 to numPoly

			preparefunction ch, "OffsetParams", "", edgeIds[i], 0.50

			tempNumPoly = callfunction (ch, "OffsetEdge", srcPolyIDArr[i], tempResPolyIDArr)
		next i

!!!dim resPolyIDArr[]
!!!numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!for i = 1 to numPoly
!!!	polygonID = resPolyIDArr[i]
!!!	gosub 1000	! Get GDL Polygon
!!!
!!!	ccc=0
!!!	for j=1 to nsp/3
!!!		xx=get(1)
!!!		yy=get(1)
!!!		ss=get(1)
!!!		ccc=ccc+0.003
!!!		circle2 xx,yy,ccc
!!!		text2 xx,yy,j
!!!	next j
!!!next i
!!!end

! Store wall inset polygon -----------------------------------------------------

		if prevSourceContainer <> "" then
			preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
		endif
		preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
		prevSourceContainer	= lastDestContainer
		lastDestContainer	= "myDestContainer3"
		preparefunction ch, "CreateContainer",			lastDestContainer, ""
		preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

		dim srcPolyIDArr[]
		numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

		nVertices4 = 4 + (curvedWall & not(wallIsLeft))
		dim vertArr4[][3]

		defaultInhEdgeInfo = -1
		dim inhEdgeInfos4[]

		vertarr4[1][1] = pxL1 * not(gs_stack_left | bLeftCornerFunction)
		vertarr4[1][2] = pyL1
		vertarr4[1][3] = 0
		inhEdgeInfos4[1] = 2

		vertarr4[2][1] = pxL2 * not(gs_stack_left | bLeftCornerFunction)
		vertarr4[2][2] = pyL2
		vertarr4[2][3] = 0
		inhEdgeInfos4[2] = 2

		vertarr4[3][1] = pxR2 * not(gs_stack_right | bRightCornerFunction)
		vertarr4[3][2] = pyR2
		vertarr4[3][3] = 0
		inhEdgeInfos4[3] = 2

		vertarr4[4][1] = pxR1 * not(gs_stack_right | bRightCornerFunction)
		vertarr4[4][2] = pyR1
		vertarr4[4][3] = 0
		inhEdgeInfos4[4] = 0

		if curvedWall & not(wallIsLeft) then
			vertarr4[5][1] = 0
			vertarr4[5][2] = pyR1 + WALL_THICKNESS
			vertarr4[5][3] = 0
			inhEdgeInfos4[5] = 0
		endif

		nContours4 = 1
		dim contArr4[]
		contArr4[1] = nVertices4 + 1

		preparefunction ch, "Store", "WallInset", nVertices4, nContours4, vertArr4, contArr4, defaultInhEdgeInfo, inhEdgeInfos4

! Substract polygons -----------------------------------------------------------

		dim tempResPolyIDArr[]
		for i = 1 to numPoly
			tempNumPoly = callfunction(ch, "WallInset - " + srcPolyIDArr[i], "", tempResPolyIDArr)
		next i

!!!! Substract polygons -----------------------------------------------------------
!!!
!!!	dim srcPolyIDArr[]
!!!	numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)
!!!
!!!	dim operandPolygonNames[]
!!!		operandPolygonNames[1] = "WallInset"
!!!	numOperandPolygonNames = 1
!!!	containerIdx = 10
!!!
!!!	while numPoly > 0 do
!!!
!!!		for i = 2 to numPoly
!!!			tempNumPoly = callfunction (ch, "CopyPolygon", srcPolyIDArr[i], tempResPolyIDArr)
!!!		next i
!!!		lastNumPoly = numPoly - 1
!!!
!!!		for i=1 to numOperandPolygonNames
!!!			tempNumPoly = callfunction (ch, operandPolygonNames[i] + " - " + srcPolyIDArr[1], "", tempResPolyIDArr)
!!!		next i
!!!
!!!		numResPoly = tempNumPoly - lastNumPoly + 1
!!!
!!!		dim resPolyIDArr[]
!!!		tempNumPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)
!!!
!!!		numOperandPolygonNames = tempNumPoly - lastNumPoly
!!!
!!!		for i=1 to numOperandPolygonNames
!!!			operandPolygonNames[i] = resPolyIDArr[lastNumPoly + i]
!!!		next i
!!!
!!!		numPoly = numPoly - 1
!!!
!!!		if numPoly > 0 then
!!!			if prevSourceContainer <> "" then
!!!				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
!!!			endif
!!!			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
!!!			prevSourceContainer	= lastDestContainer
!!!			lastDestContainer	= "myDestContainer" + str(containerIdx, 1, 0)
!!!			preparefunction ch, "CreateContainer",			lastDestContainer, ""
!!!			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""
!!!			containerIdx = containerIdx + 1
!!!		endif
!!!	endwhile

! Store wall contour polygon in wallhole coordinate system ---------------------

		if AC_WallType = 2 then

			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",		prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer4"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			nVertices2 = vardim1(AC_WallContourPolygon)
			dim vertArr2[][3]

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

			defaultInhEdgeInfo = 0
			dim inhEdgeInfos2[]
!!!ccc=0
			for i=1 to nVertices2
				vertarr2[i][1] = AC_WallContourPolygon[i][1]
				if WIDO_REVEAL_SIDE then
					vertarr2[i][2] = AC_WallContourPolygon[i][2] + WIDO_FRAME_THICKNESS
					vertarr2[i][3] = AC_WallContourPolygon[i][3]
				else
					vertarr2[i][2] = -AC_WallContourPolygon[i][2]
					vertarr2[i][3] = -AC_WallContourPolygon[i][3]
				endif

				inhEdgeInfos2[i] = 2
!!!ccc=ccc+0.003
!!!circle2 vertarr2[i][1], vertarr2[i][2], ccc
!!!text2 vertarr2[i][1], vertarr2[i][2], i
			next i

			nContours2 = 1
			dim contArr2[]
			contArr2[1] = nVertices2 + 1

			preparefunction ch, "Store", "wallContourPoly", nVertices2, nContours2, vertArr2, contArr2, defaultInhEdgeInfo, inhEdgeInfos2

! Intersect polygons -----------------------------------------------------------

			dim tempResPolyIDArr[]
			for i = 1 to numPoly
				tempNumPoly = callfunction (ch, "wallContourPoly / " + srcPolyIDArr[i], "", tempResPolyIDArr)
			next i
		endif

! Cut hidden wall skins polygon ------------------------------------------------

		if (offsetBoard > EPS) then

			if prevSourceContainer <> "" then
				preparefunction ch, "DeleteContainer",			prevSourceContainer, ""
			endif
			preparefunction ch, "SetSourceContainer",		lastDestContainer, ""
			prevSourceContainer	= lastDestContainer
			lastDestContainer	= "myDestContainer5"
			preparefunction ch, "CreateContainer",			lastDestContainer, ""
			preparefunction ch, "SetDestinationContainer",	lastDestContainer, ""

			dim srcPolyIDArr[]
			numPoly = callfunction (ch, "GetSourcePolygons", "", srcPolyIDArr)

! Store hidden wall skins polygon ----------------------------------------------

			if curvedWall then
				pxL1 = -radBoard + signWallIsLeft * 0.1
				pyL1 = WOD

				pxL2 = -radBoard - signWallIsLeft * offsetBoard
				pyL2 = WOD

				pxR1 = radBoard - signWallIsLeft * 0.1
				pyR1 = WOD

				pxR2 = radBoard + signWallIsLeft * offsetBoard
				pyR2 = WOD
			else
				if bInclinedWall then
					pxL1 = -leftWidth - 1.0
					pyL1 = WALL_THICKNESS - WIDO_SILL + pxL1 * incX + 0.1

					pxL2 = pxL1
					pyL2 = WALL_THICKNESS - WIDO_SILL - offsetBoard * incFactor * incY + pxL2 * incX

					pxR1 = rightWidth + 1.0
					pyR1 = WALL_THICKNESS - WIDO_SILL + pxR1 * incX + 0.1

					pxR2 = pxR1
					pyR2 = WALL_THICKNESS - WIDO_SILL - offsetBoard * incFactor * incY + pxR2 * incX
				else
					pxL1 = -leftWidth - 1.0
					pyL1 = WALL_THICKNESS - WIDO_SILL + 0.1

					pxL2 = pxL1
					pyL2 = WALL_THICKNESS - WIDO_SILL - offsetBoard

					pxR1 = rightWidth + 1.0
					pyR1 = WALL_THICKNESS - WIDO_SILL + 0.1

					pxR2 = pxR1
					pyR2 = WALL_THICKNESS - WIDO_SILL - offsetBoard
				endif
			endif

!!!text2 0,0.2, WALL_THICKNESS
!!!circle2 0,0, 0.01
!!!fill 1
!!!pen 1
!!!poly2_b 4, 1+2+4+64, 1,0,
!!!	pxL1, pyL1, 1,
!!!	pxL2, pyL2, 1,
!!!	pxR2, pyR2, 1,
!!!	pxR1, pyR1, 1
!!!fill wallholeFill

			nVertices2 = 4
			dim vertArr2[][3]

			defaultInhEdgeInfo = -1
			dim inhEdgeInfos2[]

			vertarr2[1][1] = pxL1
			vertarr2[1][2] = pyL1
			vertarr2[1][3] = 0
			inhEdgeInfos2[1] = 0

			vertarr2[2][1] = pxL2
			vertarr2[2][2] = pyL2
			vertarr2[2][3] = curvedWall * signWallIsLeft * 180
			inhEdgeInfos2[2] = 0

			vertarr2[3][1] = pxR2
			vertarr2[3][2] = pyR2
			vertarr2[3][3] = 0
			inhEdgeInfos2[3] = 0

			vertarr2[4][1] = pxR1
			vertarr2[4][2] = pyR1
			vertarr2[4][3] = curvedWall * signWallIsLeft * (-180)
			inhEdgeInfos2[4] = 0

			nContours2 = 1
			dim contArr2[]
			contArr2[1] = nVertices2 + 1

			preparefunction ch, "Store", "poly2", nVertices2, nContours2, vertArr2, contArr2, defaultInhEdgeInfo, inhEdgeInfos2

! Substract polygons -----------------------------------------------------------

			dim tempResPolyIDArr[]
			for i = 1 to numPoly
				tempNumPoly = callfunction(ch, srcPolyIDArr[i] + " - poly2", "", tempResPolyIDArr)
			next i
		endif

! Draw wall contour lines ------------------------------------------------------

		dim resPolyIDArr[]
		numPoly = callfunction (ch, "GetDestinationPolygons", "", resPolyIDArr)

		dim lineAttributes[2][4]
		lineAttributes[1][1] = 0
		lineAttributes[1][2] = 0
		lineAttributes[1][3] = 0
		lineAttributes[1][4] = 0

		lineAttributes[2][1] = gs_wcont_line_pen * (wcontLineIn > 0)
		lineAttributes[2][2] = gs_parapet_line
		lineAttributes[2][3] = LINE_PROPERTY_GENERIC
		lineAttributes[2][4] = bitset(0, LINE_ATTRIBUTES_GDLLINE)

		bPutHotsopts	= 0

		for i = 1 to numPoly
			polygonID = resPolyIDArr[i]
			gosub 1001	! Draw one polygon contour line
		next i

	endif

! Close channel ----------------------------------------------------------------

	if bUsePolygonOperations then
		closeaddonscope ch
	endif
return


! ==============================================================================
! Draw Wall Contour Outside
! ==============================================================================

"DrawContourLinesOutside":

	pen gs_wcont_line_pen
	line_property 0

	if curvedWall then
		R = sqr(leftRevealPnts[idxSillStartPlasterLeft][1]^2 + (leftRevealPnts[idxSillStartPlasterLeft][2] - WOD)^2) - offsetSill * signWallIsLeft

		if wallContourLineOffsetLeftOut > EPS then
			x1 = leftRevealPnts[idxSillStartPlasterLeft][1] + signWallIsLeft * wallContourLineOffsetLeftOut / cos(alpha-270)
			y1 = leftRevealPnts[idxSillStartPlasterLeft][2]
			x2 = x1 - signWallIsLeft * sin(alpha-270)
			y2 = y1 + signWallIsLeft * cos(alpha-270)
			xo = 0
			yo = WOD
			ro = R
			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			vx = cx
			vy = cy - WOD
		else
			if bNeedToOffsetSkins & bParalellInCurvedWalls then
				vx = leftRevealPnts[idxSillStartPlasterLeft][1]
				vy = -signWallIsLeft * sqr(R^2 - vx^2)
			else
				vx = leftRevealPnts[idxSillStartPlasterLeft][1]
				vy = leftRevealPnts[idxSillStartPlasterLeft][2] - WOD
			endif
		endif
		gosub 103	! Direction Angle
		alpha = angle


		if wallContourLineOffsetRightOut > EPS then
			x1 = rightRevealPnts[idxSillStartPlasterRight][1] - signWallIsLeft * wallContourLineOffsetRightOut / cos(beta-270)
			y1 = rightRevealPnts[idxSillStartPlasterRight][2]
			x2 = x1 - signWallIsLeft * sin(beta-270)
			y2 = y1 + signWallIsLeft * cos(beta-270)
			xo = 0
			yo = WOD
			ro = R
			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			vx = cx
			vy = cy - WOD
		else
			if bNeedToOffsetSkins & bParalellInCurvedWalls then
				vx = rightRevealPnts[idxSillStartPlasterRight][1]
				vy = -signWallIsLeft * sqr(R^2 - vx^2)
			else
				vx = rightRevealPnts[idxSillStartPlasterRight][1]
				vy = rightRevealPnts[idxSillStartPlasterRight][2] - WOD
			endif
		endif
		gosub 103	! Direction Angle
		beta = angle


		if bHasSidelightLeft then
			vx = -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_left_sL + thkPlasterAtSillSlLeft
			vy = -signWallIsLeft * sqr((radSill - offsetSill * signWallIsLeft)^2 - vx^2)
			gosub 103	! Direction Angle
			if bWallContourLineSl then
				line_type _wcont_line_left_sl_out
				if abs(angle - alpha) > EPS then
					arc2 0,WOD, R, min(angle,alpha), max(angle,alpha)
				endif
				if (vy + WOD) < -EPS then
					line2 vx, vy + WOD, vx, 0
					if abs(thkPlasterAtBoardSlLeft + gs_reveal_left_sL) > EPS then
						line2 vx, 0, -leftWidth + gs_sidelight_WHole_width_left, 0
					endif
				endif
			endif
			hotspot2 vx, vy + WOD, 11070
			alpha = angle
		endif
		if bHasSidelightRight then
			vx = rightWidth - gs_sidelight_WHole_width_right - gs_reveal_right_sR - thkPlasterAtSillSlRight
			vy = -signWallIsLeft * sqr((radSill - offsetSill * signWallIsLeft)^2 - vx^2)
			gosub 103	! Direction Angle
			if bWallContourLineSl then
				line_type _wcont_line_right_sl_out
				if abs(angle - beta) > EPS then
					arc2 0,WOD, R, min(angle,beta), max(angle,beta)
				endif
				if (vy + WOD) < -EPS then
					line2 vx, vy + WOD, vx, 0
					if abs(thkPlasterAtBoardSlRight + gs_reveal_right_sR) > EPS then
						line2 vx, 0, rightWidth - gs_sidelight_WHole_width_right, 0
					endif
				endif
			endif
			hotspot2 vx, vy + WOD, 11071
			beta = angle
		endif

! We have to draw this line!
!		if (gs_IsCurved & abs(R - radSill) < WIDO_SILL) | \
!			(not(gs_IsCurved) & WOD - R * signWallIsLeft < 0) | \
!			 not(isWindow) | WIDO_FRAME_THICKNESS < EPS then

			if bWallContourLine & abs(alpha - beta) > EPS then
				line_type gs_wcont_line_out
				arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
			endif
!		endif
	else
		if bNeedToOffsetSkins then
			pxL = leftRevealPnts[idxSillStartPlasterLeft][1] + bLeftCornerFunction * lx * offsetSill
			pyL = leftRevealPnts[idxSillStartPlasterLeft][2] + offsetSill

			pxR = rightRevealPnts[idxSillStartPlasterRight][1] - bRightCornerFunction * rx * offsetSill
			pyR = rightRevealPnts[idxSillStartPlasterRight][2] + offsetSill
		else
			pxL = leftRevealPnts[idxSillStartPlasterLeft][1]
			pyL = leftRevealPnts[idxSillStartPlasterLeft][2]

			pxR = rightRevealPnts[idxSillStartPlasterRight][1]
			pyR = rightRevealPnts[idxSillStartPlasterRight][2]
		endif

		if wallContourLineOffsetLeftOut > EPS then
			pxL = pxL + wallContourLineOffsetLeftOut
		endif
		if wallContourLineOffsetRightOut > EPS then
			pxR = pxR - wallContourLineOffsetRightOut
		endif

		if bHasSidelightLeft then
			px = -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_left_sL + thkPlasterAtSillSlLeft
			if bWallContourLineSl then
				line_type _wcont_line_left_sl_out
				line2 pxL,pyL, px, pyL
				if pyL < -EPS then
					line2 px, pyL, px, 0
				endif
				if abs(thkPlasterAtBoardSlLeft + gs_reveal_left_sL) > EPS then
					line2 px, 0, -leftWidth + gs_sidelight_WHole_width_left, 0
				endif
			endif
			hotspot2 px, pyL, 11070
			pxL = px
		endif
		if bHasSidelightRight then
			px = rightWidth - gs_sidelight_WHole_width_right - gs_reveal_right_sR - thkPlasterAtSillSlRight
			if bWallContourLineSl then
				line_type _wcont_line_right_sl_out
				line2 pxR,pyR, px, pyR
				if pyR < -EPS then
					line2 px, pyR, px, 0
				endif
				if abs(thkPlasterAtBoardSlRight + gs_reveal_right_sR) > EPS then
					line2 px, 0, rightWidth - gs_sidelight_WHole_width_right, 0
				endif
			endif
			hotspot2 px, pyR, 11071
			pxR = px
		endif

! We have to draw this line!
!		! We must draw this line in case of doors [not(isWindow)]
!		! and in case of window openings [where WIDO_FRAME_THICKNESS < EPS]
!		if (pyL < 0 & pyR < 0) | not(isWindow) | WIDO_FRAME_THICKNESS < EPS then
		if bWallContourLine then
			line_type gs_wcont_line_out
			line2 pxL,pyL, pxR,pyR
		endif
	endif
return


! ==============================================================================
! Draw Wall Contour Inside
! ==============================================================================

"DrawContourLinesInside":

	pen gs_wcont_line_pen
	line_property 0

	if curvedWall then
		R = sqr(leftRevealPnts[idxBoardEndPlasterLeft][1]^2 + (leftRevealPnts[idxBoardEndPlasterLeft][2] - WOD)^2) + offsetBoard * signWallIsLeft

		if wallContourLineOffsetLeftIn > EPS then
			x1 = leftRevealPnts[idxBoardEndPlasterLeft][1] + signWallIsLeft * wallContourLineOffsetLeftIn / cos(alpha-270)
			y1 = leftRevealPnts[idxBoardEndPlasterLeft][2]
			x2 = x1 - signWallIsLeft * sin(alpha-270)
			y2 = y1 + signWallIsLeft * cos(alpha-270)
			xo = 0
			yo = WOD
			ro = R
			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			vx = cx
			vy = cy - WOD
		else
			if bNeedToOffsetSkins & bParalellInCurvedWalls then
				vx = leftRevealPnts[idxBoardEndPlasterLeft][1]
				vy = -signWallIsLeft * sqr(R^2 - vx^2)
			else
				vx = leftRevealPnts[idxBoardEndPlasterLeft][1]
				vy = leftRevealPnts[idxBoardEndPlasterLeft][2] - WOD
			endif
		endif
		gosub 103	! Direction Angle
		alpha = angle

		if wallContourLineOffsetRightIn > EPS then
			x1 = rightRevealPnts[idxBoardEndPlasterRight][1] - signWallIsLeft * wallContourLineOffsetRightIn / cos(beta-270)
			y1 = rightRevealPnts[idxBoardEndPlasterRight][2]
			x2 = x1 - signWallIsLeft * sin(beta-270)
			y2 = y1 + signWallIsLeft * cos(beta-270)
			xo = 0
			yo = WOD
			ro = R
			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			vx = cx
			vy = cy - WOD
		else
			if bNeedToOffsetSkins & bParalellInCurvedWalls then
				vx = rightRevealPnts[idxBoardEndPlasterRight][1]
				vy = -signWallIsLeft * sqr(R^2 - vx^2)
			else
				vx = rightRevealPnts[idxBoardEndPlasterRight][1]
				vy = rightRevealPnts[idxBoardEndPlasterRight][2] - WOD
			endif
		endif
		gosub 103	! Direction Angle
		beta = angle

		if bHasSidelightLeft then
			vx = -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_double_innerLeft_sL + thkPlasterAtBoardSlLeft
			vy = -signWallIsLeft * sqr((radBoard + offsetBoard * signWallIsLeft)^2 - vx^2)
			gosub 103	! Direction Angle
			if bWallContourLineSl then
				line_type _wcont_line_left_sl_in
				if abs(angle - alpha) > EPS then
					arc2 0,WOD, R, min(angle,alpha), max(angle,alpha)
				endif
				if (vy + WOD) > WIDO_FRAME_THICKNESS then
					if abs(gs_reveal_double_innerLeft_sL + thkPlasterAtBoardSlLeft) > EPS then
						line2 vx, vy + WOD, vx, WIDO_FRAME_THICKNESS
						line2 vx - gs_reveal_double_innerLeft_sL - thkPlasterAtBoardSlLeft, WIDO_FRAME_THICKNESS, vx, WIDO_FRAME_THICKNESS
						line2 vx - gs_reveal_double_innerLeft_sL - thkPlasterAtBoardSlLeft, WIDO_FRAME_THICKNESS, vx - gs_reveal_double_innerLeft_sL - thkPlasterAtBoardSlLeft, 0
					else
						vy2 = max(0 - WOD, -signWallIsLeft * sqr((radSill - offsetSill * signWallIsLeft)^2 - vx^2))
						line2 vx, vy + WOD, vx, vy2 + WOD
					endif
				endif
			endif
			hotspot2 vx, vy + WOD, 11072
			alpha = angle
		endif
		if bHasSidelightRight then
			vx = rightWidth - gs_sidelight_WHole_width_right - gs_reveal_double_innerRight_sR - thkPlasterAtBoardSlRight
			vy = -signWallIsLeft * sqr((radBoard + offsetBoard * signWallIsLeft)^2 - vx^2)
			gosub 103	! Direction Angle
			if bWallContourLineSl then
				line_type _wcont_line_right_sl_in
				if abs(angle - beta) > EPS then
					arc2 0,WOD, R, min(angle,beta), max(angle,beta)
				endif
				if (vy + WOD) > WIDO_FRAME_THICKNESS then
					if abs(gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight) > EPS then
						line2 vx, vy + WOD, vx, WIDO_FRAME_THICKNESS
						line2 vx + gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight, WIDO_FRAME_THICKNESS, vx, WIDO_FRAME_THICKNESS
						line2 vx + gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight, WIDO_FRAME_THICKNESS, vx + gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight, 0
					else
						vy2 = max(0 - WOD, -signWallIsLeft * sqr((radSill - offsetSill * signWallIsLeft)^2 - vx^2))
						line2 vx, vy + WOD, vx, vy2 + WOD
					endif
				endif
			endif
			hotspot2 vx, vy + WOD, 11073
			beta = angle
		endif

!		if (gs_IsCurved & abs(R - radSill) < WIDO_SILL) | (not(gs_IsCurved) & WOD - R * signWallIsLeft < 0) then
			if bWallContourLine & abs(alpha - beta) > EPS then
				line_type gs_wcont_line_in
				arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
			endif
!		endif
	else
		if bNeedToOffsetSkins then
			pxL = leftRevealPnts[idxBoardEndPlasterLeft][1] - bLeftCornerFunction * lx * offsetBoard
			if bInclinedWall then
				pyL = leftRevealPnts[idxBoardEndPlasterLeft][2] - offsetBoard / incH
			else
				pyL = leftRevealPnts[idxBoardEndPlasterLeft][2] - offsetBoard
			endif

			pxR = rightRevealPnts[idxBoardEndPlasterRight][1] + bRightCornerFunction * rx * offsetBoard
			if bInclinedWall then
				pyR = rightRevealPnts[idxBoardEndPlasterRight][2] - offsetBoard / incH
			else
				pyR = rightRevealPnts[idxBoardEndPlasterRight][2] - offsetBoard
			endif
		else
			pxL = leftRevealPnts[idxBoardEndPlasterLeft][1]
			pyL = leftRevealPnts[idxBoardEndPlasterLeft][2]

			pxR = rightRevealPnts[idxBoardEndPlasterRight][1]
			pyR = rightRevealPnts[idxBoardEndPlasterRight][2]
		endif

		if wallContourLineOffsetLeftIn > EPS then
			pxL = pxL + wallContourLineOffsetLeftIn
			if bInclinedWall then
				pyL = pyL  + iDir * wallContourLineOffsetLeftIn * tan(WALL_INCL)
			endif
		endif
		if wallContourLineOffsetRightIn > EPS then
			pxR = pxR - wallContourLineOffsetRightIn
			if bInclinedWall then
				pyR = pyR  - iDir * wallContourLineOffsetRightIn * tan(WALL_INCL)
			endif
		endif

		if pyL > 0 & pyR > 0 then

			if bHasSidelightLeft then
				px = -leftWidth + gs_sidelight_WHole_width_left + gs_reveal_double_innerLeft_sL + thkPlasterAtBoardSlLeft
				py = pyL + (pxL - px) * (pyL - pyR) / (-pxL + pxR)
				if bWallContourLineSl then
					line_type _wcont_line_left_sl_in
					line2 pxL,pyL, px, py
					if abs(gs_reveal_double_innerLeft_sL + thkPlasterAtBoardSlLeft) > EPS then
						line2 px, py, px, WIDO_FRAME_THICKNESS
						line2 px - gs_reveal_double_innerLeft_sL - thkPlasterAtBoardSlLeft, WIDO_FRAME_THICKNESS, px, WIDO_FRAME_THICKNESS
						line2 px - gs_reveal_double_innerLeft_sL - thkPlasterAtBoardSlLeft, WIDO_FRAME_THICKNESS, px - gs_reveal_double_innerLeft_sL - thkPlasterAtBoardSlLeft, 0
					else
						line2 px, py, px, 0
					endif
				endif
				hotspot2 px, py, 11072
				pxL = px
				pyL = py
			endif
			if bHasSidelightRight then
				px = rightWidth - gs_sidelight_WHole_width_right - gs_reveal_double_innerRight_sR - thkPlasterAtBoardSlRight
				py = pyR + (pxR - px) * (pyL - pyR) / (-pxL + pxR)
				if bWallContourLineSl then
					line_type _wcont_line_right_sl_in
					line2 pxR,pyR, px, py
					if abs(gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight) > EPS then
						line2 px, py, px, WIDO_FRAME_THICKNESS
						line2 px + gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight, WIDO_FRAME_THICKNESS, px, WIDO_FRAME_THICKNESS
						line2 px + gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight, WIDO_FRAME_THICKNESS, px + gs_reveal_double_innerRight_sR + thkPlasterAtBoardSlRight, 0
					else
						line2 px, py, px, 0
					endif
				endif
				hotspot2 px, py, 11073
				pxR = px
				pyR = py
			endif

			if bWallContourLine then
				line_type gs_wcont_line_in
				line2 pxL,pyL, pxR,pyR
			endif
		endif
	endif
return


! ==============================================================================
! Head / Threshold Plan Symbol
! ==============================================================================

"DrawHeadThresholdPlanSymbol":

	line_type gs_head_symbol_line
	pen gs_head_symbol_pen

	if curvedWall & gs_IsCurved then
		if iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE | iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE then
			R = sqr(leftRevealPnts[idxSillEndPlasterLeft][1]^2 + (leftRevealPnts[idxSillEndPlasterLeft][2] - WOD)^2) - thkFinishSkinCorrection * ySign

			vx = leftRevealPnts[idxSillEndPlasterLeft][1]
			vy = leftRevealPnts[idxSillEndPlasterLeft][2] - WOD
			gosub 103	! Direction Angle
			alpha = angle

			vx = rightRevealPnts[idxSillEndPlasterRight][1]
			vy = rightRevealPnts[idxSillEndPlasterRight][2] - WOD
			gosub 103	! Direction Angle
			beta = angle

			if abs(alpha - beta) > EPS then
				arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
			endif
		endif
		if iRevealType = REVEAL_SPLAYED | ((iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE) & WIDO_FRAME_THICKNESS > EPS) then
			R = sqr(leftRevealPnts[idxBoardStartRevealLeft][1]^2 + (leftRevealPnts[idxBoardStartRevealLeft][2] - WOD)^2) - thkFinishSkinCorrection * ySign

			vx = leftRevealPnts[idxBoardStartRevealLeft][1]
			vy = leftRevealPnts[idxBoardStartRevealLeft][2] - WOD
			gosub 103	! Direction Angle
			alpha = angle

			vx = rightRevealPnts[idxBoardStartRevealRight][1]
			vy = rightRevealPnts[idxBoardStartRevealRight][2] - WOD
			gosub 103	! Direction Angle
			beta = angle

			if abs(alpha - beta) > EPS then
				arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
			endif
		endif
	else
		if iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE | iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE then
			line2 leftRevealPnts[idxSillEndRevealLeft][1],  leftRevealPnts[idxSillEndRevealLeft][2],
				 rightRevealPnts[idxSillEndRevealRight][1], rightRevealPnts[idxSillEndRevealRight][2]
		endif
		if iRevealType = REVEAL_SPLAYED | ((iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE) & WIDO_FRAME_THICKNESS > EPS) then
			line2 leftRevealPnts[idxBoardStartRevealLeft][1],  leftRevealPnts[idxBoardStartRevealLeft][2],
				 rightRevealPnts[idxBoardStartRevealRight][1], rightRevealPnts[idxBoardStartRevealRight][2]
		endif
	endif
return


! ==============================================================================
! Drawing the wall contour lines
! ==============================================================================

"DrawWallContourLines":

	dim tempLineSections[]

	call "WallContourDivider" parameters AC_Wall_Direction_Type = AC_Wall_Direction_Type,
		radSill			= radSill,
		radBoard		= radBoard,
		WOD				= WOD,
		offsetSill		= offsetSill,
		offsetBoard		= offsetBoard,
		lineSections	= lineSections,
	returned_parameters tempLineSections

	numLineSections = round_int(vardim1(tempLineSections) / 7)
	dim lineSections[][7]
	idx = 0
	for i=1 to numLineSections
		for j=1 to 7
			lineSections[i][j] = tempLineSections[idx + j]
		next j
		idx = idx + 7
	next i

	nSectNum = vardim1(lineSections)

	for i = 1 to nSectNum

		iBitField = round_int(lineSections[i][LINE_ATTRIBUTES])

		if not(bittest(iBitField, LINE_ATTRIBUTES_DRAWCC)) then

			if not(gs_transom_display) then
				penIdx		= round_int(lineSections[i][LINE_PEN_IDX])
				lineTypeIdx	= round_int(lineSections[i][LINE_LTYPE_IDX])
			else
				penIdx		= gs_transom_display_pen
				lineTypeIdx	= gs_transom_display_linetype
			endif

			if penIdx > 0 then
				pen				penIdx
				line_type		lineTypeIdx
				line_property	LINE_PROPERTY_CONTOUR

				if bittest(iBitField, LINE_ATTRIBUTES_WALLSIDE) & curvedWall then

! Curved line-------------------------------------------------------------------

					R = sqr(lineSections[i][LINE_END_X]^2 + (lineSections[i][LINE_END_Y] - WOD)^2)

					vx = lineSections[i][LINE_BEG_X]
					vy = lineSections[i][LINE_BEG_Y] - WOD
					gosub 103	! Direction Angle
					alpha = angle

					vx = lineSections[i][LINE_END_X]
					vy = lineSections[i][LINE_END_Y] - WOD
					gosub 103	! Direction Angle
					beta = angle

					if abs(alpha - beta) > EPS then
						if bittest(iBitField, LINE_ATTRIBUTES_GDLLINE) then
							if not(gs_transom_display) then
								arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
							endif
						endif
						if bittest(iBitField, LINE_ATTRIBUTES_WALLLINE) then
							if (GLOB_PREVIEW_MODE = 0) then
								arc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
							endif
							wallarc2 0,WOD, R, min(alpha,beta), max(alpha,beta)
						endif
					endif

				else

! Straight line-----------------------------------------------------------------

					if bittest(iBitField, LINE_ATTRIBUTES_GDLLINE) then
						if not(gs_transom_display) then
							line2	lineSections[i][LINE_BEG_X], lineSections[i][LINE_BEG_Y],
									lineSections[i][LINE_END_X], lineSections[i][LINE_END_Y]
						endif
					endif

					if bittest(iBitField, LINE_ATTRIBUTES_WALLLINE) & AC_WallType <> 2 then
						if (GLOB_PREVIEW_MODE = 0) then
							line2	lineSections[i][LINE_BEG_X], lineSections[i][LINE_BEG_Y],
									lineSections[i][LINE_END_X], lineSections[i][LINE_END_Y]
						endif
						wallline2	lineSections[i][LINE_BEG_X], lineSections[i][LINE_BEG_Y],
									lineSections[i][LINE_END_X], lineSections[i][LINE_END_Y]
					endif
				endif
			endif
		endif
	next i
return


! ===============================================================================
!	New Wallhole Symbol (SWE symbol)
! ===============================================================================

"DrawSWENewWallholeSymbol":

	openingWidth	= leftWidth + rightWidth

	fill gs_new_symb_fill

	if abs(WIDO_ORIG_DIST) < EPS then					!!! Straight wall

		mul2 1,-1

		if ABS(WALL_INCL) < EPS then

			WALLBLOCK2 4, 6+16+32, gs_new_symb_pen_Fg, gs_new_symb_pen_Bg,
						0, 0, 0,
						-openingWidth/2, WIDO_SILL, 32,
						-openingWidth/2 - gs_new_symb_width_r, WIDO_SILL, 32,
						-openingWidth/2 - gs_new_symb_width_r, WIDO_SILL-WALL_THICKNESS, 32,
						-openingWidth/2, WIDO_SILL-WALL_THICKNESS, 32
			WALLBLOCK2 4, 6+16+32, gs_new_symb_pen_Fg, gs_new_symb_pen_Bg,
						0, 0, 0,
						openingWidth/2, WIDO_SILL, 32,
						openingWidth/2 + gs_new_symb_width_l, WIDO_SILL, 32,
						openingWidth/2 + gs_new_symb_width_l, WIDO_SILL-WALL_THICKNESS, 32,
						openingWidth/2, WIDO_SILL-WALL_THICKNESS, 32

			if WALL_SKINS_NUMBER = 0 then
				pen WALL_SECT_PEN
				LINE_TYPE 1
			else
				if abs(SYMB_ROTANGLE-180) < EPS then
					pen WALL_SKINS_PARAMS[1][7]
					LINE_TYPE WALL_SKINS_PARAMS[1][8]
				else
					pen WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][9]
					LINE_TYPE WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][10]
				endif
			endif

			LINE_PROPERTY 2

			WALLLINE2 openingWidth/2, WIDO_SILL, openingWidth/2 + gs_new_symb_width_l, WIDO_SILL
			WALLLINE2 -openingWidth/2, WIDO_SILL, -openingWidth/2 - gs_new_symb_width_r, WIDO_SILL


			if WALL_SKINS_NUMBER <> 0 then
				if abs(SYMB_ROTANGLE-180) < EPS then
					pen WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][9]
					LINE_TYPE WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][10]
				else
					pen WALL_SKINS_PARAMS[1][7]
					LINE_TYPE WALL_SKINS_PARAMS[1][8]
				endif
			endif

			WALLLINE2 openingWidth/2, WIDO_SILL-WALL_THICKNESS, openingWidth/2 + gs_new_symb_width_l, WIDO_SILL-WALL_THICKNESS
			WALLLINE2 -openingWidth/2, WIDO_SILL-WALL_THICKNESS, -openingWidth/2 - gs_new_symb_width_r, WIDO_SILL-WALL_THICKNESS

		else								!!!inclined wall


			if SYMB_MIRRORED exor abs(SYMB_ROTANGLE) < EPS then
				incl_sign = -1
			else
				incl_sign = 1
			endif

			if WIDO_REVEAL_SIDE then
				mul2 1,-1
				add2 0, WALL_THICKNESS - 2*WIDO_SILL
			endif

			WALLBLOCK2 4, 6+16+32, gs_new_symb_pen_Fg, gs_new_symb_pen_Bg,
						0, 0, 0,
						-openingWidth/2, WIDO_SILL + WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * openingWidth/2, 32,
						-openingWidth/2 - gs_new_symb_width_r, WIDO_SILL + WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_r), 32,
						-openingWidth/2 - gs_new_symb_width_r, WIDO_SILL-WALL_THICKNESS - not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_r), 32,
						-openingWidth/2, WIDO_SILL-WALL_THICKNESS - not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * openingWidth/2, 32

			WALLBLOCK2 4, 6+16+32, gs_new_symb_pen_Fg, gs_new_symb_pen_Bg,
						0, 0, 0,
						openingWidth/2, WIDO_SILL - WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * openingWidth/2, 32,
						openingWidth/2 + gs_new_symb_width_l, WIDO_SILL - WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_l), 32,
						openingWidth/2 + gs_new_symb_width_l, WIDO_SILL-WALL_THICKNESS + not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_l), 32,
						openingWidth/2, WIDO_SILL-WALL_THICKNESS + not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * openingWidth/2, 32

			if WALL_SKINS_NUMBER = 0 then
				pen WALL_SECT_PEN
				LINE_TYPE 1
			else
				if abs(SYMB_ROTANGLE-180) < EPS then
					pen WALL_SKINS_PARAMS[1][7]
					LINE_TYPE WALL_SKINS_PARAMS[1][8]
				else
					pen WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][9]
					LINE_TYPE WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][10]
				endif
			endif

			LINE_PROPERTY 2


			WALLLINE2	-openingWidth/2, WIDO_SILL + WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * openingWidth/2,
						-openingWidth/2 - gs_new_symb_width_r, WIDO_SILL + WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_r)
			WALLLINE2	openingWidth/2, WIDO_SILL - WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * openingWidth/2,
						openingWidth/2 + gs_new_symb_width_l, WIDO_SILL - WIDO_REVEAL_SIDE * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_l)

			if WALL_SKINS_NUMBER <> 0 then
				if abs(SYMB_ROTANGLE-180) < EPS then
					pen WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][9]
					LINE_TYPE WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][10]
				else
					pen WALL_SKINS_PARAMS[1][7]
					LINE_TYPE WALL_SKINS_PARAMS[1][8]
				endif
			endif

			WALLLINE2	-openingWidth/2 - gs_new_symb_width_r, WIDO_SILL-WALL_THICKNESS - not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_r),
						-openingWidth/2, WIDO_SILL-WALL_THICKNESS - not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * openingWidth/2
			WALLLINE2	openingWidth/2 + gs_new_symb_width_l, WIDO_SILL-WALL_THICKNESS + not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * (openingWidth/2 + gs_new_symb_width_l),
						openingWidth/2, WIDO_SILL-WALL_THICKNESS + not(WIDO_REVEAL_SIDE) * incl_sign * tan(WALL_INCL) * openingWidth/2

			if WIDO_REVEAL_SIDE then del 2

		endif


	else									!!!Curved wall

		if WIDO_REVEAL_SIDE exor abs(SYMB_ROTANGLE) < EPS then
			shf_sign = -1
		else
			shf_sign = 1
		endif


		if abs(SYMB_ROTANGLE-180) < EPS then
			shf_sign2 = 1
			frame_shf2 = WIDO_FRAME_THICKNESS
		else
			shf_sign2 = -1
			frame_shf2 = 0
		endif

		if WIDO_REVEAL_SIDE then
			frame_shf = WIDO_SILL + WIDO_FRAME_THICKNESS !/ COS(leftAlfa) - WIDO_FRAME_THICKNESS
		else
			frame_shf = WIDO_SILL
		endif


		leftAlfa	= ATN((openingWidth/2) / (WIDO_ORIG_DIST + frame_shf2))
		rightAlfa	= ATN((openingWidth/2) / (WIDO_ORIG_DIST + frame_shf2))

		leftnewsymbAlfa	= ATN((openingWidth/2 + gs_new_symb_width_r) / (WIDO_ORIG_DIST + frame_shf2))
		rightnewsymbAlfa= ATN((openingWidth/2 + gs_new_symb_width_l) / (WIDO_ORIG_DIST + frame_shf2))



		radOppSide = SQR( ((openingWidth/2)^2) + (WIDO_ORIG_DIST^2) ) + shf_sign * frame_shf

		if not (WIDO_REVEAL_SIDE) then
			mul2 1,-1
		else
			add2 0,WIDO_FRAME_THICKNESS
		endif

		ADD2 0, WIDO_ORIG_DIST

		WALLBLOCK2 5, 6+16+32, gs_new_symb_pen_Fg, gs_new_symb_pen_Bg,
					0, 0, 0,
					0,0, 901,
					SIN(leftAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), shf_sign2 * COS(leftAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), 1,
					SIN(leftnewsymbAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), shf_sign2 * COS(leftnewsymbAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), 3001,
					SIN(leftnewsymbAlfa) * radOppSide, shf_sign2 * COS(leftnewsymbAlfa) * radOppSide, 1,
					SIN(leftAlfa) * radOppSide, shf_sign2 * COS(leftAlfa) * radOppSide, 3001

		WALLBLOCK2 5, 6+16+32, gs_new_symb_pen_Fg, gs_new_symb_pen_Bg,
					0, 0, 0,
					0,0, 901,
					-1 * SIN(rightAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), shf_sign2 * COS(rightAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), 1,
					-1 * SIN(rightnewsymbAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), shf_sign2 * COS(rightnewsymbAlfa) * (radOppSide - shf_sign * WALL_THICKNESS), 3001,
					-1 * SIN(rightnewsymbAlfa) * radOppSide, shf_sign2 * COS(rightnewsymbAlfa) * radOppSide, 1,
					-1 * SIN(rightAlfa) * radOppSide, shf_sign2 * COS(rightAlfa) * radOppSide, 3001


			if WALL_SKINS_NUMBER = 0 then
				pen WALL_SECT_PEN
				LINE_TYPE 1
			else
				if WIDO_REVEAL_SIDE exor abs(SYMB_ROTANGLE) < EPS then
					pen WALL_SKINS_PARAMS[1][7]
					LINE_TYPE WALL_SKINS_PARAMS[1][8]
				else
					pen WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][9]
					LINE_TYPE WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][10]
				endif
			endif

			LINE_PROPERTY 2

			if abs(SYMB_ROTANGLE-180) < EPS then
				WALLARC2 0, 0, radOppSide - shf_sign * WALL_THICKNESS, shf_sign2 * 90+leftnewsymbAlfa, shf_sign2 * 90+leftAlfa
				WALLARC2 0, 0, radOppSide - shf_sign * WALL_THICKNESS, shf_sign2 * 90-rightAlfa, shf_sign2 * 90-rightnewsymbAlfa
			else
				WALLARC2 0, 0, radOppSide - shf_sign * WALL_THICKNESS, shf_sign2 * 90+leftAlfa, shf_sign2 * 90+leftnewsymbAlfa
				WALLARC2 0, 0, radOppSide - shf_sign * WALL_THICKNESS, shf_sign2 * 90-rightnewsymbAlfa, shf_sign2 * 90-rightAlfa
			endif



			if WALL_SKINS_NUMBER <> 0 then
				if WIDO_REVEAL_SIDE exor abs(SYMB_ROTANGLE) < EPS then
					pen WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][9]
					LINE_TYPE WALL_SKINS_PARAMS[WALL_SKINS_NUMBER][10]
				else
					pen WALL_SKINS_PARAMS[1][7]
					LINE_TYPE WALL_SKINS_PARAMS[1][8]
				endif
			endif


			if abs(SYMB_ROTANGLE-180) < EPS then
				WALLARC2 0, 0, radOppSide, shf_sign2 * 90+leftnewsymbAlfa, shf_sign2 * 90+leftAlfa
				WALLARC2 0, 0, radOppSide, shf_sign2 * 90-rightAlfa, shf_sign2 * 90-rightnewsymbAlfa
			else
				WALLARC2 0, 0, radOppSide, shf_sign2 * 90+leftAlfa, shf_sign2 * 90+leftnewsymbAlfa
				WALLARC2 0, 0, radOppSide, shf_sign2 * 90-rightnewsymbAlfa, shf_sign2 * 90-rightAlfa
			endif

			del 1

			del 1

	endif
return


! ==============================================================================
! Mounting Frame
! ==============================================================================

"DrawMountingFrame":

	pen gs_mountingFrame_pen_cont
	fill gs_mountingFrame_fill
	line_property LINE_PROPERTY_GENERIC
	line_type 1

	if not(gs_stack_left | bLeftCornerFunction) then
		if abs(gs_mountingFrame_depth) > EPS then
			poly2_b 4, 1+2+4+64, gs_mountingFrame_pen_fg, gs_mountingFrame_pen_bg,
				-leftWidth,									-gs_mountingFrame_depth,	1+32,
				-leftWidth + gs_mountingFrame_width_left,	-gs_mountingFrame_depth,	1+32,
				-leftWidth + gs_mountingFrame_width_left,	0,							1+32,
				-leftWidth,									0,							1+32

			if lod2D_MountingFrame = 2 then
				line2 -leftWidth,0,-leftWidth + gs_mountingFrame_width_left,-gs_mountingFrame_depth
				line2 -leftWidth,-gs_mountingFrame_depth,-leftWidth + gs_mountingFrame_width_left,0
			endif
		endif
		pxL = -leftWidth + gs_mountingFrame_width_left

		hotspot2 pxL, 0, 11050
	else
		pxL = -leftWidth - bLeftCornerFunction * lx * (WIDO_FRAME_THICKNESS + gs_mountingFrame_depth)
	endif

	if not(gs_stack_right | bRightCornerFunction) then
		if abs(gs_mountingFrame_depth) > EPS then
			poly2_b 4, 1+2+4+64, gs_mountingFrame_pen_fg, gs_mountingFrame_pen_bg,
				rightWidth,									-gs_mountingFrame_depth,	1+32,
				rightWidth - gs_mountingFrame_width_right,	-gs_mountingFrame_depth,	1+32,
				rightWidth - gs_mountingFrame_width_right,	0,							1+32,
				rightWidth,									0,							1+32

			if lod2D_MountingFrame = 2 then
				line2 rightWidth,0,rightWidth - gs_mountingFrame_width_right,-gs_mountingFrame_depth
				line2 rightWidth,-gs_mountingFrame_depth,rightWidth - gs_mountingFrame_width_right,0
			endif
		endif
		pxR = rightWidth - gs_mountingFrame_width_right

		hotspot2 pxR, 0, 11051
	else
		pxR = rightWidth + bRightCornerFunction * rx * (WIDO_FRAME_THICKNESS + gs_mountingFrame_depth)
	endif

	pen gs_mountingFrame_pen_view
	line_property LINE_PROPERTY_GENERIC
	line2 pxL,-gs_mountingFrame_depth, pxR,-gs_mountingFrame_depth
	if bMountingFrame_DrawInsideLine then
		line2 pxL,0, pxR,0
	endif
return


! ==============================================================================
! Line - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12	line #1
!	x21,y21, x22,y22	line #2
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = valid intersection point
!	cx, cy:				intersection point
! ==============================================================================

100:
	lliDiv = (x11-x12) * (y21-y22) - (y11-y12) * (x21-x22)

	if abs(lliDiv) > EPS then
		! Intersection

		temp1 = x11 * y12 - y11 * x12
		temp2 = x21 * y22 - y21 * x22

		tempx = temp1 * (x21-x22) - (x11-x12) * temp2
		tempy = temp1 * (y21-y22) - (y11-y12) * temp2

		state = 1
		cx = (tempx / lliDiv)
		cy = (tempy / lliDiv)
	else
		! No Intersection
		state = 0
		cx = 0
		cy = 0
	endif
return


! ==============================================================================
! Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	xo,yo,ro:			circle
!	x1,y1, x2,y2		line
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = one intersection point (tangential line)
!						2 = two intersection points
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
! ==============================================================================

101:
	tempX1 = x1 - xo: tempY1 = y1 - yo
	tempX2 = x2 - xo: tempY2 = y2 - yo

	if abs(tempX2 - tempX1) < EPS then
		if abs(ro - abs(tempX1)) < EPS then
			state = 1
			xa = tempX1
			ya = 0
			xb = tempX1
			yb = 0
		else
			if abs(ro) - abs(tempX1) < 0 then
				state = 0: xa = 0: ya = 0: xb = 0: yb = 0
			else
				state = 2
				xa = tempX1
				ya = sqr(ro^2 - tempX1^2)
				xb = tempX1
				yb = -sqr(ro^2 - tempX1^2)
			endif
		endif
	else
		kf = (tempY2 - tempY1) / (tempX2 - tempX1)
		ad = 1 + kf^2
		bd = 2 * tempY1 * kf - 2 * tempX1 * kf^2
		cd = tempY1^2 - 2 * tempX1 * tempY1 * kf + tempX1^2 * kf^2 - ro^2

		if bd^2 - 4 * ad * cd < 0 then
			state = 0: xa = 0: ya = 0: xb = 0: yb = 0
		else
			xa = (-bd + sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			ya = tempY1 + (xa - tempX1) * kf
			xb = (-bd - sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			yb = tempY1 + (xb - tempX1) * kf

			if abs(xa - xb) < EPS then state = 1 else state = 2
		endif
	endif

	if state = 2 then
		da = sqr((tempX1 - xa)^2 + (tempY1 - ya)^2)
		db = sqr((tempX1 - xb)^2 + (tempY1 - yb)^2)

		if db < da then
			xxo = xa: yyo = ya
			xa = xb:  ya = yb
			xb = xxo: yb = yyo
		endif
	endif

	xa = xa + xo: ya = ya + yo
	xb = xb + xo: yb = yb + yo
return


! ==============================================================================
! Select good intersection point after Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	state:				intersection status
!	wallIsLeft:
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
!
! Returned variables:
!	cx, cy:				selected intersection point
! ==============================================================================

102:
	cx = 0
	cy = 0
	if state = 1 then
		cx = xa
		cy = ya
	endif
	if state = 2 then
		if wallIsLeft then
			if ya < yb then
				cx = xa
				cy = ya
			else
				cx = xb
				cy = yb
			endif
		else
			if ya > yb then
				cx = xa
				cy = ya
			else
				cx = xb
				cy = yb
			endif
		endif
	endif
return


! ==============================================================================
! Direction Angle
! ------------------------------------------------------------------------------
! Input variables:
!	vx, vy:				vector
!
! Returned variables:
!	alpha:				selected intersection point
! ==============================================================================

103:

if abs(vx) < EPS & abs(vy) < EPS then
	angle = 0
	return
endif

if abs(vx) < EPS then
	if vy > 0 then
		angle = 90
	else
		angle = 270
	endif
else
	angle = atn(vy / vx)
	if vx >= 0 then
		if angle < 0 then
			angle = angle + 360
		endif
	else
		angle = 180 + angle
	endif
endif

return




1000:
! ==============================================================================
! Get GDL Polygon
! ------------------------------------------------------------------------------
! Input variables:
!	polygonID:			Polygon index
!
! Returned variables:
!	GDL stack:			GDL polygon
! ==============================================================================

	_bValidPoly = 1

	dim resVertices[]
	numVertices = callfunction(ch, "GETVERTICES", polygonID, resVertices)
	numVertices = numVertices / 3

	dim contArr[]
	numContours = callfunction(ch, "GETCONTOURENDS", polygonID, contArr)

!!	dim inhEdgeInfos[]
!!	numEdges = callfunction(ch, "GetInhEdgeInfos", polygonID, inhEdgeInfos)

	for contIndex = 1 to numContours

		if contIndex = 1 then
			begIdx = 0
		else
			begIdx = contArr[contIndex] - 1
		endif
		if contIndex = numContours then
			endIdx = numVertices - 1
		else
			endIdx = contArr[contIndex + 1] - 2
		endif

		bClosed = 0
		bStartWithLast = 0

		index = endIdx * 3
		ac2gdl_lpx = resVertices[index + 1]
		ac2gdl_lpy = resVertices[index + 2]
		ac2gdl_lpa = resVertices[index + 3]
!!		edgeInfo	= inhEdgeInfos[endIdx + 1]

		if abs(ac2gdl_lpa) > EPS then
			if abs(ac2gdl_lpa - 360) > EPS then			!!! Valid Curved contour line (arc angle <> 360)
				put ac2gdl_lpx, ac2gdl_lpy, 1
				bStartWithLast = 1
			else										!!! Invalid Curved contour line (arc angle = 360)
				_bValidPoly = 0
			endif
		endif

		for vertIndex = begIdx to endIdx
			index = vertIndex * 3
			ac2gdl_px = resVertices[index + 1]
			ac2gdl_py = resVertices[index + 2]
			ac2gdl_pa = resVertices[index + 3]

			if vertIndex = begIdx then
				if bStartWithLast then
					ac2gdl_spx = ac2gdl_lpx
					ac2gdl_spy = ac2gdl_lpy
				else
					ac2gdl_spx = ac2gdl_px
					ac2gdl_spy = ac2gdl_py
				endif
			endif

			if abs(ac2gdl_lpa) > EPS then			!!! Curved contour line
				ac2gdl_mx = (ac2gdl_px + ac2gdl_lpx) / 2
				ac2gdl_my = (ac2gdl_py + ac2gdl_lpy) / 2
				ac2gdl_ratio = 1 / 2 / tan (ac2gdl_lpa / 2)

				ac2gdl_cx = ac2gdl_mx - ac2gdl_ratio * (ac2gdl_py - ac2gdl_lpy)	! Arc center
				ac2gdl_cy = ac2gdl_my + ac2gdl_ratio * (ac2gdl_px - ac2gdl_lpx)

				if abs(ac2gdl_lpa - 360) > EPS then
					put ac2gdl_cx,	ac2gdl_cy,	900,
						0,			ac2gdl_lpa,	4001
				endif
			endif

			if vertIndex > begIdx & bStartWithLast & abs(ac2gdl_spx - ac2gdl_px) < EPS & abs(ac2gdl_spy - ac2gdl_py) < EPS then
				put ac2gdl_px, ac2gdl_py, -1
				bClosed = 1
			else
				if vertIndex < endIdx | not(bStartWithLast) then
					put ac2gdl_px, ac2gdl_py, 1
				endif
			endif

			ac2gdl_lpx = ac2gdl_px
			ac2gdl_lpy = ac2gdl_py
			ac2gdl_lpa = ac2gdl_pa
!!			edgeInfo	= inhEdgeInfos[vertIndex + 1]
		next vertIndex

		if not(bClosed) & numContours > 1 then	! Close the polygon if it has holes
			put ac2gdl_spx, ac2gdl_spy, -1
		endif

		if not(_bValidPoly) then
			dim _invalidPoints[]
			for ii = 1 to nsp
				_invalidPoints[ii] = get(1)
			next ii

			contIndex = numContours
		endif
	next contIndex
return


1001:
! ==============================================================================
! Draw one polygon contour line
! ------------------------------------------------------------------------------
! Input variables:
!	polygonID:				Polygon ID
!	lineAttributes[][3]:	Line attribute array
!								[][1] = pen color
!								[][2] = line type
!								[][3] = line property
!								[][4] = additional line attributes
! bPutHotsopts:				Draw hotspots (boolean)
! polyUnID:					Hotspot start unID
! ==============================================================================

	dim resVertices[]
	numVertices = callfunction(ch, "GetVertices", polygonID, resVertices)
	numVertices = numVertices / 3

	dim contArr[]
	numContours = callfunction(ch, "GetContourEnds", polygonID, contArr)

	dim inhEdgeInfos[]
	numEdges = callfunction(ch, "GetInhEdgeInfos", polygonID, inhEdgeInfos)

	for contIndex = 1 to numContours

		if contIndex = 1 then
			begIdx = 0
		else
			begIdx = contArr[contIndex] - 1
		endif
		if contIndex = numContours then
			endIdx = numVertices - 1
		else
			endIdx = contArr[contIndex + 1] - 2
		endif

		bClosed = 0
		bStartWithLast = 0

		index = endIdx * 3
		lastVertX	= resVertices[index + 1]
		lastVertY	= resVertices[index + 2]
		lastVertA	= resVertices[index + 3]
		edgeInfo	= inhEdgeInfos[endIdx + 1]

		for vertIndex = begIdx to endIdx

			index = vertIndex * 3
			actVertX = resVertices[index + 1]
			actVertY = resVertices[index + 2]
			actVertA = resVertices[index + 3]

!!!text2	(lastVertX + actVertX) / 2,
!!!		(lastVertY + actVertY) / 2,
!!!		edgeInfo

!!!ccc=ccc+0.1
!!!circle2 lastVertX, lastVertY, ccc
!!!circle2 actVertX, actVertY, ccc

			if edgeInfo > 0 & edgeInfo <= vardim1(lineAttributes) then

				if lineAttributes[edgeInfo][1] > 0 then
					if not(gs_transom_display) then
						pen				lineAttributes[edgeInfo][1]
						line_type		lineAttributes[edgeInfo][2]
					else
						pen				gs_transom_display_pen
						line_type		gs_transom_display_linetype
					endif

					line_property	lineAttributes[edgeInfo][3]
					iAttributes = round_int(lineAttributes[edgeInfo][4])

					if abs(lastVertA) > EPS then
						ac2gdl_mx = (actVertX + lastVertX) / 2
						ac2gdl_my = (actVertY + lastVertY) / 2
						ac2gdl_ratio = 1 / 2 / tan (lastVertA / 2)

						ac2gdl_cx = ac2gdl_mx - ac2gdl_ratio * (actVertY - lastVertY)	! Arc center
						ac2gdl_cy = ac2gdl_my + ac2gdl_ratio * (actVertX - lastVertX)
						ac2gdl_rad = sqr((ac2gdl_cx - actVertX)^2 + (ac2gdl_cy - actVertY)^2)

						vx = actVertX - ac2gdl_cx
						vy = actVertY - ac2gdl_cy
						gosub 103	! Direction Angle
						alpha = angle

						vx = lastVertX - ac2gdl_cx
						vy = lastVertY - ac2gdl_cy
						gosub 103	! Direction Angle
						beta = angle

						if abs(alpha - beta) > EPS then
							if abs(alpha - beta) > 180 + EPS then
								angleStart	= max(alpha,beta)
								angleEnd	= min(alpha,beta)
							else
								angleStart	= min(alpha,beta)
								angleEnd	= max(alpha,beta)
							endif
							if bittest(iAttributes, LINE_ATTRIBUTES_GDLLINE) then
								if not(gs_transom_display) then 			! Not drawed when Display as Transom is ON
									arc2 ac2gdl_cx,	ac2gdl_cy, ac2gdl_rad, angleStart, angleEnd
								endif
							endif
							if bittest(iAttributes, LINE_ATTRIBUTES_WALLLINE) then
								if (GLOB_PREVIEW_MODE = 0) then
									arc2 ac2gdl_cx,	ac2gdl_cy, ac2gdl_rad, angleStart, angleEnd
								endif
								wallarc2 ac2gdl_cx,	ac2gdl_cy, ac2gdl_rad, angleStart, angleEnd
							endif
						endif
					else
						if bittest(iAttributes, LINE_ATTRIBUTES_GDLLINE) then
							if not(gs_transom_display) then 			! Not drawed when Display as Transom is ON
								line2 lastVertX, lastVertY, actVertX, actVertY
							endif
						endif
						if bittest(iAttributes, LINE_ATTRIBUTES_WALLLINE) then
							if (GLOB_PREVIEW_MODE = 0) then
								line2 lastVertX, lastVertY, actVertX, actVertY
							endif
							wallline2 lastVertX, lastVertY, actVertX, actVertY
						endif
					endif
				endif
			endif

			if bPutHotsopts & edgeInfo <> inhEdgeInfos[vertIndex + 1] then
				hotspot2 actVertX, actVertY, polyUnID: polyUnID = polyUnID + 1
!ccc=ccc+0.003
!circle2 actVertX, actVertY,ccc
			endif

			lastVertX	= actVertX
			lastVertY	= actVertY
			lastVertA	= actVertA
			edgeInfo	= inhEdgeInfos[vertIndex + 1]

		next vertIndex
	next contIndex
return

]]>
</Script_2D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_1D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
EPS = 0.0001

! iRevealType:
REVEAL_EDGE				= 0
REVEAL_NO				= 1
REVEAL_POSITIVE			= 2
REVEAL_NEGATIVE			= 3
REVEAL_SLANTED			= 4
REVEAL_SPLAYED			= 5
REVEAL_HISTORIC			= 6
REVEAL_DOUBLE			= 7
REVEAL_DOUBLE_SPLAYED	= 8
REVEAL_OUTSIDE_SPLAYED	= 9

! gs_reveal_type_bottom_int
REVEAL_BOTTOM_UNIFORM	= 1
REVEAL_BOTTOM_NO		= 2
REVEAL_BOTTOM_POSITIVE	= 3
REVEAL_BOTTOM_NEGATIVE	= 4

! iWindowShape:
SHAPE_RECTANGULAR			= 0
SHAPE_ARCHED				= 1
SHAPE_ROUND					= 2
SHAPE_EYEBROWS				= 3
SHAPE_HALFCIRCLE			= 4 	! straight side is horizontal
SHAPE_MULTISIDE				= 5
SHAPE_OCTAGONAL				= 6
SHAPE_HALFARCH				= 7
SHAPE_PENTAGON				= 8
SHAPE_QUARTERROUND			= 9
SHAPE_HALFROUND				= 10 	! straight side is vertical
SHAPE_TRAPEZOID				= 11
SHAPE_TRIANGLE				= 12
SHAPE_GOTHICARCH			= 13
SHAPE_ELLIPSEARCH			= 14
SHAPE_ROMBUS				= 15
SHAPE_HORSESHOE				= 16
SHAPE_OGEECENTERED			= 17
SHAPE_SARACENIC				= 18
SHAPE_T						= 19
SHAPE_HALF_T_LEFT			= 20
SHAPE_ARCHED_T				= 21
SHAPE_ARCHED_HALF_T_LEFT	= 22
SHAPE_PARALLELOGRAM			= 23
SHAPE_ELLIPSE				= 24
SHAPE_CORNER_TRIANGLE		= 25
SHAPE_QUARTERROUND_NOFRAME	= 26
SHAPE_HALF_T_RIGHT			= 27
SHAPE_ARCHED_HALF_T_RIGHT	= 28

! Line Property defines:
LINE_PROPERTY_GENERIC	= 0
LINE_PROPERTY_INNER		= 1
LINE_PROPERTY_CONTOUR	= 2

! gs_reveal_set_side:
REVEAL_SET_INSIDE	= 1
REVEAL_SET_OUTSIDE	= 2

! iClosureType:
CLOSURE_NO					= 0
CLOSURE_TRADITIONAL			= 1
CLOSURE_PREFABRICATED		= 2
CLOSURE_CUSTOM				= 3
CLOSURE_SOLID_WALL			= 4
CLOSURE_STUD_WALL			= 5
CLOSURE_STUD_WALL_SIDING	= 6
CLOSURE_BRICK_VENEER		= 7
CLOSURE_VARIABLE			= 8
CLOSURE_PLASTER_REVEAL	 			= 9
CLOSURE_INSULATED_REVEAL			= 10
CLOSURE_INSULATED_FOR_RENOVATION	= 11
CLOSURE_FINISH						= 12
CLOSURE_AIR_SPACE					= 13
CLOSURE_DUTCH_VARIABLE				= 14

! Wall Inset Sizes
PARAPET_SIZE_AUTO	= 1
PARAPET_SIZE_SYMM	= 2
PARAPET_SIZE_ASYMM	= 3

! Wall Inset Bottom at
PARAPET_BOTTOM_CURRENTSTORY	= 1
PARAPET_BOTTOM_WALLBASE		= 2

! iTypeDemolitionFill
RENOVATION_FILL_EXIST		= 1
RENOVATION_FILL_DEMOLISHED	= 2
RENOVATION_FILL_NEW			= 3
RENOVATION_FILL_NEW_FULL	= 4

! =============================================================================
! Reveal Points Indexes
! =============================================================================

idxSillStartRevealLeft		= iRevealPointsIdx[1]
idxSillEndRevealLeft		= iRevealPointsIdx[2]
idxFrameStartRevealLeft		= iRevealPointsIdx[3]
idxFrameEndRevealLeft		= iRevealPointsIdx[4]
idxBoardStartRevealLeft		= iRevealPointsIdx[5]
idxBoardEndRevealLeft		= iRevealPointsIdx[6]
idxSillStartPlasterLeft		= iRevealPointsIdx[7]
idxSillEndPlasterLeft		= iRevealPointsIdx[8]
idxBoardStartPlasterLeft	= iRevealPointsIdx[9]
idxBoardEndPlasterLeft		= iRevealPointsIdx[10]
idxSillStartRevealRight		= iRevealPointsIdx[11]
idxSillEndRevealRight		= iRevealPointsIdx[12]
idxFrameStartRevealRight	= iRevealPointsIdx[13]
idxFrameEndRevealRight		= iRevealPointsIdx[14]
idxBoardStartRevealRight	= iRevealPointsIdx[15]
idxBoardEndRevealRight		= iRevealPointsIdx[16]
idxSillStartPlasterRight	= iRevealPointsIdx[17]
idxSillEndPlasterRight		= iRevealPointsIdx[18]
idxBoardStartPlasterRight	= iRevealPointsIdx[19]
idxBoardEndPlasterRight		= iRevealPointsIdx[20]


! ==============================================================================

bInclinedWall	= (abs(WALL_INCL) > EPS)
curvedWall		= (abs(WIDO_ORIG_DIST) > EPS)
wallIsLeft		= (SYMB_ROTANGLE > EPS) exor WIDO_REVEAL_SIDE
signWallIsLeft	= wallIsleft - not(wallIsleft)

bSlantedInnerSide	= (iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_DOUBLE_SPLAYED)
bSlantedOuterSide	= (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED)
bHaveMountingFrame	= ((iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) & gs_mountingFrame)
bTShapedOpening =  (iWindowShape = SHAPE_T |\
					iWindowShape = SHAPE_HALF_T_LEFT |\
					iWindowShape = SHAPE_HALF_T_RIGHT |\
					iWindowShape = SHAPE_ARCHED_T |\
					iWindowShape = SHAPE_ARCHED_HALF_T_LEFT |\
					iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT)

bHasSidelightLeft = ((iWindowShape = SHAPE_T | \
					  iWindowShape = SHAPE_HALF_T_LEFT | \
					  iWindowShape = SHAPE_ARCHED_T | \
					  iWindowShape = SHAPE_ARCHED_HALF_T_LEFT) & (gs_sidelight_parapet_hgt_left > EPS))

bHasSidelightRight = ((iWindowShape = SHAPE_T | \
					  iWindowShape = SHAPE_HALF_T_RIGHT | \
					  iWindowShape = SHAPE_ARCHED_T | \
					  iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT) & (gs_sidelight_parapet_hgt_right > EPS))

bShapeSameRevealAngles = (iWindowShape = SHAPE_ARCHED |\
						  iWindowShape = SHAPE_ROUND |\
						  iWindowShape = SHAPE_EYEBROWS |\
						  iWindowShape = SHAPE_HALFCIRCLE |\
						  iWindowShape = SHAPE_MULTISIDE |\
						  iWindowShape = SHAPE_OCTAGONAL |\
						  iWindowShape = SHAPE_HALFARCH |\
						  iWindowShape = SHAPE_PENTAGON |\
						  iWindowShape = SHAPE_QUARTERROUND |\
						  iWindowShape = SHAPE_HALFROUND |\
						  iWindowShape = SHAPE_TRAPEZOID |\
						  iWindowShape = SHAPE_TRIANGLE |\
						  iWindowShape = SHAPE_GOTHICARCH |\
						  iWindowShape = SHAPE_ELLIPSEARCH |\
						  iWindowShape = SHAPE_ROMBUS |\
						  iWindowShape = SHAPE_HORSESHOE |\
						  iWindowShape = SHAPE_OGEECENTERED |\
						  iWindowShape = SHAPE_SARACENIC |\
						  iWindowShape = SHAPE_PARALLELOGRAM |\
						  iWindowShape = SHAPE_ELLIPSE |\
						  iWindowShape = SHAPE_CORNER_TRIANGLE |\
						  iWindowShape = SHAPE_QUARTERROUND_NOFRAME)

! ==============================================================================
! Compatibility
! ==============================================================================

openingWidth	= leftWidth + rightWidth
openingHeight	= B


! ==============================================================================

widoLeftJamb	= gs_reveal_left
widoRightJamb	= gs_reveal_right

leftJamb	= gs_reveal_left
rightJamb	= gs_reveal_right


! =============================================================================
! Restrictions for Window Shapes
! =============================================================================

widoHeadDepth = gs_reveal_top

if iWindowShape = SHAPE_ARCHED | iWindowShape = SHAPE_HALFCIRCLE then
	widoLeftJamb	= widoRightJamb
	widoHeadDepth	= widoRightJamb
	leftJamb		= rightJamb

	gs_right_oversize	= 0
	gs_left_oversize	= 0

	thkPlasterAtSillLeft	= thkPlasterAtSillRight
	thkPlasterAtSillTop		= thkPlasterAtSillRight
	thkPlasterAtBoardLeft	= thkPlasterAtBoardRight
	thkPlasterAtBoardTop	= thkPlasterAtBoardRight
endif

if GLOB_SCRIPT_TYPE = 3 then	! Only for 3D
	if iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_MULTISIDE | \
		iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ELLIPSE  then
		thkPlasterAtSillLeft		= 0
		thkPlasterAtBoardLeft		= 0
	endif

	if iWindowShape = SHAPE_HALFROUND then
		thkPlasterAtSillRight		= 0
		thkPlasterAtBoardRight		= 0
	endif

	if iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_MULTISIDE | \
		iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ELLIPSE  then
		thkPlasterAtSillTop			= 0
		thkPlasterAtBoardTop		= 0
	endif

	if iWindowShape = SHAPE_ROUND | iWindowShape = SHAPE_MULTISIDE | \
		iWindowShape = SHAPE_OCTAGONAL | iWindowShape = SHAPE_ELLIPSE  then
		thkPlasterAtSillBottom		= 0
		thkPlasterAtBoardBottom		= 0
	endif
endif


! =============================================================================
! Calculations for Corner or horizontally Stacked Window
! =============================================================================

if bRightCornerFunction & abs(rightCornerAngle) > EPS then
	beta = atn ((rightConnWallThk * sin(rightCornerAngle)) / (WALL_THICKNESS + rightConnWallThk * cos(rightCornerAngle)))
	rx = 1 / tan(rightCornerAngle / 2)

	if rightCornerAngle > 180 then
		overSizeRight = max (0, WALL_THICKNESS / tan(360 - rightCornerAngle + beta) + WIDO_SILL / tan(rightCornerAngle / 2))
	else
		overSizeRight = (WIDO_FRAME_THICKNESS + WIDO_SILL) * rx + max (0, WALL_THICKNESS * tan(rightCornerAngle - beta - 90))
	endif
else
	overSizeRight	= gs_right_oversize
endif

if bLeftCornerFunction & abs(leftCornerAngle) > EPS then
	beta = atn ((leftConnWallThk * sin(leftCornerAngle)) / (WALL_THICKNESS + leftConnWallThk * cos(leftCornerAngle)))
	lx = 1 / tan(leftCornerAngle / 2)

	if leftCornerAngle > 180 then
		overSizeLeft = max (0, WALL_THICKNESS / tan(360 - leftCornerAngle + beta) + WIDO_SILL / tan(leftCornerAngle / 2))
	else
		overSizeLeft = (WIDO_FRAME_THICKNESS + WIDO_SILL) * lx + max (0, WALL_THICKNESS * tan(leftCornerAngle - beta - 90))
	endif
else
	overSizeLeft	= gs_left_oversize
endif

if gs_stack_right | (bRightCornerFunction & abs(rightCornerAngle) > EPS) then
	rightJamb				= 0
	widoRightJamb			= 0
	thkPlasterAtSillRight	= 0
	thkPlasterAtBoardRight	= 0
	revealInnerRight		= 0
	gs_reveal_right_angle	= 0
endif

if (bCornerWindow & SYMB_MIRRORED & gs_stack_right) | gs_stack_left | (bLeftCornerFunction & abs(leftCornerAngle) > EPS) then
	leftJamb				= 0
	widoLeftJamb			= 0
	thkPlasterAtSillLeft	= 0
	thkPlasterAtBoardLeft	= 0
	revealInnerLeft			= 0
	gs_reveal_left_angle	= 0
endif

upperJamb = not(gs_stack_top)    * gs_reveal_top
lowerJamb = not(gs_stack_bottom) * gs_reveal_bottom

overSizeLowerOriginal = overSizeLower

overSizeUpper = gs_upper_oversize
overSizeLower = gs_lower_oversize


if iWindowShape = SHAPE_ARCHED then
	overSizeLeft	= 0
	overSizeRight	= 0
	overSizeUpper	= 0
endif

if not(isWindow) then
	thkPlasterAtSillBottom		= 0
	thkPlasterAtBoardBottom		= 0
endif



! ==============================================================================
! Calculations for Inclined Walls
! ==============================================================================

if bInclinedWall then
	bFactor = SYMB_MIRRORED exor WIDO_REVEAL_SIDE exor wallIsLeft
	incFactor = not(bFactor) - bFactor
	incX = incFactor * tan(WALL_INCL)
	incY = incFactor * (1 / cos(WALL_INCL))

	bDir = SYMB_MIRRORED exor (SYMB_ROTANGLE > EPS)
	iDir = not(bDir) - bDir
	incH = cos(WALL_INCL)
	incV = sin(WALL_INCL) * iDir
else
	incX = 0
	incY = 1
	incH = 0
	incV = 0
endif


! ==============================================================================
! Calculations for vertically Stacked Window
! ==============================================================================

if gs_stack_top then
	thkPlasterAtSillTop		= 0
	thkPlasterAtBoardTop	= 0
endif

if gs_stack_bottom then
	thkPlasterAtSillBottom	= 0
	thkPlasterAtBoardBottom	= 0
endif


! ==============================================================================
! Calculations for Curved Walls
! ==============================================================================

if GLOB_SCRIPT_TYPE = 2 | GLOB_SCRIPT_TYPE = 3 then
	if curvedWall & abs(radSill) > EPS then

		if GLOB_SCRIPT_TYPE <> 2 & GLOB_CONTEXT <> 22 then
			widoOrigDist = -WIDO_ORIG_DIST
		else
			widoOrigDist = WIDO_ORIG_DIST
		endif

		tempWOD = abs(widoOrigDist) - (SYMB_ROTANGLE > EPS) * WIDO_FRAME_THICKNESS

		alfaRefWidth = atn(refWidth / tempWOD)

		alfaLeftOs	= atn((leftWidth  + overSizeLeft)  / tempWOD)
		alfaRightOs	= atn((rightWidth + overSizeRight) / tempWOD)

		alfaLeftJamb	= 180 * leftJamb  / radSill / PI
		alfaRightJamb	= 180 * rightJamb / radSill / PI

		alfaLeftInnJamb = atn((leftWidth  + overSizeLeft - (revealInnerLeft * (iRevealType = REVEAL_DOUBLE))) / tempWOD)
		alfaRightInnJamb = atn((rightWidth  + overSizeRight - (revealInnerRight * (iRevealType = REVEAL_DOUBLE))) / tempWOD)

	endif	! curvedWall
endif


! =============================================================================
! Calculations for Parapet dimension
! =============================================================================

gs_parapet_autodim = (iParapetSize = PARAPET_SIZE_AUTO)

parapet_width	= gs_parapet_width
parapet_height	= gs_parapet_height

bParapetWallInset		= (gs_parapet_wall_inset & abs(gs_parapet_inset_thk) > EPS) & bEnableParapetInset
parapetWallInsetDepth	= (gs_parapet_wall_inset & bEnableParapetInset) * gs_parapet_inset_thk


! Elevation of the current story ----------------

if iParapetBottom = PARAPET_BOTTOM_CURRENTSTORY then
	act_st_pos = SYMB_POS_Y - AC_Sill_To_Curr_Story + gs_parapet_botelev - elevationOffset
else
	act_st_pos = gs_parapet_botelev - elevationOffset
endif

if gs_parapet_autodim | (gs_parapet_width < EPS) then
	if GLOB_SCRIPT_TYPE = 2 then
		if vardim1(rightRevealPnts) >= idxBoardEndPlasterRight then
			parapet_width	= sqr ((rightRevealPnts[idxBoardEndPlasterRight][1]-leftRevealPnts[idxBoardEndPlasterLeft][1])^2 + \
			 (rightRevealPnts[idxBoardEndPlasterRight][2]-leftRevealPnts[idxBoardEndPlasterLeft][2])^2)
		endif
	else
		if vardim1(rightRevealPnts) >= idxBoardEndRevealRight then
			parapet_width	= sqr ((rightRevealPnts[idxBoardEndRevealRight][1]-leftRevealPnts[idxBoardEndRevealLeft][1])^2 + \
			 (rightRevealPnts[idxBoardEndRevealRight][2]-leftRevealPnts[idxBoardEndRevealLeft][2])^2)
		endif
	endif
	maxParapetHeight = SYMB_POS_Y - act_st_pos
	parapet_height = maxParapetHeight
else
	maxParapetHeight = SYMB_POS_Y
	if parapet_height > maxParapetHeight then
		parapet_height = maxParapetHeight
	endif
endif

bParapetWallInsetFullHeight	= (bParapetWallInset & (gs_parapet_autodim | parapet_height >= maxParapetHeight - EPS))

! Calc dimensions -------------------------------

idxSL = idxFrameStartRevealLeft
idxSR = idxFrameStartRevealRight

idxEL = idxFrameEndRevealLeft
idxER = idxFrameEndRevealRight

if bInclinedWall then
	revRightX	= min(rightRevealPnts[idxSR][1], rightRevealPnts[idxER][1]) - (rightWidth + overSizeRight)
	revLeftX	= -(max(leftRevealPnts[idxSL][1], leftRevealPnts[idxEL][1]) + (leftWidth  + overSizeLeft))
	revDRight	= revRightX / incH
	revDLeft	= revLeftX  / incH

	revYL	= revDLeft	* incH
	revYR	= revDRight	* incH

	opInner = (rightWidth + overSizeRight + leftWidth + overSizeLeft) / incH + revDLeft + revDRight
else
	revDRight	= min(rightRevealPnts[idxSR][1], rightRevealPnts[idxER][1]) - (rightWidth + overSizeRight)
	revDLeft	= -(max(leftRevealPnts[idxSL][1], leftRevealPnts[idxEL][1]) + (leftWidth  + overSizeLeft))
	revYL	= revDLeft
	revYR	= revDRight

	opInner = rightWidth + overSizeRight + leftWidth + overSizeLeft + revDLeft + revDRight
endif

if iParapetSize = PARAPET_SIZE_ASYMM then
	! Assymetric
	parapetExtendRight	= gs_parapet_right
	parapetExtendLeft	= gs_parapet_left
	parapet_width = opInner + parapetExtendRight + parapetExtendLeft
else
	! Symmetric or Automatic
	parapetExtendRight 	= (parapet_width - opInner) / 2
	parapetExtendLeft	= (parapet_width - opInner) / 2
endif

py1p = -incX * (rightWidth + overSizeRight + revYR + parapetExtendRight * incH)
py2p =  incX * (leftWidth  + overSizeLeft  + revYL + parapetExtendLeft  * incH)

dx = parapetWallInsetDepth * sin(WALL_INCL)
dy = parapetWallInsetDepth * cos(WALL_INCL)

revYPLeft		= parapetWallInsetDepth * tan(gs_reveal_left_angle - WALL_INCL)
if bInclinedWall then
	revSlantXLeft	= dx + revYPLeft * incH
	revSlantYLeft	= dy - revYPLeft * sin(WALL_INCL)
else
	revSlantXLeft	= revYPLeft
	revSlantYLeft	= parapetWallInsetDepth - revYPLeft
endif

revYPRight		= parapetWallInsetDepth * tan(gs_reveal_right_angle - WALL_INCL)
if bInclinedWall then
	revSlantXRight	= -(dx + revYPright * incH)
	revSlantYRight	=   dy - revYPright * sin(WALL_INCL)
else
	revSlantXRight	= -revYPright
	revSlantYRight	=  parapetWallInsetDepth - revYPright
endif

! =============================================================================
! Different Bottom Reveal Types Enable
! =============================================================================

bEnableDifferentBottomReveal = 1

if	iRevealType = REVEAL_EDGE |\
	iRevealType = REVEAL_SPLAYED |\
	iRevealType = REVEAL_DOUBLE_SPLAYED	|\
	iRevealType = REVEAL_OUTSIDE_SPLAYED |\
	iClosureType = CLOSURE_STUD_WALL |\
	iClosureType = CLOSURE_STUD_WALL_SIDING |\
	iClosureType = CLOSURE_BRICK_VENEER  |\
	bForceUniformBottomReveal then

	bEnableDifferentBottomReveal = 0
endif

! =============================================================================
! Uniform Jamb Depth Enable (Reveal Types and USA Stud Wall Closures)
! =============================================================================
bEnableUniformJambDepths = 1
bShowUniformJambDepths = 1

if	iClosureType = CLOSURE_STUD_WALL |\
	iClosureType = CLOSURE_STUD_WALL_SIDING |\
	iClosureType = CLOSURE_BRICK_VENEER |\
	iRevealType = REVEAL_EDGE |\
	iRevealType = REVEAL_NO |\
	(iRevealType = REVEAL_DOUBLE & iSillRevealType = REVEAL_NO & iBoardRevealType = REVEAL_NO) then

	bEnableUniformJambDepths = 0
	bShowUniformJambDepths = 0
endif

if	iRevealType = REVEAL_DOUBLE_SPLAYED |\
	iRevealType = REVEAL_OUTSIDE_SPLAYED then

	bShowUniformJambDepths = 0
endif

if bShapeSameRevealAngles then
	bShowUniformJambDepths = 0
endif

]]>
</Script_1D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_PR SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_PR>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_UI SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
bCustomReveal = (iRevealType = REVEAL_NEGATIVE | iRevealType = REVEAL_SLANTED)

if bRevealSettingsPage then

	if gs_closure_auto_changed then
		! The previously selected wall closure type is not available for this reveal.
		! The wall closure was changed.
		ui_pict 76, 430, 40 + pageStartY, 12,12,1 ui_tooltip stRevealUI[2] + " " + stRevealUI[3]
	endif

	y0 = 64 + pageStartY
	infieldElevation = 4
	x1 = 2
	x2 = 104
	x3 = 223
	x4 = 443-108
	x5 = 443-5
	xPic = 8
	yPic = 157 + pageStartY
	xPicTop = 315
	yPicTop = 100 + pageStartY
	xPicBot = 315
	yPicBot = 100+58+5 + pageStartY
	yRevealText = 41 + pageStartY
	infieldHeight	= 19
	outfieldHeight	= 15

	yCurr = y0

	if bEnableUniformJambDepths & gs_reveal_uniform then
		n = request("Working_length_unit", "", formatt)
		if iRevealType = REVEAL_SPLAYED | iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_HISTORIC then
			m = request("Working_angle_unit", "", formatAngle)
		endif
	endif

	if bEnableUniformJambDepths & bShowUniformJambDepths then
		! Uniform Jamb Depth -------------------------------------------------------------

		ui_infield{3} "gs_reveal_uniform", x1, yCurr-infieldElevation, x4-x1-2, 20,
			7, "",
			2,
			1, 20, 20, 20, 20,
			0, stRevealUI[4], 0,
			1, stRevealUI[4], 1

	endif

	if bEnableDifferentBottomReveal then
		! Bottom Reveal control -------------------------------------------------------------
			bottomRevTextFlag = 4*(iClosureType = CLOSURE_STUD_WALL | iClosureType = CLOSURE_STUD_WALL_SIDING |iClosureType = CLOSURE_BRICK_VENEER)
			ui_outfield		stWallholeCutUI[32],			x3,	246,					x4-x3-2,	outfieldHeight, bottomRevTextFlag
			ui_infield{3}	"gs_reveal_type_bottom_int",	x4,	246-infieldElevation,	x5-x4,		infieldHeight,
					8, "", 4, 1, 0, 0, 0, 0,
					1, stRevealTypesBottom[1], REVEAL_BOTTOM_UNIFORM,
					2, stRevealTypesBottom[2], REVEAL_BOTTOM_NO,
					3, stRevealTypesBottom[3], REVEAL_BOTTOM_POSITIVE,
					4, stRevealTypesBottom[4], REVEAL_BOTTOM_NEGATIVE

	endif


! No Reveal - Edge -------------------------------------------------------------

	if iRevealType = REVEAL_EDGE then
		ui_style 0, 1
		ui_outfield stRevealTypes[1], x1, yRevealText, x3-x1-1, 16
		ui_style 0,0

		if not(isEmptyOpening) then
			if isWindow then
				ui_pict 135, xPic, yPic, 121, 33, 1		!no_reveal_edge_win.png
			else
				ui_pict 136, xPic, yPic, 121, 33, 1		!no_reveal_edge_door.png
			endif
		else
			ui_pict 137, xPic, yPic, 121, 33, 1			!no_reveal_edge_op.png
		endif

		ui_pict 45, xPic+121, yPic-4, 13, 9, 1
		ui_infield "AC_wido_sill", xPic+121+14, yPic-2, 72, infieldHeight ui_tooltip stRevealClusureUITips[1]

		if not(isEmptyOpening) then
			if isWindow then
				ui_pict 138, xPicTop, yPicTop, 33, 58, 1	!no_reveal_edge_top_win.png
				ui_pict 139, xPicBot, yPicBot, 33, 58, 1	!no_reveal_edge_bot_win.png
			else
				ui_pict 140, xPicTop, yPicTop, 33, 58, 1	!no_reveal_edge_top_door.png
				ui_pict 141, xPicBot, yPicBot, 33, 58, 1	!no_reveal_edge_bot_door.png
			endif
		else
			ui_pict 142, xPicTop, yPicTop, 33, 58, 1		!no_reveal_edge_top_op.png
			ui_pict 143, xPicBot, yPicBot, 33, 58, 1		!no_reveal_edge_bot_op.png
		endif

	endif

! No Reveal --------------------------------------------------------------------

	if iRevealType  = REVEAL_NO then
		ui_style 0, 1
		ui_outfield stRevealTypes[2], x1, yRevealText, x3-x1-1, 16
		ui_style 0,0
		gosub "noRevealPicsHorizontal"
		gosub "revealDepthParam"
		gosub "noRevealPicsVertical"

		if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
			gosub "bottomPositiveReveal"
		else
			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
				gosub "bottomNegativeReveal"
			else
				gosub "bottomNoReveal"
			endif
		endif
	endif


! Reveal -----------------------------------------------------------------------

	if iRevealType  = REVEAL_POSITIVE then
		ui_style 0, 1
		ui_outfield stRevealTypes[3], x1, yRevealText, x3-x1-1, 16
		ui_style 0,0

		if bTShapedOpening then
			gosub "ui of t shape"
		else
			gosub "revealPicsHorizontal"
			gosub "horizontalPosRevealParams"
			gosub "revealDepthParam"
			gosub "revealPicsVerticalTop"

			ui_pict 21, xPicTop-11, yPicTop+24, 11, 10, 1		!ui_arrow_10_v.png
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicTop+23, 72, outfieldHeight, 1
			else
				ui_infield "gs_reveal_top",	xPicTop-88, yPicTop+19, 72, infieldHeight ui_tooltip stRevealClusureUITips[6]
			endif

			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
				gosub "bottomNegativeReveal"
			else
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					gosub "bottomNoReveal"
				else
					gosub "bottomPositiveReveal"
				endif
			endif
		endif
	endif

! Negative Reveal --------------------------------------------------------------

	if iRevealType  = REVEAL_NEGATIVE then
		ui_style 0, 1
		ui_outfield stRevealTypes[4], x1, yRevealText, x3-x1-1, 16
		ui_style 0,0

		if bTShapedOpening then
			gosub "ui of t shape"
		else
			gosub "negRevealPicsHorizontal"
			gosub "horizontalNegRevealParams"
			gosub "revealDepthParam"

			gosub "negRevealPicsVerticalTop"
			ui_pict 21, xPicTop-11, yPicTop+16, 11, 10, 1		!ui_arrow_10_v.png
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicTop+15, 72, outfieldHeight, 1
			else
				ui_infield "gs_reveal_top",	xPicTop-88, yPicTop+11, 72, infieldHeight ui_tooltip stRevealClusureUITips[6]
			endif

			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
				gosub "bottomPositiveReveal"
			else
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					gosub "bottomNoReveal"
				else
					gosub "bottomNegativeReveal"
				endif
			endif
		endif
	endif

! Slanted Reveal ---------------------------------------------------------------

	if iRevealType  = REVEAL_SLANTED then
		ui_style 0, 1
		ui_outfield stRevealTypes[5], x1, yRevealText, 320, 16
		ui_style 0,0

		if not(isEmptyOpening) then
			if isWindow then
				ui_pict 111, xPic, yPic, 121, 33, 1	!slanted_reveal_win.png
			else
				ui_pict 112, xPic, yPic, 121, 33, 1	!slanted_reveal_door.png
			endif
		else
			ui_pict 113, xPic, yPic, 121, 33, 1	!slanted_reveal_op.png
		endif
		gosub "horizontalPosRevealParams"
		gosub "revealDepthParam"

		ui_pict 11, xPic,  yPic+35, 19,25, 1
		ui_pict 12, xPic+102,yPic+35, 19,25, 1

		ui_infield "gs_reveal_right_angle",	xPic+93,	yPic+63, 60,infieldHeight ui_tooltip stRevealClusureUITips[11]
		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatAngle, abs(gs_reveal_right_angle)), xPic-6,	yPic+67, 60, outfieldHeight
		else
			ui_infield "gs_reveal_left_angle",	xPic-6,	yPic+63, 60, infieldHeight ui_tooltip stRevealClusureUITips[10]
		endif

		angleYPosDiff = 0
		if not(isEmptyOpening) then
			if isWindow then
				angleYPosDiff = 10
				ui_pict 114, xPicTop, yPicTop, 33, 58, 1	!slanted_reveal_top_win.png
			else
				ui_pict 115, xPicTop, yPicTop, 33, 58, 1	!slanted_reveal_top_door.png
			endif
		else
			angleYPosDiff = 10
			ui_pict 116, xPicTop, yPicTop, 33, 58, 1		!slanted_reveal_top_op.png
		endif
		ui_pict 8, xPicTop+34, yPicTop+angleYPosDiff, 25, 19, 1
		ui_pict 21, xPicTop-11, yPicTop+24, 11, 10, 1		!ui_arrow_10_v.png

		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicTop+23, 72, outfieldHeight, 1
		else
			ui_infield "gs_reveal_top",	xPicTop-88, yPicTop+19, 72, infieldHeight ui_tooltip stRevealClusureUITips[6]
		endif

		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatAngle, abs(gs_reveal_right_angle)), xPicTop+64,yPicTop+2+angleYPosDiff, 60, outfieldHeight
		else
			ui_infield "gs_reveal_top_angle",	xPicTop+64,yPicTop-2+angleYPosDiff,  60, infieldHeight ui_tooltip stRevealClusureUITips[12]
		endif

		if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
			gosub "bottomPositiveReveal"
		else
			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
				gosub "bottomNoReveal"
			else
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
					gosub "bottomNegativeReveal"
				else
					angleYPosDiff = 0
					if not(isEmptyOpening) then
						if isWindow then
							angleYPosDiff = 10
							ui_pict 117, xPicBot, yPicBot, 33, 58, 1	!slanted_reveal_bot_win.png
						else
							ui_pict 118, xPicBot, yPicBot, 33, 58, 1	!slanted_reveal_bot_door.png
						endif
					else
						ui_pict 119, xPicBot, yPicBot, 33, 58, 1		!slanted_reveal_bot_op.png
					endif
					ui_pict 21, xPicBot-11, yPicBot+24, 11, 10, 1		!ui_arrow_10_v.png
					ui_pict 9, xPicBot+34, yPicBot+30+angleYPosDiff, 25, 19, 1

					ui_infield "gs_reveal_bottom", xPicBot-88, yPicBot+19, 72, infieldHeight 	ui_tooltip stRevealClusureUITips[7]
					ui_infield "gs_reveal_bottom_angle",xPicBot+64,yPicBot+30+angleYPosDiff, 60,infieldHeight ui_tooltip stRevealClusureUITips[13]
				endif
			endif
		endif
	endif

! Splayed Reveal ---------------------------------------------------------------

	if iRevealType  = REVEAL_SPLAYED then
		ui_style 0, 1
		ui_outfield stRevealTypes[6], x1, yRevealText, 320, 16
		ui_style 0,0


		if not(isEmptyOpening) then
			if isWindow then
				ui_pict 120, xPic, yPic, 121, 33, 1	!splayed_reveal_win.png
			else
				ui_pict 121, xPic, yPic, 121, 33, 1	!splayed_reveal_door.png
			endif
		else
			ui_pict 122, xPic, yPic, 121, 33, 1	!splayed_reveal_op.png
		endif

		gosub "revealDepthParam"

		ui_pict 20, xPic+24, yPic-11, 10, 11, 1			!ui_arrow_10.png
		ui_pict 20, xPic+87, yPic-11, 10, 11, 1			!ui_arrow_10.png

		ui_infield "gs_reveal_splayed_innerRight", xPic+87, yPic-34, 72, infieldHeight ui_tooltip stRevealClusureUITips[5]
		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatt, abs(gs_reveal_splayed_innerRight)), xPic-6,	yPic-30, 72, outfieldHeight, 2
		else
			ui_infield "gs_reveal_splayed_innerLeft", xPic-6,	yPic-34, 72, infieldHeight ui_tooltip stRevealClusureUITips[4]
		endif

		ui_pict 11, xPic,  yPic+35, 19,25, 1
		ui_pict 12, xPic+102,yPic+35, 19,25, 1

		ui_infield "gs_reveal_right_angle",	xPic+93,	yPic+63, 60,infieldHeight ui_tooltip stRevealClusureUITips[11]
		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatAngle, abs(gs_reveal_right_angle)), xPic-6,	yPic+67, 60, outfieldHeight
		else
			ui_infield "gs_reveal_left_angle",	xPic-6,	yPic+63, 60, infieldHeight ui_tooltip stRevealClusureUITips[10]
		endif

		if not(isEmptyOpening) then
			if isWindow then
				ui_pict 144, xPicTop, yPicTop, 33, 58, 1	!splayed_reveal_top_win.png
				ui_pict 145, xPicBot, yPicBot, 33, 58, 1	!splayed_reveal_bot_win.png
			else
				ui_pict 146, xPicTop, yPicTop, 33, 58, 1	!splayed_reveal_top_door.png
				ui_pict 147, xPicBot, yPicBot, 33, 58, 1	!splayed_reveal_bot_door.png
			endif
		else
			ui_pict 148, xPicTop, yPicTop, 33, 58, 1		!splayed_reveal_top_op.png
			ui_pict 149, xPicBot, yPicBot, 33, 58, 1		!splayed_reveal_bot_op.png
		endif

		ui_pict 8, xPicTop+34, yPicTop+10, 25, 19, 1
		ui_pict 21, xPicTop-11, yPicTop+24, 11, 10, 1		!ui_arrow_10_v.png

		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatt, abs(gs_reveal_splayed_innerRight)), xPicTop-88, yPicTop+23, 72, outfieldHeight, 1
		else
			ui_infield "gs_reveal_splayed_innerTop",	xPicTop-88, yPicTop+19, 72, infieldHeight ui_tooltip stRevealClusureUITips[8]
		endif

		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatAngle, abs(gs_reveal_right_angle)), xPicTop+64,yPicTop+12, 60, outfieldHeight
		else
			ui_infield "gs_reveal_top_angle",	xPicTop+64, yPicTop+8,  60,infieldHeight ui_tooltip stRevealClusureUITips[12]
		endif

		ui_pict 21, xPicBot-11, yPicBot+24, 11, 10, 1		!ui_arrow_10_v.png
		ui_pict 9, xPicBot+34, yPicBot+30, 25, 19, 1

		ui_infield "gs_reveal_splayed_innerBottom", xPicBot-88, yPicBot+19, 72, infieldHeight 	ui_tooltip stRevealClusureUITips[9]
		ui_infield "gs_reveal_bottom_angle",xPicBot+64,yPicBot+30, 60, infieldHeight ui_tooltip stRevealClusureUITips[13]
	endif

! Historic Reveal --------------------------------------------------------------

	if iRevealType  = REVEAL_HISTORIC then
		ui_style 0, 1
		ui_outfield stRevealTypes[7], x1, yRevealText, x3-x1-1, 16
		ui_style 0,0

		if not(isEmptyOpening) then
			if isWindow then
				ui_pict 123, xPic, yPic, 121, 33, 1	!historic_reveal_win.png
			else
				ui_pict 124, xPic, yPic, 121, 33, 1	!historic_reveal_door.png
			endif
		else
			ui_pict 125, xPic, yPic, 121, 33, 1	!historic_reveal_op.png
		endif
		gosub "horizontalPosRevealParams"
		gosub "revealDepthParam"

		ui_infield "gs_reveal_splayed_innerRight", xPic+87, yPic+45, 72, infieldHeight ui_tooltip stRevealClusureUITips[5]

		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatt, abs(gs_reveal_splayed_innerRight)), xPic-6,	yPic+49, 55, outfieldHeight, 2
		else
			ui_infield "gs_reveal_splayed_innerLeft", xPic-6,	yPic+45, 72, infieldHeight ui_tooltip stRevealClusureUITips[4]
		endif

		ui_pict 44, xPic+16, yPic+33, 10, 11, 1			!ui_arrow_10_m.png
		ui_pict 44, xPic+95, yPic+33, 10, 11, 1			!ui_arrow_10_m.png

		ui_pict 11, xPic,  yPic+67, 19,25, 1
		ui_pict 12, xPic+102,yPic+67, 19,25, 1

		ui_infield "gs_reveal_right_angle",	xPic+102+26,	yPic+75, 60, infieldHeight ui_tooltip stRevealClusureUITips[11]
		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatAngle, abs(gs_reveal_right_angle)), xPic+26,	yPic+79, 60, outfieldHeight
		else
			ui_infield "gs_reveal_left_angle",	xPic+26,	yPic+75, 60, infieldHeight ui_tooltip stRevealClusureUITips[10]
		endif


		if not(isEmptyOpening) then
			if isWindow then
				ui_pict 150, xPicTop, yPicTop, 33, 58, 1	!historic_reveal_top_win.png
			else
				ui_pict 151, xPicTop, yPicTop, 33, 58, 1	!historic_reveal_top_door.png
			endif
		else
			ui_pict 152, xPicTop, yPicTop, 33, 58, 1		!historic_reveal_top_op.png
		endif
		ui_pict 8, xPicTop+34, yPicTop-10, 25, 19, 1
		ui_pict 21, xPicTop-11, yPicTop+24, 11, 10, 1		!ui_arrow_10_v.png
		ui_pict 77, xPicTop+33, yPicTop+16, 11, 10, 1		!ui_arrow_10_vm.png

		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicTop+23, 72, outfieldHeight, 1
		else
			ui_infield "gs_reveal_top",	xPicTop-88, yPicTop+19, 72, infieldHeight ui_tooltip stRevealClusureUITips[6]
		endif

		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatt, abs(gs_reveal_splayed_innerRight)), xPicTop+33+19,yPicTop+15, 72, outfieldHeight
		else
			ui_infield "gs_reveal_splayed_innerTop",	xPicTop+33+19,yPicTop+11, 72,infieldHeight ui_tooltip stRevealClusureUITips[8]
		endif

		if bEnableUniformJambDepths & gs_reveal_uniform then
			ui_outfield str(formatAngle, abs(gs_reveal_right_angle)), xPicTop+64,yPicTop-8, 60, outfieldHeight
		else
			ui_infield "gs_reveal_top_angle",	xPicTop+64,yPicTop-12,  60,infieldHeight ui_tooltip stRevealClusureUITips[12]
		endif

		if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
			gosub "bottomPositiveReveal"
		else
			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
				gosub "bottomNoReveal"
			else
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
					gosub "bottomNegativeReveal"
				else
					angleYPosDiff = 0
					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 153, xPicBot, yPicBot, 33, 58, 1	!historic_reveal_bot_win.png
						else
							ui_pict 154, xPicBot, yPicBot, 33, 58, 1	!historic_reveal_bot_door.png
						endif
					else
						ui_pict 155, xPicBot, yPicBot, 33, 58, 1		!historic_reveal_bot_op.png
					endif
					ui_pict 21, xPicBot-11, yPicBot+24, 11, 10, 1		!ui_arrow_10_v.png
					ui_pict 9, xPicBot+34, yPicBot+49, 25, 19, 1
					ui_pict 77, xPicBot+33, yPicBot+32, 11, 10, 1		!ui_arrow_10_vm.png

					ui_infield "gs_reveal_bottom", xPicBot-88, yPicBot+19, 72, infieldHeight	ui_tooltip stRevealClusureUITips[7]
					ui_infield "gs_reveal_bottom_angle",xPicBot+64,yPicBot+49, 60,infieldHeight ui_tooltip stRevealClusureUITips[13]
					ui_infield "gs_reveal_splayed_innerBottom",	xPicBot+33+19, yPicBot+27, 72,infieldHeight ui_tooltip stRevealClusureUITips[9]
				endif
			endif
		endif

	endif

! Custom Reveal ----------------------------------------------------------------

	if iRevealType  = REVEAL_DOUBLE then
		ui_style 0, 1
		ui_outfield stRevealTypes[8], x1, yRevealText, x3-x1-11, 16
		ui_style 0,0

		ui_outfield		stRevealUI[5],					x1,	91 + pageStartY,	x2-x1-1, 16
		ui_infield{3}	"gs_reveal_doubleOuterTypeInt",	x2,	87 + pageStartY,	x3-x2-12, 20,
						8, "", 3, 1,
						0, 0, 0, 0,
						1, stRevealTypes[2], 2,
						2, stRevealTypes[3], 3,
						3, stRevealTypes[4], 4

		ui_outfield		stRevealUI[6],					x1,	246,	x2-x1-1, 16
		ui_infield{3}	"gs_reveal_doubleInnerTypeInt",	x2, 242,	x3-x2-12, 20,
						8, "", 3, 1,
						0, 0, 0, 0,
						1, stRevealTypes[2], 2,
						2, stRevealTypes[3], 3,
						3, stRevealTypes[4], 4

		if bTShapedOpening then
			gosub "ui of t shape"
		else
			gosub "revealDepthParam"

			if iSillRevealType = REVEAL_NO then
				if iBoardRevealType = REVEAL_NO then
					gosub "noRevealPicsHorizontal"
					gosub "noRevealPicsVertical"

					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
						gosub "bottomNoReveal"
					endif
				else
					ui_pict 7, xPic+121, yPic, 11, 11, 1			!ui_arrow_11.png
					ui_infield "gs_wido_sill", xPic+121+16, yPic-5, 72, infieldHeight ui_tooltip stRevealClusureUITips[1]
				endif

				if iBoardRevealType = REVEAL_POSITIVE then
					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 38, xPic, yPic, 121, 33, 1	!custom_norev_rev_win.png
						else
							ui_pict 39, xPic, yPic, 121, 33, 1	!custom_norev_rev_door.png
						endif
					else
						ui_pict 40, xPic, yPic, 121, 33, 1	!custom_norev_rev_op.png
					endif

					ui_pict 44, xPic+24, yPic+33, 10, 11, 1			!ui_arrow_10_m.png
					ui_pict 44, xPic+87, yPic+33, 10, 11, 1			!ui_arrow_10_m.png

					gosub "customInnerPosRevealParamaters"

					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 29, xPicTop, yPicTop, 33, 58, 1	!custom_norev_rev_top_win.png
						else
							ui_pict 30, xPicTop, yPicTop, 33, 58, 1	!custom_norev_rev_top_door.png
						endif
					else
						ui_pict 31, xPicTop, yPicTop, 33, 58, 1			!custom_norev_rev_top_op.png
					endif

					ui_pict 77, xPicTop+33, yPicTop+24, 11, 10, 1		!ui_arrow_10_vm.png
					if bEnableUniformJambDepths & gs_reveal_uniform then
						ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19,yPicTop+23, 72, outfieldHeight
					else
						ui_infield "gs_reveal_double_innerTop",		xPicTop+33+19,yPicTop+19, 72,infieldHeight ui_tooltip stRevealClusureUITips[8]
					endif

					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
						if not(isEmptyOpening) then
							if isWindow then
								ui_pict 156, xPicBot, yPicBot, 33, 58, 1	!custom_norev_rev_bot_win.png
							else
								ui_pict 157, xPicBot, yPicBot, 33, 58, 1	!custom_norev_rev_bot_door.png
							endif
						else
							ui_pict 158, xPicBot, yPicBot, 33, 58, 1		!custom_norev_rev_bot_op.png
						endif

						ui_pict 77, xPicBot+33, yPicBot+24, 11, 10, 1		!ui_arrow_10_vm.png
						if bForceUniformBottomReveal then
							ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19, yPicBot+23, 72, outfieldHeight, 0
						else
							ui_infield "gs_reveal_double_innerBottom",	xPicTop+33+19, yPicBot+19, 72, infieldHeight ui_tooltip stRevealClusureUITips[9]
						endif
					endif
				endif

				if iBoardRevealType = REVEAL_NEGATIVE then
					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 159, xPic, yPic, 121, 33, 1	!custom_norev_negrev_win.png
						else
							ui_pict 160, xPic, yPic, 121, 33, 1	!custom_norev_negrev_door.png
						endif
					else
						ui_pict 161, xPic, yPic, 121, 33, 1	!custom_norev_negrev_op.png
					endif

					ui_pict 44, xPic+16, yPic+33, 10, 11, 1			!ui_arrow_10_m.png
					ui_pict 44, xPic+95, yPic+33, 10, 11, 1			!ui_arrow_10_m.png

					gosub "customInnerNegRevealParamaters"

					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 162, xPicTop, yPicTop, 33, 58, 1	!custom_norev_negrev_top_win.png
						else
							ui_pict 163, xPicTop, yPicTop, 33, 58, 1	!custom_norev_negrev_top_door.png
						endif
					else
						ui_pict 164, xPicTop, yPicTop, 33, 58, 1			!custom_norev_negrev_top_op.png
					endif

					ui_pict 77, xPicTop+33, yPicTop+16, 11, 10, 1		!ui_arrow_10_vm.png
					if bEnableUniformJambDepths & gs_reveal_uniform then
						ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19,yPicTop+15, 72, outfieldHeight
					else
						ui_infield "gs_reveal_double_innerTop",		xPicTop+33+19,yPicTop+11, 72, infieldHeight ui_tooltip stRevealClusureUITips[8]
					endif

					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
						if not(isEmptyOpening) then
							if isWindow then
								ui_pict 165, xPicBot, yPicBot, 33, 58, 1	!custom_norev_negrev_bot_win.png
							else
								ui_pict 166, xPicBot, yPicBot, 33, 58, 1	!custom_norev_negrev_bot_door.png
							endif
						else
							ui_pict 167, xPicBot, yPicBot, 33, 58, 1		!custom_norev_negrev_bot_op.png
						endif

						ui_pict 77, xPicBot+33, yPicBot+32, 11, 10, 1		!ui_arrow_10_vm.png
						if bForceUniformBottomReveal then
							ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19, yPicBot+31, 72, outfieldHeight, 0
						else
							ui_infield "gs_reveal_double_innerBottom",	xPicTop+33+19, yPicBot+27, 72, infieldHeight ui_tooltip stRevealClusureUITips[9]
						endif
					endif
				endif
			endif

			if iSillRevealType = REVEAL_POSITIVE then
				gosub "horizontalPosRevealParams"

				ui_pict 21, xPicTop-11, yPicTop+24, 11, 10, 1		!ui_arrow_10_v.png
				if bEnableUniformJambDepths & gs_reveal_uniform then
					ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicTop+23, 72, outfieldHeight, 1
				else
					ui_infield "gs_reveal_top",	xPicTop-88, yPicTop+19, 72, infieldHeight ui_tooltip stRevealClusureUITips[6]
				endif

!				if isWindow then
!					ui_infield "gs_reveal_bottom",	x3-65, y2+85, 60, infieldHeight ui_tooltip stRevealClusureUITips[7]
!				endif

				if iBoardRevealType = REVEAL_NO then
					gosub "revealPicsHorizontal"
					gosub "revealPicsVerticalTop"

					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
						gosub "bottomPositiveReveal"
					endif
				endif

				if iBoardRevealType = REVEAL_POSITIVE then
					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 26, xPic, yPic, 121, 33, 1	!custom_rev_rev_win.png
						else
							ui_pict 27, xPic, yPic, 121, 33, 1	!custom_rev_rev_door.png
						endif
					else
						ui_pict 28, xPic, yPic, 121, 33, 1	!custom_rev_rev_op.png
					endif
					ui_pict 44, xPic+24, yPic+33, 10, 11, 1			!ui_arrow_10_m.png
					ui_pict 44, xPic+87, yPic+33, 10, 11, 1			!ui_arrow_10_m.png

					gosub "customInnerPosRevealParamaters"

					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 32, xPicTop, yPicTop, 33, 58, 1	!custom_rev_rev_top_win.png
						else
							ui_pict 33, xPicTop, yPicTop, 33, 58, 1	!custom_rev_rev_top_door.png
						endif
					else
						ui_pict 34, xPicTop, yPicTop, 33, 58, 1			!custom_rev_rev_top_op.png
					endif

					ui_pict 77, xPicTop+33, yPicTop+24, 11, 10, 1		!ui_arrow_10_vm.png
					if bEnableUniformJambDepths & gs_reveal_uniform then
						ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19,yPicTop+23, 72, outfieldHeight
					else
						ui_infield "gs_reveal_double_innerTop",		xPicTop+33+19,yPicTop+19, 72,infieldHeight ui_tooltip stRevealClusureUITips[8]
					endif

					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
						if not(isEmptyOpening) then
							if isWindow then
								ui_pict 35, xPicBot, yPicBot, 33, 58, 1	!custom_rev_rev_bot_win.png
							else
								ui_pict 36, xPicBot, yPicBot, 33, 58, 1	!custom_rev_rev_bot_door.png
							endif
						else
							ui_pict 37, xPicBot, yPicBot, 33, 58, 1		!custom_rev_rev_bot_op.png
						endif

						ui_pict 77, xPicBot+33, yPicBot+24, 11, 10, 1		!ui_arrow_10_vm.png
						if bForceUniformBottomReveal then
							ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19, yPicBot+23, 72, outfieldHeight, 0
						else
							ui_infield "gs_reveal_double_innerBottom",	xPicTop+33+19, yPicBot+19, 72, infieldHeight ui_tooltip stRevealClusureUITips[9]
						endif
						ui_pict 21, xPicBot-11, yPicBot+24, 11, 10, 1		!ui_arrow_10_v.png
						if bForceUniformBottomReveal then
							ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicBot+23, 72, outfieldHeight, 1
						else
							ui_infield "gs_reveal_bottom", xPicBot-88, yPicBot+19, 72, infieldHeight ui_tooltip stRevealClusureUITips[7]
						endif
					endif
				endif

				if iBoardRevealType = REVEAL_NEGATIVE then
					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 41, xPic, yPic, 121, 33, 1	!custom_rev_negrev_win.png
						else
							ui_pict 42, xPic, yPic, 121, 33, 1	!custom_rev_negrev_door.png
						endif
					else
						ui_pict 43, xPic, yPic, 121, 33, 1	!custom_rev_negrev_op.png
					endif
					ui_pict 44, xPic+16, yPic+33, 10, 11, 1			!ui_arrow_10_m.png
					ui_pict 44, xPic+95, yPic+33, 10, 11, 1			!ui_arrow_10_m.png

					gosub "customInnerNegRevealParamaters"

					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 168, xPicTop, yPicTop, 33, 58, 1	!custom_rev_negrev_top_win.png
						else
							ui_pict 169, xPicTop, yPicTop, 33, 58, 1	!custom_rev_negrev_top_door.png
						endif
					else
						ui_pict 170, xPicTop, yPicTop, 33, 58, 1			!custom_rev_negrev_top_op.png
					endif

					ui_pict 77, xPicTop+33, yPicTop+16, 11, 10, 1		!ui_arrow_10_vm.png
					if bEnableUniformJambDepths & gs_reveal_uniform then
						ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19,yPicTop+15, 72, outfieldHeight
					else
						ui_infield "gs_reveal_double_innerTop",		xPicTop+33+19,yPicTop+11, 72,infieldHeight ui_tooltip stRevealClusureUITips[8]
					endif

					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
						if not(isEmptyOpening) then
							if isWindow then
								ui_pict 171, xPicBot, yPicBot, 33, 58, 1	!custom_rev_negrev_bot_win.png
							else
								ui_pict 172, xPicBot, yPicBot, 33, 58, 1	!custom_rev_negrev_bot_door.png
							endif
						else
							ui_pict 173, xPicBot, yPicBot, 33, 58, 1		!custom_rev_negrev_bot_op.png
						endif

						ui_pict 77, xPicBot+33, yPicBot+32, 11, 10, 1		!ui_arrow_10_vm.png
						if bForceUniformBottomReveal then
							ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19, yPicBot+31, 72, outfieldHeight, 0
						else
							ui_infield "gs_reveal_double_innerBottom",	xPicTop+33+19, yPicBot+27, 72, infieldHeight ui_tooltip stRevealClusureUITips[9]
						endif
						ui_pict 21, xPicBot-11, yPicBot+24, 11, 10, 1		!ui_arrow_10_v.png
						if bForceUniformBottomReveal then
							ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicBot+23, 72, outfieldHeight, 1
						else
							ui_infield "gs_reveal_bottom", xPicBot-88, yPicBot+19, 72, infieldHeight	ui_tooltip stRevealClusureUITips[7]
						endif
					endif
				endif
			endif

			if iSillRevealType = REVEAL_NEGATIVE then
				gosub "horizontalNegRevealParams"

				ui_pict 21, xPicTop-11, yPicTop+16, 11, 10, 1		!ui_arrow_10_v.png
				if bEnableUniformJambDepths & gs_reveal_uniform then
					ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicTop+15, 72, outfieldHeight, 1
				else
					ui_infield "gs_reveal_top",	xPicTop-88, yPicTop+11, 72, infieldHeight ui_tooltip stRevealClusureUITips[6]
				endif

!				if isWindow then
!					ui_infield "gs_reveal_bottom",	x3-65, y2+99, 60, infieldHeight ui_tooltip stRevealClusureUITips[7]
!				endif

				if iBoardRevealType = REVEAL_NO then
					gosub "negRevealPicsHorizontal"
					gosub "negRevealPicsVerticalTop"
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
						gosub "bottomNegativeReveal"
					endif
				endif

				if iBoardRevealType = REVEAL_POSITIVE then
					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 174, xPic, yPic, 121, 33, 1	!custom_negrev_rev_win.png
						else
							ui_pict 175, xPic, yPic, 121, 33, 1	!custom_negrev_rev_door.png
						endif
					else
						ui_pict 176, xPic, yPic, 121, 33, 1	!custom_negrev_rev_op.png
					endif
					ui_pict 44, xPic+24, yPic+33, 10, 11, 1			!ui_arrow_10_m.png
					ui_pict 44, xPic+87, yPic+33, 10, 11, 1			!ui_arrow_10_m.png

					gosub "customInnerPosRevealParamaters"

					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 177, xPicTop, yPicTop, 33, 58, 1	!custom_negrev_rev_top_win.png
						else
							ui_pict 178, xPicTop, yPicTop, 33, 58, 1	!custom_negrev_rev_top_door.png
						endif
					else
						ui_pict 179, xPicTop, yPicTop, 33, 58, 1			!custom_negrev_rev_top_op.png
					endif

					ui_pict 77, xPicTop+33, yPicTop+24, 11, 10, 1		!ui_arrow_10_vm.png
					if bEnableUniformJambDepths & gs_reveal_uniform then
						ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19,yPicTop+23, 72, outfieldHeight
					else
						ui_infield "gs_reveal_double_innerTop",		xPicTop+33+19,yPicTop+19, 72,infieldHeight ui_tooltip stRevealClusureUITips[8]
					endif

					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
						if not(isEmptyOpening) then
							if isWindow then
								ui_pict 180, xPicBot, yPicBot, 33, 58, 1	!custom_negrev_rev_bot_win.png
							else
								ui_pict 181, xPicBot, yPicBot, 33, 58, 1	!custom_negrev_rev_bot_door.png
							endif
						else
							ui_pict 182, xPicBot, yPicBot, 33, 58, 1		!custom_negrev_rev_bot_op.png
						endif

						ui_pict 77, xPicBot+33, yPicBot+24, 11, 10, 1		!ui_arrow_10_vm.png
						if bForceUniformBottomReveal then
							ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19, yPicBot+23, 72, outfieldHeight, 0
						else
							ui_infield "gs_reveal_double_innerBottom",	xPicTop+33+19, yPicBot+19, 72, infieldHeight ui_tooltip stRevealClusureUITips[9]
						endif
						ui_pict 21, xPicBot-11, yPicBot+32, 11, 10, 1		!ui_arrow_10_v.png
						if bForceUniformBottomReveal then
							ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicBot+31, 72, outfieldHeight, 1
						else
							ui_infield "gs_reveal_bottom", xPicBot-88, yPicBot+27, 72, infieldHeight ui_tooltip stRevealClusureUITips[7]
						endif
					endif
				endif

				if iBoardRevealType = REVEAL_NEGATIVE then
					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 183, xPic, yPic, 121, 33, 1	!custom_negrev_negrev_win.png
						else
							ui_pict 184, xPic, yPic, 121, 33, 1	!custom_negrev_negrev_door.png
						endif
					else
						ui_pict 185, xPic, yPic, 121, 33, 1	!custom_negrev_negrev_op.png
					endif
					ui_pict 44, xPic+16, yPic+33, 10, 11, 1			!ui_arrow_10_m.png
					ui_pict 44, xPic+95, yPic+33, 10, 11, 1			!ui_arrow_10_m.png

					gosub "customInnerNegRevealParamaters"

					if not(isEmptyOpening) then
						if isWindow then
							ui_pict 186, xPicTop, yPicTop, 33, 58, 1	!custom_negrev_negrev_top_win.png
						else
							ui_pict 187, xPicTop, yPicTop, 33, 58, 1	!custom_negrev_negrev_top_door.png
						endif
					else
						ui_pict 188, xPicTop, yPicTop, 33, 58, 1			!custom_negrev_negrev_top_op.png
					endif

					ui_pict 77, xPicTop+33, yPicTop+16, 11, 10, 1		!ui_arrow_10_vm.png
					if bEnableUniformJambDepths & gs_reveal_uniform then
						ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19,yPicTop+15, 72, outfieldHeight
					else
						ui_infield "gs_reveal_double_innerTop",		xPicTop+33+19,yPicTop+11, 72, infieldHeight ui_tooltip stRevealClusureUITips[8]
					endif

					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
						if not(isEmptyOpening) then
							if isWindow then
								ui_pict 189, xPicBot, yPicBot, 33, 58, 1	!custom_negrev_negrev_bot_win.png
							else
								ui_pict 190, xPicBot, yPicBot, 33, 58, 1	!custom_negrev_negrev_bot_door.png
							endif
						else
							ui_pict 191, xPicBot, yPicBot, 33, 58, 1		!custom_negrev_negrev_bot_op.png
						endif

						ui_pict 77, xPicBot+33, yPicBot+32, 11, 10, 1		!ui_arrow_10_vm.png
						if bForceUniformBottomReveal then
							ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPicTop+33+19, yPicBot+31, 72, outfieldHeight, 0
						else
							ui_infield "gs_reveal_double_innerBottom",	xPicTop+33+19, yPicBot+27, 72, infieldHeight ui_tooltip stRevealClusureUITips[9]
						endif
						ui_pict 21, xPicBot-11, yPicBot+32, 11, 10, 1		!ui_arrow_10_v.png
						if bForceUniformBottomReveal then
							ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicBot+31, 72, outfieldHeight, 1
						else
							ui_infield "gs_reveal_bottom", xPicBot-88, yPicBot+27, 72, infieldHeight	ui_tooltip stRevealClusureUITips[7]
						endif
					endif
				endif
			endif

			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
				gosub "bottomPositiveReveal"
			else
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					gosub "bottomNoReveal"
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
						gosub "bottomNegativeReveal"
					endif
				endif
			endif
		endif
	endif

! Double Splayed Reveal --------------------------------------------------------

	if iRevealType  = REVEAL_DOUBLE_SPLAYED then

		MFrame_flag = 0
		if not(gs_mountingFrame) then MFrame_flag = 4

			ui_style 0, 1
			ui_outfield stWallholeCutUI[17], x1, yRevealText, 320, 17

			yCurr = y0

			if bEnableMountingFrameForReveal then
				ui_infield{3} "gs_mountingFrame", x1, yCurr-infieldElevation, x3-x1-2, 20,
						7, "",
						2,
						1, 20, 20, 20, 20,
						0, stWallholeCutUI[21], 0,	! Mounting Frame
						1, stWallholeCutUI[21], 1	! Mounting Frame
			endif
			ui_style 0,0

			bDefaultElem = (GLOB_INTGUID = "" | GLOB_INTGUID = "{00000000-0000-0000-0000-000000000000}")
			flag = 4 * (not(bDefaultElem) & (bInclinedWall | AC_WallType = 2 | ac_wall_crosssection_type = 3 | ac_wall_crosssection_type = 4))

			ui_outfield stWallholeCutUI[22], x3, yCurr, x4-x3-2, 15, flag
			ui_infield{3}	"gs_reveal_angle_edit_by_int",	x4, yCurr-infieldElevation, x5-x4, 20,
					8, "", 3, 1, 0, 0, 0, 0,
					1, stWallholeCutUI[29], 1,	! Angle and Depth
					2, stWallholeCutUI[30], 2	! Width and Depth

			if gs_reveal_angle_edit_by_int = 1 then
				x_pict_w	= 15
				y_pict_w	= 142 + pageStartY
				x_pict_h	= 340
				y_pict_h	= 100 + pageStartY


				ui_pict 56, x_pict_w+2, y_pict_w-25-1, 19, 25, 1			!ui_angle_5.png
				ui_pict 57, x_pict_w+176-31, y_pict_w-25-1, 19, 25, 1		!ui_angle_6.png
				ui_pict 58, x_pict_w+24, y_pict_w-12, 12, 12, 1				!ui_arrow_h_12.png
				ui_pict 58, x_pict_w+130, y_pict_w-12, 12, 12, 1			!ui_arrow_h_12.png

				ui_pict 9, x_pict_h+42+1, y_pict_h+129-20, 25, 19, 1			!ui_angle_3.png
				ui_pict 8, x_pict_h+42+1, y_pict_h, 25, 19, 1					!ui_angle_4.png
				ui_pict 59, x_pict_h-25-1, y_pict_h+129-20, 25, 19, 1			!ui_angle_7.png
				ui_pict 60, x_pict_h-25-1, y_pict_h, 25, 19, 1					!ui_angle_8.png
				ui_pict 10, x_pict_h-17, y_pict_h+23, 17, 12, 1					!ui_arrow_v_12.png
				ui_pict 61, x_pict_h-17, y_pict_h+94, 17, 11, 1					!ui_arrow_v_11.png

				ui_infield "gs_reveal_left_angle",	x_pict_w-10,	y_pict_w+70, 60,18 ui_tooltip stRevealClusureUITips[10]
				ui_infield "gs_reveal_right_angle",	x_pict_w+144,	y_pict_w+70, 60,18 ui_tooltip stRevealClusureUITips[11]
				ui_infield "gs_reveal_outerLeft_angle",	x_pict_w-10,	y_pict_w-50, 60,18 ui_tooltip stRevealClusureUITips[14]
				ui_infield "gs_reveal_outerRight_angle",	x_pict_w+144,	y_pict_w-50, 60,18 ui_tooltip stRevealClusureUITips[15]

				ui_infield "gs_reveal_top_angle",	x_pict_h+42+3,	y_pict_h+24, 58,18 ui_tooltip stRevealClusureUITips[12]
				ui_infield "gs_reveal_bottom_angle",	x_pict_h+42+3,	y_pict_h+129-41, 58,18 ui_tooltip stRevealClusureUITips[13]
				ui_infield "gs_reveal_outerTop_angle",	x_pict_h-25-60-2,	y_pict_h, 60,18 ui_tooltip stRevealClusureUITips[16]
				ui_infield "gs_reveal_outerBottom_angle",	x_pict_h-25-60-2,	y_pict_h+129-19, 60,18 ui_tooltip stRevealClusureUITips[17]

				ui_infield "gs_wido_sill", x_pict_w+176+3, y_pict_w+2, 60, 20 ui_tooltip stRevealClusureUITips[1]
				ui_infield "gs_reveal_outer_jamb_depth", x_pict_w+176+3, y_pict_w+25, 60, 20 ui_tooltip stRevealClusureUITips[18]


				if gs_mountingFrame then
					!floor plan
					ui_pict 46, x_pict_w, y_pict_w, 176, 68, 1		!ui_reveal_doublesplayed_withBF_plan.png

					ui_infield "gs_mountingFrame_width_right",		x_pict_w+85,	y_pict_w-33, 55,20 ui_tooltip stRevealClusureUITips[20]
					ui_infield "gs_mountingFrame_width_left",		x_pict_w+25,	y_pict_w-33, 55,20 ui_tooltip stRevealClusureUITips[19]
					ui_infield "gs_mountingFrame_depth", 			x_pict_w+64, 	y_pict_w+70, 65,18 ui_tooltip stRevealClusureUITips[23]

					!section
					ui_pict 47, x_pict_h, y_pict_h, 42, 129, 1		!ui_reveal_doublesplayed_withBF_sect.png

					ui_infield "gs_mountingFrame_width_top",		x_pict_h-60-17-3, y_pict_h+19, 60, 20 ui_tooltip stRevealClusureUITips[21]
					ui_infield "gs_mountingFrame_width_bottom",		x_pict_h-60-17-3, y_pict_h+129-39, 60, 20 ui_tooltip stRevealClusureUITips[22]
				else
					!floor plan
					ui_pict 48, x_pict_w, y_pict_w, 176, 68, 1		!ui_reveal_doublesplayed_woutBF_plan.png

					ui_infield "gs_reveal_right",		x_pict_w+85,	y_pict_w-33, 55,20 ui_tooltip stRevealClusureUITips[3]
					ui_infield "gs_reveal_left",		x_pict_w+25,	y_pict_w-33, 55,20 ui_tooltip stRevealClusureUITips[2]

					!section
					ui_pict 49, x_pict_h, y_pict_h, 42, 129, 1		!ui_reveal_doublesplayed_woutBF_sect.png

					ui_infield "gs_reveal_top",		x_pict_h-60-17-3, y_pict_h+19, 60, 20 ui_tooltip stRevealClusureUITips[6]
					ui_infield "gs_reveal_bottom",	x_pict_h-60-17-3, y_pict_h+129-39, 60, 20 ui_tooltip stRevealClusureUITips[7]
				endif
			else
				x_pict_w	= 15
				y_pict_w	= 122 + pageStartY
				x_pict_h	= 314
				y_pict_h	= 100 + pageStartY

				ui_pict 86, x_pict_w+9, y_pict_w+72, 1, 20, 1			!dotted_line.png
				ui_pict 86, x_pict_w+154, y_pict_w+72, 1, 20, 1			!dotted_line.png

				ui_infield "gs_reveal_innerLeft_width",		x_pict_w-13,	y_pict_w+96, 60,18 ui_tooltip stRevealClusureUITips[24]
				ui_infield "gs_reveal_innerRight_width",	x_pict_w+135,	y_pict_w+96, 60,18 ui_tooltip stRevealClusureUITips[25]
				ui_infield "gs_reveal_outerLeft_width",		x_pict_w-13,	y_pict_w-24, 60,20 ui_tooltip stRevealClusureUITips[28]
				ui_infield "gs_reveal_outerRight_width",	x_pict_w+129,	y_pict_w-24, 60,20 ui_tooltip stRevealClusureUITips[29]

				ui_infield "gs_reveal_innerTop_width",		x_pict_h+70,	y_pict_h-6, 58,18 ui_tooltip stRevealClusureUITips[26]
				ui_infield "gs_reveal_innerBottom_width",	x_pict_h+70,	y_pict_h+116, 58,18 ui_tooltip stRevealClusureUITips[27]

				ui_infield "gs_wido_sill", 					x_pict_w+176+3, y_pict_w+14, 60, 20 ui_tooltip stRevealClusureUITips[1]
				ui_infield "gs_reveal_outer_jamb_depth", 	x_pict_w+176+3, y_pict_w+37, 60, 20 ui_tooltip stRevealClusureUITips[18]


				if gs_mountingFrame then
					!floor plan
					ui_pict 78, x_pict_w, y_pict_w, 175, 72, 1		!ui_reveal_doublesplayed_withBF_plan_width.png

					ui_infield "gs_mountingFrame_width_right",		x_pict_w+90,	y_pict_w+74, 60,20 ui_tooltip stRevealClusureUITips[20]
					ui_infield "gs_mountingFrame_width_left",		x_pict_w+20,	y_pict_w+74, 60,20 ui_tooltip stRevealClusureUITips[19]
					ui_infield "gs_mountingFrame_depth", 			x_pict_w+59, 	y_pict_w-24, 60,20 ui_tooltip stRevealClusureUITips[23]

					!section
					ui_pict 79, x_pict_h, y_pict_h, 67, 129, 1		!ui_reveal_doublesplayed_withBF_sect_width.png

					ui_infield "gs_mountingFrame_width_top",		x_pict_h+70, y_pict_h+19, 58, 20 ui_tooltip stRevealClusureUITips[21]
					ui_infield "gs_mountingFrame_width_bottom",		x_pict_h+70, y_pict_h+89, 58, 20 ui_tooltip stRevealClusureUITips[22]

					ui_infield "gs_reveal_outerTop_width",			x_pict_h-63,	y_pict_h+12, 60,18 ui_tooltip stRevealClusureUITips[30]
					ui_infield "gs_reveal_outerBottom_width",		x_pict_h-63,	y_pict_h+102, 60,18 ui_tooltip stRevealClusureUITips[31]
				else
					!floor plan
					ui_pict 80, x_pict_w, y_pict_w, 175, 72, 1		!ui_reveal_doublesplayed_woutBF_plan_width.png

					ui_infield "gs_reveal_right",					x_pict_w+90,	y_pict_w+74, 55,20 ui_tooltip stRevealClusureUITips[3]
					ui_infield "gs_reveal_left",					x_pict_w+20,	y_pict_w+74, 55,20 ui_tooltip stRevealClusureUITips[2]

					!section
					ui_pict 81, x_pict_h, y_pict_h, 67, 129, 1		!ui_reveal_doublesplayed_woutBF_sect_width.png

					ui_infield "gs_reveal_top",						x_pict_h+70, y_pict_h+19, 58, 20 ui_tooltip stRevealClusureUITips[6]
					ui_infield "gs_reveal_bottom",					x_pict_h+70, y_pict_h+89, 58, 20 ui_tooltip stRevealClusureUITips[7]

					ui_infield "gs_reveal_outerTop_width",			x_pict_h-63,	y_pict_h+17, 60,18 ui_tooltip stRevealClusureUITips[30]
					ui_infield "gs_reveal_outerBottom_width",		x_pict_h-63,	y_pict_h+97, 60,18 ui_tooltip stRevealClusureUITips[31]
				endif
			endif

	endif

! Outside Splayed Reveal -------------------------------------------------------

	if iRevealType  = REVEAL_OUTSIDE_SPLAYED then
		y = 45 + pageStartY
		x = 2

		MFrame_flag = 0
		if not(gs_mountingFrame) then MFrame_flag = 4

			ui_style 0, 1
			ui_outfield stWallholeCutUI[19], x, yRevealText, 320, 17

			yCurr = y0

			if bEnableMountingFrameForReveal then
				ui_infield{3} "gs_mountingFrame", x1, yCurr-infieldElevation, x3-x1-2, 20,
						7, "",
						2,
						1, 20, 20, 20, 20,
						0, stWallholeCutUI[21], 0,	! Mounting Frame
						1, stWallholeCutUI[21], 1	! Mounting Frame
			endif
			ui_style 0,0

			bDefaultElem = (GLOB_INTGUID = "" | GLOB_INTGUID = "{00000000-0000-0000-0000-000000000000}")
			flag = 4 * (not(bDefaultElem) & (bInclinedWall | AC_WallType = 2 | ac_wall_crosssection_type = 3 | ac_wall_crosssection_type = 4))

			ui_outfield stWallholeCutUI[22], x3, yCurr, x4-x3-2, 15, flag
			ui_infield{3}	"gs_reveal_angle_edit_by_int",	x4, yCurr-infieldElevation, x5-x4, 20,
					8, "", 3, 1, 0, 0, 0, 0,
					1, stWallholeCutUI[29], 1,	! Angle and Depth
					2, stWallholeCutUI[30], 2	! Width and Depth

			if gs_reveal_angle_edit_by_int = 1 then
				x_pict_w	= 15
				y_pict_w	= 142 + pageStartY
				x_pict_h	= 340
				y_pict_h	= 100 + pageStartY


				ui_pict 56, x_pict_w+2, y_pict_w-25-1, 19, 25, 1			!ui_angle_5.png
				ui_pict 57, x_pict_w+176-31, y_pict_w-25-1, 19, 25, 1		!ui_angle_6.png
				ui_pict 74, x_pict_w+24, y_pict_w-12, 11, 12, 1				!ui_arrow_h_11.png
				ui_pict 74, x_pict_w+129, y_pict_w-12, 11, 12, 1			!ui_arrow_h_11.png

				ui_pict 59, x_pict_h-25-1, y_pict_h+129-20, 25, 19, 1			!ui_angle_7.png
				ui_pict 60, x_pict_h-25-1, y_pict_h, 25, 19, 1					!ui_angle_8.png
				if gs_mountingFrame then
					ui_pict 61, x_pict_h-17, y_pict_h+24, 17, 11, 1					!ui_arrow_v_11.png
				else
					ui_pict 10, x_pict_h-17, y_pict_h+23, 17, 12, 1					!ui_arrow_v_12.png
				endif
				ui_pict 61, x_pict_h-17, y_pict_h+94, 17, 11, 1					!ui_arrow_v_11.png

				ui_infield "gs_reveal_outerLeft_angle",	x_pict_w-10,	y_pict_w-50, 60,18 ui_tooltip stRevealClusureUITips[14]
				ui_infield "gs_reveal_outerRight_angle",	x_pict_w+144,	y_pict_w-50, 60,18 ui_tooltip stRevealClusureUITips[15]

				ui_infield "gs_reveal_outerTop_angle",	x_pict_h-25-60-2,	y_pict_h, 60,18 ui_tooltip stRevealClusureUITips[16]
				ui_infield "gs_reveal_outerBottom_angle",	x_pict_h-25-60-2,	y_pict_h+129-19, 60,18 ui_tooltip stRevealClusureUITips[17]

				ui_infield "gs_wido_sill", x_pict_w+176+3, y_pict_w+2, 60, 20 ui_tooltip stRevealClusureUITips[1]
				ui_infield "gs_reveal_outer_jamb_depth", x_pict_w+176+3, y_pict_w+25, 60, 20 ui_tooltip stRevealClusureUITips[18]



				if gs_mountingFrame then
					!floor plan
					ui_pict 50, x_pict_w, y_pict_w, 175, 50, 1		!ui_reveal_outsidesplayed_withBF_plan.png

					ui_infield "gs_mountingFrame_width_right",		x_pict_w+85,	y_pict_w-33, 55,20 ui_tooltip stRevealClusureUITips[20]
					ui_infield "gs_mountingFrame_width_left",		x_pict_w+25,	y_pict_w-33, 55,20 ui_tooltip stRevealClusureUITips[19]
					ui_infield "gs_mountingFrame_depth", 			x_pict_w+60, 	y_pict_w+56, 65,18 ui_tooltip stRevealClusureUITips[23]

					!section
					ui_pict 51, x_pict_h, y_pict_h, 42, 129, 1		!ui_reveal_outsidesplayed_withBF_sect.png

					ui_infield "gs_mountingFrame_width_top",		x_pict_h-60-17-3, y_pict_h+19, 60, 20 ui_tooltip stRevealClusureUITips[21]
					ui_infield "gs_mountingFrame_width_bottom",		x_pict_h-60-17-3, y_pict_h+129-39, 60, 20 ui_tooltip stRevealClusureUITips[22]
				else
					!floor plan
					ui_pict 52, x_pict_w, y_pict_w, 175, 42, 1		!ui_reveal_outsidesplayed_woutBF_plan.png

					ui_infield "gs_reveal_right",		x_pict_w+85,	y_pict_w-33, 55,20 ui_tooltip stRevealClusureUITips[3]
					ui_infield "gs_reveal_left",		x_pict_w+25,	y_pict_w-33, 55,20 ui_tooltip stRevealClusureUITips[2]

					!section
					ui_pict 53, x_pict_h, y_pict_h, 42, 129, 1		!ui_reveal_outsidesplayed_woutBF_sect.png

					ui_infield "gs_reveal_top",		x_pict_h-60-17-3, y_pict_h+19, 60, 20 ui_tooltip stRevealClusureUITips[6]
					ui_infield "gs_reveal_bottom",	x_pict_h-60-17-3, y_pict_h+129-39, 60, 20 ui_tooltip stRevealClusureUITips[7]
				endif
			else
				x_pict_w	= 15
				y_pict_w	= 122 + pageStartY
				x_pict_h	= 314
				y_pict_h	= 100 + pageStartY

				ui_infield "gs_reveal_outerLeft_width",		x_pict_w-13,	y_pict_w-24, 60,20 ui_tooltip stRevealClusureUITips[28]
				ui_infield "gs_reveal_outerRight_width",	x_pict_w+129,	y_pict_w-24, 60,20 ui_tooltip stRevealClusureUITips[29]

				ui_infield "gs_wido_sill", 					x_pict_w+176+3, y_pict_w+14, 60, 20 ui_tooltip stRevealClusureUITips[1]
				ui_infield "gs_reveal_outer_jamb_depth", 	x_pict_w+176+3, y_pict_w+37, 60, 20 ui_tooltip stRevealClusureUITips[18]

				if gs_mountingFrame then
					!floor plan
					ui_pict 82, x_pict_w, y_pict_w, 175, 71, 1		!ui_reveal_outsidesplayed_withBF_plan_width.png

					ui_infield "gs_mountingFrame_width_right",		x_pict_w+116,	y_pict_w+74, 60,20 ui_tooltip stRevealClusureUITips[20]
					ui_infield "gs_mountingFrame_width_left",		x_pict_w+13,	y_pict_w+74, 60,20 ui_tooltip stRevealClusureUITips[19]
					ui_infield "gs_mountingFrame_depth", 			x_pict_w+59, 	y_pict_w-24, 60,20 ui_tooltip stRevealClusureUITips[23]

					!section
					ui_pict 83, x_pict_h, y_pict_h, 67, 129, 1		!ui_reveal_outsidesplayed_withBF_sect_width.png

					ui_infield "gs_mountingFrame_width_top",		x_pict_h+70, y_pict_h+19, 58, 20 ui_tooltip stRevealClusureUITips[21]
					ui_infield "gs_mountingFrame_width_bottom",		x_pict_h+70, y_pict_h+89, 58, 20 ui_tooltip stRevealClusureUITips[22]

					ui_infield "gs_reveal_outerTop_width",			x_pict_h-63,	y_pict_h+8, 60,18 ui_tooltip stRevealClusureUITips[30]
					ui_infield "gs_reveal_outerBottom_width",		x_pict_h-63,	y_pict_h+106, 60,18 ui_tooltip stRevealClusureUITips[31]
				else
					!floor plan
					ui_pict 84, x_pict_w, y_pict_w, 175, 71, 1		!ui_reveal_outsidesplayed_woutBF_plan_width.png

					ui_infield "gs_reveal_right",					x_pict_w+116,	y_pict_w+74, 60,20 ui_tooltip stRevealClusureUITips[3]
					ui_infield "gs_reveal_left",					x_pict_w+13,	y_pict_w+74, 60,20 ui_tooltip stRevealClusureUITips[2]

					!section
					ui_pict 85, x_pict_h, y_pict_h, 67, 129, 1		!ui_reveal_outsidesplayed_woutBF_sect_width.png

					ui_infield "gs_reveal_top",						x_pict_h+70, 	y_pict_h+19, 58, 20 ui_tooltip stRevealClusureUITips[6]
					ui_infield "gs_reveal_bottom",					x_pict_h+70, 	y_pict_h+89, 58, 20 ui_tooltip stRevealClusureUITips[7]

					ui_infield "gs_reveal_outerTop_width",			x_pict_h-63,	y_pict_h+17, 60,18 ui_tooltip stRevealClusureUITips[30]
					ui_infield "gs_reveal_outerBottom_width",		x_pict_h-63,	y_pict_h+100, 60,18 ui_tooltip stRevealClusureUITips[31]
				endif
			endif

	endif

endif


! ==============================================================================
! Wall Inset tabpage
! ==============================================================================

if bWallInsetPage & isWindow then

	pageStartY = 5

	y = pageStartY
	dy = 25
	x1 = 5
	x2 = 190
	x3 = 225
	x4 = 440

	ui_style 0,1
	ui_infield{3} "gs_parapet_wall_inset", x1, y-4, x4-x1-1, 19,
				7, "",
				2,
				1, 20, 20, 20, 20,
				0, stWallholeCutUI[3], 0,		! Wall Inset
				1, stWallholeCutUI[3], 1		! Wall Inset

	y = y + dy

	ui_style 0,0

	bFlag = not (gs_parapet_wall_inset)
	iFlag = 4 * bFlag

	ui_outfield stWallholeCutUI[14], x1, y, x2-x1-1, 15, iFlag		! Wall Inset Sizes
	ui_infield{3}	"iParapetSize", x2, y-4, 120, 19,
			8, "", 3, 1,
			0, 0, 0, 0,
			1, stParapetSize[1], PARAPET_SIZE_AUTO,
			2, stParapetSize[2], PARAPET_SIZE_SYMM,
			3, stParapetSize[3], PARAPET_SIZE_ASYMM

	bFlag = not (gs_parapet_wall_inset & gs_parapet_2D)
	iFlag = 4 * bFlag

	ui_separator 326, y-9, 326, 185


	y = pageStartY + 82

	bFlag = not (gs_parapet_wall_inset)
	iFlag = 4 * bFlag

	ui_outfield stWallholeCutUI[10], x1, y + 7, 125, 15, iFlag		! Wall Inset Bottom at:
	ui_infield{3}	"iParapetBottom", x1, y + 27, 120, 19,
			8, "", 3, 1,
			0, 0, 0, 0,
			1, stParapetBottom[1], PARAPET_BOTTOM_CURRENTSTORY,
			2, stParapetBottom[2], PARAPET_BOTTOM_WALLBASE

	if iParapetSize = PARAPET_SIZE_ASYMM then
		ui_pict 24, x1+130, y-15, 80, 70, 1		! ui_wallinset_front_asymm
		ui_infield "gs_parapet_left",	x1+89,  y+62,	90, 19	ui_tooltip stWallholeCutUI[15]		! Overhang Side 2
		ui_infield "gs_parapet_right",	x1+183, y+62,	90, 19	ui_tooltip stWallholeCutUI[16]		! Overhang Side 1
	else
		if iParapetSize = PARAPET_SIZE_SYMM then
			ui_pict 25, x1+130, y-15, 80, 70, 1		! ui_wallinset_front_sym
			ui_infield "gs_parapet_width",	x1+142, y+62,	90, 19	ui_tooltip stWallholeCutUI[11]	! Width of Wall Inset
		else
			ui_pict 22, x1+130, y-15, 80, 70, 1		! ui_wallinset_front
		endif
	endif

	if iParapetSize <> PARAPET_SIZE_AUTO then
		ui_infield "gs_parapet_height",	x1+215, y+12,	90, 19	ui_tooltip stWallholeCutUI[12]		! Height of Wall Inset
	endif

	ui_infield "gs_parapet_botelev",	x1+215, y+36,	90, 19	ui_tooltip stWallholeCutUI[13]		! Bottom Elevation

	ui_pict 23, x3+119, y-15, 61, 76, 1	! ui_wallinset_section

	ui_infield "gs_parapet_inset_thk",	x3+122, y+62,	90, 19	ui_tooltip stWallholeCutUI[4]		! Depth of Wall Inset

	y = pageStartY + 184

	ui_separator 0, y, 444, y

	y = y + 20

	ui_infield{3} "gs_parapet_2D", x1, y, 280, 15,
				7, "",
				2,
				1, 20, 20, 20, 20,
				0, stWallholeCutUI[7], 0,		! Show Hidden Parapet on 2D
				1, stWallholeCutUI[7], 1		! Show Hidden Parapet on 2D

	y = y + dy

	ui_outfield stWallholeCutUI[9], x1, y, 184, 15, iFlag		! Hidden Parapet Line Type
	ui_infield "gs_parapet_line", 190, y, x4-x3-40, 25

endif

! ==================================================================================================
end
! ==================================================================================================

"ui of t shape":
	ui_pict 95, xPic+122, yPic-10, 13, 21, 1	! ui_arrow_v_21.png
	ui_infield "gs_wido_sill", xPic+90, yPic-30, 72, infieldHeight ui_tooltip stRevealClusureUITips[1]

	bNegativeView = 0
	if iRevealType = REVEAL_POSITIVE then
		bNegativeView = 0
		gs_reveal_set_side = REVEAL_SET_OUTSIDE
		ui_pict 15, xPic, yPic, 121, 33, 1		!reveal_door.png
	endif

	if iRevealType = REVEAL_NEGATIVE then
		bNegativeView = 1
		gs_reveal_set_side = REVEAL_SET_OUTSIDE
		ui_pict 106, xPic, yPic, 121, 33, 1	!negative_reveal_door.png
	endif

	if iRevealType = REVEAL_DOUBLE then
		if iSillRevealType = REVEAL_NO then
			gs_reveal_set_side = REVEAL_SET_INSIDE
		endif
		if iBoardRevealType = REVEAL_NO then
			gs_reveal_set_side = REVEAL_SET_OUTSIDE
		endif

		bRevealSetSide = 1
		if iSillRevealType = REVEAL_NO then
			bRevealSetSide = 0
			if iBoardRevealType = REVEAL_NO then
				ui_pict 2, xPic, yPic, 121, 33, 1		!no_reveal_door.png
				gosub "noRevealPicsVertical"

				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
					gosub "bottomPositiveReveal"
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
						gosub "bottomNegativeReveal"
					else
						gosub "bottomNoReveal"
					endif
				endif
				end
			endif

			if iBoardRevealType = REVEAL_POSITIVE then
				bNegativeView = 1
				ui_pict 39, xPic, yPic, 121, 33, 1	!custom_norev_rev_door.png
			endif

			if iBoardRevealType = REVEAL_NEGATIVE then
				bNegativeView = 0
				ui_pict 160, xPic, yPic, 121, 33, 1	!custom_norev_negrev_door.png
			endif
		endif

		if iSillRevealType = REVEAL_POSITIVE then
			if iBoardRevealType = REVEAL_NO then
				bRevealSetSide = 0
				bNegativeView = 0
				ui_pict 15, xPic, yPic, 121, 33, 1	!reveal_door.png
			endif

			if iBoardRevealType = REVEAL_POSITIVE then
				if gs_reveal_set_side = REVEAL_SET_OUTSIDE then
					bNegativeView = 0
				else
					bNegativeView = 1
				endif
				ui_pict 27, xPic, yPic, 121, 33, 1	!custom_rev_rev_door.png
			endif

			if iBoardRevealType = REVEAL_NEGATIVE then
				bNegativeView = 0
				ui_pict 42, xPic, yPic, 121, 33, 1	!custom_rev_negrev_door.png
			endif
		endif

		if iSillRevealType = REVEAL_NEGATIVE then
			if iBoardRevealType = REVEAL_NO then
				bRevealSetSide = 0
				bNegativeView = 1
				ui_pict 106, xPic, yPic, 121, 33, 1	!negative_reveal_door.png
			endif

			if iBoardRevealType = REVEAL_POSITIVE then
				bNegativeView = 1
				ui_pict 175, xPic, yPic, 121, 33, 1	!custom_negrev_rev_door.png
			endif

			if iBoardRevealType = REVEAL_NEGATIVE then
				if gs_reveal_set_side = REVEAL_SET_OUTSIDE then
					bNegativeView = 1
				else
					bNegativeView = 0
				endif
				ui_pict 184, xPic, yPic, 121, 33, 1	!custom_negrev_negrev_door.png
			endif
		endif

		if bRevealSetSide then
			ui_outfield stWallholeCutUI[31], x2, yRevealText, x3-x2-2, 15	! Set Jamb Depth on
			ui_infield{3} "gs_reveal_set_side", x3, yRevealText-infieldElevation, x4-x3, 20,
					8, "",
					2,
					1, 20, 20, 20, 20,
					0, stSetRevealSide[1], REVEAL_SET_INSIDE,	! Inside
					1, stSetRevealSide[2], REVEAL_SET_OUTSIDE	! Outside
		endif
	endif

	cx		= 72
	picx	= 113
	picy	= 113
	x		= 254
	y		= 103 + pageStartY

	if iWindowShape = SHAPE_T then
		if (bRevealSetSide & gs_reveal_set_side = REVEAL_SET_INSIDE & gs_reveal_type_bottom_int <> REVEAL_BOTTOM_UNIFORM) then
			if not(bNegativeView) then
				ui_pict 87, x, y, picx, picy, 1	! T_Rev_BottNoRev.png
			endif

			if bNegativeView then
				ui_pict 90, x, y, picx, picy, 1	! T_NegRev_BottNoRev.png
			endif
		else
			if not(bNegativeView) then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 87, x, y, picx, picy, 1	! T_Rev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
						ui_pict 88, x, y, picx, picy, 1	! T_Rev_BottNegRev.png
					else
						ui_pict 89, x, y, picx, picy, 1	! T_Rev.png
					endif
				endif
			endif

			if bNegativeView then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 90, x, y, picx, picy, 1	! T_NegRev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
						ui_pict 91, x, y, picx, picy, 1	! T_NegRev_BottRev.png
					else
						ui_pict 92, x, y, picx, picy, 1	! T_NegRev_BottNegRev.png
					endif
				endif
			endif
		endif

		if gs_reveal_set_side = REVEAL_SET_OUTSIDE then
			if gs_reveal_type_bottom_int <> REVEAL_BOTTOM_NO then
				ui_infield "gs_reveal_bottom", x+34, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[7]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_infield "gs_reveal_right", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[40]
				n = request("Working_length_unit", "", formatt)
				ui_outfield str(formatt, abs(gs_reveal_top)), x+20, y-16, cx, outfieldHeight, 2
				ui_outfield str(formatt, abs(gs_reveal_left)), x-cx-4, y+41, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_left_sL)), x-cx-4, y+83, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_right_sR)), x+picx+5, y+86, cx, outfieldHeight, 0
				ui_outfield str(formatt, abs(gs_reveal_bottom_sL)), x+25-cx, y+picy+5, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_bottom_sR)), x+40+cx, y+picy+5, cx, outfieldHeight, 0
			else
				ui_infield "gs_reveal_top", x+32, y-20, cx, infieldHeight ui_tooltip stRevealClusureUITips[6]
				ui_infield "gs_reveal_right", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[3]
				ui_infield "gs_reveal_left", x-cx-2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[2]
				ui_infield "gs_reveal_left_sL", x-cx-2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[32]
				ui_infield "gs_reveal_right_sR", x+picx+2, y+82, cx, infieldHeight ui_tooltip stRevealClusureUITips[33]
				ui_infield "gs_reveal_bottom_sL", x+26-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[34]
				ui_infield "gs_reveal_bottom_sR", x+38+cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[35]
			endif
		else
			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
				ui_infield "gs_reveal_double_innerBottom", x+34, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[9]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_infield "gs_reveal_double_innerRight", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[41]
				n = request("Working_length_unit", "", formatt)
				ui_outfield str(formatt, abs(gs_reveal_double_innerTop)), x+20, y-16, cx, outfieldHeight, 2
				ui_outfield str(formatt, abs(gs_reveal_double_innerLeft)), x-cx-4, y+41, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_double_innerLeft_sL)), x-cx-4, y+83, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_double_innerRight_sR)), x+picx+5, y+86, cx, outfieldHeight, 0
				ui_outfield str(formatt, abs(gs_reveal_double_innerBottom_sL)), x+25-cx, y+picy+5, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_double_innerBottom_sR)), x+40+cx, y+picy+5, cx, outfieldHeight, 0
			else
				ui_infield "gs_reveal_double_innerTop", x+32, y-22, cx, infieldHeight ui_tooltip stRevealClusureUITips[8]
				ui_infield "gs_reveal_double_innerRight", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[5]
				ui_infield "gs_reveal_double_innerLeft", x-cx-2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[4]
				ui_infield "gs_reveal_double_innerLeft_sL", x-cx-2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[36]
				ui_infield "gs_reveal_double_innerRight_sR", x+picx+2, y+82, cx, infieldHeight ui_tooltip stRevealClusureUITips[37]
				ui_infield "gs_reveal_double_innerBottom_sL", x+26-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[38]
				ui_infield "gs_reveal_double_innerBottom_sR", x+38+cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[39]
			endif
		endif
	endif

	if iWindowShape = SHAPE_HALF_T_LEFT then
		if (bRevealSetSide & gs_reveal_set_side = REVEAL_SET_INSIDE & gs_reveal_type_bottom_int <> REVEAL_BOTTOM_UNIFORM) |\
			iSillRevealType = REVEAL_NO then
			if not(bNegativeView) then
				ui_pict 93, x, y, picx, picy, 1	! P_Rev_BottNoRev.png
			endif

			if bNegativeView then
				ui_pict 97, x, y, picx, picy, 1	! P_NegRev_BottNoRev.png
			endif
		else
			if not(bNegativeView) then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 93, x, y, picx, picy, 1	! P_Rev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
						ui_pict 94, x, y, picx, picy, 1	! P_Rev_BottNegRev.png
					else
						ui_pict 96, x, y, picx, picy, 1	! P_Rev.png
					endif
				endif
			endif

			if bNegativeView then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 97, x, y, picx, picy, 1	! P_NegRev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
						ui_pict 98, x, y, picx, picy, 1	! P_NegRev_BottRev.png
					else
						ui_pict 99, x, y, picx, picy, 1	! P_NegRev_BottNegRev.png
					endif
				endif
			endif
		endif

		if gs_reveal_set_side = REVEAL_SET_OUTSIDE then
			if gs_reveal_type_bottom_int <> REVEAL_BOTTOM_NO then
				ui_infield "gs_reveal_bottom", x+54, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[7]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_infield "gs_reveal_right", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[40]
				n = request("Working_length_unit", "", formatt)
				ui_outfield str(formatt, abs(gs_reveal_top)), x+20, y-16, cx, outfieldHeight, 2
				ui_outfield str(formatt, abs(gs_reveal_left)), x-cx-4, y+41, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_left_sL)), x-cx-4, y+83, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_bottom_sL)), x+35-cx, y+picy+5, cx, outfieldHeight, 1
			else
				ui_infield "gs_reveal_top", x+32, y-20, cx, infieldHeight ui_tooltip stRevealClusureUITips[6]
				ui_infield "gs_reveal_right", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[3]
				ui_infield "gs_reveal_left", x-cx-2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[2]
				ui_infield "gs_reveal_left_sL", x-cx-2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[32]
				ui_infield "gs_reveal_bottom_sL", x+50-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[34]
			endif
		else
			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
				ui_infield "gs_reveal_double_innerBottom", x+54, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[9]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_infield "gs_reveal_double_innerRight", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[41]
				n = request("Working_length_unit", "", formatt)
				ui_outfield str(formatt, abs(gs_reveal_double_innerTop)), x+20, y-16, cx, outfieldHeight, 2
				ui_outfield str(formatt, abs(gs_reveal_double_innerLeft)), x-cx-4, y+41, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_double_innerLeft_sL)), x-cx-4, y+83, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_double_innerBottom_sL)), x+35-cx, y+picy+5, cx, outfieldHeight, 1
			else
				ui_infield "gs_reveal_double_innerTop", x+32, y-22, cx, infieldHeight ui_tooltip stRevealClusureUITips[8]
				ui_infield "gs_reveal_double_innerRight", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[5]
				ui_infield "gs_reveal_double_innerLeft", x-cx-2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[4]
				ui_infield "gs_reveal_double_innerLeft_sL", x-cx-2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[36]
				ui_infield "gs_reveal_double_innerBottom_sL", x+50-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[38]
			endif
		endif
	endif

	if iWindowShape = SHAPE_HALF_T_RIGHT then
		if (bRevealSetSide & gs_reveal_set_side = REVEAL_SET_INSIDE & gs_reveal_type_bottom_int <> REVEAL_BOTTOM_UNIFORM) |\
			iSillRevealType = REVEAL_NO then
			if not(bNegativeView) then
				ui_pict 199, x, y, picx, picy, 1	! P_right_Rev_BottNoRev.png
			endif

			if bNegativeView then
				ui_pict 202, x, y, picx, picy, 1	! P_right_NegRev_BottNoRev.png
			endif
		else
			if not(bNegativeView) then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 199, x, y, picx, picy, 1	! P_right_Rev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
						ui_pict 200, x, y, picx, picy, 1	! P_right_Rev_BottNegRev.png
					else
						ui_pict 201, x, y, picx, picy, 1	! P_right_Rev.png
					endif
				endif
			endif

			if bNegativeView then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 202, x, y, picx, picy, 1	! P_right_NegRev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
						ui_pict 203, x, y, picx, picy, 1	! P_right_NegRev_BottRev.png
					else
						ui_pict 204, x, y, picx, picy, 1	! P_right_NegRev_BottNegRev.png
					endif
				endif
			endif
		endif

		if gs_reveal_set_side = REVEAL_SET_OUTSIDE then
			if gs_reveal_type_bottom_int <> REVEAL_BOTTOM_NO then
				ui_infield "gs_reveal_bottom", x+71-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[7]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_infield "gs_reveal_right", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[40]
				n = request("Working_length_unit", "", formatt)
				ui_outfield str(formatt, abs(gs_reveal_top)), x+20, y-16, cx, outfieldHeight, 2
				ui_outfield str(formatt, abs(gs_reveal_left)), x-cx-4, y+41, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_right_sR)), x+picx+2, y+83, cx, outfieldHeight, 0
				ui_outfield str(formatt, abs(gs_reveal_bottom_sR)), x+77, y+picy+5, cx, outfieldHeight, 0
			else
				ui_infield "gs_reveal_top", x+32, y-20, cx, infieldHeight ui_tooltip stRevealClusureUITips[6]
				ui_infield "gs_reveal_right", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[3]
				ui_infield "gs_reveal_left", x-cx-2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[2]
				ui_infield "gs_reveal_right_sR", x+picx+2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[33]
				ui_infield "gs_reveal_bottom_sR", x+54, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[35]
			endif
		else
			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
				ui_infield "gs_reveal_double_innerBottom", x+71-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[9]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_infield "gs_reveal_double_innerRight", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[41]
				n = request("Working_length_unit", "", formatt)
				ui_outfield str(formatt, abs(gs_reveal_double_innerTop)), x+20, y-16, cx, outfieldHeight, 2
				ui_outfield str(formatt, abs(gs_reveal_double_innerLeft)), x-cx-4, y+41, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_double_innerRight_sR)), x+picx+2, y+83, cx, outfieldHeight, 0
				ui_outfield str(formatt, abs(gs_reveal_double_innerBottom_sR)), x+8+cx, y+picy+5, cx, outfieldHeight, 0
			else
				ui_infield "gs_reveal_double_innerTop", x+32, y-22, cx, infieldHeight ui_tooltip stRevealClusureUITips[8]
				ui_infield "gs_reveal_double_innerRight", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[5]
				ui_infield "gs_reveal_double_innerLeft", x-cx-2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[4]
				ui_infield "gs_reveal_double_innerRight_sR", x+picx+2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[37]
				ui_infield "gs_reveal_double_innerBottom_sR", x+8+cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[39]
			endif
		endif
	endif

	if iWindowShape = SHAPE_ARCHED_T then
		if (bRevealSetSide & gs_reveal_set_side = REVEAL_SET_INSIDE & gs_reveal_type_bottom_int <> REVEAL_BOTTOM_UNIFORM) then
			if not(bNegativeView) then
				ui_pict 100, x, y, picx, picy, 1	! T_Seg_Rev_BottNoRev.png
			endif

			if bNegativeView then
				ui_pict 103, x, y, picx, picy, 1	! T_Seg_NegRev_BottNoRev.png
			endif
		else
			if not(bNegativeView) then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 100, x, y, picx, picy, 1	! T_Seg_Rev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
						ui_pict 101, x, y, picx, picy, 1	! T_Seg_Rev_BottNegRev.png
					else
						ui_pict 102, x, y, picx, picy, 1	! T_Seg_Rev.png
					endif
				endif
			endif

			if bNegativeView then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 103, x, y, picx, picy, 1	! T_Seg_NegRev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
						ui_pict 104, x, y, picx, picy, 1	! T_Seg_NegRev_BottRev.png
					else
						ui_pict 192, x, y, picx, picy, 1	! T_Seg_NegRev_BottNegRev.png
					endif
				endif
			endif
		endif

		n = request("Working_length_unit", "", formatt)
		if gs_reveal_set_side = REVEAL_SET_OUTSIDE then
			ui_outfield str(formatt, abs(gs_reveal_left)), x-cx-4, y+41, cx, outfieldHeight, 1
			ui_outfield str(formatt, abs(gs_reveal_top)), x+20, y-16, cx, outfieldHeight, 2
			ui_infield "gs_reveal_right", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[42]
			if gs_reveal_type_bottom_int <> REVEAL_BOTTOM_NO then
				ui_infield "gs_reveal_bottom", x+30, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[7]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_outfield str(formatt, abs(gs_reveal_left_sL)), x-cx-4, y+83, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_right_sR)), x+picx+5, y+86, cx, outfieldHeight, 0
				ui_outfield str(formatt, abs(gs_reveal_bottom_sL)), x+25-cx, y+picy+5, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_bottom_sR)), x+38+cx, y+picy+5, cx, outfieldHeight, 0
			else
				ui_infield "gs_reveal_left_sL", x-cx-2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[32]
				ui_infield "gs_reveal_right_sR", x+picx+2, y+82, cx, infieldHeight ui_tooltip stRevealClusureUITips[33]
				ui_infield "gs_reveal_bottom_sL", x+24-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[34]
				ui_infield "gs_reveal_bottom_sR", x+36+cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[35]
			endif
		else
			ui_outfield str(formatt, abs(gs_reveal_double_innerLeft)), x-cx-4, y+41, cx, outfieldHeight, 1
			ui_outfield str(formatt, abs(gs_reveal_double_innerTop)), x+20, y-16, cx, outfieldHeight, 2
			ui_infield "gs_reveal_double_innerRight", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[43]
			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
				ui_infield "gs_reveal_double_innerBottom", x+30, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[9]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_outfield str(formatt, abs(gs_reveal_double_innerLeft_sL)), x-cx-4, y+83, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_double_innerRight_sR)), x+picx+5, y+86, cx, outfieldHeight, 0
				ui_outfield str(formatt, abs(gs_reveal_double_innerBottom_sL)), x+25-cx, y+picy+5, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_double_innerBottom_sR)), x+38+cx, y+picy+5, cx, outfieldHeight, 0
			else
				ui_infield "gs_reveal_double_innerLeft_sL", x-cx-2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[36]
				ui_infield "gs_reveal_double_innerRight_sR", x+picx+2, y+82, cx, infieldHeight ui_tooltip stRevealClusureUITips[37]
				ui_infield "gs_reveal_double_innerBottom_sL", x+24-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[38]
				ui_infield "gs_reveal_double_innerBottom_sR", x+36+cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[39]
			endif
		endif
	endif

	if iWindowShape = SHAPE_ARCHED_HALF_T_LEFT then
		if (bRevealSetSide & gs_reveal_set_side = REVEAL_SET_INSIDE & gs_reveal_type_bottom_int <> REVEAL_BOTTOM_UNIFORM) |\
			iSillRevealType = REVEAL_NO then
			if not(bNegativeView) then
				ui_pict 193, x, y, picx, picy, 1	! P_Seg_Rev_BottNoRev.png
			endif

			if bNegativeView then
				ui_pict 196, x, y, picx, picy, 1	! P_Seg_NegRev_BottNoRev.png
			endif
		else
			if not(bNegativeView) then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 193, x, y, picx, picy, 1	! P_Seg_Rev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
						ui_pict 194, x, y, picx, picy, 1	! P_Seg_Rev_BottNegRev.png
					else
						ui_pict 195, x, y, picx, picy, 1	! P_Seg_Rev.png
					endif
				endif
			endif

			if bNegativeView then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 196, x, y, picx, picy, 1	! P_Seg_NegRev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
						ui_pict 197, x, y, picx, picy, 1	! P_Seg_NegRev_BottRev.png
					else
						ui_pict 198, x, y, picx, picy, 1	! P_Seg_NegRev_BottNegRev.png
					endif
				endif
			endif
		endif

		n = request("Working_length_unit", "", formatt)
		if gs_reveal_set_side = REVEAL_SET_OUTSIDE then
			ui_outfield str(formatt, abs(gs_reveal_left)), x-cx-4, y+41, cx, outfieldHeight, 1
			ui_outfield str(formatt, abs(gs_reveal_top)), x+20, y-16, cx, outfieldHeight, 2
			ui_infield "gs_reveal_right", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[42]
			if gs_reveal_type_bottom_int <> REVEAL_BOTTOM_NO then
				ui_infield "gs_reveal_bottom", x+54, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[7]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				n = request("Working_length_unit", "", formatt)
				ui_outfield str(formatt, abs(gs_reveal_left_sL)), x-cx-4, y+83, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_bottom_sL)), x+33-cx, y+picy+5, cx, outfieldHeight, 1
			else
				ui_infield "gs_reveal_left_sL", x-cx-2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[32]
				ui_infield "gs_reveal_bottom_sL", x+50-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[34]
			endif
		else
			ui_outfield str(formatt, abs(gs_reveal_double_innerLeft)), x-cx-4, y+41, cx, outfieldHeight, 1
			ui_outfield str(formatt, abs(gs_reveal_double_innerTop)), x+20, y-19, cx, outfieldHeight, 2
			ui_infield "gs_reveal_double_innerRight", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[43]
			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
				ui_infield "gs_reveal_double_innerBottom", x+54, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[9]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_outfield str(formatt, abs(gs_reveal_double_innerLeft_sL)), x-cx-4, y+83, cx, outfieldHeight, 1
				ui_outfield str(formatt, abs(gs_reveal_double_innerBottom_sL)), x+33-cx, y+picy+5, cx, outfieldHeight, 1
			else
				ui_infield "gs_reveal_double_innerLeft_sL", x-cx-2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[36]
				ui_infield "gs_reveal_double_innerBottom_sL", x+50-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[38]
			endif
		endif
	endif

	if iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then
		if (bRevealSetSide & gs_reveal_set_side = REVEAL_SET_INSIDE & gs_reveal_type_bottom_int <> REVEAL_BOTTOM_UNIFORM) |\
			iSillRevealType = REVEAL_NO then
			if not(bNegativeView) then
				ui_pict 205, x, y, picx, picy, 1	! P_right_Seg_Rev_BottNoRev.png
			endif

			if bNegativeView then
				ui_pict 208, x, y, picx, picy, 1	! P_right_Seg_NegRev_BottNoRev.png
			endif
		else
			if not(bNegativeView) then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 205, x, y, picx, picy, 1	! P_right_Seg_Rev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NEGATIVE then
						ui_pict 206, x, y, picx, picy, 1	! P_right_Seg_Rev_BottNegRev.png
					else
						ui_pict 207, x, y, picx, picy, 1	! P_right_Seg_Rev.png
					endif
				endif
			endif

			if bNegativeView then
				if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
					ui_pict 208, x, y, picx, picy, 1	! P_right_Seg_NegRev_BottNoRev.png
				else
					if gs_reveal_type_bottom_int = REVEAL_BOTTOM_POSITIVE then
						ui_pict 209, x, y, picx, picy, 1	! P_right_Seg_NegRev_BottRev.png
					else
						ui_pict 210, x, y, picx, picy, 1	! P_right_Seg_NegRev_BottNegRev.png
					endif
				endif
			endif
		endif

		n = request("Working_length_unit", "", formatt)
		if gs_reveal_set_side = REVEAL_SET_OUTSIDE then
			ui_outfield str(formatt, abs(gs_reveal_left)), x-cx-4, y+41, cx, outfieldHeight, 1
			ui_outfield str(formatt, abs(gs_reveal_top)), x+20, y-16, cx, outfieldHeight, 2
			ui_infield "gs_reveal_right", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[42]
			if gs_reveal_type_bottom_int <> REVEAL_BOTTOM_NO then
				ui_infield "gs_reveal_bottom", x+71-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[7]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				n = request("Working_length_unit", "", formatt)
				ui_outfield str(formatt, abs(gs_reveal_right_sR)), x+picx+2, y+83, cx, outfieldHeight, 0
				ui_outfield str(formatt, abs(gs_reveal_bottom_sR)), x+77, y+picy+5, cx, outfieldHeight, 0
			else
				ui_infield "gs_reveal_right_sR", x+picx+2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[33]
				ui_infield "gs_reveal_bottom_sR", x+54, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[35]
			endif
		else
			ui_outfield str(formatt, abs(gs_reveal_double_innerLeft)), x-cx-4, y+41, cx, outfieldHeight, 1
			ui_outfield str(formatt, abs(gs_reveal_double_innerTop)), x+20, y-19, cx, outfieldHeight, 2
			ui_infield "gs_reveal_double_innerRight", x+picx+2, y+39, cx, infieldHeight ui_tooltip stRevealClusureUITips[43]
			if gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM then
				ui_infield "gs_reveal_double_innerBottom", x+71-cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[9]
			endif
			if bEnableUniformJambDepths & gs_reveal_uniform then
				ui_outfield str(formatt, abs(gs_reveal_double_innerRight_sR)), x+picx+2, y+83, cx, outfieldHeight, 0
				ui_outfield str(formatt, abs(gs_reveal_double_innerBottom_sR)), x+8+cx, y+picy+5, cx, outfieldHeight, 0
			else
				ui_infield "gs_reveal_double_innerRight_sR", x+picx+2, y+79, cx, infieldHeight ui_tooltip stRevealClusureUITips[37]
				ui_infield "gs_reveal_double_innerBottom_sR", x+8+cx, y+picy+1, cx, infieldHeight ui_tooltip stRevealClusureUITips[39]
			endif
		endif
	endif

return


"bottomPositiveReveal":
	if not(isEmptyOpening) then
		if isWindow then
			ui_pict 126, xPicBot, yPicBot, 33, 58, 1	!reveal_bot_win.png
		else
			ui_pict 127, xPicBot, yPicBot, 33, 58, 1	!reveal_bot_door.png
		endif
	else
		ui_pict 128, xPicBot, yPicBot, 33, 58, 1		!reveal_bot_op.png
	endif
	ui_pict 21, xPicBot-11, yPicBot+24, 11, 10, 1		!ui_arrow_10_v.png

	if bForceUniformBottomReveal then
		ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicBot+23, 72, outfieldHeight, 1
	else
		ui_infield "gs_reveal_bottom", xPicBot-88, yPicBot+19, 72, infieldHeight	ui_tooltip stRevealClusureUITips[7]
	endif
return

"bottomNegativeReveal":
	if not(isEmptyOpening) then
		if isWindow then
			ui_pict 129, xPicBot, yPicBot, 33, 58, 1	!negative_reveal_bot_win.png
		else
			ui_pict 130, xPicBot, yPicBot, 33, 58, 1	!negative_reveal_bot_door.png
		endif
	else
		ui_pict 131, xPicBot, yPicBot, 33, 58, 1		!negative_reveal_bot_op.png
	endif
	ui_pict 21, xPicBot-11, yPicBot+32, 11, 10, 1		!ui_arrow_10_v.png

	if bForceUniformBottomReveal then
		ui_outfield str(formatt, abs(gs_reveal_right)), xPicTop-88, yPicBot+31, 72, outfieldHeight, 1
	else
		ui_infield "gs_reveal_bottom", xPicBot-88, yPicBot+27, 72, infieldHeight	ui_tooltip stRevealClusureUITips[7]
	endif
return


"bottomNoReveal":
	if not(isEmptyOpening) then
		if isWindow then
			ui_pict 132, xPicBot, yPicBot, 33, 58, 1	!no_reveal_bot_win.png
		else
			ui_pict 133, xPicBot, yPicBot, 33, 58, 1	!no_reveal_bot_door.png
		endif
	else
		ui_pict 134, xPicBot, yPicBot, 33, 58, 1			!no_reveal_bot_op.png
	endif
return

"horizontalPosRevealParams":
	ui_pict 20, xPic+24, yPic-11, 10, 11, 1			!ui_arrow_10.png
	ui_pict 20, xPic+87, yPic-11, 10, 11, 1			!ui_arrow_10.png

	ui_infield "gs_reveal_right", xPic+87, yPic-34, 72, infieldHeight ui_tooltip stRevealClusureUITips[3]

	if bEnableUniformJambDepths & gs_reveal_uniform then
		ui_outfield str(formatt, abs(gs_reveal_right)), xPic-6, yPic-30, 72, outfieldHeight, 2
	else
		ui_infield "gs_reveal_left", xPic-6,	yPic-34, 72, infieldHeight ui_tooltip stRevealClusureUITips[2]
	endif
return


"noRevealPicsHorizontal":
	if not(isEmptyOpening) then
		if isWindow then
			ui_pict 1, xPic, yPic, 121, 33, 1		!no_reveal_win.png
		else
			ui_pict 2, xPic, yPic, 121, 33, 1		!no_reveal_door.png
		endif
	else
		ui_pict 3, xPic, yPic, 121, 33, 1			!no_reveal_op.png
	endif
return

"horizontalNegRevealParams":
	ui_pict 20, xPic+16, yPic-11, 10, 11, 1			!ui_arrow_10.png
	ui_pict 20, xPic+95, yPic-11, 10, 11, 1			!ui_arrow_10.png

	ui_infield "gs_reveal_right", xPic+87, yPic-34, 72, infieldHeight ui_tooltip stRevealClusureUITips[3]
	if bEnableUniformJambDepths & gs_reveal_uniform then
		ui_outfield str(formatt, abs(gs_reveal_right)), xPic-6, yPic-30, 55, outfieldHeight, 2
	else
		ui_infield "gs_reveal_left", xPic-6,	yPic-34, 72, infieldHeight ui_tooltip stRevealClusureUITips[2]
	endif
return


"revealDepthParam":
	ui_pict 7, xPic+121, yPic, 11, 11, 1			!ui_arrow_11.png
	ui_infield "gs_wido_sill", xPic+121+16, yPic-5, 72, infieldHeight ui_tooltip stRevealClusureUITips[1]
return


"negRevealPicsHorizontal":
	if not(isEmptyOpening) then
		if isWindow then
			ui_pict 105, xPic, yPic, 121, 33, 1	!negative_reveal_win.png
		else
			ui_pict 106, xPic, yPic, 121, 33, 1	!negative_reveal_door.png
		endif
	else
		ui_pict 107, xPic, yPic, 121, 33, 1	!negative_reveal_op.png
	endif
return


"negRevealPicsVerticalTop":
	if not(isEmptyOpening) then
		if isWindow then
			ui_pict 108, xPicTop, yPicTop, 33, 58, 1	!negative_reveal_top_win.png
		else
			ui_pict 109, xPicTop, yPicTop, 33, 58, 1	!negative_reveal_top_door.png
		endif
	else
		ui_pict 110, xPicTop, yPicTop, 33, 58, 1		!negative_reveal_top_op.png
	endif
return


"noRevealPicsVertical":
	if not(isEmptyOpening) then
		if isWindow then
			ui_pict 4, xPicTop, yPicTop, 33, 58, 1	!no_reveal_top_win.png
		else
			ui_pict 5, xPicTop, yPicTop, 33, 58, 1	!no_reveal_top_door.png
		endif
	else
		ui_pict 6, xPicTop, yPicTop, 33, 58, 1			!no_reveal_top_op.png
	endif
return


"revealPicsHorizontal":
	if not(isEmptyOpening) then
		if isWindow then
			ui_pict 14, xPic, yPic, 121, 33, 1	!reveal_win.png
		else
			ui_pict 15, xPic, yPic, 121, 33, 1	!reveal_door.png
		endif
	else
		ui_pict 16, xPic, yPic, 121, 33, 1	!reveal_op.png
	endif
return


"revealPicsVerticalTop":
	if not(isEmptyOpening) then
		if isWindow then
			ui_pict 17, xPicTop, yPicTop, 33, 58, 1	!reveal_top_win.png
		else
			ui_pict 18, xPicTop, yPicTop, 33, 58, 1	!reveal_top_door.png
		endif
	else
		ui_pict 19, xPicTop, yPicTop, 33, 58, 1		!reveal_top_op.png
	endif
return


"customInnerPosRevealParamaters":
	ui_infield "gs_reveal_double_innerRight", xPic+87, yPic+45, 72, 20 ui_tooltip stRevealClusureUITips[5]
	if bEnableUniformJambDepths & gs_reveal_uniform then
		ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPic-6, yPic+49, 72, outfieldHeight, 2
	else
		ui_infield "gs_reveal_double_innerLeft", xPic-6, yPic+45, 72, 20 ui_tooltip stRevealClusureUITips[4]
	endif
return

"customInnerNegRevealParamaters":
	ui_infield "gs_reveal_double_innerRight", xPic+87, yPic+45, 72, 20 ui_tooltip stRevealClusureUITips[5]
	if bEnableUniformJambDepths & gs_reveal_uniform then
		ui_outfield str(formatt, abs(gs_reveal_double_innerRight)), xPic-6, yPic+49, 55, outfieldHeight, 2
	else
		ui_infield "gs_reveal_double_innerLeft", xPic-6, yPic+45, 72, 20 ui_tooltip stRevealClusureUITips[4]
	endif
return



]]>
</Script_UI>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_VL SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[

! =============================================================================
! Reveal Types
! =============================================================================

if bShapeSameRevealAngles then
	gs_reveal_uniform = 1
	parameters gs_reveal_uniform = gs_reveal_uniform
endif
 
if not(bEnableUniformJambDepths & bShowUniformJambDepths) then
	hideparameter	"gs_reveal_uniform"
	lock			"gs_reveal_uniform"
endif

if not(bEnableDifferentBottomReveal) then
	hideparameter	"gs_reveal_type_bottom",
					"gs_reveal_type_bottom_int"

	lock	"gs_reveal_type_bottom",
			"gs_reveal_type_bottom_int"
endif


if iClosureType = CLOSURE_STUD_WALL then
	hideparameter	"gs_reveal_bottom",
					"gs_reveal_top"

	lock	"gs_reveal_bottom",
			"gs_reveal_top"
endif

if	iClosureType = CLOSURE_STUD_WALL then
	hideparameter	"AC_wido_sill"
	lock			"AC_wido_sill"
endif

if bEnableDifferentBottomReveal then
	if gs_reveal_type_bottom_int = REVEAL_BOTTOM_NO then
		hideparameter	"gs_reveal_bottom"

		lock			"gs_reveal_bottom"
	endif

	if gs_reveal_type_bottom_int <> REVEAL_BOTTOM_UNIFORM then
		hideparameter	"gs_reveal_splayed_innerBottom",
						"gs_reveal_bottom_angle"
		lock			"gs_reveal_splayed_innerBottom",
						"gs_reveal_bottom_angle"
	endif
endif

if	iRevealType = REVEAL_EDGE |\
	iRevealType = REVEAL_NO |\
	iRevealType = REVEAL_SPLAYED |\
	(iRevealType = REVEAL_DOUBLE & iSillRevealType = REVEAL_NO) then

	if (gs_reveal_type_bottom_int = REVEAL_BOTTOM_UNIFORM & bEnableDifferentBottomReveal) | not(bEnableDifferentBottomReveal) then
		hideparameter	"gs_reveal_bottom"
		lock	"gs_reveal_bottom"
	endif

	hideparameter	"gs_reveal_left",
					"gs_reveal_right",
					"gs_reveal_top"

	lock	"gs_reveal_left",
			"gs_reveal_right",
			"gs_reveal_top"

	if bTShapedOpening then
		hideparameter	"gs_reveal_left_sL",
						"gs_reveal_right_sR",
						"gs_reveal_bottom_sL",
						"gs_reveal_bottom_sR"

		lock	"gs_reveal_left_sL",
				"gs_reveal_right_sR",
				"gs_reveal_bottom_sL",
				"gs_reveal_bottom_sR"
	endif
else
	values "gs_reveal_left"		range[0,]
	values "gs_reveal_right"	range[0,]
	values "gs_reveal_top"		range[0,]
	values "gs_reveal_bottom"	range[0,]

	if bEnableUniformJambDepths & gs_reveal_uniform then
		hideparameter	"gs_reveal_left",
						"gs_reveal_top"

		lock	"gs_reveal_left",
				"gs_reveal_top"

		if	bittest(gs_RevealTypeEnable, REVEAL_HISTORIC) |\
			bittest(gs_RevealTypeEnable, REVEAL_SPLAYED) then

			hideparameter	"gs_reveal_splayed_innerLeft",
							"gs_reveal_splayed_innerTop"

			lock	"gs_reveal_splayed_innerLeft",
					"gs_reveal_splayed_innerTop"
		endif

		if	iRevealType = REVEAL_SLANTED | \
			iRevealType = REVEAL_HISTORIC then

			hideparameter	"gs_reveal_left_angle",
							"gs_reveal_top_angle"

			lock	"gs_reveal_left_angle",
					"gs_reveal_top_angle"
		endif

		if bTShapedOpening then
			hideparameter	"gs_reveal_left_sL",
							"gs_reveal_right_sR",
							"gs_reveal_bottom_sL",
							"gs_reveal_bottom_sR"

			lock	"gs_reveal_left_sL",
					"gs_reveal_right_sR",
					"gs_reveal_bottom_sL",
					"gs_reveal_bottom_sR"
		endif
	else
		if	iWindowShape = SHAPE_ARCHED_T | \
			iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | \
			iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then

			hideparameter	"gs_reveal_top",
							"gs_reveal_left"

			lock	"gs_reveal_top",
					"gs_reveal_left"
		endif

		if	iWindowShape = SHAPE_HALF_T_LEFT | \
			iWindowShape = SHAPE_ARCHED_HALF_T_LEFT then

			hideparameter	"gs_reveal_right_sR",
							"gs_reveal_bottom_sR"

			lock	"gs_reveal_right_sR",
					"gs_reveal_bottom_sR"
		endif

		if	iWindowShape = SHAPE_HALF_T_RIGHT | \
			iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then

			hideparameter	"gs_reveal_left_sL",
							"gs_reveal_bottom_sL"

			lock	"gs_reveal_left_sL",
					"gs_reveal_bottom_sL"
		endif
	endif
endif

if iRevealType = REVEAL_HISTORIC | iRevealType = REVEAL_SPLAYED then
	values "gs_reveal_splayed_innerLeft"	range [0,]
	values "gs_reveal_splayed_innerRight"	range [0,]
	values "gs_reveal_splayed_innerTop"		range [0,]
	values "gs_reveal_splayed_innerBottom"	range [0,]
else
	if	bittest(gs_RevealTypeEnable, REVEAL_HISTORIC) |\
		bittest(gs_RevealTypeEnable, REVEAL_SPLAYED) then

		hideparameter	"gs_reveal_splayed_innerLeft",
						"gs_reveal_splayed_innerRight",
						"gs_reveal_splayed_innerTop",
						"gs_reveal_splayed_innerBottom"

		lock	"gs_reveal_splayed_innerLeft",
				"gs_reveal_splayed_innerRight",
				"gs_reveal_splayed_innerTop",
				"gs_reveal_splayed_innerBottom"
	endif
endif

if iRevealType = REVEAL_SPLAYED then
	if bEnableUniformJambDepths & gs_reveal_uniform then
			hideparameter	"gs_reveal_left_angle",
							"gs_reveal_top_angle",
							"gs_reveal_splayed_innerLeft",
							"gs_reveal_splayed_innerTop"


			lock	"gs_reveal_left_angle",
					"gs_reveal_top_angle",
					"gs_reveal_splayed_innerLeft",
					"gs_reveal_splayed_innerTop"

	endif
endif

if	iRevealType = REVEAL_DOUBLE & iBoardRevealType <> REVEAL_NO then
	values "gs_reveal_double_innerLeft"		range [0,]
	values "gs_reveal_double_innerRight"	range [0,]
	values "gs_reveal_double_innerTop"		range [0,]
	values "gs_reveal_double_innerBottom"	range [0,]

	if bEnableUniformJambDepths & gs_reveal_uniform then
		hideparameter	"gs_reveal_double_innerLeft",
						"gs_reveal_double_innerTop"
		lock	"gs_reveal_double_innerLeft",
				"gs_reveal_double_innerTop"

		if bTShapedOpening then
			hideparameter	"gs_reveal_double_innerLeft_sL",
							"gs_reveal_double_innerRight_sR",
							"gs_reveal_double_innerBottom_sL",
							"gs_reveal_double_innerBottom_sR"

			lock	"gs_reveal_double_innerLeft_sL",
					"gs_reveal_double_innerRight_sR",
					"gs_reveal_double_innerBottom_sL",
					"gs_reveal_double_innerBottom_sR"

			if	iWindowShape = SHAPE_ARCHED_T | \
				iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | \
				iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then

				hideparameter	"gs_reveal_double_innerTop"
				lock	"gs_reveal_double_innerTop"
			endif
		endif
	else
		if	iWindowShape = SHAPE_ARCHED_T | \
			iWindowShape = SHAPE_ARCHED_HALF_T_LEFT | \
			iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then

			hideparameter	"gs_reveal_double_innerTop",
							"gs_reveal_double_innerLeft"

			lock	"gs_reveal_double_innerTop",
					"gs_reveal_double_innerLeft"
		endif

		if	iWindowShape = SHAPE_HALF_T_LEFT | \
			iWindowShape = SHAPE_ARCHED_HALF_T_LEFT then

			hideparameter	"gs_reveal_double_innerRight_sR",
							"gs_reveal_double_innerBottom_sR"

			lock	"gs_reveal_double_innerRight_sR",
					"gs_reveal_double_innerBottom_sR"
		endif

		if	iWindowShape = SHAPE_HALF_T_RIGHT | \
			iWindowShape = SHAPE_ARCHED_HALF_T_RIGHT then

			hideparameter	"gs_reveal_double_innerLeft_sL",
							"gs_reveal_double_innerBottom_sL"

			lock	"gs_reveal_double_innerLeft_sL",
					"gs_reveal_double_innerBottom_sL"
		endif
	endif
else
	if bittest(gs_RevealTypeEnable, REVEAL_DOUBLE) then
		hideparameter	"gs_reveal_double_innerLeft",
						"gs_reveal_double_innerRight",
						"gs_reveal_double_innerTop",
						"gs_reveal_double_innerBottom"

		lock	"gs_reveal_double_innerLeft",
				"gs_reveal_double_innerRight",
				"gs_reveal_double_innerTop",
				"gs_reveal_double_innerBottom"

		if bTShapedOpening then
			hideparameter	"gs_reveal_double_innerLeft_sL",
							"gs_reveal_double_innerRight_sR",
							"gs_reveal_double_innerBottom_sL",
							"gs_reveal_double_innerBottom_sR"

			lock	"gs_reveal_double_innerLeft_sL",
					"gs_reveal_double_innerRight_sR",
					"gs_reveal_double_innerBottom_sL",
					"gs_reveal_double_innerBottom_sR"
		endif
	endif
endif

if	iRevealType = REVEAL_SLANTED | \
	iRevealType = REVEAL_SPLAYED | \
	iRevealType = REVEAL_HISTORIC | \
	iRevealType = REVEAL_DOUBLE_SPLAYED then

	values "gs_reveal_left_angle"	range [0,90)
	values "gs_reveal_right_angle"	range [0,90)
	values "gs_reveal_top_angle"	range [0,90)
	values "gs_reveal_bottom_angle"	range [0,90)
else
	if	bittest(gs_RevealTypeEnable, REVEAL_SLANTED) |\
		bittest(gs_RevealTypeEnable, REVEAL_SPLAYED) |\
		bittest(gs_RevealTypeEnable, REVEAL_HISTORIC) |\
		bittest(gs_RevealTypeEnable, REVEAL_DOUBLE_SPLAYED) then

		hideparameter	"gs_reveal_left_angle",
						"gs_reveal_right_angle",
						"gs_reveal_top_angle",
						"gs_reveal_bottom_angle"

		lock	"gs_reveal_left_angle",
				"gs_reveal_right_angle",
				"gs_reveal_top_angle",
				"gs_reveal_bottom_angle"
	endif
endif

if	iRevealType = REVEAL_DOUBLE_SPLAYED then
	values "gs_reveal_innerLeft_width"		range [0,)
	values "gs_reveal_innerRight_width"		range [0,)
	values "gs_reveal_innerTop_width"		range [0,)
	values "gs_reveal_innerBottom_width"	range [0,)

	if gs_reveal_angle_edit_by_int = 1 then
		hideparameter	"gs_reveal_innerLeft_width",
						"gs_reveal_innerRight_width",
						"gs_reveal_innerTop_width",
						"gs_reveal_innerBottom_width"

		lock	"gs_reveal_innerLeft_width",
				"gs_reveal_innerRight_width",
				"gs_reveal_innerTop_width",
				"gs_reveal_innerBottom_width"
	else
		hideparameter	"gs_reveal_left_angle",
						"gs_reveal_right_angle",
						"gs_reveal_top_angle",
						"gs_reveal_bottom_angle"

		lock	"gs_reveal_left_angle",
				"gs_reveal_right_angle",
				"gs_reveal_top_angle",
				"gs_reveal_bottom_angle"
	endif
else
	if bittest(gs_RevealTypeEnable, REVEAL_DOUBLE_SPLAYED) then
		hideparameter	"gs_reveal_innerLeft_width",
						"gs_reveal_innerRight_width",
						"gs_reveal_innerTop_width",
						"gs_reveal_innerBottom_width"

		lock	"gs_reveal_innerLeft_width",
				"gs_reveal_innerRight_width",
				"gs_reveal_innerTop_width",
				"gs_reveal_innerBottom_width"
	endif
endif

if	iRevealType = REVEAL_DOUBLE_SPLAYED | \
	iRevealType = REVEAL_OUTSIDE_SPLAYED then

	values "gs_reveal_outer_jamb_depth"		range [0,)
	values "gs_reveal_outerLeft_angle"		range [0,90)
	values "gs_reveal_outerRight_angle"		range [0,90)
	values "gs_reveal_outerTop_angle"		range [0,90)
	values "gs_reveal_outerBottom_angle"	range [0,90)

	values "gs_reveal_outerLeft_width"		range [0,)
	values "gs_reveal_outerRight_width"		range [0,)
	values "gs_reveal_outerTop_width"		range [0,)
	values "gs_reveal_outerBottom_width"	range [0,)

	if GLOB_MODPAR_NAME = "gs_reveal_angle_edit_by" then
		gs_reveal_angle_edit_by_int = 1
		if gs_reveal_angle_edit_by = stRevealAngleEditBy[2] then gs_reveal_angle_edit_by_int = 2
		parameters gs_reveal_angle_edit_by_int = gs_reveal_angle_edit_by_int
	else
		gs_reveal_angle_edit_by = stRevealAngleEditBy[1]
		if gs_reveal_angle_edit_by_int = 2 then gs_reveal_angle_edit_by = stRevealAngleEditBy[2]
		parameters gs_reveal_angle_edit_by = gs_reveal_angle_edit_by
	endif

	bDefaultElem = (GLOB_INTGUID = "" | GLOB_INTGUID = "{00000000-0000-0000-0000-000000000000}")

	if not(bDefaultElem) & (bInclinedWall | AC_WallType = 2 | ac_wall_crosssection_type = 3 | ac_wall_crosssection_type = 4) then
		values "gs_reveal_angle_edit_by" stRevealAngleEditBy[1]
		values "gs_reveal_angle_edit_by_int" 1
		lock "gs_reveal_angle_edit_by", "gs_reveal_angle_edit_by_int"
		hideparameter "gs_reveal_angle_edit_by"
	else
		values "gs_reveal_angle_edit_by" stRevealAngleEditBy[1], stRevealAngleEditBy[2]
		values "gs_reveal_angle_edit_by_int" 1, 2
	endif

	if gs_reveal_angle_edit_by_int = 1 then
		hideparameter	"gs_reveal_outerLeft_width",
						"gs_reveal_outerRight_width",
						"gs_reveal_outerTop_width",
						"gs_reveal_outerBottom_width"

		lock	"gs_reveal_outerLeft_width",
				"gs_reveal_outerRight_width",
				"gs_reveal_outerTop_width",
				"gs_reveal_outerBottom_width"
	else
		hideparameter	"gs_reveal_outerLeft_angle",
						"gs_reveal_outerRight_angle",
						"gs_reveal_outerTop_angle",
						"gs_reveal_outerBottom_angle"

		lock	"gs_reveal_outerLeft_angle",
				"gs_reveal_outerRight_angle",
				"gs_reveal_outerTop_angle",
				"gs_reveal_outerBottom_angle"
	endif
else
	if	bittest(gs_RevealTypeEnable, REVEAL_DOUBLE_SPLAYED) |\
		bittest(gs_RevealTypeEnable, REVEAL_OUTSIDE_SPLAYED) then

		hideparameter	"gs_reveal_outer_jamb_depth",
						"gs_reveal_outerLeft_angle",
						"gs_reveal_outerRight_angle",
						"gs_reveal_outerTop_angle",
						"gs_reveal_outerBottom_angle",
						"gs_reveal_outerLeft_width",
						"gs_reveal_outerRight_width",
						"gs_reveal_outerTop_width",
						"gs_reveal_outerBottom_width",
						"gs_reveal_angle_edit_by"

		lock	"gs_reveal_outer_jamb_depth",
				"gs_reveal_outerLeft_angle",
				"gs_reveal_outerRight_angle",
				"gs_reveal_outerTop_angle",
				"gs_reveal_outerBottom_angle",
				"gs_reveal_outerLeft_width",
				"gs_reveal_outerRight_width",
				"gs_reveal_outerTop_width",
				"gs_reveal_outerBottom_width",
				"gs_reveal_angle_edit_by"
	endif
endif

if bTShapedOpening then
	values "gs_reveal_left_sL"		range[0,)
	values "gs_reveal_right_sR"		range[0,)
	values "gs_reveal_bottom_sL"	range[0,)
	values "gs_reveal_bottom_sR"	range[0,)
	values "gs_reveal_double_innerLeft_sL"		range[0,)
	values "gs_reveal_double_innerRight_sR"		range[0,)
	values "gs_reveal_double_innerBottom_sL"	range[0,)
	values "gs_reveal_double_innerBottom_sR"	range[0,)

!	if gs_sidelight_parapet_hgt_left < EPS then
!		hideparameter	"gs_reveal_left_sL",
!						"gs_reveal_bottom_sL",
!						"gs_reveal_double_innerLeft_sL",
!						"gs_reveal_double_innerBottom_sL"
!
!		lock	"gs_reveal_left_sL",
!				"gs_reveal_bottom_sL",
!				"gs_reveal_double_innerLeft_sL",
!				"gs_reveal_double_innerBottom_sL"
!
!	endif
!
!	if gs_sidelight_parapet_hgt_right < EPS then
!		hideparameter	"gs_reveal_right_sR",
!						"gs_reveal_bottom_sR",
!						"gs_reveal_double_innerRight_sR",
!						"gs_reveal_double_innerBottom_sR"
!
!		lock	"gs_reveal_right_sR",
!				"gs_reveal_bottom_sR",
!				"gs_reveal_double_innerRight_sR",
!				"gs_reveal_double_innerBottom_sR"
!
!	endif
endif


! =============================================================================
! Outside Splayed Reveal
! =============================================================================

if iRevealType = REVEAL_OUTSIDE_SPLAYED & (GLOB_MODPAR_NAME = "gs_reveal_type_new" | GLOB_MODPAR_NAME = "gs_reveal_type_int") then
	AC_wido_sill = WALL_THICKNESS - WIDO_FRAME_THICKNESS
	gs_wido_sill = AC_wido_sill
	parameters AC_wido_sill = AC_wido_sill, gs_wido_sill = gs_wido_sill
endif


! =============================================================================
! Mounting Frame
! =============================================================================

if bEnableMountingFrameForReveal then
	if not(iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) then
		lock "gs_mountingFrame"
		hideparameter "gs_mountingFrame"
	endif
	if not(iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) | not(gs_mountingFrame) then
		lock	"gs_mountingFrame_depth",
				"gs_mountingFrame_width_left",
				"gs_mountingFrame_width_right",
				"gs_mountingFrame_width_top",
				"gs_mountingFrame_width_bottom",
				"gs_mountingFrame_pen_view",
				"gs_mountingFrame_pen_cont",
				"gs_mountingFrame_fill",
				"gs_mountingFrame_pen_fg",
				"gs_mountingFrame_pen_bg",
				"gs_mountingFrame_mat"
		hideparameter	"gs_mountingFrame_depth",
						"gs_mountingFrame_width_left",
						"gs_mountingFrame_width_right",
						"gs_mountingFrame_width_top",
						"gs_mountingFrame_width_bottom",
						"gs_mountingFrame_pen_view",
						"gs_mountingFrame_pen_cont",
						"gs_mountingFrame_fill",
						"gs_mountingFrame_pen_fg",
						"gs_mountingFrame_pen_bg",
						"gs_mountingFrame_mat"
	endif

	if (iRevealType = REVEAL_DOUBLE_SPLAYED | iRevealType = REVEAL_OUTSIDE_SPLAYED) & gs_mountingFrame then
		lock	"gs_reveal_left",
				"gs_reveal_right",
				"gs_reveal_top",
				"gs_reveal_bottom"
		hideparameter	"gs_reveal_left",
						"gs_reveal_right",
						"gs_reveal_top",
						"gs_reveal_bottom"
	endif

	if iWindowShape = SHAPE_ARCHED then
		if GLOB_MODPAR_NAME = "gs_mountingFrame_width_left" then
			gs_mountingFrame_width_right 	= gs_mountingFrame_width_left
			gs_mountingFrame_width_top 		= gs_mountingFrame_width_left
			parameters gs_mountingFrame_width_right 	= gs_mountingFrame_width_right
			parameters gs_mountingFrame_width_top 		= gs_mountingFrame_width_top
		else
			if GLOB_MODPAR_NAME = "gs_mountingFrame_width_top" then
				gs_mountingFrame_width_left 	= gs_mountingFrame_width_top
				gs_mountingFrame_width_right 	= gs_mountingFrame_width_top
				parameters gs_mountingFrame_width_left 		= gs_mountingFrame_width_left
				parameters gs_mountingFrame_width_right 	= gs_mountingFrame_width_right
			else
				gs_mountingFrame_width_left 	= gs_mountingFrame_width_right
				gs_mountingFrame_width_top 		= gs_mountingFrame_width_right
				parameters gs_mountingFrame_width_left 	= gs_mountingFrame_width_left
				parameters gs_mountingFrame_width_top 	= gs_mountingFrame_width_top
			endif
		endif
	endif

	values "gs_mountingFrame_depth"			range(0, gs_reveal_outer_jamb_depth]
	values "gs_mountingFrame_width_left"	range(0,)
	values "gs_mountingFrame_width_right"	range(0,)
	values "gs_mountingFrame_width_top"		range(0,)
	values "gs_mountingFrame_width_bottom"	range(0,)
endif


! =============================================================================
! Wall Inset
! =============================================================================

if bEnableParapetInset then
	hideparameter "gs_parapet_autodim"
	values "gs_parapet_inset_thk" range [0, ]
	if not(gs_parapet_wall_inset) then
		lock	"gs_parapet_inset_thk",
				"gs_parapet_autodim",
				"gs_parapet_width",
				"gs_parapet_height",
				"gs_parapet_2D",
				"gs_parapet_line",
				"gs_parapet_bottom_st",
				"iParapetBottom",
				"gs_parapet_botelev",
				"gs_parapet_sizes_st",
				"iParapetSize",
				"gs_parapet_left",
				"gs_parapet_right"
		hideparameter	"gs_parapet_inset_thk",
						"gs_parapet_autodim",
						"gs_parapet_width",
						"gs_parapet_height",
						"gs_parapet_2D",
						"gs_parapet_line",
						"gs_parapet_bottom_st",
						"iParapetBottom",
						"gs_parapet_botelev",
						"gs_parapet_sizes_st",
						"iParapetSize",
						"gs_parapet_left",
						"gs_parapet_right"
	else
		if gs_parapet_autodim then
			lock	"gs_parapet_width",
					"gs_parapet_height"
			hideparameter	"gs_parapet_width",
							"gs_parapet_height"
		else
			values "gs_parapet_width"	range(0,]
			values "gs_parapet_height"	range(0, WIDO_SILL_HEIGHT]
		endif
	endif
endif

if isWindow & not(gs_parapet_2D) then
	hideparameter "gs_parapet_line"
	lock "gs_parapet_line"
endif


! ==============================================================================
! Head Depth on Symbol
! ==============================================================================

if isWindow | (not(isWindow) & (isEmptyOpening | bDoorCHE)) then
	if not(gs_head_symbol) then
		lock "gs_head_symbol_line", "gs_head_symbol_pen"
		hideparameter "gs_head_symbol_line", "gs_head_symbol_pen"
	endif
endif


! ==============================================================================
! Setting Reveal Side
! ==============================================================================

if bTShapedOpening then
	values "gs_reveal_set_side" REVEAL_SET_INSIDE, REVEAL_SET_OUTSIDE
endif
]]>
</Script_VL>

<Comment SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Comment>

<ParamSection SectVersion="22" SectionFlags="0" SubIdent="0">
	<ParamSectHeader>
		<AutoHotspots>false</AutoHotspots>
		<StatBits>
			<STBit_FixSize/>
		</StatBits>
		<WDLeftFrame>0</WDLeftFrame>
		<WDRightFrame>0</WDRightFrame>
		<WDTopFrame>0</WDTopFrame>
		<WDBotFrame>0</WDBotFrame>
		<LayFlags>65535</LayFlags>
		<WDMirrorThickness>0</WDMirrorThickness>
		<WDWallInset>0</WDWallInset>
	</ParamSectHeader>
	<Parameters>
		<Length Name="A">
			<Description><![CDATA["Dimension 1"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="B">
			<Description><![CDATA["Dimension 2"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="ZZYZX">
			<Description><![CDATA["Height"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Boolean Name="AC_show2DHotspotsIn3D">
			<Description><![CDATA["Show 2D Hotspots in 3D"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="ac_bottomlevel">
			<Description><![CDATA["Bottom Level"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="ac_toplevel">
			<Description><![CDATA["Top Level"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Integer Name="gs_macro_version">
			<Description><![CDATA["Macro Version"]]></Description>
			<Value>9</Value>
		</Integer>
		<Length Name="AC_Sill_To_Curr_Story">
			<Description><![CDATA["Sill Height to Current Story"]]></Description>
			<Value>0</Value>
		</Length>
		<Integer Name="AC_Hole_Hotspot_Control">
			<Description><![CDATA["Hotspots 0-None,1-2D,2-3D,3-All"]]></Description>
			<Value>3</Value>
		</Integer>
		<Integer Name="AC_Hole_Display_Option">
			<Description><![CDATA["Floor Plan Display Option"]]></Description>
			<Value>3</Value>
		</Integer>
		<Boolean Name="AC_HoleSideMaterial">
			<Description><![CDATA["Hole has Wall's Side Surface"]]></Description>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="AC_HoleMaterialCurved">
			<Description><![CDATA["Hole Surface's Split is Curved in Curved Walls"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Integer Name="AC_WallType">
			<Description><![CDATA["Wall Type"]]></Description>
			<Value>0</Value>
		</Integer>
		<Integer Name="AC_WindowInWallContour">
			<Description><![CDATA["Window in Wall Contour"]]></Description>
			<ArrayValues FirstDimension="4" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="AC_WallContourPolygon">
			<Description><![CDATA["Wall Contour Polygon"]]></Description>
			<ArrayValues FirstDimension="1" SecondDimension="3">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="AC_Wall_Direction_Type">
			<Description><![CDATA["Wall Direction Type"]]></Description>
			<Value>0</Value>
		</Integer>
		<Integer Name="ac_wall_crosssection_type">
			<Description><![CDATA["Wall Cross Section Type"]]></Description>
			<Value>0</Value>
		</Integer>

		<!-- iTypeDemolitionFill: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Integer Name="iTypeDemolitionFill">
			<Description><![CDATA["Demolition / New construction"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<FillPattern Name="gs_new_symb_fill">
			<Description><![CDATA["New Wall Fill Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</FillPattern>
		<PenColor Name="gs_new_symb_pen_Fg">
			<Description><![CDATA["New Wall Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</PenColor>
		<PenColor Name="gs_new_symb_pen_bg">
			<Description><![CDATA["New Wall Fill Background Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</PenColor>
		<Length Name="gs_new_symb_width_r">
			<Description><![CDATA["New Wall Fill Width Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.15</Value>
		</Length>
		<Length Name="gs_new_symb_width_l">
			<Description><![CDATA["New Wall Fill Width Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.15</Value>
		</Length>
		<Boolean Name="gs_bShowNewOnCC">
			<Description><![CDATA["Show new construction on Wall"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- gs_function_control_parameters: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_function_control_parameters">
			<Description><![CDATA["Function Control Parameters"]]></Description>
		</Title>
		<Boolean Name="bEnableParapetInset">
			<Description><![CDATA["Enable/Disable Wall Inset"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bEnableMountingFrameForReveal">
			<Description><![CDATA["Enable/Disable Mounting Frame (For Reveal)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bCut3DWallhole">
			<Description><![CDATA["Cut 3D Wallhole"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bDWSymbolAtMiddle">
			<Description><![CDATA["Symbol at Middle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="lod2D_MountingFrame">
			<Description><![CDATA["2D Detail Level - Mounting Frame"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="lod3D_MountingFrame">
			<Description><![CDATA["3D Detail Level - Mounting Frame"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Boolean Name="bEnableWallContourHiddenLine">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bWallContHiddenLineIn">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bWallContHiddenLineOut">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bWallContHiddenLineInLeftSl">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bWallContHiddenLineOutLeftSl">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bWallContHiddenLineInRightSl">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bWallContHiddenLineOutRightSl">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="gs_RevealTypeEnable">
			<Description><![CDATA["Reveal Type Enable Mask"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>

		<!-- gs_wallhole_geometry: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_wallhole_geometry">
			<Description><![CDATA["Wallhole Geometry"]]></Description>
		</Title>
		<Boolean Name="bParalellInCurvedWalls">
			<Description><![CDATA["Parallel Opening in Curved Walls"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="refWidth">
			<Description><![CDATA["Curved Wall - Reference Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="leftWidth">
			<Description><![CDATA["Left Offset from the Origo"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="rightWidth">
			<Description><![CDATA["Right Offset from the Origo"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="radSill">
			<Description><![CDATA["Curved Wall - Sill Radius"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="radBoard">
			<Description><![CDATA["Curved Wall - Board Radius"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="WOD">
			<Description><![CDATA["Curved Wall - Wall Center Distance"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="elevationOffset">
			<Description><![CDATA["Elevation Offset"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="offsetSill">
			<Description><![CDATA["Thickness of Hidden Wall Skins at Sill Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="offsetBoard">
			<Description><![CDATA["Thickness of Hidden Wall Skins at Board Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="lineSections">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="7">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
				<AVal Column="4" Row="1">0</AVal>
				<AVal Column="5" Row="1">0</AVal>
				<AVal Column="6" Row="1">0</AVal>
				<AVal Column="7" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="overSizeLower">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- iRevealType: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Integer Name="iRevealType">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="gs_reveal_type_new">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Без Четверти - Торец"]]></Value>
		</String>
		<Integer Name="gs_reveal_type_int">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="gs_reveal_type_bottom">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Без Четверти"]]></Value>
		</String>
		<Integer Name="gs_reveal_type_bottom_int">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Integer Name="iSillRevealType">
			<Description><![CDATA["Outer Reveal Type - Custom Reveal"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="iBoardRevealType">
			<Description><![CDATA["Inner Reveal Type - Custom Reveal"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="gs_wido_sill">
			<Description><![CDATA["Reveal Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>-9999</Value>
		</Length>
		<Length Name="AC_wido_sill">
			<Description><![CDATA["Reveal Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<String Name="gs_reveal_type">
			<Description><![CDATA["Outer Reveal Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Без Четверти"]]></Value>
		</String>
		<Integer Name="gs_reveal_doubleOuterTypeInt">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<String Name="gs_reveal_double_innerType">
			<Description><![CDATA["Inner Reveal Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Без Четверти"]]></Value>
		</String>
		<Integer Name="gs_reveal_doubleInnerTypeInt">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="gs_reveal_set_side">
			<Description><![CDATA["Set Jamb Depth on Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Boolean Name="gs_reveal_uniform">
			<Description><![CDATA["Uniform Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="leftRevealPnts">
			<Description><![CDATA["Left Reveal Points"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Length Name="rightRevealPnts">
			<Description><![CDATA["Right Reveal Points"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="1" SecondDimension="2">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="iRevealPointsIdx">
			<Description><![CDATA["Reveal Points Index"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="20" SecondDimension="0">
				<AVal Row="1">1</AVal>
				<AVal Row="2">1</AVal>
				<AVal Row="3">1</AVal>
				<AVal Row="4">1</AVal>
				<AVal Row="5">1</AVal>
				<AVal Row="6">1</AVal>
				<AVal Row="7">1</AVal>
				<AVal Row="8">1</AVal>
				<AVal Row="9">1</AVal>
				<AVal Row="10">1</AVal>
				<AVal Row="11">1</AVal>
				<AVal Row="12">1</AVal>
				<AVal Row="13">1</AVal>
				<AVal Row="14">1</AVal>
				<AVal Row="15">1</AVal>
				<AVal Row="16">1</AVal>
				<AVal Row="17">1</AVal>
				<AVal Row="18">1</AVal>
				<AVal Row="19">1</AVal>
				<AVal Row="20">1</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="gs_reveal_left">
			<Description><![CDATA["Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_reveal_right">
			<Description><![CDATA["Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_reveal_left_sL">
			<Description><![CDATA["Lower Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_reveal_right_sR">
			<Description><![CDATA["Lower Jamb Depth Side 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_reveal_splayed_innerLeft">
			<Description><![CDATA["Inner Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_splayed_innerRight">
			<Description><![CDATA["Inner Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerLeft">
			<Description><![CDATA["Inner Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerRight">
			<Description><![CDATA["Inner Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="revealInnerLeft">
			<Description><![CDATA["Inner Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="revealInnerRight">
			<Description><![CDATA["Inner Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerLeft_sL">
			<Description><![CDATA["Inner Lower Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_reveal_double_innerRight_sR">
			<Description><![CDATA["Inner Lower Jamb Depth Side 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_reveal_top">
			<Description><![CDATA["Head Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_reveal_bottom">
			<Description><![CDATA["Sill Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Boolean Name="bShowRevealSE">
			<Description><![CDATA["Show reveal on Section/Elevation"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Length Name="original_gs_reveal_bottom">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_bottom_sL">
			<Description><![CDATA["Sill Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_reveal_bottom_sR">
			<Description><![CDATA["Sill Depth Side 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_reveal_splayed_innerTop">
			<Description><![CDATA["Inner Head Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_splayed_innerBottom">
			<Description><![CDATA["Inner Sill Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerTop">
			<Description><![CDATA["Inner Head Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerBottom">
			<Description><![CDATA["Inner Sill Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerBottom_sL">
			<Description><![CDATA["Inner Sill Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_double_innerBottom_sR">
			<Description><![CDATA["Inner Sill Depth Side 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_reveal_outer_jamb_depth">
			<Description><![CDATA["Outer Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<String Name="gs_reveal_angle_edit_by">
			<Description><![CDATA["Edit Jamb by"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Угол и Глубина"]]></Value>
		</String>
		<Integer Name="gs_reveal_angle_edit_by_int">
			<Description><![CDATA["Edit Jamb by"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Angle Name="gs_reveal_left_angle">
			<Description><![CDATA["Angle Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_right_angle">
			<Description><![CDATA["Angle Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_top_angle">
			<Description><![CDATA["Upper Side Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_bottom_angle">
			<Description><![CDATA["Bottom Side Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Length Name="gs_reveal_innerLeft_width">
			<Description><![CDATA["Splay Width Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Length Name="gs_reveal_innerRight_width">
			<Description><![CDATA["Splay Width Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Length Name="gs_reveal_innerTop_width">
			<Description><![CDATA["Upper Side Splay Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Length Name="gs_reveal_innerBottom_width">
			<Description><![CDATA["Bottom Side Splay Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Angle Name="gs_reveal_outerLeft_angle">
			<Description><![CDATA["Outer Angle Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_outerRight_angle">
			<Description><![CDATA["Outer Angle Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_outerTop_angle">
			<Description><![CDATA["Outer Angle Upper Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_outerBottom_angle">
			<Description><![CDATA["Outer Angle Bottom Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Length Name="gs_reveal_outerLeft_width">
			<Description><![CDATA["Outer Splay Width Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Length Name="gs_reveal_outerRight_width">
			<Description><![CDATA["Outer Splay Width Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Length Name="gs_reveal_outerTop_width">
			<Description><![CDATA["Outer Splay Width Upper Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Length Name="gs_reveal_outerBottom_width">
			<Description><![CDATA["Outer Splay Width Bottom Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.08</Value>
		</Length>
		<Boolean Name="gs_mountingFrame">
			<Description><![CDATA["Mounting Frame"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_mountingFrame_depth">
			<Description><![CDATA["Mounting Frame Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_mountingFrame_width_left">
			<Description><![CDATA["Mounting Frame Width Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_mountingFrame_width_right">
			<Description><![CDATA["Mounting Frame Width Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_mountingFrame_width_top">
			<Description><![CDATA["Mounting Frame Width Upper"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<Length Name="gs_mountingFrame_width_bottom">
			<Description><![CDATA["Mounting Frame Width Bottom"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.06</Value>
		</Length>
		<PenColor Name="gs_mountingFrame_pen_view">
			<Description><![CDATA["Mounting Frame Uncut Line Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="gs_mountingFrame_pen_cont">
			<Description><![CDATA["Mounting Frame Contour Line Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<FillPattern Name="gs_mountingFrame_fill">
			<Description><![CDATA["Mounting Frame Fill Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</FillPattern>
		<PenColor Name="gs_mountingFrame_pen_fg">
			<Description><![CDATA["Mounting Frame Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="gs_mountingFrame_pen_bg">
			<Description><![CDATA["Mounting Frame Fill Background Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<Material Name="gs_mountingFrame_mat">
			<Description><![CDATA["Mounting Frame Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Material>
		<Boolean Name="bMountingFrame_DrawInsideLine">
			<Description><![CDATA["Draw Mounting Frame INside Line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- gs_closure: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_closure">
			<Description><![CDATA["Cavity Closure"]]></Description>
		</Title>
		<Integer Name="iClosureType">
			<Description><![CDATA["Closure Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Boolean Name="gs_closure_auto_changed">
			<Description><![CDATA["Closure Method Changed Automatically"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- PlasterGeometry: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="PlasterGeometry">
			<Description><![CDATA["Plaster Geometry"]]></Description>
		</Title>
		<Boolean Name="gs_turn_plaster_dim_2D">
			<Description><![CDATA["Dimensionable on 2D"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_turn_plaster_show_3D">
			<Description><![CDATA["Show in 3D"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="thkPlasterAtSillLeft">
			<Description><![CDATA["Plaster Thickness at Sill - Left Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtSillRight">
			<Description><![CDATA["Plaster Thickness at Sill - Right Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtSillTop">
			<Description><![CDATA["Plaster Thickness at Sill - Top Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtSillBottom">
			<Description><![CDATA["Plaster Thickness at Sill - Bottom Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtSillSlLeft">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtSillSlLeftBottom">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtSillSlRight">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtSillSlRightBottom">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardLeft">
			<Description><![CDATA["Plaster Thickness at Board - Left Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardRight">
			<Description><![CDATA["Plaster Thickness at Board - Right Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardTop">
			<Description><![CDATA["Plaster Thickness at Board - Top Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardBottom">
			<Description><![CDATA["Plaster Thickness at Board - Bottom Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardSlLeft">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardSlLeftBottom">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardSlRight">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="thkPlasterAtBoardSlRightBottom">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_macro_control_parameters: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_macro_control_parameters">
			<Description><![CDATA["Macro Control Parameters"]]></Description>
		</Title>
		<Boolean Name="isWindow">
			<Description><![CDATA["Window or Door Type Object"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="isEmptyOpening">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_IsCurved">
			<Description><![CDATA["Curved Window"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bDrawSillFill">
			<Description><![CDATA["Draw Wallhole Fill at Sill Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bDrawBoardFill">
			<Description><![CDATA["Draw Wallhole Fill at Board Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="wallContourLineOffsetLeftIn">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="wallContourLineOffsetRightIn">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="wallContourLineOffsetLeftOut">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="wallContourLineOffsetRightOut">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="bCustomMatNicheTop">
			<Description><![CDATA["Custom Niche Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Material Name="matNicheTop">
			<Description><![CDATA["Custom Niche Surface at Top"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>101</Value>
		</Material>

		<!-- iWindowShape: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Integer Name="iWindowShape">
			<Description><![CDATA["Window Shape"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="archHeight">
			<Description><![CDATA["Height of the Arc"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.25</Value>
		</Length>
		<Length Name="gs_lowerArchHeight">
			<Description><![CDATA["Bottom Arch Height"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.15</Value>
		</Length>
		<Boolean Name="bMirroredOpening">
			<Description><![CDATA["Mirrored Opening"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="nArchResolution">
			<Description><![CDATA["Arch Resolution"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<Length Name="smallRadiusEllips">
			<Description><![CDATA["smaller radius of ellips arch"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Integer Name="gs_numOfSides">
			<Description><![CDATA["Num of Sides in multiside openings"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="gs_posTopEdge_triangle">
			<Description><![CDATA["Top Edge from Center"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_sidelight_WHole_width_left">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_sidelight_WHole_width_right">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_sidelight_parapet_hgt_left">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_sidelight_parapet_hgt_right">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="holeBottomOffset">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="holeSideOffset">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_frame_width">
			<Description><![CDATA["Frame Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- ac_corner_window: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="ac_corner_window">
			<Description><![CDATA["Corner Window Function"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bLeftCornerFunction">
			<Description><![CDATA["Left Corner"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Angle Name="leftCornerAngle">
			<Description><![CDATA["Left Corner Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Length Name="leftConnWallThk">
			<Description><![CDATA["Left Connected Wall Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="bRightCornerFunction">
			<Description><![CDATA["Right Corner"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Angle Name="rightCornerAngle">
			<Description><![CDATA["Right Corner Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Length Name="rightConnWallThk">
			<Description><![CDATA["Right Connected Wall Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="bCornerWindow">
			<Description><![CDATA["Corner Window"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- gs_window_sizes: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_window_sizes">
			<Description><![CDATA["Window Sizes"]]></Description>
		</Title>
		<Length Name="ac_wallhole_width">
			<Description><![CDATA["Wallhole Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="ac_wallhole_height">
			<Description><![CDATA["Wallhole Height"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="ac_wallhole_height_original">
			<Description><![CDATA["Wallhole Height"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="ac_reveal_height">
			<Description><![CDATA["Reveal Height"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="gs_wallhole_hotspots">
			<Description><![CDATA["Show Wallhole Hotspots"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_reveal_hotspots">
			<Description><![CDATA["Show Reveal Hotspots"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- gs_windw_stack: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_windw_stack">
			<Description><![CDATA["Ganging"]]></Description>
		</Title>
		<Boolean Name="gs_stack_left">
			<Description><![CDATA["Connection on the Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_stack_right">
			<Description><![CDATA["Connection on the Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_stack_top">
			<Description><![CDATA["Connection on the Top"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_stack_bottom">
			<Description><![CDATA["Connection on the Bottom"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- gs_window_oversize: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_window_oversize">
			<Description><![CDATA["Oversize"]]></Description>
		</Title>
		<Length Name="gs_left_oversize">
			<Description><![CDATA["Left Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_right_oversize">
			<Description><![CDATA["Right Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_upper_oversize">
			<Description><![CDATA["Upper Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_lower_oversize">
			<Description><![CDATA["Lower Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_parapet_wall_inset: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="gs_parapet_wall_inset">
			<Description><![CDATA["Wall Inset"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_parapet_inset_thk">
			<Description><![CDATA["Depth of Inset"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.2</Value>
		</Length>
		<String Name="gs_parapet_sizes_st">
			<Description><![CDATA["Wall Inset Sizes"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="iParapetSize">
			<Description><![CDATA["Wall Inset Sizes"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="gs_parapet_width">
			<Description><![CDATA["Parapet Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="gs_parapet_right">
			<Description><![CDATA["Overhang Side 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_parapet_left">
			<Description><![CDATA["Overhang Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_parapet_height">
			<Description><![CDATA["Parapet Height"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="gs_parapet_2D">
			<Description><![CDATA["Show Hidden Parapet"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<String Name="gs_parapet_bottom_st">
			<Description><![CDATA["Wall Inset Bottom at"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="iParapetBottom">
			<Description><![CDATA["Wall Inset Bottom at"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="gs_parapet_botelev">
			<Description><![CDATA["Bottom Overhang"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<LineType Name="gs_parapet_line">
			<Description><![CDATA["Hidden Parapet Line Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</LineType>

		<!-- gs_wallhole: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_wallhole">
			<Description><![CDATA["Plan Symbol Fill"]]></Description>
		</Title>
		<FillPattern Name="gs_wallhole_fill">
			<Description><![CDATA["Plan Symbol Fill Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>65</Value>
		</FillPattern>
		<PenColor Name="gs_wallhole_pen_fg">
			<Description><![CDATA["Plan Symbol Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</PenColor>
		<PenColor Name="gs_wallhole_pen_bg">
			<Description><![CDATA["Plan Symbol Fill Background Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</PenColor>
		<FillPattern Name="gs_wallhole_fill_sl">
			<Description><![CDATA["Plan Symbol Fill Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>65</Value>
		</FillPattern>
		<PenColor Name="gs_wallhole_pen_sl_fg">
			<Description><![CDATA["Plan Symbol Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</PenColor>
		<PenColor Name="gs_wallhole_pen_sl_bg">
			<Description><![CDATA["Plan Symbol Fill Background Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</PenColor>
		<String Name="gs_wcont_line">
			<Description><![CDATA["Wall Contour Line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="iWallContourLine">
			<Description><![CDATA["Wall Contour Line"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<LineType Name="gs_wcont_line_in">
			<Description><![CDATA["Wall Contour Line Type Inside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</LineType>
		<LineType Name="gs_wcont_line_out">
			<Description><![CDATA["Wall Contour Line Type Outside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</LineType>
		<LineType Name="gs_wcont_hidden_line_in">
			<Description><![CDATA["Hidden Wall Contour Line Type Inside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</LineType>
		<LineType Name="gs_wcont_hidden_line_out">
			<Description><![CDATA["Hidden Wall Contour Line Type Outside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</LineType>
		<PenColor Name="gs_wcont_line_pen">
			<Description><![CDATA["Use Fills"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>3</Value>
		</PenColor>

		<!-- iWallContourLineSl: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Integer Name="iWallContourLineSl">
			<Description><![CDATA["Wall Contour Line Sidelights"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<LineType Name="gs_wcont_line_sl_in">
			<Description><![CDATA["Wall Contour Line Type Inside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</LineType>
		<LineType Name="gs_wcont_line_sl_out">
			<Description><![CDATA["Wall Contour Line Type Outside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</LineType>
		<LineType Name="gs_wcont_hidden_line_sl_in">
			<Description><![CDATA["Hidden Wall Contour Line Type Inside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</LineType>
		<LineType Name="gs_wcont_hidden_line_sl_out">
			<Description><![CDATA["Hidden Wall Contour Line Type Outside"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</LineType>

		<!-- gs_head_symbol: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="gs_head_symbol">
			<Description><![CDATA["Head Depth on Symbol"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<LineType Name="gs_head_symbol_line">
			<Description><![CDATA["Head Depth Symbol Line Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>21</Value>
		</LineType>
		<PenColor Name="gs_head_symbol_pen">
			<Description><![CDATA["Head Depth Symbol Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>6</Value>
		</PenColor>
		<Boolean Name="bRevealSettingsPage">
			<Description><![CDATA["Show Tabpage"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bWallInsetPage">
			<Description><![CDATA["Show Tabpage"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="gs_ui_sub_tabpage">
			<Description><![CDATA[""]]></Description>
			<Value>1</Value>
		</Integer>
		<Integer Name="pageStartY">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Integer>

		<!-- gs_string_resources: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_string_resources">
			<Description><![CDATA["String Resources"]]></Description>
		</Title>
		<String Name="stWallholeCutUI">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="32" SecondDimension="0">
				<AVal Row="1"><![CDATA["Специальная Четверть"]]></AVal>
				<AVal Row="2"><![CDATA["Размеры Специальной Четверти"]]></AVal>
				<AVal Row="3"><![CDATA["Подоконная Ниша"]]></AVal>
				<AVal Row="4"><![CDATA["Длина"]]></AVal>
				<AVal Row="5"><![CDATA["Специальная Четверть"]]></AVal>
				<AVal Row="6"><![CDATA["Тип Четверти"]]></AVal>
				<AVal Row="7"><![CDATA["Показать Нишу в 2D"]]></AVal>
				<AVal Row="8"><![CDATA["Автоматические Размеры Ниши"]]></AVal>
				<AVal Row="9"><![CDATA["Тип Линии Невидимого Контура Ниши"]]></AVal>
				<AVal Row="10"><![CDATA["Привязка Низа Ниши:"]]></AVal>
				<AVal Row="11"><![CDATA["Ширина Подоконной Ниши"]]></AVal>
				<AVal Row="12"><![CDATA["Высота Подоконной Ниши"]]></AVal>
				<AVal Row="13"><![CDATA["Отметка Низа"]]></AVal>
				<AVal Row="14"><![CDATA["Размеры Ниши:"]]></AVal>
				<AVal Row="15"><![CDATA["Выступ Слева"]]></AVal>
				<AVal Row="16"><![CDATA["Выступ Справа"]]></AVal>
				<AVal Row="17"><![CDATA["Четверть с 2 Откосами - Геометрия Четверти"]]></AVal>
				<AVal Row="18"><![CDATA["Четверть с 2 Откосами - Реквизиты Установки Коробки"]]></AVal>
				<AVal Row="19"><![CDATA["Четверть с Откосом Снаружи - Геометрия Четверти"]]></AVal>
				<AVal Row="20"><![CDATA["Четверть с Откосом Снаружи - Реквизиты Установки Коробки"]]></AVal>
				<AVal Row="21"><![CDATA["Монтажная Коробка"]]></AVal>
				<AVal Row="22"><![CDATA["Толщина Коробки"]]></AVal>
				<AVal Row="23"><![CDATA["Покрытие"]]></AVal>
				<AVal Row="24"><![CDATA["Перо Линии Сечения"]]></AVal>
				<AVal Row="25"><![CDATA["Перо Линии Видимого Контура"]]></AVal>
				<AVal Row="26"><![CDATA["Тип Штриховки Сечения"]]></AVal>
				<AVal Row="27"><![CDATA["Перо Штриховки"]]></AVal>
				<AVal Row="28"><![CDATA["Перо Фона Штриховки"]]></AVal>
				<AVal Row="29"><![CDATA["Угол и Глубина"]]></AVal>
				<AVal Row="30"><![CDATA["Ширина и Глубина"]]></AVal>
				<AVal Row="31"><![CDATA["Ширина Четверти"]]></AVal>
				<AVal Row="32"><![CDATA["Нижняя Четверть"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stRevealUI">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="4" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
				<AVal Row="3"><![CDATA[""]]></AVal>
				<AVal Row="4"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stRevealTypes">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="10" SecondDimension="0">
				<AVal Row="1"><![CDATA["Без Четверти - Торец"]]></AVal>
				<AVal Row="2"><![CDATA["Без Четверти"]]></AVal>
				<AVal Row="3"><![CDATA["Четверть"]]></AVal>
				<AVal Row="4"><![CDATA["Отрицательная Четверть"]]></AVal>
				<AVal Row="5"><![CDATA["Четверть с Рассветами"]]></AVal>
				<AVal Row="6"><![CDATA["Четверть с Откосом"]]></AVal>
				<AVal Row="7"><![CDATA["Историческая Четверть"]]></AVal>
				<AVal Row="8"><![CDATA["Специальная Четверть"]]></AVal>
				<AVal Row="9"><![CDATA["Четверть с Двумя Откосами"]]></AVal>
				<AVal Row="10"><![CDATA["Четверть с Откосом Снаружи"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stRevealTypesBottom">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="4" SecondDimension="0">
				<AVal Row="1"><![CDATA["Одинаковый"]]></AVal>
				<AVal Row="2"><![CDATA["Без Четверти"]]></AVal>
				<AVal Row="3"><![CDATA["Четверть"]]></AVal>
				<AVal Row="4"><![CDATA["Отрицательная Четверть"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stSetRevealSide">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="0">
				<AVal Row="1"><![CDATA["Внутри"]]></AVal>
				<AVal Row="2"><![CDATA["Снаружи"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stRevealAngleEditBy">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="0">
				<AVal Row="1"><![CDATA["Угол и Глубина"]]></AVal>
				<AVal Row="2"><![CDATA["Ширина и Глубина"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stParapetSize">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="3" SecondDimension="0">
				<AVal Row="1"><![CDATA["Автоматически"]]></AVal>
				<AVal Row="2"><![CDATA["Симметрично"]]></AVal>
				<AVal Row="3"><![CDATA["Асимметрично"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stParapetBottom">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="2" SecondDimension="0">
				<AVal Row="1"><![CDATA["Текущий Этаж"]]></AVal>
				<AVal Row="2"><![CDATA["Основание Стены"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="stRevealClusureUITips">
			<Description><![CDATA[""]]></Description>
			<ArrayValues FirstDimension="43" SecondDimension="0">
				<AVal Row="1"><![CDATA["Глубина Четверти"]]></AVal>
				<AVal Row="2"><![CDATA["Ширина Четверти со Стороны 2"]]></AVal>
				<AVal Row="3"><![CDATA["Ширина Четверти со Стороны 1"]]></AVal>
				<AVal Row="4"><![CDATA["Ширина Внутренней Четверти со Стороны 2"]]></AVal>
				<AVal Row="5"><![CDATA["Ширина Внутренней Четверти со Стороны 1"]]></AVal>
				<AVal Row="6"><![CDATA["Ширина Верхней Четверти"]]></AVal>
				<AVal Row="7"><![CDATA["Глубина Отлива"]]></AVal>
				<AVal Row="8"><![CDATA["Глубина Внутренней Перемычки"]]></AVal>
				<AVal Row="9"><![CDATA["Глубина Внутреннего Отлива"]]></AVal>
				<AVal Row="10"><![CDATA["Угол Откоса со Стороны 2"]]></AVal>
				<AVal Row="11"><![CDATA["Угол Откоса"]]></AVal>
				<AVal Row="12"><![CDATA["Угол Верхней Стороны"]]></AVal>
				<AVal Row="13"><![CDATA["Угол Нижней Стороны"]]></AVal>
				<AVal Row="14"><![CDATA["Внешний Угол, Левая Сторона"]]></AVal>
				<AVal Row="15"><![CDATA["Внешний Угол, Правая Сторона"]]></AVal>
				<AVal Row="16"><![CDATA["Наружный Угол Верхнего Откоса"]]></AVal>
				<AVal Row="17"><![CDATA["Наружный Угол Нижнего Откоса"]]></AVal>
				<AVal Row="18"><![CDATA["Ширина Наружной Четверти"]]></AVal>
				<AVal Row="19"><![CDATA["Ширина Коробки Слева"]]></AVal>
				<AVal Row="20"><![CDATA["Ширина Коробки Справа"]]></AVal>
				<AVal Row="21"><![CDATA["Ширина Монтажной Коробки Вверху"]]></AVal>
				<AVal Row="22"><![CDATA["Ширина Монтажной Коробки Внизу"]]></AVal>
				<AVal Row="23"><![CDATA["Толщина Монтажной Коробки"]]></AVal>
				<AVal Row="24"><![CDATA["Ширина Скоса Внизу"]]></AVal>
				<AVal Row="25"><![CDATA["Ширина Скоса Справа"]]></AVal>
				<AVal Row="26"><![CDATA["Ширина Скоса Вверху"]]></AVal>
				<AVal Row="27"><![CDATA["Ширина Скоса Внизу"]]></AVal>
				<AVal Row="28"><![CDATA["Ширина Скоса Снаружи, Левая Сторона"]]></AVal>
				<AVal Row="29"><![CDATA["Ширина Скоса Снаружи, Правая Сторона"]]></AVal>
				<AVal Row="30"><![CDATA["Ширина Скоса Снаружи Вверху"]]></AVal>
				<AVal Row="31"><![CDATA["Ширина Скоса Снаружи Внизу"]]></AVal>
				<AVal Row="32"><![CDATA["Ширина Боковой Нижней Четверти со Стороны 2"]]></AVal>
				<AVal Row="33"><![CDATA["Ширина Боковой Нижней Четверти со Стороны 1"]]></AVal>
				<AVal Row="34"><![CDATA["Глубина Отлива со Стороны 2"]]></AVal>
				<AVal Row="35"><![CDATA["Глубина Отлива со Стороны 1"]]></AVal>
				<AVal Row="36"><![CDATA["Ширина Нижней Внутренней Четверти со Стороны 2"]]></AVal>
				<AVal Row="37"><![CDATA["Ширина Нижней Внутренней Четверти со Стороны 1"]]></AVal>
				<AVal Row="38"><![CDATA["Глубина Внутреннего Отлива со Стороны 2"]]></AVal>
				<AVal Row="39"><![CDATA["Глубина Внутреннего Отлива со Стороны 1"]]></AVal>
				<AVal Row="40"><![CDATA["Ширина Четверти"]]></AVal>
				<AVal Row="41"><![CDATA["Ширина Внутренней Четверти"]]></AVal>
				<AVal Row="42"><![CDATA["Ширина Боковой / Верхней Четверти"]]></AVal>
				<AVal Row="43"><![CDATA["Ширина Внутренней Верхней / Боковой Четверти"]]></AVal>
			</ArrayValues>
		</String>
		<Length Name="bBoardElevUsa">
			<Description><![CDATA["USA board elevation"]]></Description>
			<Value>0</Value>
		</Length>

		<!-- gs_transom_display: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="gs_transom_display">
			<Description><![CDATA["Display as Transom"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<PenColor Name="gs_transom_display_pen">
			<Description><![CDATA["Wall End Line Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</PenColor>
		<LineType Name="gs_transom_display_linetype">
			<Description><![CDATA["Wall End Line Line Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</LineType>
		<Boolean Name="bShowAddHotspotsForIS">
			<Description><![CDATA["Show Additional Hotspots For IS"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Integer Name="bDoorCHE">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Integer>
		<Boolean Name="bForceUniformBottomReveal">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
	</Parameters>
</ParamSection>

<CalledMacros SectVersion="2" SectionFlags="0" SubIdent="0">
	<Macro>
		<MName><![CDATA["WallContourDivider"]]></MName>
		<MainGUID>39C131DF-CC37-40EA-ACB5-BAF01DE1FDB6</MainGUID>
	</Macro>
</CalledMacros>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="1" length_in_bytes="473" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D3000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC200000EC20115284A80000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A10000013E494441546843ED9AE10E83200C8479FFA7E04D9D1ADD16A7DB
	35B3570AF7C31093862BF7B54888A59432919E5966D58A1C37F9E7109D0FCD7B
	9AD0D161BD931AACD63A793E6FBB84987E3AB03698A7FFCBDCC55DE0F5391064
	411EB206D4C90360176441BEE7BCA46F726C25A99363FDA7A80B32C5E6581141
	8EF59FA2DE1D64D6CDDA95CE19B5E89CBA838CB4C67E978CC4B61C83AE43905B
	A6F8233741FE62106A4EEBFCD175A8935B277943B10E0BD9EB30C43E7821353A
	2C64C49CD663B45DDFB0CD09B2E13F80D6EEAED10E1064410EAF01B458BBFB26
	7B1DA8D079D9072F342FFDFE13DE93BE0974D7C9BE76E59C5D90737233652DC8
	26BB72060B724E6EA6AC05D96457CE6041CEC9CD94B5209BECCA192CC839B999
	B2E6409E53826F66FE8C35AD7E90609AF734A1AD48167EFBDD2E7B3CD60E5BFF
	4CCFDDFF07BC98DD4E0F50FADD0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="2" length_in_bytes="465" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000143494441546843
	ED9B5D0EC3200C8373FF537053D675D055DDD6E581D8FCF801A14908077F0450
	AA99996550DB64762D665FE48F8E1D0FCC7B98D0D561FD0625584A2947B6D329
	21A69F0EEC0916E9FF736E0B17785F07822CC84BEE0165F202D8055990DBBC97
	74277377923299EB3F445D90213673450499EB3F447D3AC8A8CADA2F9D6FD4D8
	314D07D9931AB596EC19DBF318EF3A04B9678A7F6213E41B83BCE6F4CEDFBB8E
	353339E76CA3B7F251C6B311057954D8827CBFBF37AECAE4D65F067B2B6B7AEF
	32CF51C81CE35DC79AC735934C436D41D6EBFA7060BA4C66579754F16A7DD9D7
	F9CA4BD37B7C353C3187986ABA4C1EC2757090820C369C2127C80CD7C19A820C
	369C2127C80CD7C19A820C369C2127C80CD7C19A820C369C2187817C2A564457
	A41826F6AE19ED799D1FF4F7C997DDB5F2C5EAAFD059719C75C3413F0054EB68
	DF282C4AAE0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="3" length_in_bytes="425" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D3000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC200000EC20115284A80000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A10000010E494441546843ED9B4B12C3200C437DFF537053B7C990364D36
	5DC4D2006FC130D9448C6409934F44448AC61B66C772CE1DFE33B9D723E35E06
	7465986B91C15A6B59394E2981A67706768355F2BFDD3BCA01BEDB012223F292
	35809317901D9111F9997E893DD95B4938D9CBBF047D2E91333318BF1C1CC7CB
	F2134E39403F4221F0BDC8117901E72332223FF6244CD65D13D7C4F5924D1971
	4D5C13D733C43F4EC6C9381927FFFF5C9BEEDA9818C4B5917C554A203222B327
	ABDC5689839371324EAE7498EADED33959F20A7E3C90B93E1A188F7FC98A1159
	42B3170491BDFC4BD0115942B3170491BDFC4BD035221F6DBC6096B0361888EC
	8F5219502FA44D07D77FC1D71A70ADE38C5BCEFF0B81FA03DFE114FD91000000
	0049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="4" length_in_bytes="346" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000CC494441545847
	ED970B0A80201044BDFF29BCA9953F4A2AA770FBC0132402D91D7667C6D539E7
	C2B2BDF78FEF927BFE022276814AC089A2442A41255A57861370024E1CCD2AA8
	0375A08E7FA963A5D932013FF94DEF8E97F732F5F75708F579D03F9CDF12CAC1
	722646EF2D431052FE88CF10448ADFAB823108293F95D874094E541D7FCC2754
	77554427AB73571D992335C8EAFF5AE00C55D2694BCC8120A4FC54E2D42706B6
	E3FEDD3110049CB834CFA00ED4B17BF118DA363EB1E59C72F11BB603C7C4315B
	0AC289CA8909C33CD1CBDAE0DF580000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="5" length_in_bytes="347" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000CD494441545847
	ED97510AC4200C44BDFF29BCA95D6D23ADB464CA9AEE169E10FC511392993149
	29A5522DE7FCB899EFCF4E10AD0A64024C1813C904991855194C80093071D5AB
	C00ED8013BDEC58E1D67AD037E725FE78E1F5BEDFAFD554A1F0FFCC3DB2CA11C
	B433ED756F050621F96FF10506B1BEEF65213808C93F993854094C741EFF994E
	A8EAAA904E66E7253B2A4ECC068F3AEDB68BD28533604E0A42F24F265C9D9854
	8EEFFE8E494180895BFD0CEC801DA71F4FA06CA31347CC291F7F6039504C1473
	842098E89858008C3BFD9F8F6956180000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="6" length_in_bytes="317" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000AF494441545847
	ED97510AC0200C437BFF5378D36EEA1C2A5A3FA60EE109C58F829634298D8888
	FA70CE6D8FF4F77D5344E80248C089A4449000897A2AC3093801277ABB0AEA40
	1DA8E32C75649A4D1BF0CE3BFA8E9FC36FFDEDA3AA322BFABFC44C301FAD33AB
	00FF8E71CCE4341406458044D1213891E0000990A887179C801370A2BB36B04F
	3C083027981367CD89E0073E788F91D7C8F3B629585F84ED3B40A2E8D5FA76D8
	0E6C533BE0C43BB12F904149A89704FE940000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="7" length_in_bytes="1229" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000000B0000
	000B08030000009E7287140000000467414D410000B18F0BFC61050000030050
	4C54450000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	000000B330F4880000010074524E53FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFF0053F70725000000097048597300000EC200
	000EC20115284A800000001974455874536F667477617265005061696E742E4E
	45542076332E352E38373B805D0000002849444154185763F8CF008650F41F04
	1818C02250268807051065501992D8404310E640CC47D80B00DAEC5BA5D18553
	0D0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="8" length_in_bytes="158" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000190000
	0013080300000052AC563700000006504C5445FF000000000041A31203000000
	0174524E530040E6D8660000003C4944415478DA75D1410E0040040441FDFF4F
	EFC14DB6E6223134618E1AC85655B436FC6968CB38E7637DE4447E9E1BF7E9E6
	AF93E473FB3C7E84690F3FB6004D7DA27ABE0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="9" length_in_bytes="158" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000190000
	0013080300000052AC563700000006504C5445FF000000000041A31203000000
	0174524E530040E6D8660000003C4944415478DA75D1410A004008C3C0F6FF9F
	5E5672D3E43A084273D4DCF5A71409A835E61FB426D8164C0043C49065889852
	0506E502D3097C3687075572004D07FC9A0E0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="10" length_in_bytes="127" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000110000
	000C0103000000BEEBC4FC00000006504C5445000000FF00001BFF8D22000000
	0274524E53FF00E5B7304A0000001C4944415408D763B81BCAC0D0FFBF81811D
	88EFE3C02039901AA05A003D6E17C1F0CC98E60000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="11" length_in_bytes="163" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000130000
	00190103000000E90587E900000006504C5445000000FF00001BFF8D22000000
	0274524E53FF00E5B7304A000000404944415408D763F8FFF7010318FF84E2AF
	50FC168AEF42F15E28AE85E07B403D7E40DC0AC427FF2E60B825ABC0F0FB0103
	C3F7BF0A40BC80E13D50FC3DC46C00F9CC3FCDEEB7E9000000000049454E44AE
	426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="12" length_in_bytes="163" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000130000
	00190103000000E90587E900000006504C5445FF000000000041A31203000000
	0174524E530040E6D8660000004149444154785E2DC34B0D80301444D10B6131
	E59314074861592995F1A4540AA2BA07D2CCE22018765B2D99C26EBB2C073A1B
	DA1ECA11D41EBC0BD419CA4F93C10748CC08E524D9D3E80000000049454E44AE
	426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="13" length_in_bytes="213" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003C0000
	00140803000000E6DDAE1B0000000F504C5445FF0000000000808080C0C0C0FF
	FFFF602B5F1B0000000174524E530040E6D8660000006A4944415478DAEDCE41
	0AC0200C445147BDFF991B1D309D211BF7FE064A1B9ED85ED7216AC51371CBCE
	FFD3C631E5997CE530E8376ADC5427365D63D5072B8DA912AA999E18E863CE35
	1D23D7A4B6756DC9B501784939FF90D4574CB4E34430AB1A3BC3CCAC5FEE75D9
	07BD300121003D0C660000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="14" length_in_bytes="513" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D3000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC200000EC20115284A80000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A100000166494441546843ED9B6B0E83201084B9FF29BCA9ADA65A631B33
	2CCE2E8BF3C398263C96F91858212DA594B993E71DC61A0BF3FD697E7FB1FBEB
	46DB6E02391318E0771FDA4ED334473E87556400A63F43582147EABBF45DC203
	F86E17824C329C2073A7969CBC2E2572327D399793E5647E5226273B68ACC48B
	6A65EDC9DA93F92E76F984AA384DA35A2AA871E83084BD9AD213AF0AC890200D
	EDFDE3CCEE136A7F24C88899B6B364A46CCF65D071B8ECD99E4E46A0A0E2206D
	459641C721C891941AFB16E40B0151711A19D0ABA3E378AC93A164C590807927
	5EC84C7A2C64449CDECBC8C95AAE7705E4E4DEED7AC364156441BEE7D8D3F33B
	999550A1ED7A275E685CF9EF9307BF4A6C5D6C1EB95CB78A96ADBE2067236688
	57900DA265AB22C8D98819E215648368D9AA08723662867805D9205AB62A829C
	8D98215E1FC8862B3BF824E7D4B64183E1AB58B5ACADE7F6FFE485D8760517F5
	3ECF9AA8388EFDD602AB2EFF02A2A474C40675E8430000000049454E44AE4260
	82
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="15" length_in_bytes="494" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000160494441546843
	ED9B810E83200C44F9FFAFF04F9D1A758E393D8257BA724B8C598685F671144B
	96524AA3936B1AC63216E67D35BFDFD8FDB989AD9B81E404027CF711DB6118C6
	96D7611509C0F4CB850572CBF8CE7DA7E60378A70B4126094E90B9534B4A5E96
	122999BE9C4BC952327F5326251BC4581B2FAA9495939593F92A3679852AA8A6
	5125D5C838540C61AFA6F48D570164282015F6CE38B3FB84EC47828C8869AB25
	236D3DB741FD30C9D9964A46A0A0C1416CB56C83FA21C82D2955F62DC817011C
	A74FFAF76BDD3720F3A44F25FF3BE079FC827C3DBFA564C24994365EC8A25ADE
	4639F92A2797C7D3E513822CC87B04C26DBCA0EA4F4545EBCEBE2A5EACD25AF0
	A3C4DA5C114EC9B50189F8BC2047A49AF924C882FCCC79B3B7F7E40EB87EB828
	2577405C900559CB758439202547A078E3830D64628529AF4075C0ACD8C5BB2A
	DD53BF9BFD3FF978CEBA15F0ADEF3905EBFECFFA7B0AE44F3B2F3AF700556BEA
	BAD00000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="16" length_in_bytes="466" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000144494441546843
	ED9B610E82300C4677FF5370D32984A941A598AD5D6DDF8F653180B47DFBD632
	5829A55427ED6EC6668B66BFFFFDA3D3BE9F9BD8BA31E44820C06F1FB15D96A5
	CE6C2FB34800A66F2E6C9067C677BD77996EC0335D0059497040D61D5A28799B
	4A50B2FA748E9251B27E5186920D62ECA5F0AAB59668AD0DE0E9319E6EC09E93
	A3015EFD4903F9EA6A5A64C8520CB485A65E78490EB6E340D6CBCD96904FEBD8
	A090A5DADDE4391AC88A059F44D82A670319C8FD79E2EA7330D3757FACBF1570
	281925F78F2E947C5E6F5ABC8A44C928799C9223E6DC5E9FC255D7BD0189783D
	9015A7512F0306C8401EF6318159E1E5453D9EEC40C928F9FF942CADE37A52D8
	285B249FC329F982C3194FC9F5162A2361949C833A4A4EC019C840EE5F56DE37
	30986D5D4DC0EC6717AD763D9A42B6D80FDC3E85FDD41F29CCB6C704F20DAA89
	09D8A64BF59F0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="17" length_in_bytes="372" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000E6494441545847
	ED98810E83200C44F9FFAFE04F71E2204870BD4658CCF64888D1801CD7BB620D
	2184B4F718E3D77B59FB7505448E024CA089E2449880893E2BA309348126AEBE
	557007EEC01DBFE58EC6D3E50B79E655AB3B9E06622F13AC966B094F93CAC036
	C50A2FF780D08B9F8520F29E60A284F6394C382C28E8F2A8B43DCD9B7494777B
	40686353AAE3B409EF7F0E0ADA56131FC7772054E6540CDAC6464CF4CF9AFB62
	7B1544CD131E268E495D886E808009599343EA2787034D9CCC60AA73B145CDF5
	D1C4395E83B36362B2C21DB86378589A3E254FD4636EAD45CD489031FF2F636E
	7B76859EC7B7D8780000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="18" length_in_bytes="355" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000D5494441545847
	ED980D0AC5200C83BDFF29BCA96F3A2B4570A6B03DC6F80411863F3126D52EA5
	944AAD39E7BF575BFB6801D14E0126D08439112660628ECA68024DA089D55B05
	77E00EDCF12D77384FDB0BF9CE56CB3BDE06A2A609BBD272894891D2401F6285
	C92320F4E4E741106D4F306147FB1E26021614747966DA91120D3ACADC11105A
	DF52463F6D40FFE7A0A0F59AB8EC3F8150995331681B5B3151BF5B9D56D42676
	83B6031E06B15DFF8C660B4DC0C450349AE854A00934D16FDA11E7D0049A4013
	DCA2DE05765DF8171471E29371E2074475B172A60832710000000049454E44AE
	426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="19" length_in_bytes="323" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000B5494441545847
	ED97E10A80200C84F7FE4FE19B5A5A1B26A80BB4223E41ECC760C77977391191
	987608E1F1ADBDF71310F91660024DA813610226EA54461368024DB4DE2AB803
	77E08E7FB9A3F0B4BE90679EBEB9E36B20D29890578C71B8AD78F0E11A03CB88
	9D0CC23FFC2C0471B0EA19881782800993965DC70D0BAE73C78B20B226BACB93
	059E9A619F5E81A781A7A6D303262EEE4013A72B718786254CC044A9011293C4
	AC33014DA00934D1FA53E20E73C706BF7F4624EF21D4F40000000049454E44AE
	426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="20" length_in_bytes="1227" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000000A0000
	000B080300000071B0EC2A0000000467414D410000B18F0BFC61050000030050
	4C54450000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	000000B330F4880000010074524E53FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFF0053F70725000000097048597300000EC200
	000EC20115284A800000001974455874536F667477617265005061696E742E4E
	45542076332E352E38373B805D0000002649444154185763F8FF9FE13F100009
	86FF0C102688810048A2486AC12AA1AA614CA84AE24401FF5A51AF2799234A00
	00000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="21" length_in_bytes="193" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000000B0000
	000A080600000062F0A4830000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000033494441542853
	63604080FF58D8303164390610078691F46032911512A50164048A55788D1F78
	C5247B90E8A083799C60A4000033EF1BE52FCE02680000000049454E44AE4260
	82
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="22" length_in_bytes="241" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000500000
	00460403000000A9B00E180000000F504C5445FFFFFFA0A0A0FFFFFFD4D0C700
	0000671AD9330000000174524E530040E6D8660000008649444154785EED8F41
	0A033108003DF801212F48FA82B00F30ADFF7F5393EC964294202D941E1CF036
	8C0A274494F2BDAE1CB911D1E5BCC54759B929F157C528465134B668F08D98C4
	A62931DBB48F8B94AA85F54CB1986214A318C528F2BEA845B19822B3F04BDCD1
	1D04A7E82DA2C818F1AD6660571110FD37BA56E30064077007FE94E00966D1FF
	9AD494A50F0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="23" length_in_bytes="829" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003D0000
	004C0806000000DE1CBF8D000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1874455874536F667477617265007061696E742E6E657420342E302E32FBE1A7
	C6000002A449444154785EED96516EDB30100555C4F73F8C0F531F21B7B0EB29
	CC225990DC272E492B2A0D0CDE460E1F35D87C64BBDFEF8FDBEDF6C8E5E572F9
	3B5B4ACF41F9AE766724E97F7E368FCD2B212D11E9D25D3D5296F64A982D1169
	B27667246569AF84B444A44B77F54859DA2B61B644A4C9DA9D9194A5BD12D212
	912EDDD5236569AF84D91291266B77465296F64A484B44BA74578F94A5BD1266
	4B449AACDD194959DA2B212D3C6FA574578FA4DF0AE668DE34DFEF25F5318F48
	59DA2B212D1169928E11294B7B25CC968834E79947A42CED959096883449C788
	94A5BD12664B449AF3CC235296F64A484B449AA46344CAD25E09B32522CD79E6
	11294B7B25A425224DD231226569AF84D91291E63CF38894A5BD12D2129126E9
	1891B2B457C26C8948739E7944CAD25E0969894893748C4859DA2B29C1F77BE1
	5CE9AE1E49BF15CCE16E9AD91291266B77465296F64A484B44BA74578F94A5BD
	12664B449AACDD194959DA2B212D11E9D25D3D5296F64A982D3C6F85F3B53B23
	49BF15CCD1B4690FCE953A47A62CED9530EF259DAB758F4859DA2B21F7C2B952
	E7C894A5BD12E6BDA473B5EE11294B7B25E45E387764866DFAC80CDD74EEBB77
	F24FBA244C9E569A1F4AE2A7952E0993A795E68792F869A54BC26454FAA86CB9
	876767BB5EAF8F77C10BF09751FB6BDB93F4D9FFBE72BC5D5A1552F2C748AB42
	4AAE4D57589B9ECDDA74875C9BAEB0363D9BB5E90EB9365D616D7A366BD31D72
	6DBAC2DAF46CD6A63BE4DA7485B5E9D9AC4D77C8B5E90AFFE7A6730F67F1F9F9
	FB1BB9DFF168E9C83E9C85BA19951FB3E9DCF356D6A62B641FCEE2B9998F27BF
	D850EBD6D3D9D493FB1D4BF6E12CD84C7AE9D6ADB774641FCEE2EBCB46A45FE2
	1FB9EF73BCFD935EBA07AFCAE37FD8507A69BB118574969E57E5F13FAF3FF1E7
	7BB74BA759FB6CDB1F2FCA9175ACBEC77F0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="24" length_in_bytes="1088" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000500000
	004608060000005B9E132B000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1874455874536F667477617265007061696E742E6E657420342E302E32FBE1A7
	C6000003A749444154785EED9741B2DC200C44A792FBDF616E936D16B98FE3C6
	C85F961B231CE01B325DF5464260446B37AF65598A78BFDF4B8AD70B473649FE
	E7F7AFC744FB3EE641C0110FB478056B26D8077A4CF58CC30D10F29AEB11871B
	A0C754CF38DC0021AFB91E71B8017A4CF58CC30D10F29AEB11871BA0C754CF38
	DC0021AFB91E71B8017A4CF58CC30D10F29AEB11871BA0C754CF38DC0021AFB9
	1E71B8017A4CF58CC30D10F29AEB11871BA0C754CF38DC0021AFB91E71B8013E
	111172E641C0110FB478056B26E8073E5D9F01FEA31E35403C66649827EB3B05
	2D5EC19AE111A3EA31031C19E6C9FA4E418B57B06633627DA7A0C52B58B319B1
	BE53D0E215ACD98C58DF825658DB033958B314E8F15DB0F79400AFB8C746FC88
	420D3F25B06629D0C3F317AB468424475FF69E12704D8A6D763197C40B6B9622
	36CA9AAF1175DE7280B85B086BBDE981354B8126CC6C8B08498EBEEC3D25E01A
	8B0CEE003B78056B96020DA09CF91A51E7E8CBDE53C2AA937721FADA7249BCB0
	6629D088996D1121C97B0C70E567C8ED660ED62C051A4139F335A2CE7B0C70CF
	25F1C29AA5402366B64584249F6A8050CE7C8DA8F3A906C8CCB68890E4530D10
	CA99AF11753ED50099D91611927CAA014239F335A2CEA71A2033DB2242924F35
	402867BE46D4F9540364665B4448F2A90608E5CCD7883A9F6A80CC6C8B08493E
	D500A19CF91A51E7530D90996D1121C9A71A2094335F23EA7CAA0132B32D2224
	F954038472E66B449DB71A20EE3DC10E5EC19AA5400366B6458424475FF69E12
	700D631FDC4A58EBCD50881B2958B314F1AEACF91A51E7E8CBDE53C2AA937701
	F7E327886DDA9A86354B81BBBE0BF69E12E015F7A4227E8250D06CA5634DC39A
	CD88F5ADD1333A6C84C2678001EB5BC07C84B0D69BA1F01960C0FA0632B803C9
	8D88BE00B06633627D6BF45C6891AD05D66C46AC6F80999CB0077464B0663362
	7D0B988D10D67A33142E860758B319B1BE357A4687422E4AFE3FA07DDB18F34D
	52A881BDCFAE5B62C5CE68B4D87E8E5D6CF32EDB75E9754B8CD6123F27E04C38
	B98AED7BA1450F4F937ED39DF7696F25D0E25DF08EF09A2FADE5E4D9AA32F7AE
	E9B9A70667E24184D3BE175AF450A2D2F37764DEF62314575DF5D6DFDC85163D
	28E9857DED69CF7C5B4DE65DA7BE51A75CBEBB0B2D7A50C222F998A870C6D4AA
	C9DEABD6A12F9228BB0E92F377A0450F51F22037E6FB6A927BD5FD87BE167BFE
	2EB4E841491E75A5C3A35B48EED6A01C11ED6B76FE0EB4E841695F78CE49CD9E
	AB8D925EEC39FBA69CE5F5177EEEA5FBD6BB2EE10000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="25" length_in_bytes="1009" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000500000
	004608060000005B9E132B000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1874455874536F667477617265007061696E742E6E657420342E302E32FBE1A7
	C60000035849444154785EED9741B2DB300C43D3E9FDEF90DB74DB45EF931AB2
	E9D20C6421F992BEA506332F9429D914B0CBEDF178BCC4FD7E7FE4B8DD706495
	ADFFFCFE75991AEFC73C1838A2409B67B06146BCA062AA671D2E404835D7A30E
	17A062AA671D2E404835D7A30E17A062AA671D2E404835D7A30E17A062AA671D
	2E404835D7A30E17A062AA671D2E404835D7A30E17A062AA671D2E404835D7A3
	0E17A062AA671D2E404835D7A30E17A062AA671D2E404835D7A30E17E0153161
	CD3C1838A2409B67B06186BFE0D5F509F08BBA5480B8CCC8304FD1770EDA3C83
	0DC32546D565021C19E629FACE419B67B06133127DE7A0CD33D8B01989BE73D0
	E6196CD88C44DF86577A8E074AB0612530EB3B61772A01AF783756FC98520F3F
	AFC08695C02CE5AF568B8AD9EC4E25F06A8E35BB6D6D0B1536ACC43650365DB3
	D60E10DF33D2B3DF5460C34A609862B645C56C76A712783562C11D6007CF60C3
	4A6010A49AAE59319BDDA9C4A227EFC6E6675DDB42850D2B81818AD916B55580
	0B3FD33A6E9660C34A6020A49AAE595B05B8AF6DA1C28695C040C56C8B3A4D80
	906ABA669D2640C56C8B3A4D80906ABA669D2640C56C8B3A4D80906ABA669D26
	40C56C8B3A4D80906ABA669D2640C56C8B3A4D80906ABA669D2640C56C8B3A4D
	80906ABA669D2640C56C8B3A4D80906ABA669D2640C56C8B3A4D80906ABA66AD
	1920BEF5043B78061B56028314B32D2A66B33B95C0AB8C3DB885F4EC375363DB
	C8C18695D8BE299BAE59319BDDA9C4A227EF06BE899F24B6197B1E36AC04BEF9
	9DB03B958057BC9BABF84942C3B3B68E3D0F1B3623D1B7C76774D8488D4F8089
	E8DB403E467AF69BA9F10930117D030BEE407663C37F00B06133127D7B7C2EB4
	C99E0D366C46A26F804C9E88077C65B06133127D1BC8C648CF7E33354EC2036C
	D88C44DF1E9FD1A151AAB6FE1FF0BE63DDD6ABACD1022FB63F32BBD8662D9C96
	477EA635AD67D3A6C2D5C4EED803DA54608A7DF7BC2CF9775AD37A366D2A98FC
	DA2B77DE2BD77F47719EB1E807EB2B48622F2A98FC73AEBFC8DFC6AF77F977DF
	91CDDBBEB394E7F5AB48622F2AB077638F08CD7D23BEF315D937B6EFA439BEF7
	0E92D88B0A26FFCCFA6E1F3FDD89F7A80D6D2A98FCDA2B733E995A97FFDE0D67
	DE927D63FB4E9AE37BADA0CD1638D1A4C2999715662DE538BF0D8FDB5F403D7B
	63071CDB250000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="26" length_in_bytes="529" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D3000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC200000EC20115284A80000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A100000176494441546843ED5BED1283200CE3FD9FC23775D353E7ED43C2
	206DC1FCF0B89D5D81A4290535A594E620D77318EB5898EDE6FE68D8FD85C136
	CC40DE1918E0770C6CA7699A3DAF53161980D38F29AC247BE2BBF49DDC07F05A
	2E4432497022991B5A52F29A4AA4647A3A9792A5647E5126251B60ACC28B2A65
	ADC95A93F92A36D942159CA65125E5E41C3A0C6167537AE1554032044885BF6F
	3CB3FB84FC8F443222A6FD2C19B18D6C83CEC364CDB65432420A0A0EE2CBD306
	9D8748F664A9B26F917C01200A4E2507F4BFA3F3B8AD92A162E58F02CCBAF042
	22E9B62423E044B7919295AE0F04A4E4E8726D10AC225924B739F6B4DC27B30A
	2AD4AF75E1858EABFFE7C9055570C7C2FD397488E8EE8F3573133805C1B024E7
	3060DFA7A7EBDC0444729B75F70A6791CCCD1F26D57356483903F67D29594AE6
	EA8CEF5D4AD6EB3F7C159BBCFE934BF74AD77CA255787153768C745D7058016D
	EC2BFC71E1F6F1CEC60CF5AFEF93B7C05CC2607F44D8B24589A0D93D007BC80C
	3A054F46C40000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="27" length_in_bytes="516" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000176494441546843
	ED5AD10E83200CE4FFBFC23F656AE6469CB18772A5B27B20649195D2E3DA5248
	29A51CA4CD6AACBA30FBB7F84FC79E2F8C6DC328B2476080DF316C3B4D53EED9
	0A2F3200A63F4B5841EE69DF65EED45D816FB810C824C20964EED61293575722
	26D3DDB9982C26F3933231D9C1C64ABCA854564C564CE6B3D8E50855514DA352
	AA9370A818C2F6A6F4C4AB0264C82037E41DE1CC9E13923F12C80899B65A3232
	36F218741D2E31DB93C90828A87110593DC7A0EBF84F9073CEE9E9ADB84DB336
	9A407E2AD802F97C6FCFB88AC9AD13B170315920B73F3B0B6482E790BB36DCB5
	95A93CE4BBB2EB13A050E344C71A5DC770D93554FDB951D1B2E4ABE2D53AA3DB
	E45580169D9D57F4B336DE184CB6368FEE93DB67D37B9BD3B36B81ACD79A7AE3
	457AA159924B4CBE1269F1FFB8C45CD35B5A03D8DF1593159371CEC41C2926EB
	8D179FC52E6FBC2C772F77CD077A7172D081DD615C4C877B4FAB30B60DA34871
	7BB3D57E5BF77BC85ACB3F92D7DDBE2F37B4BCA5D50E2C8E0000000049454E44
	AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="28" length_in_bytes="491" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A10000015D494441546843
	ED9BE10AC3200C847DFFA7E89BBAADB4DBE858130817837E3F4486B6C63BCF44
	97B6D65A2F529E66ECB628EBE3F5EF4A3D5E196CCB1872656082DF35B0DDB6AD
	8F2C5FBBC8049CFE4C61277924BEAFB1DB70033EEE029245828364EDD242C9FB
	568292E5DB394A46C9FAA00C2527605C25F0EABDB7D9CAB98087633CDC80C327
	CF46F06B3ECB90ECBD4D9B99640B03B5D0E4819735C1B31D9275BE3993E4DB38
	765292ADD83DE51C0DC9C280CF6238CB67433224C7FD84F71CCC761DC7FA5F00
	879251727C75A1E4FB7833E3AF48948C925172245620BABE201001B3EAB32B92
	7C9BEF5495A8885DDEDB3EAE35853E3342A0E7D96548B656E90A77D71606EA76
	79746D4DC07BC472F8B78A5D52EEA64D8CAD0EEA76488E9F602C8E50B256FF28
	996C4DBD8A49AED7AA789DF41FD35F90774DDEB55E6CD2116AF864EF813DA19F
	14ED412FAFF155630279DE899E3E4C595FB95EE2FBE407CB70556F0875B0C300
	00000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="29" length_in_bytes="355" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBE00000EBE01EA42B1C00000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000D5494441545847
	ED97010E84200C04FBFF57F0534EF0CA216ADAAAA7311913428C0436CB4E0511
	915C5A4AE9F6A66B4F3D22EA2EE004995012710227C6AA4C26C80499D83BAB40
	077440C7BBE8E898D513F0E9DEBACBACEAC4A32272CEE26D7A4728F704E371DD
	EA164E3C2EC22BA08CC309750B278E3A11C0BE10EAC334BA1D111116F3F5FB01
	3A5CF3EAA0CA9EF57422BCE5DC9A32B4FEA6135F51AD7674EF917AD284469DE8
	455D21C2B53E4E2C8235D241261A57F35FF58A60FE26B1A0FEE376400715738C
	1F9920136462AF28430774ACE8F800F9AD80B10B9A44FB0000000049454E44AE
	426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="30" length_in_bytes="361" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBE00000EBE01EA42B1C00000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000DB494441545847
	ED97510EC3200C4373FF537053365853016B85D38D55931E12E2A394B88E9D12
	33B35C664AE9E7D3633F5740D42CC0049A7027C2044C8C55194DA00934717657
	C11DB80377FC973B1ACFFA0DF8E375D6CBBCD5895B41E49C4D9DDE23943E6132
	A4AEAE63E276102A80B20F269C2D98B8CA44C0F6C5A19A4DA3E988809879BE3E
	BFE00EE95CDF54BD371B0D08B59CCF8E0CC53F646203E50CEDEB76B2F4612D4A
	E985311D5F0421C587894E580BD3F1625A91F14210527C3481260E75BA5098B8
	A3D71C7522F2DB5D284C2A2637ABD18C6862D7C403C2ACAC854856A07C000000
	0049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="31" length_in_bytes="358" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBE00000EBE01EA42B1C00000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000D8494441545847
	ED97810AC3200C44FDFFAFF04FDD6A9712B2464DAB2B8327889416725CEEEC25
	A594CAB673CE3FDF52FB7D02A2760126D08438112660C2DECA68024DA0092FAB
	E00EDC813BFECB1DCAB392806F9FBD59E6EB9E781AC416FBDD554A497AF7BEFD
	BC1F9AEA2C13C3202CA8B3E7D1A94E830831B10A441DC3BC3552F4A465E176C0
	840CC4CB9808D87E1FCD57682202623A138E6DDB7566331104D1EC44C576C5A2
	41107B1D98503F9BA9EE08B6034D08FB300113D68968024DA00937BC35D30E79
	42D343B23A6E1233955F65A627BEC733E60BD11C8DDC6BF65F3F000000004945
	4E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="32" length_in_bytes="359" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000D9494441545847
	ED98810E83201043F9FFAFE04FD944314858DADBC2E29667428C06B95ADA8323
	A594CAD672CE5F6F2DF6F30E883A0B3081269A13610226C6AC8C26D0049A78B5
	57C11DB80377FC973B3A4FB71DB2BCAB5A269C27EE06622B13D46555759F30A1
	00D8B50C20DE4EDB3D75C67CFCB02602163488D88F1B022DD4B996F1C61501E0
	8D59CAD9CFFBE0387330C09E5DE4C00308F72F5D0C327E1D68C6C4F8AE7B6EC9
	CA05B1C750BD178390F161E232438BA7034D5CD9C61D0703D2A78B8529E39327
	C81353B72E162619938C39D71D6BC75DD68E07AE1B5159514B1D8C0000000049
	454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="33" length_in_bytes="365" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000DF494441545847
	ED980B0E84200C44B9FF29B829BBA018246C3AD5747F7926C4C4001DA733D592
	524AA58E9CF3DB478FFDBC03A2650126D04477224CC0C45C95D1049A4013AFFE
	557007EEC01DFFE58EC1D3FD0FD9BC5BBD8CBB4E7C1B88DA265897D4D5DD61C2
	0220F73280B85CB647EA847CFCB0261C161488D88E1B1CC335B9B5F1C2E501A0
	ED59CA314F5BB09F3908608F29E6C61308F52D550C66FCB6D18A89FA6C1E4354
	6D63CF8260101AE060101BDB56F2824198F1D1C42943C1E9401367B671C7CE80
	E9D360619AF1A913D489A55B838549C5A462AE75F7E96FC7034E8C00B887F47A
	880000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="34" length_in_bytes="325" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000B7494441545847
	ED98EF0A80200CC4F7FE4FE19B5A1A0B116C9B81FDE137187EB13ACEBBB52922
	924BA69496A77E7B5F01514F0126D0843A112660A2AFCA68024DA08951AF823B
	7007EEF8973B1A4F6B876CAED62C13AE136F0351C6042B5C53DD1D262C00EE59
	0610D365BBA5CE711E1FD644C0820E228EEB86408636D731DE111100F63B73CE
	329B0EB0E7964B24B300CA73CEB0372E0051B1C2841E194CC0446F5F348126D0
	C4E8A7863B7007EEC01D56D3FB789DD80021C86B691334F4BB0000000049454E
	44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="35" length_in_bytes="370" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000E4494441545847
	ED97810AC3201043FDFFAFF04FEDB475B3D23677C2B1C1DE4018ABDEC598A42E
	A594CA6B3C7E4A794FF97C997E1BE6D45AB2E6D0D036371844C32391048390FD
	7794B1C701132733C833093E0ED91F4D9CCF0B771C7C040B939C20272EAF0D32
	B1828529FB939824E6B5727FF0DD51D56C19EA12DF9FAFBB43FD4BB022189158
	76D6E758EA7BEA3526DC0B0C28DC35DB829CF3E318C01A30EC1BF3D4742DA811
	AE46070C88FF60C2A2CA70263C960E13E65741A85DAD3C1FB3C794132B4DD41A
	40748660022666B7A009348126EEDE21B80377E00EDCC11D533130E7C406B08D
	BCED38B513CA0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="36" length_in_bytes="382" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000F0494441545847
	ED57010E84200CE3FFAFE0A7A8203A11ED46B2A8B19790DC296EB56BC72E8410
	D2BC6E3F296D5BF62FF3B5E5BA5C22088C69DEEB0C22E381A89D41C0FC05A56F
	39C8C4C10CB026CEE580F9A98963BDE88E950F6761B24FB04F74C706D8B19C85
	09F3B363B263F6952BCE8E76B8EDFDD68C8C6D22A84EE90E071030FFC91D0E20
	B6B36341A35DE86F4A9DE0B5F1321396CD3AEA0662661031C6DB25C0AA99B0C4
	FC2E880B6B5696CC2F667D40ADA17F9403A8D3CA6EB1A881BA5794E3391088A9
	91FBB2F7A8CA3192043D431095213241265AB75013D40435717586D01D7407DD
	417770C6440CB47D62022D2251676104717F0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="37" length_in_bytes="321" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000B3494441545847
	ED97510E80200C4377FF5370D329EA1242C46D10E2CF33D98F3A284D5B404444
	CF7A7D5455566B3476F37E38FFF5CF2A80DA1F7D60C298820998E85D8326D004
	9A186E96ECA20F03E40439414E9013DEA9BBE644A6BCF1AEDB42B2F20D011473
	204A29FA55CDCA0218EE8565C64C35446E6506181030617AD9CE44C6FFDB84F9
	2B086F5533DFDBEC09E5C4CC245E0F208C21988089DE2D68024DA089D11E823B
	7007EEC01D9C313D06FA9C3800AB168161919E51A50000000049454E44AE4260
	82
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="38" length_in_bytes="494" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000160494441546843
	ED9BE10E83200C8479FFA7F04D9D1A75C639DB45AED7C1FD306491D1725F0B1D
	61A59432063D9399C516B35DCDEF0DDB9F30EDC30C9D15D6E7A0041B8661443E
	8755424C3F1558120CA9FF3C76811B786F07822CC85DC68032B903EC822CC875
	EA25EDC9DC48522673F50FB12EC82132738D083257FF10EBCD418E3A59FB66E7
	8A1ADBA7E6207B52633B4BF6F4CDDCC73B0F41CE4CD1F04D906F04F28A939DBF
	771ECAE4EC242B046BB79051C55074E1E589D16E217BC4C9DE47CB7585654E90
	7FB80790EDECDA9B01822CC8F418F0066B737B32AAA0F28E1B5D7879FD6AEAFA
	8F35697AFA011CB0E6DC46265B77C826613721001AD3870C81686A6C7540BF17
	E43AB73FEE38C1AB6B2B48045990E9EBED4307B45C2F17BFB527FF7F75ADE51A
	FF0F095363AB03FABD32597BF2C32D91FEF51C7BF221935C3FDC81FDE944000E
	B035DDCF20D238B206D0ACF576F65BBB3D73AC3DFED578747D5F95BC74C4C158
	3E530000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="39" length_in_bytes="494" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000160494441546843
	ED9B5B0E84200C45D9FF2ADC29A3461DE338D28FBE84F3618C9150B8A72D0858
	4A29D5E99ACDACB622EF9BF9E316DD1E37EDDD0C5D15E6D929C0A669AA96D729
	4BC0F4578135C02CF55FEA2EE606BEC30190813CA40F10C9036007329075E64B
	8CC9B19E4424C7EAEF621DC82E32C71A0172ACFE2ED6BB83ECB5B2F6CFCE1DB5
	E836750759121AFB5AB2A46CE632D27E003933C546DB80FC2090549CECFCA5FD
	1833926BADE5EDD7B62923714420BF1536909FFD7BE64A246BEF0C665BD6948E
	659254185946DA8F31D375241945DB4066767D28D05D2447AF2EB1E2A53DD8EF
	F56D334D0960C56C99A62A49BFDF7FC6ABE53C2727484346B1212EE9B8A971AB
	80F57B20EB9CFE78E264FE09D572122003593173865445BA5E0F7EF77D2E1BC8
	40B64FD52E7F503026DBFF06D3D4B855C0FA3DE9DA3E9A97D988E883DDA15CC8
	CCC8D8681A6DD334E4B40FBB2FF06BDFAF4CB5EBBFAB2F5CDF0F2E0F0055BA67
	E7480000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="40" length_in_bytes="496" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000162494441546843
	ED9B810E83200C44F9FFAFF04FD934E20CDB3CB270872BB7C4984562A5AF2DB4
	2929A59445D753CC266BE47D177FDC467F8F4CF73241B586FD5FE460CBB264E6
	758A1266FAAE81CDC198FA5FDF9DE8025ECB81211BF29436604F9E00BB211B72
	9FFD92D7E4B196349727E79C53B4ABC17E62418E06B0C77C4A7A49CF70E802F6
	14AA8752A2BDC3900386EFDA480DD990BB55C26EB3BB8E168AD7F934FC626DBC
	D0840DB94F4EFC698F654F262E0BC8B0C3ADC968C2F6647BF25F164A9061DB93
	89615415350CB9D2804AF14A39866CC8A5D7AD5B3EFCAD7AA9DC5D5FF692293D
	4C25EBD4FA7439777A69992EA0B11B54A578A59C692023230ADEE827A968411D
	A301ECE786CCCB8F0B3BFA9A8C8CC4900DB9210BB9F51087EBADF13B765FB621
	1B323F544B4E50784DE61F83813A4603D8CF1DAEF9DE7C94D65A1377E2B85BEF
	A07EFC38D589512447747C1257BE8AC131EF352BC5F9640480FEFC01A23BCEE8
	EB9554200000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="41" length_in_bytes="545" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D3000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC200000EC20115284A80000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A100000186494441546843ED9BE10E83200C8479FFA7F04DB769D41967C6
	293D5AE07E18B30481DED7834A5C4A29BD825C9F692C7361DED7EEF71B7BBC30
	DA8699C8994007BF63683B4DD3CBF33AAC221D30FD096181ECA9EF3C76729FC0
	77BB106492E104999B5A72F2B294C8C9F4E55C4E9693F945999C5C4163155E54
	2B6B4FD69ECC77719557A81BA769544B39750E1D86B057537AE1750332244841
	7F579CD96342FDF7041931D376968CB48DDC068DA3CA9E5DD3C90814541CA42F
	CF36681C82EC49A9706C41FE23202A4E2103FAE3681CC33A192A561E1460B50B
	2F249386858C8813BD8D9CACE57A57404E8E6E5783646D03F28DBD1161862E73
	485F9E6DD038A0FAA3F4B0A4F83DF906642820627FB50B2FB3782341F6744EAF
	639B2CE7964EEE5568CFB89A828CEE519E827A8C9DD3A529C81E02F630665390
	7319DB03902731E474690AF21301F4CCFA256B2BD5752E6347059AD3454E1E20
	339A829CCBD801785D8698D3C506B2E109D3A8A098715B9D9A99FD3F790E76CB
	CCA8F73390A8F33CCEAB18F41B54268B463A103BE00000000049454E44AE4260
	82
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="42" length_in_bytes="532" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000186494441546843
	ED9B010E833008457BFF537853A74637A38BFCA650A0FE25C62CEB28FC076D65
	5929A5CC41AEC58DCD17CBFB6EFE7BB39E2F8CB6611CB91218E07D0C6DA7699A
	3DAFD32A3200D35B081B644F7DD7B98BBB03BFED82908D0A8E906D538B95BC2D
	25AC64F3E59C95CC4AB63F94B1923B68CC83976929734FE69E6C5FC55D1EA12A
	BA69A625E5641C6A8658AFA6E607AF0AC890200DF6FE71B69E13B23F1264A498
	8E5E323236F218348E2E7B76CF4A46A0A0E220B63CC7A07110B227A5C6B909F9
	41C0797995ECD77E6E40F2E49D959C1DF0EA3F213FE7372BD9E097A870072F56
	B27E83241C6464234B3066AC835745730261838A83D8F21C83C6D1A559D25CC9
	1590A1800CED85ED784931B776C434217B56CEA873AB3C621172ECF4480519DD
	A3624BAEEF9DA44B2AC8FAF2BCC3622AC852C6BE03D93D4A49975490DF0AB135
	EE5490A58C6D1523EBF7255D5241CE0AC1DBEF5490A58CF516D36B7E49171DC8
	52B7A5E2732FA1469E57AB4BA8F6FFE455EC2333A3DEAF0911D5CFB35FCDA03F
	8CB7A94444743CF30000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="43" length_in_bytes="513" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000173494441546843
	ED9BE10E83300884FBFE4FE19BD669745B5CE6D51428D0FB61CC3263E1BE5E8B
	6C96524A7572BCC2D863D13C1FB77F9FB4C773A3AD9B40AE04127CF6A1EDB22C
	75E4F1B58A2460FA93C20E79A4BEDBD86578009FED8290950C47C8BA538B4EDE
	97123A597D39A793E964FDA28C4E36D0D84BE1556B2DD98E73020FD7787800C7
	9E9C0DF096CF34905BBB699921230DB48DA65E78A104CFEF09596F6FB6847C5B
	C726858C6A7793E76842562CF81061AB3D9B9009B97F9F687D0EE672DDAFF5BF
	028E4EA693FB67179D7C5F6F5AFC144927D3C9724ECEB8E7F6E614A6BA9EB9D9
	21051969D8DB11EB5EAE5180993B5A33429EAEA3250019F54B443A62924E26E4
	87451C222CB5675B413EFFDFDC90D75497205D6239792A7472C986828C66AC9C
	2CB1EE847409053996F47EA20D0519CD583FB2DA4682740905D956BA3CA38582
	8C666C1E2CCF3241BAC8406EED58355CF72C3D5EDDA280D45B9162EF276F415B
	BCEFDB33CE5558EFF18A405E018FDFB3AA0378195B0000000049454E44AE4260
	82
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="44" length_in_bytes="193" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000000A0000
	000B0806000000466E1C180000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000033494441542853
	63602001FC27422D316A10C610A39A1835149888CD780C3190002E8570719822
	4234D8B1449908F3165E370200CCCA1BE54DD3E3B50000000049454E44AE4260
	82
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="45" length_in_bytes="125" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000000D0000
	00090103000000D3B4342900000006504C5445000000FF00001BFF8D22000000
	0274524E53FF00E5B7304A0000001A4944415408D763F87F8301841818FE7730
	84DE00912036481000B8F90D96213469B20000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="46" length_in_bytes="1492" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000B00000
	0044080600000021B4BF51000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A10000053949444154785EED9D6D7ADC200C8473FF53E4A66D771B524205
	9260C487991F79B60918CBA39731164EF3F1F9F9F9EBE3E363F8EB35C06B9C27
	7F0E8B748146D12CE57CBDFF8D0238C18B4832C700380A8224E718CEEED534B7
	F29F9FE31BE017C4235FE5A0BD007212AC037754FB9C8111965EC7D6F81127C8
	E8C9D2F128887BE1E7716BE14FF947F0A4E5329F6CEF2504EA6B14E25117D02E
	9CED75C87BB5473A6FE250CB5318C0E57A5A0B84EDEB5C13A17D04BCAD25448A
	3914E011887B5D00918CDBC7F06A1F05EF16008F407C3B48275C7F24BCDB00DC
	03B1D7054E48F629315AB58F86772B8073884F4924E36CAFCBCB6AC3EBFB9467
	C4E7D1005B5D8090E11FFEACDA23CB653537D7F21BFE109797E552905A506CC7
	4319A1290A606953628B325A595326C0678069851D0570BE015632A3C5420716
	F7249F059A06416FFBB5009FCE8C96F0E40AB5CFF78B270F9A23C8DDDB231C58
	7B4878C25243BB466D12AC6CB7E81F51424B558C1C624D87654B885A824BD7D2
	2E60C7F63CB93BC6A7C5A4E5206F97A0EB75E4A3004EB7D15CCC1FB3E9EB8578
	4DECDDDAA5A5C16E316AF1B4F250B65D0D700E71E9C827DF82A5C9A941B3537B
	2D17D2CFAF07B8966C02BCEE294FD2BEF6B3EB01AEADB708F03E00B7727435C0
	AD65C3A900730DECFFA50849B3ED77E2588558E7B0DA7A7B45152287D8524693
	A087FE4A91544AB19697523F4DE89DDB4FBD83E49B2C2D7D6BC0F596D0F2B7D7
	2C00979B41EFEF474E6E39569C35FB1A51357FDAC4291D4C72B4A76891D6C051
	9F52A52A37871FFFB64038D207E5AC27BB9B06FFAC768486299F234C68C77AF4
	98E6C09EA0A4BE08F14763D08EDF3D46447C6880A58A86A6F38F8D306D368CB6
	D381F7592FED08B0C417015EB4D84400E2499EB72F223E3A70275C9D877973DC
	FD106739D1EA6BD811603AF00E547CC58000C432117AFB20E2A30377028710BF
	37F14F390EA1211A603A70E7848880120148445C694C447C6880B7AE42E46C8D
	260621FE680CA71F8FD030CFE96885AA76BC47E7B03AF046C6E8D163E8214E03
	E4699A48EEE9853A8D917FB676E292C6DF9FDE135AFA239D1742DF13C9597C4D
	914EECC939DC816F865773604F624EE81B05B1E7DAA100DF0CAF47F427F58D80
	D8A30F0C60C2FB4781437F29D5038CD4170DB1271E08C084779FF71D3CC947F6
	4542EC89EB0D30EA790036102AA0C9E3DCEAC0799D1921B9872338C0FF95391E
	F2C70F3DA2D6FA3E559BFCBAA6038C480CC7F8BB84B8DD81577030FC37669934
	AE7F4B706732418011F7BCAF3166266E85DB59CF395387218053EEAD17C67E77
	B8F54C2E08301D788881565D78866175075F3E51CF0896E738C3C167B24180E9
	C0DD0C58CB8591C6D3157CBE489FB9608F148263E3DC7D261F04980EDCC5406B
	C26F0D70E9B874609C733DE52E309311F7EC9B19DC6909E56496772423757101
	2C051219DC690033DEFA967A142704986B60170396493AD3E8CCC1D76650D4CC
	B208C53E7BAEBF67B24280E9C06606AC86B11460AFFDD381F774412B6C11FD5A
	4C78F9D2E2FB9E7DF9F69FA7D24080FF014C2DF4F7A225B646B69E7FDC3ECABB
	A9E5256D268D0EEC7D1FB834CBC49DE6B6E28B43D2C95B6EDC0AF676986FBEFE
	FCDA351D726047E07D1BAC0548C999D3711ED87B66188F39C3E14B28F3BC6977
	760DF8E6B6B5754FBB15500BF09B001C49C4C93A69851CF1D60FFA3F34AA2514
	6B32E8C0673864F404693970EDDC56C6BA1CD83AB867ED132DE2EAF1AD9AAD8E
	33E2FC3D1C20F4121DD833B0A76F84701C73BF3B8087094F5F5315C2523A2BD7
	C38448AF7FDEA491074A4F5F33C01EB14703F09C8B7DF773DBC807344BBE7F03
	A6F579A792CA11EA0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="47" length_in_bytes="851" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000002A0000
	00810806000000B6182876000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A1000002B849444154785EED9C5B76C3200C44BDFF5564A77939F8602AA4
	010B509AF9F0499B60182E929068E36DDBB6FBEBBADD6E21AFA4EFF94AA12E2B
	44A2DEB64EA224CAF0E4B481D099E84C74A69F77A6883969169AEEEF64347FC3
	DB6B7BFB3B89DC73E6ED1E4D6C2EF25D7E9C5006212B8ACC891ECA3FA5C90A9B
	95448A44578A55454A445788D544AA4425B18217A6666EAFB58E0E7FD2469A21
	308DA1EAE8C50175FE714C648C1426A5B610516D3952FCAD75AE7D5EDEA309FD
	13479199E7F62BFD5C8AB304D4FAC8B5B8102D072A8579087523AA51F110FA7B
	44B5E50E43B42624CFCA1027B526B41F8E765CCBE26849A0F67BCFF68A80184A
	D443C0F4386AED60D6A448D422802C69B94D0ECB9EACE5F44A4A5C77A67F61A3
	6898D626FBEC63AFEB5B2FF43EA91DFADEC9865B057A3849ABD06536DA2AD43D
	1F95560715A59912895A811CA55C2440F4FAE3ECB5B45D1245BD196D47A22829
	B41D89A2A4D076248A9242DB91284A0A6D47A22829B41D89A2A4D0765D447B8B
	BBD9F73597C9B3051E59FEAA815BC7ED263AF300825528ABD056C37E1FB18087
	6B68CCE449098956CE6A1947B5035FD4C178E23C2ACDE389B3F7164AA2241A3D
	29A18D7EAD8DA27F13AE99E0B29A09DDC196EFF5AD4249D47226126D25309468
	CABAADD73C73BF1A765A2674A966B22AD13411648B1E5ED7D7062857C6126B4E
	DAEA40DB2D6A055C3EA825402B020B33F3F90F881A410FA1EED9534F194CA212
	819264481BFD0AAFB71C65481CB576246979D19D096DA785CAAE9D091DB8B59D
	6B869F0FDEFBE5D4F2BEBCCFAAD8969D6984C8245A13DB94E18F1409894588CE
	10A9898588CE14A98A55434290AF07AB445790D4A2811847238814CCE09C8F46
	12F9127BE8290BACF4815730BFDA4F062EDE130BF2C99D88465B6E5168649127
	1B8D66934A88E2E3E8F8383A170257E3266DD49B208992E8E7095C69437A003C
	B49C179D42051C0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="48" length_in_bytes="1416" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000B00000
	0044080600000021B4BF51000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A1000004ED49444154785EED9D6B8EEB200C85BBFF557455B39D7B956A18
	B994601F30C669CE8F2AD5C4E1617F3E3150691ECFE7F3DFE3F170F994468EF6
	8EEF77B9B69C7797B9977996787BB0D46347DE7B7DF704584EC625233CBCC136
	7CD449F1A3A79B7BECC87EFE003E209EFDD40DD76A6C019A09E0F42A1CA009F1
	7D6D2BBB9BE5E878FE8C95E6B43C3A2C6D9C416C819736FBE09DF1BD37BC3D80
	5BA2F82A213C3F1F12FF5B0F5B9C84A880A53DDAD89302F1BDACEF4BBC3D19D2
	E2F656777B764C25B603A30529FBFD15CA5BF8D1E6BE1CE07A61A80D68A45EB6
	B6493B5B52A10ABC427953013C0A3181B301B7CB4F2B95371DC028C4880AEC0A
	E0B7F66BF17D04BCDB1771AD9A9ABB13B955D5929451F0A604D8AAC41615B038
	9B3678C2F47C1F096F3A808FC9737702072A4B12B6E095315DB18BA5CD3D6417
	E26C62BD72820ABC0FF496EFA39537ED22AE869935F13E503575935B9A675B65
	B756E05E394105DE07F6DB6B590C634589A0B5A925596809D1CB562AF13E602D
	3F98E995811A8433F75301AC4D8410E781B8B7602B42745C7F7E7E5E8C95DD25
	CF6BEA5D8891859D968DBCEF9300C882CDAB063EEB538B696809A129705D136B
	83E77D1F606B3F9E2DD8ACF143ED24BC75DF5A8C4301B6666B99843678DEDF0F
	B035A616A85B6D69310E05D832097952A70D9EF7F7036C8DA9C52E3DC0D66CA5
	02AF01D39AF04809618D690FE0CB9410962CA402EF85F7801C01D81A53CD0E5D
	C4B5A07F689DCCDE6F76DA8997553168E70B3D1AA7592EE4E2BD6EAB17DB7ADB
	351DC0A82333D89FADE8338C6DD5183CF77E4B4952AEE58DD0BACABFBDBE7B65
	92B6C73BAB9872E539DBD65D9FF7F06144A981C48700AF92A884ED6604786417
	42024E801382862810629B11E0D69B1B9A134B08DFC510E2FC68DB8C00DF4A81
	B38AE5951671B349C31A7890420FF5980DDED59FF7F0A137C0B752E0AB03B47B
	FC1901660D3CA8E8BB61DAD17F4680532B707D6A3213340FE7CFF4FF0DCF7AF8
	50C674D50600E2EB65DB687712C62B2DE2BCE3320B717D0A5792CC7C9D1D40EB
	794FE545B291B6715B822B951889A3BB0213DE38889040AFB05D053132565780
	09EF7DE02D90AD80780BC084F77EF0AE82381C60C27B5F7857400C03ECB53245
	3AA6EDF741BF83A3570DECD9B179FBE3F79FBF7C8BBD74E2B7CC69641E1E2C21
	4086FC133C6440B4FD3E655E19D369803D4E77564E906DC72744241304D8E39D
	C736DE38BA0CC0256E54B97895CBECF3482EA6143872A09903C6B1BD27702417
	C300D72B5406912A2CF7848FEF11A5040166FD3ACCC09968458ADBD0E0656645
	6419D5FD5AEA1EC90701A6020F31D01395D400D78A4B05BE963A46BCCD221981
	B32F727011CE661FFE0918C90804704B6DA9C0FE005C3DA9223921C0AC812106
	2CC99512E033A5A50253816BA8235931675FE4A02C594E9BBC8913C9CA07C0A8
	FC5381F382B42BC97B4CA07C6973F803589E9E20AB48024C80AD2544EB78B92C
	41468F9E3F7E0627D73496460930014600964CD5EB674D6D5BF79B25444F8D7B
	8325CCF78519397DAB5577869B6E0D5C832C3B6EFDF268662023D9C767F2244C
	AF1468292D027CF7D8DA7AA62DEDB4AD53829507AC88588CF0E02576A7DB68D6
	0E907223C299EC634FF28C2CC6AC8C0D29B0B571AF5701C1DB039E97DF4738B0
	3206038C348CD87A398BEDE4861D6102B135ED4258B6CEEA7A9840E5062A3A3E
	089488AD196064C2B30340FAA2ED3512259289FFD726E7F8109FB0EA00000000
	49454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="49" length_in_bytes="848" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000002A0000
	00810806000000B6182876000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A1000002B549444154785EED9C6D6EC32010447DFF53E4A6699C1407E305
	666130549D1F51A486B8CF8FFDB25577DBB6EDB9BF1E8FC792AFC0F77A172865
	8764941DEB322AA32A4FA406A26452322999944C2403CC648A4AD33E337FE6D1
	D586E704F2F9265C0D36E609160F9DABC09A909F1DDF9E07F5E430B0202F4667
	C3162153A3B3604B90668C86C4CA2558A80C9EF74BF646E1957E76949FB42EE5
	8CB2CC7A20E35CB180BF453473D49E6A10BE9B3315FFBC04FA7B9C6FD657D4BB
	9B020BF4DC962AFBD46296050A1B6D8D5916A8CB680B2C0BD46DD40BCB026D32
	EA816581361B456159A05D462DD85CE1A0D6D15070BDEF69BBB5607B4129466B
	10B5D618EF4C73AFAF41209F334065141D363CEBAAD313B2BDA5358CADEFAEA3
	C84930406F8B5174805E2EEB2DCB35F35362D40B3A2D46BDA0B7C5681A7B5E50
	19AD157219450A7BA9062A467B0CB6DAA3DC29E9014713479D09B52CA3A82974
	9D8CA2A6D075328A9A42D7C9286A0A5DF7FF8CA26666AF1B7E15CA3A41810693
	8C64D255A8AE425999691D4731CAB62BA3321ADD1F47C3E154E6D80675A74446
	C32411FDED9F7750518C8E6AA1FB71870FCE6829D2FD51B45AC8286A0A5DE749
	83DC31A75D33A1D5617A1DF582CA68ED2A5446D10CF79A42CD9F62341466D67B
	69526A39A1A1BD3ED4506447A6F5FAB8D0F7820E9B9ED26ED40B3AA48E5A2DB3
	17946E3486DC1F695B324653482628CDA805C904A5C4680E9209DA6DB404C904
	6DEA4C71C709A0B967413D4373A9E0371BAD990CE02CD0A61845213D4FDC225D
	CCD5EB47405AF6AD3B82AFDF5D7F42EC1D23373C335A320B19BD03B264168AD1
	3B218BB0A581610664A162D8313A13D284CD5D16D48AB9A7FCF4AC8D849D8DAE
	60323EB18327BD125CC5A4B1FD1FA3AB99BC80AE0C194F60CB9A34B77EDFF69E
	CC1CF9DD53D60B94F04F5A64941DAF322AA3ABF5F67447FE5C8CFE008C1284A6
	C810C07D0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="50" length_in_bytes="1132" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000AF0000
	003208060000002A6A8BE8000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A1000003D149444154785EED9DEB72AB300C8479FFA7C89BF6949CBAE378
	8CB5B2D7582EFB23934E1144AC3E2DC2F4721CC7F185BC52D0197B7EFDB47748
	2443C8A76996CE37F1827276A553CEDDCFD718BC79228C42EA18A06B20150F1E
	E349AFC5457E9C37BCAFD7EBCB7A953B79C043A147E33C9FAD58AC4150EDD1B8
	5CF79C1D8BB373FB55CDAA0D801CF08C190158106110FD359DBCE0B6E02DC756
	D87913E03D00A3DD8AC6FDB50247381F547B34AE9C7151839C0AAF1CF8990EEA
	6DB01EC74D805B9FF57113E8E98A1E0746BB158DB34E4EDBFD0D866A8FC48D80
	3BDD797B0016507EA076D46C14DCDBE0454708A45BCBF5BB1D0BB773CE8C1A31
	C0BD155E14E09D0BABDCEDAB060BDCDBE1B5006674B500B2011AD168A4464C70
	97C06B013C22ACF69D0BEE88BE6C7097C13B0A30DAFD23626BDF7A23F4683F03
	DCA5F08E022CB8E2BAECC8235FCF72ACC5C0F03AAF95CCCC2771D6C969BBBF01
	3CCE3BCB716F7B4861C12B07F603B443D3CD0677F9D890839D4E16298CA7FB91
	E329066F2054FB54CFFC4155322AC6FBB6F00A361CB6555A95F02257E0AB982B
	17B7CE6DFACC5B3E42B612D213B6B5E0F63A6F2FBC39B8654358AC8484D74A5A
	DBD7029E0CE684A717DA72BFDAB1AC3A0BDE5AEBEB7BE6EF8331C7867C46CEA1
	0E07EFEE5CA082265728DF73D7DA5D8BC739AF35537956252C90566DB7CE7155
	5EC8E722FACF5826DB666CB82A6ECDA510C123C5E4858D94179A8B55837CFBE3
	9C37895802FC317CFFFC3D0854F02871B531204A6E681EAD3A94DB1E0B6FBE24
	D60219153D52DCEE6343AEE595133FF286AD84AC56E89D8BBFFB3A355A8FC7C3
	DBEAEA484EEACD65E7E6BBBA0AD6BEFFD8B14133EFFA070DB5A6D4CC5BF9B351
	F9128C561B6282DBBA0F296FB4596343ED26D7FA91C8DA3E07EB515FED38E812
	520EB9F7721D257EF7B1C1CA3FAF258399ABE3B5EA59F2741BBCD5CE896B461F
	1A5A0D52CEF1B5B97EE7F32F7367FDF8639A9FF3F7DA95E06AACB9055EABF8D6
	76CB15ACFDB5FD5B41C23A3A6B6C6839B7A756829764890C383C85F3C632F263
	C35B5BB9F09C97E025C1EB117D456C44786B0EECD146F092E065C0E1299C3796
	919F9CB703968E5DBCB56DC6330EB6FA1C22C22BE78D40C5FB7EE8FF3F9A89FA
	62E437CB79D1D586740EBFEF8C353BEB97EC460BCA107E3487DDF76768C88657
	CE1BC4ED1870CC6C10467EE1E0BDA3F6A34561083F9AC3EEFB33348CC6CA7B56
	D3ABAD012290058734C63843B44E31D811A5BC740AC8808A422A8AE5BC1E4751
	2C360E085E12BC020E038EA993E025C12BE715BC6A265233311D2EEAB1040B09
	1639AF9C57CD446AA6A86EC9CC4BB0906091F3DEEFBCFF0049BEF0A7E223B331
	0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="51" length_in_bytes="875" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000002A0000
	00810806000000B6182876000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A1000002D049444154785EED9BE176C2200C46FBFE4FE19B6EDA895204F2
	7D3481D4E5C74EE71AE9E592403C676EDBB6FD3C7E6EB79BCB9FC477BF06A8CA
	0A8551ED5C0FA361F472DB93D74DFF554C8F6329AB2C95BD4F334F0F55EF19F6
	60743FEC9D9AFD30EA15B66AD4236CD3A837D8AE514FB0A2512FB090510FB0B0
	D1D5B094D195B0B4D155B0434657C00E1BADC1E64D8DD9EFF983D3798F5CCBDE
	C00CF0F9717E6FF112ACD63541F7C643620EABA705978F9326DF9220DD2F9952
	736762B44CA9DA6B743577504BA3ADFC6F4DA2C532C5680F2A8CA269929B2AAD
	F5EE75971E7D38132755B5747F6AD54BF937BC8F96B31C7DCD9E58C84A4DADFA
	1A90647DDAC924D9A240D160E9A1B523547A0FFAEC6927536FDB912693E5BC4D
	F78402A07153CEFAAF300A37DC887A36862992DA2934F5644226579B50EB6FEE
	72B4098A2E136268A42186979E014063D1C9534B8F0E8A42A60D1A89A7409101
	D91874F214283A28038B8E4981320068AC09283A280A19391A46816E832AA630
	1A460103E81685A653E46818CDD2EEFA1D3EBA9C4C9C493131002B634D3EDC59
	4CE83AA0683E3196D031A90D9F0140634D40D14151C8E8F0C328D08D51C51446
	C3286000DDA2D0748A1C0DA35FD5E1A3898F2E7B9CF56114D897631F450B0A4D
	A74B190532E4CF0F6A89893B63B4F69CE764E23F20C4D562CCDF63C3E83F379A
	52E0EC353525E8B683EC26A6552FE57E9A080C8A04B231E5AA94EF97EED7E2CD
	ABBE349BBF96AC27E0692753CB20058A0633CBCF341BC8B861B497872E73B495
	56AEAA5ECAFDE17DF4EC89542E297A321171BADD13F160A4E0DF315CF4FBEB5A
	9D4E7CBFA5F51DFB6CE23A4673935A908F715EE36A18B5823C804AD5294DC412
	52CDA835A48AD11990A78DCE823C657426E4B0D1D99043465740D24657415246
	5742C246574342463D408A46BD40768D7A826C1AF5065935EA11F2C3A857C80F
	A30954B333D71AEBF05144F3338E16601A2740AD8CFE0269109588FB7EAB4B00
	00000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="52" length_in_bytes="991" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000AF0000
	002A0806000000C5EF0B1E000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A10000034449444154785EED9D6B72C3200C8473FF53E454B94E5B67AA0E
	A118A4B01222DE1F1D67629987F8B496B033BDDD6EB72FC49F3472B4757CBECA
	B1E5BCABCC5DE629EB8DE2E8CC7F2557BF9F31F09613814403C2136C03B7B81D
	5F22DDDC63A7ECE709EFFD7EFF9AFDAB1BAD55580333E107DD02DF20C9E2FBDA
	B6EC6E96A3E3FA33569AD3427478B47106B0065CDAAC0377C6F768707BF0B604
	11A2BC1200FF64FD37FFD538C812FD9AF668A30F088BEFCB7C54D61B25804BE1
	A502EB81D939B83C14570260E4979722111935670A3C1A505D456AEC69830B14
	ABF27A286E1A78A9C038B03205A9A7E2A682D70AB025FA332DE8278C45E3FB08
	7097E7BC751AC25D88FD55380ADC54F01E93D62AB026FA3F41E532CEA1E7FB48
	7053C15BAA3015783F056E812B82E451E8A782B79E680F602AEF3AB85BBE8F56
	DC74055B2B3AA9C0EB20D5A62C3D702FABBCBD7D602AEF3AA85F36FE8B6178A5
	06BD764701E6FE904233692AF03A58352FBF9CADE1E59577E649DC283279FEBD
	A0E81567E5AED1E3F178BA58769190C754051B15F83D90A203D0529CA194F7AC
	CFD1DCC3D206ED446522A381F3BC4F3088FF356283B029C1ADFB1EAD7118BCDA
	89125E1F28472094EFC85A8446BBAE23BB569FA33187C16B7108771BD6011CAD
	BC65CD53039E06DE51E4D585DB68E03CEF03B8055EAD2069D69ECADB4AA0F89D
	E98797167835506A6D52C36B9904D3061F55D5DCAD2CF05279AB5F2CB3605B07
	AEFC8A0509A545B498F3324D30A509B51A5B94570BA6C62E75DAA08D662AEF3E
	CAAB5DD3EDE1D54C401E2F32E75D0770B4F26EF190421BA554DE75E05A735EED
	9A8E84AB04B8B4D5BC34F477EDA89388F384771F78913C5873DE12F867D02107
	53B765ADA334DB3AB4C1836E5D27E49B6402B01CE54ED03A96DFA583D7EAC40C
	F667957B86B1798DC153F02CE214A2BC9601B56C59CCCDAB2DC287E8C2CE9A36
	FC130ACF2842E5B208C7CF06D0EED7237C8886B7C59EC5CF545EAF7B6BB27633
	C24BE54D06894539226D33C27B19E5CDCAE84E05DB6CB0A0D3867AA741024C7D
	64CE3B5F0CCD4211713D95D7F8FF2B58B0E5090CC24B78A7DEDE8A50D8DEE3D5
	D9FED169C374CE1B914B229C36DBC6D5AF472AAF27339675FA19C7B6626299A7
	9BED4E05DB0E6B6D59A86FEBB0FB237543985D0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="53" length_in_bytes="796" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000002A0000
	00810806000000B6182876000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A10000028149444154785EED9CD17283201405FDFFAFC89FA635535234A0
	7BF022B4731E32763A47B2AC7085B4665996E5B9BE1E8FC794AFC4F77D3468C8
	15B2D1E8B16EA336EAF2147403F164F264F264F2640A32D07D32CDBA787ED7D1
	75799F15D5903564A4D50DE8CCB09B3BD36BD334A9D90FA3B3C2168DCE085B1C
	A3E9F2D78641AA0C578FEB64CB2730FC7979D6CEEA590D20DC2FDA59D77AC1A6
	76CFDE3FBBBA75A33DC7AC0C4A7AD4A374C9A0EB09236065500A193D0C6450C5
	6824AC0CAA1A8D8295415B8C46C0CAA0AD464BB07211871339AD995EB33E9955
	8FFBD2A5C21251AF3649B057860EBB8DD15E3047ED4AA02300F3F14DDEDF4689
	A57C029FE56DF4CC50630DE6AB270A4073A5595FFBDD7475B40A4A6B19B5A4E4
	6C54B145B2364A2C29191B556C91AC8D124B4AC646155B246BA3C49292B151C5
	16C9DA28B1A4646C54B145B2FFD328E9F90C99A1BB50458041892D6932795F0F
	3E23B75132EE948C8D2AB648D64689252563A38A2D92B5516249C9D8A8628B64
	6D9458523236AAD822591B2596940CD804E4CDCDF5D7E552475F1D520C4467E9
	C6D2FF0141CDDB283545734D46D349771DD7CE48A0B4F7D1B9544349BBC3667D
	5EE83128094666F67723D2F6ED464BB74C0C4A8211991C327F5684B47D9BD13D
	641328E9D1954C09B20994D6B216D81A6413680B0039E708B20934EA4EB459E1
	FE7CA5C8DA76ED894671D11CBF1E3D3399C065D0C8314A2195E746DF6D92F146
	323D2077CFE65DDF33F582DC80125B47999E9061467B438618BD03F2B2D1BB20
	2F19BD13B2D9E8DD904D464740CA4647414A46474262A3A32191D119204F8DCE
	0279687426C8AAD1D9208B466784FC009D15F2E3D22750658B70573693E82FA1
	0CF902A13F67F40B3B728C26422486AA0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="56" length_in_bytes="157" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000130000
	00190103000000E90587E900000006504C5445FF000000000041A31203000000
	0174524E530040E6D8660000003B4944415408D763606062601080620E260720
	3EC0C022FF8041F5D101063320BF0A28BE1188158198A1098A9DA058098A85A0
	980B8AD9A098098C01087107E30B7FBF8B0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="57" length_in_bytes="163" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000130000
	00190103000000E90587E900000006504C5445FF000000000041A31203000000
	0174524E530040E6D8660000004149444154081D05C1C10DC230000031E74055
	1013F0CB289D1C314ABEEC80546C930CA17368E1BABB7DDF47FBC57C7E72EC5C
	DB5C42969053F020340845E847F80336160965B6181D790000000049454E44AE
	426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="58" length_in_bytes="124" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000000C0000
	000C01030000006CBBCEA400000006504C5445FF000000000041A31203000000
	0174524E530040E6D8660000001A49444154081D63507060484860F8FF014402
	D940D0208046020089A705E062D4AB8D0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="59" length_in_bytes="158" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000190000
	001301030000005FBC344600000006504C5445FF000000000041A31203000000
	0174524E530040E6D8660000003C49444154081D05C1B11180201000B0F0FE61
	474DE72A8E829BFC688EE2269848B86040C2DEBBA44E9AA445B4223A6222165A
	E18459785E1C1F14DCFCA3230928B7E1B4AC0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="60" length_in_bytes="158" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000190000
	001301030000005FBC344600000006504C5445FF000000000041A31203000000
	0174524E530040E6D8660000003C49444154081D05C1B11180201000B0F0FE61
	474DE72A8E829BFC688EE226987043E1F8F0BC9885135A211662223AA2156991
	26A9B3F72E09032E48FCC9F70928EE4302A00000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="61" length_in_bytes="126" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000110000
	000B0103000000A3EEF44400000006504C5445FF000000000041A31203000000
	0174524E530040E6D8660000001C4944415408D763505AD5C050C0C0C0F00388
	15B0609038481EA80E008790060916080B8C0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="62" length_in_bytes="142" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000000C0000
	001102030000009453A53100000009504C5445FF0000000000FFFFFFCA92C399
	0000000174524E530040E6D8660000002949444154085B6360000151209684D2
	4898353484816DD512380DC769290C9233A73084860680740300E7DA0A3F336E
	43A40000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="63" length_in_bytes="148" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000000C0000
	001102030000009453A53100000009504C5445FF0000FFFFFF9D9DA1AA7CC3B0
	0000000174524E530040E6D8660000002F49444154085B636000012D20567300
	D2A8986BD50A06CED04820BD124C73C2604727835A5A26C3AA554B1944434300
	1D930B4AF52DDA260000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="64" length_in_bytes="138" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000170000
	001102030000004B1DDF2E00000009504C5445000000FFFFFF00000073C68371
	0000000174524E530040E6D866000000254944415408D763608003A6AC052452
	ABC014C3AC06646A1584E26040A3B456AD82AA0702006F300EDFB3946F770000
	000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="65" length_in_bytes="138" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000170000
	001102030000004B1DDF2E00000009504C5445000000FFFFFF9D9DA1E333CFFB
	0000000174524E530040E6D866000000254944415408D763608003A6AC052452
	ABC014C3AC06646A1584E26040A3B456AD82AA0702006F300EDFB3946F770000
	000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="66" length_in_bytes="119" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000170000
	00110806000000367337BD000000344944415438CB636018C4E03F0880682C78
	D4F051C3E969381E4CB3B4CE30340CA75590A05B42BB7266400C0749D85348D3
	17000026EA6F8B6D39155B0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="67" length_in_bytes="125" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000170000
	00110806000000367337BD0000003A4944415438CB636018AC60EEDC85FF4100
	44A3E351C3470DA7B3E1B830CDD23A4D3312550DA74990A05B42D37286FE8643
	C3CA9E129AEE4532006AAB07C0B35FDB140000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="68" length_in_bytes="144" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000140000
	00140203000000F0E7F59E00000009504C5445000000FFFFFF00000073C68371
	0000000174524E530040E6D8660000002B4944415408D763600003AD55AB56AD
	8091D3A64D0392515151190C9A9999994072E9D2A59489239B0F0600BBC729B5
	52F540B20000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="69" length_in_bytes="144" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000140000
	00140203000000F0E7F59E00000009504C5445000000FFFFFF9D9DA1E333CFFB
	0000000174524E530040E6D8660000002B4944415408D763600003AD55AB56AD
	8091D3A64D0392515151190C9A9999994072E9D2A59489239B0F0600BBC729B5
	52F540B20000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="70" length_in_bytes="159" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000001D0000
	00100803000000DDD384E300000009504C5445000000FFFFFF00000073C68371
	0000000174524E530040E6D8660000003A4944415478DAC5CC410A00200C0341
	DDFF3F5A7A09D215042FA63D8843331EC2A452AF7DA5C6A8F073336AD6B150CA
	C9532CCCA7504ADBCC350BFF930106624DF5830000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="71" length_in_bytes="159" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000001D0000
	00100803000000DDD384E300000009504C5445000000FFFFFF9D9DA1E333CFFB
	0000000174524E530040E6D8660000003A4944415478DAC5CC410A00200C0341
	DDFF3F5A7A09D215042FA63D8843331EC2A452AF7DA5C6A8F073336AD6B150CA
	C9532CCCA7504ADBCC350BFF930106624DF5830000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="72" length_in_bytes="142" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000001D0000
	0010020300000097639C4200000009504C5445000000FFFFFF00000073C68371
	0000000174524E530040E6D866000000294944415408D7636040016AAB181844
	434303C86468C1189C2BD0195C300643032A234849A101E10000B16918201D39
	4CE70000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="73" length_in_bytes="142" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000001D0000
	0010020300000097639C4200000009504C5445000000FFFFFF9D9DA1E333CFFB
	0000000174524E530040E6D866000000294944415408D7636040016AAB181844
	434303C86468C1189C2BD0195C300643032A234849A101E10000B16918201D39
	4CE70000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="74" length_in_bytes="124" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000000B0000
	000C01030000008E67D5DD00000006504C5445FF000000000041A31203000000
	0174524E530040E6D8660000001A49444154081D635068604838C0F0FF018804
	B281A041018D0400ACC707406FF6F2910000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="75" length_in_bytes="125" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000000D0000
	00100103000000F76D677A00000006504C5445FF000000000041A31203000000
	0174524E530040E6D8660000001B4944415408D76358A5C0C050C0C0F0838141
	012FFA0152B64A0100861205A51FE7F2A00000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="76" length_in_bytes="481" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000000E0000
	000E08060000001F482DD100000006624B474400FF00FF00FFA0BDA793000001
	8C494441542891AD91CB4B025114C6BF3B332A6333A989540699653E02C17C5D
	14A345F470DDAAD7BF5021FD03B54DD761D0B65AB56ED92208DA852DA25D51B9
	7282B0521CEF6D110E65136D3ACB73CEC7EF7CE703FEBBE8746A3F359D3E0140
	CCE6A2593318CBA6643B2B3914362A28BE8A567DB8EDDE11CC84BDAABEBBB1A4
	D9B7D66A8AC3CE8A66D41FC2709C262481A7FAFB7462B332B89C6C3098A4F9BF
	AC2139953E3BDC1F63514A7994527E7AECE3F15CFAA69BFA8DD8A12DCEBC9066
	8BA0D92298CBBCC2A5B68742F1CCFCAF42A58797D65734D96AE1468F10A0B056
	53547BBB682AFC4A038044A48144A4010058C8D6A1AAEDE1F1249DEDEC1B718C
	04868E3657B5402CD42000E071E9484EBCC3E76D8110C0ED60B68B2B3956BD7F
	DA3388DD340028940650280D18A7E573752832F30727333306D11FF41E6C2C6B
	E10E0D00C2234DCC67EBF0795B9F9E08E07632CBE5B51C7ABC7B3C9000401048
	75A7EC11B6CB9E6FD14822D74509BA6C650D9B155C12191345FE86EE6CCC2A40
	69AFFC66317E51A99C3F03C007C40F77771DFF36FB0000000049454E44AE4260
	82
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="77" length_in_bytes="186" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000000B0000
	000A080600000062F0A4830000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A10000002C494441542853
	63608080FF38686439A812DC14C81018C6AB185921511A4872C620504CB207B1
	061D5191020085811BE5B4C65CA50000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="78" length_in_bytes="1552" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000AF0000
	0048080600000080D3A54F000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A10000057549444154785EED9DE192DB200C84F3FE4F716F7A6DDA92A19C
	402B580C02FDB84927608CB49FD61827E9EBFBF57A31FEDEC394E348EF31CE15
	637034EBC9E34E3AD3C0AD051500AF03AD07CED631C9E724935AA1F330BCA871
	B313B9DB782BC47B32073BEA3C0CEF3B81BB55E493A2DE74AEDD74A6C09B00BE
	79CD7BBAF3266D8F5BF3DEE43E11EB3E6BF861E7451C07E9E31D8AD36344E243
	FA30751E86973999186B1F57F3A0C530BC48B5217D3C244BDB46F21EC3687C4F
	EB3C0CEFC982456C7B5F0986E145AA0DE9E31D94D36344E243FA30751E869739
	99186B6FA7DB4D9FCF0306F4098AD42FDFE74DD577DAAB261CE23AA7E5448A67
	84232D3FE5F3040ABC88709AF8D1EEDB7547A1AD3DBDCBB9C8CFF107E4AFAFAF
	EF91BF724009C21BE03E3DC6567C3903232CBD8FAD9998581CA3277B1F8F001C
	CEEADB5911A8182C699CE44534ECBC69C22D804F77A5722DA609E0B15DD290E9
	B889232D3753E00D073ED3599F72DCE5F0DE0CF00D579704F20CC7DD02DE9B01
	D62E7927B4CF04B775C39617CEE7DF8C45B634C66D37713738EF6C70B7813777
	E0131C2762786FACFE7D206B35BC748CF61AF0B276CB8DE3DCE4BC5678B52B73
	DEAE99C4B4DD867292497F6D42D1EE63A7A2D7796B5C48CB108D8580D7E8AA5A
	426FD8E74D31F62C1B6A4E2D8DA5E53AE09D00AF96F413DA59CE9B3FD82AC1D6
	F2F438BCDE5941139A125BBEE6AEE53D17D739AF763373C2DA588B512B8095ED
	48FE676C93B95936D4C4955C6AA5903DE7CE85ED397EF5319A0679FB75CE2B3D
	1D296F72BC3A97B40C580DA3F5FCFFAD238B1F4C2CDBAE853707B684D52BBCB5
	C2B402B4B27F4D0BE9FDABE1AD6D2B05BCEBF67AA5DCD7DEBB1ADEDAFA2AE0DD
	07DE9646D7C2DB5A2A788537D6BCF6AF914939DBE62391E5B72B5A4FA0B43BDD
	956B41F4DCB1DB300630F2D9060978DAD780B40F5FB44048134361D9B19FD72B
	47FE0005D168E5B2A13489C7E0152B67DD32CFC4BFD6B9BC7A485713CFF19773
	4F1F779DF12AED48D5B6F21E8157135F6BF7EC6A5A6C4FB533729820667C24B2
	3686251FDBC0DB4A2E23F196A49CD897915F36BCD212C492FB6DE0D5D65B96A0
	A2EFCFF518C300D8F04AEE6BD16E1B7819CE6009FCB6BE8CFCB2E1BDC67957DE
	F030405F397FD66E0E1BDE70DE1DA8703087705EE38FF2312B9EE17E378F116B
	DE89F0329CE16638B5D819F9652F1BB65DF3E657522DB15A3BC335B4739CDECE
	C861AEE9ACBD5E8B0E53761B1C2C012D39AAFE66AC6590D37222B9A615E83446
	FEDA7AC2960AF0F36A3DA1D69FE9B81638A2EF73CFDA673AB04547AAF34AE0A2
	972BB49F25B8E88B018DE63EEF370B608B663478C37131502CE2ECDE7706C096
	9829F0B6C0EDA96A4B00D177BC68463462036CD17318DE70DC71782C82EDD897
	09B025BEDFE7E5FC3F82B5938E54B52590E8DB2F2443A3D91C49FA52E1FDB195
	F1EF3700BCBFCF280CEF3940E6CF00D8926B8EED3666CDA86A4B40D1D7EEC05E
	359A0E6FC06487297286E58C026FAB72BD56F54D00313442C760E695022F7342
	3116E63A9127C60AFB7DCB57FC385B9E58B422D17E211A1F6E34F70C9D99FA85
	F3920A98294A8C851528055E4645A2D51FC262C25AF284E69EA1B3655E5A5F0A
	BCDA49A29D0F5CE49474C96454245AFD211ABF10D0DC337466EA17CE4B2A60A6
	28311656A01478191589567F088B096BC9139A7B86CE9679697D29F06A278976
	3E709153D22593519168F58768FC424073CFD099A95FB7F3A201B71E58F48CC1
	0C3EC6D27FD3AC47A39E637AB41882374D12A9C864F225CCC8183D81C531B843
	E71A945AE6BAF5EA3C4B0B08DE12B072B5F19E5C6D05D26ACB8F9915608C8B41
	8CAC20AD3AA7FEF92B530F085EE9848C8A44C760061C63D5970A2357C7967BCF
	CA3904AF74B9E859D74897A45981C5B898E396796268C4E245D3F01799D0A9ED
	B975ECCD0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="79" length_in_bytes="1345" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000430000
	008108060000009BEA07CC000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A1000004A649444154785EED5DE172F2300CE3FD9F8237E53B38DA0BAE13
	C99E53423FFDD8ED46D324966559296CBB3D6EB75BC5D736CDFD7E7FACF8B5ED
	6F146B0910CF050446C32A8121307C8D1133C40C3103761D9589CA4465A23289
	D874698634E35A9AF1CCE75601500BD852F9B532710FEB6CB068DCAF81D19EB4
	3776ECCCD85F78D326F3F3AA80B42CB0493D94C9683062447BBD9D6795073CB6
	1C364674BE1F652302C02E3E0DA356610893645740DB173360ACC6100F082FC6
	2960D885BE59320C232CA35F65E3BDF85766B4739E5D32AC584E05A357666732
	24C208170CCF7C5431C363886B766ADEADD8B7DDDB3FA519194447FDDADBCC19
	206C6B781DCE0ABCDB5A7B37464D179A67942DD4C96C9023E68EE6A298515116
	282044DD91E6B459447B8DECC35644D9410D6D1281E105FCE1019AD3650533DC
	B2CD0611D50C060CAF8EA3AD3FC20C9B80A598310A9C0D32AA191FC22A664C78
	B8930575A40BFFAD66A89B3C0F476FF7893AC42CCDF8605F96DE95DD8475A7AE
	6BEC3C99633AD3C1585681919DA722E39ED5F6F683D62A6BAD6821D6679C35CE
	052B9BD1AAFB58102BC6A139C48C46B0CAC0C8320565ABD28EA3B5CAC0400B9D
	A505D97DBCBA4F36A355F7B19B8F6C350B7C19186C50597FE2CDCFBEC626AE0C
	0C76C16F8281125606065A284BDDE8B13EBB8F9FD30C86552330105062C6557C
	465440C58C404F2E2B137593B6DEC847F98C08B2C7EF6899A084891933041489
	937C06215E2C886C49C8671468971CA8616E9980B27457371968070BA2340368
	010B10F217FBC9981D386B9C9891507F96052CB8977BDF8405887DC2AE6E32C3
	8E673585A535CB82251C68168C95EE2B2B939582CAEE456048333ABF8199A554
	F68C91BDAF424051AC5F2F934B761336283143A756EEE30E2CA3A419C5477804
	7C9980A285F4745C4FC739AD608FD5FA7C86C3A80A0145A52CCDD0D944671358
	0570003ADCFCF53AAAE34A01456B9581811692CF90CF90CF48971B5B5EF219C5
	073524F6E98CA289D9EB11661012F45A362BD66560B041553EE972DF2F4D7EEA
	F0E73FB9130503254CCCB8CAD944CC002A8A4A6124EC6565C2768F6F0A2802AA
	0C0CB4D0A8DD455AE6B60EFAFEEA0EE6F7E4EDA1EF304736A355F76D400CE94B
	FC2505E6312272B14B30A3CD62AF8C58E6B1E3B635DB64948191654ABB791BC8
	E85AC665DAF90EE5990D222B84E83E54E768BF116658462EC58CE853AD0A9FF1
	C11684347B3D9A915EE062C6BB78A5191D2FD0F30488A91186B602BACCA91505
	C07891529F811CDDCCEBAC0365C721567563F1CC07A262D57536B8E8B8880731
	DEE3D85D33C122AA7BFE620BB2EA0FB65B0D60E2705B6B341866A15186AA81D8
	001D01E2C538050C16CC76B3558CB0F3441832050C862967003162C832CC3813
	08A664BC56BCAB274B7386016788255B62B613B587B3438B65CC0A03400FCC6F
	3022A221A769C60A40D89269136B85B6AC4C2C335602E209C8B69FB6120E66AE
	AA4C7A88B3B53D7B9C05C31550CFEA321AE189A4B5F6B3038CCCDF03E3238995
	6793D54AA3058B0663D86E02FF3D6B96C58E30A037360446A6343C9DA8D8F88C
	390446F33FEA0586C0B83FBC321333C40C31C32D8DB4CF506BF5BC78F2B5950D
	977750F3925FF6C6F315C0F807EF22294148E8C1620000000049454E44AE4260
	82
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="80" length_in_bytes="1481" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000AF0000
	0048080600000080D3A54F000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A10000052E49444154785EED9D5172A4300C44E7FEA7C84DB34B2A4E3904
	B05A7E0633F4478AAA20CBB6FA490898495E9FAFD78BFA595CA9BE3263D4396C
	1FD338A345660CA5070A6E66232577A80DD94F0CD4759CB23A64C7113A21F052
	C59BD8907DE8F0DE553F04DE05986C0666C719521DD2A3986575C88E23F4C3E0
	2D00AB8BCAB41AEA1CB68F819ED1223386D20385975A94FDC4607B7A9C107889
	EC237C3C5DCCECFE89D8133ED4F523F0AA93DADE959560008197C83AC2071190
	27FA20624FF850638FC0AB4E6A7B575E8201045E22EB081F44409EE883883DE1
	438D3D02AF3AA9ED5D7909067E5E2EF4BE65298B2919F894E396084FD97B5D6D
	7BF9A95F76ECC56FFD2E0183F78ACB0691BDF6D17F15A0C06D3154CFF305F2C7
	C7C767EFCFDA690688D6C2333E3D2606664FEC6BED7B395AC6EF69B69920C484
	8B0F0260C316836D9638D1E01EC1BB6E4BB1CA5B12A007E09EEC9F45CCBBAE23
	13FB11E05E0AAF2BF0BD2A6736D946817B39BC598033D99F0DBEC7FD4E3225F6
	23C19D02DE2CC0866AEECA3D1ADC69E0550156B2DF90B39047627F06B853C1AB
	026C285928A9789E05EE74F046018E643F2586FDC47BDE33C19D12DE28C0866A
	AECA7B36B8D3C2DB02D895F73A70B7627F05B853C3DB02D895F73A80EBD85F05
	EEF4F0EE01ECCA7B1DB875ECAF04F716F0BA025F07EAD1D5ED6A706F03AF019E
	0BE02D7097DF159DCE38DE0A5E033C07C05754DCBD395BF73DBF5A1CEA23913D
	7ECA465A0BF7F931B097F8F768A88CADC15DCFDDD2D8F06E45EFC1BF3B1BDE02
	7A694B6AF00DEF83416C89BF75DEF0767C9DC86DC39876200AF2D9F0BA6D7075
	C5FE6CC1D9F0AE6FD4236DC3A6DC4AA3ADDAAA7C452B85EDD84AADEAA472B067
	AFF6BCF53AF1EFB0AD17A906E58EF6EB44BAE31ED435D73AD3CF82BFA0FCFEDF
	26EB637DEE34787B2B65FD78A4D7D753C713313CA3BD50F4795197802D3FCA8D
	D8517089C02B4179475B22BE34BC6ADBF0E72A370BBCAD77EEEF08D4997B220A
	000DEF167B4A4C5C79D586EFA6F6AEBCE2B35CA56D6855DE5999B9D30D9B52D5
	AE7A99A1ACD19577D6AC80D7E5CA7B61E55532D2B67F9F03BBE71D082F51190C
	EDFECB0B22BEF40DDBB44F1BEAAB5E2F5444D5E85DC3DDC71331AC351DF5944A
	89F3909E176ED794FD9C6E7BA71B365A975E804BE5AD8F476FD84A02FE1C7B17
	70F44AF874926875EC6FF3C33F232BB0C20C5A79B75A85E8E52A6AA76CCEB6B1
	0FF044635FDB8D0258D10C8397EC71950DD83606E888388D0058592702EF11B8
	99AC563660DB7E787B34A20156F4EC86D715B71F1E45B0196D498095FDFD9F97
	F940FEDEA43D59AD6CC4B67921098D4673B4F3BA9A83F7CFA38C9D0F15BF9B5D
	1DD877DB9BB21F0260A50831E41EAC9AC86A6543B6D52BF05D351A0EAF61D261
	72CC623143E03DCADCBB66F5930022348AFA20E38AC04B2EC8BE6255C771223A
	ECE579C5F78DD9CE1DE1EEFF93DDBAD1B128E7C31BAD9A84CEA4BEAEBC500293
	A2D8572C811178898C8C66BF858D09ABC4291A7B4267655D2D5B04DED6243ECF
	03E79842974C2223A3D96FD1F84488C69ED099D4CF95174A605214FB8A252802
	2F9191D1ECB7B03161953845634FE8ACACAB658BC0DB9AC4E779E01C53E89249
	646434FB2D1A9F08D1D8133A93FAA52B6F74C3472F22323EC8CDDB57FBEF3B64
	34CA8CC968D1056F596424234B915FC31CF191D998C7C42B74ADC15ACB5AB7AC
	CEA3B408C1BB066CDD6D2C8BDBEB408ECED563466DD07E6310473A4855E7625F
	1F493D42F06E4D486464D407B961FBDA6F157AAE8E47D57B54CC43F06E5D2E32
	7DCDD62569D4C6EC375671D7712234A2786969F80FDF7826AB658A404C000000
	0049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="81" length_in_bytes="1408" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000430000
	008108060000009BEA07CC000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A1000004E549444154785EED9CEB5624210C84E7FD9FC23755C7236D860E
	54418A6E66373F3CAE72FFA814A1DB9DC7E7E3F1507C956E3E3E3E3E77FC2AF3
	EBAD5502E23940C230AA4A1809C3F79854462A2395014F9D0C930C930C930C93
	91343D3D233DE3DFF28CE77E9608805EC086CABB85897B5967178BEABD1B0C7B
	D32EEAF82F946155506FAA1B26079DDF189AF9794775D4E15014E17EF7E48242
	A2556E07DEE169574F1187695A03F58C6416460DF64E201E081B122E0CEF9733
	305E62CF9CBE77006114B11486674C7778086B964B61B42478259011452C85B1
	D254DD04A9F386A33797A1A375C62FEC31E5B58F9E32B330EAF4A056C3297D50
	192882180152DAA231984DB95D1916F88C87A860F44CFE07E455CA880051C168
	1DFF0706150CEF345199AA0A46CBCF0E062A184C3CDB3A231EA282714B06CA82
	6181A8606CAB8C110F51C1809EE19DE1ECCED6B29F69578EC3DE29A382419D26
	3369ECECC219536D2559CC983D231FF68C53561678D8639320D46FAD90966251
	3F7528788958B30F86F60E75D8A37B54192FA1AE5A283BD9D9F1D8FED97AEEC9
	323BB9ABDBB18B4C65188361A1A532CCC3DFA530223BC2841CDB3F5B6F290C66
	41913AADDC63246944A0A46FD4228B456D51C264D37BD45733F19B6D78753B05
	8C54C6407CC9C264B5525219207F6001B11B95CAB0C0596AA81E3227D41E95B3
	2A88CC239591CA68FC911E92E72EE58A304121240B13345014AA02069A830C06
	1A285AAE8081364C06030DB4030C3407190C3450B43C95911968FB6FD36B75B1
	6A61AFF7B23049CF18B81EA7670861B1211151A82C4CA23B8FDA2B6020503218
	6820B45854AE8001C74015762957C0401B2653C62ED022F348182B9E67447664
	97B66FA38CB7F20C644ED1DD57C040734865ACF08C548630DD861276FEB6820D
	9DBCB54E6C547A467A46BE37F9D6C0DF2722781E250B133410324854CE9A6564
	1E32186831D172050C044A06030DB4030C3407190C3450B43C9591EF4DF2BD09
	0C574598A0508593401D5C55AE80814C5E06030D1485A68081E6208381068A96
	2B60A00D93C14003ED0003CD4106030D142D1FB991B7C6421B2683810652C060
	FA88CC4306839968A40EBBC85E3DD4870C061A2802E2D996ED9FADB7F40A1F5D
	2C6ACF2E329501EE3008F4F1C098AD7877BD4B955106DBEDFBB16B83FF27DFFA
	4C0DB2B9C6D2A828ED6E05B8C6F67B9165E636EA19B6FE8F4BD75FCCA0751D56
	C6A37DDBB9316D47E651F77DF9A731310BB2A1A18451A9E03C953A2647266BEB
	8EEC0833C6AC6247E7F10248058359205BC782787E84E6889F853C4305637447
	5A606A104A182D733EE519AAC5B0BBDF3B359E73B11FAABA42195E18CA0C340A
	D3534401A282E19D80B66F198C158A50C3F0366C8981CE2AA3A7881A862BED4E
	9E54E654CFADFEFDF1B3CA406794C180B0063A0A83490CB750060B62E4D3A947
	13347B7FF9F9F71DCA5801C20BA9ED95B1120403A407E852655C01A207649BD3
	E44A10230A5962A0BDD3E40E10AD63D99AE6E9885519682BCFB81304A390CB94
	B103885E165B1FC53203F5B2BC32D848AEB0AAAEBD839450392571AA30A91FF4
	EC04A2F718E0254CBC147736B5AE89AFDAE5997E6B65B88F10EA05CC80B0EADA
	4D112337DF9367346F74C47B8B5D41B04FCBA42F9E9F3066247C451B3A4C22A1
	5187C8150B9B1923617C3F599FF28CA83A76F68BF40CA38A849130FE3CA236D9
	34D034505F1DA98C41657C01D4EC1D100A4A9D1B0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="82" length_in_bytes="1535" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000AF0000
	004708060000007185179A000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A10000056449444154785EED9D519ADB200C8473A5DE3837DD36BBA52504
	D0C848B2047AE897ED226318FD8C65ECB48FAFC7E381FE79856AC4A27D661C9E
	2B4DADBC70C002973B684EBCA6D8D9B71CF4C5EB504DB9F168BFAF38085E306C
	785ECE803216CBC91D3A79E30082F79BF2BF9AA2A271E3D17EBDC69D7295E1E6
	951BCFC92F046F490C2741578EE10C3C63ED1DFA4A4EAF1C83E6168217EDECE4
	38CEC23E5927C9B943F0AE2466E558C989665FEB4EBD92CB956347B983E0CDC4
	D389D7484EEA3ED71D827725312BC766F2E84563A9D14A2E578E4DE75DDDE721
	8ED7488E259811CF95CEAB0C754428864EC778C2DAF6A1B1B82178774A80D65C
	3492A335D65DFAFDF7F08132A032E176DFEE94BF4B24FC14AD7A7BBB145FF5C3
	8C914EE56159C5226EBE1209DCB58F74DEF1CD250A2EA561DDCF37C8CFE7F38B
	FAD31EC401901A50EBE89CBE33566637423347353B1467AFF659BDFDB108900E
	5F312B009F00190AC0095AD48654B84139A3F4A975869CB79CF80AC06852D138
	6A72D9CE7763547B34AED4A65C7067CEDBBB42B3E04D079ED775B9707EF4E196
	0AB52B531A5E76DE2B0E8CAE56348E9A5CB6DFEBBC2BE0AA3BEF15804F002A17
	DF9AE316AE2856969D9703309A54348E9A5CB6DFE3BCAB8E6B0E6FD6C0FF4139
	79F149816B5636D445F66C17024D2A1A97CECA77564A3354FB5E9C24B8B7C09B
	0EFC53EF5190ECD62E0DEE6DF08E0046938AC6ED068087F9A0DABFDD2C551700
	F401041247E92176C3D61BCCAC84A00616B91D0520F21C579E9C21E0DEEABC9C
	5D8836892725DF1BC01CED354A05D38714C82A3ACD8139007883171D8F36B82E
	9CB77560449C13928FE870470CAA7D81B7CE6FB9D791F80C0BEF1D49933C270A
	80E439ADFB6AE145AEC0A398918B537352BD61EBEDFF52032A2F7320711973EF
	3EEF0B9E1568DB5DA9764150F975092F3568EFEDE9BCF4971A5AE87B0B81CA73
	C25B5FB3F267F87B609265435D23BBDB6D185D1E22B282BA417185F6B3944511
	E7DE1BF36AD9D0DEF0B987770640118882C4737BE4B201D15F639B2C4CD9304A
	6ECFA53C43DA1B5BF43D6D2A0775BBC40D5B28E7AD1F2BD6C97F2BBE83BED8D2
	BBAC465C7C688E8E85B7DE126B9D38F26537FA56DF2817BDDF1F0DEF28D109AF
	FCFE2D7A05E8693FFADDD1F08EEAAB84D70FBCB31C1D0BEFAC54880A6FD6BCFC
	8713E16ED872B7E13E67A5CA07EBDD86DE822F408FC6DA3BE621B5E1BCF2623A
	B2CF4825E0EEF6A8578EFA010AB2172F5536D430A20F29DA2D493378BB2BC7AF
	19BDE5915A18AD73F59C2CF2FCDBB14BBDFE581642FDD9DB91AA8DE1ED670BE7
	A5924FB54776356A6E56ED121A16883599E1E861E2BCC8807E4D1E5248088F8C
	61E798998633EDDB874A5265C3D51773DEC6A3B98AA46AD98477BDBE92D0309D
	7750FCA5F3AE034ADD708DDAD3793BFFC2BAA4F3DE79C323514EDC397EE93C68
	5EAD395A67CDEB812A833178AE79D1DD868F5D1DCD5524B9E2392B32633F4B90
	AC7981FF7CE5EA1730B3E63DAFE6ED1927C778FE2C48F82B4C9C7E599BFC54C7
	12AE419D63F776090DBDB16202AFC5A435CF2101B6E6F876EA9BA3B5BEEDEEA4
	6CCEC5152FEA83412F57681C6765662C5613A2DAA37156BAABC36B35913C0F06
	EA4E3AA9C38BAE56346E27F1BDCC05D51E8DB39A973ABC5613C9F3A4F38AC38C
	AE56342E21958714D51E8DB3CA9138AC5603CFF3C8431C4D537578D1D58AC645
	1338C27851EDD138AB39ABC36B35913CCF794EAC0E2FBA5AD1B884541E52547B
	34CE2A47EAF05A4D24CF230FB5774DD5E145572B1AE75DD088E343B547E3AC34
	5087B79E483B796F625889EEF93C9172A40E6F11A3BCD3D2C25CB77B4EEACE63
	8B9A2375785F492FE0CE3E778623C2DC22E6481DDEA8AB3A027052638C9A2375
	78B3E68DB50B10A9E6FD0D5ADE3FB5E9157D3A0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="83" length_in_bytes="1343" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000430000
	008108060000009BEA07CC000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A1000004A449444154785EED9CE17263210885F3FE4F91376D3799B84B5C
	F51C0822B7E547A7D3868BF27940346D6E5FB7DBCDE3ABB9B9DFEF5F19BFDAFC
	56B1BA80780C503084AA0A46C118D798524629A39401779D4A939F9A268FB85A
	BF60FD9E591D74D3259BD04FBA51E9275B174AC11875E316205259191542C168
	81B7602C20FA67322A2414460F331B90501823456502120A639666598084C258
	DE1388A6F5D42E130A0315E0D30A0985C1EC42278184C240CA905BF8893E2414
	06A38C93404261B0CA38058482E1D58E6B947102080543DE6C6B575702B03E3B
	5A8C9DBFA3DE2A90072DCB11BE3FE3B0FEFAC5D80902CEC922EF59EBEDE5AB4F
	23A6A163C61EA957FE0E5EE73183ECB2E95772743A962A46F3E86148153EFD20
	07ECEBD69A8156BD4FBFD1CFECD86F2A1885CE067BC26EB492232558600CA17A
	05C94E48331ECAF1996A6663207F6E69A20992B52D65883AD6E7F8ACAF6155F9
	236AC62C58B4DBCC769F7EEBFEEB87952CB2635707F9E9571FF96D4262FC5EBE
	66B0BBBFDC6560A7397BC38C21CAD8A015647C20596B7689912D9AE3A57693CB
	C040D44B196CC24FEC58C05E766E69C24E48A310D6A7979D1B0C4D90ACAD5790
	6CDBEE06839D380B6274205B1550362357E3BBC1D004C9DAB2805133F5EB94C1
	F428086E29431E0C59C9223B441D3D6FE91857F26753E7ED2C649964D4332C60
	3670E4CF2D4DD0401680ACCF74302CC1A2672E0B839D3802F096C3AFA3367AA6
	94217781013416D096025ACA607B60A31D0B985501F257BBC98EA60B1539CBEB
	6825D3365DECC43550589FE9D24413246B7B5918ECC45910DAFB8C3AB5BE8A5F
	BA34296518FB07365558C0A58CCCED38BBDA1ABB52065871F6468C4D9D2D0735
	CD8A67B5753B9B640D5033AF82B1E3A0C6163BD54AD54DD7BFBF566501B3C512
	F9734B1334904611ABA3F9AFDD4D58C0A58CEA40E79FEA92EA08CF4A5A533B58
	9FE9D24413246B7B5918ECC4591075D3D5DD8FB080D3A5093BF15286F1468C05
	5CCAA83EA3FA0C787E4A97269AC2C8DA56CDA83B50BE165CE208CF4A9A4D91EA
	40AB039DFF3F3EAB364D4FB75226DCB634B2F6B6D5C060C646FEDC60A08198C9
	3217346C01B5D8B9C1B0048B9E61017BD9B9C160278400BCBDF7F9C1FB26A50C
	5049D182953264C7AB916DB4AD76CB6C2B6FFEEE152092A0659C0663D91BBCDA
	14C63F3ADDBAA5093319AD4DBFC2B3AD975D88DE4E2AEFD9FE6B2738B36727A4
	194FFA1C05D27CB163F7FEFE0B5F33B968DB198015189452ABC6EE32CA58A9C0
	A28C913F37183B5453CA90FBBEE840AB66749F8DF3EB7713540F985E84AD37E9
	6B86E3EEFF64F2EC27D0A7314143E468C3EBDE20A0CA1A298DDC76EC1CFDD1BD
	CDC7EB13EC99F8864DA82558449DF529D5E005E2E18782A16D69D9A02C76BB40
	84C3F854193B4184C3B02841AAD2BB46F429169A265665EC564483120AC3A28C
	2810E169A25546248870181A6544830887C12AE3048870188C324E8108878194
	711244380C74F7B8BB8F40AD7BE8D63A53C66945A4E933B280084F935E199940
	D030E4A499BCCABE6BCC6A0713DBF3DA4F0261821DD934656453C447354306B5
	BC2F1CDC5C670541A7895509A36BFBD3DBE76A7BA5D3C403486610C794819A9F
	53AF9732FE5C046B0AE837944B22B269746ACF0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="84" length_in_bytes="1300" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000AF0000
	004708060000007185179A000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A10000047949444154785EED9C6B92DC300884E7FEA7989B6EE2DDD296E2
	C836A00681A67F6C4D65AC07341F183F26AFAFD7EB85FA3B96D2AE6599A3DD83
	E36531B6C4C23207150F28B816475AEEA01CE23A3250CF3A59E3609D87881304
	5E54F14638C435F4F0568D1F04DE03186B065AE711523DA4779A59E3609D8788
	1F04DED62E58DB86063FC221AEA187BA6AFC20F012183D30D46C5E3308BC968A
	3BBA606040E7036AD1B06AFC20F05A04E39C35A0EEA43B04DEAA99BB5320677C
	A91A3F08BC33C2712E2BB0950108BC5533D72ADA6EF3AAC60F02EF6EC1A43F35
	CE06BF0F17669FB2B4809FEF19EEFEEF11E8BBFB3CBA2F3CCB4FFFB0E34ABFF3
	F30018BC88530F2B5E8D8A77F55E040260C953C05FB8DFEFF7D7EC5F6FB41540
	C2BF0EDC19EDFBD8CF7274CCBFE2679818880D8F3510005BC1E7BC35E0A3C1BD
	83F7DC967EB710287867019EC97EC23B07AF457B0F7097C23B0B30219C83304A
	3F2F7097C36B05D892FD51C1DA7D1F8DF69EE0A680D70AF0EE9054F7CF1BDC34
	F06A01D6647F7508B2D92FD13E02DC54F06A01CE1654DAF3D38347819B0E5E29
	C092EC274C3E177477DA47829B125E29C084D3074EABAED1E0A685F7096056DE
	75E08EB45F016E6A789F00B65608CEC382BF0ADCF4F05E01CCCA8B055093D0BD
	F62BC12D012F2BF03A50A56F6D215F1BD0ACF59474FF249A6661F458BECC9307
	E251C53DBE6B8526E2B34CE56D894080D703BCA255B8DAB34CE53D03FC64388F
	FB80DE40429F59AFD6EBC13DEFFD14E3346D03E1F581F10980F3F16878FBB89F
	017FB29DF08E52FF83BF23BC133F276AE23D651D8FFB546AC24B78CBFE370284
	97F0125E2503ED565CDFF73E9D5DD9F37E707F3B8283955799757DB6B1E7F5E9
	659FAA583B4E78092FDB0625036C1BD8024C274D74E5E5430A423B0DEDCAB641
	FB787818EEA8478277FBB0E765CFDBF890BEF5F6FDDB3A4F78B5C5517A81C171
	58D8B571F27CC3ACFDE073F4D97F970E5EAD8819C65FBD2790C1362F1B3C0B9E
	A63085545E8D4157F72167D7F8F4F9FDCD7DAB16E80B3BCBDD86DEF634F0DE89
	8B10DE1AB05DE621F445C33BAAE01ABDD3C0FBD4A86B9CE2D8FF7B62440140C3
	CBCAEBD5D86DB62E2BAFE1090A32E333F254E9826DF68CE455795B056EAC883F
	3DAF1C35F76F11956136383BCF47E88B86973D6FC6729CD026E419D0B3E0690A
	489A0B364465D038FE696311FAA6ABBC114562161444D598B5A1FA7C8486D958
	F96B0FECFD8EEAF135D95FE982AD42AC354120B915224A1B879CBAC32B3D5D49
	C76932936365A755A9F6D27151BABBC31BE508F79181BA934EEEF04AB3553A6E
	27F1B3F822D55E3A2ECA2F7778A31CE13EACBC7098A5D92A1D4748F1904AB597
	8E8B8A111CD628C3B90F1EE26A9ABAC32BCD56E9B86A0257B057AABD745C94CF
	EEF04639C27D3EAF12BBC32BCD56E938428A8754AABD745C548CDCE18D7284FB
	E0A1CEAEA93BBCD26C958ECB2E6845FBA4DA4BC74569E00E6FEFC8D9F96C6244
	899E799F4A317287B789D1DE2D39C3DC1FCF1CD49D6DAB1A2377788FA03770EF
	3E7786A3826F1563E40E6FD5ACAE001CCAC6AA317287973D6FADBB00957ADE3F
	EAB6DE7ADE4899050000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="85" length_in_bytes="1179" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000430000
	008108060000009BEA07CC000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A10000040049444154785EED9D6B4E03310C847BFF53F4A6C022824248E2
	B1637B5D757EA0429BE7B7E3B137A0E5F1F1783C3CBEDA30CFE7F3A3E2575BDF
	6EAF2E20AE0908A353156110C6DC63A80C2A83CA10B30EC38461C230619868CA
	747A063D839E41CFA06718CF3768A01303BDDE7AF9C39D6B13ED90C6F2DA1FF0
	5404029F74F591A1F189BE6D0FB362C8403066166105D2FAF5635609190846BF
	8113084D195581A4C29881ACA4905418A332760A69067BFA7A85A0B612807E55
	B0DA8C7AB6C9EA22156281B1CC9C519E31428C0282C87FB7C75E04BFF71C91CA
	8834D513186349E1060385E9AD102B8C6978798589C65B3C815861CCF69DAE0C
	EF90290943A30C4F202561A09EE19D65AC301629F9FF2196E52A9FF439F1102B
	8CF12EFBFBE7D99B968D5995310B196D2185CE3D6BB7AD3396D59970DE31BAB3
	769CF1A26881B4FE47AF1615AC6ECABCC6D28E73A28C7E2EF1D45BBBB03BDA97
	83812E2802163AB7D48ECAE8CCC90D86443D4211DA5B09698D6E3022372B8D2D
	6D1285E606035D90B431CBE79A34BC1BDF0D8665135E7DA462EAED9431BBE741
	DE7B8B3A03554B088CBB3D035181B4467AC63BD419B786895766B08C836E3C2D
	4CA4892C9B44FB9483812E3CA25D39185486A60E0E6C4B65F429F1E748F24F01
	05BE1752744578013A26954165ACFF54BB5439CE6C12982150BFB8DAD133E819
	F40CF198A15C986862DCBB6D3918CC2645B28997D2C478F49AE815C6210C9E81
	2E52F42BC8575A23B3092B5056A0A2C9970B1329AE233F2F07831568910A94CA
	603661366136D1641F7A063D839E41CFA067188BB87206AAB992DE6DCBC1E0BD
	8951D654462038CDD0BB0B21A62DEFAB18311E1AA2523B3718D2441110DA98E8
	DC523B3718919B95C6963689427383812E48DA98E573746EA99D1B0CCB26BCFA
	489BA43226294682F6EF6122AD83F675A4AFED6F6DDFFF4D97758CDF7E6DB006
	D22A5D89BA755CA99F66DD52D9FEF5F9FDCFCF9036BCFABC5F3B32C60863EC7F
	DB337790C56FABC5E12222E3F530A6552BEAB4C864596DAC6A16C3C40B469667
	F420FA67FB2117220D06B298D3362388B230A29531037102E3653D6305E204C6
	ACA4289F4D76204E61F405DBF7F75E067AEA07B3FE1208EBC3519795AA170C6F
	CF404058612C8B382F189ECA4041689E5C8D94ED6E61E2A58C0810A8B7B8C1F0
	504614887418A7CA8804910EE34419D120D26158959101221D8645195920D261
	68959109221D864619D920D261A0CAB803443A0C4419778148872129E34E10E9
	30D0C35BCDFD8467DB12F726772BA2014D85613D8FF0BCFABBB152618C9E5145
	112A65F48B46E855CF1A2B75207B737F227D3545A894319E742DCF078127D257
	05A14EAD88FCABA74F3703F58291951DB4F3C09E710AA2FF858C769159ED09E3
	EB9FCE690CF413EA2A1950185A9FCE0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="86" length_in_bytes="112" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000010000
	0014010300000076C0C5E200000006504C5445FF000000000041A31203000000
	0174524E530040E6D8660000000E49444154081D6361606920060200BB3809D1
	B798CD030000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="87" length_in_bytes="1315" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A10000049549444154785E
	ED9D5173E3200C84F3FFFFECF5AD8FB9B31B323A6A60B105AC95ED4C9A69AA60
	D88F95C07192C7F3F97C44BE3D1EDBF0828F31FA003F617CA15DB801941383A7
	A1282E9513034C54411444DE55DF560BF35B94F4998F23B4132DC4A800F7C55B
	E4C169757A502B8E52941EFB9DB63D34E9315797133D3AA73630E8C3217E7FFF
	79EA36468334C905F1C6934C106F0C2F65B6251055E3B01A57D3C996A66510B7
	D77A587F5E27C059BBB79F9010C40A9E6CB34F09521041802645D18114440089
	D26976D626CDE83C87035A2E0B11C4001097CD1EF0C04AA7A050CC6182C84C07
	EC9B20824231870922331DB06F82080AC51C2688CC74C0BE0922281473982032
	D301FB2688A050CC6182C84C07EC9B20824231870922331DB06F82080AC51C26
	88CC74C0BE0922281473982032D301FB2688A050CC6182C84C07EC9B20824231
	870922331DB06F82080AC51C2688CC74C0BE0922281473982032D301FB2688A0
	50CC615320BE2E83DFDFDBDFBA8C9FFD9279169856A71644ABFFC6E0E8D6FCE0
	8504AE05D1C4B16845DB0FAB550DA2D5BE04F0C5E5E7F34013717B9F1AC9EF8F
	DE1499C7D02AB8B06357F43CE2F336568DB0759F9CE847DFDD8908C414A39AE8
	03727A4DB4905B107D86F859ADB416362D93ED191209429DF859F2FB8C56107D
	745CDA8A202E95DFE7E082E8A3E3D2560471A9FC3E0717441F1D97B622884BE5
	F739B820FAE8B8B415415C2ABFCFC105D147C7A5AD08E252F97D0E2E883E3A2E
	6D451097CAEF73F0DB40B42FBDF80C3D4E2B821880253DC4A3CB1102E8EE3A04
	7A88DB682D48D7D10769EC161013C8209ABB0F830662E92A2E8FC7DD55236B90
	02E2C8EF8CFA8455AD2092B9AAD69DD284144441FC797BC5F60BBD79D4B8561B
	77FABA06640EB5B659CB9CD80271E5FFD120B6B659D321A28ECDE35EF5A0EAF8
	043E22C4DA36EB1610B3CD7E11E45D205EC932A5E74EFDD6B65E2716EAC1F17B
	ECFE95E7A35989D49D9931791FBDB75849B31EADE1454D4FA391D3A9205656C2
	774AA7DEEEA34EA7C991911636A5858877ADECC97C53D229D2A1BB3AD11B9E6A
	E28415CED92D01928D90C97E14232776823F0311DD6651434466E1DDD3690940
	CF368B1A626D8076F153DB27BE2642A76FFCC3CF38713F49BD9FA6C6CF53F7C4
	4E49A7A501D8225E73A289F3A7D2D92225C424F0C8FBAFAFAFFD6C8C9D91A555
	1DFB67E45042ECB1EDD9D8BB3BD1A6F216C49169B35896CE82F1789E1D706B61
	B3B226DA745E8358DBE38D84BBB426DA89D082D859BA5CC22FA6FCF762666BA7
	5452F21273EA6F0F4779B4C10831CD0437279666C5C5C7E544C0B32E35F122A8
	FFAEC2CEDA9A0211712AB3132DE7D6C2A6BA271E04720A44A4A847875873D2D5
	FF4D812827BECED8C88940F19A1072369D5E759B6AA223DCB310F79222273A92
	B8D0D45988A300A653EB147531FAC2464EBCE01CEFA7CA89C0D56E83CAC6C86C
	F67E85A6B60A4F4EF4BE9F964E7BF6895121BE015F1DE06604D63336C85E3244
	8C13445B63A72C6A10278600845C7EE104D1BA710AC48F013411A29C88883D2A
	464E1C73B5D8D44CE104514E1CE532A45D2788AA8988D8A3629C20CA89A30021
	ED3A41941311B147C53841B44EFC0B995FBD7E760AEA350000000049454E44AE
	426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="88" length_in_bytes="1386" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E7100000E7101469ED6200000000774494D4507DB0B190D063A76
	62822F0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A1000004C949444154785EED9DD172E3200C45F3FF3FBB8F
	7DEC266EC910178C041749E0DB994E66B720C13D4802C74E1EDF8FC763E7DFD7
	F4769EDF6B6E5B03DC1D5E9ADFF61019898CD42516F912831C498B8CC40D2291
	101786581AFA484447EEBB753ACD414686303AB6AD211E67289E133FCF910B67
	D7D1C56EDE5FE350158984A8924BC3E14F5B4D67D5A812C4AFAF7FDFFC9DA341
	D29810175E6484B830BC94D95C20B24EAA2A52314BE6A5C90DE277E09FE38811
	F8E7353E42BC00F471D80F0A92108500DF292A2048421440613A3DED5A4AE7C4
	154412B0766BC24874931EE79810715ABA59224437E9718E0911A7A59B254274
	931EE79810715ABA59224437E9718E0911A7A59B254274931EE79810715ABA59
	224437E9718E0911A7A59B254274931EE79810715ABA59224437E9718E0911A7
	A59B254274931EE79810715ABA59224437E9718E0911A7A59B254274931EE798
	10715ABA59224437E9718E0911A7A59B254274931EE79810715ABA59328178DC
	A6FF7BFF7EEB36FEE8B7F4BB913A39CE756A41CCF5AF3D02DE7C4232814B1F27
	5272FA1AE3BB5D14A5028F23D7EA0A62AEFDD533FCCF763F91567A4D46CEAFA5
	8722CF6D026BE836B4113D2F39B53EA5819188670E8F440944D6442C48F39A98
	436E6D6CB053BD87B5D6C6A61564EA8F8F2644FCC22244BCA6E61609D15C72BC
	4342C46B6A6E9110CD25C73B2444BCA6E61609D15C72BC4342C46B6A6E9110CD
	25C73B2444BCA6E61609D15C72BC4342C46B6A6E9110CD25C73B5C0662FED60B
	5E86B52D12E2DAFC8ED1878758BA1D6103DDA153080F31ADB4FC7604A8021B18
	5B026202B981DE53A6100662ED2E2EC4FF4F512E90D11010677E67D41D76B584
	1828A25A43A92D48426C2917E8EFE120226A5DCDC6F9EEF2401CBA86D23A66B9
	452221EA78E67A9D7B9A4394DCC85A6A73A49206F9F4E7DD2231410B934E5B20
	6A00DF87FD0B90AB409C91854CBFB54D0BB1580F2A2AAC0471F6B14A92B93E1E
	AFD082E9692F191421FE7C47B1246B9D19341F32ED81F6C7C94635F1BC114147
	2521EA368D5DAD6BBB4974ADD4048F49244A06B46A3A45C3632476C596AE53EF
	B94EB22F902CF6E209A0B723BADFEA91D8F86084AE0D8B546393742A5985BB42
	D41CB3A4D05C76A7B5C1E5705B106B573C74C970BCF56DD3692D12F3227E05F1
	DD6E9CC1B085901093C01EAFA55413FD33724242ECCDC39A7EAB47629ECA5B10
	25F55FA39DA4ADC9C666F59A98A7F32B885767BC99704D204A26D0DAD80C17B3
	0E03B583BC28E53F3B9B952849B85AB48908317F2F30A55446626D69FFAEDA92
	401D0154EC327244614DBC00F7F19ED8F39D8EA810F355D1DAD848EA3F3AB36D
	5F134B6B6824BA7B21A2C199BF292C99C0CC9A98831C01981E49E8B99D42B2B9
	93E8E476015C3281991091CF833012051B1B6109ED5DB4D3FAB50C4B1672CB46
	B5DEF676D4F4934C60557869DC1A3DD06D4D3636E841AF684FB2907BE7650271
	E6047A27BE533F1388BD824584DF3BA65997E05EDA9A401C9978DEF75C7FBCFF
	AD5A9CCF07199EBBE471BD0B36C68D1A2D0495608531F52EA451BFEFFE60881F
	8B1B36C8C6F1C1C2CFD5252FF75D241862C82B36B320172FBB79640F30C4DB45
	E251FC058F12CC5A48875D30C45B45629AEC6E106F198953A34C929E1989E347
	2146A264A505DE9DBA47216BE27814EEB8B1C933CB7F4D8409884FC1EB920000
	000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="89" length_in_bytes="1386" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E7100000E7101469ED6200000000774494D4507DB0B190C351856
	ABCCCC0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A1000004C949444154785EED9DDD922A210C847DFF973D97
	7BE9D15999C2597E023449607AAB2CAB5648A03F9280CEE8E3F9783C767EBCA7
	B7F3FCDE73DB1AE0EEF0C2FCB687C84864A42EB1C89718E4485A64246E108984
	B830C4D4D04722DA73DFADD3690CD23384D1B16D0DF13843F19CF87D8E5C38BB
	8E2E76F5FE2D0E9B2291109BE46AE1F0A76D4BE7A65105883F3FFF9E7CCCD120
	684C880B2F32425C185EC86C261059279B2A52324BC6A5C90CE2D3F1DF71C470
	FCF71E1F2116007D1DF69D82244421C033453904498802284CA7975D4BEA9CB8
	824802D6664D188966D2E31C13224E4B334B8468263DCE3121E2B434B3448866
	D2E31C13224E4B334B8468263DCE3121E2B434B3448866D2E31C13224E4B334B
	8468263DCE3121E2B434B3448866D2E31C13224E4B334B8468263DCE3121E2B4
	34B3448866D2E31C13224E4B334B8468263DCE3121E2B434B3448866D2E31C13
	224E4B334B8468263DCE3121E2B434B3448866D2E31C13224E4B334B2A108FCB
	F43FD7EFD72EE3F77E49BF19A98BE358A71AC458FFDC2DE0D53B2403B8F07522
	29A7EF319EEDBC28E5781CB1562588B1F6A57BF85FED7E232DF51C8C5C9F5337
	455EDB38D6D06C68237A1639D5BEA5819188670E8F440944D6442C48F59A1843
	AE6D6CB053BD87B5DAC6A61664CD5F1F4D88F8854588784DD52D12A2BAE47887
	8488D754DD2221AA4B8E774888784DD52D12A2BAE478878488D754DD2221AA4B
	8E774888784DD52D12A2BAE478878488D754DD2221AA4B8E77B80CC4F8A317BC
	0C6B5B24C4B5F91DA3770F317539C206BA43A7E01E625869F1E50850053630B6
	04C4007203BDA74CC10DC4DC555C88FF4F51CE9151171067FE66D41D76B584E8
	28A26A43C92D4842AC29E7E875771011B52E67E37A75B9230E5D43A91DB3CC22
	9110DB78C67A5D7BAA43945CC89A6A73A4920AF9F0F26E9118A0B949A7351039
	80E761BF0072158833B290EAAFB6B5424CD6838C0A2B419C7DAC9264AEAFDB2B
	5AC1F4B4970C8A107F7FA35892B5AE0CAA3799F640FBE364A39A78DD88A0A392
	10DB368D5DAD73BB4974AD6C091E9548940C68D5748A86C748EC8AADB64EBDE7
	3AC9BE40B2D8932780DE8EE87EAB4762E58B11BA362C528D55D2A96415EE0AB1
	E598258566B23BCD0D2E865B83987BC7A32D198EB7BE6D3ACD45625CC44B10CF
	76E30C862DB8841804B6784EA51AEFDF91E312626F1E6EE9B77A24C6A9BC0651
	52FF5BB493B455D9D8AC5E13E3745E82583AE3CD84AB02513281DAC666B89875
	18C81DE44529FFD559AD4449C255A38D4788F1678121A53212734BFBB36A5302
	750450B2CBC8118535B100EEEB33B1D7271D5E21C6ABA2B6B191D47F7466DBBE
	26A6D6D04874F742448353FF5058328199353106390230DC92D0733985647327
	D1C9EC0D70C904664244DE0FC248ECD8D8084B6AEF22EEEAC748CC50B946E268
	DA9BDD3F802C1DF0BB5648C7AA55D9D84826B33B44494991E8B4544D9C1D49A3
	F619898994D191457A17EE947E35A3B3DE827BFB5549A79254A234949AD6DDAF
	573BBE6E647845FFB8DE091BE34617515FB290AA2046E60A8618CF4705A2B580
	5F87FD1110237DC1105DBE63332B0A926FBB8DC0E8ED0B8678BB483C8ABFE056
	82590BE9B00B8678AB480C93DD0DE22D23716A9449522C2371FC28C44894ACB4
	421B730107C70F8962462223F15C489FC37E1C18FF012ECCA3B90E499F1C0000
	000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="90" length_in_bytes="1483" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E6F00000E6F01AB038A140000000774494D4507DB0B190D1B1C5B
	036BCE0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A10000052A49444154785EED9D8192AB200C45FBFF3FBD5B
	6DED44144830B902DE37D3E9765723E424B9C1AAEFF5F77ABD667E2DD39B797E
	CBDCA606383BBC6D7ED343642632538708F2210679A52C321327C844421C18E2
	D9D0AF6474CFFB4E5D4E25C89E215C1DDBD410D73514D789FB75E416D97FEFE5
	F3F2E2E74F0E78FBC31A78A64C9403DE06CEF74F407BBE42217A0E94B62AE00D
	4DA52913E978DF8C2BFA330A625A4E0DC7B9DA804DBFBF041A5A4E09D156B82C
	410E8398A6BFE84E970EADCB7FDFC0EB726C6B5BFB5D001C4AAB21026CA19574
	61BD43DC2DF63BC50887982BA73DFAE7F4B45B87033D83788B2676E89BDF9046
	2CA7A110A989FEE10A2FA72342F477BBAF4538C49134D1D7D571D6A88971BE85
	5986436439F5670B2FA7843801446A220662E81283102780C8728A81B8FA99E7
	4EFD9D1D6511DED8B09CFAA3842F3108710288D4440C446AA2BF9F432D521343
	DD8B314E4DC4F839F4287088D4447F9EF0724A8884E8EF81092CC23391EB44FF
	A8816B22214E00919A8881C8C5BEBF9F432D521343DD8B314E4DC4F839F42870
	88D4447F9EF0724A8883429417EDD49618BDDFF7E08FA0CDA2F453AD9C6A2E9A
	AA5ECBF13BC8FB8712443198B6993D682FE9AB1244E9FBD235371F301BA0E47D
	3392ABDBE9DFE5E70731514FB5E2AFDD1338CEB6CD72AA5D55B58B86C24DA6CC
	44354B797770F14E6175266A20FE1E8E2A1EBCB3343929386AA20E245C1325E4
	5A63A39B02B7921EA83536B524B33F3E7AB07BF64708975CBFA181D7F6F86842
	748F0B384496537786A78D8D666DB8933953DA561A1BFF29CE6F919A38016378
	39E5B953FFA88143A42662205213FDFD1C6A919A18EA5E8C717839A526FA8385
	43A42662205213FDFD1C6A919A18EA5E8C7178396DD5447E45950F0838C4564D
	24441BC4AE34F1F412034C951AE6284368A204398C6781038597536AA23F5D38
	C49C269E954DAFDFF9BBAD2F8BF0724A88FE0100879896D3C8CF6272FE9EBBC1
	62AE438797D34868AD7A7B038FA6437603312DA7915067C9C4DA320B5E4ED303
	7A7E6E3D91D09416E09D4ACB2C3844CB4555878B8E2BEDEACC109798E9A69CB6
	40DC456109E420D7B47A2D9D523B0769321CA87A6B5B0B3879EFC661B0B9C111
	E2EFAEA8356B7B81B8BB116792729A5D1238FEE7D08418DCB42020AEA575C44C
	1C659DF85888AAA81A4C1365D0C9CEDA6DD93562268EB2C4685DD759754E15F8
	DFC1986AAFC5B075DB9121D6344CBDCC32645FF35D51563096EE74784DCC0038
	FB75AB1F73FBDD9A89BB1253D1C4DC198FE066F460FEB1E534A7073F87BC7F28
	9553E13834B331206E0EBEE33D2D3569C79793883B49669718153D1BBEB1D164
	624913EFCE4459CA6B10236151132FA4AF0CA292264A79481D1E0917D2D86826
	D0E312A354216BA57F7DBE4CE1916BAE7FF76E775BEDF508714BDE5A266EEBC4
	C76762CFEB446A62A56B130F72397DCAE005290BD9B5A489A52AA49194E62AD6
	BAA3653FCD047A2EA7321A5A215AFC65DD16D2D868063532C4DAB953D9C4687C
	61DD06025193893D6B622D133510AD602CDB4320AA0634FAF7894F3D63B3FB3A
	6590E7C651130BD14A4D7C47B1B6934FB66BDED172406A623B208D9F21103503
	C935368DC1A93AE415DB876B6C949AE87D2A6EED7CC3672BCE21D616C3B2A482
	86D63CFD0D62E954DBCEF8D6B85D9DD8C9E58C1088CD9EF29870EEA2DEABB6AD
	FB3B4394120581A8D244AB5334DB97AECAD6ECEFB98D33C45D677F5B96783A28
	676B6288CC44E365F22E81CE4C6C6CC098898D8E3B296DD4C4F574D4E7755546
	D89D7E1DE9E14C2B0C6788D4C40920B23B9D00A2CCC47F813BE3DD4E3833D500
	00000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="91" length_in_bytes="1540" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E7000000E700194D934C40000000774494D4507DB0B190D1B1C5B
	036BCE0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A10000056349444154785EED9D8192AB300845FBFF3FBD5B
	6D75304D02248049BC6FA6D3EDAE62C2016EB0EA7BFDBD5EAF955FDBF4569EDF
	36B7A501AE0EEF98DFF2109189C8D429827C8A41F6944564E2029908881343CC
	0DBD27A347DE77E9724A418E0CA1776C4B43DC7B28F489D73EF288ECBF77FBBC
	BDF0F99303D6FED0069E2A13E9808F81E3FD13D0962F57889603852D06BC6251
	A9CA4438DE36E3AAFEF482989653C5717A1760CBEF4F81BA965340D4152E4D90
	87414CD39FAC4EB715DA90FFBE8137E4D8F665EDB701F829AD8A08D08556B20A
	1B1DE2A5D91F146338C452391DD13FD9D36E030E3407F1164D1CD037E790662C
	A7AE10A189F6E11A5E4E678468EF765B8BE11067D2445B57FB598326FAF936CC
	72384494537BB6E1E514101780084D8C81E8DA6200E20210514E6320EE7EC6B9
	537B677B590C5FD8A09CDAA30C6F3100710188D0C41888D0447B3FBB5A8426BA
	BA37C6383431C6CFAE470987084DB4E7195E4E011110ED3DB080C5F04C449F68
	1F35E19A08880B408426C64044B36FEF67578BD04457F7C6188726C6F8D9F528
	E110A189F63CC3CB29204E0A915EB4C3B518A3DFF7608FA0CD22F513574E2517
	4DB1D7729C0779FF50834806D336B307ED457D5583487D5FBBE6E603E60094BC
	1F464A753BFD3BFDFC2026E2A932FEBA3C8123B76D91137755D5251A2A379922
	13C52CE9DDC1D53B85C5992881783E1C953C78675BE4A4E0A0893290E19A4821
	730B1BD914B015F500B7B0E1924CFFF8E8C9EED99F215C4AEB0D09BCB6C74703
	A2795C844344393567985DD8487AC38BCCA9D29659D8D84F717D8BD0C4051887
	97539C3BB58F9A7088D0C41888D0447B3FBB5A8426BABA37C67878398526DA83
	0D87084D8C81084DB4F7B3AB4568A2AB7B638C8797D3564DC45754E5800887D8
	AA8980A883389426662F3188A952D31C650A4DA420A7F16CE040C3CB2934D19E
	6E38C49226E6CAA6D5EFECDD3696C5F0720A88F601100E312DA79E9FC9E4EC3D
	7783C5D20A3DBC9C7A426BD5DB1B78341D7218886939F584BA4A26726D567839
	4D0F68F9B9F54442535A04EF546BB3C2216A2EAAFAB9E89859AEAE0C718B9961
	CA690BC44B14D6404E724DAB55EB94DAF99126C581D85BDB5AC0D17B377E065B
	1A1C209E7745ED593B0AC4CB8D388B94D3624B60F89F4303A2F3A22502E25E5A
	67CCC459FAC4C7421445D5649A48838EAEACCDDAAE1933719616A3B5AFD3EA9C
	28F0BF8351D55E8D61EDB63343E4344CDC6629B2AFF9AE282D18CDEA747A4D2C
	00C8FDBAD58FA5FD6ECDC44B896134B174C6C37931FA63FEB1E5B4A407A743DE
	3FD4CA29715C34B339201E0EBEE33D2D35E98AAF241177922CB6188C9E4DBFB0
	9164624D13EFCE445ACA39889EB0A0891DE94B83A8A689541E52877BC20D59D8
	482630628B51AB905CE9DF9F2F5379E49AE9DFAD97BBADF6468478242F978947
	9FF8F84CF4EE13A9AE692B2B349159B59107B9649F32A8757869FB1E88D4664D
	136B55482229CD55AC7547CD7E92097895D35C0CF504462B448DBFB4DB862C6C
	2483F282785CDF62D5A6702D46B10D507E5B2FF1D9795A53B371EBB6924C1C59
	13B972CA9D006FF59B74BFA1329166A3544AEFDAEE08BADA8AF4F24DC3233231
	A16155FE7AF42FB7AF149A348B2CB61B2613736738AC569496205B218A24A5B1
	AC84406C990032F15D7F8550C51B4A0D5A6D271CBFD5E1D476B43B1C816CFDBE
	9FBED30EA665FB9E4C0C1AA27A5AFA1DDE97212A2F45CC1E23632304A27AC20E
	E45A02C974DCC7950BBD73FB42A4F3098178B703A9DF4CC168801843BCB42FB7
	4D4AE3808E6D73BBDE326763888FCBC45DFC1D9B6D515018437C54269EE71717
	83F8C84C14654B47D966ED2313FB5BA15BCB29BDA6B637509EBA3A65B3A4D7B1
	DCFE0E10A1899CD3ADFFEE009156967F218E9A19922D20B80000000049454E44
	AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="92" length_in_bytes="1536" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E6F00000E6F01AB038A140000000774494D4507DB0B190D1B1C5B
	036BCE0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A10000055F49444154785EED9D8172A3300C44F3FF3FDD36
	3430C2B12DCB488B6DF6663A691A10B69EA4B50870AF9FD7EBB5F2CF7B7A2BCF
	EF3DB7A501AE0E6F9FDFF2109989CCD429827C8A415E298BCCC4053291102786
	981BFA958C1E79DFA5CBA904393284AB635B1AE2D643B14F3CF7917B64FFFCB5
	CFEF1FBEFFCF016F7F5803CF948972C0FBC0F9FA1FD09E3FA1103D074A5B0A78
	C3A2D2948974BC6FC655FD1905312DA786E35C5D802DBFBF041A5A4E09D156B8
	2C410E8398A6BF589DBE576843FEFB04DE9063DB96B59F06E0ABB41A22C0165A
	C92A6C7488A7667F508C7088A5723AA27FB2A7DD061C680EE22D9A38A06F8E21
	CD584E43215213FDC3155E4E6784E8EF765F8B70883369A2AFABE3AC5113E37C
	0BB30C87C872EACF165E4E09710188D4440CC4D01683101780C8728A81B8F999
	E74EFD9D1D6511BEB06139F547096F3108710188D4440C446AA2BF9F432D5213
	43DD8B314E4DC4F839F4287088D4447F9EF0724A8884E8EF81052CC233917DA2
	7FD4C03591101780484DC44064B3EFEFE7508BD4C450F7628C5313317E0E3D0A
	1C2235D19F27BC9C12E2A410E5453B5A8B31FA7D0FFE08FA2C4A3F69E5B4E5A2
	29F55A8EE3207FBFD4208AC1F4CDEC417B495FD5204ADFD7AEB9F907B3034A5E
	7723A5BA9D7E2EDF3F8849F354157F9D9EC091DBB6C849BBAAEA140D959B4C99
	89CD2CE5DDC1D53B859B33B105E2F17054F1E09DF7222705474D6C0309D74409
	595BD8B44D815B490F680B1B2DC9EC8F8F9EEC9EFD19C2A5B4DE6881D7F7F868
	42748F0B384496537786D9854D4B6F78923953DA2A0B1BFF29AE6F919AB80063
	7839E5B953FFA88143A42662205213FDFD1C6A919A18EA5E8C717839A526FA83
	8543A42662205213FDFD1C6A919A18EA5E8C717839EDD5447E45550E0838C45E
	4D24441BC4A134317B8901A64A4D7394293451829CC6B3C081C2CB2935D19F2E
	1C6249137365D3EB6FFE6E1BCB22BC9C12A27F00C021A6E534F2BD989CBFE76E
	B0585AA1C3CB6924B45EBDBD8147D72187819896D348A8AB64A2D666C1CB697A
	40CFF7BD2712BAD202BC53ADCD8243B45C54F575D1B1B25C5D19E23B668629A7
	3D104F51580339C935AD5EAD536AE74B9A0C07526F6DEB0127EFDDF81A6C6970
	8478DC15B565ED28104F37E22C524E8B2D81E37F0E4D88C18B1604C4ADB4CE98
	89B3F4898F85D814559369A20C3AB9B2766BBB66CCC4595A8CDEBECEAA734D81
	FF198CA9F65A0C5BB79D19A2A661CD6D9621FBBAEF8AB282B1AC4EA7D7C40280
	DC9F7BFD58DAEFD64C3C951845134B673C8217A35FE61F5B4E4B7A7038E4EF97
	5A39158E43339B03E2EEE03B5ED35293AEF84A127127C9628BA1E8D9F40B9B96
	4CAC69E2DD99284BB90631121635F142FACA20AA69A29487D4E19170210B9B96
	098CD862D42AA456FAB7E7CB541EB9E6FAB9F772B7D7DE8810F7E4D53271EF13
	1F9F89D17DA2D4356B65A5262AAB36F12097EC5306AD0E2F6D7F05A2B459D3C4
	5A156A9194EE2AD6BBA365BF96094495D35C0C5D098C5E88167F59B7852C6C5A
	06150571BFBEC5AB4DD15A8C621B60FCB6BEC567C7694DCBC6BDDBB664E2C89A
	A89553ED0478AFDF5AF71B2313339736B44AE95DDB65BF4FAC0CA629903B2703
	81A84EE0F3005CADF7EA9C636B409BB6B3423419374E1402B16502A9267E5DC2
	E7782152886DC5F16A201BC14DF17D6288A32303E102849620AFB62F570D78ED
	3F7326B664D9BE8DF7EB76FACE0BC2D546572EDDD365FC0CEFAB7E9415E0AACF
	33973342202202453B464BB66836BA3F0F8028E7038178AB03DFE546149C6E10
	57322800227C61738BE33E4ECFF91E3E9E00888FCBC44DFC034F7BA9411100F1
	5199789C5F5C0CE2233351CD962B9AA7EDCB4CF46983562BA7CC442D73BC3F67
	2632134F52F069F66526FE028DD1C5EDE158345B0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="93" length_in_bytes="1204" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E7100000E7101469ED6200000000774494D4507DB0B190D0807B0
	89E3B00000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A10000041349444154785EED9DD16EC3200C45FBFF3FBBC7
	3D764DBA7434A301C2AD8DE9A95455DA121BEEC10612482ED7CBE532F377A9DE
	CCF55BEA3635C0D9E16DF59B1E229148A48668E4210AD9931689C40922118881
	21E68ADE13D1239F3B753A4D418E0CA1B76C53435CE750CC139FE79181B36B6F
	63373FBFC561532402B149AE160EFF8E6D39B9A9541BC4EFEFAF2BDFF768B069
	0CC4C08D0C8881E16D99CD0522FD64538F94CD9269D7E406F13AF0679D620CFC
	59CA07C403404F93FD414102B112E023450D081288155048A7BB514B6E9E1841
	A40AD66E8710896ED2EB1C0351A7A59B2520BA49AF730C449D966E9680E826BD
	CE3110755ABA5902A29BF43AC740D469E96609886ED2EB1C0351A7A59B2520BA
	49AF730C449D966E9680E826BDCE3110755ABA5902A29BF43AC740D469E96609
	886ED2EB1C0351A7A59B2520BA49AF730C449D966E9680E826BDCE3110755ABA
	5902A29BF43AC740D469E96609886ED2EB1C0351A7A59B251388EB32FDDFF5FB
	A565FCA32FE97723B5739CEA548298EAFF6A0B787187E4066E7B9C48CEE952C6
	C771A32835703952AD8E20A6DA1FEDE1BF1D778FB4DCEF6664FF9BDB14B93F66
	600DDD8AD6A3E721A7D2531A88443D737924D640A44FD48234EF1353C8A5818D
	B6AA9F61AD34B0290559F3E3A381A86F5840D46B6A6E1188E692EB1D0251AFA9
	B945209A4BAE770844BDA6E61681682EB9DE2110F59A9A5B04A2B9E47A8740D4
	6B6A6E1188E692EB1D0251AFA9B945209A4BAE771816627A2B462F4B2C8B408C
	C52B5BDA701073CB1326E0D05585701097DAA620BB6A3FC9C921216E202761D0
	5D8D6120BE5AC5E5F1F76E558D0D0C0171A47746451CF50271F75A212056E4BE
	DC422922B12FFFBA456205EF9A95769263F6ABD1FB24B53F1B8899F72CD963E8
	F3680E51123AB752AF7D576738E7523B7D62A7A8B5509E26FB1D3E81F8F7BEE7
	E2D6B65A3835C7652FBB9D0409442788E9C69C1AE8853D79EBBF19D89C8C0205
	00850D20DEA3D1349D1289FF47B26147A7BD5158DA7ADE37E8B73D3B2C44A618
	7F0D252C442271028844E20410CF46620ABF344F8C72F5266C3A3D1B891BB8D2
	C0E6719CED18E5943709C44DD0517F5360B91951F467EA48209E4D6D3DE71189
	F489F7AB14BFD7295E5D76A34F7CF3959CB39138E33375C2A6D39E545CFB74AB
	53A30C8793C24224123FB84F249DE66F587017C32185A62EC3A653FAC409D2A9
	B24FDCB76AE7C06A76BF9F0AA557A56A1BBB4B3AAD2D5CCDF20C20BE793EF80A
	0291F89C4EF70DB1551F22B139016A4F089B4E5B5B5A2EA273772AA25C6A3BEA
	023EB24F74EA1114DDFAA18D16072EE9541989400CACC0FD46C6BC9F8F88C447
	256F5B736E7DCC5CDFC6E07249A72DADAC78EC6C0097FA4480A8E8138944E70D
	35AD2DED781837592A251227011A219D128985C61601227DE2041089442DC41F
	80AD5257848DDF6C0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="94" length_in_bytes="1212" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E7300000E7301396015A90000000774494D4507DB0B190D0807B0
	89E3B00000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A10000041B49444154785EED9DD172EB200C44F3FF3FDBC7
	3EA6B55352E2120366D14A743BD3C9F45E5BC27BBC026CECDCEEB7DB6DE5DFED
	F0563EBEEDD89606B83ABC747CCB439413E5D410277988468E9445397101270A
	626088A5A68F38DAF3BE4B97D31CA46708A36D5B1AE23E87D23CF1751E19B8BA
	8E9EECE6FBF724EC72A22076C9D5C3E1CFB63D3B77B52A41FCFCFCB8EB778E06
	4963410C7C9209626078A9B25120AA9FECEA918A5532EF9A6810EF8E7FF62986
	E39FAD7D827802E865B2EF14A42036027C9628872005B1018ACAE961D4529A27
	4610A981356D133991263D2EB120E2B4A44512449AF4B8C48288D39216491069
	D2E3120B224E4B5A2441A4498F4B2C88382D69910491263D2EB120E2B4A44512
	449AF4B8C48288D39216491069D2E3120B224E4B5A2441A4498F4B2C88382D69
	910491263D2EB120E2B4A44512449AF4B8C48288D39216491069D2E3120B224E
	4B5A2441A4498F4B2C88382D69910491263D2EB120E2B4A4453281B82FD3FF59
	BF5F5BC6EF7D493F8DD42171AE530D62AEFFBB47C0AB4F482670E97522A5A45B
	1B9FDB7951CA713B72ADCE20E6DA9F3DC3FFBDDDC369A5CF14E4F8597A28F2B8
	8D630D694D1BD1F39453ED2D0D72229E39DC892D10D52762419AF78939E4DAC0
	067BA8FF235A6D60533359F7EBA305117F6209225E53F38882682E393EA120E2
	35358F2888E692E3130A225E53F38882682E393EA120E235358F2888E692E313
	0A225E53F38882682E393EA120E235358F2888E692E313868598DF8AC1CB122B
	A220C6E2556C6D3888A5E5090B70183A847010B7A3CD410E1DFD223B87849840
	2EC260F830DC407CB78A8BF1EFC3AA1A077001D1D37746451CF50AE2E16B8504
	B1A1F695164AC98963F597E6C406DE2D2BED20DB1C57A38F496ABFB72016BE67
	C91EC35846738810EB7CB77AEFBB06ED5C2AEDEA1307456D85F232D91FC82988
	BFDFF75C7DB4AD154ECB76C5CB6E17410A220962FE604E0BF4CA3379FB7F6B60
	73D1050800881882F870A369399513FF8E64C38E4E475D587BF47C6CD06FBB77
	58889A62FC9E286121CA890B409413178078D58939FCDA3C31CAD59BB0E5F4AA
	1313B8DAC0E6B99DED18E5523608C424A8D7CF1C58694614FD9D3A1088574BDB
	C87E72A2FAC4C7558A9FEB14EF2EBBA94F9C7C25E7AA13577CA74ED8723A528A
	5BDF6E75699441D8292CC4684E9C599AC3428CE644412CF4AF519C581A1AA02B
	AE9C68705338078906981E6928CD757BAA95EE27369051399D345D9914B6C700
	53B7ED091EDE89ABC2740FB1A781DAB6BE8426AC130597BC64711600C4D46556
	DBDEC545B4792927E6F71BF38BE4C74B755EFFBE7A0251205E6D2C6B3F845B66
	B69D02D1BB28A5BB259EDB4C8138F3AC44C62E5E767338A7A140F47C56974E02
	EFEDA54044BAC52296204EBA8B61012F4A0E39B1A18F9313E5C4E946999E204A
	493A6BA777277E01D421C5CEB00ACE3C0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="95" length_in_bytes="236" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000000D0000
	001508060000009D6E648A000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A10000005149444154384F63F8CFC0C0400C062983A9234A03BAA1446B1A
	B5094B94D031F460E18F8B86A702525304B2B7408610F4135625C42456B0E9A4
	3A6F203501B3D67F2230D84F5075B40B3D8C782227450000E9E227E740F30509
	0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="96" length_in_bytes="1222" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E7200000E7201EB27F74D0000000774494D4507DB0B190B2C2609
	856EFA0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A10000042549444154785EED9DDD72EB200C84F3FE2FDBCB
	5EA6B51352E29020AC453F743BD3E9CC3958C2FB790538D8B95C2F97CBCABFDB
	E9AD7C7EDBB92D0D707578E5FC96874827D2A9292EF2149DD494453A71012712
	626288ADAE6B1C1DF9D8A5CB690D3232046DDF9686B8AFA1B84E7C5E4726AEAE
	DA8BDDFCF89184434E24C421B94638BCB41D3978A85705E2F7F7D795BF733428
	1A1362E28B8C1013C32B95CD0522C7C9A111A95925EBA1C90DE235F0CFBEC408
	FCB3F58F103F007A5AEC0705498842808F12151024210AA0B09C1E662DAD7562
	069104ACDD9AD0896ED2E31213224E4BB74884E8263D2E3121E2B4748B44886E
	D2E31213224E4BB74884E8263D2E3121E2B4748B44886ED2E31213224E4BB748
	84E8263D2E3121E2B4748B44886ED2E31213224E4BB74884E8263D2E3121E2B4
	748B44886ED2E31213224E4BB74884E8263D2E3121E2B4748B44886ED2E31213
	224E4BB74884E8263D2E3121E2B4748B44886ED2E31213224E4BB7482610F76D
	FAF7FDFBBD6DFCD1B7F4BB913A24AE75EA41ACF57FF70878F709C902AEBC4EA4
	9574EBE3A35D14A502F7A3D6EA13C45AFB4FCFF0FFB6BB39ADF5B70439FE6D3D
	14796C135843B7AE69F4FCC8A9F796063A11CF1CEE4409448E895890E663620D
	B937B1C19EEAFF88D69BD8F44C36FCFA6842C45F588488D7D43C22219A4B8E4F
	4888784DCD2312A2B9E4F8848488D7D43C22219A4B8E4F4888784DCD2312A2B9
	E4F8848488D7D43C22219A4B8E4F4888784DCD2312A2B9E4F8846921D61FC5E0
	65C915911073F16AF6361DC4D6F6840538A84E211DC4ED6C6B90AAB35FE4E094
	100BC84518A84F230CC477BBB83CFE5DADAA71801010237D6754C6592F211EBE
	56881005B5AFB5518A4ED4D55F37270A784B76DA41DA1C77A3EB24B53F9A101B
	DFB3648F4197D11C22C43ABFBDDEC72EA59D5BA59D63A252542994A7C5BE2227
	21FE7DDF73F7D136291C49BBE66DB7932009D10962FD608E047AE799BCFDBF39
	B139E9020400440C42BCB9D1B49CD289AF33D9B4B353AD0B7B8F9EEB26FDB647
	A785C825C6DF859216229DB800443A710188679D58C3EFAD13B3DCBD495B4ECF
	3AB180EB4D6C1EED6CE728A7B241201641A3FEAD81B55644D9DFA9038178B6B4
	698EA3133926DEEE52DCEF53BCBBEDC63171F29D9CB34E5CF19D3A69CBA9A614
	4BDF6E756A96E170505A88D99C38B334A78598CD8984D8185FB338B135354057
	5C3AD1E043E11A241A6079A4A1B5D61DA956FC3C514086E574D272E5DD3A7152
	BA11630CB7A513EF5BF905860ADDA480ACEF0F4BAF0697722AEDDCC846A9D084
	049D4B0771C6EC54A053E826E920229D98710C94F479442397728A74A244908C
	6DC2431CE96084B6888B6EE679A475E24C515A9F964406E902D10A80364FF3B6
	5BC0DAEC0231F255DD021FBDBF2E10B50EB13E9E10277D8A610D32723E3A5130
	C6D18974E274A34C4F10B90C49FB16DD893F120CA7C66595AA51000000004945
	4E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="97" length_in_bytes="1413" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E7000000E700194D934C40000000774494D4507DB0B190D1B1C5B
	036BCE0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A1000004E449444154785EED9D8D929B300C84F3FE2F7D4D
	72811A9FF11FAB8D2CB63399340D08A34FD25A2E90C7CFE3F188FC7A9D5EE4F3
	7B9D5B6880D1E16DE7171EA2325199BA44902F31C82B65519918201305716188
	A5A15FC968CFFB862EA72948CF10AE8E2D34C4770FA53EF1D8476E91FDF36C9F
	5F2F7DFECD01B43F46036F2813D3016F03D7FB6F40235FA610910395AD06F881
	49E55026CAF1D88CABFAD30A625E4E078E737502167EFF14A8693915C4B1C235
	12E4348879FA27B3D3D70CCDE59F4FE0B91CDB7B5AFB6900FE94D68108180BAD
	6C16E61DE2A1D9778A910EF1AC9C7AF44F71D9CDE1404B10BFA2890E7DB30F69
	C5726A0A519A880F577A395D1122DEED588B74882B6922D6D576D6A48976BEA5
	59A6435439C5B3A59753410C00519AC88168DA62086200882AA71C886F3F6BED
	14EF6C2B8BF4898DCA291E25BDC510C40010A5891C88D244BC9F4D2D4A134DDD
	CB312E4DE4F8D9F4287488D2443C4F7A39154441C47B2080457A26AA4FC4470D
	5D1305310044692207A29A7DBC9F4D2D4A134DDDCB312E4DE4F8D9F4287488D2
	443C4F7A3915C44521A617EDB45A0CEFF73DE011CC594CFDD42AA73D174D35AF
	E5D80FF2FC4B0D623298B933BBD15EA9AF6A1053DFD7AEB9F905B301CADE3723
	67753BFF3EFD7C2326DDA7DAF0D7E1091CA56D4F39B5AEAA3A4443E526536562
	37CBF4EEE0EA9DC2DD99D803717F386AF2E09DD7242707274DEC0349D7C41472
	6B62D3770ADA2AF5406B62D34AB2F1C7472F76CFFE0AE17236DFE88137F7F868
	4184C7051DA2CA299C617162D3D31B1E646E286D1B131BFC29C6B7284D0CC098
	5E4EB5768A8F1A3A44692207A23411EF67538BD24453F7728CD3CBA934110F96
	0E519AC881284DC4FBD9D4A234D1D4BD1CE3F4728AD244FD97D5FF00A1434469
	A220D621BAD6C4E225079CAAE5F6284B6A620AD2AD678903A3975369229E2E1D
	E2992696CAE4B7FE0DEF665B8BF4722A8878A074887939F5F4397106DED38616
	E9E5D41334943E1BF2E9324D879897534F502365A2799F9882CCA388F919B5F0
	D0952E861BF1351134E52C465AEBD740B3634786F8AE7003BE1EDA78C4F0D9B6
	8766FFD8F9D77FD2353FA920D7C0D235F12AC4E2B25B03CE69540686D89C7BE4
	55E92A9899FDABC25D2AAB05FA91CBA9201A4E422C4C9F96D3DA1C214A2686EF
	13BD43AC96E0CE721A19E2FAE5B4736A2D4DFCFC18F1D311F41663662254DA27
	32C4E64A987B4DEC0DACC02DC6121067B3F1D09A34207E32D5624209B579BAEC
	E67D6253ED132B99B89FF04B072AF74A268E813ADCC21804E2E650AFEFDBB35B
	8AAB3D49B4D6AAB085F35136A7FAC4BC0ACD96B62BFB2132B1D662AC9E894D4D
	F40071360076F805BDC8C185D6440F10673331794A41551351A58E61674A133D
	409CCDC4BB405CA29C223231F2B2DB12101199181962DE3EB5A07E65D9ED7226
	36FA448696A18E715F4D0C0EB195797FAAD0E5D2D6BBD6996C7729134F96A356
	EA0DD32CAE36FB9DBEFD4A39BD14383780B86BA26788884CACAD9DA2F48A61A7
	AA899E2122323132C45DF33C43446462E4166309889699D819BC978660718C34
	286FA5896949B5702CD3E606F1A0919D0308333B1DEDAD96D8DE33C44B9A989F
	58EB469C95BFF70C112A482B436A8DDD334465E2F3D6B533809DE0A61FE40ECD
	A089C1168FDF8AE6D5BE9FF0CB572636CA4465E231F056CBB4D678958995086F
	39CFCBF7AB40846AAB17E7A3C63101F11FA54322021F2C26D40000000049454E
	44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="98" length_in_bytes="1448" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E7100000E7101469ED6200000000774494D4507DB0B190D1B1C5B
	036BCE0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A10000050749444154785EED9D8B72EB300844F3FF3FDDE6
	61A7B2AA07926083C8DE994E9A1B1B4B1C60856B3BB79FDBED16F9E731BDC8F3
	7BCC2D34C0E8F0CEF98587C84C64A66E11E45B0C72A52C3213036422216E0CB1
	34F4958CF6BC6FE8729A82F40C61756CA1213E7B28F689D73EF28CEC9F7BFBFC
	F8E1FB570E68FB6334F08632311DF03970BEBE025AF3C714A2E64069AB037E60
	5139948974BC6EC635FD6905312FA703C7595D8085DF3F056A5A4E0971AC708D
	04390C629EFEC9EAF4B14273F9EF083C97637B2E6B8F06E05F691D8880B1D0CA
	5661DE215E9A7DA718E1106BE5D4A37F8AA7DD1C0EB404F1239AE8D037EF21ED
	584E4D215213F5C3155E4E7784A8EF765D8B70883B69A2AEABEDAC5113ED7C0B
	B30C87C872AACF165E4E093100446A2206A2698B41880120B29C62203EFDCC73
	A7FACEB6B2085FD8B09CEAA384B71884180022351103919AA8EF67538BD44453
	F7628C5313317E363D0A1C2235519F27BC9C122221EA7B2080457826B24FD48F
	1AB82612620088D4440C4436FBFA7E36B5484D34752FC6383511E367D3A3C021
	5213F579C2CB29216E0A31BD68A7D76278BFEF411FC19CC5D44FBD722AB968AA
	7B2DC7FB20F75F5A1093C1CCCDEC8BF64A7DD58298FABE75CDCD0BCC09287B3D
	8DD4EA76FE79FAFE8B9888A7DAF1D7E5091CA56DAB9C7A57555DA2A171932933
	51CC32BD3BB879A7B038132510DF0F474D1EBCF358E4E4E0A8893290704D4C21
	F71636B22970ABD403BD854D2FC9C61F1FBDD93DFB3B844B6DBD218137F7F868
	42548F0B384496537586C5858DA437BCC8DC50DA761636FA538C6F919A188031
	BC9CF2DCA97ED4C02152133110A989FA7E36B5484D34752FC638BC9C5213F5C1
	C22152133110A989FA7E36B5484D34752FC638BC9C6A6922FF64F5172070885A
	9A48886D88AE35B178C901A66AB93DCA969A988274EB59E0C0E0E5949AA84F17
	0EB1A689A532F9A9FFD377B3AD45783925447DA070887939F5F43E7186BEA70D
	2DC2CBA927685AFA6CC847641A0E312FA79EA046CA44F33E3105994711F2BDD6
	890751BA186E84D744A5256731D27ADF069A1D3B32C467851BF0F5D0C623866B
	DB5E9AFD6BE7DFFE4AD77C5241AE81856BE22AC4E269B70E9C6A540686D85D7B
	E4556915CCCCFE4DE12E95D502FDC8E594100D172116A6ABE5B4B546889289E1
	FB44EF109B2558584E2343DCBF9C0A97D6D4C4E3CB88EF8E80B718330BA1D23E
	912176CF84B9D7446960056E31B680389B8D97D6A403F1C8548B05A5AACDEA69
	37EF0B9B669FD8C8C4F7841F3AD0B85732718CAAC32D8CA9403C1DEAF5F57C76
	4BF16C4F12ADAD2A6CE17C2D9B537D625E85664BDBCA7E1A99D86A3176CFC4AE
	267A80381B006FF805BDC8C185D6440F10673331794A415313B54A1DC2CE9426
	7A80389B89DF02718B72AA9189C8D36E96A579DB858D4626468698B74FBDCCFC
	C869B7E54CECF4895A5A56696BB4CC3FED7CAF268220A64EB62AA9DB96538D4C
	8C5C4EDD5F28B5AC8747E8E611DC3A63B3C36767505EE6251CF8B69A88CC4455
	11CC8C35CBA967882AD9F80D7F8AF20C71374D64260AA369383B2B996875386B
	BBC55E5078D0709A289CF770CC58DBDD0E22D483B5BF900F50992AFFBD7B4BCE
	CFFF5636FF6F63108E71DF4C144EB07ACA4AB87FBAD950F0458738E40CA1B3AB
	361732B178DA4D3A9EE810A7CA93D479F9760B10DF5F59707C15D350F08D429C
	9DDF7DBF8F94D32167AC8E91106D20EF96895341C74C540C1E66A2A23393B2C8
	4CBCDFCE9DB7180BB2414D14386F2AE880E5F4170006EA0174F7B12600000000
	49454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="99" length_in_bytes="1470" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E7000000E700194D934C40000000774494D4507DB0B190D1B1C5B
	036BCE0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A10000051D49444154785EED9D8D92DA300C8479FF97BE02
	4738C7F58FE4AC842CB6330CA5248AAD4FD25A69126E3FB7DB2DF3EB31BDCCF3
	7BCC2D35C0ECF08EF9A587C84C64A66E11E45B0CF24A59642626C84442DC1862
	6BE857323AF2BEA9CB6909323284AB634B0DF1D943B14F3CF7914764FFDCDBE7
	C78B9F7F7300ED0F6DE0A932B11CF03170BEFF0634F2650A113950DA9A80572C
	2A559948C763336EE84F2B887539551CE7EA022CFDFE2550D3724A88BAC2A509
	72378875FA17ABD3C70A2DE49F57E0851CDB7359FB6A00FE2BAD8A08D08556B5
	0A8B0EF1D4EC07C5E80EB1574E23FAA779DA2DE0405B103FA289017DF31ED28E
	E5D4142235111FAEEEE574478878B7632DBA43DC4913B1AEB6B3464DB4F3AD9B
	6577882CA778B6EEE594101340A426FA40346D310831014496531F884F3FF3DC
	29DED95616DD17362CA77894EE2D06212680484DF481484DC4FBD9D42235D1D4
	BD3EC6A9893E7E363D8A3B446A229EA77B39254442C47B208145F74C649F888F
	1A774D24C40410A9893E10D9ECE3FD6C6A919A68EA5E1FE3D4441F3F9B1EC51D
	223511CFD3BD9C12E2A610CB8B76662D46F4FB1EF008D62C967E9A9553C94553
	D36B39DE07B9FF6504B118CCDACCBE68AFD2572388A5EF47D7DCFC82390055EF
	87915EDDAEBF2F3F7F1113F15427FE3A3D81A3B56D97D3ECAAAA53340C6E3265
	268A599677070FEF141667A204E2FBE1A8C583771E8B9C1A1C355106D25D134B
	C8B3858D6C0ADCAAF4C06C61334B32FDE3A337BB677F8770E9AD3724F0D61E1F
	4D88F0B87087C8720A67D85CD8487AC393CCA9D276B2B0C14F31BF456A6202C6
	EEE594E74EF151E30E919AE803919A88F7B3A9456AA2A97B7D8CBB97536A221E
	AC3B446AA20F446A22DECFA616A989A6EEF531EE5E4E519AC8FFB2FA0B107788
	284D24C431C4D09AD8BCE4C0A76A853DCA969A58820CEB59C781B997536A229E
	AE3BC49E26B6CAE4A7FE0DEF665B8BEEE59410F140DD21D6E534D2E7C219784F
	1B5A742FA791A0A1F4D9908FC8B43BC4BA9C46829A2913CDFBC412641D459E9F
	51271E44E962B891BF2682969CCD489BFD1A6875ECCC109F154EE16BD5C61AC3
	BD6D4FCDFEB9F31FFFA46B3DA924D7C0BA6BE25588CDD36E1338DDA84C0C71BA
	F6A8ABD255302BFB0F85BB55561BF433975342345C845898EE96D3D11A214B26
	A6EF13A3431C96606139CD0C71FF722A5C5A53135F3F467C77847B8BB1B2106A
	ED9319E2F44C58784D940656E216630B88ABD9786A4D26105F996AB1A084DAEC
	9E768BBEB019F689834C7C4FF8A103837B250BC7401D6E610C02F17068D4F7E3
	D92DCDB33D45B48EAAB085F3513697FAC4BA0AAD96B62BFB213271D462EC9E89
	534D8C00713500DEF01B7A51834BAD891120AE6662F19482A126A24A9D879D25
	4D8C00713513BF05E216E51491899EA7DD2C4BF3B60B1B4426668658B74FB3CC
	FCC869B7CB9938E913515AD6696B50E69F76BE57139D20964EB62AA9DB965344
	26662EA7E12F94BAAC877FA13B7D52EFE82C4EB4EFCAA07C6BA27090E9345138
	6F582CA18EB71D448407B52BB8D90A2FE4F7C208D93613433A7D7601B4F6FBC8
	1011999819E25769E231D97A999EE1B36685FA91720AC94461A9E966AC74FFA3
	27556CFF9C9FB4747656DBE12142FA44A9537BCE14EE5F6EA60ABEEC1055CE10
	3ABB6BF302C4E66937E978B243DC29138FCB43D481A785280D8EC676D44481F3
	96822E3BC425A7089CDDCC960BE5549D7D2701BDDF282A01B93AAF623F66A2C0
	894B412701A8BC23B87BE3EEA5681338A07B09FEE2BEEAF13213F7BD57A3BC1E
	A759D61441143D13FF0177CEA2499B260F7E0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="100" length_in_bytes="1551" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A10000058149444154785E
	ED9DD976DB300C44FDFF3FDBBCF5318D64ABA5552E5806DC3C3DC74D1A912089
	CB010859711FDF8FC763E7D7B1BC9DD777AC6D6B80BBC3BBD6B73D442A914A5D
	62932F31494F58A412375022212E0C3137758FA267EEBB75384D41CE0CC13BB7
	AD219E3514EBC475EA484BE4F72A6096FECB29D1024BDB671638D2794C0D51E3
	FCDFBF7F7D6B5F1AFB52878E683715448953B5A02CED25F31801AB34E6708835
	87590044F5A9CD7334D021104B0EB1029028A7D79823807683887062550DDFF9
	3F678951B91639AF5E40C321E69C24555CF6AE4B11C9FF17DE8A7D63BFCB866B
	CE9E5021E81B0AF13EBEC411F73E0ADFBF35F56E80D418641D021856E586414C
	E7DC82870297035E0BA7960DA205FA160D824086409402B4863B8DF3D1104B0A
	AD6DD46890708812803DE069407BDBAAD70C562414626B31BBC1BBC357AD1F08
	120651BA00EFAE5FA17FED441B115A211009B05CDEE472251AA41B2201966343
	2F45C220D676DC0A21306A8E1290D6FA10F2DC694D85D7B528E7AC64B7041215
	565D4A6C4D6E254747CFB5E92BC769D50CB1A4422A509723116A7443BCE7C2C8
	3B24D16AE961FFF04FCE67A7DF8C6A3441A40AEDB87361D5AB461744AAD00613
	AD463544AAD0062E77E33C1581478D668854A10F26528D10883C91EA81D672A3
	F680A382580BA5FA65B0C75D8DD6906A82C8508AD980A890EA86C8506A078A0A
	A91088F665B06729A46AF222210EDE4784381800627842447871B00D421C0C00
	313C2122BC38D80606E2CF1B203FEB10BD72E504DF7AF2ED82BBFF121F8B981C
	EC783AF53170F7EEA2C4D74E397745A938BD564255CA98A67E2A427C45C7D4FF
	A588D9946C2AEF1A44DEB991013C5AA5BEAA419486D6535D97CAEE5FD31BB2E9
	F7A5F7C1DE6EE0CAD7F4312D3DFEAC726A1D6AA844FC1E832B5102F16AC39C88
	01DA3D27A6905B10314BFC2C2BAD834D4B64CF124358234A4EA79FE57ECC6A09
	11E3C7A1560871A8FB31831322C68F43AD10E250F7630627448C1F875A21C4A1
	EEC70C4E88183F0EB5428843DD8F199C10317E1C6A851087BA1F33382162FC38
	D40A210E753F66F06520A66FBD6096BE8F1542DC80E5F410738F236CE077E812
	A68778AC96CFDDD4992F01F10209DDBE1B199B0662E9292EC4CF37E2955DCA14
	105B1FD2EEB9FE09A75A425C48A6A50D498884F8FCF58AE32FE90B91E35A36EE
	4F972FC4A998F3EE6B4E1B0E53620B84E7FA6E105B6556778852C5DEDBBDF241
	55F117F81D21D6CAAC2520DE8AFD22C855207AA24CA96FEE1794348211E7438D
	D1AB6DE1B65B76CC95207ACAA656DFCB0F1A7F87424C61B6264588CFFF139910
	3B1C65EF39ACA52CED75421C003122474A0E826964EB124E5BA1F4F966C7F333
	20663F9D964E936898129FFD4D579AC6D6B6929DB53AC4966F243E68D9285DA7
	129521D852D749CBACA9214A76E1AE4AD4945953432C8681D727774872E26B23
	2875836F6E51E2B53E2BA456BF2EE1B4A4C4F4385D5362D20E4F4569714A8897
	8323BF7E7D7D9D27CF7447964E73B37F46CE94105B52455C5F5D8969286F4194
	E47F844FA7A913D305B70E362373621ACE6B10D3F47007150977684E7CDB4D13
	16FBCE90FFD3FD5F0A29A5947B8A31FD1B2D6DABBD961295E70F68732AF1754B
	AD05777688D7AE604EAC3CCF3333C454D62D886F9B3589C767682DC567E7CF99
	139581D70A310AE0F3AD03C5D36E916DA944DD4779A79BA20B44C9F17A778854
	A232E44536B78653E6C4482A4ADB568854A2D2D191CDAD10A9C4482A4ADB5688
	1FA54467C914E9ABAAEDECC93D53275E8A447DED5662684EA7DB412C9570D685
	1EF66E7DBB941891F5E5D4B66B75B813629A63BB409428716A18D61B228110BB
	17FB5B0292800D8448254A0020DA0442A4121180243602215289120088368110
	A9440420898D408854A20400A24D20442A11014862231062AAC43FDD5BF774A6
	F5C7370000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="101" length_in_bytes="1607" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E7000000E700194D934C40000000774494D4507DB0B190D063A76
	62822F0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A1000005A649444154785EED9DDB92DB2A1045FDFF3F9BC7
	79742C65E46A295CFA4A83B44FD5D449221AC15EEC0624EC79BD5FAFD79D7FB6
	EEDDB97F5BDF6E0DF0EEF08EFEDD1E229C08A72E31C89768A4252DC289377022
	202E0CB1D4748BA3678EBD753AA5206786606DDBAD21EE7B28EC13D7D9476A32
	BFD501B3C42FE7440D2C69CC2C70B8ED981AA244FC9F9F3F6FE98FA47EAEA019
	E5A682C811550A4A539ED38E0C58B57BA6436C09A6011015D36A6736D0148835
	41B40038CE1975CF0CA0C3207A88D874C3BBFCDFBEC5685C8B6CD728A0E1104B
	22711D577CEA5245F2FF85D3665F1977D4616AB32555306243215EEFCF11E21A
	23D0FE54D43A0068652EFD60C0D03A370C226D730F9E17B812F0563AD50C1029
	D0533608021902910B509BEE24E27B43AC39B43550A341BA43E4001C014F02DA
	5A56DC676747BA42EC75E66EF0AEF045FD7704E90691DB01EBA85F21BEB5A28D
	48AD2E1001B0BEBD29CD95DE20CD1001B09E1B4639D20D626BC4AD9002A3DAC8
	01A9DD1FBA9C3B6DB9F0B81625CE4AF5D6407AA55593137B8D5B49E8E8B676B5
	32AC56D5106B2E84036573A4871BCD10AF7361E4139268B78CA87FD3A7A4D9AE
	9BD28D2A8870A11E7729AD5ADD68820817EA607ABB510C112ED4812B3D38A726
	B0B8510D112EB4C1F474A30B44AC48E5405B73A374812382D84AA5F26E20E2EA
	466D4A5541442AF519805E29D50C11A9540FD42BA5BA40D4770391B5942A9917
	0131791C016232008FDB03A2878AC975006232008FDB03A2878AC975F840FCBC
	00F9F483F553DA4EE0D5936D145CF5231AB3986CECB03AB5313047FB38B1F322
	92BEACAC6D4E8F9EC0953CA654A71E44AABFFA93C25F7B7FFED0828827373C80
	5B29AA550B22D5BEB5F9DFC1D0EF7BA17FAF99B4F61E8C96E777E939252D7A36
	39F51EEFC089FE83CCDD891C88DF43AABFEBA0AB133127CA400F9F1329E4DEC2
	46D615943EE6C7D2F4D433D7898BA870C789C02257A0B73AE5F0C13E51AEBB6B
	0420BACA99531920E6E8EE7A5740749533A73240CCD1DDF5AE80E82A674E6580
	98A3BBEB5D01D155CE9CCA00314777D7BB02A2AB9C399501628EEEAE77054457
	39732A5B06227DF59223D5BC7705C479D9B05B363DC4D2710476EF1E52707A88
	1B079CBB698FC625201E201F622C7137A781583BC5E5F1EF6255160B980262EF
	4BDA2DD79FB0AA05C4855C571B90800888FB1929D541296118E7C0D6B74CED4C
	EB42BC4E4DED6DB3D29C0888B221D5DA660D8728B21469F93E1F74C81F97EFE6
	C403F73473620F44E9FA69143640AE0231220B0D3D012E85589C0F2A2AAC04D1
	B26DEAC51E3A48B4162D6C24155F3FC3D18B05C47FBF13191065EB0D55E9EB42
	A4E72CE9754054619105D55693DE73652F73A93F1525A9585A76D574EA0D0F4E
	94994A555ABBAFE36CB3A403FFFBE15F6DA077DCEA4EEC7C31826AC1C2D518AB
	53A11FA54E946CB3B8D0AEE58640AC358EA6989E136B4F3C840CCCC5A510BF29
	8FF1D46A6A88B5F9804EE22D88DF726604F60AA68478089CF1FF52AA99FD3B72
	A684A8B5B0246E7527D254DE8318B90AAD4E4B1218DE65579913693A6F416CED
	F122E10E59D8703AD05BD8D86733790DB58D3C2BE57F82874D51DEEED2D63723
	44FA2EF048A970626D68FF8EDA924072FF9423E8BC26AD13736203DCF575D5AC
	1029F4DEC286B327D666ABD4854DE69C581A4352277A40F406F7B8B71814A405
	E0F19104CD710ACE40D6827ECCEAD43227C289C23991595C3B68C3E27A153FCA
	897785D8836CB93E249D5A1A7897D84738F12EB032FA31B5132347AF566C6D9B
	A21EC16DFD1802D1D2711A7B3497BE68CDBCCE1A08B55FE1A4D57EABEF123B04
	22ABB3DA4E31E3B403C9DCF62088A7C16B6E2443C434017FDB76DAEC33DAEBAA
	4910C4299FD8B80A4740151FBB8D041904F1714EDC27FFC0834ACD011804F151
	4EA48BA028B767407CA4135300EE4A577EC1A836A563753A664B751A304110E1
	44AD0B3471411031276A60686382205227FE05AB2E8204589B88AF0000000049
	454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="102" length_in_bytes="1605" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E7000000E700194D934C40000000774494D4507DB0B190C351856
	ABCCCC0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A1000005A449444154785EED9DD972E4200C45FBFF7F761E
	F398693BA10B1304DA4060DFA94ACD62C4A2A32B81EDEE797DBF5EAF3BFF1CCB
	BBF3FA8EB5DD1AE0DDE1A5F5DD1E229408A56E11E45B4CD29216A1C41B281110
	3786589BBA45D12BDBDE3A9DE6205786609DDBAD219E67289C13F739476A32BF
	5501ABD86FA7440D2CA9CD2A70B8F3581AA2C4F95F5FFFBEA53F92FEB90E8D68
	B714448E53A5A034ED39F38880458D190EB1E5300D805136AD7946030D814839
	440B80A39C596346009D06D1C3894D357CD77F9D478CC6B591F39A057438C49A
	93B88AABDE752191FCBD7039EC2BED521FA6395B5205C37628C4727C8E234A1B
	81EF2F4DAD019077E6B20E060CAD728741CCE7DC83E705AE06BC954E35012205
	7AC90683400E81C805A84D7712E77B43A414DA0AD4D120DD217200CE8027016D
	6D2B5EB3B3225D21F616733778257CD1FA1D41BA41E42EC01AF53BD8B776B423
	52AB0B4400A48F37B55AE90DD20C1100E9DC304B916E105B11B7430A1C35470E
	48EDF9D0E5BDD3960AD3B551CED9A95F0AA4575A3529B137B99D1C3D7AAE5D5F
	1976AB6A88940AA140598DF450A31962590B47DE2119AD9619FD1FFEA9F9ECF4
	9B528D2A8850A11E772DAD5AD568820815EA607AAB510C112AD481ABDD38CF45
	6051A31A22546883E9A9461788D891CA81B66AA374832382D84AA5F265C0A254
	A336A5AA202295FA04A0574A3543442AD503F54AA92E10F5CB80259552257511
	1083E308108301780C0F881E5E0CEE03108301780C0F881E5E0CEEC307E2FB01
	C87B1DAC9FDA71028F9E6C5150FA2FF3318BC9C10EBB531B03B3B58F123B0F22
	F38795D4E134AD04AAE431CDFDD48398FB5FFD49E18FBCDF7F6841C49D1B1EC0
	A355EEAB16C4DCF7ADC3FF0926FFBE97FCEF9448A9E760797BFE929ED3D2E2CF
	26A7DEED1D28D13FC8DC95C881F87949F5771F542A113551067A7A4DCC21F736
	36B2A5A075AA8FB5F2D413D7858BA8714789C022F7406F77CAE18373A2DCEFAE
	1680E8EACE98CE0031C6EFAEA302A2AB3B633A03C418BFBB8E0A88AEEE8CE90C
	1063FCEE3A2A20BABA33A633408CF1BBEBA880E8EACE98CE0031C6EFAEA302A2
	AB3B633ADB0662FEE825C655EB8E0A88EBB261CF6C7988B5D711D8AB7B48C3E5
	211E1CF0DE4D3B1AB78098403E4458E2652E03917A8BCBE3DFC55ED9CC600988
	BD2F69B75C7FC2AE161037521D1590800888E73B52AA17A584669C17B63E6DA8
	775A37E275996AEF9815A64440948554EB98351DA24852D9CCCF7AD0219F2EDF
	4D8909F73235B107A276FD12850D90BB401C9185A6BE012E8558AD0784177682
	683936F56C931F24BE166D6C241D979FE1E8D902E2CFFF890C88B2FD86AA75B9
	11E9294B7A1D1055586446D46ED2BB56F63297FA5351928EA56D774DA7DEF0A0
	4499A854ADB5E73ACE314B1AF89F0FFF6A0DBDED765762E78B11541B16AE8FB1
	3B15EA51AA44C9318B0BAD6C37052235B93CC5F49448DDF1103230379742FCA4
	3CC65DABA52152F5202FE22D889F766604F60E9684981C1CF17B2DD5ACFE1D39
	4B42D44A5862B7BB12F354DE833872174A9625090CEFB6BBD4C43C9DB720B6CE
	7823E14ED9D87016D0DBD8D8AB99BC07EA20CF4AF96FE36925CA5B5DDAFE5684
	983F0B4C29154AA442FB376A6B0E92EBA76E91D735699FA8890D70E5E3AA5521
	E6D07B1B1BCE99589BAD4237369135B1164352257A40F406F7B8A71839480BC0
	F49104CDEB149C40D6827ECCEED45213A144634D649A6B83586507251254CA23
	8635ED8DB64F205B077C558428A2764A3AE52CE6EE101F5913472BC9DA3F9458
	49198A2CC211F8B436BD8146DD823BC69D924E39A964D2547ABE565F270DA9FF
	C249BBE0A3BFC2760A44B567B40B25941E328F411073614C81C851E248075F0E
	FB8E81C19AF320884BDEB161394401A07ADB4DD18F7A7E83203E4E8967F11FF8
	A25213F020888F52625AECDD203E5289EA74684DBD50A2DF11084A3446639803
	8DF376512F940825FE09A4DFC37E2E8CFF8C761C446EB418D80000000049454E
	44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="103" length_in_bytes="1639" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E6F00000E6F01AB038A140000000774494D4507DB0B190D1B1C5B
	036BCE0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A1000005C649444154785EED9D8172E32A0C45F3FF3FDD4D
	D23A8B0992AE849001EBCDEC74F71963D091EE05E2B68F9FC7E3917FD68EC1F6
	005F39BA7B926E0F717780AFF96D0F312BF1069077A8D4ACC40D12352126C479
	3DB5C56607E96CCD61EB4A2C41EE0A3057A71B48E976106B2665F571D756AFD2
	25E5F40BC8F34CE6C7F86707B8D3433CF99A119405F04A7E3A1DC4ABA049A067
	867A39C459A1AD04F5128807382950E8F59E4526FA0CA9DD674E3D8331DE1B0F
	B1C3D78C73342D3E2568ECF5C881467E8A61A93E4D2C9E416DFEF7FE1483B986
	3E430335BA2A632A11AC3E24A02491C685CA6FE15BC17160DB1AA4B3CE364321
	22D5278D1F8E7CD5B079766AEC0C18230934A22AC74114AA8F0A8C31CEAC648E
	E8934812BE3AA56C305E1F02F1CF879A13F2AC10040EE789C8FD521B0DCCF758
	8CA0B8FBDC216A004A015AE97ACD865A088D00E90A1105B8121CED58ABC514A9
	469E15E90791F140EB2A511BC059DA2320DF95EA24AD2E1D65057EA70F02D24B
	5ABB212640BAFEA3407643E40CBCD827CEA274E1E34040F6CAEA108877F34029
	3344909DDED805B125A509903EC32D94E9B46AEDF5463344CA0B5342658F6C59
	500F4833446A20095186482E068DB23A04A2E41177BE4E496ACFBED10431BDD0
	9E86DC22C72AA96A88E9857680C79D5C355A40AA21A617FA41F4F2465788FDD3
	BB4F0F9EDEA886C8F9E17D10F4CFD473CFA882980B9A7E78B52F5231D51CC5A9
	20727EE837BDFBF4E425A909F1C29CB904625DFA793AD39F012D90DA6D86AA12
	13623FB4BA8784E81FD3F01EC321D60B9B94D37EE6A42F2A0EC355729A10FBA1
	2172AA3D0C172196262B79E2DF75FF996ED6631927494E91450E04F1E8888398
	D28A675A192B0EE2E79A20ADCFCBBFAF96B7BED6F75272DA7A063EA5FBB4E458
	20B1253949C73BA76CA85E102632EA3E548C33952AF1F044B8121188479BF444
	23B5EAB6704FAC7FA04F59F6E983FD50A5858D5464FA9F28C5C869FF74EED943
	EE1337E01E0E51F2C40D621A3E8570394D88FE8CC321E6B15B0C44F763B7D3EA
	281736EE14D313DD431ADF61B89CA627FA430E87989E1803313DD13FCE437B4C
	4F1C1ADE98CEC3E5343DD11F6C38C4F4C41888537A62F9D18B7F18D6EE71194F
	4C8874A285CBA9D613F3B50D5925C2215A3CB104294FE97E2DC2E5D402F18525
	E55427A7431736949CB664D3EBFFED5E9BE1729A10FD532A1C622DA723FFBDDB
	4B5894A55CEE890911AFCC6920D6729A106588D2362B5C4EEB077AFE5BBB0795
	C3374F0B6E9B150E117991B5F98B8B815F25B033446E9B15EF89867DC3290BB9
	FB17797FC7100228F7BFAC49F120F15BDBA011100F6CFA0135B884F8F941B66F
	559A05E2E91B718441AD22A7A4FC81BFD40C590C26C4C1EB990888438FDD3425
	FEF5DD54923C2C26A7484575B591E2555C1FEA892AE80B432CADC06DDB351B44
	44E357F644787E0A309A0298A6125786287918BCCD32420E818864AAF5B3CAC1
	EB98AFEEB59B73D5366B668894349CE00A9EF857A9D1CC20884892226D34127A
	5A385A6FD4DC474DE093D5CFBF70725A647F426C54EB6FF08E20067FADC7534A
	2AA72C5792D4CAA9E6C0435318535622E78957576229E512C491B249DA9295BE
	C77DAB786299442D88A59A71D6E111B3E6A744A33AD69ED8709E78957C0A927E
	3AB0FEB286486B8A80883C63468847F2489578EC13CB855A3DE791329BFB44A0
	CCD313394D2AAFAD7E762ACCF3169538B39C96C5CA2D6C10DB18D126444E9181
	AF0C513A3B2DF7E1482CB46D42204252B2B09C2210B56034ED432042035A1822
	92A4481B284E0DEF0D81884C60653945E6670584DC1702111AC8EB0CB7A8C6AB
	8FDAA89D8774EC067D6283AED8C1762110A14C5D584ED313FFA7F6E718EB1514
	300991221FD2A6560DE92147227B7F0D8B145289B54CAD02913B6A7B83A5DE47
	B54EF0D55F756F889C4A593AEC3AF742AF3588DAFB06412C0B23042252894340
	6E0CF1F429D190E069B37554FB8D216625367C6558320F92D3ACC40D2066256E
	00312B71038859891B40CC4ADC00625989FF00FCF3B0AE1B54D6490000000049
	454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="104" length_in_bytes="1673" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	0070080600000029229F750000000467414D410000B18F0BFC61050000000970
	48597300000E7000000E700194D934C40000000774494D4507DB0B190D1B1C5B
	036BCE0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A1000005E849444154785EED9D0B92E3200C4473FF4BCF26
	D9388509482D21C980B555539959DB18F4683522BFC7DFE3F1C89FB563B03DC0
	D71CDD7D926E0F717780AFF16D0F31957803C83B283595B8C1444D8809715E4F
	6DB1D92175B6C6B0B5124B90BB02CCD5E906A9743B883593527DD4B1D555BA64
	3AFD01F2DC93F953FEEC00777A88275F5382D2005EC94FA7837815340EF4CC50
	2F87382BB495A05E02F100C7050A3D3EB2C844EFC19DF71DD3486794D7C6431C
	F035E518558B4F0E1A793CB2A391CF6268D42789C533A8CD7FEF67318863E83D
	2450A35519A344507D4840BB441A072ABF852F05FB819535486383E7B84244D4
	C7F51F8E7C756273EF54D918D0C72ED00855FA4164D4D70B8C32CE64CAF468B3
	3349687572B34179DC05E2C7879A03B254080287F244E47AEE1C09CC775F94A0
	A8EBCC214A0072015AE978CDA6B710F200690A1105B8121C695FABC554371B59
	2AD20E22E181DA55A23480B39C8F807C2BD528B59A34940AFC9D3E0848ABD43A
	0C3101F6F51F0572182265E0459D384BA60BEF07027234ADBA40BC9B07723383
	0539E88D43105BA93401F6F7708BCC745AB58E7AA31A62CF0B3385F21ED9B2A0
	11906A88BD8E24441E627731A84CAB2E10398FB8F3F15E4A1DA91B5510D30BF5
	D3905AE46853AA18627AA11EE07125A5460D4831C4F4423B8856DE680A717C78
	F769C1D21BC510293FBC0F82F1915AD68C2288B9A0198757FB622FA692AD3811
	44CA0FED86779F96AC526A42BC70CE5C02B1967EEECE8CCF8016486999215262
	421C8756B7100EB1F6C454E238D46E4A15ECA38A949810C7A1214A94EEA32644
	7B2EA2164394589A2CE7899FE3A241DCF1E4324E9C27228B1C5689DF9B3C7FA1
	20A63FE2D3B18C1505B18C3DF90AF08374EBB1F6D69E27B63C181FD27DCEA4D6
	2A486CDF1F77F2792B40F9285222B5B04925E2939153E2B1B08195C8EDD1A527
	E270D033C33DB1FE409F528DA93E145BFF3C6E61C3894CFE8952D5FB2D12A20F
	C4AC13C7E31ADA424B89AE10A9122374E41BDD2C3C9D2644FBD9130E31F74E63
	20BAA6D384B801C44CA73110CBDADCBCC448881B40CC741A03313DD13ECEAE2D
	669DE81ADE98C6C34B8CF4447BB0E110D31363204EE989E5532FF66158BBC565
	3C31214EF45494D413F3651B7C9658C2134B90FC90EE7746783AD52E6C329DCA
	D2A9EBC2A6974E5B69D3EAFF76D766783A4D88F6532A1C629D4E3DFFDEEDF53B
	3D4BB9DC131322AECC6920D6E93421F210B9322B3C9DD637B4FC5B5A83F2E19B
	E70CAACC0A87883CCBDCFCE262E0AB047686F89A4ED3A4530DC4D32CA4EA8E45
	5E986C553AD5EDFC5893E046EC1B6A34E08E6B9A7ED0EB5C42FC7E90ED5BB5B3
	402C61729D5A259D764B02F04BCD90C56042745ECF444074DD76E3D4D43B0ECD
	ACC5D229A2A8A173664BA710FC85219656605676CD061151E2CA9E088F4F0006
	9AF89FF65C57A7A28EFCFFDAD8D30AAD575B39DB1ED97CD71309407099A5841C
	021199A9DAE72AA3814A218ACAAC9921420B1EC6136751650B22324991732499
	EBF4367CED8592EB7A03F806E4F90BE58945E0A285F773BF29211E01BEE2B1CE
	1E2D4F6CA6A30B514AD3A964C343228C29954879E2D54A2C533907D1336D766D
	494BDFE2BAD38027F6C4721251E9B4B4873A3E9E70A7599D529E7855F6A4168B
	5CEAEF7D8497CBFF5B28CAA28D19211E938753E2B1D7797B257AD78923258A85
	272E9F4E21A53AEF9D8E402CD3B9B6C4806240E56FE2D8F69E685DA26821DE42
	899E9E58821C5D24712586A7E22E2D31A059B8703A459EC4856230733A456667
	3DC395E3416E6572CEB110A356A426370202318D27B68A63ABC5C8680A6D2E6C
	80E09EB6C6842F7E924C801088920E957B8D3B41D4C400BD2604A2C60FCA02DB
	5249A36D69D3E71103EBC7F70E104A3BFABC89BBF60E051C8FDE4B19B5037CB5
	575D1B025134E84F07B5638CBAEE6A88654C4320C2037624A0994826FDBEB312
	4D02D850B565BB505B4E106FA5C496B8A1E05B65052788A7F225624097A5B202
	C4657D7082782B25967567C484FDB98713C45B2AF11280FF772BDA3FDA74FD29
	315289DA006AAE7382984AD4C0D05EE304B154E23F2246F44E4828F3BA000000
	0049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="105" length_in_bytes="550" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D3000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC200000EC20115284A80000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A10000018B494441546843ED9BE10E82300C84F7FE4FC19BA210A7842857
	E809C7763F08311BA5BB6F2DA56A29A58CA4E36966B6A57C7EB9F73EA9FB4B63
	4333B456D09FD30A70D80CC330668E4516D85A518D98F4AA1B338074992167F8
	4CD796B4814FBA6F4C7F89E5DC0A32DAB1128A5EE004D2E556902FD0AF895BDE
	0A32DAB14D1039B008A4CBAD201F58BF2FA9456DBA6E4A1B88155E68C7F64A14
	E9E248EE606718B221C77A1CCCF7644E7786D7665DFBF36D4FA8FB2C17C948B0
	48E0A16754C486C29CE83A90661A9051E1166C7B56305171144032DAB8148890
	019A901D37E4CDFD68C8EAE1BAE15F3423750B39F49C5A6488E8FCB30BAFC81E
	ED1672441CF5398E64429A33E41DBF0348BF27A3C2CC85970BAFB502D134E748
	168DE46881F4AF7967175EE175A06C981D574BD7EA11CAF6AFCBEA9A2DA2BA3D
	43562744F0CF900922AA9B3064754204FF0C9920A2BA0943562744F0CF900922
	AA9B3064754204FFCE817CE02BBB702767659BA04973268E6AB9F73ADAFF93D1
	8D2742B5377DD5F957AFFC2A7F906694F1071F4FF3D07ABCDF50000000004945
	4E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="106" length_in_bytes="539" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A10000018D494441546843
	ED9BEBAE82400C84F7FD9F82375D2F1125E41C66B4553ABBF383104359DBF9BA
	A534DA5A6B3DE9B82E735FABF2F9E1DEF354DDDF3436690BED15F4E7B002396C
	9665E9916353058E225A774C38EAC11640BADC2147F8DCEE6DE1055EE57E30FD
	4B84230519656C09454F7002E92205F904FD86F84A29C828638720F241104817
	29C81FC4EF5BD6A636DC378517E01A2F94B1B31245BA78274F9019866CC8DC8C
	23F33D39673A933766DDFBF3574E54F7B9DC4E4682311B0F3DA398352AD8B071
	20CD6A40468D1B39F65CC1B0E254009931C64D8108192083E8F57721F7DE9BFA
	F1889949444356856DC8C7F97DE5EA9D1CAD9EFBFBC3DD3572C8E5FA30AB5DAE
	5577B5CB3528D74CB72260C3BE25CCB9930500322E4E0B997AF1DF3CC3B3EDCB
	4EBC505F13BD5EADF16276C948365396EB910032B11832A392B88D218B0364DC
	37644625711B431607C8B86FC88C4AE236862C0E9071DF901995C46D7E03F98B
	1326E63756E28CC2EE674FF5FE5B2FEDFFC9C8E19B22EB4CF7ACF39ECA597E6C
	BF17E916BE7E01DB2CA44AA188EB1A0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="107" length_in_bytes="500" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000166494441546843
	ED9B6B0E84200C84B9FF29BC29BB9A651F6E741AA70285F9618C016B99AFE5A5
	A69452763A9E66365B3D9F5FEEBD4FBDFBEBC6C6CDD05E415DD30AF8B0599625
	33C7572F70D6A2923174AB07338074D920337CD67B136DE0D3DD0FA67F17CD09
	0519456C178A367002E9120A7203FD86786428C82862872072A111489750902F
	B45FB794492D3D6FA20DD8265E286267258A748995C939E7A4E357034364F705
	5900FD83B8C7EEFA74774641F01F04D6ED647A48A50D18F7BE05393064142425
	5A05F91832D2902DA7B7359103827C3C567B8DB99001AAC0960BB2204FBDAC52
	264FB0AE166441A6DF2397A15613AF86C1A44C6E287EADE59E200BB2BAEB5AD9
	76E77394C9CAE478996C78AD36631597578968C3AADAEC7A468286360BB241A4
	E85504393A4183FF826C10297A15418E4ED0E0BF201B448A5EA50E64EB77460E
	F5A203B9C37F9FBF16F127586EFF27238757915AFF0FBC07D5DA1FA4994BF903
	FC1A7BF19999875E0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="108" length_in_bytes="364" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000DE494441545847
	ED968D0A80200C847DFFA7F04DED77B50C73D62C822F1011565EB7BB6D218490
	A615637C7DC9DDE30E88390B308126C4893001137955461368E21F9A504A95CE
	56DCBD668F933BBE0631B5F3EA93927FDBCF99F81C4415C03CF9C0C4CA134C88
	6034132D7636C62E23B78CDEA5BD3788567758E2E5C72CB107062E5F504C583E
	DC02C21EDB11044C1CD26ACA49C77498EE5F72B6F70E6F61A289479AA88E7FAA
	EAFAA62ED7C47ADECABD3AEB166001715F138E20EEBBC311044C3C72872E5E1E
	C24413920E988089BC94A3093481264A030EEEC01D27770C9690F4F481E3D7D0
	0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="109" length_in_bytes="377" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000EB494441545847
	ED56010E832010E3FFAFE0A76CE8CE9D285242D19874092131386ADBBB5E0821
	A4BC628CB72FBBFBBB0BC4A282989027AC12C5849828BBB23C214FBCC313CEA9
	966CD59D357B1CAAE3691039CE9BBF94F8B15F32F13888268065F211133F9EC4
	8419C633D153CEE0D975E4B6D1BBB6CF06D15B1DC879FB30E4EC8E81CB171C13
	C81FF780C0CF4E04212676B2429A4C9403BA7FD5EC9F1D6C63CA13439E688E7F
	AEEB72A53BF3447EE697BB11375B9119DD1D930402072C264EE6894D36921C63
	7D8204429ED894469A49353B4872C81343D9C12E515587AAA36C0BF2843C214F
	D4C2327D003D3A6295462598A90000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="110" length_in_bytes="320" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000B2494441545847
	ED96ED0AC02008457BFFA7E84DDBFA10A4266D908BE00CA41F0D94D3BD6A0821
	A41C31C6DF4372DF2745945780049A10274202127D57461368E20C4D28A5CA64
	33CF55BBC7E08EDD45E4713EFD525A3FF67B12DB8B981650361F48344E9010C1
	68125FECFCF2DFBA72CBEA6D9DDE4598EEC8893DE229A19018EE3C0A6844752E
	337F7D1F48A8DEE041034D08554840A277189A401368C29A3BB80377E00EDC31
	DB4BE913F409FAC4517DE2022CB3EB6015B253BD0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="111" length_in_bytes="562" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D3000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC200000EC20115284A80000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A100000197494441546843EDDB690E84200C0560EE7F0A6F3A8B195C10C7
	16FAA0CAFB61CC248E2C1F858A3184105E4E8E4F35E6BA20CFBFDB2F2774796E
	FAD64D45528107FCF6D1B7D334BD7A1E9B59E401A68726CCC83DFBF75B76E85E
	8175B9203228E0888C1D5A8CE4792A6124C3A773463223199F9431921BF43113
	2F6828734DE69A8C8FE2268F508ADD34684875BAB96833043D9B42132F05B0A8
	332AEF97736E51AEA80C24340C3901910652DC4B965EEFF53A4D3B9641808286
	2017026F5F4C78C593D64B831CDB0D4BD2CC912B80474686429B2257028F8E0C
	8336433600DE35B232C9CA253BAD132FE9D49E5E67BE469B201B013392576E53
	E86A64436022EF63DA0CBA0AD91898C8C709DE04BA1819004CE4FC2A5E0D5D84
	0C488A44BB4295E5B64EBC206D2AD93051238322B834131DE97FC511AD422670
	F73155042D46267077E0580135B40899C06E808BA02F9109EC0E580DFD1799C0
	6E8155D0A7C804760F2C86CE2213F836C022E80332816F077C091DB712A5AFE6
	6EDB038354FC6C972DFB7DF27674C481F084736ADDE2FBE496FD960DDA370157
	BC9F744FE9E10000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="112" length_in_bytes="549" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000197494441546843
	EDDB010E83200C0550EE7F0A6FEAD40D750E670BFD50F42F71668913E8A3802C
	0B2184D1C9315563A90BF2FCB9FD7A4297E726B66E2A7214B8C1671FB11D8661
	6C79EC46911B98FE3461416E19DFB9ECD0BC02DB74416450C21119DBB598C9CB
	50C24C860FE7CC6466327E51C64CAE10632EBCA0A9CC399973323E8BAB3C4229
	76D3A029D5E8E6A2CD10F4680A5D78298045C128BC5FCAB946B9A23290D030E4
	03883491E25EB2F47AAFD769DAB17602143404391378FFC384573C69BD34C8B1
	DDB0459A397201F0D2D8E935BF757D7C6220ED10F13A58469B2217023F1D1996
	D166C806C0447EE7B479469B201B0113791BE04DA18B910D8189FC3D8B9B4117
	211B033F79757DB6483381CE46060013394D5D0C9D857C0016EDE838F84E2A84
	BDD4BD085A8D0CCA60ED33E513AFCF86562113B879DFCA82162313B83970F6CE
	980899C06E80B3A02F9109EC0E580DFD1799C06E8155D0A7C804760F2C864E22
	13B81B6011F40F3281BB03BE848E5B89A99D9F6E5BFBE08A9FEDE025FF9FBCEF
	1DB123DCE17CF4AFF1FFE49A714B26ED0BBD346D19AFC7F0330000000049454E
	44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="113" length_in_bytes="557" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A10000019F494441546843
	EDDB5B1283200C0550F6BF0A774A2BB5965725900431733F1CA70F2BE19080CC
	D439E7FC22C7BB19A12D9AE7E3E7CF93F6FD96E9DB651A920B1878BD46DF6EDB
	E6EF3CA22A62C0B4082120DFD9BFFBBDDDED0DF84D1740564A3820EB0E2D6472
	2825C864F5728E4C4626EB2FCA90C913FA180B2FD554C69C8C39593F8BA73C42
	5177D3BCF7CEDA418D5DBB9AAA2EBCA841EEDFB306BCC7D313BF26B41A721660
	73E2338ADC8C3BEE272D6815E45EE030E46D966B0A7292F11AD0E2C823C0400E
	63E1DC18928616451E0506F299F02AD062C81C602027555D1C5A04990B0CE462
	EA168566234B0003B9BA3E138366214B015B45E63C311CEC22D0C3C892C0402E
	77FBA2DC66430F21C7C09CD18A6B695BB9DCC7AB6EE43C83014583E2F413B774
	7721D74A34A7F1B8963640B8A59B8C2C3D07E7EB4980A7E0D5F5F6E7CDEE399A
	84AC0D6C75E17501C5FDA80BBA893C0318C843E664E84BE459C04321E22272E9
	FE8B0CE0C78CA26646579101FC18E06F432FA10B64003F0EB8099DD475003F16
	B880CE2D6B7FAF8C2FFA0E040BE75C71C6FF9367F65B35695FA12F49BBEA0AD4
	A70000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="114" length_in_bytes="429" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A10000011F494441545847
	ED970B0A8330104473FF53E4A6A95A12624C7436D9590BDD82D842D1C79BFD68
	0821A4FD88319A1FF9DEDBD9218E14FEDB44550FEF986801CCE3E80198420C00
	ECE21819D82D98987800E09B783240370102F04C80005984FEEE1002E89B1002
	E89B9804D033D1001C17967C961F6A3A062410EB26EE46B189899B1AB031818C
	62AA09A00BB8260080BC142522F08909024821F0EE10004821F0E7890A02D1CC
	A90922849B38C50AED0E621C53DDA15D983F56139DE781FCC6DC9E79265E8490
	CC94121DCD0472E13C8E4731CDC4363DE2BF4A52B1B87D4DF5EFB50B033AEA3B
	E7BFAF42CCD7849BA832D08A43D476A782538CC36BA2C40974E565EDFB9C6015
	A67747BFD8802AF5DD71E9699F988405E6BBC377473B8ED2074349239975A816
	DA0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="115" length_in_bytes="408" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A10000010A494441545847
	ED97510E84200C44B9FF29B829BB6A6A1041A7D8A99B6C4D887FFA7C9D164C29
	A5B2AC9CB3FB92777FEF01B156E1BF4D547978C7440BE05E8E1E802BC400C0AF
	1C23038B05171337007C137706E82640009E09104044D8EF1D4A007B134A007B
	13930076261A80F5C19AEBF1A1A6634003F1DCC4D52876317191011F13C828A6
	9A00BA806B0200904D5123029F9820801602EF0E058016023F4F541088664E26
	881061E2505668EF209663AA3BAC83F96399E89C07E48FB9BDF34CBC08A19929
	7BE968269007CB381E9569A66CD3237E5352CA69555F42537CA0368498073684
	50852D4CD49DB3D7CFB01C9109311C26C244BB4F452622139189D1E92DBA23BA
	E3D41D1FFEF9912BA8FA8A500000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="116" length_in_bytes="430" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000120494441545847
	ED985B0EC2201045D9FF2AD8294A2D865270EE0566FAE198107E4C7A3CF3B421
	8490F289319A9FF2ECF7ED104714FEDB44950FCF986801CCC3D10330851800D8
	856364205B30312100E89B900CA89B0001F44C800045C4FED94102EC374102EC
	373109B0CF440D90520AF9309FE5A5E6368C38887513DD61C441AC75CCE130E2
	20E64DFC4A42939C90AA8084E04D4800C744E4C2C1E504023001819B40012620
	70131584D883C8704C99D80DE1262E46A1D9E139515E19989868FA40F9B7DCBB
	F5AAE341087CFB290D88B94565D5172012E6E1331D13025684F8764C11441102
	8AC487F4DC11985BFC659E131D45504C98307875B4B6C0C48422E1D571DD7CBC
	4F9C3E144BD467C76DDB164B5A311CDE278A7D37E126DA4A4C2F4AB40DD9C171
	EE290000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="117" length_in_bytes="481" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000153494441545847
	ED97810E83200C44F9FFAFE04FDDC0E09081DC01A75BD225249A547CBB5E5B74
	CEB9EDBDD0DF11BB6D9FCBF070761F6FD10DC9D8B8AD02E2BC3140AF80605433
	254E4952A4C33C5197D8AA03502085288C697DE24B5D34238A74589FB03E51F5
	1F53A70A6332EFFFADF3442047165DF6AB1F18971820396D1E4ED86915CF3210
	4CECEE89FCC5ADEBD1633C92E3140308C67F773000A87468DCF1872284F7FE72
	6515A153E24188A301FD9712D2EA40D321808826A68C298018F3440F846C56BC
	1248D72421702582678AE979D52F9866852B918C0B8230109C12040803C12B01
	823010634A00200CC4B8121D1006624E890B1006625E89060803B14609C023DD
	9E02CD8EDE809B04C106180A4176D63440D7430C806820089075D5D14A17386B
	744A8066D52B0182E895405AFCD23ED12BE596476E856855CDED10359047200A
	90FB8C59FA25FFC83625821A2F03C078445231EE240000000049454E44AE4260
	82
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="118" length_in_bytes="422" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000118494441545847
	ED97510E02210C05B9FF29B8290A0A4B1A7669CB2B685213BE24BBE3F05A4B08
	21A4F7E27EDADE9452A0AB7B88EA992721CABB55D46EA29E9B9B70135F03DE27
	5A143C139E09F2CFE6D5E1D541871DCFC46F656234CC0C065EC9C8289F310D20
	E4C00610CD44A6E12ECEF540F2EBCA5EEECBEB3E34C46522C6989E56078B86B8
	4C1C84F87313C0CB8FCA0437C89CECB4BB7079A867A2969EC004FA38F899C890
	A4B171CF7CB68FDF27AA2923904FDB9E1D47FF3D18446EC2CA88D80418446F02
	0C22CF04CDCF6246D64DA08CA83301328233B16A046642098237A10459AF8EBB
	6ECBAC1A3B135223F04C08ABC6DE04D788B98909C83E133323DB4C3C816C8718
	8D8A472008885DB39A8D8CFD25DB4D641B2FDB8BE1DAB0E48FB1000000004945
	4E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="119" length_in_bytes="404" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000106494441545847
	ED98510EC3200C43B9FF29B8291B744C2B5A894312F871A5FC8162BDDA2934A5
	94CABBC4A794922C356900F56FFB2D02EA5EE99157C48A80FA93C4ED35D2131D
	074990C438E1E8097A829E78FAEE331D4C07D371321DF5C40B9536AAD251BFDF
	7BA0E65D648088EB345F2BE73CAD4011EDDE715A0449DCEF35F4C487C76963EA
	D371FD25C07E980083EABB042251E7C83055353D666B71127D980509C186D5EF
	447516A227114504F6C4F87D7122B24EC29BC83209272176124E42F4E9783A7B
	2C7AC48F849588D913C6D4F8935825E24E4229248E8452885F3A1653134F0225
	12E6093035FB484844B6919809D92EE2DF51F1888841487C4481E85244B3C20B
	86F0DA1AFF52D8EB0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="120" length_in_bytes="638" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D3000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC200000EC20115284A80000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A1000001E3494441546843ED9B01AE83201044B9FF29BCA9BF35B5526AFF
	CE2E3B8A669A18D31481E531C3826929A5CC835C8F6E2C7D61DE5FD5BF6FECF6
	8619DB613AD212B8C1F731C6769AA6F9CCAB72911B30FD0A61817CE6F83EDB2E
	A777605B2E0499243841E64E2D2979B11229996EE72329999DA4EC6996DDA694
	1C50F2BAE5E19AAC5D3BDA0F4116E463763623D9B5AD9FEDB00429CB2C23257B
	B665CEC40B1D5C26E0FA44CE6A47761DB4EB68B2949D785980D7C940CF9E2D51
	C9AE1154DF6550479192834A8E61C97D4A902DFBA87FD79ACCCFB0E9765D41B4
	D652446BA88290BA7ACAA0FDB0623EC4CEA9901D80A1C1E8AC2F3BF14AEDB3C7
	FDBC6569901B203F5533CF73A9AF1E795DF4D9F764F1C243CB5320A380973DC6
	4D213BE3A2824E875C03460245CA5C51A1485C8D83D140A7426E15EC0DF459FE
	2E1F6FECAFB829A0D320EF59B43750415E50A7834E81FC6B0D16E42DA9DC4DED
	AB7CA4F93D157437E4FF922C410E434E557417642B8B16E42EC869A0C3902DC0
	E8F6089908574CC690B8C0F3816EEB0E4146000BB27DC80342EE56B41B320A58
	90532177817641F60016E474C861D030642F6041A6400E81862047000B320DB2
	1BF4C7030DCCBD5769E9892E9285A6377A408507C4E579D509FF3F799D1057BE
	B778D7C3F22BDF4DD87F32F7CF3CC901C4D80000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="121" length_in_bytes="628" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000001E6494441546843
	ED9B010E83200C45B9FF29BCA953331D636CFD857E81D125C62C562C7DFC4231
	8610C2DAC9B1B971F8C23C3F9BBF4EECE77513DB6E1C4909FCC1FF3E62BB2CCB
	DAF288B2C81F30FDE8C201B9657CF76787E60EBCA60B874C129C43E60E2D57F2
	914A5CC9F474DE9392D98B949C66D9CF74251728F92C79B849566E1DF5C3213B
	E47B2A9B9ED2B5AC9FD7660962CBB471256BCA32E5C26BDD7EA1F511EDCC4903
	C9D37549BA6E0D787FBE435616F4AE64FEBCEC73B29470F3D77D4E66CEC9654C
	CCEF72C831E4281D4B1B0F080934B8485B3536A81F529F6F599851D3B5023014
	8CCAF69AED78217E6BB29FD6960639E9588D6A86BD375709643A730D702D3CD4
	9E025903380DC4B04473F43235FD97FE51419B438E012300119B51C14B4A8EAF
	C77143158ADA99424E158C00446C26817C6EB2982FC6CC20E752340210B19908
	3205B409E46F73300210B1990CB239E86AC8BF16590840C46642C8A6A0AB204B
	AB6804206233296433D0C59025C08787490991DD8D006C26866C02BA083202D8
	217F0EF2E76BCA6BCC2625D4AFB15C5547AB21A3801DB229E42A45AB206B003B
	6473C8C5A061C85AC00E9902B9083404B904B043A64156837EBB2181997BFD37
	EA42B789DFD2DE75A5539AD7B3F0F7C9E78018F99CC6F58EEF93D9F112613F00
	2EFAFC1D7C6610750000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="122" length_in_bytes="577" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000001B3494441546843
	ED9BE17284200C8479FFA7F04D6975D0B3D41E09C91E81EE0FC7B919F5B2F9DC
	1045524A2907D9BEC3386241EECBE5AF1DFAFFC2E4364C203581057EC7C8EDB6
	6D79E476AB220B30FD25E1803C32BFFB7FA7E101BC860B4206198E90B1B7169D
	7C9492E2E49C735A6D3BB50DAF96C3032064F8981DA65CAFE6E25D0F9D5C9A0C
	966BFCD30D9D0CEC05E8643A193E169FFD169D4C277F60BC60770D77349D4C27
	D3C99647BB7FD37849A7312DC98C7AAE543BFA8514B45C4B45EEC7450565894B
	A31F091A06B912D89C06B02433EAB94DD1AF0F24A0131910C877C05101448AEB
	9E2F84A3DD21D70ED6245378E74F7398547B1174CDC879837685FC54A2A542CB
	0BFD69004A02956ABF5D0B02DA0DF25F63B05428215FA8DD41BB407ED7641172
	FB638887AAE00ADA0CB9D545137217E46B2E7ACFAF758C36416E013E2255BC36
	948C73331D23D5FE46938BA3BB214B001372DBC5825EC40CBA0BB2143021BB40
	36976E35640D604276836C02AD82AC054CC8AE90BB418B21F700266477C85DA0
	45907B01133204B21AF48F132A984F2BF2667A82593D56CD8A49F1FAE4F38698
	795F83FFC4FA6474BE9AB0BF0037FCC2C751F14DB40000000049454E44AE4260
	82
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="123" length_in_bytes="586" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D3000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC200000EC20115284A80000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A1000001AF494441546843ED9B61AE84200C84B9FF29BC29BB1A758DAB38
	A596569C1FC6BCA40FE87C1DA8249B524A39C8F35DC6B416CBF73CFCFAB29E2F
	8CB66116B227D0C1DF31B41D86217B3E9B5DA403A67F294C903DF51DE74EEE0B
	F81D17846C643842B62D2D3A79DA4AE864F3ED9C4EA693ED9B323AB981C66CBC
	4CADCC339967B2BD8B9B7C42096ED34C2DE53438741962BD9B9A375E02C89020
	8AF18E385BCF098DDF1364C44CCB5D32121B3906CDA3C999DDD2C90814541C64
	2CCF18340F42F6A4A49C9B900B02A2E2281998FF3B9AC76B9D0C352B150D58EB
	C60BA9A4D74246C4891E432773BB5E15A093A3DBF586627D0664C1D9883043B7
	39642CCF18340FA8FFD05E96A8BE930580A1648CC76BDD78DD9AB3067435E41D
	104FD7F43EF75A2CB5A0AB201370F3BA528116433E008C9C3F484C73E5024C88
	E8B2C454831641A683DDCBA20A340CB90058528DEE2A055B408D7662D010643A
	3858696C7EDA843463979001C035D5184E35A70569B4831D5D840C0076D286D3
	CE0A40A04F210B006BAAF1EDB4EED0EE12F428F2D5CD4C1144CE39F1B1D50070
	C225C352C032FEF65B6D298C27BEF77AF594D729C70FDCD0556D4911B1DD0000
	000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="124" length_in_bytes="573" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000001AF494441546843
	ED9B810E83200C44F9FFAFF04F9D1A75C44DB882A5056F89314B08947B3DC0BA
	8510C2ECE45AC2D862D1BCEFDD9F37EDF1DC68EB26902B8101BEFBD0769AA6D9
	F28A56910198FE4C61836CA9EF3A76300FE0BB5D10B292E1085937B5E8E46D29
	A193D597733A994ED63F94D1C90D34E6C14BD5CADC93B927EBBBB8C92394A09A
	A66A29A3CEA16288F66AAA7EF012408604A9E8EF1F67ED31A1FE47828C98E9A8
	25236D3DB741E7D164CF6EE964040A2A0ED297651B741E846C49A9726C424E08
	382F9FD0FBB59F1B903C79A7937B07BCC64FC8E9FCA69315DE44B93B78D1C9CF
	1748DC414636B20EDA8C75F01214271036A838485F966DD07934299654395900
	189A8C727F6E2B5EC8BC6BAA62C5902F8159BA66F4B14F8394822E824CC0CDF3
	AA0AB418F21FC0C8FE83B469AE9C8301115DE2DF8617154F4490E960F3B42872
	340C390158928DE62A390BA0443B316808321DEC2C35A2BF362187B12C640070
	4936BA53CD28A01AED6047272103808DB4E1B0BB0210E85BC802C035D9F8765A
	4F689705BD8A9CAB4625418CF042C1FB1C00276419A61A1CFDC7CF6A4762F478
	BFEA35D2BC6E397E001570736BAABCC1030000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="125" length_in_bytes="580" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000001B6494441546843
	ED9BED1A82200C85B9FFABF04E294DCC90D8D81AC23A3F7CAC273FB6F3723634
	0D218438C8F20C638BC572BD1FFE58599F6F186D87092427E0E0FB18DA2ECB12
	EF5C4E55C401D34B0A1BE43BF55DCF1D6E0FE0DD2E00D9C870806C3BB4E0E4AD
	94C0C9E6E51C4E8693ED27657072078D31F132B5327A327AB2BD8BBB5C4271EF
	A6C51883B7859BBB7535359F787113F50678CD879BBB27C8D5E6E71432D5F0BB
	F4EC9E4E06E4AB02803CBBBB291BA7728E723DF1840C90330566776D297E4006
	E463F68D728D72ADFE0303B36BC341E4A65C732FF83DF65C6D4E5CEDB4E55CE5
	646E90EB765A413CEEDFA29F06B41872162059993C42D2E6448AF6DAE078B042
	0A5A04B915F016A961EF9BF5D84CC86AD0CD900B80D3B3CBB59851AE0B837CD7
	92627D7E365C741BB409B2C4C15406E9F759DD588B9B9B7BC376A2D2CD865C01
	CC723295C89F429668D70C9A05D9D2C1703235FC8BBF3781262133004B46A328
	33873B69B46383AE42660076A8FB5429B1407F85DC0058331AA752D420D85F68
	4782FEB806CBC0A69DABB9799C308D96136370516F4F56DF4F3EE645FB871EEF
	F3A68167B1CEF59A3D9F7325F80AFA01400CBAA290C1365E0000000049454E44
	AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="126" length_in_bytes="383" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000F1494441545847
	ED57010E84200CE3FFAFE0A728203A89DA42B2A8492F21B99CBBAD745DC11042
	48EB7AFCA4B4871C5FBADF4C4CCE05739A825CAC3388820722710601EB5794BE
	ED1013A761803D716E07AC2F4D9CFBA5E9D8F87016A67C423E71796D808EE52C
	4C585F8E29C7BC56EE07CF8EAC6666A14B7C7B3E3F1DE82D81456091303B6B31
	4C7E6E773553891D01C02667E3F60D151031C6C765C0FA31C182C8168E16F342
	D5EF64880904603B6746DA7168424C34C1FD8A898991662CA0FA04CBC4AB2010
	C899E7D67B2826668AA0FF084463484C88897E5AA40969429AB83B43341D9A0E
	4D87A643774CC440EF130BBA5B0C260F63DB060000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="127" length_in_bytes="394" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000FC494441545847
	ED57010EC2200CE4FFAFE0A7E89860C16D779D34C6E44C488CEBDAF37A5720A5
	94CA735D7E4AE92143ECF67B5B530298D3C473B1C1202A1E88241804ACBFA38C
	6D879818B40C7B12DC0E585F9A18FB2577BCF80816A6E684E6C4E1B1014EAC60
	61C2FA9A989A98C7CA357B873DDC9E7D678E8C7321A84EEB8E0010B0FE873B02
	40F4BD6343C32E744DA14EF0F3BD832DDEE25683783391732E57CB30B51A44D5
	44FD873F04F11D132BEFA25E26580D316DEB315E104C72CEFB7BA6FFD504DB0E
	4F9CDB1D9EE46C2C070259F8CE733B7B2861DE2982DE1188C690981013B35BA4
	0969429A38DB43E40EB943EE903B74C6440CCC73E201F8AC02308A3D8DDA0000
	000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="128" length_in_bytes="345" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000CB494441545847
	ED976B0E84200C847BFF5370D3AAB8F820B28C9AC6DDF891F48F561887E950CC
	CC7C8CC3E1EE76375A736F9E37D7CF3977014CDFAB03260A5330011375D5A009
	3481269A8725A7E887017CE23D3EA17657A19A1040C4F7980288B99F8DF40901
	C46F3131A191E2CA35A0D3F66726A4C54B5E008845139E52FA1A812056261E04
	01133BBD66613EB81D7FAA89B3252DE6CF3EA16E8738E929EF59CCAA0722E2FD
	E68734260011C1409993ED80895A5F68024DA08996EB521D5407D54175F4BA32
	7CA2F689014ECB6CFD35101EB70000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="129" length_in_bytes="382" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000F0494441545847
	ED57D10E843008DBFF7FC5FE7477D36190CC502E70F1A1972C17CD845A5A86AD
	B536BECBFD8D716CBBF6AEEBEB9EBABEED730383F98F388520CEF800DA4A1050
	7E3271AB12352174900932611B1835414D50134FC73ADD4177BCDD1D73264416
	32BAC233EE76C67432E0C3EB0A043D602D9A0802CA4F26B6D3F62C8BB7D00F2A
	9D00AA8968C20310D4CE6FEE280011FF162D000155E2AFEE1044DB7F556BA45B
	46F760DDB51A0454130DA2F73E32963A83E24C6400983134083221DD954C6826
	42BEAE12E63B4064BD5D248EB5684AF38900D8F5098290C9864C90095A54FA09
	992013F66CA126AC263ED5D46097097D7B220000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="130" length_in_bytes="397" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000FF494441545847
	ED97510A03210C44BDFF29BCA9ADBB0DC410BA13EA503FA620A525E8DBC92471
	5B6B6DBCD7E3678C2B6C899DFFF9E53681F6FCC4E3B144888B0522214240E7DF
	A4BC744889A518A09C10D3019D2F4FAC395375586F951252220C7762B3D2ECD0
	EC48AF92D014231A133A7F99A2F1729BFD46AF8C5E1288C494204040E79FA7C4
	E30BCA1D803F5D253633E617A00A044E4D84C0818910BF29F1CF77D1291FB240
	0F179C4C4CC7799E30A2F4DB2981A4A21A83A58E0D01E5C443F4DEC78EE50C5E
	576207C0DCC34348091B7652C22B51AA6B9631CF80D8F574957D62896E693E15
	80AC4F08C26EC652424AA844AD9F48092911678B3C113DF10259B4B344EDF67D
	E60000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="131" length_in_bytes="330" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000BC494441545847
	ED98810A80200C44F7FF5FE19FAE2C85214A0E27083D610469EBBA6EB7524444
	EFE80E5595D518E536E787F77FD6AC02C8D7CF0E98A84CC1044CB4558326D004
	9A18364BBA6861009FC027F0097CE2EBAB1B9FC027F0097C62D627AA5F748FE5
	373FCFED882F8CEFFC6E10533B1916444A4923C2B0EA67220240CE6141C04461
	63BC7B675FD46F34E1AAFD5DC23C0344D4D379F2B4251A623E1E003D9F00C4D3
	9B7278A98C588F262A8B3001136D45A1093471B4262E9B4D0D31B589A2B60000
	000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="132" length_in_bytes="370" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000E4494441545847
	ED97E10E83200C8479FFA7E04DD960E2D0E0EEDCECE28FCFA48951422FEDDD51
	524AA93CE3E353CABAE4FDB2FB36ACA97BC93D8784DEDA60100D8F44120C42E6
	7FA18C6D0795D88841F624B81D323F9CD8F60B752CF50826263E814F4CC706E9
	58C1C494F9714C1C73CEDC1B9E1D95CD4EA821BEFFFF5E1DEA96E022B091CC7C
	E2421054C2EEC4A1635ED88EF3F344E5870AE756F7D35D54015848EC91ED0C92
	511D01203CC0C1125D39E13860E41ACB822301B476B40439E7BFC7700601A2B7
	994A5089A644D4D13D894A5089FDF90427E0049C389ADA5007EAB8B53A1E73C9
	2289797E7C8E0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="133" length_in_bytes="365" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000DF494441545847
	ED98510EC3200C43B9FF29B8295B61D900ADABD1E48D8F57295255A5C4754C12
	9A524AE56E975729D56DF03D9E854D0B486B3EDED17D8D202A160989118414BF
	21F5A50326062D4B3931A6438A8F26C69CB13BA2B6C2044CCCBD194DA0093471
	32F2462BEF87DBB37B7564EC4349FDDC08428A3FCC135B30717940690EFAD7AD
	F8BE1BEF3E005A01A1A33682D0011B417CC7C43FCFA2077D8A891A5E50B2311D
	7B6942A1D7E923E5D709E0F9F7A5E49C7F6E9DC01B1380084A6002265EE59FDD
	1145102660A2B6097A47B408988089795C401368626B4DDC00EC854E5DB600BA
	2B0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="134" length_in_bytes="278" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000088494441545847
	EDD7510A80201084E1BDFF29BCA9652184601642127CC23E9AEB38FFA4111179
	AFEEC839C76CDD7D7FB4FE3177B68132FFC9A044558912946889E1099EE089DE
	7F041DE840073A46F74C392127E4849C90136F5EE5253557D6D2C5EBC6CF2652
	4A9FD7457D4D388EC37F3C5149A40425DA54E6099EE089DE5D051DE840C72FE8
	D800A2C0E9F93D6100910000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="135" length_in_bytes="1226" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210803000000CAF9F4E100000300504C5445000000A0A0A000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	00000000000000000000000000000000000000116DE5C50000010074524E53FF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
	FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0053
	F70725000000097048597300000EC300000EC301C76FA8640000005A49444154
	48C7EDD7310AC0200C40D178FF432B22A28321C6C4ED7F1797F2A84849459EAB
	3DF9519DADDD6DDBB37A45294D5601E4B3ECBF619C36B22D277DC322EF1C0919
	19191919191919D93DE825C92F7FB1D61AF3ADB1D41A2F5204E22E368F0E0000
	000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="136" length_in_bytes="478" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D3000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC200000EC20115284A80000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A100000143494441546843ED9A010A83301004F3FF57F8D334299696D4CA
	09CEB9362B844249377B3B3147C5524AA9938C56E6D7354DED59856E853C7ED7
	BDFCC315AD2327FB65592A393E4E8908BC683811AD2BE744EB784226F3EFDA05
	5FE0DD0E22A147C389685D39275AC79C906BADE5EE633DBD229BCC90EF0ADB90
	F7F777E3EA3BF9EC16EA9E1C39548FCF714FDEC92C1ACEF1D8737F11AD63CE9E
	9CCB025B6D5AC8397FFC7F3FC1937DE275760F1EF5D47A32766B890A4F795C8B
	B2C06C193216AD8EB021EBB0C09C183216AD8EB021EBB0C09C183216AD8EB021
	EBB0C09C183216AD8EB021EBB0C09C183216AD8EB021EBB0C09C183216AD8EB0
	21EBB0C09C183216AD8EB021EBB0C09C183216AD8EB021EBB0C09C183216AD8E
	B021EBB0C09CE4406EF6B35EB0C392BAB1705AF6690BAD1BAA3379BDB29AFD39
	EE87ECF5B7D6C3F37F00722D48FF306A13910000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="137" length_in_bytes="426" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D3000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC200000EC20115284A80000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A10000010F494441546843ED9B410EC3201003F9FF2BF8E956A042AAB61C
	22B176D3CC01A15C70623384B44B29A584A2453499AEE5EC9FF2B3B3DDCF8B1F
	0AFF7521B707A31D1E28E0EA1AB5D6C86CE34108F773820F6F32FD6F6313B271
	752164A3F9AA5587900979DB6B94E5DA389920D9683ECBF5C9DD38BBEBF56723
	244332EF64D5929AA903C9900CC99984A9C68664488664156D993A900CC9909C
	49986A6C4886644856D196A903C9907C3D92DF8BABB89EB56EDBC25C5598C8FE
	6A24D4AF0EF422BEBF29FF216442BEEB1C80E41B244FC884BCA75C9A8D977726
	41B2D77F893A214B6CF68A10B2D77F893A214B6CF68A68421E3F920B7AAF9DBF
	A9AE38B63ACF0C2BC49ACDB6F3C08B8CDDF7A3F03D1E3980748A5CFA69C60000
	000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="138" length_in_bytes="327" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000B9494441545847
	ED976B0E80200C83B9FF29B8293EC8784A527E089A7C268418EB364B8BC339E7
	C235BCF7CB87E53E678AB8570126D08439112660A2DD95D1049A4013A35E0577
	E00EDCF12F77149EB50E78E51CCF1D9B47ECFB854BC509A17A881A5CC5CD1691
	0E3FCA8B6F1571E75683AB38E5834A0C4C181B30F14D26D41D7356F90ABED644
	08C985F141BE9FB1B292B8C3E4CC7B8A80896777A089C4CB1E61D67FD14DCB81
	3B7047BB65A30934812646CD0EEEC01D9D3B0E2799623B26E0CA160000000049
	454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="139" length_in_bytes="345" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000CB494441545847
	ED97ED0A80200C457DFFA7F04DADB4690AE12D5AF5E304A38225E3B4BB8F1042
	48ABE52BA5F638BCE757F37BF89ECFFD3A88020012960A9080C4A073D4514581
	3A5007EA389903A813D4893135C889634E6C34147B78D06E33AE3ACAAB7EB702
	550F57FDAE06D1EF1D93AFBD82E8F78E8F822824B6F56F668E6B6021310B60DF
	51BD7E0724BADEA56256FDAE4AB4AA43A9969E3E52B9F60CA016AB14637CDD0E
	FDAA90200843020948B4690E755811840424729BA077588B800424C671819C20
	277E9D130B9084CDCFEFBBB41F0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="140" length_in_bytes="323" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000B5494441545847
	ED974B0E80200C447BFF5370535408848F24C302D0E499346C6AC1611E163333
	FF84736E7BA4B9EF9145845D40093C9148440994684F653C8127F0C4A857810E
	E8808E7FD151309B3AE09D63BC771C8ED8F70B8F9A2794EA53D4E26ADEEC22F2
	E5477971D522C2DC6A71354FF9A0320725921A28F14D25D41373D6F94A7EED09
	EFBDB551545985687D4E1C5A044ABCD371683BF044856F46EFD076400774B4FF
	133C8127F0C4A8CB820EE8E8E8B800EB7D119ACCDCD6090000000049454E44AE
	426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="141" length_in_bytes="355" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000D5494441545847
	ED97510E83300C437BFF53F4A6D9569412C2A6B988021F0F291282A88D5CBB71
	4A29C5DED11E33DB85FF8B79E1DB19AF6DFFBB8B58000009A7024880441237EA
	E8A2401DA80375FC68FEDC13DC13991A7022B48CBDCBCECE7BBADBFE66F52F2C
	62EBB6FF0C119D3B670C1B799E511757F30ED5A82EAEE68D16B19DC06E3A8E67
	71E2038912A350CBF9EA59AB79F2C6D1D9A98BAB79A345744E2847313347E2C2
	CC02BA44ADD67A7904312C48508443021220B1B60AD4E197204880446B13F40E
	6F11200112D92EC00938F1684EBC00202447640C81DD720000000049454E44AE
	426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="142" length_in_bytes="281" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A10000008B494441545847
	EDD7510A8020108461EF7F0A6F6A6A08214820A2059FB0F8E832CD3FED861042
	2A1563DC5EEDED7C6BA27E054AF04423911294E853992778822746B30A3AD081
	8E7FD1F160B64DC03BEF7BEF385CB98394A6AAEC0BAB4EEEE1681375F99952A1
	34BEF250A2A949094AF464F1044FF0C4E87F830E74A0031D6FF3A89C90137242
	4E7C3E272E7F66CB0AB2EA8F7A0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="143" length_in_bytes="280" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A10000008A494441545847
	EDD8410AC0200C4451EF7F0A6FDA6AC05204116AA95DBC40DC29E133338A29A5
	7494AACBE32E67ACD4119B5706A87BDF28241A452490E81D4513344113A37B86
	3BB8833BB863F60E951372424EC80939312370E544FD1DD8DCDB07880F8EA090
	73FEBC6FF40DD1B4880412E144EE6899840412FDFD4413344113A3571B7770C7
	AFDD7102BDE48A59289BBC7A0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="144" length_in_bytes="410" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A10000010C494441545847
	ED98610EC3200846B9FF29BCA99BDB30EAD4A002ED96EF8731358D7D7902C112
	11C5344208EE83BFFD9C01F13A0598404C7026C2C46D4C1447714D8AB600EE75
	A203E06BA267205970333101F0313133E0624200606B4200C0226CFA8905001B
	130B0036263600744D6C00E89A3800D0317100A0634201E0CC44091063A4D591
	35F0463B979FAA3DDB875033B16C215983098E1D98B8B789A6E8F06D593AEB64
	C7851075AE5689FBF96FD0ACF51EDFC566BF58E56E7BB8B903C49F9910181BBD
	A267E200422F260E206082E5FD860971D9368F89A20BCAD5B1F8E854A7146EB4
	495E378690C5843184AC4E1843C0C45A9D303E0EC4C4D70D6CDA59191F07B203
	D9D1C65F7C00412D0992869EEE000000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="145" length_in_bytes="443" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A10000012D494441545847
	ED98090EC3200C04F9FF2BF8290D69485D04C6273DE44A969A04A4CDB03E9494
	522A478C7EF7FD525E7FEB42707D5E4EF6536FA3FB778938C506897666412248
	F4F91B9E084F8427665D0DCB8EFA8C12D48E89766BF643B041DBCA695D74F19A
	5A11B479C259C40F90A863DC2A0CC63B9CC44AC0356BFA7A6293083B1214C1FD
	9ACBF076D9A1107193A054456CCDD2C02391908456C089D38444CEB97003F415
	8D88E74BD4E00AA8EBA1084D07FB061141E26DC6FD2F4F08D3D4CC13EA5A213E
	8E2E4D0F10EBD63FE81F3A12ADB674C3B0A864A8481808B1216120445EB647A5
	5E7034B62434444C3CD1536110F1212121E2428221C4970443886D76CC8623C4
	237B485088B87A8290357B496044B6929809F988887E5A0F11EDFB4690081291
	1DB08CB7A6F6000CC4B2DA04A87CE70000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="146" length_in_bytes="403" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000105494441545847
	ED98510EC2201044B9FF29B8298A711B402003BB4B6B321FA4B1A1F8F2985DA9
	218490F288311E1FF2DDEF2B213EBB4013CC8454224D3CC644B115F794680B70
	BC4F7400CE9AE819C8168E9998009C31313370C40400E06B020010113EE78905
	001F130B003E2636006C4D6C00D89A5000D8985000D8983000D0992801524A61
	755C1A64A19D979FEA78B60F616662D942B64613921D9A78B689A6E9C8DB327A
	B5A98E1B21EA5AAD0AF7FBBF4173AFF771BA08F0FC75DAD62CAE85A089F2B43F
	DC3554333A6F1A8FD122E8E2E8BC110433F15F9980DB36DA943AF3F04C94E7C7
	CDCEAAAF0E47089A58AF0EC7EDC07F451D21980966A26D5ACC0433F1938917C2
	51B0DCD5AD12F50000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="147" length_in_bytes="460" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A10000013E494441545847
	ED99090E84200C45B9FF29B829E3C60808B57423269D84C4983AF37DFC2E8E21
	8490B6D5FB54E7534A21AF267874FDE06B1FA7C1EBAD441CAA9C44DE1C27E124
	DA44754FB827BEE589B2698D8E81B28F6D6070EF30120177512311F82E0AB0B5
	9B2714457C8C84E2788727A128E275C6DC03306BAA26BC4ED54500D6F5471C26
	9DDB98EBB75E4960EE902BE2EF090C7228864D822B408E448C31CDAEC2B43224
	6605ECF142226E4F2C14716EE7BE168A7012550D5ABD1D629ED82AF2FD270AF6
	B8444126D1A429B6D774A77D96082121F4142DD3BA69F998C6573D01B2496431
	0C213224184278D931AAB2142262DB41F4880E09CAD6A8909810A24B6242886C
	7610CC6A43024344D5132D994EFADA928088989218095922E231AD53075DCA70
	3CA8AA3629DA135C3DB73889EBF5971BF3F2851BF3B0C20FA68A5843C6C43D4E
	0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="148" length_in_bytes="383" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000F1494441545847
	ED974B1202210C44B9FF29B869E653069838331212828B5E50E3C2D2E7A33B60
	4A29D1B172CEE18BBF7B7F02E2DC05984026B88930F137269AAD58535109103E
	276E00624DDC19382C849978018831F16620C44407C05C131D002C62CE7D4201
	30C78402608E8901005F130300BE260C003E260C003E265A00224A9AD54CECF1
	8A7E1DC76310B6B3832134BF5EBEF7F319761346089838436C3E459109796537
	06B34E4CD179FEB7DCF53442D4762C84A8E92C29554EBDD64289FAC08B0B8987
	5A25034CB473EA2A6FC1769476D4F1191F4C6402999063049940269089A7C315
	ED403BD00EB4E3D7E59B3624A48540597F8FCE0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="149" length_in_bytes="400" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000102494441545847
	ED986B0EC3200C83B9FF29B8291B6C9942FA58E300AB3457CA8F4AB47CB2B003
	A494527956F7945252A4ECFFBEBC6FE66FE32300F55BE4A112A21A95A0129B58
	604EBC15A03BE80EBAE3A8C3D21D7407DDF15FEEF0ECD6B53B6A56C0E599D48E
	95730F3CB98007215E679D5A3967770D826889FD6B082AD1CEBC9D3BB8266EB0
	30C7B8E31338CECB15DD47608BD675A493D61B5AFADC1382B020C82D4D28ACB4
	A34CEFF1B0C4D684B57500048FEDBD6C0140C62A215000C858250090394A0020
	73947080CC55C2013257890B206B94B800B246891390B54A9C29126E60915D59
	77EE407E14FD4625EBDA3571D07909213B332A4125DA0DC0AD2CFA003517EDD7
	C33146580000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="150" length_in_bytes="449" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000133494441545847
	ED975D1283200C84B9FF29BCA9F50F8C29358B65F1651F9C16A7856F36C926A4
	94D2BC3ED3340D7FF2D9CBA720B6284809E5C45A8946857772C202CCF3C630B6
	44BF14180DE10136094696E80F808363403802007E62460A6429680D0C04E029
	0102F072A211A0BF121580C58FCA39A52473695272C236A5A2F5FD17AA1220C3
	E958DD463B299107652931440957FF7E32AAADFB57C71388C0A4F691AA659E68
	4CB87C00AC06D4458910B86312214A4C42C724424809DBC5F77B47C38364FCB3
	EA78110203CE57353F0DDD48826D6C3608FFE020D0D021612B8E19FEB8A6847F
	67D6F8C67F28B19BCB71912DDE7FAE5B21C248540FEC0C7176B1BB9890C32125
	2E8EA9EA800D909C98AA8E4B2E86754A0E4778BE1CF31A2FD7ACD43BACB1746C
	E5F209F944B56B878EC576CC0F3C59FCDD69B2A84B0000000049454E44AE4260
	82
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="151" length_in_bytes="453" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000137494441545847
	ED96511283200C44B9FF29BCA9AD483052691624D8E9EC0763B582CF75B32484
	10D66D2CCB327DC8B3DF4742C4AF4025E889AD12950ACF784203AC6B64985BA2
	1F0ACC862801A204334BB4029038267C0E03C0DF9896022285DB060602F82901
	02F879A21160BC1217007B1AA552D44709AAE161A537A5AC75E547827055C262
	38FD3FB43A5A94704BCC0E886C98614D6E07043DA1131BEB278AFA2F3BA3ABF3
	A073E0AA549A73E206841556B8271A0DB72F9CBAA65A60DC510209A10C618148
	8C4361D5AB040081E7440F042299BB1220C48F29D15082C80B4A5922F71E4A3C
	0881012B8763138E2EAA4989AF3717104864A3B031D320D29A12DB7519C542D8
	C26A9239C119C27CFEEEDC630F384DA012B91BA1279214F4043D51462C3D414F
	D013DC457515C876A13B28E6C45FE6C40B841446A238152EAD0000000049454E
	44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="152" length_in_bytes="411" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A10000010D494441545847
	ED975D1284200C83B9FF29B8292B68594421D5A1F5250FCCFEB0338D1F49CB86
	1042CA2BC6E8BEA4F6F64A11E51448829EC8496C287CE38956404A45836F442F
	04BC45F4020A02CF880E041C3A1C8E0308B03726222028CC069852801D09A500
	3B4F8C62582B9EDFAC27714360EB47B54E8DA444D3C413ED501A3C79FFB52909
	A5867FC75A76B52309B92893840B892EFFFDCDE8EEF3FA74BC11019AD47EA57A
	729F98192E179B2D0D12D5143514A1EF988622EA99C08E69288224DA29BEFFEF
	78B02E665F968E0F4548BF9827193D29DAD7F689E9EF5011B40F4490C4291DF0
	C8106EB40F0BC8149BFD101541FBF48410220992E8D3424FD013F4C46886301D
	4C07D3F1361D3F39EE1908D1EB79A40000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="153" length_in_bytes="467" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000145494441545847
	ED98810E83200C44F9FFAFF04FD960A21D2BF66A38354B97909949E4F6B81E60
	4A29E5773BFCE4BC75D92FBADF449FF22CF3996240AC2F5944D5632A218B30C7
	FFA8E44E4790F82A06734EC8D3618E1F9EF89EAFA88E9507D99891139113EAB6
	C14C2CB231CDF12331233175E73E70ED286E469AB5896FF7CF5787754A401548
	25C83FAB7D4A66580DD9C1F7E70E5880E3E118E24E495E96E5B0091F20A43D22
	6ADF4AE24611DB7E021661F9615D67B8240822FE9C442386B8F88C31A1921622
	9A3F7EBEA57FBCD5E1153184215FAC4022AC126EF73D79E22641148157075104
	9E9844114142BE0BC31630E274503D310CA9FDB0BFAF735373A210EBF6A05672
	CF27A18416B4AC4F27E114C223E11432B73AB42A323CC2278112A179A2A73220
	721D891191B6A7B88C8426E436115AA05D4E42DB85858876C80E128F21F10259
	54AD3B7A2D8B050000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="154" length_in_bytes="476" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A10000014E494441545847
	ED57090E83300CE3FFAFE0A7DDB84A5A0A76500DD39449D5D0881ACF71DC7418
	86217DD7E527A51C52C44EBF6FABDA00EE69E2B9583188190F44220601F32F28
	B5E508260A2DC39A88CB01F38726CA7A4577AC7C8885193E113ED11C1BA06389
	8509F387638663B6956BCE0E3BDC9E3D3323639D08AAD376870004CC7FE80E01
	887C764C68A82500313341253771E8AE445D235A9A48E3385E2E21889D891741
	EC9AB803A2E75D74D6840304AB21463B39C60B82D99CEBFD65279D268CC19D82
	B6315E26A8723466908D9DFCBDC6DC62C20B8229DF62564898EC7BA79FF83421
	04C1FB841004AF09218860A29C63FFB93B0EE6B4FEF5DAACFA6B621270352821
	B3EADF1D5B173981F4754CDBCA24101D135E46BA9E1D2D53038CE89960199133
	01803CC70462E43126AE803C0EA26568AF80A880E8CC0ACD2076140C265C971F
	44ED9DF73F558E0FD83C9A4E807AB0B90000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="155" length_in_bytes="421" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000117494441545847
	ED98510EC3200C43B9FF297A533658A3B10C12A75BE88F2BA17D140DEBD50E81
	524AA9CFB17C6AAD25630C0B9AEBF7791902DA7FEA87248408499004D3217587
	244842EF41F4043D414FAC3A33A683E940D2D1FA4C68448F00D699E67CD77B5C
	6871999720E275BE69E3380E73248A7893B85104497C78969E184F60703AD048
	0FE559CEBA5FBFE715413C1D174498173021125E84E5BDAE2756C50C93888A00
	CA75BF054A251110817B82245002DA9881CF81EF1DA89821C2AE8E1DE9581629
	6966D2D2D188A982E611F97F3A26DEF0AF8DD1CE0AF5C4380F249247224A04EA
	27AE900085E493008560DDF62F241C21FB487844D23DA129CE52B35DC4ACA0DD
	224209D9674CE3B350846C7624D1493C00CF3247F5CB1F3AC20000000049454E
	44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="156" length_in_bytes="360" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBD00000EBD0147FB90AD0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000DA494441545847
	ED974B0E80200C44B9FF29B869551044FC745C3471F14CBA406A3B193AA5A694
	92ADE63E66C5ADFBEEEBFE6E589FFCDCC062FE122710448D2FA08D0421E58789
	D32951138D0E988089B9815113D40435F174ADA30ED4F177756C33A162CAE82A
	CFB8B733A693411F5EF740ABFAAC4CD39EA993B9C8D4C1A69778DC0F0351FF6B
	7C16E666251C87E59C5FAD33A6020805011387D4A9892653A9FB291DF2E223AB
	E37363D15A7601F41984F741C4FE40403D8E88245E4C40348660022666B55013
	D40435F17487A00ED4813A500733A6C7C0DC2716156780B122713BB700000000
	49454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="157" length_in_bytes="373" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBD00000EBD0147FB90AD0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000E7494441545847
	ED96E10E8330088479FFA7E89BE2D65AAB75936B1692FDF84C8831C5723938C0
	CCCC5F163EEED5EDF0DDBF6D7EEF1749772EFB2682A85824D48920A4F80D695E
	3A60E22206292789E990E25313D79CA18EDE5B610226A6E19ED8AC981DCC8E8F
	ABA434C5120B538AFF9753F48D5CB17083FF79DB0E22E8148F8EEC75918D4CDD
	CC45A6069B51E0F3791A88B6CDC72CCCEA10D2E1A594473B185301A482808921
	756AA2CB54EA7E4A87BCF9C8EA586E2C5ACBAE809641443F649C9F0868E9C808
	12DD0988CE104CC0C4AC166A829AA026BECD10D4813A5007EA60C78C1898FBC4
	06C773AC855337DADC0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="158" length_in_bytes="335" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBE00000EBE01EA42B1C00000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000C1494441545847
	ED97490EC0200C03F3FF57F0D3741154151224A6A2A741CA89CD183B1033333F
	63D8DCDD5662B666D737DDFF1EBB02E09AA33698688CC1044CF4EE411368024D
	8CDE14DC813B7007EE88FE9CE489549E58F9F6D75AE662381BD16DE9B587B079
	0339AFC0BE30514AF159BCC0EE63420111D66C6A29D84EA88008A9F803044CD4
	AB4B7B39EBF9679CA20979F16C1E9041441376F4BFF3C4CDC48E4DA23501D118
	820998E8DD8226D0049A18BD21B80377E00EDCC11F3362A0CF1307AAF26EED31
	C727050000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="159" length_in_bytes="500" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000166494441546843
	ED9AEB0E83200C8579FFA7F04DDD34731A77E921402FF4FC3064B1AEE57C2D90
	86524A59959EA79BDD97E5F872FF1EACE351D35ECDD15D61FE562AB06559D691
	CF659520D34F05F6021BA9FFF6DF65B883733B2064424E9903ACE404D8099990
	FB9C97B827DB66122BD9567F15EF84AC22B3AD1342B6D55FC5FB7490B53A6BBF
	FC7CA3661DD3749091D2387AC988AD671B741E84EC99A2101B21FF110815C73B
	7F741EAC64EF243B246B5AC8A30E43DA072F2447D34246C4F16EC3E5BAC33247
	C815F700BCF5AED10A20644DC8DBCD06F041C0A4842CE9D77AB1A3B992A5001D
	BDD73E78A1C92FDA79828C542A6DEA14E872FAEE59C975E1D31A512014E459F6
	5A044C8D8DA44B28C83513A7EDA94028C852C666052BE9120A725688ADF30E05
	59CAD85631A27E2FE9120A725408D67187822C65ACB59856FE255DFA40EED891
	B2126A66BF62370CE407F79E25879BD847667A1DEF09E135CE6B5C92EEE2FB07
	6E1AF3D087D00C380000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="160" length_in_bytes="503" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000169494441546843
	ED9B010E83200C45B9FF29BCA953A31B71EAAF0A2DA57F09318B8ED2FF5A2095
	A594D2A8D426338B2DCBEB6AFE7BB11E8F9AF66A86F60AF3BB52820DC330D66C
	D92C41A6FF0A2C095653FFB9EF54DDC06F392064420E1903CCE400D8099990CB
	EC97B826DB461233D9567F15EB84AC22B3AD1142B6D55FC57A7790B52A6B6776
	8EA8598FA93BC892D4D86AC992675B7E46EA0721B74C118C8D902F041AA74FF2
	DEB2B76D284E6366B277C0F3F809F93AB699C915DE0AB656F1226442F6B15E73
	BA06D335DAA938B9DFD7EE3A3BF9810A0B123E5271247D593E23F503695664F7
	FD7A4DBE0159E450C5FE9AAD78219FDF9EDE2909D932737AB5DD5C26F72AB4A5
	5FAE204BD7284B412D6C235D5C41B610B0079BAE20A388ED01C8131F902EAE20
	3F1180BF59CFAC7BD95DA3888D0A14E9C24C0E1019AE20A3880DC0EBD045A44B
	19C8A8DA72E37E545035FD2E55252CF6F7C9D9D92D325BBDEE81B43ACE7C5CAF
	417F002A06A44A6DCB6E270000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="161" length_in_bytes="475" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A10000014D494441546843
	ED9B5B0E84300845D9FF2ADC6967343A0F4D8446A040EF8731933442EF01645A
	4B44D49CAEB799CDD6C8FB6EFE731BED8F9BF66E86CE0AE3B753822DCBD22CAF
	9F2A01A65705B604B3D47F7D36991BF8BE0E001990A78C0164F204D801199075
	FA25BC93C74652AD4C6EAD11AE7F0D8E7F1EE6CDAFB981BDBB06E06B9003F204
	990FC880ACB648E2D678A15CA35C4FD994A15CA35CA35C5728FFC86464323219
	992C5FF244773DB062A05C0F14DFAB4AA4812CFD3ECC4BB84C76A4DA3D5D7A7E
	5CAEA58E6612DFCB57A9769120DF6EDA790997C98E609753652B523393053E63
	48A702A9201FDF3777CEB1FC704E975490CBD3329A602AC85CC41A6914FEB19C
	2EA92087573BA883A92073111B546373B7385D52413657ABA8815490B9882DCA
	889D16A78B0E64E9AA8B601C3B230CE85640EBC4A9DAF1C9750611CEFBDEF971
	5639BABF2A905F83914C21FC18A5720000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="162" length_in_bytes="387" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBE00000EBE01EA42B1C00000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000F5494441545847
	ED57010AC4200CF3FFAFF0A7DEE6ACF47A43735D3D848B2032E8664CD3D8A594
	523967CEF9E753F63E5682A8592013D4845422992013D695A9096AE2BF34A114
	2F3724B2C6F613BB8138DB047884B677DA804004F14D8D0344C54A262465FB30
	E12CAD910780BABCC21033F1C468A6659FD13A075D4AAFA47970FB9740022DD2
	E13B0B41D4D341632188AE8929908520C8C4579ABC72C6EA68A4EDC604EA9ED3
	8A93F3A1811F9A68CC741B56CFDA9AF1EF2391361D8120FC3E1108C2EF988120
	C8C473C70C4C0735F1E60C903AE9135DC2E62A0F14269489DB7E221004AB83D5
	71DB3940EAA44FD027AC7A566AE20544D4DD0C16BE68080000000049454E44AE
	426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="163" length_in_bytes="385" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBE00000EBE01EA42B1C00000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000F3494441545847
	ED57D10E84200CE3FFBF823FC5031D9948A072DB85E44A427899524B5B660821
	A43C638C3F9FB2F7672588720A64829A1027920932D1A63235414DFC972694E2
	E5864456DB7E623710B94D8087697BA703084460DFD42C802858C9841CD93E4C
	2C5A6B9401A02ECF32244C566A34D3B2CF689D834EA93A695E7CFD4B20852DD2
	E1338E20CAD741C31144D5C41488230832F14A93E799D11D1769BB3181A6E7D4
	71F27D68E14313999976AA97E1B67B83A43D0E431038604710EB8949266ACCD9
	09939AF8FEEE301426DD714B6B489D8E6105EDDFED27A80987B0A23BE88E6E37
	07F99439A12D99FF811C2C9A0EE5368C6B71AAA62E0000000049454E44AE4260
	82
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="164" length_in_bytes="325" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBE00000EBE01EA42B1C00000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000B7494441545847
	ED97510AC0200C437BFF53785337373A44B06B4587B027883F15434C621511C9
	65A6943E9F7AF6B902E2BA05984013EA449880893695D1049AF897262AC5EB0B
	E959E7F613BB81286D827B4C6DEFEA00722298DFD40C80B8B0C2845ED93E4C0C
	5ACBCA00A72EEF324F988CD4D44CEB39D66A83CE394B748668D0CF87B5290AA0
	D40786AF783188471326F0C52060A2750FEE401368A275019A401368A2F736E0
	0EDC813B70C7DB17849C2027C8896E4E1C564876ABF9C053830000000049454E
	44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="165" length_in_bytes="376" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBD00000EBD0147FB90AD0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000EA494441545847
	ED98E10E83200C8479FFA7E04DD964B643A6E33025DB8FCF84184D29C77107D5
	94522ACF36BC4AA9611EBB3FFBBBE6F910374C2C8E5FF32C04F1CA2FA05D0942
	1A1F260EAB84268C0E9880897E03431368024D5C1DEBB80377FCBB3BB69A5069
	4AE92AD7B8A735E66004BD78DD13491D7A8B068290C68789AFD576E072DCFF02
	0B048126FC445037948F0FE2C0E5704D283BE06C4C3F535BFBD3FB6C72355E66
	D9F6EE92730E69CDB9A282F05F402100B689DC00F1D6044C187D30B19009D5CA
	4BDDF13B1033DA6AED5C11CF748E8A058431091330D1BB0A4DA009347175D6E0
	8EDE1D0F0A21DD0CFFB700FA0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="166" length_in_bytes="383" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBD00000EBD0147FB90AD0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000F1494441545847
	ED98E10E83300884FBFE4FD137EDD6BA9A5ADDFAE120DB8F3321C684C0097750
	4D29A5F2B4E5554A73DB7DEBF36C431014F3E5CF7D0341342C08492008947F43
	1AD70E55E22006D493C076A0FCE2C4B16752479FADAA842A312DF7C061A5DDA1
	DD717994445B2C909828FF5F6ED18A9CD8F204FFF5697B918197D88264E68423
	080E3810C4FD89A94A40CAF33EC32FC0CB39E1D80E71E2B445C904B4FAF4249D
	1F1FEFD6E0D41F7278736B4173CE2E36EC150A62FF05E402A0BEC80D10AAC459
	1DE244A03AA89443D5F13B10166E8D72761D560261A940F7553B54899937E284
	38214EBC9BA652C7AC8E074EF38C6BA5FD983F0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="167" length_in_bytes="352" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBD00000EBD0147FB90AD0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000D2494441545847
	ED98510A84300C4473FF53F4A6756DED12C57536D0509027043FAC6698CC24B5
	6666F5138F57ADD5A2A1BEE99ECBFC6D6D14C0BE3E7AC9379241C8FC30712A69
	72393ADB4A44C920647E3481266E359A2C4CDC71D61D7DE2604076AC6461CAFC
	744C3A261D73E5969FD9C1ECB8772053F4F55334FA67BECFF3E9E1408CFDC2E3
	7D3A807EA4F1DF5E6598A28128A54C09C7AA329DCFDF4BB110C47776AC04D1EA
	0613E37CE4D54C44AC9FA68975202256F73D65AA2600116160ACA51C3071D50D
	9A401368E25737C51D57776C45E87FA2B5D1A2BA0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="168" length_in_bytes="380" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000EE494441545847
	ED58011283200CE3FFAFE0A738D142D7314D19EA36E39DC7E9551A431AAA2184
	90E633C678FA29B91F2341E4552013D4845422992013D695A9096AE25E9A508A
	971D1219C7F613DF06626E13E063687BA70D084430BEA9E90091B1920959B2DF
	61A2A3F4405D2E6110131F80C8EA97D6FEDDE80581BCA1244662BB984026F680
	C07DC259FF1E1064E26959AF1666D584A304470BB36AE242109888532A71D803
	EB3F078432BD776CC61B1048BB8682D54EBA8DB9C584BDA7AEF18955DA5DD407
	83D8CDBF28B7A1093251D46CD8A126A449211364823E419F301F302FFB097D82
	3E419FF85B9F9800FCFF90DFC0ACFB090000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="169" length_in_bytes="397" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000FF494441545847
	ED58010E84200CE3FFAFE0A7DC814E01453B6E9C1A6B4248CC945ADAB2E89C73
	210EEFFDDF87ACFD9D0922ED0299A026C48964824CD4A94C4D5013EFD244A678
	392191D9B69FB81B88D826C097697B97071088C0BEA9E90091B09209D9B2E730
	D1613D50975319C4C40F2092FAA5B56FCD5A10C817CAC2486D1713C88B3520F0
	9C50FA5F03824C14DB7AB530574D282C682DCC55131782C0441CC252873D30FF
	734028CBCF8EC3FA0A04D2AEA160F3243DC6DC6222DE9751BD4103A2C8F42692
	C12030C0834190894D626ADCB1D41A09939A80736A526E23318DB683EEA03B76
	E3E0D4A7838579BA3EDD512A973931F33158984CCC7B25E607C5FEBCB380015F
	E20000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="170" length_in_bytes="348" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000CE494441545847
	ED97510A84300C4473FF53F4A6755B097485C8448BBBEA134A7F820EAF336934
	33AB6D95522E5FFEEDCF8E887E0A90C0139E44484062DB95F1049E78972706C7
	FB0DA9EC73E7897F13D1C604F9993ADE8D0D4854307FA83920A26B85841FD97D
	481C889EE8CBB54C2271424477BF8FF6D19E1561B55679A9387E2D42EF135F53
	1024FCBFF1D12412119493D152A43ECAD031D6CC16B1AF34D30F94DA3D2AA112
	E5C5999A400424C65B3C3EA90C6AA5164F38254840629B183C8127F044748F90
	0ED2413A6E998E05813010B4BC90F02C0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="171" length_in_bytes="421" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000117494441545847
	ED57010E832010E3FFAFE0A76C3071C888ED99356E494D88462F507BBD72A494
	52798ED3AB943DE4FD30BD1B62EA5C70CE61412E560CA2E18148C420E0FA2F94
	DA7498894331C09C88D301D7B7268EF972756C7C8885699FB04F2CDB06E85862
	61C2F5ED9876CCB5727F70EFA86A66066AE2FBF7EBD5814E092C821109F3672D
	A67A061A4C073F9F3B680081C9398A272425E77C3A061D304C4740B4D8C6C48D
	20F67E820681F4B0ED335A260420FE94094695812ADAA78B0A932DE9D911BB4E
	967735088A3C0A042AE1FE3DE827DD22389F1082E0AB430882774C210833F171
	02837BC78574B07E22D5C47D2058C66ADCE8295F352B838830B0B278A7A3F71E
	66C24CD8AC463FB16DDB31E7FDA56BE2016942FC735274CDDF0000000049454E
	44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="172" length_in_bytes="417" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000113494441545847
	ED978D0AC3200C847DFFA7F04DDDD46AD5FEE4327A94C10D64650BE648BE5C35
	8410D277DD7E52EA21536CFEBDAD650373CF211E8B258B287A4C25641166FEAA
	92DB0E556262D9EC09B91D667E3131F74BD3B1D5830CA67C423E717A6C301D8B
	0CA6995F8E29C73C277778778C87DBAB67E4C8B82632E91CA78320C2CC7F980E
	8288FEEEC86AA04510512A01251FE2ACBB12748D386322C5186F1751C45E8917
	45EC4CFC22E2C9BB6861C22102650861A7C77845209B63B35F77FA5F26BCED68
	55B9FDF6B6C32B02695F352B0B4CF47FA79FF898208AC07D8228029F0EA20855
	E27003634C073ACA5426DE1381029CE3464F79D4AC24C2538116AB76A8122B37
	62424C88892B37D574ACD3F101609C2856F3C5BC7F0000000049454E44AE4260
	82
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="173" length_in_bytes="395" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000FD494441545847
	ED97510E84200C447BFF5370D3EE82B00116E9D4D8E8C798103FAC7632BCB628
	22A2DFB5BD5455AE2CEBBBF5B999BFC45D1190DFF15C6674B008333F9D18B633
	783B0EB72D80824598F9C9049958321A0C26AB63E48E7D029DE7C160B2633614
	E9049D98DBD2BB98C86AA0E5E9195627EEFB1494BC1309FF8780227E5354534A
	DB1528A230519C785084DF89502650270244D089BF9395074CB4A4E7D9D03AE3
	F2EEAD0EAF08A85D40222C70DBF3BE9F40D9EBBFF0D322F0EAA013A803646276
	0A3D974C71D81445B7E5152250B1396E38A320E709CFC7D1588A5895F3AD6D1B
	DD0A32D13B453009E666CEDC3B3B58A21E0708E619981F0686594FF41AF28800
	00000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="174" length_in_bytes="584" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D3000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC200000EC20115284A80000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A1000001AD494441546843ED5BD10E833008ECFF7F857FBA4D33376336EF
	5AC062BD87C52C6D29DC0145D4524A7938FD5E62165999AF6FF53E97ECFABA71
	E326688FA0FE9B11F0E1669AA687E5B7C9024716AD1163B67A3001089785640B
	3FF3DA6216F04DF783E19FC29C4B918C3C3605A21D9440B85C8AE40EF80DB1E5
	A548461E3B04230D46205C2E457283FD5AB216B5E6BAC92C802BBC90C7DE9551
	848B22F9069E21924532D7E3F0BC4FF6E9CEF8B559F7FAFCF289EC3AA78B6404
	181378E88C62646498C3DA8130CB41322ADCC8B6E74A0C0B4E06223DDAB82E24
	420ED004EBB8483EF447919C3D5C0FF46333D26D49A6CEA94D8660E79F5D7831
	3E7A5B921970B2CF51243BA439915CF11E80F93E1915662ABC5478ED1160D39C
	22396924B30552D4BCB30B2FDA0E940DADE367A66B6474F6E86CD10FD93C4675
	8DBCB0F2CC6E01BAE79A53488418A309D1E322997B9264E1213C5D23E544B248
	EE996A3DF656BA5E5EFCE65E1FF200BC870C912C92E353B5CB1714E8CC45E38A
	E478A25578C526F11CE9BAE1911D7583DF203716EE3ED2A3B0AA95EBF67D72ED
	C6FBF9330D6BEF3AEAFAAF571EB59F151397F54FF8648B4694991A9E00000000
	49454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="175" length_in_bytes="571" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000001AD494441546843
	ED9B610E83200C85B9FF29BC29734636669CAFDA560ABE1FC62C602DFD5A5A90
	A5945236BA66318BACC8F755BDCF2DBABE666CCC046D2DC8DF6A0BD8B099A629
	6BAE6A16381A518918F5A8071380ECB240D6F0793F9BD402BED3FD60F60F319C
	AE20238F0D61D1064A20BB7405B981FD867865579091C70E41E4C220905DBA82
	7C61FC7CA414B5EABA492D405678218F7D2A51641746F2033C83900959B6C761
	B94EB6D99DB1DB66DDEAB3E713D1750E17C9C86092C043394A2223421FE93890
	CD624046859B70DBB380911A2702488B6D5C13889001EAA06D27E4437F7C26E4
	9C73EAFD5A1D5B32DB1072AFB009F9D8BF67AE8C646D8ADC3EAF5E4221859893
	9993B7166075AD3CC4B117748C64497974BE8FD459872BBC440BFF6A7AB7EE1F
	76C70BA53C6DFB9D918CA09D8F97F84FA0318F11C9C80B4F1666F1B1FE6A780B
	446863D4C1BB9D90655F92341CDCA76BA41C2113726FD3F3DE92507D6E1A050A
	6A6724FBBA1173F272BA5F7646CC17859F74422664FF7C6CF23719940F503B23
	D91FF47BA2122DD86FE8E73769B6931CC6B66114A9BEC396BD5FEBFBBF0F22D6
	EFA9E535B7EF0B90B716D7BD97D4DB0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="176" length_in_bytes="537" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A10000018B494441546843
	ED5B011283200CE3FFAFF0A74E3DD99C1BA433808565779EB703BA3621B5761A
	420873A16331B3D9F27CDEDD7B9EBCFB5B8C9B6286CE08EA3B8D40196EA6699A
	99E39005721145C5D0510F6600E1B291CCF0B3AE0DB48157BA1F0C7F17E17445
	32DAB12E10BDC109844B5724DF80DF103FD915C968C70EC1C88520102E5D917C
	217E2D89452D5D37D1066C85D7BC7C828E770C0E7D85D48EEE4BC922F873931B
	72952F924562F94CE5315D67BB33DA045F956CEA68D19754DA80B1F72D923B26
	196D92987244729A6484213B4EB7359103C6DEF6909577ABC20A728026B0E322
	394B7591EA1971242557BC7F97924F088C78CD16C922794540E9BA77754BC952
	F2904AFEBB8ED8E1CE221B3BAA8ED9F196D5B5484E74075912D1FAEA2443076C
	7F551A2E6F2EA73429AC20C66842ED716BB3C42585D82991BC3D2E2A25D38FDC
	22212A5D63353233A46429997BB10129388E4BC98C4EF15A29594A9692B14EFC
	CFF0A1646B57A6C13CFF94FDEEA1E919AE16D8BA71640F36F6746B9CCF34B578
	3FF9767C1F665974E9B7EA52890000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="177" length_in_bytes="396" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000FE494441545847
	ED57090EC3200CE3FFAFE0A7B4D08665D911C3C8AA4DAE5421244A22C776D294
	522AF5CD397FFD95D8FBCA245A15880439214A241244C2BA3239414EFC062714
	53A5B3BD5C57CD1E0FEAB83A89DACEDDA794F56DDF227179126E026DF2211227
	4E444208A39140E5ECF9C93375340DCA086ED7E82446D5819C87FEEA3EF18990
	24904BB54F20E789441753ADF78C3ADEC2ACD411520EE4D2294EA07EA27D6139
	122349442101DDAB49E47E30E198EE9DC6A1FDF39698E7BE9753EDE112EBA8D2
	338638B1300928FED1D56E9395DE130941864810892EA785123DD4E65B55A844
	A1F8F489BB2AD1317BBF67EF90C983481009E3E57FEF131BC935C0AFBF82CA0E
	0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="178" length_in_bytes="400" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000102494441545847
	ED57010EC2200CE4FFAFE0A74C709D05A73DB0759ADC1242625877B9DEF530A5
	944A5D39E7AF2FF9F66D2788D60532414D8813C9049918A73235414DFC872694
	5225D95EEE5E778F27775C0DA2C6B9F994E21FFB231397833001B49B0F99D879
	22132218CD046A676B9E9CB9A37950AEE0E31E0D62D61DC879E85FDD27732204
	045254CF09E43C9938CC54FBBDE28EB7342B7784B40329BAA409749EE8B9E0CE
	C40C882826A0BA5A44E60B0B13D3AC394C68FBFC9930EB6F7AA92A120176E119
	24812070C08120BAD49C7687533BC8C4943BEF3D7BDCB68FB639B5839AE88C00
	A933B01DD0F7A989BE677487A41C99201343B0070E2B66C76F65C7066FDF2E50
	7EEDA4C10000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="179" length_in_bytes="386" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000F4494441545847
	ED986B0E84201083B9FF29B829BBA0B31911E6C18E1A939A1012FFD07CB4054D
	29A55247CEF9F6416B7F678868BB0012F00425112440A26F6578029E78872798
	53E9649BCE51778F533A9E16518F73F52925FED8EF493C2E4215D06E3E20B173
	0209320C27618DB3D627A374B40CD215BC9FAF1621A6A32EDE0F439C4C5F75E6
	9E1889D0DE59BFEAB80837892B4490178662B40527DBE5DE0E9060299CC3F867
	3BAC7DC27B21DC131E11E19E58E996F074384588EB6F1D3E68CC95775ACB82C4
	EF949650ADA08727246A026DA4C3E449F4C4C1433744F470BB0E3B45D113E809
	8B79D19844092440C2F13BA17C00F81CB1058C92670B0000000049454E44AE42
	6082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="180" length_in_bytes="403" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000105494441545847
	ED58D10E84200CE3FFBF823FE54ECE99B980EB3C96F0D04BC8059DA3E9DAB958
	4A29EDBBDC5F6B3DEC8A3DF7D735B5BFC5B989C1F37B9E4410BFFC00DA4C10D0
	F964E256256A42E8201364C236306A829AA02666AF75BA83EED8DD1DC74C882C
	64748567DCE18CE99C800FAF6722E8016B510004C296C460AC65834863A2D6DA
	9E96D2D67B260E76F452993ACD1110AF99580902A24234610F1EED85E63426B2
	406CC5846863F8AF2C0AFB3F528E101360CB4E77876B3D8F01B9FF4F9F480111
	ED132920C29A40E9F6E27439C8847CB8837D8FB663AF0C2377EC030245BF32CE
	0A7399ED222009622ACC088DAB62590E96C36A899AA026A8895987DDCA1D1F83
	682955B61276320000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="181" length_in_bytes="435" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000125494441545847
	ED970B0EC3200C43B9FF29B8295B3F48C080D89448D5E449685A9BD157C70910
	4208E93BCC4F4A6758157B5C2B47310934E71D8FC73A429C2C10892304F4FC8B
	D42F1D52A22A0628278EE9809E2F4FD4395375E4DE2A25A444B3B83B362BAD1D
	5A3BBA5B496815CBC66CF795BDDFE86E6D798FE900C15787030494896A3FE100
	C12B611E50AE80E3ED98814DDBEB98937F3200BFA7AAD1C42B1031C6341B855A
	EB4A18C7C029C001574240EE5C58C02808488A0202CE37938E65252C633210AC
	1248FCA916039195987E7BA70379B3F254FE0A4F98325B69C8F79FF4091708B6
	3A5C20684FA0725B714F3AE67F2B01971DD284AC34F4AA8302708540E977C6B5
	C6DC663606521043633232EE8A553A948ED64BF2843C214F8C3AECABAAE30362
	8C99E4F3109B2E0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="182" length_in_bytes="381" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000EF494441545847
	ED58D10AC43008F3FFBFA27FEA6E6342F1A81AE98E716450F6506B434C5C3B11
	11FD8CE5A3AAD219514E3717EE7FC576009C6BD0874C186364824C78F75013D4
	0435B1FAA6D01D7407DD41776467CEFFED13E8893B3D9FA3C7FEFB2E73E6AD8E
	AC5AF8DD03D8DC40C637B0CE05C8408C31341A13D8E79840403CA60904444A45
	579808083261BF268C89F07D379FAAEFAF38A41CA926CCA6A8FF1110A9263C88
	2C79751EEA13BF004126BC3B4281CEEEA8D63C8B7BA526B6FA3F63C0E6672620
	009526D406515DB833EE8B899DC9ABB9086229CC2A853BE3580E96C3EB899AA0
	26A88955977D953B0E88249513A58AAD0B0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="183" length_in_bytes="574" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D3000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC200000EC20115284A80000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313030
	F472A1000001A3494441546843ED9BE10E82300C84F7FE4FC19BA218A6040D77
	D093B55B7F1862185D7B5FBB95454B2965167D9E665EB63C5F57F7DE17EFFECA
	D8C80CED15CCEF6605346CA6699A2D9FCD2A701451AD1873D49D1940BABC205B
	F82CCF16B381CF72DF99FE2EC209051965AC0B451B3881740905B9817E5D4C19
	0A32CAD82E885C0802E9120AF285F8F391DAD49AFB26B301AEF142193B2A51A4
	4B56F200999190133277C6A17C4FD69CCEE88E59F7FEFCCA09EF3EBBAB642418
	5378688F626C7818C3C68134F30119356EE4B16705C38AE301A4E21857021132
	4003ACF713F2613E2664EFE57AE01FBB220D0B99DAA7362B043BFEEEC68BC9D1
	612133E2781F93952C58E612F289DF0198DF935163968D57078DD789BD91A93E
	7699636CB51CC3C641F513A890D07D73259F804C05F4477B77375EB278114474
	5F09B965E5F43AB7A4FB4EC8BED3231464768FF22DB9DE3BA44B28C87A79C6B0
	180A32CAD831907D4789740905795488D6B8434146196B1523EAF348975090A3
	4268ED7728C828635B8BD96A7EA48B06B2F084A995503DCFAB3A35CBFF27AF89
	BE244BAD2C4F5733E807D0C20A61AA9DD8E80000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="184" length_in_bytes="559" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000001A1494441546843
	ED9B610E83200C85B9FF29BC29D345A621EA2BB6192DBC1FC62C426DDFD70A36
	2EA594B2D1B19AF9DAF27CDEDDFB9DBCFB6BC6C6CC50AD207FAB15B061B32C4B
	D61CA7A7C05344A562D4510F6600E9F285ACE1B3CD4D6A03C7E37E30FD5D8413
	0A32CA58178A767002E9120A7207FD86B86528C828638720F22208A44B28C82F
	E2E794B2A955EF9BD406641B2F94B1B31245BAB09227C80C422664598FC3F23D
	D9A63B63D766ADFDB9CA09EF3EBBAB642498A4F0D01A25B1E1618C340EA4990F
	C868E3266C7B163052713C80B468E39A40840CD000ED75427ECCC73921E79C53
	F4634F6CC9D38690A3C226E4E7FC5EB9B292B54B643D5FFD0A851CE29ACC35B9
	5680BB6BE5471C5745A7AEE453A5A2773EE9464432CEFB1869B222CD4C3666FF
	842C0AA821695AEDB1E385D6D6BBEB8D6BAEF70AF4E69FBB4AF626D008FE8482
	2C5DA34600D31203D22514E496C039F65020146494B1B38245BA84823C2B446D
	DCA120A38CD58A11753ED22514E4A8107AFB1D0A32CAD8DE62F6BA3FD2C506B2
	6187A9975023DFB7B5AB77379EFF4FDE137D4B9652599ECE6AD01F691595E390
	FF23610000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="185" length_in_bytes="531" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000790000
	00210806000000FD2704D30000000467414D410000B18F0BFC61050000000970
	48597300000EC100000EC101B8916BED0000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000185494441546843
	ED9A8D0E83200C8479FFA7F04D9D3363630EBDCE23A1855B42CCA296725FF9B1
	90524A6BA3B299D96D79BEBEDC7B5FBCFBDB8C4D33434705F59F56A00D9B6559
	56A614A3C0558B728FA15B3D9801A4CB0E99E1F37C37D1063EC3FD60FABB684E
	28C828625D28DAC109A44B28C81DF41BA2CA509051C40E41E44623902EA120DF
	68BF5EC98B5A7ADD441BB02DBCD6ED9754BE3528F20A67111DAB270BF06F901B
	C62A5F9005B1FD48E571B8BECCCE2808AA3DD994D1A2A754DA8031F72DC88121
	A320C9438E209F43461AB2F7E9B426724090CFE7EA56732E64801E60EF0BB220
	4FFDEDAC9E3C41F244900599DE47CE53AD165E1D83294C4F2E4E862819F267C0
	58B5A317BFB40125436E2F1E2342BECCB72B1932C00605DA5111E4F1216B3FB9
	325F0FB79F8C7ABAEE5715F0B59F0C20A1B34CB33246BA84823C2B44B6DDA120
	A38865C588FA3ED22514E4A8107AFB1D0A328AD8DE62F6AA1FE9D206B235EB62
	78AE975023D76B3A036661D3CC50F1DD9723D4DBF51810DEFCABF943F379006C
	D32EF3397C9E4B0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="186" length_in_bytes="393" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000FB494441545847
	ED57010AC4200CF3FFAFF0A7EEA6AB744E6DE4EC718308220357B334695D0821
	A473C6187F3EE5ECCF4A10390B64829A1027920932D156656A829A7887269452
	A5B30DD7D9DD6325CEC31D2B2F7B8038DBB93952C2DABEFE3A33A8DA90A35BC3
	1104747EC6E708A2C4B7587006019D4F266E59D29A00ED8C64B9EE919C4CD72F
	4040F121C40A04B21F17DB150D7AC11104747EEB0E32011736B4006A4AA19C50
	13421999E830615EFF16850969B25B27AEF454C7A8E715173D7AC7B408B59AD8
	08824C54B9217D809A18DDAC34337487FC87900932514BECC6B25DDC86542CF6
	8ED1CD6A633AA04CB077B077741DEB68D1FFA813071828004433B1B82E000000
	0049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="187" length_in_bytes="380" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000EE494441545847
	ED97590EC3200C44B9FF29B8290DB4462E59181A8854E94542FC803D198F1742
	0821E515637C7C99EF6D074489024CA009CB44988089B62AA30934F11F9A704A
	B5CE76BA5FCD1E237676D93172790588DCCEBB5F4A5ADBF77FD735EA0E14EBBD
	6F2108C97FC1B710C4DB7E8F85C52024FF30F11525AF09319D9528D7331693CB
	FD0608C9BE84D88150CEEB62FB58932E2C0421F96FB30326E4C2A616404FA914
	13346194C1C40113DDF16F509892260FEB440E4FBB4607A5DBD93111044C54B9
	297D004D9C4D569519B2C39E00300113BE314D2CDB3FBD4567A728BD83DED136
	4D348126769A7801B88AAF94B7B696B50000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="188" length_in_bytes="373" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000E7494441545847
	ED56D10E84200CE3FFBF823FE58473668ADA3AB34B2E2909E141DCEADA759652
	4AEBBBD6FAF36DB9975320060BAA8434619DA84AA81247579626A489FFD08453
	AA4DB6CBF3EEDFE3499CA93B9EBC9C01A28F73B85AE3C6BEFF3A18D45D18D1D1
	4A0441E51FF812417CE3A32A2483A0F2AB123B96BC26C8766658DEEE1827B7E7
	0B10547C88B803886E187CBD00D51905B0560FE180F9B7CE88024108EC394412
	05A04AF8CA11744026A489C92DA3E224E8E0A6681480BA43DD71A61D4298F209
	7A76C931E598A71D956CDB9A1D7BDD21574BA6438E29C73C4A509A9026264D7C
	003CC95923A23A0F890000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="189" length_in_bytes="404" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000106494441545847
	ED57090EC3200CE3FFAFE0A76CB0A63288C36DC9B4499E84265696B88E731042
	08E9BD969F94CAB1F3ECB13F7F837D756E6998F45FEC3882F8D827D07A82A0FC
	8B892A4AD284D12126C4445BC0A40969429A18B5756587B2E3D7B323CF84CC62
	46577AC6EDCE980B0FFCF07A18A2FED0A6E84610947F31319DB63786E3D90D2C
	EB041700E3E34CDE002B4DB48E7B7BF66A896C52A82D3B1C4050FEBFCA8421EA
	7E439D60AA25BEDDD4EEA5D03D0041956F2A260822C698460BFA0AE5FC36139B
	41DCAA1343163238316121FA7B26D8DC2FE748615EB1498D6A9541371033C35E
	CF503F4B8A05C28B815E3A2B1CD6C0C4849868DBBE34214D4813D88FAC95BF00
	D64C5FE4042C63C20000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="190" length_in_bytes="423" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EC000000EC0016AD689090000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A100000119494441545847
	ED980B0EC3200C43B9FF29B829EB8F0D525A5E199136C993D054354A5CC7F9B4
	21849096D3FDA5B499BD6DD76B7B0A27C8E761CF6D1D416C581012471028FE8E
	D42F1D62A22A069413C774A0F8D2449D335547EEAD62424C98E1EED8AC343B34
	3B9AAB249A628EC244F1AB29DA5A701B0B2F77FC64DBCD4C3880E0801D418CF7
	89CE8B0A7F3AB8ED3737AB8920C4C4FF77CC5574E4745FB24B03A464DB31270A
	13C51FAA8E0334662323B9FD2F9820A958CC3F9F324C67BE8AD307FC0588BEF3
	81EF1329C678790AD1A2E034BED5C46C10431D733688A1EA980D424C9C6607AA
	FDAC7C581D4F7CA2395039740371E7D8EB5ED953B6A7F40A0459DBD3211044F1
	5E2C491399593121266C954913D2C44F6BE20575580949BA392DB00000000049
	454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="191" length_in_bytes="367" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	003A08060000003EF530370000000467414D410000B18F0BFC61050000000970
	48597300000EBF00000EBF01380553240000001A74455874536F667477617265
	005061696E742E4E45542076332E352E313030F472A1000000E1494441545847
	ED98510AC4200C05BDFF29BCA9BBDA2A565AF352082CEC08D20F35C6E7184D53
	4AA97CEBB69452D29B6AD93DDBCDF95BBF370ED4319E62F60E76C29C1F252EDB
	19BC1D87DA1640C14E98F3C3044CDC321A0C26A7E3CA1D7142BDCF83C1246276
	14510225D6B004133001134F9735A7E3774F47DF9BDBEF99EAD736B5AE2BDDDA
	B75E77230B7338A0C136CD2C0D9895C83997A73A392A2D4EC98587A14027B4BC
	A3A5EEC7EF9FC6034AFC8512EAD9F730E1B129079F615404D3EFC4CE7054DB1C
	534C8971224A816E97ED4089953198800998501EC55C6035567C0021CEF974AE
	F98A9F0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="192" length_in_bytes="1703" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E6E00000E6E01794468F00000000774494D4507DB0B190D1B1C5B
	036BCE0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A10000060649444154785EED9D8B72E3200C45FBFF3FBD9B
	9733988074F54006AC9DC9B45DDB1874A47B8138EDDFBFBFBFBF7CAD1D83ED01
	3E7374F724DD1EE2EE009FE3DB1E6256E20D20EF50A959891B246A424C88F37A
	6A8BCD0ED2D91AC3D6955882DC1560CE4E3790D2ED20D64CCAEAA38EAD5EA54B
	CAE90F90C79ECC3FE56B07B8D3433CF99A129406F04A7E3A1DC4ABA071A06786
	7A39C459A1AD04F5128807382E50E871CB2413BD0777DE774C96CE28AF8D8768
	F035E51855934F0E1A793CB2A391EF6268AA4F128B47509BFF5EEF6210C7D07B
	48A04657654C2582D58704B44BA471A0F25BF852B01FD8B20669CC78CE508848
	F571FD87235F9DD8DC3B553606F4B10B34A22AC74164AAAF1718659C49C91CD1
	662749E8EAE4B241797C08C48F0F3507E45921081CCA1391EBB97324305F7D51
	82A2AE73872801C80568A5E3359BDE44680448578828C095E048FB5A4DA6BA6A
	E459917E10090FD4CE12A5019CE57C04E4AB529DA4D5A5A1ACC0DFF441407A49
	AB196202ECD77F14483344CAC08B75E22C4A17DE0F04A455568740BC9B077299
	C182347AA309624B4A13607F0FB750A6D3ACD5EA8D6A883D2F4C09E53DB26541
	16906A88BD8E24441E627732A894D52110398FB8F3F19EA45AD68D2A88E985FA
	34A426395A4915434C2FD4033CAEA4AA5103520C31BDD00FA29737BA42B40FEF
	3E2D787AA31822E587F741601FA9E79A51043127347678B52FF6622AD98A1341
	A4FCD06F78F769C94B5213E285397309C4BAF47377C69E012D90D26586A81213
	A21D5ADD4242F48F69788BE110EB894DCAA99D79D717059BE122394D88766888
	9C4A37C35988A5C9729EF839EE3FD2CD5A2CE3C4C92932C981201E0D5110535A
	F14C2B634541FC1E63A4F571F8FD6879EB6B7D6D4F4E5BF7C087749F33291648
	6CBB9CB8ED9D5336540F087732EA3E549423E52AF1F044B8121188C739E9894A
	6AD565E19E58FF429FB2ECD307ED50B9890D5764F2DF2845C8A97D38F76C21D7
	891B700F87C879E206310D1F42B89C26447FC6E11073DB2D06A2FBB6DB697694
	131B778AE989EE218D6F305C4ED313FD2187434C4F8C81989EE81FE7A12DA627
	0E0D6F4CE3E1729A9EE80F361C627A620CC4293DB17CEBC53F0C6BB7B88C2726
	C47EA285CBA9D413F3B10D5E25C2216A3CB104C90FE97E6784CBA906E2134BCA
	A94C4E874E6C7A72DA924DAFFFDBBD36C3E53421FAA75438C45A4E47FEBCDB43
	583D4BB9DC1313225E99D340ACE53421F210B96556B89CD637F4FC59BA06E5C3
	37CF19D4322B1C22F2206BF30F17037F4A606788D4322BDE1315EB86531652D7
	2FF2FC8E220450EEFF5893E046EC47DBA01E746ED8F4835EE712E2F717D9BE54
	691688A70FE2309D5A454EBBF207FE51336432981007CF6722200EDD769394F8
	CFA7A93879584C4E918A329DC3C5AB383ED41345D01786585A81DBB26B368888
	C6AFEC89F0F804602405304D25AE0C91F3307899A5841C0211C954ED7B9583E7
	313FCD4B17E7A265D6CC107BD27082CB78E2A752A3994110912445CE9148E869
	E2A8BD50725D6F00DFAC7E7C43C96991FD09B151ADEFE01D410CFE5AF7A79454
	4A59AE24299553C98687A430A6AC44CA13AFAEC452CA39882365B36B4B5AFA1E
	D7ADE2896512B520966A46598747CC9AEF128D6A58BA634379E255F2C948FA69
	C3FAC71A22AD290222728F19211EC9C355E2B14E2C276AF59847CAEC6DD689A5
	AF492B3B3D91D2A4F2D8E0BD530BC4123AE58994E2DCA21247C9692B87A495E8
	0111B114ED3921728A746E14C4E3F916AF650AB7C48076A7507502CF0B810849
	C9C272CA6D8023496C39270422DBC1C6A30D6012B24D8F6AA7DE5DE2404289AC
	EC6C08447600EF8DBF97F21D2FE578C2A04A218EEC58084464003544D3A30D8E
	0F2DC1FD60B28E4D6443D6864084067045E03DEF6980802439B97CB136E075FD
	CA958824E9718EF7D7B71105BCD0411E20EB69FC0A3FB3713CAADE1AEF673B55
	1B2110D9015A07065C8F24D2D07E3A432CC71302F1EA00968C8782A292C919E2
	E95DA2CB0605548F47DF5AB7F16857DC8633C4DB55E2CBFC851F521143E292D2
	19E2AD2AF118EC6E106F5989EE95C5555E7D3C2BD1BE14CA4A94665DBD8EB9DA
	8F8CFD77A9E2ACC4ACC46F227D16FBA5B2FC07C4592F229012C6A80000000049
	454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="193" length_in_bytes="1424" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E6F00000E6F01AB038A140000000774494D4507DB0B190D0807B0
	89E3B00000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A1000004EF49444154785EED9DC972DB301044F5FF3F9BA3
	8F8EC88436446199A5C1E1409D2A559C086B3FF40C4052F2E3FBF178ACFCDAA6
	B7F2FCB6B92D0D707578C7FC96874827D2A92916798A417AC2229DB880130931
	31C4DAD03D8EBE73DDA5C36909F2CE10BC635B1AE27E86E23931CF39D212F9BD
	0EB84BFD744EB4C0D2D6B90B1CE9386E0D5123FED7D79F6FED4BD3BE54D08872
	B7822811550BCA525E328E0858AD3EC321F604B3009855A737CE68A021105B82
	5801489C73559F11402F838810B1EB86EFFA9FFD88D1796FE6B8AE023A1D624D
	24A9E3AA575D9A48DEDF7839EC1BEB1D6DB8C6EC091582BA53219EFB970871AE
	A3D0FEA5A87701948D41E621806175EE3488E59847F050E06AC07BE1D4B240B4
	405FA2C1249053204A015AC39D467C34C496437B0B753648384409C02BE06940
	7BCBAAE70C762414E26832ABC13BC357CD1F081206513A01EFAACF50BFB7A39D
	115A211009B07DBCA9E54A34483744026CC786AB1C0983D85B711942E0AC314A
	405ACF8790E74E7B2E3CDE9B254EA6765B205161D5E5C4D1E032093D7BAC43AD
	1CBB5533C4960BE9405D8E44B8D10DF19C0B675E2199ED962BDADFF4A969B6EB
	6674A309225D68C75D0BAB5E37BA20D28536986837AA21D2853670B50BE7A509
	3C6E3443A40B7D30916E8440E48E540FB4971BB51B1C15C45E28D54F8335CE6E
	B4865413448652CC02448554374486523B5054488540B44F83355B2155931709
	31781D1162300044F784885031B80D420C0680E89E10112A06B78181F8BC01F2
	9C87E8553B4EF0D6936F159CF52B341631D9D87177EA63E0AE8D71E2E0466479
	B3B275383D664257CA98963A8D2096FA9B3F29FC63EFE70F3D88BC722303B895
	2AB5EA412CB5EF1DFE7730E5F7BD94FF6E99B4751FAC2C2F9FD2E794F4E8D9E5
	34BABC4327E21719DC8912883F0FA9FEDF079D9DC89CA8037D794E2C218F3636
	BAA9B0F4911F6BE96964AE172EAAC20327128B5E81D1EE54C287E744BDEED01A
	84089533A631428CD11DDA2B2142E58C698C10637487F64A885039631A23C418
	DDA1BD122254CE98C60831467768AF84089533A631428CD11DDA2B2142E58C69
	2C2DC4F2564C8C74F7E99510EFC3C23C9274106B8F279867BF48C5741037DDF9
	1CCEEBEA4B09F100B98891DCD3B80DC4D6535C11FFEF56F5E2066E0171F425ED
	57BE9F71D74B88A75FF2458882D8577BDAED4AA78DFA224405444151C9435A90
	32AD67602F4E6DE6EEC2C229219A99BD55BC1C22C43ACF51EF61CFB9126AA19D
	E1D429AA14CACB61DFD12721FE7EB654F5F0B01454F3737495CFB45ADB24C420
	88E50773ACF0A41FEEC165ADB92D31279EBE8A9939D1919FB4AEE2C6E6D7DD69
	9DA8855E2BCF9CC89C3837D1295AA7139913F7D3C5A5470CEE4EDF2DFA714E2C
	3744A39C9865A79A16A275777A803BBEB2A52640F908882235851585403C04BD
	EBDF25B05AF4CFFE9D3A108888EDBEB60D3AF183CF89CC89F58D2877A761D9F0
	5FC769C3A936FCF28A4DFF284827D28931170B46478C602EAAEED38653EBEE74
	C5EF994B0B9139718123069DB8004495131BBF296074ED549598020B37C3E931
	6FC14D8AFBEF4E0971C8685840E51AC1AA51B747884346C3026AD1052099133F
	2D2736168560ADCC587F97B5A9E928BD135785797B889A0176CB0A7FC7D5769D
	39D54BB932D33A71879B0D8E74BC1920D28983C890012262774A27063F3C4C27
	D289BF795C9A63B295CB104EE9443A914E3C3935E4884127629DF817BD425A8E
	8804CF550000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="194" length_in_bytes="1452" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E7100000E7101469ED6200000000774494D4507DB0B190D0807B0
	89E3B00000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A10000050B49444154785EED9DD996DB201044FDFF3F9BC7
	799CD84A348364965E0A1A70E51C9FCCC4AC75A90624A43CBE1F8FC7CE9F57F7
	76EEDFAB6F5B03DC1DDED9BFED21D28974EA12837C89467AC2229DB881130971
	6188B9A67B1C3D73DEADC3690A726608DEB66D0DF1D843719FB8CE3ED212F9BD
	0E9825FF724EB4C0D2E699058EB41D5343D488FFF5F5E75BFBD1942F153422DD
	541025A26A4159D24BDA1101AB546738C49A601600BDF2D4DA190D3404624910
	2B00897346D51901741844848855377CE7FF1C5B8CCA773DDB350A6877883991
	A48ECB5E75292279FFE2B2D937E63BCB70B5D9132A0479BB42BCD72F11E29E47
	A1FD25A97700A48541FA218061756E3788699B5BF050E072C06BE1D43240B440
	2FD1A013C82E10A500ADE14E233E1A62C9A1B581DA1B241CA204E008781AD0DE
	B4EA3E831D0985D8EACC6EF0EEF055FD078284419476C03BEA57C85F5BD1F608
	AD10880458DEDEE4E64A34483744022CC786518E8441AC8DB8154260AF364A40
	5AF7879073A735179EDFF51267A5724B205161D5E5C456E35612BA775B9B5A39
	56AB66882517D281BA3912E14637C4FB5CD8F30A496FB78C28FFA54F4EB34337
	A31B4D10E9423BEE5C58F5BAD105912EB4C144BB510D912EB481CB5D384F4DE0
	71A319225DE883897423042257A47AA0B5B951BBC05141AC85527D3798E3EE46
	6B4835416428C50C40544875436428B50345855408447B3798B3145235F32221
	068F23420C0680A89E10112A06974188C10010D5132242C5E03230109F37409E
	FD107D72DB09DE7AF28D82BB7E89C622262F765C9DFA18B873639CD8B81199DE
	AC2C6D4ECF9ED09532A6A94E2D88A9FEE627857FECFDFCA10691576E64005FA9
	52AD6A1053ED6B9BFF034CFABE97F4F792494BF7C1D2F4F22E7D4E4A8F9E554E
	ADCB3B74227E90C19D2881F87348F5FF3AE8EE44CE893AD0C3E7C414726B61A3
	EB0A539FF3636E7A6A99EBC24595B8E14462D12BD05A9D4AF8709FA8D71D9A83
	10A172C614468831BA436B2544A89C318511628CEED05A09112A674C618418A3
	3BB4564284CA19531821C6E80EAD9510A172C614468831BA436B2544A89C3185
	2D0B31BD151323DD3CB512E23C2CCC2D590E62EE7882B9F79B645C0EE24B779E
	C3B98EBE25219E20373192BB1BD3402C9DE28AF877B7AA830B980262EB25ED23
	BF5F71D54B88B7FFE48B1005B12F77DA6DA4D35A7511A202A220A9E49016244D
	E90CECE0A9CD5C5D5838254433B3B78CC32142ACF36CF511F69C232117DA194E
	9DA24AA15C36FB8E3A09F1F7D952D5E16129A8E2737499675AAD65126210C4F4
	C11C2B3CE9C33DB859AB6F499C136FAF62E69CE8989FB4AEE2C2E6D7DDCB3A51
	0B3D979E7322E7C4BE139DA2743A9173E2B1BB18BAC5E0EAF4DDA21FE7C47441
	D49A135759A92E0BD1BA3A3DC19DAF6CC909901E01514C4D614921104F4167FD
	3B05968BFEABBF53070211B1DCD79641277EF03E9173627E21CAD569D86CF8AF
	E265C3A936FCF28A4D7D2B48270A9CD873BB42270EBA624388997D8175753AFA
	3D73B92D8DC0B8AA2474E20027A620557484899785B88A134F0E0CA79D2EB277
	2A16B1708694A12964F9D5E9AE30A787A86920D3B66F172EEB44C20D3E9ED10B
	0062C1D4AB6DB5B3B8DE3AB772627ABF31BD85753FAB3AEBEF56982110AD8D8D
	CA37BBC34320CE2E4AEECAD0CC6D0E8118E5286DBDD9CB6E13EE694220CE3CAA
	4BB7BDB4036064FA1088233B88A86BF641170271765110E04796110271640711
	75CD3EE84220CE2E0A02FCC83242208EEC20A2AED907DD5FF3B1EE9A3CDD68FF
	0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="195" length_in_bytes="1468" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000AED00000AED01028849C10000000774494D4507DB0B190C3828C5
	DC822D0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A10000051B49444154785EED9DD996DB201044FDFF3F9BC7
	799CD84E348365965EAA69902BE7CCC96268A02ED580242BB7EFDBED76E59FC7
	F0AE3CBEC7D82E0DF0EAF08EF15D1E229D48A76E31C9B7E8A4272DD289177022
	216E0CB1D6758FA357AE7BE9745A825C1982B76F9786F83C43F19CB8CF39D292
	F9BD0E58A5FE764EB4C0D2D659058EB41F4B43D488FFF5F5E75BFBA3892F1534
	A3DC521025A26A4159CA4BFA9101ABD5663AC49E60160051757AFDCC069A02B1
	25881580C439B3DACC003A0D2242C4AE1BBEEBBF9E478CCE6791FD9A05341C62
	4D24A9E3AA575D9A48DE3F7839EC1BEB1D315C7DF6A40A41DD5088E7F625429C
	EB28B47F29EA9D006530C8380430ACCE0D8358F679040F05AE06BC974E2D1344
	0BF4251B04810C812805684D771AF1D1105B0EED4DD468907088128033E06940
	7BCBAAC70C762414E2683057837786AF1A3F10240CA27400DE59BF43FDDE8E36
	22B542201260FB78535B2BD120DD1009B09D1B66391206B137E3764881517D94
	80B49E0F21CF9DF65C787C1625CE4E715B205169D5E5C451E776123ABAAF43AD
	1CBB5533C4960BE940DD1A8970A31BE2792D8CBC4212ED9619F11FFAD4347BEA
	6674A309225D68C75D4BAB5E37BA20D28536986837AA21D2853670B50BE7A509
	3C6E3443A40B7D30916E8440E48E540FB4B7366A37382A88BD54AA1F066B9CDD
	684DA926884CA59809884AA96E884CA576A0A8940A81681F066BB652AA665D24
	C4E4794488C90010CD132242C5E41884980C00D13C2122544C8E818178BF0172
	1F87E8A7769CE0AD27DF2C38EB57682C62F260C7DDA98F81BB36C689831B91E5
	CDCAD6E1F418095D29635AEA348258EA6FFEA6F08FBDEF7FE841E4951B19C047
	A952AB1EC452FBDEE1FF09A67CDF4BF9F796495BF7C1CAF2F2217D4E498F9E5D
	4EA3CB3B74227E92C19D2881F8F390EAFF7DD0D9895C1375A0A7AF8925E4D1C6
	463714963ED6C7DAF23432D70B1755E181138945AFC068772AE1C373A25E7768
	0D4284CA99138C10737487B64A885039738211628EEED05609112A674E3042CC
	D11DDA2A2142E5CC09468839BA435B2544A89C39C10831477768AB8408953327
	D8B610CB5B3139D2ADD32A21AEC3C2DC93ED20D61E4F308FFE2215B783F8D09D
	CFE1BCCEBE2D211E202F6224F7309681D87A8A2BE3DFDDAA4E0EB004C4D14BDA
	677EBEE3AE97104FFFC917210A725FED69B7994E1BB545880A8882A29287B420
	655ACFC04E5EDACCCDA5A5534234337BAB381D22C43AF75E3FD39E7326D4523B
	D3A95354299497C3BEA34D42FCFD6EA9EAE16129A8E6F7E82ADF69B5C624C424
	88E51773ACF0A45FEEC1AD5AB191B8269E5EC5CC35D1B13E695DC58DCDAFBBB7
	75A2167AAD3CD744AE89B10B9D223A9DC835F179BA987AC4E0EEF4DDA21FE7C4
	7243345A1377D9A96E0BD1BA3B3DC01DAF6CA909503E02A2589AD28A42201E82
	AEFA7B09AC96FD777FA70E042262BBAF8D41277EF039916B627D23CADD69DA6A
	F8AFE16DD3A936FDF28A4DFF2848270A9C18795CA113275DB121C4CAB9C0BA3B
	9DFD9EB9DA9146605C55113A7182134B902A3AC2C2DB42DCC5890707A6D3A08B
	ECAD6BA741CD2136D4CD18535F95891A49841385D96BD96207C8F2FAB054EF94
	2386B473BD7267272E4B47D8B1ED20D289EF64B7838874E28E6BA0A4CF1A8D52
	D229D2891241762CB33C444D0757288B987491E3D8D68991A2D4AE0CAD0C3205
	E22C00DE76AA97DD16CCCD2910579ED5ADDB5EDE0911593F0562E4802262AF3E
	E95220AE2E4AC444888C990231724011B1579F742910571725622244C64C8118
	39A088D8AB4FBABF319CD092B0C076470000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="196" length_in_bytes="1587" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E6F00000E6F01AB038A140000000774494D4507DB0B190D1B1C5B
	036BCE0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A10000059249444154785EED9D8172E32A0C45F3FF3FDD3A
	69ECDA324842123208BD999D7D5DDBD8E870EF059226AF9FD7EB957FE6AE4178
	80EF311A7D908687181DE0BB7FE121A61217801C41A9A9C40003352126C47133
	B5C426827596FA105A8967905101E6EC348095868308999CD5871D9B5DA553DA
	E90DC8B627F323FC1301EEF0102FB9260425013C539E0E07F1296814E891A13E
	0E71546833417D04E20E8E2A14F7B86692C9BD0775DED127CDC308AFF587A8C8
	35611F45934F0A1A7ADCF3413D5FC590A8AFA5165B518BFF7D5EC5408E71EFD1
	02D55B953E4A64AA8F53D02A91C20190B7EC4B99CFC15BD6701A539ED3152247
	7DD4F3B32B0F4E2CEE9D0A1B633C6315A8872AFB4124D4572B8CB0CEA865F668
	B33248707552A34178BC0BC46F0E153B64A9100E1C2C1339D753E7B4C0FC3C8B
	1014769D39C416805481663A0ED9D426423D409A42E4029C094EEBB382C954D5
	8D2C15690711C940E92CB1B580A39CCF01F951AA91B59A34940ABC0F1F0E482B
	6B55434C8075FD7B815443C402FCB44E1CC5E9DC9F8303526BAB5D20AE9681D4
	C820412AB35105B164A509B0BE877B72A6CBAC559B8D6288B52C4C0BA533B214
	411A906288B507498834C4EA645068AB5D205219B1F2F19AA56AD68D22889985
	F261884D72A496DA0C31B3500E70BF1253A3046433C4CC423B8856D9680A51DF
	BD755AB0CCC66688581EAE8340DF53CB356313C49CD0E8E1C15CACD5B4652BAE
	0922968776DD5BA7252B4B4D880F8E99472042E9E7EE8C7E049440B62E339A94
	9810F5D0600B09D1BEA6EE2DBA4384139BB4533DF36A2E366C8637D96942D443
	E3D869EB663809F11CB254267E8FDBF734588BE73A5176CA99E4B020EE0D6110
	D35AF923ED5C2B0CE2718CB0D6EDF0DF5BCB4B7FC36B6B765ABA07BF4BEB9C89
	B1E0D4B6CA89DADEB98C06F006E1CA885A878AB0A79412F74C642B9103713F27
	3351480D5CE69E89F0037DCEB2CF1CD443A5263694C8DA3F510AB1537D77D66C
	21D78901B8BB43A43231404DDDBBE06EA709D19EB13BC4DC76F38168BEED7699
	1DE5C4C69C6266A27949FD1B74B7D3CC447BC8EE1033137D206626DAD7B96B8B
	99895DCBEBD3B8BB9D6626DA8375879899E803718A4C3CBF14635F96B95A9C36
	1313E2FF4073B7536D26E6DB38EE2EE10ED12213CF20E732BE3E4FEB6EA71610
	DFA5483BC5EDB4EBC4A666A7259B7CEADFFAE8A55FABEE769A10ED61BA438476
	3AD2CFB3BE69EBF14C4C887A65BA4384769A10FB40FCD4B9615241FE2E46E98B
	247778701479FEAC5DB3EACB6FD3827F26368C0EF42B004A238DFA161B70EFC8
	10BB2E315A245E3BF7B2D8BFAEFCDBBE1824C8FB7DDC33510BB1B8ED06FFB1A4
	C8F27EDDED835F67DC44A8DA29E64CD095B46024D7A3C1CD8418D94EC9096442
	B4999058B552B5D3159468B58F6B0543DACEB410510B66DA696488F3DB297319
	9399B8ADD3BEB56A5AEC4B2631BDAE890C91DC091B7E62C35462643B9D02A254
	9D97A509B1D89F65CD18739D8828F1E8F0F63F989D9E0A239D34BA5D6702711F
	DDA3FEBD7F764B79D366FB0EC2AF223117762322B8916889015D486A6D9AEBD0
	1D1BA612B14C9C5D8964268E00513A000EF885B52404173A1347802855E201FF
	EF83CCDEE675B35381A33D7A89281347802855E22A10A7B0530B252EBD4E8CA2
	C4C810615450CA7C64DB4DAD44629DF868C835DE7CDD4C0C0E9152DECD85D493
	0C6C955D39A65262E5C5D299D68667B1A28B7D666D1FB153D5C05900E2918923
	43B450E212EBC491215A283132C423F3468668A1C4C84B8C2920F6542273F0AA
	1EA1C73DE016E2E767E68DD827721BE49C67A14438AB63F697F3788F9C035F52
	1B1EA2AA4AD4EF6C443ACE1C99F32911762C1234D8979121AA9498106FC24B25
	8EA664A6FA2EBF376AAA0AC103A8EF3F1A04EDF3086A984AD416DDFAFA5920AA
	D577EEA875119F6E6F1688AA7562F489CD2C105389FF6FF0BABD762880F80BE2
	E19F14A675455F0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="197" length_in_bytes="1644" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E7000000E700194D934C40000000774494D4507DB0B190D1B1C5B
	036BCE0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A1000005CB49444154785EED9D8B72E3200C45F3FF3FDD75
	B2716213D01B19C9DA994EB7B5C14647BA17A8933CFE1E8F477DC58E417A80CF
	1CCD9EA4E9216607F81C5F7A88558937809CA152AB1213246A412C88EB7A6A8F
	4D06E9EC8D2175251E41660558B3D304529A0E62CBE4587DD0B1E8551A524E7F
	806C7B327FC2AF0C70978778F235212809E0487EBA1CC4ABA061A057867A39C4
	55A145827A09C41D1C1628EA71CD24937A0DECBCCF983437236CEB0F51E16BC2
	318A269F1834F0B8E78D7AFE1543527D9C586C41EDFE7BFD15033846BD0607AA
	7755FA5422B1FA28011D12E91C68FC96DC94781FB4650DA533E539532152AA0F
	BB7F72E49B13BB7BA7C2CE08F73804EA5195F32022D5370A8C30CEA064CEE873
	9024707562D9203C3E05E2DB87BA03B2AC100A1CC81329EDB17338305FF72204
	05B53387C801880528D2F196CD68223403A429442AC04870B8F7DA4CA6866A64
	59917610010F94CE12B9015CE57C0AC857A51A49AB49475581BFE943016925AD
	6A8805705CFF5E20D51021033FAC1357513AF7FBA080D4CAEA148877F3402C33
	50904A6F5441EC4969011CEFE11E94E9346BD57AA318E2C80B4B42718FEC5990
	06A418E2E8460A220E71381914CAEA14889847DCF9F8485235EB4611C4F24279
	1A42931CA9A4B2219617CA01EE2DA16A948064432C2FB48368E58DA610F5C3BB
	4F0F96DEC88608F9E17D10E8476AB9666441AC098D1E5EEB8BA39872B6E25810
	213FB41BDE7D7AB292D4827861CE5C02B12DFDDA9DD167400F247799C1AAC482
	A887D6F65010ED63EADEA33BC476625372AA673EF445C666384B4E0BA21E1A45
	4EB99BE128C4A3C9629EF83E6E3FD2643D1EE384C92965924382B87704412C69
	A567DA315610C4CF31445AB7C3FF1F2DEF7D6FDB8EE4B4770DFA90EE7326C482
	12DB21276C7BE7940DCD03C2838CBA0F15E148B14ADC3D915C891488FB39E589
	426A4D33774F6CDFD0E758F6E5837AA8D8C4062B32FE3B4A0172AA1FCE3D7BA8
	756202EEEE10314F4C1053F721B8CB6941B467EC0EB1B6DD7C209A6FBB9D6647
	35B131A7589E681E52FF0EDDE5B43CD11EB23BC4F2441F88E589F6719EDA6379
	E2D4F0FA74EE2EA7E589F660DD219627FA400CE189C73FC5D88725568F613DB1
	207E13CD5D4EB59E588F71FCAA843B440B4F3C828C257C73EED65D4E2D203E43
	51720ACBE9D489CD484E7B3279D5EFE6D4CBBC5EDDE5B420DAC37487D8CAE94A
	3F477D68EB724F2C88FACA7487D8CA69419C03F11567C6A4027D2D46EF832477
	786D1679FEAC5DB3EAC36FD383BF2732B203FC08805EA6619F62D35C3B33C4A9
	4B0C4E898FCE3D2DF6CF2B7FDE07832479DEC7DD13B510BBDB6EED2F7B15D9DF
	AFFB79E3D7889B0843398594A955252D18497BD0B8891033CB293A812C883613
	12AB5E86727A874AB4DAC7B58221ED272C44508289729A19627C39252E63CA13
	B775DA3B56ACC5BE641233AB4D6688E84ED8F2131B62256696D31010A5D5795A
	9A208BFD286BC69CEB44A0123F03DEFE03C9E92130D249A35B3B13887B76AFFA
	7D7FEF96FEA6CDF61984EF8A8454D88D88E042A22546AB425269D3B403776C88
	95087962F44A443D710588D204F8C0EFAC255B70A93D710588D24AFCC0FFFF46
	664FF1FA915381A25DDA44E4892B409456E25D208690538B4AF45C27CE94E6B0
	131B8B4ACC0CB1B50AAC322FD976535722B24EB432B9C1B2C6AAFB573FF7F544
	2788C720CF92D4B0726A518999E574F907A5D47EF84EDD3683A11D9B08C7DA9D
	270EC8B09EE85989A626D87406CA2931FB2E8168528DD91F597C8E6F6588D13C
	B12A91984DD4AC3BEEDAF4B6DD665D6E76BFDDB520F1A2E492650719B8819995
	481CB7E5704CFA0A07D164D4545AA3E737A9EDF73529E3FCD7F8B0D796ECC7BF
	339BDF36C46BC6AD44E20087C124B63F9EC64ABEEC1059C120067BD8A7A212BB
	DB6ED4FBC90ED1C413B5C1A4B6F79253C6FDB4097B899C46A9C4CFC3B9CC57EE
	8A3C311AC46895284A3AAE9C4683280A8A74900A4FAC4A9CBD4EA4423580284A
	BAAAC4EF8B4544013CAD0BBE0F539D961BD4240830B1F9073DA46722D0DED844
	0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="198" length_in_bytes="1657" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E6E00000E6E01794468F00000000774494D4507DB0B190D1B1C5B
	036BCE0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A1000005D849444154785EED9D8B72E3200C45F3FF3F9D36
	69EC128CDE423CAC9DE9B45DDB1874B8BA823AC9E3F97C3EF26BED183C9E8FC7
	D65FAFE16D3FC6DD077887F16DADC217C054E2E6A9761795A6123798A8093121
	CE5BD9B6D8EC923EEB716CADC412E4AE00DFC5DBCE83CBEA7441C07597CB098A
	1D5B7D222FA9C40B10C3D6E10E70A787F8E56B0658D2FDE195FC743A88A3A051
	9067863A1CE2ACD056823A04E2018E0A14F7B8A506E3DE833AEF1C93A533CA6B
	E3211A7C4D394655F14941438F477634729DA8519F2416BF416DFE7BFF150339
	C6BD87046AB42A6394C8541F27A02091C681CA6FD99732FBC17B2282D398F19C
	AE1039EAA3FACF8E7C7562AB5DCFB6B80559842AFB4124D407C1D3065A934EB5
	F742FA8EAB939AB1CAE35D207E7CA839204F857020609EC8B99E3A07180F3876
	559545C075872801480568A5E3759CA142E81D1FA5E2A0EB5C217201AE0447DA
	578E577A83F4838878A0B64A94067096F33920DF4A7552A44B43A9C0EBF4E180
	F452A419620284F51F05D20C1133F0629D384BA60BEF0707A435AD768178370F
	A4660609D2E88D2688AD549A00E13DDC22337DAD23ADDEA886087961A650DA23
	5B166401A98608752421D210C162509956BB40A43CE2CEC7A1946A5937AA20A6
	17EAA72156E46853AA18627AA11EE07125A6460D4831C4F4423F885EDEE80AD1
	3EBCFBB4E0E98D6288981FDE07817DA49E6B4611C42C68ECF06A5F84622AD98A
	1341C4FCD06F78F769C92BA526C481736608C45AFAB93B639F012D90D2658648
	8909D10EAD6E211C62ED89A9443B5430A50AF651454A4C8876681C254AF75113
	A23F17518B214A2C4D96F2C4CF71D120EE78721927CA1339450EA9C4F326BF3F
	6010D31FF9D3B18C1506B18C3DB6F8FF037300AABED7DE0A7962CB83F943BACF
	9958ADC2892DC889DADEF99A0DD503C2C08CBA0F15E54829251E850D5B891C88
	C739E9894A6AD565E19E58BFA14F29FBF4413B54AAB0A144267F5B30249DDA87
	73CF164296185F332121BACFB470889427BA8FF0060D86A7D384E83FABC221E6
	DE690CC4DC3BF58F73D716D313BB8637A6F1F0749A9EE80F361C627A620CC4F4
	44FF38776D313DB16B78631A0F4FA7E989FE60C321A627C6405CC213CB3FC5F8
	8765AD1697F5C484F83FD1C2D3A9D513F3318E6B960887E8E18925C8B5125F9F
	DE86A7530F88AF50643AC5D369D7C2064AA7AD3439EAFFFAE8A55FABE1E93421
	FAC30C8758A7D3997E5FF5A1ADE19E9810EDCA0C8758A7D384D807E23BCE82A2
	827C2D46EB83240F78F52C8AFCDDBA66B587DFA785784F14CC0EE20520D79946
	7D8A4D75EF9D21765D6248240EBEFD7FF131C6D833AD97545D4FA04D9E810DF7
	442BC4E6B61B01079C951B43246B8F3A2B59C168AE478DBB95561BF4774EA709
	D1A7DE086B054CA7588DB08B12BDF671C36801375A16229A8299E9746788EBA7
	53E632263DF1BFCC172DF635454CAF6B768648EE844DEF894C25EE9C4E9780A8
	55E7D7D28458277E943ABA6E21EF0F6EBB2D5D9D224A3C07FCFB03964E8BC090
	411C7D820BC46376CFFAFD78EF96E66E4F315BB12C3C1A14767FD512A3CE42DA
	D466B90EDDB1612A11F3C4D595487AE20C10B513E084DFF08B1ADCD69E380344
	AD124FF87F6F64F6CA52E7A79FADA4BE32BDAA3C7106885A25DE05E212E9D443
	8991EBC49EA979D9C2C643893B43ACAD8252E6906D37B3128975A2D7920258D6
	7835FF6EE7BE9E1804B10C72AF94BA6C3AF550E2CEE9147C240558430F49A766
	4FFC93C5E5C395B15D9BD98FD5CB2509C821103D9408AD13678705F56F39881E
	4A945670548537E571E68C5C568953069D7A005A7A7C66881E4ADC19E2996566
	86E8E589C760EB327D87DFA72F6C5C94C89CA5A062B9D71F6B52C1F99FD7B35F
	2AE8665FFE67DCF57CE63DD7F544E600AD10CBDB88261FD7FF5685280A061716
	5CBBB715C168B7750ABBEFBB43F4F044733019108F7BA8FA2B8528E84F3DF621
	E9940DC030B0F26F8FA81731EE91101B4152058511ECE6E48014A16D8F7B5D2A
	B178252A37681D3C31D32912FC5462B1796F9DA4AF2550A83F8DB89F433A554D
	BAC074FA03B35004931ABAF5CA0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="199" length_in_bytes="1209" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E7000000E700194D934C40000000774494D4507DB0B190D0807B0
	89E3B00000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A10000041849444154785EED9DDB72A3301044FDFF3FBB8F
	79CC1AC7B814824197665A920F55949D943423FA68460884B97DDF6EB799F7E5
	F0663EBEE5D8A606383BBCF5F8A687482412A94374F2211AD9921689C4092211
	880343DC6B7A4B44F75C77EA749A82EC19426BDBA686F89843314FFC3D8F1C38
	BBB676F6F0FA250E8B22118845729570F853B6A47251AB56885F5FFFBED9AFD1
	60D51888037732200E0C6FCD6C16888C934523D26E964C87261BC4EF8EB7C714
	A3E36D691F100F00FD9AEC770A128899005F29AA439040CC80423ADD9CB5ECCD
	1347102983B5AD089168935EE718883A2D6D968068935EE718883A2D6D968068
	935EE718883A2D6D968068935EE718883A2D6D968068935EE718883A2D6D9680
	68935EE718883A2D6D968068935EE718883A2D6D968068935EE718883A2D6D96
	8068935EE718883A2D6D968068935EE718883A2D6D968068935EE718883A2D6D
	968068935EE718883A2D6D968068935EE718883A2D6D9642203E96E93FD7EF9F
	2DE3EF7D49BF8DD4C671AAD319C454FF778F809F3E21B9825B7F4E64CFE9D2C6
	57B95E94EAB81DA956471053ED8F9EE1BF97FB89B4BDCFD5C8F673EFA1C86D99
	8E35B435AD45CF434E67BFD24024EA99CB2331072263A21664F89898423E3BB1
	D11EEA67583B3BB1390BB2E29F8F06A2BE630151AF69B84520864BAE770844BD
	A6E11681182EB9DE2110F59A865B0462B8E47A8740D46B1A6E1188E192EB1D02
	51AF69B84520864BAE770844BDA6E11681182EB9DE2110F59A36594C6F31E51A
	0262AE5241E5801824F4156EF6965DE4FA211273950A2897822C7107C412B502
	CA924E03445E5DBC5B75E6FA3FAF54A880BF4D613DBDF72A5D5D98B3BEE663D7
	D80071E78D2A15C160AD02C40921BAC6C223BFB9A99474FA7CCB1B103B7FA1D6
	5EDE56CCCDF622E531C530F488D3A7A2665C017E05C45F93FD609040BCA7D49A
	D3FABDCEED02094401C4F48123D269D0C4E38A749A3EE3190D924824127FC693
	D1B6AB22313A025F69BCC4F13A706F2FD802F1DE93EFE230C508EC0944E2C497
	DD4AB21293FDC0A84BEF21A6DF8FEEE1B9D2626D27FA98B3D3D784FE4EF2289D
	B64CFC5DF0A787F8EE0A58CE6FF1A450D6EF3D7E4E0F71BB2463F99B481CF4C4
	269DCF9E9D9DBAD2226362C1C9D219C46A31B9155540A1B1E855106BE1B7D6FB
	983131E57E1544571A06A2F002786B44D5D607A2102291D838CE9554BF2A9DD6
	46526BBDAA48DC8E2F2502F650767BFBACE52ACD7699462B909AFA407C4EFE5D
	A9B006DAB60E1085105D1D018842888AA8AAB1014421C4A122F1DD9D81D1FF5F
	13053DD4A98AC4D161BD6B7F2B90512271590C34EDD60AD155BF28129FEB1397
	358A73EDA2D432442402F16769626F7B7983668BC2E5784460884467E7104154
	7586523BE5BDD029F655BE451089C4AB00E5D815412C8D2055792291317192A9
	C6E091F81FC28452572B2C93CF0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="200" length_in_bytes="1223" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E7200000E7201EB27F74D0000000774494D4507DB0B190D0807B0
	89E3B00000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A10000042649444154785EED9DDD92EA2010847DFF973D97
	7BE989BA5884C5F0D74C0FD85659BA5B6186F4C70C998498DBFD76BBEDFC7EEC
	DECEFBF7D8B7AD01EE0E2FECDFF61015898AD42506F9129D1C498B8AC40D2251
	10178698EBFA48447B6EBB753A8D417A8630DAB7AD213E6B28D589E73A72E1EC
	3A3AD8CDDBB7386C8A44416C92AB85C39F6D5B1A37F52A40FCF9F977D77B8E06
	4163415C789009E2C2F04266A340D43CD9342365B3643C35D120DE1DBF9E2586
	E3D7A37F827801E854EC3B0529889500DF29CA214841AC80A2749A1CB5E4EAC4
	1544AA604DDB449148931EE75810715AD22C09224D7A9C6341C46949B3248834
	E9718E0511A725CD9220D2A4C73916449C96344B8248931EE75810715AD22C09
	224D7A9C6341C46949B3248834E9718E0511A725CD9220D2A4C73916449C9634
	4B8248931EE75810715AD22C09224D7A9C6341C46949B3248834E9718E0511A7
	25CD9220D2A4C73916449C96344B8248931EE75810715AD22C99407C2ED3FF5D
	BF5F5AC6EF7D493F8D54E238D6A90431D6FFD32DE0C53B2403B8F0732239A78F
	3EBEB7F3A294E37EC45A5D418CB5BFBA87FFD8EE1569B9CF6024FDCCDD14996E
	E358435AD746F4BCE454FA950645229E393C126B206A4EC482349F1363C8A503
	1BECAE7E87B5D2814D29C89A7F3E5A10F1034B10F19A9A5B144473C9F10E0511
	AFA9B9454134971CEF5010F19A9A5B144473C9F10E0511AFA9B9454134971CEF
	5010F19A9A5B144473C9F10E0511AFA9B9454134971CEF5010F19A0E598C2F31
	D51A12C45AA58CB6134423A167B8C92DBBA8F5A348AC55CA60BB18648B3B416C
	51CB605BA5530391838B4FABCE58FFD723153AE0A729CCD373AFE2D58535EB6B
	BE768D8D20669EA8D2110CD42682B82144D65C78E5B736952A9DFE3EE54D109D
	3F502B97B711B5592E529E2506614414EF8ADA7105F80C88A762DF18A4201E29
	B5E7B03E37B8592005110031BEE148E9D4A8F098914EE37B3CAD412A121589AF
	F964B5D7AC48B48EC0771A6F711C26EEF484AD201E23F910472586E14850246E
	7CDAAD252BA9D8378CBAF81A62FCFDEA1A1E2B2DF60EA2AF393A7D17F407C9AB
	743A52F8B3E06F0FF1D319B09ADFE289A184EF1E3FB787982EC978FCAD485CF4
	C026AE674B47A7ACB4A839B1E160A904B15B4C5D8A6AA030B8E92C88BDF047DB
	B99E13679DD29B05919586051178027C34A27ADBBB84982B0B0633E8A9B922D1
	E8E8F474951C49B05062F44603B39DCB48CC9D2A43725424BEAEBA6CF95E75A7
	9A68EC0A6FE47C69BA608A31109A20323A289FE5B42788C0F4B2449DE8E942E8
	4884B2C41EE9F355DBE1484CE793D5FE460ACB1A1CC3109122A4B658A2CCDCA7
	19B6DD423C15FBC0796B8688C1266BD0B984983DEDB608C89983E4936D9710D9
	23BB1784223113692C517A21B2DAB98E449628BD7E5983CE35449628BD1059ED
	5C436489D2EB9735E85C436489D20B91D5EE3F8EC5C5CE9BB539270000000049
	454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="201" length_in_bytes="1230" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E7100000E7101469ED6200000000774494D4507DB0B190B2C2609
	856EFA0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A10000042D49444154785EED9DDB72C3200C44F3FF3FDBC7
	3EA676123CD825E6B6D60ABC99E9A4ED8084F72071314E1ECFC7E331F3CF7A79
	335FDF7A6D53039C1D5EB8BEE9212A1215A94374F2211AD9931615891344A220
	0E0C31D5F49E88F65C77EA741A83F40CA1B76D53437CADA1B44EDCAF2307CEAE
	BD9DDDBC7E8DC3AA4814C42AB96A38FC2B5B53B9AA5501E2EFEFCF533FD76810
	3416C4813B99200E0C2F64360A448D93552352324BC643130DE2D3F1EBB5C470
	FC5ADB27882780768B7DA72005B110E096A21C8214C402284AA787594B6A9D38
	824805AC6945148934E9718E0511A725CD9220D2A4C73916449C96344B824893
	1EE75810715AD22C09224D7A9C6341C46949B3248834E9718E0511A725CD9220
	D2A4C73916449C96344B8248931EE75810715AD22C09224D7A9C6341C46949B3
	248834E9718E0511A725CD9220D2A4C73916449C96344B8248931EE75810715A
	D22C09224D7A9C6341C46949B3248834E9718E0511A725CD9209C4D731FDCFF9
	FDDC317EEF47FA69A40E8E639D721063FDBF3D029E7D4232800B1F279272BAB6
	712BE74529C7ED88B53A83186B7FF60CFF52EE1D69A9F760E4F89E7A28F258C6
	B186B4A6F5E879CA29F7290D8A443C7378249640D4988805693E26C69073131B
	ECA5DEC35A6E62930BB2EA8F8F16447CC71244BCA6E61605D15C72BC4341C46B
	6A6E5110CD25C73B1444BCA6E61605D15C72BC4341C46B6A6E5110CD25C73B14
	44BCA6E61605D15C72BC4341C46B6A6E5110CD25C73B1444BCA65D16E35B4CA5
	8604B15429A372826824F4156E52C72E4AFD28124B9532281783AC712788356A
	1994553A351039B8F876EA8CF57F7DA54203FC630AF3F4BD57F1E9C292F335B7
	3D632388896F546908066A15419C10226B2C3CF35B9A4A954E3FDFF22688CEBF
	502B95B7116BB354A4BC9618841E917D2A6AC613E05740DC2DF68D410AE29252
	5BA6F5A9CECD0229880088F103474AA7460B8F2BD269FC8CA7354845A222F13D
	9E8CF6BA2A12AD23704BE3358EC3C07DDCB015C4A5272FE2688961D813148913
	6FBBD564252DF60DA32EBE8718FF7E760F8F95165B3BD16D66A7DB827E217996
	4E7B16FE2CF8D343FCB60356F2593C3194F0BBC7F7E9211E8F64AC7F2B12079D
	D8C4EBD9DCEC9495163526564C9672109BC5D4ADA80A0A9D45AF82D80ABFB79E
	EB31F1AA2DBDAB20B2D2B0200237C07B23AAB5BE4B88A965416706DD5557241A
	CD4E7777C99104334B8CD66860D6731989A9AD32244745622212BFED8A78FE7F
	EFF30FCCC83BFAEE8A446474306C05903DFBA5C703530CB88278F7D929237A90
	3E6F1D899EC7BA9EB6315221C267533AED11CA73DD5E4187D8B1E9BDC8DAFA2C
	516ADBC92E5F1589968DDD2DF63D876FD43656A7730931B9ED360848CB8EDE74
	EED4BA81AC9EDD7A9DACF6BA8CC4AD87916EB2B64264D5730D91254AAB5F4562
	62CC6389D20A91554F91089C30B13A9D6B882C515811D5EAF70F5F51A7C6885D
	D6C00000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="202" length_in_bytes="1433" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E6F00000E6F01AB038A140000000774494D4507DB0B190D1B1C5B
	036BCE0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A1000004F849444154785EED9D8D92EB200885FBFE2FBDDB
	9F2443AC8A182042CF9DD9D9EDAD31CA071C3469FAF87B3C1E997F5ED3CB3CBF
	D7DC5203CC0E6F9F5F7A888844446A08270F31C82B691191982012013130C4DA
	D0AF44F4CAC7A64EA714E4CA10AE8E2D35C4F71A0AEBC4F33AF2E4D9CF25F4DF
	7B19FDF183D7DF78AD680F8194892291C2DAA1E1F7C779357FA4D943045173A0
	E88B016F158930BC6EC475ED6905B14CA782F35C2DC0D21F4F819AA6534094A9
	8FC4C9DD2096E14F2AD35775BAE4BFCDF1961CDBBBA42FAAFBC3C6020F90B956
	5185AD0EB158122D09D21D622B9DAE689DEAB6DB8203AD41BC451317B4CD31A4
	88E9D414223451DF5DDDD3694488FA66D7EDD11D62244DD435B55D6FD0443BDB
	BAF5EC0E11E9549FAD7B3A05C40410A1893E104D971880980022D2A90FC4B79D
	B177AA6F6CAB1EDD0B1BA4537D94EE4B0C404C00119AE803119AA86F67D31EA1
	89A6E6F5E91C9AE86367D3B3B8438426EAF3744FA7800888FA1648D0A37B2462
	9DA8EF35EE9A0888092042137D2062B1AF6F67D31EA189A6E6F5E91C9AE86367
	D3B3B8438426EAF3744FA780181422BD69875B62ACFEB9077D04733D523B71E9
	74E4A629F65E8EE324CF3F7A10C960E666F64347515BF52052DBF7EEB9F980D9
	0115BFF74E5A79BB7C9FBEFE2126C35365EC757A0247AD6D93137757D5C91B3A
	1F3245240EB3A49F0EEE7E5278381247201E0F47250F1D7A1539253868E21848
	774DA490B9C2666C0A68452DC015365C90C91F1F1DEC33FB11DCA5556F8CC09B
	7B7C3420AAFB853B44A4537586D5C266646D78923951D832858DFE14F3F7084D
	4CC0D83D9D62EF54DF6BDC2142137D204213F5ED6CDA2334D1D4BC3E9DBBA753
	68A23E587788D0441F88D0447D3B9BF6084D3435AF4FE7EEE9149AD8073B7329
	CE1D2234D1072234D1270B9ECE52BD9562701CD0C441437934A32025E7734FA7
	D0449F74FAB6732DBC1BFF276B9CE45294C03E125B5E6A4B03049A3890CB7E1A
	629674DAD421E56F5F2BED257A2DF034513A05C4C45FF83590C1966AB27A2442
	1307DCA5B9365BE99B59914EF9A5406DF7E9ABBCE434B230B434822E95B3E4DC
	D0440AAAF47E01C4D3625F10451A20BF2176069E65EF54B44B52B3472502BFF8
	3B820444F2ADE4D5A8188078FAC09123BCF66DFC5C0A21EF138F1E2827D66922
	DA7406C475C0D19168A7D35091084DDC16FB37A4CCEEC7BD25657566881ACB03
	8D3E66AA5551619379DBED2E0033D0CA6300B1B74E14A6CDBB1C410431723ADD
	C6FEAE6FB8C2E62E18B351F953107790BD25C6F19E300AE9E3496661CC1E777A
	768AE87A57E5E9192B2E287A2CCAABE9B5B6E5F2618FD2957EA787B83B16DD98
	E8A5D3F491985E13B71B94E269A2709BAD9682564CA3BD313535517897D957A9
	BF3D626D56DB668FFB9974CA6DBB1D5966A2A09935BED671805866A20B10EF4A
	C322889135918BC443262E40D48A2C693F80C85D4F14400D1189D83B7D562E02
	A85E6DC70755A962E9DA2B5285DA5C27EE739C04755F248E0E78DBA1C9BAC438
	6599519B2CD24E1489990B9BD3DC26E18488C4F49A78319D7A69207F3DB1E585
	D044366B8588C4563A9DCC3E77396EF57AA2463ABD6B42AC7791193FE7F969BE
	A7D5A8F05AF3B8BAE00F1189D2EB8D61DB07F34E51248685C25DA951828648E4
	0C6DF9BE12C4F535914ED4D2A077F4AD0471FD4804C471E951728AD1C89E1BD8
	1DD162794E25A323122D21717D2B411C8D1CED7688C48BF7D5502088442E5A2C
	DF0F1E89FF0FA322022BCC1CC00000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="203" length_in_bytes="1481" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E7000000E700194D934C40000000774494D4507DB0B190D1B1C5B
	036BCE0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A10000052849444154785EED9D8B92EA200C867DFF97DE5D
	BBD609C825812440FCCF8CE37A6C29E4CB95527CFC3C1E8FC8AFE7F0228FEF39
	B6D000A3C3BBC7171E222C11967A84921FD1C919B7084B0C6089807830C452D7
	672C7AE77343BB530A726708B37D0B0DF1AAA15027A67564A2D97F25F4CF5546
	FFEBC1F36F7C5694872094892C91C2BAA1E1FD5F79355F52EF2182A8D951B4D5
	016F658910BCAEC535E569053177A782EBCC2660E1CFA7404DDD2920CAA28F44
	C9DD20E6E64F32D36776BAE5BF97E26DD9B72BA5CFB2FBB78C051A2053AD2C0B
	DB1D6256126D09D21D62CD9DEE289DE2B4DB861D2D415C12133794CDBB4B27BA
	5353888889FAEAEAEE4E4F84A82F76DD16DD219E141375456DD71A62A29D6CDD
	5A76870877AACFD6DD9D0262008888893E104D4B0C400C0011EED407E22567CC
	9DEA0BDBAA45F7C406EE541FA57B89018801202226FA40444CD497B3698B8889
	A6E2F5691C31D147CEA65771878898A8CFD3DD9D022220EA4B20408BEE96883A
	515F6BDC63222006808898E80311C5BEBE9C4D5B444C3415AF4FE388893E7236
	BD8A3B44C4447D9EEEEE14100F854817EDF44A8CDD9F7BD04730D6229553CF9D
	72164D75D772BC2FF2F7470B22E9CCD8C8BEE82C2AAB16442AFBD69A9B7F3037
	A0ECFD6EA4E6B7F3EFE9E72F62C21E6A475EC90E1CA563AB9C7AABAA126D683C
	640A4B64B3A44F07379F14665B2207E27B7354B2E9D033C9C9C12126F240BAC7
	440AB997D8F08680A3A8047A894DCFC8E4DB471FF6CCFE09EA52CB3738F0C6B6
	8F064475BD70870877AACEB098D8706AC324CC89CCB693D8E80F317E8B888901
	18BBBB53CC9DEA6B8D3B44C4441F888889FA72366D1131D154BC3E8DBBBB53C4
	447DB0EE1011137D202226EACBD9B445C44453F1FA34EEEE4E1113DB60476EC5
	B943444CF4818898E8E30593AB14975230FB8198C81494C76114A4E47AEEEE14
	31D1C79D5E722E9977E5FF640707B91525908F449653C75203414C64F8B2AF86
	18C59D56E390F2AFAFE5F2127D16689AC89D0262E01FFC6278B0AD0ED9DD1211
	1319EA52ADCD76FA6556B8D37E29509A7DFA482F7B313213B4D482A6D259726D
	C4440A2AD77E01C4A4D817589106C84F888D8E47993B15CD9294E451B0C00FFE
	8E200191FC2A79D12A181093078E1CE1D597F1F75C08F99E6834239DD8E710D1
	A43320EE038EF644DB9D1E65898889AF627F81CB6C3EEE2D49AB2343D4280F34
	DA18C95645894DE469B7550046A0E5E70062AB4E14BACD558A208278B23B7DF5
	FDCA6F7A89CD2A18A356F955106F90AD12E3FD9DD00AE9F624A33046CF4BF64E
	11DDEF2AEC9EB16341D16291DF4D2F1D9B970FB795EEF41E1EE2AD587462A2E5
	4EC35B62F898F85AA0745E4C144EB3955CD08E6EB4D5A76A4C14AE32FB48F55F
	5BAC8DC6B6D1F3BEC69DF6A6DDDE5E6620A11915BED6795B43A46581A6B55763
	E23758A2774C3C0DA2966549DB1159A217C462AAAF688AAD3A512AC0645320C4
	C4941205A9C8AF3A63735A463ABCA394F704B8BB3B9D4C6A5629027FA1546339
	DFE4D8673CD8D4B9B752CE14F8531D50129C08A2B7256ABBD1C2EC4D9A134C0A
	F5084B04C4BFCC6512B4C5F9FC4E156676E87CA495D558B4DB9A3B9D11F2D196
	B8A172B2587CDCB53974202A9678E8D8AFFBC3C96B7220475A22B945CE9B3410
	0A492C94DA64BEF0BA2C33DEA8CD294BB4849814FB5C812D8628563AEEB83AC7
	6D09B138EDC619F06288AB2C980FB12544EE3D490E08728C58B3174314F75728
	8F9A9200A292205759E1B5404BE5E2469628EE1B2C7102A81144B17B5A0C51AC
	744A46044B5412E4DA75A71A838025EA18C3208B5FFBADEA01C1F371DB000000
	0049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="204" length_in_bytes="1498" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E6F00000E6F01AB038A140000000774494D4507DB0B190D1B1C5B
	036BCE0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A10000053949444154785EED9D0972C3200C4573FF4BB78D
	6B670461D1C7422CFE9DE9A46930C67A5A3126AF9FD7EBB5F3EFFBF276BEBEF7
	B56D0D707778D7F56D0F9196484B5D42C99718E41DB7484BDCC01209716188A9
	A1DFB1E8998FDDDA9D4A903343B83BB6AD211E3514EBC4B08E0C34FBAF84FE39
	CAE87F3D78FFCDF786F2004219648912D6058DAFFFCA6BF98B7A0F08A2E540D9
	57057C2F4BA4E06D2DAE28CF5E1063770A9CE76E02B6FDF1126857774A8858F4
	4194DC0D626CFE22337D67A753FE9C8A37E5D88E943ECAEE3F3206340053AD28
	0B9B1D6254124D09D21D62CE9DCE289DE4B4DB84034D411C12132794CD67482B
	BAD3AE101913EDD5D5DD9DAE08D15EECB63DBA435C2926DA8ABA5F6F8C89FD64
	EBD6B33B44BA537BB6EEEE94103780C898E803B16B8941881B40A43BF58178C8
	9973A7F6C2EED5A37B6243776A8FD2BDC420C40D203226FA40644CB49773D71E
	1913BB8AD7A773C6441F39773D8B3B44C6447B9EEEEE941009D15E021BF4E86E
	89AC13EDB5C63D2612E2061019137D20B2D8B79773D71E1913BB8AD7A773C644
	1F39773D8B3B44C6447B9EEEEE941017852817EDD44A8CD99F7BB047D0D6A394
	53CD9D6A164D55D7727C4EF2F74709A2184CDB953DE82829AB124429FBD29A9B
	7F3017A0E8F5EA24E7B7E3CFE5FB0731515F6A455EC10E1CA9B6594EB5555581
	36141E32A525AA59CAA7838B4F0AAB2D5103F1B339AAD874E89DE4C4E0181375
	20DD63A2845C4B6C7497C0565202B5C4A66664F8F6D18B3DB3BF82BAE4F20D0D
	BCB6EDA309D15C2FDC21D29D9A334C26369ADA30087390D956121BFB4BDCBF47
	C6C40D18BBBB53CE9DDA6B8D3B44C6441F888C89F672EEDA23636257F1FA74EE
	EE4E1913EDC1BA43644CF481C898682FE7AE3D32267615AF4FE7EEEE9431B10C
	B6E5569C3B44C6441F888C893E5E30384B722985721C8C894A417934932091F3
	B9BB53C6441F777AC83965DE99FF618D37B91505C80791E5ADB6D240181315BE
	ECD1107771A7D93864FCED6BB1BCA0F780A641EE941037FEC22F85079BAAC9EC
	96C898A850976C6D36D337B3D29DD64B81D4ECD3577A598B9191A0510BBA95CE
	8A7333264A50B1F6031083621FB0220B90DF100B03DF65EE149A2549C9236181
	5FFC1D4112A2F856F2A4552820060F1C39C2CB2FE3AFB910F1B9D068453A314F
	1368D29910E701274762ED4E97B244C6C4B3D81FE0328B8F7B2369F5CE102DCA
	038B3E5AB25528B1D979DA6D14801668F1318458AA1341B7394A1120882BBBD3
	73EC477E534B6C46C168B5CA4741BC40964A8CCF67A015CAED495A61B41E17EC
	9D02DDEF4AEC9E316341516211DF4D4FB58DCB87CB4A677ADD1EE2A5587262A2
	E44EB7B7C4ED63E2B94069BD98084EB3A55CD08C6EB434A66C4C0457997DA5FA
	E7166BADB1ADF5B8C7B8D3DAB4DBC7CB342434ADC2B73A6E6A88B22CB0B4F66C
	4C7C82257AC7C4D5205A5916DA0F64895E1093A9BEA12996EA445480C1A6408C
	89212509D2905F76C666B58CB4794729EF097077777A33A919A508FA8552E70C
	8D6696E3A62CEE7834E8D8AF19AA55061E8D93106B6B6C00B04B58223AB7BA52
	FB510020D7915128C8125782D23456C0EA52C21FA50810C4B8C468121430CDE7
	DEFF4D881656D5D24733C4B8D65AF9FD9D3B1773D4895AED2BADBFD45A97F65C
	673BD83DE5C6019EB7C51A461E0359623625EF003128F6B510064384954E7B5D
	957653424C4EBB692E7830C451D6A887581262074B6C5AB33218E2FC96488836
	0AAFF128601B9B8175B244D83DD112FFEEA3801A201670EA6E6981FDC3EE6930
	C466F98172A9AF006FE99096781800AC742DB24E1CD36E7D410DA0DC1A041C34
	2C94875AE22F28ABA2490407ED810000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="205" length_in_bytes="1425" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E6E00000E6E01794468F00000000774494D4507DB0B190D0807B0
	89E3B00000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A1000004F049444154785EED9DD972EB201044FDFF3F7B1F
	F3E82B29960B2B2CB3348CC09D2A5716B3F6A1079088FC783E1E8F955F7BF756
	EEDFDEB7A501AE0EEFECDFF210E9443A758A413E45233D61914E5CC089843831
	C45CD33D8EBE73DEA5C3690AF2CE10BC6D5B1AE2B187E23E719E7DA425F27B1D
	7097FCD339D1024B9BE72E70A4EDB835448DF83F3FFF9EDA97A67CA9A011E96E
	055122AA169425BDA41D11B04A758643AC096601D02B4FAD9DD14043209604B1
	02903867549D1140874144885875C333FF756C312AEFF56CD728A0DD21E64492
	3A2E7BD5A588E4EF1B1F9B7D63BEB30C579B3DA14290B72BC46BFD1221AE7914
	DA7F24F50E80B430483F0430ACCEED06316D730B1E0A5C0E782D9C5A068816E8
	4734E804B20B4429406BB8D3888F865872686DA0F6060987280138029E06B437
	ADBACF60474221B63AB31ABC2B7C55FF81206110A51DF08EFA19F2D756B43D42
	2B04220196B737B9B9120DD20D9100CBB161942361106B236E8610D8AB8D1290
	D6FD21E4DC69CD85E77BBDC499A9DC124854587539B1D5B89984EEDDD6A6568E
	D5AA1962C98574A06E8E44B8D10DF13A17F6BC42D2DB2D23CADFF5C96976E866
	74A309225D68C79D0BAB5E37BA20D28536986837AA21D2853670B90BE7A9093C
	6E3443A40B7D30916E8440E48A540FB436376A17382A88B550AAEF06735CDD68
	0DA926880CA59801880AA96E880CA576A0A8900A8168EF06739642AA665E24C4
	E0714488C10010D5132242C5E03208311800A27A4244A8185C0606E2760364EB
	87E895DB4EF0D6936F145CF54B341631D9D97175EA63E0CE8D7162E346647AB3
	B2B4393D7B4257CA98A63AB520A6FA9BFF53F86DEFED871A445EB99101DC53A5
	5AD520A6DAD736FF0798F4792FE9EF259396EE83A5E9E55DFA9E941E3DAB9C5A
	9777E844FC20833B5102F17D48F5B50EBA3A9173A20EF4F0393185DC5AD8E8BA
	C2D4E7FC989B9E5AE6FAE0A24ADC7022B1E81568AD4E257CB84FD4EB0ECD4188
	5039630A23C418DDA1B5122254CE98C20831467768AD84089533A630428CD11D
	5A2B2142E58C298C10637487D64A885039630A23C418DDA1B5122254CE98C208
	3146F762ADE92D2669D30851AAD4A074843848E81ED5E48E5D48EBA113A54A0D
	48673D5F448803E068AA6038D5A8E54C5B3A7516F5771ECF3000BD86B0D683E6
	47BE9F9E2E941CCD388E9B4A139E67537331DCA063681642BC3C9BCC320F8412
	DC2A27C405212A0392267899D36A32329C6E9FBB4888950FD48A0E9BA5FA117B
	B31CF9636A0918117462E2440F808FCDFE609084088098BDEC361024210220A6
	FF70E471B3352F2112E2EFCA6EB62F2E6C16DE275AC359743E8653865386D368
	17F202F8E6C2FD0E85E5CE0137FB012BA17401D65AD8445D79B1BAFA6BE6C4B7
	DB32773152277A5C19057F7988A50B279267F1A450CE9FEFF87D798867E4A613
	5F0A9C42949E631330D589ABE49CB800C494766B61635E60F05694D854EE84BD
	205AE17BF37DCD9C4827329CAA06BBD759DAFCAAC6CDBCB0A113E944D560D73A
	C99B5ED5383AB17ED8FADE576C5E4FEB5F1E62E95309069E97B1B852E6444214
	E94427BA777FF2028AFBC4A59DC885CD024EBC40BCF9146199567E0F7C4DDA31
	D1084BCF554EDA4F111F51A28A0051034105F1753E51FC1946FBFDD7695E138F
	4E423C071A00229D18ED5A00446F38B6E6A713E9C489E6BC96D3E9C405600220
	724E6C39A5F7FB0088D639CD9B8F7322E7C405C22810A2D751D6FCFF010FB35A
	8EA3DDCB790000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="206" length_in_bytes="1459" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E7000000E700194D934C40000000774494D4507DB0B190D0807B0
	89E3B00000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A10000051249444154785EED9DD976DC201044E7FF7F368F
	7E74468AE52099A59782065C3E674EEC0C6B5DAA0181C7AFCFD7EBB5F3EBE8DE
	CEFD3BFAB635C0DDE15DFDDB1E229D48A72E31C89768A4272CD2891B38911017
	86986BBAC7D133E7DD3A9CA6206786E06DDBD610CF3D14F789EBEC232D91DFEB
	8059F22FE7440B2C6D9E59E048DB3135448DF81F1F7F3EB52F4DF9524123D24D
	055122AA169425BDA41D11B04A758643AC096601D02B4FAD9DD14043209604B1
	02903867549D1140874144885875C367FEEBDC6254DEEBD9AE5140BB43CC8924
	755CF6A94B11C9CF376E9B7D63BEAB0C579B3DA14290B72BC467FD12219E7914
	DADF927A07405A18A41F021856E7768398B6B9050F052E07BC164E2D03440BF4
	160D3A81EC02510AD01AEE34E2A321961C5A1BA8BD41C2214A008E80A701ED4D
	ABEE33D8915088ADCEEC06EF095FD57F204818446907BCA37E85FCB5156D8FD0
	0A814880E5ED4D6EAE4483744324C0726C18E54818C4DA885B2104F66AA304A4
	757F08B9775A73E1F55E2F71562AB7041215565D4E6C356E25A17BB7B5A99563
	B56A865872211DA89B23116E74437CCE853D9F90F476CB88F20F7D729A9DBA19
	DD68824817DA71E7C2AAD78D2E8874A10D26DA8D6A8874A10D5CEEC1796A028F
	1BCD10E9421F4CA41B2110B922D503ADCD8DDA058E0A622D94EABBC11C4F375A
	43AA092243296600A242AA1B2243A91D282AA44220DABBC19CA590AA99170931
	781C1162300044F584885031B80C420C0680A89E10112A06978181F83E0079F7
	43F4CA6D2778F4E41B054FFD128D454C0E765C9DFA18B873639CD838884C0F2B
	4B9BD3AB2774A58C69AA530B62AABFF93785BFEDFDFEA606914F6E64008F54A9
	563588A9F6B5CDFF0926FDBC97F4E792494BE760697A79977E4F4A8F9E554EAD
	C73B74227E90C19D2881F87D49F56B1DF47422E7441DE8E173620AB9B5B0D175
	85A9AFF931373DB5CC75E3A24ADC7022B1E81568AD4E257CB84FD4EB0ECD4188
	5039630A23C418DDA1B5122254CE98C20831467768AD84089533A630428CD11D
	5A2B2142E58C298C10637487D64A885039630A23C418DDA1B5122254CE98C208
	3146F762ADE91193B4698428556A503A421C24748F6A72D72EA4F5D08952A506
	A4B3DE2F22C401703455309C6AD472A62DDD3A8BFA7F5ECF30007D86B0D607CD
	8F7C3FBD5D28B99A715E379526BCEEA6E662B841C7D02C84F8F86C32CB3C104A
	F05D39216E0851199034C1CB9C569391E1F4FD771709B1F207B5A2C366A97EC4
	DE2C47FE9C5A0246049D9838D103E0B6D91F0C92100110B38FDD0682244400C4
	F4178E3C6EB6E6254442FCB7B25BED8B0B9B8DF789D670169D8FE194E194E134
	DA857C00FE76E17142613939E0663F6025942EC05A0B9BA8272F5657FF9A39F1
	DB6D99538CD4891E5746C1DF1E62E9C189E4B3785228D7F733FEBB3DC42B72D3
	895F0A5C42943EC72660AA1357C93971038829EDD6C2C6BCC0E05194D854EE84
	BD205AE17BF34D3D27F67A2EDB0B2257A7197FAD06D1EB286BFE299D983D6475
	07D1FF05D089834E316ED71D80008FA27A41B43AC99B6F4A27A67B3B30BFB3B8
	5E10979A13075E1FF10E52557E55E28944303971A2F64375F716B68413BD9D64
	7EDDEFBE48F55239515AE86F4DB7AC13A31AEE19282BB6B9D65FB7139FE76FAB
	FDEC190CCFBC5183C30D1129C22CA2F4EC538FB2A78578DBEC2FB21CA6131350
	D9C76E8B80ECE1B45699D33AF16878D4C86E89567A3FAABD84B881C3A7866875
	44543E3A31E3882851A20681B55E3A11184EA306DDD410A344B13A222ADF5FAE
	55EE9AF9175F680000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="207" length_in_bytes="1470" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000AEC00000AEC01D0CFAB250000000774494D4507DB0B190C3828C5
	DC822D0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A10000051D49444154785EED9DC972DB301044F5FF3F9B63
	8E8EC8980AC86099A58101E076952A7684B51F7AB0D1F2EBEBF57AEDFC3ABAB7
	73FF8EBE6D0D70777857FFB6874827D2A94B0CF2251AE9098B74E2064E24C485
	21E69AEE71F4CC79B70EA729C8992178DBB635C4730FC57DE23AFB484BE4F73A
	6096FCCB39D1024B9B671638D2764C0D5123FEEFDFBFBEB42F4DF9524123D24D
	055122AA169425BDA41D11B04A758643AC096601D02B4FAD9DD14043209604B1
	02903867549D1140874144885875C357FEEBDC6254DEEBD9AE5140BB43CC8924
	755CF6D4A588E4FF376E9B7D63BEAB0C579B3DA14290B72BC467FD12219E7914
	DADF927A07405A18A41F021856E7768398B6B9050F052E07BC164E2D03440BF4
	160D3A81EC02510AD01AEE34E2A321961C5A1BA8BD41C2214A008E80A701ED4D
	ABEE33D8915088ADCEEC06EF095FD57F204818446907BCA37E85FCB5156D8FD0
	0A814880E5ED4D6EAE4483744324C0726C18E54818C4DA885B2104F66AA304A4
	757F0879EEB4E6C2EBBD5EE2AC546E09242AACBA9CD86ADC4A42F76E6B532BC7
	6AD50CB1E4423A50374722DCE886F89C0B7B9E90F476CB88F20F7D729A9DBA19
	DD68824817DA71E7C2AAD78D2E8874A10D26DA8D6A8874A10D5CEEE03C3581C7
	8D668874A10F26D28D10885C91EA81D6E646ED024705B1164AF5DD608EA71BAD
	21D50491A11433005121D50D91A1D40E1415522110EDDD60CE5248D5CC8B8418
	3C8E08311800A27A4244A8185C0621060340544F88081583CBC0407C5F80BCFB
	217AE5B613BC7AF28D82A77E89C62226073BAE4E7D0CDCB9314E6C5C44A69795
	A5CDE9D513BA52C634D5A90531D5DFFC9BC21F7BBFBFA941E4C98D0CE0912AD5
	AA0631D5BEB6F93FC1A49FF792FE5C3269E91E2C4D2FEFD2CF49E9D1B3CAA975
	BC4327E20719DC8912889F8754BFD7414F27724ED4811E3E27A6905B0B1B5D57
	98FA9A1F73D353CB5C372EAAC40D27128B5E81D6EA54C287FB44BDEED01C8408
	9533A630428CD11D5A2B2142E58C298C10637487D64A885039630A23C418DDA1
	B5122254CE98C20831467768AD84089533A630428CD11D5A2B2142E58C298C10
	63742FD69A5E31499B468852A506A523C44142F7A826F7D885B41E3A51AAD480
	74D6E78B0871001C4D150CA71AB59C694B4F9D45FD3F1FCF30007D86B0D607CD
	8F7C3F7DBA50F268C6F9B8A934E1F56C6A2E861B740CCD42888FCF26B3CC03A1
	04DF9513E2861095014913BCCC693519194EDF7F7791102B7F502B3A6C96EA47
	ECCD72E4CFA9256044D08989133D006E9BFDC120091100317BEC361024210220
	A6BF70E471B3352F2112E2DF95DD6A5F5CD86CBC4FB486B3E87C0CA70CA70CA7
	D12EE401F8DB85C70D85E5E6809BFD809550BA006B2D6CA24E5EACAEFE3173E2
	C76D995B8CD4891E5746C1DF1E62E9E044F2593C2994EBFB19FFDD1EE215B9E9
	C46F052E214A9F631330D589ABE49CB801C494766B61635E60F02A4A6C2A77C2
	5E10ADF0BDF9A69E137B9DCBF682C8D569C65FAB41F43ACA9A7F4A27662F59DD
	41F45F0174E2A05B8CDBE30E40804751BD205A9DE4CD37A513D3BD1D98DF595C
	2F884BCF89031F27F10EDA4F7EEFEF3FC01A0210CFE5C41E2E1959E605D2735E
	9AC25CD2892305EF51171A62943BE9C49F7A9F0808E35183B65AEF948D12886D
	72A2A0DC25F5F0367A8939D1DB496DFE2851B4ED8C4EAF72E2C8C6DE36FB8B58
	3F6AD04D09317BECB608C89103FDAA6B4A889FC605DDCF5941D08919A7458962
	8518956F6A27468962AD376AD04D0D314A142BC4A87C53438C12C55A6FD4A09B
	1A629428568851F9FE007EE1D092B121C7620000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="208" length_in_bytes="1586" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E6E00000E6E01794468F00000000774494D4507DB0B190D1B1C5B
	036BCE0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A10000059149444154785EED9D8D72E3200C84F3FE2FDD4B
	73718A09A05F8491F7663A9D9E3131FAB45AC04EF2F8793C1EF8D93B06E901FE
	E668F6244D0F313BC0DFF1A5870825DE007206A542890912151001F1BA9EDA62
	93A174B6C6905A8925C8AC00313B4D504AD341AC9994EA1B1DDB5DA55B96D32F
	20CF3D991FE54F06B8978778F23525280DE09DFCF472105741A3405F19EA7288
	5785B613D425100F7054A0B8C72D934CEE6B50ED3E63B25C8CF2DC7888065F53
	8E5135F9A4A00D8F475E68E45D0C8DFA24B17806B5F9EF751763708CFB1A12A8
	D1AA8C5122537D9C807689340E547ECB3E95791DBC650DA733639BA91039EAA3
	AE9F1DF9AA6173EF54D919E31ABB402354390F22A1BE5E6094711E96CC197D76
	9264AC4E2A1B94C7A7407CFB5073409E0AE1C0197922E77CAA8D04E6EB5A94A0
	46E7B9439400A402B4D3F19A4D6F223403A42B442EC09DE048AFB59A4C75AB91
	A722FD200E3C503B4B9406F02AED39205F4A752AAD2E1D4181DFE9C301E9555A
	CD1001B0AFFF2890668823032FD68957A974E1D7C101692DAB5320DECD03A9CC
	20411ABDD104B1554A01B0BF875B54A6D3ACD5EA8D6A883D2F4409A53DB26541
	16906A88BD0B01441A627732A82CAB5320521E71E7E3BD926A5937AA20C20BF5
	69389AE4684BAA1822BC500FF03873A4460D48314478A11F442F6F7485681FDE
	7D7AF0F44631C4911FDE07817DA49E6B4611444C68ECF06A5FECC554B2152782
	38F243BFE1DDA727AF920A880B736609C45AFAD89DB167400BA4749921522220
	DAA1D53D00A27F4CC37B0C87584F6C504EEDCCBBBE28D80C17955340B443E394
	53E9663809B13459CA13DFC7FD479AACC7324E5439E54C7258108F8E4610515A
	F99956C66A04F1738C28ADCFC3FF1F2D6FFDAECFED95D3D66BF087749F962316
	9CD8763951DB3BA76CA81E10EE64D47DA828474A29F1F044B61239108F36F044
	25B5EAB4704FAC3FD0A7943D7CD00E959AD85022937FA2D4A09CDA8773CF1EB0
	4E4CC03D1C22E58909621A3E84F0720A88FE8CC32162DB2D06A2FBB6DB697684
	898D3B4578A27B48E33B0C2FA7F0447FC8E110E1893110E189FE719EDA233C71
	6A78633A0F2FA7F0447FB0E110E1893110E189FE7166F758DE62E29E044FE446
	2AA89D17C4E3290BCE6D28F1AD2878623B1B2C8FA7C0138314C679991224A7FD
	D126BC9C626233C6E3554EA74E6CB294D356F95BFD7FA540E0898C5AB61A58C7
	433F9F323515629672DAF521E6B706D47198F2B720D3C827C033DE4FBC35C46C
	9E3845410E6A9E5A4E33433CC656AB74D9DF28A7F452A095905F3B2494AAAA40
	4B15C4DD91A1DAC1134B5075F60B209E16FB0215518038C7BF21129FAA5FAF67
	340B5CC62A606A13D12E492B1E0D057EF10F0409886F48DD52C880787AC35120
	BCCFEB8A7DA0185491D15395E3DD794B8980E81DE5C9FD7997D3AD94987989D1
	DD74169453CE2464461B7822E589028FBBCE12839A56DFCD13051067A88CD3A7
	4889E937C08DC0B650E2CE9E58AE67A989CD2A181CD5B5DA8894B83BC403E468
	89F139A650E52AF8BC6FA8EEF8E40EEBC4118BD6EE536FE7E50074C5DFE92136
	1E48FA54A4AF5B514F42E995B87B39259F307B7FBBE8AAB2A8F744E19222EB06
	F82741155EB87EC7460031F312C303A25649D6F36EE389E5766C778961FCB2E6
	5565580471674F8C80685594F67C404CB1770A4F7C25F2AA52A855DFE98313D9
	9D3460EFB0D86FDD9A1C7AA2C117572502FF41A9235B93DEC538CDBC0DCB0CB6
	281C5F03104B4F3C125419E02D94788B75A2A19CAE50A1EC9DC2F044B26A6DA1
	C4DE3A51597D56256E7303FC34B6CD0644665731E2BF1DFEC247361BEF29710E
	7BF89AAD2A07B58512AFFA2E22F7EB52425C555A444A740F9661A3C1F55A9CA0
	41892B813A41BCBE12CB81AE0CF88CD77682787D250222DF7A9C9282AB6CDD85
	CD50C3CA3E9D820E252680C8558E773B28D1719B0D4A841275827A66CE3FABF0
	9F14899EFA140000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="209" length_in_bytes="1657" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E6F00000E6F01AB038A140000000774494D4507DB0B190D1B1C5B
	036BCE0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A1000005D849444154785EED9D8B72E3200C45F3FF3FDD4D
	53DB8B09424F04C8DA994EA70BC6A0C3D505ECA6AF9FD7EB955F7BC7203CC0DF
	391A7D928687181DE0EFF8C2434C253E007204A5A612034CD4849810D7F5D416
	9B08A9B33586D04A2C41460598ABD300A9341CC49A49A9BE5ED9EE2ADD329D7E
	01799FC9FC08BF22C05D1EE2CDD784A0248077F2D3E520CE8286815E19EA7488
	AB42DB09EA148827382C50D472CD22937A0FACDE35264D6784D7FA4354F89A70
	8CA2C52706AD5BEED951CFA71812F57162F10E6AF3DFE72946A78C7A0F0E546F
	55FA2891A83E4A4041228D82CA6FC99712FB41DBD6501A53D6190A91A23EACFF
	E4C857159B67A7C2C6087D04817AA8721C44447D50608471EEA6CC116D0293A4
	AF4E6C3608CB87403C7CA839204B8550E0F43C91723D568703F3D31721A8DE75
	E6103900B100ED545EB381164223409A42A402DC090EB7AFD5620ACC46968AB4
	83D8F140E92A911BC055EA53407E946A945A4D1A4A057E4F1F0A48ABD4AA8698
	0061FD7B815443EC1978B14F5C25D3B9F78302529B5687407C9A0762330305A9
	F44615C4562A4D80F0196E91996EAB56AD378A21425E982914F7C8960569408A
	21421D498838447031284CAB4320621EF1E47228A56AF68D2288E985F269D85B
	E448532A1B627AA11CE079654F8D12906C88E9857610ADBCD114A27E78CF69C1
	D21BD9107B7EF81C04FA915AEE1959107341A38757FB221453CE511C0B62CF0F
	ED86F79C96AC526A429C3867A640ACA59FA733FA19D002C9DD66B0949810F5D0
	EA1612A27D4CDD5B7487582F6C329DEA9983BEC8380C67A5D384A8874649A7DC
	C370146269B298271EE5F6230DD66219272C9D521639248867433D88995AE933
	AD8C550FE25586A4D677F1DFABE5ADEFF5B5503A6DDD833EA4E7D4ECB1A0C416
	E4841DEFDC6643F5823030A39E434538524C89A7279295488178D6494F1452AB
	2E73F7C4FA037D4AD9A70FEAA1620B1B4C64FC4F94EAA453FD709ED942EE1303
	7077878879628098BA0FC13D9D26447BC6EE10F3D8CD07A2F9B1DB6D75940B1B
	738AE989E621F56FD03D9DA627DA437687989EE803313DD13ECE435B4C4F1C1A
	5E9FC6DDD3697AA23D587788E9893E10D313EDE34C6EB17CC444BD283D911A29
	A77A5610CFB72C288FA1D88FA2D213DBB341F37A4A7AA293C228B7294152EA9F
	75DCD3692E6CFA78ACD2E9D0854D9474DA4A7FB3FFAF14487A222197CD060678
	E8F5295343214649A7A00F11FF6A401D87213F33661AFA0678C4E7898F8618CD
	138728C840CD43D3696488E7D86A954EFB39D329BE15684DC8AF13124C5555A0
	B90AA29EC860F5D2134B50F5EC6740BC6DF6192AC20051CABF21229FAA5FEF67
	241B5CC22E606815D629492B1E0D057EF1770499100F48602A2440BCFDC29123
	BCEBBE6C1F280655CCE8A1CAB16EBCA5C484681DE5C1ED59A7D3AD9418798B01
	1E3A33D229651132A24E7A22E6890C8F5B678B812DAB9FE6890C882354466993
	A5C4F007E04A605B2871674F2CF7B3D8C266160C8AEA5A75584ADC1DE209B2B7
	C5B8CA04AA9C059FF617AA019FDC619FD863D13A7D824E5E4E402B7E0F0FB1F1
	42D29591BE1E45BD098557E2EEE9147DC3ECF8EBA2B3D2A2DC13995B8AA807E0
	D7041578E1FC131B06C4C85B0C0B88522569AF5BDA13CB6D81E5712AB8C550FE
	B1E659699805D1DB137783A85594F4FA2521B66C69B4122D5464D18604240BA2
	A72796202D01FEB6D5DBEC4B8238FB9AA5DFB1714FA78A95E9E757CC8E0F00F6
	864A87F8F7F9C49FFE9D8A548ED97BAC8D97187E3E9948B3C19F3E88ABF7141A
	8DAD4801D53AE30D6D0F5C9D52E2D0A9B385123D3D7124C5511067A992954E13
	E2E127801AB756A2320BCD9AC097B75F9373D381982871D3B19B43DC5289C586
	8BB6DF64D26607053A0766DE775A6A10F653A5C491106F9B7DEAE02643644F3A
	EAB8907A4B426CF599A48EC910497D340257DE8B0EB17773EAE32CE600D8337B
	3244767F99F180264942340AE42C15FE3F6FD20E649012D9814925F637B2DD80
	0E82C84E4F9321B2279D563CC7F54BA75376502643644FBA27406407653244F6
	A43382F80F9809672246F8E2F50000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="210" length_in_bytes="1645" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000710000
	00710806000000E27E4CD00000000467414D410000B18F0BFC61050000000970
	48597300000E6D00000E6D01D4FD499D0000000774494D4507DB0B190D1B1C5B
	036BCE0000001A74455874536F667477617265005061696E742E4E4554207633
	2E352E313030F472A1000005CC49444154785EED9D8B72E3200C45F3FF3F9D4D
	DCD88B31424FC44B3BD369BBC6D8E8E8EA027193D7FBFD7EC5D7DC3178BD5FAF
	A5BFBEC35B7E8CAB0F7087F12DADC22FC050E2E2A576159586121748D4801810
	C79DD996D8AC523EF3712CADC414E4AA008FC9DBCA838BD9E98480F35B4E13B4
	766CF6449E52890F208AADC315E00E0FF1E66B0A58DCFDE199FC743888BDA061
	904786DA1DE2A8D06682DA05E2090E0B14F5B8660E46BD06D6EE1A93E66684E7
	FA4354F89A708CA2C92706AD7ADCF3463DD78912F57162F1096AF1DFF12A46E5
	18F51A1CA8DEAAF45122517D948082440A0732BF259F4ABC0FDA131194CE946D
	9A42A4A80FBB7F72E4B386A57E2DFBA24EC83C54D90E22A23E089E34D092722A
	BD56E5DEEBEAC4325678BC09C49F0F150764A9100A849A2752CEC7DA00E301C7
	2E9A652170CD21720062019AE9781E67682274C447A838E83C5388548033C1E1
	DE2BC52BAD41DA41AC78A07496C80DE028ED29200FA51A29D2A4A350E0337D28
	20AD14A986180061FD7B815443AC1978B24E1CA5D2B9DF0705A4B6AC3681B89B
	0762998182547AA30A62A9940640780F37A94CB775A4D61BC510212F8C128A7B
	64C9823420C510A11B098838447032282CAB4D20621EB1F371A8A46AD68D2288
	E185F234AC4D72A425950D31BC500EF03CB3A646094836C4F0423B8856DE680A
	513FBC7D7AB0F44636C49A1FEE83403F52CB35230B624C68F4F0725F8462CAD9
	8A6341ACF9A1DDF0F6E9C9AAA406C48E39D305622EFDD89DD1674009247799C1
	526240D443CB7B7087987B6228510F152CA98C7D54961203A21E1A4589DC7DD4
	8068CF85D5A38B125393C53CF1779C35881D1BA771C23C9132C94195785DE4F3
	430D62F8233D1DD358D520A6B1AF2DFEFFC09C80B2EFB9B7429E58F260FA90F6
	69599BAB50620B72C2B6776ED9903D200C64D43E548423C594784E6CC84AA440
	3CDB84270AA965A7B97B62FE863EA9ECC307F550B1890D2632FEDB8255CAA97E
	387BF6E0B2C4B865424034CF34778898279A8F70830EDDCB6940B4CF2A7788B1
	77EA0331F64EEDE3DCB4C7F0C4A6E1F5E9DCBD9C8627DA837587189EE803313C
	D13ECE4D7B0C4F6C1A5E9FCEDDCB6978A23D587788E1893E10C313EDE34CEE31
	7D89897A52782235524EEDAC209E4F5B505E8662BF14159E58CE06CDE329E189
	4E0AA35C260549697FB6712FA731B1A9E3B12AA74D2736AB94D352F9EBFD7FA9
	40C21309B5AC3730C043AF77996A0A7195720AFA10F15303F23834F99D9169E8
	13E02B3E63B335C4D53CB189820CD4DCB49CAE0CF11C5BAED26EBF4739C59702
	A5847CEC9060AACA02CD55107547066B179E9882CAB39F01F1B6D867A8080344
	39FE8488BCAB7EBE9E912C7009AB80A64D58BB24A5781414F8E0EF083220FE20
	81A59000F1F607478EF0AEEBB27D20195492D14D9563DD79498901D13ACA8DFB
	B32EA7532971E52506B8E9CC28A79449488B36E1899827323C6E9C250636ADDE
	CD1319105BA88CD2274B89CB6F802B814DA1C4993D315DCF62139B5E3028AA2B
	B5612971768827C8DA12E33A2650652FF8B44FA8067C728675628D4569F709DA
	7939018DF87D7988850792AE8AF47829EA43687925CE5E4ED127CC7E9F2EDAAB
	2CCA3D91B9A4587503FC4A508117F6DFB161405C7989610151AA24ED79437B62
	BA2CB0DC4E059718CA0F6BEE55865910BD3D7136885A4549CF1F1262C9965A2B
	D14245167D4840B2207A7A620AD212E0B7AFDA625F12C4DEE70CFD8C8D7B3955
	CC4C8F3F31FBBD01B037543AC4BFF7273E12F9FC528ED97BAC858718FE8F85FB
	472CDD6F3E097E405CF2F544485E8AF5E4A84F5AE75565247571EE85A5C41960
	A8EE51E90F537AA22A60232A5B0991A31ECBB62C25A6139B7C9A3EF3EFD7BD2B
	214EA1C4D24B3747465155C50C123B28D07D30AF6BA9128FBE584AF484785BEC
	53217486C84E3AEAB8907643422CDD3329A33B4324DDA311B8F45A7488B58B47
	393DE238BE1203A24DC2EFA6447679EA5C4E4389850C6507A5334476D219A9D2
	A64434F24476503A436427DD0E10D941E90C919D744610FF01C2DC0493C94A71
	9A0000000049454E44AE426082
	]]>
</GDLPict>

<Copyright SectVersion="1" SectionFlags="0" SubIdent="0">
	<Author>GRAPHISOFT</Author>
	<License>
		<Type>CC BY-ND</Type>
		<Version>3.0</Version>
	</License>
</Copyright>

</Symbol>
