<?xml version="1.0" encoding="UTF-8"?>
<Symbol IsArchivable="false" IsPlaceable="false" MainGUID="FABE39FA-D652-4925-A307-B86F0B7D3D00" MigrationValue="Normal" Owner="0" Signature="1465080141" Version="38">
<Ancestry SectVersion="1" SectionFlags="0" SubIdent="0" Template="false">
	<MainGUID>F938E33A-329D-4A36-BE3E-85E126820996</MainGUID>
	<MainGUID>103E8D2C-8230-42E1-9597-46F84CCE28C0</MainGUID>
	<MainGUID>6ACDA889-69B2-4EC5-936C-CB1DA7032A92</MainGUID>
	<MainGUID>F6AE9687-2BC7-4D47-88C9-8F793E1DE2D6</MainGUID>
	<MainGUID>4ABD0A6E-634B-4931-B3AA-9BEE01F35CDF</MainGUID>
</Ancestry>

<CalledMacros SectVersion="2" SectionFlags="0" SubIdent="0">
	<Macro>
		<MName><![CDATA["SaveQueue"]]></MName>
		<MainGUID>94152DAD-3888-4DAC-AC2E-EB7988A1C356</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["terrace_PolygonOperations"]]></MName>
		<MainGUID>B68AEDAB-3C76-4FCB-BECB-CE5123363320</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["LoadQueue"]]></MName>
		<MainGUID>76C49CD5-2439-4953-8829-5B7914C1A082</MainGUID>
	</Macro>
</CalledMacros>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_3D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_3D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_2D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! Contact person: <NJ>

! ==============================================================================
! This macro draws the cavity closure and turned plasters
! ------------------------------------------------------------------------------
! Input parameters:
!	refWidth:				reference width in curved walls (length)
!	leftWidth:				wallhole's side distance from the origin at the left side (length)
!	rightWidth:				wallhole's side distance from the origin at the right side (length)
!	bWndCurved:				is the window made of curved panels (0 / 1)
!	bParalellInCurvedWalls:	is the wallhole parallel in curved walls (0 / 1)
!	bDrawObjContourIn:
!	bDrawObjContourOut:
!	bDrawFrameContourLeft:	Draw the wall contour border on window frame at the left side (0 / 1)
!	bDrawFrameContourRight:	Draw the wall contour border on window frame at the left side (0 / 1)
!	bWindowSymbolAtMiddle:	Is the window symbol appears always on the middle of the wall (CHI special) (0 / 1)
! Corner Window Parameters -----------------------------------------------------
!	bCornerWindow:			is the hole a corner window? (0 / 1)
!	ac_corner_angle:		angle between connected walls in case of Corner Window (angle)
!	ac_diff_con_wall_thk:	indicates the equality thickness of the two connected walls (0 / 1)
!	ac_con_wall_thk:		thickness of the connected wall in case of Corner Window (length)
! Wallhole Cover Fill Parameter (only for polygon walls ) ----------------------
!	fillWallHole:			wallhole cover fill (only for polygon walls) (fill)
!	penWallHoleFg:			wallhole cover fill pen (only for polygon walls) (pen)
!	penWallHoleBg:			wallhole cover fill background pen (only for polygon walls) (pen)
!	penWallContour:			wallhole contour pen (only for polygon walls) (pen)
!	iWallContourLine		Identifies the wall cotours to be drawn
!								(integer; 1 = none, 2 = inside, 3 = outside, 4 = both)
!	gs_wcont_line_in:		type of the wall contour line inside (line type)
!	gs_wcont_line_out:		type of the wall contour line outside (line type)
! Oversize Parameters ----------------------------------------------------------
!	gs_left_oversize:		Left opening oversize (only for polygon walls) (length)
!	gs_right_oversize:		Right opening oversize (only for polygon walls) (length)
! Reveal Parameters ------------------------------------------------------------
!	iRevealType:			reveal type (integer)
!								0 = no Reveal
!								1 = Positive Reveal
!								2 = Negative Reveal
!								3 = Slanted Reveal
!								4 =
!	gs_reveal_left:			left reveal size (length)
!	gs_reveal_right:		left reveal size (length)
!	gs_reveal_left_angle:	left reveal angle in case of slanted reveal (angle)
!	gs_reveal_right_angle:	right reveal angle in case of slanted reveal (angle)
! Stacked Window Parameters ----------------------------------------------------
!	gs_stack_left:			align to door/window on left side (0 / 1)
!	gs_stack_right:			align to door/window on right side (0 / 1)
! Cavity Closure Parameters ----------------------------------------------------
!	gs_useWallFinishSkin:	use wall finish component (0 / 1)
!	gs_maxPlasterThk:		wall skin classification parameter (length)
!							consider Skin as Plaster if it is thinner this
!	gs_bAutoTurnIn:			automatic plaster return at Outside Face (0 / 1)
!	gs_bAutoTurnOut:		automatic plaster return at Inside Face (0 / 1)
!	gs_bOverIn:				number of turned plaster skins at Outside Face (integer)
!	gs_bOverOut:			number of turned plaster skins at Inside Face (integer)
!	gs_closureMethod:		controls the method being used for internal cavity closure
!	bCavityCloserLeft:		show cavity closure at left side
!	bCavityCloserRight:		show cavity closure at right side
!	gs_nTurn:				number of turned skins in traditional mode (integer value)
!	gs_bJoint:				is there an insulation strip at the front
!							 side of the turned skins (0 / 1) [MODE1]
!	gs_thkJoint:			strip thickness (length)
!	gs_penJoint:			strip contour pen (pen)
!	gs_ltJoint:				strip contour linetype (line type)
!	gs_fillJoint:			strip fill type (fill)
!	gs_penJointFg:			strip fill pen (pen)
!	gs_penJointBg:			strip fill background pen (pen)
!	gs_widthPlug:			heat insulation profile width (length) [MODE2]
!	gs_penPlug:				profile contour pen (pen)
!	gs_ltPlug:				profile contour linetype (line type)
!	gs_fillPlug:			profile fill type (fill)
!	gs_penPlugFg:			profile fill pen (pen)
!	gs_penPlugBg:			profile fill background pen (pen)
! ==============================================================================

slantLength = 0

if GLOB_CONTEXT = 6 | GLOB_CONTEXT = 46 then end	! List
if GLOB_CONTEXT = 5 then	! Object Settings Dialog
	bDrawObjContourIn	= 0
	bDrawObjContourOut	= 0
	bSettingsDialog		= 1
else
	bSettingsDialog		= 0
endif


! === save the current parameter buffer
dim savedQueueValues[]
call "SaveQueue" parameters returned_parameters savedQueueValues


! ==============================================================================
! Cut Wallhole with WALLHOLE2
! ==============================================================================

if WIDO_REVEAL_SIDE then
	mul2 1,-1
	add2 0,WIDO_FRAME_THICKNESS
endif

! ==============================================================================

! wallThkRefSide:	Wall side distance from the origo at the Outside Face
! wallThkOppSide:	Wall side distance from the origo at the Inside Face

if AC_WallType = 2 then		! Polygon Wall
	if WIDO_REVEAL_SIDE then
		wallThkRefSide	= max(0, -boundMinY) + 0.05
		wallThkOppSide	= max(0,  boundMaxY) + 0.05
	else
		wallThkRefSide	= max(0,  boundMaxY) + 0.05
		wallThkOppSide	= max(0, -boundMinY) + 0.05
	endif
else
	wallThkRefSide	= max(0, WIDO_SILL, bulgeHeightRefSide) + 0.2
	wallThkOppSide	= max(0, WALL_THICKNESS - WIDO_SILL, bulgeHeightOppSide) + 0.2
endif


! ==============================================================================
! Wallhole Polygon - No Reveal
!	for all wall types
! ==============================================================================

if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then

	! Curved Walls
	if not(bParalellInCurvedWalls) then
		dxOLeft	 =  iArchSign * wallThkOppSide * tan(leftAlfa)
		dxORight =  iArchSign * wallThkOppSide * tan(rightAlfa)
		dxRLeft	 = -iArchSign * wallThkRefSide * tan(leftAlfa)
		dxRRight = -iArchSign * wallThkRefSide * tan(rightAlfa)
	endif

	! Trapezoid Walls
	wallThkOppSide = wallThkOppSide + max(leftWidth, rightWidth) * tan(abs(WALL_INCL))

	if curvedWall then
		dxLeft		= bArchSign * WIDO_FRAME_THICKNESS * tan(leftAlfa)
		dxRight		= bArchSign * WIDO_FRAME_THICKNESS * tan(rightAlfa)
	else
		dxLeft 		= 0
		dxRight		= bCornerWindow * 2.0		! 2.0 m is large enought
	endif

	put	-leftWidth  - dxLeft  + dxOLeft,	-wallThkOppSide,	1,
		-leftWidth  - dxLeft  + dxRLeft,	 wallThkRefSide,	1,
		 rightWidth + dxRight - dxRRight,	 wallThkRefSide,	1,
		 rightWidth + dxRight - dxORight,	-wallThkOppSide,	1

	if curvedWall & bWndCurved then
		sxL = -rSillLine * sin(leftAlfa)
		syL = iArchSign * (-abs(WOD) + rSillLine * cos(leftAlfa))
	else
		sxL = -leftWidth - dxLeft
		syL = 0
	endif
	bxL = sxL
	byL = syL

	if curvedWall & bWndCurved then
		sxR = rSillLine * sin(rightAlfa)
		syR = iArchSign * (-abs(WOD) + rSillLine * cos(rightAlfa))
	else
		sxR = rightWidth + dxRight
		syR = 0
	endif
	bxR = sxR
	byR = syR
endif


! ==============================================================================
! Wallhole Polygon - Positive Reveal, Negative Reveal, Slanted Reveal
!	for all wall types
! ==============================================================================

if iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE | iRevealType = REVEAL_SLANTED then

	if iRevealType = REVEAL_POSITIVE then		! Positive Reveal
		if SYMB_ROTANGLE > EPS exor SYMB_MIRRORED then
			leftJamb	= WIDO_RIGHT_JAMB
			rightJamb	= WIDO_LEFT_JAMB
		else
			leftJamb	= WIDO_LEFT_JAMB
			rightJamb	= WIDO_RIGHT_JAMB
		endif
		leftJamb	= gs_reveal_left
		rightJamb	= gs_reveal_right

		! Trapezoid Walls
		wallThkOppSide = wallThkOppSide + max(leftWidth, rightWidth) * tan(abs(WALL_INCL))
	endif
	if iRevealType = REVEAL_NEGATIVE then
		leftJamb	= -gs_reveal_left
		rightJamb	= -gs_reveal_right

		! Trapezoid Walls
		wallThkOppSide = wallThkOppSide + max(leftWidth, rightWidth) * tan(abs(WALL_INCL))
	endif
	if iRevealType = REVEAL_SLANTED then
		leftJamb	= gs_reveal_left
		rightJamb	= gs_reveal_right
		leftAngle	= gs_reveal_left_angle
		rightAngle	= gs_reveal_right_angle
	endif

	if gs_stack_left then
		leftJamb	= 0
		leftAngle	= -signWallIsLeft * leftAlfa
	endif
	if gs_stack_right then
		rightJamb	= 0
		rightAngle	= -signWallIsLeft * rightAlfa
	endif

	alfaLeftJamb	= leftJamb  * ArcLengthSillToAngle
	alfaRightJamb	= rightJamb * ArcLengthSillToAngle

	if not(bParalellInCurvedWalls) then
		dxOLeft	 =  iArchSign * wallThkOppSide * tan(leftAlfa)
		dxORight =  iArchSign * wallThkOppSide * tan(rightAlfa)
		dxRLeft	 = -iArchSign * wallThkRefSide * tan(leftAlfa  - alfaLeftJamb)
		dxRRight = -iArchSign * wallThkRefSide * tan(rightAlfa - alfaRightJamb)
	endif

	if iRevealType = REVEAL_SLANTED then
		dxOLeft		= -wallThkOppSide * tan(leftAngle)
		dxORight	= -wallThkOppSide * tan(rightAngle)

		! Curved Walls
		if curvedWall then

			dyR = iArchSign * (-abs(WOD) + rSillLine * cos(rightAlfa))
			dxR = rightWidth - rSillLine * sin(rightAlfa)

			dyL = iArchSign * (-abs(WOD) + rSillLine * cos(leftAlfa))
			dxL = leftWidth - rSillLine * sin(leftAlfa)

			if bArchSign then
				xo = 0
				yo = -WOD
				ro = rBoard

				if bWndCurved then
					x1 = -rSillLine * sin(leftAlfa)
					y1 = iArchSign * (-abs(WOD) + rSillLine * cos(leftAlfa))
					x2 = x1 + sin(leftAngle)
					y2 = y1 + cos(leftAngle)
				else
					x1 = -leftWidth
					y1 = 0
					x2 = -leftWidth + dxOLeft
					y2 = -wallThkOppSide
				endif

				gosub 101	! Circle - Line intersection

				if state = 0 then
					hitYLeft = -WOD
				endif
				if state = 1 then
					hitYLeft = ya
				endif
				if state = 2 then
					hitYLeft = max(ya, yb)
				endif

				xo = 0
				yo = -WOD
				ro = rBoard

				if bWndCurved then
					x1 = rSillLine * sin(rightAlfa)
					y1 = iArchSign * (-abs(WOD) + rSillLine * cos(rightAlfa))
					x2 = x1 - sin(rightAngle)
					y2 = y1 + cos(rightAngle)
				else
					x1 = rightWidth
					y1 = 0
					x2 = rightWidth - dxORight
					y2 = -wallThkOppSide
				endif

				gosub 101	! Circle - Line intersection

				if state = 0 then
					hitYRight = -WOD
				endif
				if state = 1 then
					hitYRight = ya
				endif
				if state = 2 then
					hitYRight = max(ya, yb)
				endif

				wallThkOppSide	= -min(hitYLeft, hitYRight)
			endif

			if bWndCurved then
				dxOLeft		= (-wallThkOppSide - dyL) * tan(leftAngle)  + dxL
				dxORight	= (-wallThkOppSide - dyR) * tan(rightAngle) + dxR
			else
				dxOLeft		= (-wallThkOppSide) * tan(leftAngle)
				dxORight	= (-wallThkOppSide) * tan(rightAngle)
			endif
		endif

		! Trapezoid Walls
		if abs(WALL_INCL) > EPS then

			x11 = 0
			y11 = WIDO_SILL - WALL_THICKNESS
			x12 = 1
			y12 = y11 - iInclDir * tan(WALL_INCL)

			x21 = -leftWidth
			y21 = 0
			x22 = -leftWidth + dxOLeft
			y22 = -wallThkOppSide

			gosub 100		! Line - Line intersection

			if state = 1 then
				hitYLeft = cy
			endif

			x11 = 0
			y11 = WIDO_SILL - WALL_THICKNESS
			x12 = 1
			y12 = y11 - iInclDir * tan(WALL_INCL)

			x21 = rightWidth
			y21 = 0
			x22 = rightWidth - dxORight
			y22 = -wallThkOppSide

			gosub 100		! Line - Line intersection

			if state = 1 then
				hitYRight = cy
			endif

			wallThkOppSide	= -min(hitYLeft, hitYRight)
			dxOLeft			= -wallThkOppSide * tan(leftAngle)
			dxORight		= -wallThkOppSide * tan(rightAngle)
		endif
	endif

	if curvedWall then
		! Jamb arch length projection onto the X axis
		if bParalellInCurvedWalls then
			dxLeftJamb	= leftWidth  - rSillLine * sin(leftAlfa  - alfaLeftJamb)
			dxRightJamb	= rightWidth - rSillLine * sin(rightAlfa - alfaRightJamb)
		else
			dxLeftJamb	= leftWidth  - iArchSign * WOD * tan(leftAlfa  - alfaLeftJamb)
			dxRightJamb	= rightWidth - iArchSign * WOD * tan(rightAlfa - alfaRightJamb)
		endif
		dxLeft		= bArchSign * (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS * tan(leftAlfa)
		dxRight		= bArchSign * (iRevealType <> REVEAL_SLANTED) * WIDO_FRAME_THICKNESS * tan(rightAlfa)
	else
		dxLeftJamb	= leftJamb
		dxRightJamb	= rightJamb - bCornerWindow * 2.0		! 2.0 m is large enought
		dxLeft 		= 0
		dxRight		= bCornerWindow * 2.0					! 2.0 m is large enought
	endif

	rSillLine = rSill - iArchSign * WIDO_SILL	! Radius of the reveal at the Sill depth

	if curvedWall & bWndCurved then
		put	 0,										 WIDO_ORIG_DIST,	901,
			-leftWidth - dxLeft + dxOLeft,			-wallThkOppSide,	1

		if iRevealType = REVEAL_SLANTED & not(bWndCurved) then
			put -leftWidth - dxLeft,				 0,					1
		else
			put -rSillLine * sin(leftAlfa),					iArchSign * (-abs(WOD) + rSillLine * cos(leftAlfa)),					1
		endif
		put	-rSillLine * sin(leftAlfa  - alfaLeftJamb),		iArchSign * (-abs(WOD) + rSillLine * cos(leftAlfa  - alfaLeftJamb)),	1,
			-leftWidth  + dxLeftJamb  + dxRLeft,	 wallThkRefSide,	1,
			 rightWidth - dxRightJamb - dxRRight,	 wallThkRefSide,	1,
			 rSillLine * sin(rightAlfa  - alfaRightJamb),	iArchSign * (-abs(WOD) + rSillLine * cos(rightAlfa  - alfaRightJamb)),	1
		if iRevealType = REVEAL_SLANTED & not(bWndCurved) then
			put rightWidth + dxRight,				 0,					1
		else
			put rSillLine * sin(rightAlfa),					iArchSign * (-abs(WOD) + rSillLine * cos(rightAlfa)),					1
		endif
		put	 rightWidth + dxRight - dxORight,		-wallThkOppSide,	1

		sxL = -rSillLine * sin(leftAlfa  - alfaLeftJamb)
		syL = iArchSign * (-abs(WOD) + rSillLine * cos(leftAlfa  - alfaLeftJamb))
		if iRevealType = REVEAL_SLANTED & not(bWndCurved) then
			bxL = -leftWidth - dxLeft
			byL = 0
		else
			bxL = -rSillLine * sin(leftAlfa)
			byL = iArchSign * (-abs(WOD) + rSillLine * cos(leftAlfa))
		endif

		sxR = rSillLine * sin(rightAlfa  - alfaRightJamb)
		syR = iArchSign * (-abs(WOD) + rSillLine * cos(rightAlfa  - alfaRightJamb))
		if iRevealType = REVEAL_SLANTED & not(bWndCurved) then
			bxR = rightWidth + dxRight
			byR = 0
		else
			bxR = rSillLine * sin(rightAlfa)
			byR = iArchSign * (-abs(WOD) + rSillLine * cos(rightAlfa))
		endif
	else
		put	-leftWidth - dxLeft + dxOLeft,			-wallThkOppSide,	1,
			-leftWidth - dxLeft,					 0,					1,
			-leftWidth  + dxLeftJamb,				 0,					1,
			-leftWidth  + dxLeftJamb  + dxRLeft,	 wallThkRefSide,	1,
			 rightWidth - dxRightJamb - dxRRight,	 wallThkRefSide,	1,
			 rightWidth - dxRightJamb,				 0,					1,
			 rightWidth + dxRight,					 0,					1,
			 rightWidth + dxRight - dxORight,		-wallThkOppSide,	1

		sxL = -leftWidth  + dxLeftJamb
		syL = 0
		bxL = -leftWidth - dxLeft
		byL = 0

		sxR = rightWidth - dxRightJamb
		syR = 0
		bxR = rightWidth + dxRight
		byR = 0
	endif
else
	! no reveal
	alfaLeftJamb	= 0
	alfaRightJamb	= 0
endif

if GLOB_CONTEXT = 5 then
	poly2_b nsp/3, 2+4+64, 0,-1, get(nsp)
else
	wallhole2 nsp/3, 2, 0,-1, 0, 0, 0, get(nsp)
endif


! ==============================================================================
! Wall Contour Lines and Background Fill - Polygonal Walls
! ==============================================================================

! Defines of PolygonOperations macro ===========================================

OPERATION_CONVERT_POLYGON_AC_TO_GDL		= 1
OPERATION_POINT_INSIDE_POLYGON			= 2
OPERATION_LINE_LINE_INTERSECTION		= 3
OPERATION_SEGMENT_SEGMENT_INTERSECTION	= 4
OPERATION_INTERSECT_POLYGONS			= 5
OPERATION_CALCULATE_POLYGON_AREA		= 6
OPERATION_REVERSE_POLYGON				= 7

INPUT_NO			 = 0
INPUT_FROM_PARAMETER = 1
INPUT_FROM_GDL_STACK = 2

OUTPUT_TO_PARAMETER = 1
OUTPUT_TO_GDL_STACK = 2


if WIDO_REVEAL_SIDE then
	trAddY = -WIDO_FRAME_THICKNESS
	trMulY = -1
	sillDepth = abs(boundMinY - 1)
else
	trAddY =  0
	trMulY =  1
	sillDepth = boundMaxY + 1
endif

if AC_WallType = 2 & not(bSettingsDialog) then

	del top

	leftW	 = leftWidth
	rightW	 = rightWidth
	bContour = 1
	gosub 5000	! Get Wallhole Polygon

! Display cutting polygon ----- [
!dim ddd[][3]
!numPoints = nsp/3
!for ii=1 to numPoints
!	ddd[ii][1] = get(1)
!	ddd[ii][2] = get(1)
!	ddd[ii][3] = get(1)
!next ii
!for ii=1 to vardim1(ddd)
!	put ddd[ii][1], ddd[ii][2], 1
!next ii
!pen 20
!line_type 1
!line_property LINE_PROPERTY_CONTOUR
!poly2_b nsp/3, 1+4, penWallHoleFg, penWallHoleBg, get(nsp)
!for ii=1 to vardim1(ddd)
!	put ddd[ii][1], ddd[ii][2], ddd[ii][3]
!next ii
! ] ----- Display cutting polygon

	call "terrace_PolygonOperations",
		parameters	opcode 		= OPERATION_INTERSECT_POLYGONS,
					opmethod	= 3,
					edgeAttribute = 33,
					srcPolygon1	= INPUT_FROM_PARAMETER,
					polygon1	= AC_WallContourPolygon,
					srcPolygon2	= INPUT_FROM_GDL_STACK,
					result		= OUTPUT_TO_GDL_STACK

	pen WALL_SECT_PEN
	line_type WALL_LINETYPE
	line_property LINE_PROPERTY_CONTOUR

	if AC_Hole_Display_Option = 5 then		! 5 = Overhead All
		poly2_b nsp/3, 1+4, penWallHoleFg, penWallHoleBg, use(nsp)		! Wall Contour
	else
		if not(gs_stack_left) then
			if gs_left_oversize < EPS then
				line2 bxL,byL + trAddY, bxL - (iRevealType = REVEAL_SLANTED) * WIDO_FRAME_THICKNESS * tan(gs_reveal_left_angle),-trMulY * WIDO_FRAME_THICKNESS + trAddY
			endif
			if iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_SLANTED then
				if abs(bxL - sxL) > gs_left_oversize then
					line2 bxL,byL + trAddY, sxL,syL + trAddY
				endif
			endif
		endif

		if not(gs_stack_right) then
			if gs_right_oversize < EPS then
				line2 bxR,byR + trAddY, bxR + (iRevealType = REVEAL_SLANTED) * WIDO_FRAME_THICKNESS * tan(gs_reveal_right_angle),-trMulY * WIDO_FRAME_THICKNESS + trAddY
			endif
			if iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_SLANTED then
				if abs(bxR - sxR) > gs_right_oversize then
					line2 bxR,byR + trAddY, sxR,syR + trAddY
				endif
			endif
		endif
	endif

	numPoints = nsp/3
	for ii=1 to numPoints
		if ii = 1 then
			x1 = get(1)
			y1 = get(1)
			s1 = get(1)
			firstX = x1
			firstY = y1
			firstS = s1
		endif
		if ii = numPoints then
			x2 = firstX
			y2 = firstY
			s2 = firstS
		else
			x2 = get(1)
			y2 = get(1)
			s2 = get(1)
		endif

		if bittest(s1, 0) then
			wallline2 x1,y1, x2,y2

			if bDrawObjContourIn & bDrawObjContourOut then
				line2 x1,y1, x2,y2
			else
				if (bDrawObjContourOut & not(WIDO_REVEAL_SIDE)) | (bDrawObjContourIn & WIDO_REVEAL_SIDE) then
					if y1 > EPS | y2 > EPS then
						if y1 < -EPS | y2 < -EPS then	! need to split this line
							if y1 < -EPS then
								if abs(y2 + WIDO_REVEAL_SIDE * WIDO_FRAME_THICKNESS) > EPS then
									line2 x2,y2, x1,-WIDO_REVEAL_SIDE * WIDO_FRAME_THICKNESS
								endif
							else
								if abs(y1 + WIDO_REVEAL_SIDE * WIDO_FRAME_THICKNESS) > EPS then
									line2 x1,y1, x2,-WIDO_REVEAL_SIDE * WIDO_FRAME_THICKNESS
								endif
							endif
						else
							line2 x1,y1, x2,y2
						endif
					endif
				endif
				if (bDrawObjContourIn & not(WIDO_REVEAL_SIDE)) | (bDrawObjContourOut & WIDO_REVEAL_SIDE) then
					if y1 < -EPS | y2 < -EPS then
						if y1 > EPS | y2 > EPS then	! need to split this line
							if y1 > EPS then
								if abs(y2 + WIDO_REVEAL_SIDE * WIDO_FRAME_THICKNESS) > EPS then
									line2 x2,y2, x2,-WIDO_REVEAL_SIDE * WIDO_FRAME_THICKNESS
								endif
							else
								if abs(y1 + WIDO_REVEAL_SIDE * WIDO_FRAME_THICKNESS) > EPS then
									line2 x1,y1, x1,-WIDO_REVEAL_SIDE * WIDO_FRAME_THICKNESS
								endif
							endif
						else
							line2 x1,y1, x2,y2
						endif
					endif
				endif
			endif
		endif

		x1 = x2
		y1 = y2
		s1 = s2
	next ii

! Back Fill and Wall Contours ==================================================

	if (iWallContourLine > 1 | fillWallHole > 0) then
		pen penWallContour
		line_property LINE_PROPERTY_GENERIC
		fill fillWallHole

		if (iWallContourLine = 4 & gs_wcont_line_in = gs_wcont_line_out) | (iWallContourLine <= 1 & fillWallHole > 0) then

			leftW	 = leftWidth  - not(gs_stack_left)  * gs_left_oversize
			rightW	 = rightWidth - not(gs_stack_right) * gs_right_oversize
			bContour = 0
			gosub 5000

			if iWallContourLine <= 1 then
				opmethod = 1	! set staus 0 (invisible) for all edges
			else
				opmethod = 4	! edges from polygon1 with 0, edges from polygon2 with 1 status
			endif

			call "terrace_PolygonOperations",
				parameters	opcode 		= OPERATION_INTERSECT_POLYGONS,
							opmethod	= opmethod,
							edgeAttribute = 1,
							srcPolygon1	= INPUT_FROM_PARAMETER,
							polygon1	= AC_WallContourPolygon,
							srcPolygon2	= INPUT_FROM_GDL_STACK,
							result		= OUTPUT_TO_GDL_STACK

			line_type gs_wcont_line_out

			drawindex 30
			poly2_b nsp/3, 1 + 4 + 2 * (GLOB_CONTEXT = 5) + 64, penWallHoleFg, penWallHoleBg, use(nsp)					! Contour lines
			wallhole2 nsp/3, 1 + 2 + 4, penWallHoleFg, penWallHoleBg, 0, 0, 0, get(nsp)		! Back Fill
			drawindex 20
		else
			if iWallContourLine = 2 | iWallContourLine = 4 | fillWallHole > 0 then	! Inside

				leftW	 = leftWidth  - not(gs_stack_left)  * gs_left_oversize
				rightW	 = rightWidth - not(gs_stack_right) * gs_right_oversize
				bContour = 0
				gosub 5000

				if iWallContourLine = 2 | iWallContourLine = 4 then
					opmethod1 = 4	! edges from polygon1 with 0, edges from polygon2 with 1 status
					opmethod2 = 0	! edges with original status
				else
					opmethod1 = 1	! set staus 0 (invisible) for all edges
					opmethod2 = 1
				endif

				call "terrace_PolygonOperations",
					parameters	opcode 		= OPERATION_INTERSECT_POLYGONS,
								opmethod	= opmethod1,
								edgeAttribute = 1,
								srcPolygon1	= INPUT_FROM_PARAMETER,
								polygon1	= AC_WallContourPolygon,
								srcPolygon2	= INPUT_FROM_GDL_STACK,
								result		= OUTPUT_TO_GDL_STACK

				fullWidth = leftWidth + rightWidth
				dim splitPolygon[4][3]
					splitPolygon[1][1] = boundMinX - fullWidth:	splitPolygon[1][2] = 0.01
					splitPolygon[2][1] = boundMaxX + fullWidth:	splitPolygon[2][2] = 0.01
					splitPolygon[3][1] = boundMaxX + fullWidth:	splitPolygon[3][2] = boundMinY - 1
					splitPolygon[4][1] = boundMinX - fullWidth:	splitPolygon[4][2] = boundMinY - 1

				call "terrace_PolygonOperations",
					parameters	opcode 		= OPERATION_INTERSECT_POLYGONS,
								opmethod	= opmethod2,
								edgeAttribute = 1,
								srcPolygon1	= INPUT_FROM_PARAMETER,
								polygon1	= splitPolygon,
								srcPolygon2	= INPUT_FROM_GDL_STACK,
								result		= OUTPUT_TO_GDL_STACK

				line_type gs_wcont_line_in

				if nsp > 6 then
					drawindex 30
					poly2_b nsp/3, 1+2+4+64, penWallHoleFg, penWallHoleBg, get(nsp)		! Back Fill
					drawindex 20
				else
					for i=1 to nsp: n=get(1): next i
				endif
			endif

			if iWallContourLine = 3 | iWallContourLine = 4 | fillWallHole > 0 then	! Outside

				leftW	 = leftWidth  - not(gs_stack_left)  * gs_left_oversize
				rightW	 = rightWidth - not(gs_stack_right) * gs_right_oversize
				bContour = 0
				gosub 5000

				if iWallContourLine = 3 | iWallContourLine = 4 then
					opmethod1 = 4	! edges from polygon1 with 0, edges from polygon2 with 1 status
					opmethod2 = 0	! edges with original status
				else
					opmethod1 = 1	! set staus 0 (invisible) for all edges
					opmethod2 = 1
				endif

				call "terrace_PolygonOperations",
					parameters	opcode 		= OPERATION_INTERSECT_POLYGONS,
								opmethod	= opmethod1,
								edgeAttribute = 1,
								srcPolygon1	= INPUT_FROM_PARAMETER,
								polygon1	= AC_WallContourPolygon,
								srcPolygon2	= INPUT_FROM_GDL_STACK,
								result		= OUTPUT_TO_GDL_STACK

				fullWidth = leftWidth + rightWidth
				dim splitPolygon[4][3]
					splitPolygon[1][1] = boundMinX - fullWidth:	splitPolygon[1][2] = 0
					splitPolygon[2][1] = boundMaxX + fullWidth:	splitPolygon[2][2] = 0
					splitPolygon[3][1] = boundMaxX + fullWidth:	splitPolygon[3][2] = boundMaxY + 1
					splitPolygon[4][1] = boundMinX - fullWidth:	splitPolygon[4][2] = boundMaxY + 1

				call "terrace_PolygonOperations",
					parameters	opcode 		= OPERATION_INTERSECT_POLYGONS,
								opmethod	= opmethod2,
								edgeAttribute = 1,
								srcPolygon1	= INPUT_FROM_PARAMETER,
								polygon1	= splitPolygon,
								srcPolygon2	= INPUT_FROM_GDL_STACK,
								result		= OUTPUT_TO_GDL_STACK

				line_type gs_wcont_line_out

				if nsp > 6 then
					drawindex 30
					poly2_b nsp/3, 1+2+4+64, penWallHoleFg, penWallHoleBg, get(nsp)		! Back Fill
					drawindex 20
				else
					for i=1 to nsp: n=get(1): next i
				endif

			endif
		endif
	endif

! Hotspots =====================================================================

	leftW	 = leftWidth  - not(gs_stack_left)  * gs_left_oversize
	rightW	 = rightWidth - not(gs_stack_right) * gs_right_oversize
	bContour = 1
	gosub 5000

	call "terrace_PolygonOperations",
		parameters	opcode 		= OPERATION_INTERSECT_POLYGONS,
					opmethod	= 5,
					edgeAttribute = 1,
					srcPolygon1	= INPUT_FROM_PARAMETER,
					polygon1	= AC_WallContourPolygon,
					srcPolygon2	= INPUT_FROM_GDL_STACK,
					result		= OUTPUT_TO_GDL_STACK

	polyUnID = 11200	! Hotspot unID for polygonal wall corner points

	for i=1 to nsp/3
		px = get(1)
		py = get(1)
		ps = get(1)

		if ((px <> 0) | (py <> 0))  &  (i <> 1) then
			hotspot2 px,py, polyUnID
			polyUnID = polyUnID + 1
		endif
	next i

endif


! ==============================================================================
! Cavity Closure
! ==============================================================================

dim skinCummThkRef[]	! Cummulative skin thickness from the Outside Face (48 + 1 skins)) [VBAttr::MaxSkinNumber + 1]
dim skinCummThkOpp[]	! Cummulative skin thickness from the Inside Face (48 + 1 skins) [VBAttr::MaxSkinNumber + 1]

cumRefThk = 0
cumOppThk = 0

if bCompositeWall then
	for i=1 to WALL_SKINS_NUMBER
		idx = i: gosub 10	! Get proper index

		cumRefThk = cumRefThk + WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
		skinCummThkRef[idx] = cumRefThk

		idx = WALL_SKINS_NUMBER + 1 - idx	! reorder
		cumOppThk = cumOppThk + WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
		skinCummThkOpp[idx] = cumOppThk
	next i
endif


! ==============================================================================

thkSkinTurnIn = 0
if nSkinTurnIn > 0 then
	idx = nSkinTurnIn: gosub 10	! Get proper index
	thkSkinTurnIn = skinCummThkRef[idx]
endif
thkFinishSkinTurnIn = 0
if nFinishSkinTurnIn > 0 then
	idx = nFinishSkinTurnIn: gosub 10	! Get proper index
	thkFinishSkinTurnIn = skinCummThkRef[idx]
endif

thkSkinTurnOut = 0
if nSkinTurnOut > 0 then
	idx = WALL_SKINS_NUMBER - nSkinTurnOut + 1: gosub 10	! Get proper index
	thkSkinTurnOut = skinCummThkOpp[idx]
endif
thkFinishSkinTurnOut = 0
if nFinishSkinTurnOut > 0 then
	idx = WALL_SKINS_NUMBER - nFinishSkinTurnOut + 1: gosub 10	! Get proper index
	thkFinishSkinTurnOut = skinCummThkOpp[idx]
endif


! ==============================================================================
! Wall Contour Lines
! ==============================================================================

if AC_WallType <> 2 then
	if not(gs_stack_left) then

		sideSign	= -1
		distanceX	= leftWidth
		alfaX		= leftAlfa
		alfaJamb	= alfaLeftJamb
		revealWidth	= gs_reveal_left
		revealAngle	= gs_reveal_left_angle
		bDrawFrameContour	= bDrawFrameContourLeft
		bx = bxL
		by = byL
		sx = sxL
		sy = syL

		gosub 4000		! Wall End Lines
	endif

	if not(gs_stack_right) & not(bCornerWindow) then

		sideSign	= 1
		distanceX	= rightWidth
		alfaX		= rightAlfa
		alfaJamb	= alfaRightJamb
		revealWidth	= gs_reveal_right
		revealAngle	= gs_reveal_right_angle
		bDrawFrameContour	= bDrawFrameContourRight
		bx = bxR
		by = byR
		sx = sxR
		sy = syR

		gosub 4000		! Wall End Lines
	endif
endif


! ==============================================================================

del top

if curvedWall then
	if WIDO_REVEAL_SIDE then
		mul2 1,-1
		add2 0,WIDO_FRAME_THICKNESS
	endif
else
	if WIDO_REVEAL_SIDE then add2 0,-WIDO_FRAME_THICKNESS
	if SYMB_ROTANGLE > EPS then mul2 1, -1
	if wallIsLeft then
		add2 0, -WIDO_SILL
	else
		add2 0, -WALL_THICKNESS + WIDO_SILL
	endif
	if reorder then
		mul2 1,-1
		add2 0, -WALL_THICKNESS
	endif
endif


if bCompositeWall then

! Left Cavity Closure ==========================================================

	if curvedWall then
		numTrans = 0
	else
		mul2 -1, 1
		numTrans = 1
	endif

	sideSign	= -1
	distanceX	= leftWidth
	alfaX		= leftAlfa
	alfaJamb	= alfaLeftJamb
	revealWidth	= gs_reveal_left
	revealAngle	= gs_reveal_left_angle
	bx = bxL
	by = byL
	sx = sxL
	sy = syL

	if not(gs_stack_left) then
		gosub 1000		! Turn Plaster
	endif

	if bCavityCloserLeft then
		if iClosureMethod = CLOSURE_METHOD_TRADITIONAL	 then gosub 2000
		if iClosureMethod = CLOSURE_METHOD_PREFABRICATED then gosub 3000

	endif

	del numTrans

! Right Cavity Closure =========================================================

	if not(bCornerWindow) then
		if curvedWall then
			mul2 -1,1
			numTrans = 1
		else
			numTrans = 0
		endif

		sideSign	= 1
		distanceX	= rightWidth
		alfaX		= rightAlfa
		alfaJamb	= alfaRightJamb
		revealWidth = gs_reveal_right
		revealAngle	= gs_reveal_right_angle
		bx = bxR
		by = byR
		sx = sxR
		sy = syR

		if not(gs_stack_right) then
			gosub 1000		! Turn Plaster
		endif

		if bCavityCloserRight then
			if iClosureMethod = CLOSURE_METHOD_TRADITIONAL	 then gosub 2000
			if iClosureMethod = CLOSURE_METHOD_PREFABRICATED then gosub 3000

		endif

		del numTrans
	endif

endif	! bCompositeWall


! Restore the saved parameter buffer ===========================================

call "LoadQueue" parameters savedQueueValues = savedQueueValues

! ==============================================================================

if GLOB_STRUCTURE_DISPLAY = STRUCTURE_ENTIRE_STRUCTURE then
	thkSkinTurnInLeft	= thkSkinTurnIn
	thkSkinTurnOutLeft	= thkSkinTurnOut

	thkSkinTurnInRight	= thkSkinTurnIn
	thkSkinTurnOutRight	= thkSkinTurnOut
else
	thkSkinTurnInLeft	= thkSkinTurnIn  - thkFinishSkinTurnIn
	thkSkinTurnOutLeft	= thkSkinTurnOut - thkFinishSkinTurnOut

	thkSkinTurnInRight	= thkSkinTurnIn  - thkFinishSkinTurnIn
	thkSkinTurnOutRight	= thkSkinTurnOut - thkFinishSkinTurnOut
endif

if bCompositeWall then
	idx = 1: gosub 10	! Get proper index
	penSkinContourIn	= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
	ltSkinContourIn		= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])

	idx = WALL_SKINS_NUMBER: gosub 10	! Get proper index
	penSkinContourOut	= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN])
	ltSkinContourOut	= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE])
else
	penSkinContourIn	= WALL_SECT_PEN
	ltSkinContourIn		= WALL_LINETYPE

	penSkinContourOut	= WALL_SECT_PEN
	ltSkinContourOut	= WALL_LINETYPE
endif

end thkSkinTurnInLeft,	! Thickness of turned plaster skins at the Inside Face
	thkSkinTurnInRight,
	thkSkinTurnOutLeft,	! Thickness of turned plaster skins at the Outside Face
	thkSkinTurnOutRight,
	penSkinContourIn,	! Skin Contour Pen Opp. Side
	penSkinContourOut,	! Skin Contour Pen Ref. Side
	ltSkinContourIn,	! Skin Contour Line Type Opp. Side
	ltSkinContourOut,	! Skin Contour Line Type Ref. Side
	offsetSill,			! Thickness of hidden wall skins at sill side
	offsetBoard			! Thickness of hidden wall skins at board side

! ==============================================================================
! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end ! end
! ==============================================================================




! ==============================================================================
! === SUBROUTINES
! ==============================================================================

! ==============================================================================
!		Turn Plaster
! ------------------------------------------------------------------------------
! Input variables:
!	nSkinTurnIn:			number of turned plaster skins at the Outside Face
!	nSkinTurnOut:			number of turned plaster skins at the Inside Face
!	bFirstSkinAtReveal:		the first skin located at the reveal side of the window
!	iRevealType:			reveal type (0 = no reveal, 1 = positive, 2 = negative, 3 = slanted)
!	sideSign:				1: at the right side, -1: at the left side
!	distanceX:				horizontal distance from the original origo
!	alfaX:					alfa x in case of curved walls (alfaX > 0)
!	alfaJamb:				jamb alfa (alfaJamb > 0)
!	revealWidth:			width of the reveal
!	revealAngle:			angle of the Inside Face in case of Slanted os Splayed Reveal
!	skinCummThkRef:			precalculated cummulative skin thickness from the Outside Face
!	skinCummThkOpp:			precalculated cummulative skin thickness from the Inside Face
! ==============================================================================

1000:

	bSlantedInnerSide = (iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED)


! ==============================================================================
! Turn Plaster - at the Outside Face
! ==============================================================================

	if nSkinTurnIn > 0 then
		dx = 0
		slantLength = 0
		if bFirstSkinAtReveal then
			if iRevealType = REVEAL_POSITIVE then dx = -revealWidth
			if iRevealType = REVEAL_NEGATIVE then dx =  revealWidth
			if iRevealType = REVEAL_SLANTED  then dx = -revealWidth

			slantX = 0
			if bParalellInCurvedWalls then
				vectS = 0
				vectC = 1
			else
				vectS = sin(alfaX - alfaJamb)
				vectC = cos(alfaX - alfaJamb)
			endif
		else
			if iRevealType = REVEAL_SLANTED then slantLength = WALL_THICKNESS - WIDO_SILL						! Slanted Reveal
			if iRevealType = REVEAL_SPLAYED then slantLength = WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS	! Splayed Reveal

			if bSlantedInnerSide then
				slantX = tan(revealAngle)
				vectS = -sin(revealAngle) * signWallIsLeft
				vectC = cos(revealAngle)
			else
				slantX = 0
				if bParalellInCurvedWalls then
					vectS = 0
					vectC = 1
				else
					vectS = sin(alfaX)
					vectC = cos(alfaX)
				endif
			endif
		endif

		turnThk = 0

		for i = nSkinTurnIn to 1 step -1
			idx = i: gosub 10	! Get proper index

			skinThk = WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
			bFirst	= (i = nSkinTurnIn)
			bLast	= (i = 1)

			if reorder then
				cummThk = skinCummThkRef[idx + 1]
			else
				if idx > 1 then
					cummThk = skinCummThkRef[idx - 1]
				else
					cummThk = 0
				endif
			endif

			if curvedWall then

! Curved Wall ==================================================================

				if reorder then
					signReorder = -1
				else
					signReorder = 1
				endif

! p2 point ---------------------------------------------------------------------

				xo = 0
				yo = -WOD
				if bFirstSkinAtReveal then
					ro = rSill - cummThk * signReorder
				else
					ro = rBoard - cummThk * signReorder
				endif

				if bFirstSkinAtReveal then
					x2 = -sx * sideSign
					y2 =  sy
				else
					x2 = -bx * sideSign
					y2 =  by
				endif
				x1 = x2 + vectS
				y1 = y2 - vectC * signWallIsLeft

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px2 = cx
				py2 = cy


! p3 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x2 = -sx * sideSign + (turnThk + skinThk) * vectC
					y2 =  sy			+ (turnThk + skinThk) * vectS * signReorder
				else
					x2 = -bx * sideSign + (turnThk + skinThk) * vectC
					y2 =  by			- (turnThk + skinThk) * vectS * signReorder
				endif
				x1 = x2 + vectS
				y1 = y2 - vectC * signWallIsLeft

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px3 = cx
				py3 = cy


! p1 point ---------------------------------------------------------------------

				xo = 0
				yo = -WOD
				if bFirstSkinAtReveal then
					ro = rSill - skinCummThkRef[idx] * signReorder
				else
					ro = rBoard - skinCummThkRef[idx] * signReorder
				endif

				if bFirstSkinAtReveal then
					x2 = -sx * sideSign
					y2 =  sy
				else
					x2 = -bx * sideSign
					y2 =  by
				endif
				x1 = x2 + vectS
				y1 = y2 - vectC * signWallIsLeft

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px1 = cx
				py1 = cy


! p6 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x2 = -sx * sideSign + turnThk * vectC
					y2 =  sy			+ turnThk * vectS * signReorder
				else
					x2 = -bx * sideSign + turnThk * vectC
					y2 =  by			- turnThk * vectS * signReorder
				endif
				x1 = x2 + vectS
				y1 = y2 - vectC * signWallIsLeft

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px6 = cx
				py6 = cy


! Window's line or arch ========================================================

				if bWndCurved then
					xo = 0
					yo = -WOD
					ro = rSillLine + not(wallIsLeft exor reorder) * WIDO_FRAME_THICKNESS * signReorder
				else
					x11 = 0
					y11 = -not(wallIsLeft exor reorder) * WIDO_FRAME_THICKNESS
					x12 = 1
					y12 = y11
				endif


! p4 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x22 = -sx * sideSign + (turnThk + skinThk) * vectC
					y22 =  sy			 + (turnThk + skinThk) * vectS * signReorder
				else
					x22 = -bx * sideSign + (turnThk + skinThk) * vectC
					y22 =  by			 - (turnThk + skinThk) * vectS * signReorder
				endif
				x21 = x22 + vectS
				y21 = y22 - vectC * signWallIsLeft

				if bWndCurved then
					x1 = x21: y1 = y21
					x2 = x22: y2 = y22
					gosub 101	! Circle - Line intersection
					gosub 102	! Select good intersection point
				else
					gosub 100	! Line - Line intersection
				endif
				px4 = cx
				py4 = cy


! p5 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x22 = -sx * sideSign + turnThk * vectC
					y22 =  sy			 + turnThk * vectS * signReorder
				else
					x22 = -bx * sideSign + turnThk * vectC
					y22 =  by			 - turnThk * vectS * signReorder
				endif
				x21 = x22 + vectS
				y21 = y22 - vectC * signWallIsLeft

				if bWndCurved then
					x1 = x21: y1 = y21
					x2 = x22: y2 = y22
					gosub 101	! Circle - Line intersection
					gosub 102	! Select good intersection point
				else
					gosub 100	! Line - Line intersection
				endif
				px5 = cx
				py5 = cy

			else

! Straight Wall, Trapezoid Wall ================================================

				slantDiffUpper = not(bFirstSkinAtReveal) * bSlantedInnerSide * ((turnThk + skinThk) - (turnThk + skinThk) / cos(revealAngle))
				slantDiffLower = not(bFirstSkinAtReveal) * bSlantedInnerSide * (turnThk - turnThk / cos(revealAngle))

				py1 = cummThk + skinThk
				px1 = distanceX + dx + (slantLength - py1)* slantX

				py2 = cummThk
				px2 = distanceX + dx + (slantLength - py2)* slantX

				py3 = cummThk
				px3 = distanceX + dx - turnThk - skinThk + (slantLength - py3) * slantX + slantDiffUpper

				py4 = lengthPlasterTurnIn
				px4 = distanceX + dx - turnThk - skinThk + (slantLength - py4) * slantX + slantDiffUpper

				py5 = lengthPlasterTurnIn
				px5 = distanceX + dx - turnThk + (slantLength - py5)* slantX + slantDiffLower

				py6 = cummThk + skinThk
				px6 = distanceX + dx - turnThk + (slantLength - py6)* slantX + slantDiffLower
			endif

! Draw the turned plaster skins ================================================

			bShowSkin = (GLOB_STRUCTURE_DISPLAY = STRUCTURE_ENTIRE_STRUCTURE | (GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) > EPS))

			if bShowSkin then
				fill WALL_SKINS_PARAMS[idx][SKIN_FILL]
				bLocalFill = round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_ORIENTATION])

				wallblock2 6, 2 + 24 * bLocalFill + 32,
					WALL_SKINS_PARAMS[idx][SKIN_FILL_PEN],
					WALL_SKINS_PARAMS[idx][SKIN_FILL_BACK_PEN],
					0,0,0,
					px1,	py1,	0,
					px2,	py2,	0,
					px3,	py3,	0,
					px4,	py4,	0,
					px5,	py5,	0,
					px6,	py6,	0
			endif

			if WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN] > EPS then
				pen			WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN]
				line_type	WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE]
				line_property LINE_PROPERTY_INNER + bLast		! (1 / 2)

				if bShowSkin then
					wallline2	px2,py2, px3,py3
					wallline2	px3,py3, px4,py4

					if bLast & bDrawObjContourOut then
						line2	px2,py2, px3,py3
						line2	px3,py3, px4,py4
					endif
				endif
			endif

			if bFirst & bShowSkin & WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN] > EPS then
				pen			WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN]
				line_type	WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE]
				line_property LINE_PROPERTY_INNER

				if not(curvedWall) | (py6 < py5 exor wallIsLeft exor reorder) then
					wallline2	px5,py5, px6,py6
				endif
			endif

			turnThk = turnThk + skinThk
		next i

	endif


! ==============================================================================
! Turn Plaster - at the Inside Face
! ==============================================================================

	if nSkinTurnOut > 0 then
		if bFirstSkinAtReveal then
			dx = 0

			if iRevealType = REVEAL_SLANTED then slantLength = WALL_THICKNESS - WIDO_SILL						! Slanted Reveal
			if iRevealType = REVEAL_SPLAYED then slantLength = WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS	! Splayed Reveal

			if bSlantedInnerSide then
				slantX	=  tan(revealAngle)
				vectS	= -sin(revealAngle) * signWallIsLeft
				vectC	=  cos(revealAngle)
			else
				slantX	= 0
				if bParalellInCurvedWalls then
					vectS = 0
					vectC = 1
				else
					vectS = sin(alfaX)
					vectC = cos(alfaX)
				endif
			endif
		else
			dx = 0
			if iRevealType = REVEAL_POSITIVE then dx = -revealWidth
			if iRevealType = REVEAL_NEGATIVE then dx =  revealWidth
			if iRevealType = REVEAL_SLANTED  then dx = -revealWidth

			slantX	= 0
			if bParalellInCurvedWalls then
				vectS = 0
				vectC = 1
			else
				vectS = sin(alfaX - alfaJamb)
				vectC = cos(alfaX - alfaJamb)
			endif
		endif

		bIncSign = (SYMB_MIRRORED exor WIDO_REVEAL_SIDE exor reorder)
		iIncSign = bIncSign - not(bIncSign)

		turnThk = 0

		for i = WALL_SKINS_NUMBER - nSkinTurnOut + 1 to WALL_SKINS_NUMBER
			idx = i: gosub 10	! Get proper index

			skinThk = WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
			bFirst	= (i = WALL_SKINS_NUMBER - nSkinTurnOut + 1)
			bLast	= (i = WALL_SKINS_NUMBER)

			if reorder then
				if idx > 1 then
					cummThk = skinCummThkOpp[idx - 1]
				else
					cummThk = 0
				endif
			else
				cummThk = skinCummThkOpp[idx + 1]
			endif

			if bInclinedWall then
				if reorder then
					incDiffLower	= cummThk - cummThk / incH
					incDiffUpper	= skinCummThkOpp[idx + 0] - skinCummThkOpp[idx + 0] / incH
				else
					incDiffLower	= skinCummThkOpp[idx + 1] - skinCummThkOpp[idx + 1] / incH
					incDiffUpper	= skinCummThkOpp[idx + 0] - skinCummThkOpp[idx + 0] / incH
				endif
			else
				incDiffLower	= 0
				incDiffUpper	= 0
			endif

			slantDiffLower = bFirstSkinAtReveal * bSlantedInnerSide * ((turnThk + skinThk) - (turnThk + skinThk) / cos(revealAngle))
			slantDiffUpper = bFirstSkinAtReveal * bSlantedInnerSide * (turnThk - turnThk / cos(revealAngle))

			if curvedWall then

! Curved Wall ==================================================================

				if reorder then
					signReorder = -1
				else
					signReorder = 1
				endif

! p2 point ---------------------------------------------------------------------

				xo = 0
				yo = -WOD
				if bFirstSkinAtReveal then
					ro = rBoard + cummThk * signReorder
				else
					ro = rSill + cummThk * signReorder
				endif

				if bFirstSkinAtReveal then
					x2 = -bx * sideSign
					y2 =  by
				else
					x2 = -sx * sideSign
					y2 =  sy
				endif
				x1 = x2 + vectS
				y1 = y2 - vectC * signWallIsLeft

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px2 = cx
				py2 = cy

				bValidP2 = (state > 0)


! p3 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x2 = -bx * sideSign + (turnThk + skinThk) * vectC
					y2 =  by			+ (turnThk + skinThk) * vectS * signReorder
				else
					x2 = -sx * sideSign + (turnThk + skinThk) * vectC
					y2 =  sy			- (turnThk + skinThk) * vectS * signReorder
				endif
				x1 = x2 + vectS
				y1 = y2 - vectC * signWallIsLeft

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px3 = cx
				py3 = cy

				bValidP3 = (state > 0)


! p1 point ---------------------------------------------------------------------

				xo = 0
				yo = -WOD
				if bFirstSkinAtReveal then
					ro = rBoard + skinCummThkOpp[idx] * signReorder
				else
					ro = rSill + skinCummThkOpp[idx] * signReorder
				endif

				if bFirstSkinAtReveal then
					x2 = -bx * sideSign
					y2 =  by
				else
					x2 = -sx * sideSign
					y2 =  sy
				endif
				x1 = x2 + vectS
				y1 = y2 - vectC * signWallIsLeft

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px1 = cx
				py1 = cy

				bValidP1 = (state > 0)


! p6 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x2 = -bx * sideSign + turnThk * vectC
					y2 =  by			+ turnThk * vectS * signReorder
				else
					x2 = -sx * sideSign + turnThk * vectC
					y2 =  sy			- turnThk * vectS * signReorder
				endif
				x1 = x2 + vectS
				y1 = y2 - vectC * signWallIsLeft

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px6 = cx
				py6 = cy

				bValidP6 = (state > 0)


! Window's line or arch ========================================================

				if bWndCurved then
					xo = 0
					yo = -WOD
					ro = rSillLine - (wallIsLeft exor reorder) * WIDO_FRAME_THICKNESS * signReorder
				else
					x11 = 0
					y11 = -(wallIsLeft exor reorder) * WIDO_FRAME_THICKNESS
					x12 = 1
					y12 = y11
				endif


! p4 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x22 = -bx * sideSign + (turnThk + skinThk) * vectC
					y22 =  by			 + (turnThk + skinThk) * vectS * signReorder
				else
					x22 = -sx * sideSign + (turnThk + skinThk) * vectC
					y22 =  sy			 - (turnThk + skinThk) * vectS * signReorder
				endif
				x21 = x22 + vectS
				y21 = y22 - vectC * signWallIsLeft

				if bWndCurved then
					x1 = x21: y1 = y21
					x2 = x22: y2 = y22
					gosub 101	! Circle - Line intersection
					gosub 102	! Select good intersection point

					bValidP4 = (state > 0)
				else
					gosub 100	! Line - Line intersection

					bValidP4 = 1
				endif
				px4 = cx
				py4 = cy


! p5 point ---------------------------------------------------------------------

				if bFirstSkinAtReveal then
					x22 = -bx * sideSign + turnThk * vectC
					y22 =  by			 + turnThk * vectS * signReorder
				else
					x22 = -sx * sideSign + turnThk * vectC
					y22 =  sy			 - turnThk * vectS * signReorder
				endif
				x21 = x22 + vectS
				y21 = y22 - vectC * signWallIsLeft

				if bWndCurved then
					x1 = x21: y1 = y21
					x2 = x22: y2 = y22
					gosub 101	! Circle - Line intersection
					gosub 102	! Select good intersection point

					bValidP5 = (state > 0)
				else
					gosub 100	! Line - Line intersection

					bValidP5 = 1
				endif
				px5 = cx
				py5 = cy


! Check for valid points =======================================================

				if abs(px3) < EPS and abs(py3) < EPS then
					px3 = px4
					py3 = py4
				endif
				if abs(px2) < EPS and abs(py2) < EPS then
					px2 = px3
					py2 = py3
				endif
				if abs(px6) < EPS and abs(py6) < EPS then
					px6 = px5
					py6 = py5
				endif
				if abs(px1) < EPS and abs(py1) < EPS then
					px1 = px6
					py1 = py6
				endif
			else

! Straight Wall, Trapezoid Wall ================================================

				if (bInclinedWall | bFirstSkinAtReveal) & (iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED) then

					if bFirstSkinAtReveal then
						x1 = bx * sideSign
						y1 =  by + WIDO_SILL + (iRevealType = REVEAL_SPLAYED) * WIDO_FRAME_THICKNESS
					else
						x1 = sx * sideSign
						y1 =  sy + WIDO_SILL + (iRevealType = REVEAL_SPLAYED) * WIDO_FRAME_THICKNESS
					endif

					x3 = x1 - (turnThk + skinThk) * cos(revealAngle)
					y3 = y1 + (turnThk + skinThk) * sin(revealAngle)

					x6 = x1 - turnThk * cos(revealAngle)
					y6 = y1 + turnThk * sin(revealAngle)

					if bInclinedWall then
						x11 = dx + cummThk * incV * iInclDir * sideSign * iIncSign
						y11 = WALL_THICKNESS - cummThk * incH
						x12 = x11 + incH
						y12 = y11 + incV * iInclDir * sideSign * iIncSign
					else
						x11 = dx
						y11 = WALL_THICKNESS - cummThk
						x12 = x11 + 1
						y12 = y11
					endif

					x21 = x1
					y21 = y1
					x22 = x21 + sin(revealAngle)
					y22 = y21 + cos(revealAngle)

					gosub 100		! Line - Line intersection
					px2 = cx
					py2 = cy

					x21 = x3
					y21 = y3
					x22 = x21 + sin(revealAngle)
					y22 = y21 + cos(revealAngle)

					gosub 100		! Line - Line intersection
					px3 = cx
					py3 = cy

					if bInclinedWall then
						x11 = dx + (skinCummThkOpp[idx]) * incV * iInclDir * sideSign * iIncSign
						y11 = WALL_THICKNESS - (skinCummThkOpp[idx]) * incH
						x12 = x11 + incH
						y12 = y11 + incV * iInclDir * sideSign * iIncSign
					else
						x11 = dx
						y11 = WALL_THICKNESS - skinCummThkOpp[idx]
						x12 = 1
						y12 = y11
					endif

					x21 = x1
					y21 = y1
					x22 = x21 + sin(revealAngle)
					y22 = y21 + cos(revealAngle)

					gosub 100		! Line - Line intersection
					px1 = cx
					py1 = cy

					x21 = x6
					y21 = y6
					x22 = x21 + sin(revealAngle)
					y22 = y21 + cos(revealAngle)

					gosub 100		! Line - Line intersection
					px6 = cx
					py6 = cy
				else
					px1 = distanceX + dx
					py1 = WALL_THICKNESS - cummThk - skinThk + (px1 - dx) * incHor * sideSign * iIncSign + incDiffUpper

					px2 = distanceX + dx
					py2 = WALL_THICKNESS - cummThk  + (px2 - dx) * incHor * sideSign * iIncSign + incDiffLower

					px3 = distanceX + dx - turnThk - skinThk
					py3 = WALL_THICKNESS - cummThk  + (px3 - dx) * incHor * sideSign * iIncSign + incDiffLower

					px6 = distanceX + dx - turnThk
					py6 = WALL_THICKNESS - cummThk - skinThk + (px6 - dx) * incHor * sideSign * iIncSign + incDiffUpper
				endif

				py4 = WALL_THICKNESS - lengthPlasterTurnOut
				px4 = distanceX + dx - turnThk - skinThk + (slantLength + (py4 - WALL_THICKNESS)) * slantX + slantDiffLower

				py5 = WALL_THICKNESS - lengthPlasterTurnOut
				px5 = distanceX + dx - turnThk + (slantLength + (py5 - WALL_THICKNESS)) * slantX + slantDiffUpper

				bValidP1 = 1
				bValidP2 = 1
				bValidP3 = 1
				bValidP4 = 1
				bValidP5 = 1
				bValidP6 = 1
			endif

! Draw the turned plaster skins ================================================

			bShowSkin = (GLOB_STRUCTURE_DISPLAY = STRUCTURE_ENTIRE_STRUCTURE | (GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) > EPS))

			if bShowSkin then
				fill		 WALL_SKINS_PARAMS[idx][SKIN_FILL]
				bLocalFill = round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_ORIENTATION])

				if bValidP1 then put px1,py1, 0
				if bValidP2 then put px2,py2, 0
				if bValidP3 then put px3,py3, 0
				if bValidP4 then put px4,py4, 0
				if bValidP5 then put px5,py5, 0
				if bValidP6 then put px6,py6, 0

				penFillFg = round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_PEN])
				penFillBg = round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_BACK_PEN])
				bDrawContour = 0
				gosub 200	! Draw wallblock with contour
			endif

			if WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN] > EPS then
				pen			WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN]
				line_type	WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE]
				line_property LINE_PROPERTY_INNER + bLast		! (1 / 2)

				if bShowSkin then
					wallline2	px2,py2, px3,py3
					wallline2	px3,py3, px4,py4

					if bLast & bDrawObjContourIn then
						line2	px2,py2, px3,py3
						line2	px3,py3, px4,py4
					endif
				endif
			endif

			if bFirst & bShowSkin & WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN] > EPS then
				pen			WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN]
				line_type	WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE]
				line_property LINE_PROPERTY_INNER

				wallline2	px5,py5, px6,py6
			endif

			turnThk = turnThk + skinThk
		next i

	endif

return


! ==============================================================================
!		Traditional Cavity Closure
! ------------------------------------------------------------------------------
! Input variables:
!	possibleSkinTurnIn:		number of possible plaster skins at the Outside Face
!	possibleSkinTurnOut:	number of possible plaster skins at the Inside Face
!	distanceX:				horizontal distance from the original origo
!	alfaX:					alfa x in case of curved walls (alfaX > 0)
!	alfaJamb:				jamb alfa (alfaJamb > 0)
!	revealWidth:			width of the reveal
! ==============================================================================

2000:
	nSkins = WALL_SKINS_NUMBER - possibleSkinTurnOut - possibleSkinTurnIn
	if nSkins < 3 then return

	gs_nTurn = min(gs_nTurn, nSkins - 2)
	signTurnDir = (gs_bTurnDir) - not(gs_bTurnDir)

	if gs_bTurnDir then
		idx = WALL_SKINS_NUMBER - possibleSkinTurnOut - 1: gosub 10	! Get proper index
		baseSkinLevel = skinCummThkRef[idx]

		idx = WALL_SKINS_NUMBER - possibleSkinTurnOut:	gosub 10	! Get proper index
		baseSkinIdx = idx
	else
		idx = possibleSkinTurnIn + 1: gosub 10	! Get proper index
		baseSkinIdx = idx
		baseSkinLevel = skinCummThkRef[baseSkinIdx]
	endif

	lengthSkinTurnIn = baseSkinLevel - signTurnDir * gs_bJoint * gs_thkJoint

!!!	idx = nSkinTurnIn + gs_nTurn: gosub 10	! Get proper index
	if gs_bTurnDir then
		idx = possibleSkinTurnIn + gs_nTurn: gosub 10	! Get proper index
		if idx > 0 then
			level_1 = skinCummThkRef[idx]
		else
			level_1 = 0
		endif
	else
		idx = WALL_SKINS_NUMBER - possibleSkinTurnOut - gs_nTurn: gosub 10	! Get proper index
		level_1 = skinCummThkRef[idx]
	endif

	idx = baseSkinIdx
	baseSkinFillType		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL])
	baseSkinFillFgPen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_PEN])
	baseSkinFillBgPen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_BACK_PEN])
	baseSkinFillOrientation	= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_ORIENTATION])
	baseSkinContLinePen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
	baseSkinContLineType	= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])

!!!	idx = nSkinTurnIn: gosub 10	! Get proper index
	if gs_bTurnDir then
		idx = possibleSkinTurnIn: gosub 10	! Get proper index
		if idx > 0 then
			level_2 = skinCummThkRef[idx]
		else
			level_2 = 0
		endif
	else
		idx = WALL_SKINS_NUMBER - possibleSkinTurnOut: gosub 10	! Get proper index
		level_2 = skinCummThkRef[idx]
	endif

	widthJoint = abs(level_1 - level_2)

	dx = 0
	bCuttedPlug = 0
	bNegativeTurn = 0

	vectS = -sin(revealAngle) * signWallIsLeft
	vectC =  cos(revealAngle)

	if bFirstSkinAtReveal exor not(gs_bTurnDir) then
		if iRevealType = REVEAL_POSITIVE then dx = -revealWidth
		if iRevealType = REVEAL_NEGATIVE then dx =  revealWidth
		if iRevealType = REVEAL_SLANTED  then dx = -revealWidth

		if not(curvedWall) then
			slantX = 0
			vectS = sin(alfaX - alfaJamb)
			vectC = cos(alfaX - alfaJamb)
		endif

		bCuttedPlug		= 0
		plugLeftDx		= 0
		plugOnWindow	= 0		! GER request

		bIncludeReveal	= 0

		if iRevealType <> REVEAL_NEGATIVE & revealWidth + EPS >= widthJoint & widthJoint + gs_thkJoint < WIDO_SILL then
			! note: widthJoint equals the summ width of the turned skins

			if gs_bTurnDir then
				baseSkinLevel = WIDO_SILL
				lengthSkinTurnIn = baseSkinLevel - gs_bJoint * gs_thkJoint
			else
				baseSkinLevel = WALL_THICKNESS - WIDO_SILL
				lengthSkinTurnIn = baseSkinLevel + gs_bJoint * gs_thkJoint
			endif
			plugOnWindow = 1
		else
			if iRevealType = REVEAL_NEGATIVE then
				plugLeftDx = 0

				if gs_bTurnDir then
					if baseSkinLevel - EPS > WIDO_SILL then
						bCuttedPlug = 1
					endif
				else
					if baseSkinLevel - EPS < WALL_THICKNESS - WIDO_SILL then
						bCuttedPlug = 1
					endif
				endif
			else
				if gs_bTurnDir then
					if lengthSkinTurnIn - EPS >= WIDO_SILL then
						if lengthSkinTurnIn < WIDO_SILL + EPS then
							plugLeftDx = revealWidth
						else
							bIncludeReveal = 1
							if bSlantedInnerSide then
								if iRevealType = REVEAL_SLANTED then slantDy = lengthSkinTurnIn - WIDO_SILL
								if iRevealType = REVEAL_SPLAYED then slantDy = lengthSkinTurnIn - WIDO_SILL - WIDO_FRAME_THICKNESS
								dx = slantDy * tan(revealAngle)
							else
								dx = 0
							endif
						endif
					else
						bCuttedPlug = 1
					endif
				else
					if lengthSkinTurnIn + EPS <= WALL_THICKNESS - WIDO_SILL then
						if lengthSkinTurnIn > WALL_THICKNESS - WIDO_SILL + EPS then
							plugLeftDx = revealWidth
						else
							bIncludeReveal = 1
							if bSlantedInnerSide then
								if iRevealType = REVEAL_SLANTED then slantDy = WALL_THICKNESS - lengthSkinTurnIn - WIDO_SILL
								if iRevealType = REVEAL_SPLAYED then slantDy = WALL_THICKNESS - lengthSkinTurnIn - WIDO_SILL - WIDO_FRAME_THICKNESS
								dx = slantDy * tan(revealAngle)
							else
								dx = 0
							endif
						endif
					else
						bCuttedPlug = 1
					endif
				endif
			endif
		endif
		if WIDO_SILL < EPS & (iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE) then
			bIncludeReveal = 0
		endif
	else

		if iRevealType = REVEAL_NEGATIVE then
			if gs_bTurnDir then
				if baseSkinLevel + EPS >= WALL_THICKNESS - WIDO_SILL & WIDO_SILL < WALL_THICKNESS then
					bIncludeReveal = 1
				endif
			else
				if baseSkinLevel + EPS <= WIDO_SILL & WIDO_SILL < WALL_THICKNESS then
					bIncludeReveal = 1
				endif
			endif
		else
			if gs_bTurnDir then
				if curvedWall & not(bWndCurved) then
					if wallIsLeft then
						sLevel = sqr(bx^2 + (by + WOD)^2) - rBoard
					else
						sLevel = WALL_THICKNESS - sqr(bx^2 + (by + WOD)^2) + rSill
					endif

					if baseSkinLevel - EPS >= sLevel then
						bCuttedPlug = 1
						plugLeftDx = -revealWidth
					endif
				else
					if baseSkinLevel + EPS > WALL_THICKNESS - WIDO_SILL then
						bCuttedPlug = 1
						plugLeftDx = -revealWidth
					endif
				endif
			else
				if curvedWall & not(bWndCurved) then
					if wallIsLeft then
						sLevel = rSill - sqr(bx^2 + (by + WOD)^2)
					else
						sLevel = sqr(bx^2 + (by + WOD)^2) - rSill
					endif

					if baseSkinLevel + EPS <= sLevel then
						bCuttedPlug = 1
						plugLeftDx = -revealWidth
					endif
				else
					if baseSkinLevel + EPS < WIDO_SILL then
						bCuttedPlug = 1
						plugLeftDx = -revealWidth
					endif
				endif
			endif
		endif

		if iRevealType = REVEAL_NEGATIVE then
			if gs_bTurnDir then
				if WALL_THICKNESS - WIDO_SILL < baseSkinLevel + EPS then
					dx = revealWidth
				endif
			else
				if WIDO_SILL > baseSkinLevel + EPS then
					dx = revealWidth
				endif
			endif
			bNegativeTurn = 1
		endif
		if iRevealType = REVEAL_SLANTED then slantLength = WALL_THICKNESS - WIDO_SILL
		if iRevealType = REVEAL_SPLAYED then slantLength = WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS

		if not(curvedWall) then
			if bSlantedInnerSide then
				slantX = tan(revealAngle)
				vectS = -sin(revealAngle) * signWallIsLeft
				vectC =  cos(revealAngle)
			else
				slantX = 0
				vectS = sin(alfaX)
				vectC = cos(alfaX)
			endif
		endif
	endif

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		bCuttedPlug		= 0
		bIncludeReveal	= 0
	endif

	if curvedWall then
		if reorder then
			rBegH = min(rSill, rBoard) + baseSkinLevel
			rEndH = min(rSill, rBoard) + baseSkinLevel - signTurnDir * gs_thkJoint
		else
			rBegH = max(rSill, rBoard) - baseSkinLevel
			rEndH = max(rSill, rBoard) - baseSkinLevel + signTurnDir * gs_thkJoint
		endif
		baseSkinRadius	= rEndH
		lengthToAngle	= (180 / rBegH / PI)	! Ref circle is on the rBegH
	endif

	dxAngle = dx * ArcLengthSillToAngle

	if iRevealType = REVEAL_SLANTED & not(bIncludeReveal) & wallIsLeft & (reorder exor gs_bTurnDir) then
		! In this special case we have to draw a normal positive reveal
		bSlantedInnerSide = 0
	endif


! Insulation Strip =============================================================

	if gs_bJoint then

		if not(bFirstSkinAtReveal exor not(gs_bTurnDir)) & bSlantedInnerSide & not(curvedWall) then widthJoint = widthJoint / cos(revealAngle)

		if gs_bTurnDir then
			slantDx = bSlantedInnerSide * not(bFirstSkinAtReveal exor not(gs_bTurnDir)) * (baseSkinLevel - gs_thkJoint - WALL_THICKNESS + WIDO_SILL) * tan(revealAngle)
		else
			slantDx = bSlantedInnerSide * not(bFirstSkinAtReveal exor not(gs_bTurnDir)) * (WIDO_SILL - baseSkinLevel - gs_thkJoint) * tan(revealAngle)
		endif

		if not(bFirstSkinAtReveal exor not(gs_bTurnDir)) & baseSkinLevel > WIDO_SILL then
			if gs_bTurnDir then
				plugLeftDx = (WALL_THICKNESS - lengthSkinTurnIn - WIDO_SILL) * tan(revealAngle)
			else
				plugLeftDx = (lengthSkinTurnIn - WIDO_SILL) * tan(revealAngle)
			endif
		endif

		if curvedWall then

			if bSlantedInnerSide | bParalellInCurvedWalls then

				xo = 0
				yo = -WOD

				ro = rBegH

				if (gs_bTurnDir exor reorder exor wallIsLeft) & bCuttedPlug then
					x1 = -sx * sideSign
					y1 =  sy
					x2 = x1 - sin(alfaX - alfaJamb)
					y2 = y1 + cos(alfaX - alfaJamb) * signWallIsLeft
				else
					x1 = -bx * sideSign
					y1 =  by
					x2 = x1 - vectS
					y2 = y1 + vectC * signWallIsLeft
				endif

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px1 = cx
				py1 = cy

				ro = baseSkinRadius

				x1 = -bx * sideSign - widthJoint * vectC
				y1 = by - widthJoint * vectS * signWallIsLeft
				x2 = x1 - vectS
				y2 = y1 + vectC * signWallIsLeft

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px3 = cx
				py3 = cy

				alpha =  atn(cx/(cy+WOD))
				px2 = px3 - signTurnDir * signReorder * signWallIsLeft * gs_thkJoint * sin(alpha)
				py2 = py3 - signTurnDir * signReorder * signWallIsLeft * gs_thkJoint * cos(alpha)

				ro = rEndH

				if (gs_bTurnDir exor reorder exor wallIsLeft) | not(bCuttedPlug) then
					x1 = -bx * sideSign
					y1 =  by
					x2 = x1 - vectS
					y2 = y1 + vectC * signWallIsLeft
				else
					x1 = -sx * sideSign
					y1 =  sy
					x2 = x1 - sin(alfaX - alfaJamb)
					y2 = y1 + cos(alfaX - alfaJamb) * signWallIsLeft
				endif

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px4 = cx
				py4 = cy

			else

				plugAngle = widthJoint * lengthToAngle
				alfaPlug = alfaX + (iRevealType = REVEAL_NEGATIVE) * dxAngle

				sin1 = sin(alfaPlug)
				cos1 = cos(alfaPlug) * signWallIsLeft
				sin2 = sin(alfaPlug + plugAngle + (iRevealType <> REVEAL_NEGATIVE) * dxAngle)
				cos2 = cos(alfaPlug + plugAngle + (iRevealType <> REVEAL_NEGATIVE) * dxAngle) * signWallIsLeft

				if bCuttedPlug then
					if gs_bTurnDir exor reorder exor wallIsLeft then
						alfaPlug3 = alfaX - alfaJamb
					else
						alfaPlug3 = alfaX
					endif
					sin3 = sin(alfaPlug3)
					cos3 = cos(alfaPlug3) * signWallIsLeft

					sin4 = sin(alfaX + dxAngle)
					cos4 = cos(alfaX + dxAngle) * signWallIsLeft
				endif

				if bCuttedPlug then
					px1 = -rBegH * sin3
					py1 = -WOD + rBegH * cos3
				else
					px1 = -rBegH * sin1
					py1 = -WOD + rBegH * cos1
				endif

				px2 = -rBegH * sin2
				py2 = -WOD + rBegH * cos2

				px3 = -rEndH * sin2
				py3 = -WOD + rEndH * cos2

				if bCuttedPlug then
					px4 = -rEndH * sin4
					py4 = -WOD + rEndH * cos4
				else
					px4 = -rEndH * sin1
					py4 = -WOD + rEndH * cos1
				endif
			endif
		else
			px1 = distanceX + dx + plugLeftDx
			py1 = baseSkinLevel

			px2 = distanceX + dx + plugLeftDx
			py2 = baseSkinLevel - signTurnDir * gs_thkJoint

			px3 = distanceX + dx - slantDx + widthJoint
			py3 = baseSkinLevel - signTurnDir * gs_thkJoint

			px4 = distanceX + dx - slantDx + widthJoint
			py4 = baseSkinLevel
		endif


! Draw Insulation Strip ========================================================

		if gs_showJoint then
			pen gs_penJoint
			line_type gs_ltJoint
			set fill gs_fillJoint
			line_property LINE_PROPERTY_INNER

			if bCuttedPlug then

				bDivide		= 0		! is sill line cross the insulation plug?
				divLength	= 0

				if bFirstSkinAtReveal then
					if gs_bTurnDir then
						bDivide = (baseSkinLevel + EPS  > WIDO_SILL & baseSkinLevel - gs_thkJoint - EPS < WIDO_SILL)
						divLength = baseSkinLevel - WIDO_SILL
					else
						bDivide = (baseSkinLevel - EPS < WIDO_SILL & baseSkinLevel + gs_thkJoint + EPS > WIDO_SILL)
						divLength = baseSkinLevel + gs_thkJoint - WIDO_SILL
					endif
				else
					if gs_bTurnDir then
						bDivide = (baseSkinLevel + EPS > WALL_THICKNESS - WIDO_SILL & baseSkinLevel - gs_thkJoint - EPS < WALL_THICKNESS - WIDO_SILL)
						divLength = baseSkinLevel - gs_thkJoint - (WALL_THICKNESS - WIDO_SILL)
					else
						bDivide = (baseSkinLevel - EPS < WALL_THICKNESS - WIDO_SILL & baseSkinLevel + gs_thkJoint + EPS > WALL_THICKNESS - WIDO_SILL)
						divLength = baseSkinLevel - (WALL_THICKNESS - WIDO_SILL)
					endif
				endif

				if iRevealType = REVEAL_SLANTED & not(plugOnWindow) & bDivide then
					px1Slant = abs(divLength * tan(revealAngle))
					px1Slant = max(0,px1Slant)
				else
					px1Slant = 0
				endif

				if bFirstSkinAtReveal then
					pySill = WIDO_SILL
				else
					pySill = WALL_THICKNESS - WIDO_SILL
				endif

				if curvedWall then
					if curvedWall & not(bWndCurved) & (iRevealType <> REVEAL_NEGATIVE) & (iRevealType > REVEAL_NO) & (py4 - EPS < by) & (py3 + EPS > by) then
						xo = 0
						yo = -WOD
						ro = baseSkinRadius - (reorder exor gs_bTurnDir) * gs_thkJoint

						x1 = 0
						y1 = by
						x2 = 1
						y2 = by

						gosub 101	! Circle - Line intersection
						gosub 102	! Select good intersection point

						if (reorder exor gs_bTurnDir) then
							put	cx,				cy,		1,
								px2,			py2,	3000 * curvedWall + 1,
								px3,			py3,	1,
								px4,			py4,	3000 * curvedWall + 1

							put	-sideSign * bx,	by,		1
						else
							put	 px1,			py1,	1,
								 px2,			py2,	3000 * curvedWall + 1,
								 px3,			py3,	1,
								 cx,			cy,		3000 * curvedWall + 1,
								-bx * sideSign,	by,		1
						endif
					else
						put	px1,			py1,	1,
							px2,			py2,	3000 * curvedWall + 1,
							px3,			py3,	1,
							px4,			py4,	3000 * curvedWall + 1

						if gs_bTurnDir exor reorder exor wallIsLeft then
							put	-sideSign * bx,	by,		1,
								-sideSign * sx,	sy,		1
						else
							put	-sideSign * sx,	sy,		1,
								-sideSign * bx,	by,		1
						endif
					endif
				else
					if gs_bTurnDir exor reorder exor wallIsLeft then
						put	px1,		py1,		1,
							px1,		pySill,		1,
							distanceX,	pySill,		1,
							distanceX + px1Slant,	py3,		1,
							px3,		py3,		1,
							px4,		py4,		1
					else
						put	distanceX + px1Slant, baseSkinLevel,	1,
							distanceX,	pySill,		1,
							px1,		pySill,		1,
							px2,		py2,		1,
							px3,		py3,		1,
							px4,		py4,		1
					endif
				endif

				penFillFg	= gs_penJointFg
				penFillBg	= gs_penJointBg
				bLocalFill	= 0
				bDrawContour = 1

				gosub 200	! Draw wallblock with contour
			else
				px1Slant = bSlantedInnerSide * bFirstSkinAtReveal * not(plugOnWindow) * gs_thkJoint * tan(revealAngle)	! Slanted Reveal

				if curvedWall then
					px1Slant = 0
				else
					if bFirstSkinAtReveal exor not(gs_bTurnDir) then
						px1Slant =  bSlantedInnerSide * not(plugOnWindow) * gs_thkJoint * tan(revealAngle)	! Slanted Reveal
					else
						if baseSkinLevel > WIDO_SILL then
							px1Slant = -bSlantedInnerSide * not(plugOnWindow) * gs_thkJoint * tan(revealAngle)	! Slanted Reveal
						else
							px1Slant = 0
						endif
					endif
				endif

				put	px1 + px1Slant,	py1,	1,
					px2,			py2,	3000 * curvedWall + 1,
					px3,			py3,	1,
					px4,			py4,	3000 * curvedWall + 1

				penFillFg	= gs_penJointFg
				penFillBg	= gs_penJointBg
				bLocalFill	= 0
				bDrawContour = 1

				gosub 200	! Draw wallblock with contour

			endif		! if bCuttedPlug then
		endif		! if gs_showJoint then
	endif		! if gs_bJoint then


! Turn Skins - Traditional Mode ================================================

	if bInclinedWall & not(iCavityClosureTurnDir = CAVITY_TURN_REFERENCE) then
		bStraightInside	 = 0
		bStraightOutside = 0
	else
		bStraightInside	 = 1
		bStraightOutside = 1
	endif
	turnThk = 0

	if gs_bTurnDir then
		startCount	= possibleSkinTurnIn + 1
		endCount	= possibleSkinTurnIn + gs_nTurn
	else
		startCount	= possibleSkinTurnOut + 1
		endCount	= possibleSkinTurnOut + gs_nTurn
	endif

	bHaveShownSkinBefore = (startCount > 1)		! Skin before the first turned skins is shown or not?
	if bHaveShownSkinBefore then
		prevSkinIdx = startCount - 1
		if gs_bTurnDir then
			idx = prevSkinIdx: gosub 10	! Get proper index
		else
			idx = WALL_SKINS_NUMBER - prevSkinIdx + 1: gosub 10	! Get proper index
		endif

		bHaveShownSkinBefore = not((GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY & WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] < EPS) | \
								   (GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) < EPS))
	endif

	for i = startCount to endCount

		if gs_bTurnDir then
			idx = i: gosub 10	! Get proper index
		else
			idx = WALL_SKINS_NUMBER - i + 1: gosub 10	! Get proper index
		endif

		skinThk = WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
		bFirst	= (i = startCount)
		bLast	= (i = endCount)

		if reorder then
			cummThk = skinCummThkRef[idx + 1]
		else
			if idx > 1 then
				cummThk = skinCummThkRef[idx - 1]
			else
				cummThk = 0
			endif
		endif


! Curved Wall ==================================================================

		if curvedWall then

			bSpecCase	= (not(bIncludeReveal) & not(wallIsLeft) & not(reorder exor gs_bTurnDir))

			if gs_bTurnDir then
				py1 = cummThk + skinThk
				slantL = slantLength - py1
			else
				py1 = cummThk
				slantL = slantLength - WALL_THICKNESS + py1
			endif

			slantX = 0

! p1 point ---------------------------------------------------------------------

			xo = 0
			yo = -WOD
			if bFirstSkinAtReveal then
				if gs_bTurnDir then
					ro = rSill - (cummThk + skinThk) * signReorder
				else
					ro = rSill - cummThk * signReorder
				endif
			else
				if gs_bTurnDir then
					ro = rBoard - (cummThk + skinThk) * signReorder
				else
					ro = rBoard - cummThk * signReorder
				endif
			endif

			if bSlantedInnerSide | bParalellInCurvedWalls then
				x1 = -bx * sideSign - (turnThk + skinThk) * vectC
				y1 =  by - (turnThk + skinThk) * vectS * signWallIsLeft
				x2 = x1 - vectS
				y2 = y1 + vectC * signWallIsLeft
			else
				alfa = alfaX + (turnThk + skinThk) * lengthToAngle + dxAngle

				x1 = 0
				y1 = -WOD
				x2 = -signWallIsLeft * sin(alfa)
				y2 =  cos(alfa) - WOD
			endif

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			px1 = cx
			py1 = cy


! Valid Skin Test --------------------------------------------------------------

			if reorder exor gs_bTurnDir then
				bSkipThisSkin = (baseSkinRadius > ro - EPS)
			else
				bSkipThisSkin = (baseSkinRadius < ro + EPS)
			endif


! p4 point ---------------------------------------------------------------------

			if bFirstSkinAtReveal then
				if gs_bTurnDir then
					ro4 = rSill - cummThk * signReorder
				else
					ro4 = rSill - (cummThk + skinThk) * signReorder
				endif
			else
				if gs_bTurnDir then
					ro4 = rBoard - cummThk * signReorder
				else
					ro4 = rBoard - (cummThk + skinThk) * signReorder
				endif
			endif
			ro = ro4

			if (bSlantedInnerSide & not(bSpecCase & bFirst)) | bParalellInCurvedWalls then
				x1 = -bx * sideSign - turnThk * vectC
				y1 =  by - turnThk * vectS* signWallIsLeft
				x2 = x1 - vectS
				y2 = y1 + vectC * signWallIsLeft
			else
				alfa = alfaX + turnThk * lengthToAngle + dxAngle

				x1 = 0
				y1 = -WOD
				x2 = -signWallIsLeft * sin(alfa)
				y2 =  cos(alfa) - WOD
			endif

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			px4 = cx
			py4 = cy


! p2 point ---------------------------------------------------------------------

			ro = baseSkinRadius

			if bSlantedInnerSide | bParalellInCurvedWalls then
				x1 = -bx * sideSign - (turnThk + skinThk) * vectC
				y1 =  by - (turnThk + skinThk) * vectS * signWallIsLeft
				x2 = x1 - vectS
				y2 = y1 + vectC * signWallIsLeft
			else
				alfa = alfaX + (turnThk + skinThk) * lengthToAngle + dxAngle

				x1 = 0
				y1 = -WOD
				x2 = -signWallIsLeft * sin(alfa)
				y2 =  cos(alfa) - WOD
			endif

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			px2 = cx
			py2 = cy


! p3 point ---------------------------------------------------------------------

			if (bSlantedInnerSide & not(bSpecCase & bFirst)) | bParalellInCurvedWalls then
				x1 = -bx * sideSign - turnThk * vectC
				y1 =  by - turnThk * vectS* signWallIsLeft
				x2 = x1 - vectS
				y2 = y1 + vectC * signWallIsLeft
			else
				alfa = alfaX + turnThk * lengthToAngle + dxAngle

				x1 = 0
				y1 = -WOD
				x2 = -signWallIsLeft * sin(alfa)
				y2 =  cos(alfa) - WOD
			endif

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			px3 = cx
			py3 = cy

			if bIncludeReveal & bFirst then
				if bNegativeTurn then
					px6 = -sideSign * bx
					py6 =  by

					px5 = -sideSign * sx
					py5 =  sy
				else
					px5 = -sideSign * bx
					py5 =  by

					px6 = -sideSign * sx
					py6 =  sy
				endif

				ro = ro4	! on the same circle as the p4 point

				alfa = alfaX - not(bNegativeTurn) * alfaJamb

				if bParalellInCurvedWalls then
					x1 = -sx * sideSign
					y1 =  sy
					x2 = x1
					y2 = y1 + 1
				else
					x1 = 0
					y1 = -WOD
					x2 = -signWallIsLeft * sin(alfa)
					y2 =  cos(alfa) - WOD
				endif

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px7 = cx
				py7 = cy

				if px4 > px7 - EPS then		! to avoid generating degenerated polygons
					px4 = px7
					py4 = py7
				endif
			endif

		else

! Straight Wall, Trapezoid Wall ================================================

			if bInclinedWall then
				inclinedWallDiffInside	= skinCummThkOpp[idx] / incH
				if idx > 1 then
					inclinedWallDiffOutside	= skinCummThkOpp[idx - 1] / incH
				else
					inclinedWallDiffOutside = 0
				endif
			endif
			slantDiffUpper = not(bFirstSkinAtReveal exor not(gs_bTurnDir)) * bSlantedInnerSide * ((turnThk + skinThk) - (turnThk + skinThk) / cos(revealAngle))
			slantDiffLower = not(bFirstSkinAtReveal exor not(gs_bTurnDir)) * bSlantedInnerSide * (turnThk - turnThk / cos(revealAngle))

			py2 = lengthSkinTurnIn
			if gs_bTurnDir then
				slantL = slantLength - py2
			else
				slantL = slantLength - WALL_THICKNESS+ py2
			endif
			px2 = distanceX + dx + turnThk + skinThk + slantL * slantX - slantDiffUpper

			if not(bStraightInside) then
				bStraightInside = (WALL_SKINS_PARAMS[idx][SKIN_THICKEN_TRAPEZOID])
			endif

			if gs_bTurnDir then
				py1 = cummThk + skinThk
				slantL = slantLength - py1
			else
				py1 = cummThk
				if bInclinedWall & not(bStraightInside) then
					py1 = WALL_THICKNESS - inclinedWallDiffInside
					py1 = py1 + (distanceX + dx + turnThk + skinThk) * incHor * sideSign * iInclDir
				endif
				slantL = slantLength - WALL_THICKNESS + py1
			endif

			if bInclinedWall & not(bStraightInside) & bSlantedInnerSide then
				x11 = 0
				y11 = WALL_THICKNESS - inclinedWallDiffInside
				x12 = x11 + incH * sideSign
				y12 = y11 + incV

				x21 = px2
				y21 = py2
				x22 = x21 + sin(revealAngle)
				y22 = y21 + cos(revealAngle)

				gosub 100	! Line - Line intersection

				px1 = cx
				py1 = cy
			else
				px1 = distanceX + dx + turnThk + skinThk + slantL * slantX - slantDiffUpper
			endif

			if gs_bTurnDir then
				bSkipThisSkin = (lengthSkinTurnIn < py1 + EPS)
			else
				bSkipThisSkin = (lengthSkinTurnIn > py1 - EPS)
			endif

			py3 = lengthSkinTurnIn
			if gs_bTurnDir then
				slantL = slantLength - py3
			else
				slantL = slantLength - WALL_THICKNESS + py3
			endif
			px3 = distanceX + dx + turnThk + slantL * slantX - slantDiffLower

			if bIncludeReveal & bFirst then
				if WIDO_SILL < EPS then
					py5 = cummThk
					px5 = distanceX + (py5 - WIDO_SILL)* tan(revealAngle)
				else
					if gs_bTurnDir exor bNegativeTurn then
						py5 = WIDO_SILL
					else
						py5 = WALL_THICKNESS - WIDO_SILL
					endif
					px5 = distanceX + bNegativeTurn * revealWidth

					if gs_bTurnDir exor bNegativeTurn then
						py6 = WIDO_SILL
					else
						py6 = WALL_THICKNESS - WIDO_SILL
					endif
					px6 = distanceX - not(bNegativeTurn) * revealWidth

					if gs_bTurnDir then
						py7 = cummThk
					else
						py7 = cummThk + skinThk
					endif
					px7 = distanceX - not(bNegativeTurn) * revealWidth
				endif
			endif

			if gs_bTurnDir then
				py4 = cummThk
				slantL = slantLength - py4
			else
				py4 = cummThk + skinThk
				if bInclinedWall & not(bStraightOutside)then
					py4 = WALL_THICKNESS - inclinedWallDiffOutside
					py4 = py4 + (distanceX + dx + turnThk) * incHor * sideSign * iInclDir
				endif
				slantL = slantLength - WALL_THICKNESS + py4
			endif

			if bInclinedWall & not(bStraightOutside) & bSlantedInnerSide then
				x11 = 0
				y11 = WALL_THICKNESS - inclinedWallDiffOutside
				x12 = x11 + incH * sideSign
				y12 = y11 + incV

				x21 = px3
				y21 = py3
				x22 = x21 + sin(revealAngle)
				y22 = y21 + cos(revealAngle)

				gosub 100	! Line - Line intersection

				px4 = cx
				py4 = cy
			else
				px4 = distanceX + dx + turnThk + (slantL)* slantX - slantDiffLower
			endif

			if not(bStraightOutside) then
				bStraightOutside = (WALL_SKINS_PARAMS[idx][SKIN_THICKEN_TRAPEZOID])
	        endif
		endif

! Draw the turned skins ========================================================

		bShowSkin = not(GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY & WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] < EPS)

		if not(bSkipThisSkin) & bShowSkin then

			skinFillType		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL])
			skinFillFgPen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_PEN])
			skinFillBgPen		= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_BACK_PEN])
			skinFillOrientation	= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_ORIENTATION])

			fill skinFillType
			bLocalFill	= skinFillOrientation
			penFillFg	= skinFillFgPen
			penFillBg	= skinFillBgPen

			if gs_bTurnDir then
				bCond = (baseSkinLevel - gs_thkJoint < WIDO_SILL)
			else
				bCond = (baseSkinLevel + gs_thkJoint < WIDO_SILL)
			endif

			if bFirst & abs(slantX) > EPS & bCond then

				if gs_bTurnDir then
					boardY = by + WALL_THICKNESS - WIDO_SILL
				else
					boardY = by + WIDO_SILL
				endif
				put	px1,			py1,	0,
					px2,			py2,	0,
					bx * sideSign,	py3,	0,
					bx * sideSign,	boardY, 0,
					px4,			py4,	0
			else
				if bIncludeReveal & bFirst then
					if WIDO_SILL < EPS then
						put	px1,	py1,	0,
							px2,	py2,	0,
							px3,	py3,	0,
							px5,	py5,	0,
							px4,	py4,	0
					else
						put	px1,	py1,	0,
							px2,	py2,	0,
							px3,	py3,	3000 * curvedWall,
							px5,	py5,	0,
							px6,	py6,	0,
							px7,	py7,	0,
							px4,	py4,	3000 * curvedWall
					endif
				else
					if curvedWall & not(bWndCurved) & bFirst & (iRevealType <> REVEAL_NEGATIVE) & (iRevealType > REVEAL_NO) & (py3 - EPS < by) & (py4 + EPS > by) then
						xo = 0
						yo = -WOD
						ro = baseSkinRadius

						x1 = 0
						y1 = by
						x2 = 1
						y2 = by

						gosub 101	! Circle - Line intersection
						gosub 102	! Select good intersection point

						put	 px1,			py1,	0,
							 px2,			py2,	0,
							 cx,			cy,		3000,
							-sx * sideSign,	sy,		0,
							 px4,			py4,	0

						px3 = -sx * sideSign
						py3 =  sy
					else
						put	px1,	py1,	0,
							px2,	py2,	0,
							px3,	py3,	3000 * curvedWall,
							px4,	py4,	0
					endif
				endif
			endif

			bDrawContour = 0
			gosub 200	! Draw wallblock

			bShowLine = 0
			if gs_bTurnDir then
				tempPen		 = round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN])
				tempLineType = round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE])
			else
				tempPen		 = round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
				tempLineType = round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])
			endif
			if tempPen > EPS then
				pen			tempPen
				line_type	tempLineType
				if GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY then
					line_property LINE_PROPERTY_CONTOUR
				else
					line_property LINE_PROPERTY_INNER
				endif

				wallline2	px1,py1, px2,py2

				if not(gs_bJoint) or gs_bJoint * not(gs_showJoint) then	! Contonouous mode
					if not(bForceContinousMode) & (baseSkinFillType <> skinFillType | baseSkinFillFgPen <> skinFillFgPen | baseSkinFillBgPen <> skinFillBgPen | baseSkinFillOrientation <> skinFillOrientation) then
						if baseSkinContLinePen > EPS then
						if not(gs_thkJoint) then pen baseSkinContLinePen
							line_type	baseSkinContLineType

							wallline2 px2,py2, px3,py3
						endif
					endif
				endif
			endif
		endif

		if bFirst & bShowSkin then
			if gs_bTurnDir then
				tempPen		 = round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
				tempLineType = round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])
			else
				tempPen		 = round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN])
				tempLineType = round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE])
			endif
			if tempPen > EPS then
				pen			tempPen
				line_type	tempLineType
				if bHaveShownSkinBefore then
					line_property LINE_PROPERTY_INNER
				else
					line_property LINE_PROPERTY_CONTOUR
				endif

				if not(curvedWall) | (py4 < py3 exor wallIsLeft exor reorder) then
					if abs(slantX) < EPS then
						if bIncludeReveal then
							if WIDO_SILL < EPS then
								wallline2	px3,py3, px5,py5
							else
								if ((wallIsLeft exor reorder) & maxSkinTurnIn = 0) | (not(wallIsLeft exor reorder) & maxSkinTurnOut = 0) then
									line_property LINE_PROPERTY_CONTOUR
								endif

								if not(bInclinedWall & not(gs_bTurnDir)) then
									! because the top of the "bIncludeReveal" polygon does not fit to the inclined wall's slanted side
									wallline2	px4,py4, px7,py7
								endif
							endif
						else
							wallline2	px3,py3, px4,py4
						endif
					endif
				else
					if curvedWall & bIncludeReveal then
						R = sqr(px4^2 + (py4 + WOD)^2)

						vx = px4
						vy = py4 + WOD
						gosub 103	! Direction Angle
						alpha = angle

						vx = px7
						vy = py7 + WOD
						gosub 103	! Direction Angle
						beta = angle

						if abs(alpha - beta) > EPS then
							wallarc2 0,-WOD, R, min(alpha,beta), max(alpha,beta)
						endif
					endif
				endif

				if iRevealType = REVEAL_NEGATIVE then

					line_property LINE_PROPERTY_INNER

					if curvedWall & bWndCurved then
						R = sqr(bx^2 + (by + WOD)^2)

						vx = -bx * sideSign
						vy =  by + WOD
						gosub 103	! Direction Angle
						alpha = angle

						vx = -sx * sideSign
						vy =  sy + WOD
						gosub 103	! Direction Angle
						beta = angle

						if abs(alpha - beta) > EPS then
							wallarc2 0,-WOD, R, min(alpha,beta), max(alpha,beta)
						endif
					else
						if curvedWall then
							revealY = by
							signTemp = -1
						else
							signTemp = 1
							if reorder exor wallIsLeft then
								revealY = by + WIDO_SILL
							else
								revealY = by + WALL_THICKNESS - WIDO_SILL
							endif
						endif

						wallline2	bx * signTemp * sideSign, revealY,
									sx * signTemp  * sideSign, revealY
						if bDrawObjContourIn | bDrawObjContourOut then
							line2	bx * signTemp  * sideSign, revealY,
									sx * signTemp  * sideSign, revealY
						endif
					endif
				endif
			endif
		endif

		turnThk = turnThk + skinThk
	next i
return


! ==============================================================================
!		Prefabricated Cavity Closure
! ------------------------------------------------------------------------------
! Input variables:
!	possibleSkinTurnIn:		number of possible plaster skins at the Outside Face
!	possibleSkinTurnOut:	number of possible plaster skins at the Inside Face
!	distanceX:				horizontal distance from the original origo
!	alfaX:					alfa x in case of curved walls (alfaX > 0)
!	alfaJamb:				jamb alfa (alfaJamb > 0)
!	revealWidth:			width of the reveal
!	skinCummThkRef:			precalculated cummulative skin thickness from the Outside Face
! ==============================================================================

3000:
	if lastCoreSkin = 0 then
		return
	endif

	nSkins = WALL_SKINS_NUMBER - possibleSkinTurnOut - possibleSkinTurnIn
	if nSkins < 3 then return

	bSlantedInnerSide	= (iRevealType = REVEAL_SLANTED | iRevealType = REVEAL_SPLAYED)
	bNegativeReveal		= (iRevealType = REVEAL_NEGATIVE)

	fill gs_fillPlug
	pen gs_penPlug
	line_type gs_ltPlug
	line_property LINE_PROPERTY_INNER

	idx = possibleSkinTurnIn + 1
	gosub 10	! Get proper index
	begH = skinCummThkRef[idx]
	properBegIdx = idx

	idx = min(lastCoreSkin - 1, possibleSkinTurnIn + nSkins - 1)

	if idx < 1 then
		return
	endif

	gosub 10	! Get proper index

	endH = skinCummThkRef[idx]
	properEndIdx = idx

	if abs(endH - begH) < EPS then return

	if curvedWall then

! Curved Wall ==================================================================

		rWindowEdge = sqr((bx * sideSign)^2 + (by + WOD)^2)
		rRevealEdge = sqr((sx * sideSign)^2 + (sy + WOD)^2)

		if reorder then
			rBegH = min(rSill, rBoard) + begH
			rEndH = min(rSill, rBoard) + endH
		else
			rBegH = max(rSill, rBoard) - begH
			rEndH = max(rSill, rBoard) - endH
		endif
		plugAngle = gs_widthPlug * (180 / max(rBegH, rEndH) / PI)

		if wallIsLeft exor (iRevealType = REVEAL_NEGATIVE) then
			refH = min(rBegH, rEndH)
			oppH = max(rBegH, rEndH)
		else
			refH = max(rBegH, rEndH)
			oppH = min(rBegH, rEndH)
		endif

! Curved walls - Slanted Reveal ================================================

		if bSlantedInnerSide | bParalellInCurvedWalls then

			xo = 0
			yo = -WOD
			ro = refH

			if wallIsLeft then

				bPullBackPlug = 0

				if rWindowEdge < refH + EPS then
					bSlantedPlug = 0
				else
					bSlantedPlug = 1
				endif

				if (rWindowEdge < oppH & rWindowEdge > refH) then
					bCuttedPlug = 1
				else
					bCuttedPlug = 0
				endif
			else
				bPullBackPlug = (rWindowEdge > refH + EPS & rRevealEdge < refH + EPS)

				if rWindowEdge > refH + EPS & rRevealEdge > refH + EPS then
					bSlantedPlug = 0
				else
					bSlantedPlug = 1
				endif

				if (rWindowEdge > oppH & rWindowEdge < refH) | (rRevealEdge > oppH & rRevealEdge < refH) then
					bCuttedPlug = 1
				else
					bCuttedPlug = 0
				endif
			endif

			if bParalellInCurvedWalls then
				bCuttedPlug = 0
				bSlantedPlug =1
			endif

			if bSlantedPlug & not(bPullBackPlug) then
				if bWndCurved then
					x1 = -rSillLine * sin(alfaX)
					y1 = iArchSign * (-abs(WOD) + rSillLine * cos(alfaX))
					x2 = x1 - sin(revealAngle)
					y2 = y1 - cos(revealAngle)
				else
					x1 = -distanceX
					y1 = 0
					x2 = -distanceX - wallThkOppSide * tan(revealAngle)
					y2 = -wallThkOppSide
				endif

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point

				alfaPlug = -signWallIsLeft * atn(cx / (WOD + cy))

				ro = oppH
				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point

				alfaPlugOpp = -signWallIsLeft * atn(cx / (WOD + cy))

				sin1 = sin(alfaPlug)
				cos1 = cos(alfaPlug) * signWallIsLeft
				sin2 = sin(alfaPlug + plugAngle)
				cos2 = cos(alfaPlug + plugAngle) * signWallIsLeft
				sin3 = sin(alfaPlugOpp)
				cos3 = cos(alfaPlugOpp) * signWallIsLeft
				if bCuttedPlug then
					if bWndCurved then
						alpha = atn(bx * sideSign / (by + WOD))
					else
						alpha = atn(distanceX / WOD)
					endif
					sin4 = sin(alpha)
					cos4 = cos(alpha)
				endif

				if wallIsLeft exor reorder then
					if bCuttedPlug then
						x1 = -rBegH * sin4 * signWallIsLeft
						y1 = -WOD + rBegH * cos4 * signWallIsLeft
					else
						x1 = -rBegH * sin3
						y1 = -WOD + rBegH * cos3
					endif
				else
					x1 = -rBegH * sin1
					y1 = -WOD + rBegH * cos1
				endif

				x2 = -rBegH * sin2
				y2 = -WOD + rBegH * cos2

				x3 = -rEndH * sin2
				y3 = -WOD + rEndH * cos2

				if bCuttedPlug then
					if wallIsLeft exor reorder then
						x4 = -rEndH * sin1
						y4 = -WOD + rEndH * cos1

						x5 = -bx * sideSign
						y5 = by
					else
						x4 = -rEndH * sin4 * signWallIsLeft
						y4 = -WOD + rEndH * cos4 * signWallIsLeft

						x5 = -bx * sideSign
						y5 = by
					endif
				else
					if wallIsLeft exor reorder then
						x4 = -rEndH * sin1
						y4 = -WOD + rEndH * cos1
					else
						x4 = -rEndH * sin3
						y4 = -WOD + rEndH * cos3
					endif
				endif

				put x1,	y1,	1,
					x2,	y2,	3001,
					x3,	y3,	1,
					x4,	y4,	3001

				if bCuttedPlug then
					put x5,y5, 1
				endif

			else	! if bSlantedPlug & not(bPullBackPlug) then

				if bPullBackPlug then
					alfaPlug = abs(atn(bx / (by + WOD)))
				else
					alfaPlug = alfaX - alfaJamb
				endif

				sin1 = sin(alfaPlug)
				cos1 = cos(alfaPlug) * signWallIsLeft
				sin2 = sin(alfaPlug + plugAngle)
				cos2 = cos(alfaPlug + plugAngle) * signWallIsLeft

				x1 = -rBegH * sin1
				y1 = -WOD + rBegH * cos1

				x2 = -rBegH * sin2
				y2 = -WOD + rBegH * cos2

				x3 = -rEndH * sin2
				y3 = -WOD + rEndH * cos2

				x4 = -rEndH * sin1
				y4 = -WOD + rEndH * cos1

				put x1,y1, 1,
					x2,y2, 3001,
					x3,y3, 1,
					x4,y4, 3001
			endif	! if bSlantedPlug & not(bPullBackPlug) then ... else

		endif	! if bSlantedInnerSide then

! bPullBackPlug ================================================================

		if bWndCurved then
			if bNegativeReveal then
				if wallIsLeft then
					bPullBackPlug = (max(rBegH, rEndH) <= rSillLine + EPS)
				else
					bPullBackPlug = (min(rBegH, rEndH) >= rSillLine - EPS)
				endif
			else
				if wallIsLeft then
					bPullBackPlug = (min(rBegH, rEndH) <= rSillLine - EPS)
				else
					bPullBackPlug = (max(rBegH, rEndH) >= rSillLine + EPS)
				endif
			endif
		else
			if wallIsLeft then
				rCorner	= max(rWindowEdge, rRevealEdge)
			else
				rCorner	= min(rWindowEdge, rRevealEdge)
			endif

			if bNegativeReveal then
				if wallIsLeft then
					bPullBackPlug = (max(rBegH, rEndH) <= rCorner + EPS)
				else
					bPullBackPlug = (min(rBegH, rEndH) >= rCorner + EPS)
				endif
			else
				rWindowInnerEdge = sqr((distanceX)^2 + (WOD - WIDO_FRAME_THICKNESS)^2)

				if wallIsLeft then
					bPullBackPlug = ((min(rBegH, rEndH) < rCorner + EPS) | (min(rBegH, rEndH) < rWindowInnerEdge + EPS))
				else
					bPullBackPlug = ((max(rBegH, rEndH) > rCorner + EPS) | (max(rBegH, rEndH) > rWindowInnerEdge + EPS))
				endif
			endif
		endif

! Curved walls - not Slanted Reveal ============================================

		if not(bSlantedInnerSide | bParalellInCurvedWalls ) then

			if bPullBackPlug then
				if abs(bx) < abs(sx) exor bNegativeReveal then
					alfaPlug = abs(atn(abs(sx) / (WOD + sy)))
				else
					alfaPlug = abs(atn(abs(bx) / (WOD + by)))
				endif
			else
				alfaPlug = alfaX - alfaJamb
			endif

			alfaPlugOpp = alfaPlug

			sin1 = sin(alfaPlug)
			cos1 = cos(alfaPlug) * signWallIsLeft
			sin2 = sin(alfaPlug + plugAngle)
			cos2 = cos(alfaPlug + plugAngle) * signWallIsLeft
			sin3 = sin(alfaPlugOpp)
			cos3 = cos(alfaPlugOpp) * signWallIsLeft

			if wallIsLeft then
				x1 = -rBegH * sin1
				y1 = -WOD + rBegH * cos1
			else
				x1 = -rBegH * sin3
				y1 = -WOD + rBegH * cos3
			endif

			x2 = -rBegH * sin2
			y2 = -WOD + rBegH * cos2

			x3 = -rEndH * sin2
			y3 = -WOD + rEndH * cos2

			if wallIsLeft then
				x4 = -rEndH * sin3
				y4 = -WOD + rEndH * cos3
			else
				x4 = -rEndH * sin1
				y4 = -WOD + rEndH * cos1
			endif

			put x1,y1, 1,
				x2,y2, 3001,
				x3,y3, 1,
				x4,y4, 3001
		endif	! if bSlantedInnerSide then

	else	! if curvedWall then


! Straight and Trapezoid Wall ==================================================

		if wallIsLeft exor bNegativeReveal exor reorder then
			if iRevealType = REVEAL_NEGATIVE then
				revealLevel = WALL_THICKNESS - WIDO_SILL
				bPullBackPlug = (begH + EPS < revealLevel)
			else
				revealLevel = WIDO_SILL
				bPullBackPlug = (endH - EPS > revealLevel)
			endif
		else
			if iRevealType = REVEAL_NEGATIVE then
				revealLevel = WIDO_SILL
			else
				revealLevel = WALL_THICKNESS - WIDO_SILL
			endif
			bPullBackPlug = (begH + EPS < revealLevel)
		endif

		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
			posPlug = distanceX
			bPullBackPlug = 0
		endif
		if iRevealType = REVEAL_POSITIVE then
			posPlug = distanceX - not(bPullBackPlug) * revealWidth
		endif
		if iRevealType = REVEAL_NEGATIVE then
			posPlug = distanceX + bPullBackPlug * revealWidth
		endif
		if iRevealType = REVEAL_SLANTED then
			posPlug = distanceX - not(bPullBackPlug) * revealWidth
		endif

		if bSlantedInnerSide & bPullBackPlug then
			if wallIsLeft exor reorder then
				sillLine = WIDO_SILL
			else
				sillLine = WALL_THICKNESS - WIDO_SILL
			endif

			if wallIsLeft exor reorder then
				refH = endH
				oppH = begH
			else
				refH = begH
				oppH = endH
			endif

			x11 = distanceX
			y11 = sillLine
			x12 = x11 + sin(revealAngle)
			y12 = y11 + signWallIsLeft * signReorder * cos(revealAngle)

			x21 = 0
			y21 = refH
			x22 = 1
			y22 = refH

			gosub 100	! Line - Line intersection

			if sillLine < endH & sillLine > begH then
				put posPlug, sillLine, 1,
					posPlug, oppH, 1
			else
				put cx - (endH-begH) * tan(revealAngle), oppH, 1
			endif

			put	cx + gs_widthPlug, oppH, 1,
				cx + gs_widthPlug, refH, 1,
				cx, refH, 1
		else
			put	posPlug, begH, 1,
				posPlug, endH, 1,
				posPlug + gs_widthPlug, endH, 1,
				posPlug + gs_widthPlug, begH, 1
		endif

	endif	! if curvedWall then

! Draw Insulation Plug =========================================================

	bLocalFill	= 0
	penFillFg	= gs_penPlugFg
	penFillBg	= gs_penPlugBg
	bDrawContour = 1

	gosub 200	! Draw wallblock with contour


! Draw wall skin part ==========================================================

	if (wallIsLeft exor bNegativeReveal exor reorder) | bInclinedWall then
		if iRevealType = REVEAL_NEGATIVE & bInclinedWall then
			y1 = revealLevel
			y2 = endH
			if reorder then
				idx = properEndIdx - 1
			else
				idx = properEndIdx + 1
			endif
		else
			y1 = begH
			y2 = revealLevel
			idx = properBegIdx
		endif
	else
		y1 = revealLevel
		y2 = endH
		if reorder then
			idx = properEndIdx - 1
		else
			idx = properEndIdx + 1
		endif
	endif

	bShowSkin = not(GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY & WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] < EPS)

	if bShowSkin then
		if curvedWall then
			if (bPullBackPlug exor bNegativeReveal) & iRevealType > REVEAL_NO then
				aWindowEdge = atn(bx * sideSign / (by + WOD))
				aRevealEdge = atn(sx * sideSign / (sy + WOD))

				px1 = -bx * sideSign
				py1 =  by

				px2 = -sx * sideSign
				py2 =  sy

				if bParalellInCurvedWalls then
					xo = 0
					yo = -WOD
					ro = oppH

					x1 = px2
					y1 = py2
					x2 = x1
					y2 = y1 + 1

					gosub 101	! Circle - Line intersection
					gosub 102	! Select good intersection point
					px3 = cx
					py3 = cy

					x1 = px1
					y1 = py1
					x2 = x1
					y2 = y1 + 1

					gosub 101	! Circle - Line intersection
					gosub 102	! Select good intersection point
					px4 = cx
					py4 = cy
				else
					px3 = -signWallIsLeft * oppH * sin(aRevealEdge)
					py3 = -WOD + signWallIsLeft * oppH * cos(aRevealEdge)

					px4 = -signWallIsLeft * oppH * sin(aWindowEdge)
					py4 = -WOD + signWallIsLeft * oppH * cos(aWindowEdge)
				endif

				bSkip4 = (abs(px1 - px4) < EPS & abs(py1 - py4) < EPS)		! Avoid generating invalid polygon

				put	px1, py1, 0,
					px2, py2, 3000 * bWndCurved + 1

				if wallIsLeft then
					if bWndCurved then
						if not(bNegativeReveal) & oppH > rWindowEdge + EPS & refH < rWindowEdge - EPS then
							put px3, py3, 0,
								px4, py4, 3000
						endif
						if bNegativeReveal & refH > rWindowEdge + EPS & oppH < rWindowEdge - EPS then
							put px3, py3, 0,
								px4, py4, 3000
						endif
					else
						bOutPoint = 0
						if py3 > py2 exor bNegativeReveal then
							put px3, py3, 0
							bOutPoint = 1
						endif
						if (py4 > py1 exor bNegativeReveal) & not(bSkip4) then
							put px4, py4, 3000 * bOutPoint
						endif
					endif
				else
					if bWndCurved then
						if not(bNegativeReveal) & refH > rWindowEdge + EPS & oppH < rWindowEdge - EPS then
							put px3, py3, 0,
								px4, py4, 3000
						endif
						if bNegativeReveal & oppH > rWindowEdge + EPS & refH < rWindowEdge - EPS then
							put px3, py3, 0,
								px4, py4, 3000
						endif
					else
						bOutPoint = 0
						if py3 > py2 exor bNegativeReveal then
							put px3, py3, 0
							bOutPoint = 1
						endif
						if (py4 > py1 exor bNegativeReveal) & not(bSkip4) then
							put px4, py4, 3000 * bOutPoint
						endif
					endif
				endif

				fill		  round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL])
				bLocalFill	= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_ORIENTATION])
				penFillFg	= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_PEN])
				penFillBg	= round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_BACK_PEN])

				if WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN] > EPS then
					pen WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN]
					line_type WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE]
					line_property LINE_PROPERTY_INNER
					bDrawContour = 1
				else
					bDrawContour = 0
				endif

				gosub 200	! Draw wallblock with contour
			endif

		else	! if curvedWall then

			if bPullBackPlug then
				x1 = distanceX
				if iRevealType = REVEAL_POSITIVE then x2 = distanceX - revealWidth
				if iRevealType = REVEAL_NEGATIVE then x2 = distanceX + revealWidth
				if iRevealType = REVEAL_SLANTED  then x2 = distanceX - revealWidth

				if y2 > y1 then
					fill		 WALL_SKINS_PARAMS[idx][SKIN_FILL]
					bLocalFill = round_int(WALL_SKINS_PARAMS[idx][SKIN_FILL_ORIENTATION])
					wallblock2 4, 2 + 24 * bLocalFill + 32,
						WALL_SKINS_PARAMS[idx][SKIN_FILL_PEN],
						WALL_SKINS_PARAMS[idx][SKIN_FILL_BACK_PEN],
						0,0,0,
						x1, y1, 1,
						x1, y2, 1,
						x2, y2, 1,
						x2, y1, 1
				endif

				if WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN] > EPS then
					pen WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN]
					line_type WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE]
					line_property LINE_PROPERTY_INNER

					if (wallIsLeft exor bNegativeReveal exor reorder) then
						wallline2 x1,y2, x2,y2
					else
						wallline2 x1,y1, x2,y1
					endif
				endif
			endif

		endif	! if curvedWall then
	endif
return



! ==============================================================================
! Wall Contour Lines
! ------------------------------------------------------------------------------
! Input variables:
! ==============================================================================

4000:

	if (wallIsLeft exor reorder) then
		if GLOB_STRUCTURE_DISPLAY = STRUCTURE_ENTIRE_STRUCTURE then
			bPlasterAtSill	= (nSkinTurnIn  > 0)
			bPlasterAtBoard	= (nSkinTurnOut > 0)

			thkPlasterAtSill	= thkSkinTurnIn
			thkPlasterAtBoard	= thkSkinTurnOut
		else
			bPlasterAtSill	= (nSkinTurnIn  - nFinishSkinTurnIn  > 0)
			bPlasterAtBoard	= (nSkinTurnOut - nFinishSkinTurnOut > 0)

			thkPlasterAtSill	= thkSkinTurnIn  - thkFinishSkinTurnIn
			thkPlasterAtBoard	= thkSkinTurnOut - thkFinishSkinTurnOut
		endif
	else
		if GLOB_STRUCTURE_DISPLAY = STRUCTURE_ENTIRE_STRUCTURE then
			bPlasterAtSill	= (nSkinTurnOut > 0)
			bPlasterAtBoard	= (nSkinTurnIn  > 0)

			thkPlasterAtSill	= thkSkinTurnOut
			thkPlasterAtBoard	= thkSkinTurnIn
		else
			bPlasterAtSill	= (nSkinTurnOut - nFinishSkinTurnOut > 0)
			bPlasterAtBoard	= (nSkinTurnIn  - nFinishSkinTurnIn  > 0)

			thkPlasterAtSill	= thkSkinTurnOut - thkFinishSkinTurnOut
			thkPlasterAtBoard	= thkSkinTurnIn  - thkFinishSkinTurnIn
		endif
	endif

	bNeedContourAtSill	= not(bCompositeWall) | not(bPlasterAtSill)
	bNeedContourAtBoard	= not(bCompositeWall) | not(bPlasterAtBoard)

	bDrawFrameContourAtSill = (bDrawObjContourIn | bDrawObjContourOut) | bPlasterAtSill

	if curvedWall then
		if bParalellInCurvedWalls then
			xo = 0
			yo = -WOD
			ro = rSill + ySign * offsetSill

			x1 = sx
			y1 = sy
			x2 = x1
			y2 = y1 + 1

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			px1 = cx
			py1 = cy
		else
			if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
				px1 = sideSign * (rSill + ySign * offsetSill) * sin(alfaX)
				py1 = -WOD - ySign * (rSill + ySign * offsetSill) * cos(alfaX)
			else
				px1 = sideSign * (rSill + ySign * offsetSill) * sin(alfaX - alfaJamb)
				py1 = -WOD - ySign * (rSill + ySign * offsetSill) * cos(alfaX - alfaJamb)
			endif
		endif

		px3 = bx
		py3 = by

		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE then
			if bParalellInCurvedWalls then
				xo = 0
				yo = -WOD
				ro = rBoard - ySign * offsetBoard

				x1 = bx
				y1 = by
				x2 = x1
				y2 = y1 + 1

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px2 = cx
				py2 = cy
			else
				px2 = sideSign * (rBoard - ySign * offsetBoard) * sin(alfaX)
				py2 = -WOD - ySign * (rBoard - ySign * offsetBoard) * cos(alfaX)

				if offsetSill > EPS & not(bDrawFrameContour) then
					cx = sideSign * (rSill + ySign * offsetSill) * sin(alfaX)
					cy = -WOD - ySign * (rSill + ySign * offsetSill) * cos(alfaX)
					if cy < py3 then
						px3 = cx
						py3 = cy
					endif
				endif
			endif

			if bWndCurved then
				px5 = bx - signWallIsLeft * sideSign * WIDO_FRAME_THICKNESS * sin(alfaX)
				py5 = by - WIDO_FRAME_THICKNESS * cos(alfaX)
			else
				if wallIsLeft then
					px5 = sideSign * distanceX
					py5 = -WIDO_FRAME_THICKNESS
				else
					px5 = bx + sideSign * (WIDO_FRAME_THICKNESS * tan(alfaX))
					py5 = -WIDO_FRAME_THICKNESS
				endif

				if bWindowSymbolAtMiddle then		! CHI Special
					dy = (WALL_THICKNESS - WIDO_FRAME_THICKNESS) / 2 - WIDO_SILL
					px5 = px5 - dy * signWallIsLeft * sideSign * tan(alfaX)
					py5 = py5 - dy
				endif

			endif
		endif

		if bWindowSymbolAtMiddle then		! CHI Special
			dy = (WALL_THICKNESS - WIDO_FRAME_THICKNESS) / 2 - WIDO_SILL
			px3 = px3 - dy * signWallIsLeft * sideSign * tan(alfaX)
			py3 = py3 - dy
		endif

		if bWndCurved then
			if iRevealType = REVEAL_NEGATIVE then
				px4 = sx
				py4 = sy
			else
				xo = 0
				yo = -WOD
				ro = rSillLine

				if bParalellInCurvedWalls then
					x1 = sx - sideSign * thkPlasterAtSill
					y1 = sy + signWallIsLeft * thkPlasterAtSill
					x2 = x1
					y2 = y1 + 1
				else
					x1 = sx - sideSign * thkPlasterAtSill * cos(alfaX - alfaJamb)
					y1 = sy + signWallIsLeft * thkPlasterAtSill * sin(alfaX - alfaJamb)
					x2 = x1 + signWallIsLeft * sideSign * sin(alfaX - alfaJamb)
					y2 = y1 + cos(alfaX - alfaJamb)
				endif

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px4 = cx
				py4 = cy
			endif
		else
			if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_SLANTED then
				if bParalellInCurvedWalls then
					px4 = sx - sideSign * thkPlasterAtSill
					py4 = sy
				else
					px4 = sx - sideSign * thkPlasterAtSill / cos(alfaX)
					py4 = sy
				endif
			else
				px4 = sx
				py4 = sy
			endif
		endif

		if iRevealType = REVEAL_SLANTED then
			xo = 0
			yo = -WOD
			ro = rBoard - ySign * offsetBoard

			x1 = bx
			y1 = by
			x2 = x1 - sideSign * sin(revealAngle)
			y2 = y1 + cos(revealAngle)

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			px2 = cx
			py2 = cy

			if offsetSill > EPS & not(bDrawFrameContour) then
				xo = 0
				yo = -WOD
				ro = rSill + ySign * offsetSill

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				if cy < py3 then
					px3 = cx
					py3 = cy
				endif
			endif

			if bWndCurved then
				ro = rSillLine - signWallIsLeft * WIDO_FRAME_THICKNESS

				gosub 101	! Circle - Line intersection
				gosub 102	! Select good intersection point
				px5 = cx
				py5 = cy
			else
				px5 = sideSign * (distanceX + WIDO_FRAME_THICKNESS * tan(revealAngle))
				py5 = -WIDO_FRAME_THICKNESS
			endif
		endif

		if iRevealType = REVEAL_SLANTED then
			alpha = revealAngle
			signTemp = -1
		else
			alpha = alfaX
			signTemp = signWallIsLeft
		endif
		if bWndCurved then
			xo = 0
			yo = -WOD
			ro = rSillLine - signWallIsLeft * WIDO_FRAME_THICKNESS

			if bParalellInCurvedWalls then
				x1 = bx - sideSign * thkPlasterAtBoard
				y1 = by
				x2 = x1
				y2 = y1 + 1
			else
				x1 = bx - sideSign * thkPlasterAtBoard * cos(alpha)
				y1 = by - thkPlasterAtBoard * sin(alpha)
				x2 = x1 + signTemp * sideSign * sin(alpha)
				y2 = y1 + cos(alpha)
			endif

			gosub 101	! Circle - Line intersection
			gosub 102	! Select good intersection point
			px6 = cx
			py6 = cy
		else
			if bParalellInCurvedWalls then
				px6 = px5 - sideSign * thkPlasterAtBoard
				py6 = py5
			else
				px6 = px5 - sideSign * thkPlasterAtBoard / cos(alpha)
				py6 = py5
			endif
		endif
	else
		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
			px1 = sideSign * (distanceX - thkPlasterAtSill)
			py1 = WIDO_SILL - offsetSill
		endif
		if iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_SLANTED then
			px1 = sideSign * (distanceX - revealWidth - thkPlasterAtSill)
			py1 = WIDO_SILL - offsetSill
		endif
		if iRevealType = REVEAL_NEGATIVE then
			px1 = sideSign * (distanceX + revealWidth - thkPlasterAtSill)
			py1 = WIDO_SILL - offsetSill
		endif

		px3 = sideSign * distanceX
		py3 = 0

		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE then
			px2 = sideSign * distanceX
			if bInclinedWall then
				py2 = -WALL_THICKNESS + WIDO_SILL - sideSign * distanceX * iInclDir * tan(WALL_INCL) + offsetBoard / incH
			else
				py2 = -WALL_THICKNESS + WIDO_SILL - sideSign * distanceX * iInclDir * tan(WALL_INCL) + offsetBoard
			endif

			if offsetSill > EPS & not(bDrawFrameContour) then
				cx = px2
				cy = WIDO_SILL - offsetSill
				if cy < py3 then
					px3 = cx
					py3 = cy
				endif
			endif

			px5 = sideSign * distanceX
			py5 = -WIDO_FRAME_THICKNESS

			if bWindowSymbolAtMiddle then		! CHI Special
				dy = (WALL_THICKNESS - WIDO_FRAME_THICKNESS) / 2 - WIDO_SILL
				py5 = py5 - dy
			endif
		endif

		if iRevealType = REVEAL_SLANTED then
			if bInclinedWall then
				x11 = 0
				y11 = -WALL_THICKNESS + WIDO_SILL + offsetBoard / incH
				x12 = x11 + incH
				y12 = y11 - incV

				x21 = sideSign * distanceX
				y21 = 0
				x22 = x21 - sideSign * sin(revealAngle)
				y22 = y21 + cos(revealAngle)

				gosub 100		! Line - Line intersection
				px2 = cx
				py2 = cy

				if offsetSill > EPS & not(bDrawFrameContour) then
					x11 = 0
					y11 = WIDO_SILL - offsetSill
					x12 = x11 + 1
					y12 = y11

					gosub 100		! Line - Line intersection
					if cy < py3 then
						px3 = cx
						py3 = cy
					endif
				endif
			else
				px2 = sideSign * (distanceX + (WALL_THICKNESS - WIDO_SILL - offsetBoard) * tan(revealAngle))
				py2 = -WALL_THICKNESS + WIDO_SILL + distanceX * iInclDir * tan(WALL_INCL) + offsetBoard

				if offsetSill > EPS & not(bDrawFrameContour) then
					cx = sideSign * (distanceX + (-WIDO_SILL + offsetSill) * tan(revealAngle))
					cy = WIDO_SILL - offsetSill
					if cy < py3 then
						px3 = cx
						py3 = cy
					endif
				endif
			endif

			px5 = sideSign * (distanceX + WIDO_FRAME_THICKNESS * tan(revealAngle))
			py5 = -WIDO_FRAME_THICKNESS
		endif

		if bWindowSymbolAtMiddle then		! CHI Special
			dy = (WALL_THICKNESS - WIDO_FRAME_THICKNESS) / 2 - WIDO_SILL
			py3 = py3 - dy
		endif

		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
			px4 = px3 - sideSign * thkPlasterAtSill
			py4 = py3
		endif
		if iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_SLANTED then
			px4 = sideSign * (distanceX - revealWidth - thkPlasterAtSill)
			py4 = 0
		endif
		if iRevealType = REVEAL_NEGATIVE then
			px4 = sideSign * (distanceX + revealWidth)
			py4 = 0
		endif

		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE then
			px6 = px5 - sideSign * thkPlasterAtBoard
			py6 = py5
		endif
		if iRevealType = REVEAL_SLANTED then
			px6 = px5 - sideSign * thkPlasterAtBoard / cos(revealAngle)
			py6 = py5
		endif
	endif

	if bCompositeWall then
		idx = 1: gosub 10	! Get proper index
		penSkinContourIn	= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_PEN])
		ltSkinContourIn		= round_int(WALL_SKINS_PARAMS[idx][SKIN_UPPER_LINE_TYPE])

		idx = WALL_SKINS_NUMBER: gosub 10	! Get proper index
		penSkinContourOut	= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_PEN])
		ltSkinContourOut	= round_int(WALL_SKINS_PARAMS[idx][SKIN_LOWER_LINE_TYPE])
	else
		penSkinContourIn	= WALL_SECT_PEN
		ltSkinContourIn		= WALL_LINETYPE

		penSkinContourOut	= WALL_SECT_PEN
		ltSkinContourOut	= WALL_LINETYPE
	endif

	if (wallIsLeft exor reorder) then
		penSkinContourSill	= penSkinContourIn
		ltSkinContourSill	= ltSkinContourIn

		penSkinContourBoard	= penSkinContourOut
		ltSkinContourBoard	= ltSkinContourOut
	else
		penSkinContourSill	= penSkinContourOut
		ltSkinContourSill	= ltSkinContourOut

		penSkinContourBoard	= penSkinContourIn
		ltSkinContourBoard	= ltSkinContourIn
	endif

	line_property LINE_PROPERTY_CONTOUR

	bEqualWallEndLineStyle = 1

	if bCompositeWall then
		penSkinContour	= round_int(WALL_SKINS_PARAMS[1][SKIN_END_FACE_PEN])
		ltSkinContour	= round_int(WALL_SKINS_PARAMS[1][SKIN_END_LINE_TYPE])

		for i = 2 to WALL_SKINS_NUMBER
			if abs(WALL_SKINS_PARAMS[i][SKIN_END_FACE_PEN] - penSkinContour) > EPS | \
			   abs(WALL_SKINS_PARAMS[i][SKIN_END_LINE_TYPE] - ltSkinContour) > EPS then

				bEqualWallEndLineStyle	= 0
				i = WALL_SKINS_NUMBER	! Force loop end
			endif
		next i
	endif

	if (iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO) & (not(bCompositeWall) | (bCompositeWall & bEqualWallEndLineStyle & bPlasterAtSill = 0 & bPlasterAtBoard = 0)) then
		if bCompositeWall then
			pen WALL_SKINS_PARAMS[1][SKIN_END_FACE_PEN]
			line_type WALL_SKINS_PARAMS[1][SKIN_END_LINE_TYPE]
		else
			pen WALL_SECT_PEN
			line_type WALL_LINETYPE
		endif

		wallline2 px1,py1, px2,py2
		if not(bSettingsDialog) & bDrawFrameContour then
				line2 px3,py3, px5,py5
		endif
	else
		if penSkinContourBoard > EPS then
			pen penSkinContourBoard
			line_type ltSkinContourBoard

			if bNeedContourAtBoard & py2 < py3 then
				wallline2 px2,py2, px3,py3
			endif

			if bCompositeWall & thkPlasterAtBoard > EPS then
				wallline2 px5,py5, px6,py6	! inner plaster - window frame contour
			endif

			if bDrawObjContourIn then
				wallline2 px2,py2, px3,py3	! full contour
			else
				if not(bNeedContourAtBoard) then
					wallline2 px3,py3, px5,py5	! only the frame's contour
				endif
			endif

			if not(bSettingsDialog) & bDrawFrameContour then
				if bCompositeWall & thkPlasterAtBoard > EPS then
					line2 px5,py5, px6,py6	! inner plaster - window frame contour
				endif
				line2 px3,py3, px5,py5	! only the frame's contour
			endif
		endif

		if penSkinContourSill > EPS then
			pen penSkinContourSill
			line_type ltSkinContourSill

			if bNeedContourAtSill & py1 > py4 then
				wallline2 px4,py4, px1,py1	! reveal contour
			endif

			if curvedWall & bWndCurved then	! reveal inner - window frame contour
				R = sqr(px3^2 + (py3 + WOD)^2)

				vx = px3
				vy = py3 + WOD
				gosub 103	! Direction Angle
				alpha = angle

				vx = px4
				vy = py4 + WOD
				gosub 103	! Direction Angle
				beta = angle

				if abs(alpha - beta) > EPS then
					wallarc2 0,-WOD, R, min(alpha,beta), max(alpha,beta)
					if not(bSettingsDialog) & bDrawFrameContour then
						arc2 0,-WOD, R, min(alpha,beta), max(alpha,beta)
					endif
				endif
			else
				if abs(px3 - px4) > EPS & offsetSill < WIDO_SILL then
					wallline2 px3,py3, px4,py4
					if not(bSettingsDialog) & bDrawFrameContour then
						if bDrawObjContourOut | iRevealType <> REVEAL_NEGATIVE then
							line2 px3,py3, px5,py5
						endif
					endif
				endif
			endif

			if bDrawObjContourOut & py1 > py4 then
				wallline2 px4,py4, px1,py1		! reveal contour
				if not(bSettingsDialog) & bDrawFrameContour then
					line2 px4,py4, px1,py1
				endif
			endif
		endif
	endif

return


! ==============================================================================
! Line - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	x11,y11, x12,y12	line #1
!	x21,y21, x22,y22	line #2
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = valid intersection point
!	cx, cy:				intersection point
! ==============================================================================

100:
	lliDiv = (x11-x12) * (y21-y22) - (y11-y12) * (x21-x22)

	if abs(lliDiv) > EPS then
		! Intersection

		temp1 = x11 * y12 - y11 * x12
		temp2 = x21 * y22 - y21 * x22

		tempx = temp1 * (x21-x22) - (x11-x12) * temp2
		tempy = temp1 * (y21-y22) - (y11-y12) * temp2

		state = 1
		cx = (tempx / lliDiv)
		cy = (tempy / lliDiv)
	else
		! No Intersection
		state = 0
		cx = 0
		cy = 0
	endif
return


! ==============================================================================
! Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	EPS:				epsylon
!	xo,yo,ro:			circle
!	x1,y1, x2,y2		line
!
! Returned variables:
!	state:				0 = no intersection point
!						1 = one intersection point (tangential line)
!						2 = two intersection points
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
! ==============================================================================

101:
	tempX1 = x1 - xo: tempY1 = y1 - yo
	tempX2 = x2 - xo: tempY2 = y2 - yo

	if abs(tempX2 - tempX1) < EPS then
		if abs(ro - abs(tempX1)) < EPS then
			state = 1
			xa = tempX1
			ya = 0
			xb = tempX1
			yb = 0
		else
			if abs(ro) - abs(tempX1) < 0 then
				state = 0: xa = 0: ya = 0: xb = 0: yb = 0
			else
				state = 2
				xa = tempX1
				ya = sqr(ro^2 - tempX1^2)
				xb = tempX1
				yb = -sqr(ro^2 - tempX1^2)
			endif
		endif
	else
		kf = (tempY2 - tempY1) / (tempX2 - tempX1)
		ad = 1 + kf^2
		bd = 2 * tempY1 * kf - 2 * tempX1 * kf^2
		cd = tempY1^2 - 2 * tempX1 * tempY1 * kf + tempX1^2 * kf^2 - ro^2

		if bd^2 - 4 * ad * cd < 0 then
			state = 0: xa = 0: ya = 0: xb = 0: yb = 0
		else
			xa = (-bd + sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			ya = tempY1 + (xa - tempX1) * kf
			xb = (-bd - sqr(bd^2 - 4 * ad * cd)) / (2 * ad)
			yb = tempY1 + (xb - tempX1) * kf

			if abs(xa - xb) < EPS then state = 1 else state = 2
		endif
	endif

	if state = 2 then
		da = sqr((tempX1 - xa)^2 + (tempY1 - ya)^2)
		db = sqr((tempX1 - xb)^2 + (tempY1 - yb)^2)

		if db < da then
			xxo = xa: yyo = ya
			xa = xb:  ya = yb
			xb = xxo: yb = yyo
		endif
	endif

	xa = xa + xo: ya = ya + yo
	xb = xb + xo: yb = yb + yo
return


! ==============================================================================
! Select good intersection point after Circle - Line intersection
! ------------------------------------------------------------------------------
! Input variables:
!	state:				intersection status
!	wallIsLeft:
!	xa, ya:				intersection point #1
!	xb, yb:				intersection point #2
!
! Returned variables:
!	cx, cy:				selected intersection point
! ==============================================================================

102:
	cx = 0
	cy = 0
	if state = 1 then
		cx = xa
		cy = ya
	endif
	if state = 2 then
		if wallIsLeft then
			if ya > yb then
				cx = xa
				cy = ya
			else
				cx = xb
				cy = yb
			endif
		else
			if ya < yb then
				cx = xa
				cy = ya
			else
				cx = xb
				cy = yb
			endif
		endif
	endif
return


! ==============================================================================
! Direction Angle
! ------------------------------------------------------------------------------
! Input variables:
!	vx, vy:				vector
!
! Returned variables:
!	alpha:				selected intersection point
! ==============================================================================

103:

if abs(vx) < EPS & abs(vy) < EPS then
	angle = 0
	return
endif

if abs(vx) < EPS then
	if vy > 0 then
		angle = 90
	else
		angle = 270
	endif
else
	angle = atn(vy / vx)
	if vx >= 0 then
		if angle < 0 then
			angle = angle + 360
		endif
	else
		angle = 180 + angle
	endif
endif

return


! ==============================================================================
! Draw wallblock with contour
! ------------------------------------------------------------------------------
! Input variables:
!	stack:				wallblock polygon
!	penFillFg			fill foreground pen (pen index)
!	penFillBg			fill background pen (pen index)
!	bLocalFill			fill orientation (0 / 1)
!	bDrawContour		draw contour lines
! ==============================================================================

200:
	if nsp >= 9 then
		wallblock2 nsp/3 + 1, 2 + 24 * bLocalFill + 32, penFillFg, penFillBg,
			0,0,0,
			0,-WOD,900,
			use(nsp)
	endif
	if nsp < 9 | not(bDrawContour) then
		for ii=1 to nsp
			n = get(1)
		next ii
		return
	endif

	numPoints = nsp/3
	for ii=1 to numPoints
		if ii = 1 then
			x1 = get(1)
			y1 = get(1)
			s1 = get(1)
			firstX = x1
			firstY = y1
			firstS = s1
		endif
		if ii = numPoints then
			x2 = firstX
			y2 = firstY
			s2 = firstS
		else
			x2 = get(1)
			y2 = get(1)
			s2 = get(1)
		endif

		if bittest(s2, 0) then
			if s2 >= 3000 then
				R = sqr(x2^2 + (y2 + WOD)^2)

				vx = x1
				vy = y1 + WOD
				gosub 103	! Direction Angle
				alpha = angle

				vx = x2
				vy = y2 + WOD
				gosub 103	! Direction Angle
				beta = angle

				if abs(alpha - beta) > EPS then
					wallarc2 0,-WOD, R, min(alpha,beta), max(alpha,beta)
				endif
			else
				wallline2 x1,y1, x2,y2
			endif
		endif

		x1 = x2
		y1 = y2
		s1 = s2
	next ii
return


5000:

	if bContour & gs_stack_left then
		put	boundMinX - 1,	trMulY * (-sillDepth) + trAddY,				0,
			boundMinX - 1,	trMulY * (WALL_THICKNESS - WIDO_SILL + 1),	0
	else
		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
			put	-leftW,	-trMulY * wallThkOppSide,	0,
				-leftW,	 trMulY * wallThkRefSide,	0
		endif
		if iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE | iRevealType = REVEAL_SLANTED then
			dxOLeft  = 0
			if iRevealType = REVEAL_SLANTED then
				dxOLeft		= (trAddY - wallThkOppSide) * tan(leftAngle)
			endif

			put	-leftW + dxOLeft,	-trMulY * wallThkOppSide,	0,
				-leftW,				 trMulY * byL + trAddY,		0,
				-leftW + leftJamb,	 trMulY * syL + trAddY,		0,
				-leftW + leftJamb,	 trMulY * wallThkRefSide,	0
		endif
	endif

	if bContour & gs_stack_right then
		put	boundMaxX + 1, 	trMulY * (WALL_THICKNESS - WIDO_SILL + 1),	0,
			boundMaxX + 1,	trMulY * (-sillDepth) + trAddY,				0
	else
		if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
			put	rightW, trMulY * wallThkRefSide,	0,
				rightW,-trMulY * wallThkOppSide,	0
		endif
		if iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE | iRevealType = REVEAL_SLANTED then
			dxORight = 0
			if iRevealType = REVEAL_SLANTED then
				dxORight	= (trAddY - wallThkOppSide) * tan(rightAngle)
			endif

			put rightW - rightJamb,	 trMulY * wallThkRefSide,	0,
				rightW - rightJamb,	 trMulY * syR + trAddY,		0,
				rightW,				 trMulY * byR + trAddY,		0,
				rightW - dxORight,	-trMulY * wallThkOppSide,	0
		endif
	endif
return


]]>
</Script_2D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_1D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! const values for parameter: iTypeDemolitionFill
RENOVATION_FILL_EXIST      = 1
RENOVATION_FILL_DEMOLISHED = 2
RENOVATION_FILL_NEW        = 3


! const values for parameter: iCustomCCEditWallSide
EDITED_WALL_FACE_OUTSIDE = 1
EDITED_WALL_FACE_INSIDE  = 2


! const values for parameter: iCustomCCEditJambSide
EDITED_JAMB_SIDE_BOTH  = 1
EDITED_JAMB_SIDE_LEFT  = 2
EDITED_JAMB_SIDE_RIGHT = 3


! const values for parameter: iCustomCCThicknessType
THICKNESS_TYPE_ORIGINAL = 1
THICKNESS_TYPE_CUSTOM   = 2


! const values for parameter: iCustomCCEditSkin
EDITED_SKIN_1 = 1
EDITED_SKIN_2 = 2
EDITED_SKIN_3 = 3
EDITED_SKIN_4 = 4


! const values for parameter: iCustomCCOrientation
ORIENTATION_ORIGINAL  = 1
ORIENTATION_TURNED_IN = 2

EPS = 0.0001

! ==============================================================================

! iRevealType:
REVEAL_EDGE				= 0
REVEAL_NO				= 1
REVEAL_POSITIVE			= 2
REVEAL_NEGATIVE			= 3
REVEAL_SLANTED			= 4
REVEAL_SPLAYED			= 5
REVEAL_HISTORIC			= 6
REVEAL_DOUBLE			= 7
REVEAL_DOUBLE_SPLAYED	= 8
REVEAL_OUTSIDE_SPLAYED	= 9


! ==============================================================================

curvedWall	= abs(WIDO_ORIG_DIST) > EPS

bRotAngle180 = SYMB_ROTANGLE > EPS
wallIsLeft	= bRotAngle180 exor WIDO_REVEAL_SIDE
signWallIsLeft	= wallIsleft - not(wallIsleft)


! ==============================================================================
! Compatibility
! ==============================================================================

if refWidth < EPS then refWidth = A
if leftWidth < EPS then leftWidth = A / 2
if rightWidth < EPS then rightWidth = A / 2


! ==============================================================================

CAVITY_SIDE_BOTH	= 1
CAVITY_SIDE_LEFT	= 2
CAVITY_SIDE_RIGHT	= 3

CAVITY_TURN_REFERENCE	= 1
CAVITY_TURN_OPPOSITE	= 2

CLOSURE_METHOD_NONE				= 1
CLOSURE_METHOD_TRADITIONAL		= 2
CLOSURE_METHOD_PREFABRICATED	= 3

gs_bTurnDir = (iCavityClosureTurnDir = CAVITY_TURN_REFERENCE)

! ==============================================================================
! Parameter Restrictions - only for the 2D and 3D scripts
! ==============================================================================

if GLOB_SCRIPT_TYPE = 2 | GLOB_SCRIPT_TYPE = 3 then
	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO then
		gs_reveal_left	= 0
		gs_reveal_right	= 0
	endif

	if iRevealType = REVEAL_EDGE | iRevealType = REVEAL_NO | iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE then
		gs_reveal_left_angle  = 0
		gs_reveal_right_angle = 0
	endif

	if WIDO_SILL < EPS & (iRevealType = REVEAL_POSITIVE | iRevealType = REVEAL_NEGATIVE) then
		iRevealType = REVEAL_NO
	endif

	if not(gs_bJoint) then gs_thkJoint = 0
	if gs_thkJoint < EPS then gs_bJoint = 0

	if GLOB_SCRIPT_TYPE = 2 & AC_Hole_Display_Option = 5 then	! Overhead All
		gs_bAutoTurnIn		= 0		! Do not turn plasters in this display mode
		gs_bOverIn			= 0
		bDrawObjContourIn	= 1		! Always draw wall contour lines

		gs_bAutoTurnOut		= 0
		gs_bOverOut			= 0
		bDrawObjContourOut	= 1
	endif
endif


! ==============================================================================
! Calculations for Trapezoid Walls
! ==============================================================================

if abs(WALL_INCL) > EPS then
	bInclinedWall = 1
	bInclDir = SYMB_MIRRORED exor (SYMB_ROTANGLE > EPS)	! (0 / 1)
	iInclDir = not(bInclDir) - bInclDir					! (1 / -1)

	incH = cos(WALL_INCL)
	incV = sin(WALL_INCL) * iInclDir

	incHor = tan(WALL_INCL)
else
	bInclinedWall = 0
	bInclDir = 0
	iInclDir = 0

	incH = 0
	incV = 0

	incHor = 0
endif


! ==============================================================================
! Calculations for Curved Walls
! ==============================================================================

if curvedWall then

	widoOrigDist = -WIDO_ORIG_DIST

	if GLOB_SCRIPT_TYPE <> 5 then
		if GLOB_SCRIPT_TYPE = 2 | GLOB_CONTEXT = 22 then
			widoOrigDist =  WIDO_ORIG_DIST
		endif
	endif

	WOD = abs(widoOrigDist) - (SYMB_ROTANGLE > EPS) * WIDO_FRAME_THICKNESS

	leftAlfa	= atn(leftWidth / WOD)
	rightAlfa	= atn(rightWidth / WOD)

	bArchSign = (WIDO_REVEAL_SIDE exor SYMB_ROTANGLE > EPS)
	iArchSign = bArchSign - not(bArchSign)		! 1 / -1

	R = sqr((refWidth / 2)^2 + (WIDO_ORIG_DIST)^2)
	bulgeHeight = R + iArchSign * WIDO_SILL - abs(WIDO_ORIG_DIST)

	if bArchSign then
		bulgeHeightRefSide = R + WIDO_SILL - abs(WIDO_ORIG_DIST)
		bulgeHeightOppSide = 0
	else
		bulgeHeightRefSide = 0
		bulgeHeightOppSide = R - WIDO_SILL + WALL_THICKNESS - abs(WIDO_ORIG_DIST)
	endif

	if WIDO_REVEAL_SIDE then
		WOD = widoOrigDist + WIDO_FRAME_THICKNESS
	else
		WOD = -widoOrigDist
	endif

	if WIDO_REVEAL_SIDE exor SYMB_ROTANGLE < EPS then
		ySign = 1
		if WIDO_REVEAL_SIDE then
			rSill = sqr(refWidth^2 / 4 + WOD^2) - WIDO_SILL
			rBoard = rSill + WALL_THICKNESS
		else
			rSill = sqr(refWidth^2 / 4 + WOD^2) - WIDO_SILL
			rBoard = rSill + WALL_THICKNESS
		endif
	else
		ySign = -1
		if WIDO_REVEAL_SIDE then
			rBoard = sqr(refWidth^2 / 4 + WOD^2) + WIDO_SILL - WALL_THICKNESS
			rSill = rBoard + WALL_THICKNESS
		else
			rSill = sqr(refWidth^2 / 4 + WOD^2) + WIDO_SILL
			rBoard = rSill - WALL_THICKNESS
		endif
	endif

	rSillLine = rSill - iArchSign * WIDO_SILL	! Radius of the reveal at the Sill depth

	ArcLengthSillToAngle	= 180 / rSill / PI
!!!	ArcLengthBoardToAngle	= 180 / rBoard / PI

else
	WOD = 0
	bulgeHeightRefSide = 0
	bulgeHeightOppSide = 0
	leftAlfa	= 0
	rightAlfa	= 0
	iArchSign = 0
endif


! ==============================================================================
! Bounding Box of Polygon wall
! ==============================================================================

if AC_WallType = 2 then

	boundMinX =  1000
	boundMaxX = -1000
	boundMinY =  1000
	boundMaxY = -1000

	for i = 1 to vardim1(AC_WallContourPolygon)
		if boundMaxX < AC_WallContourPolygon[i][1] then boundMaxX = AC_WallContourPolygon[i][1]
		if boundMinX > AC_WallContourPolygon[i][1] then boundMinX = AC_WallContourPolygon[i][1]
		if boundMaxY < AC_WallContourPolygon[i][2] then boundMaxY = AC_WallContourPolygon[i][2]
		if boundMinY > AC_WallContourPolygon[i][2] then boundMinY = AC_WallContourPolygon[i][2]
	next i
else
	boundMinX = 0
	boundMaxX = 0
	boundMinY = 0
	boundMaxY = 0
endif


! ==============================================================================
! Cavity Closure
! ==============================================================================

reorder = (AC_Wall_Direction_Type <> 1 & AC_Wall_Direction_Type <> 3)
signReorder = not(reorder) - reorder

SKIN_FILL				=  1
SKIN_THICKNESS			=  2
SKIN_CONT_PEN			=  3	! Obsolete (old contour pen)
SKIN_FILL_PEN			=  4
SKIN_FILL_BACK_PEN		=  5
SKIN_CORE_STATUS		=  6
SKIN_UPPER_LINE_PEN		=  7 + 2 * reorder
SKIN_UPPER_LINE_TYPE	=  8 + 2 * reorder
SKIN_LOWER_LINE_PEN		=  9 - 2 * reorder
SKIN_LOWER_LINE_TYPE	= 10 - 2 * reorder
SKIN_END_FACE_PEN		= 11
SKIN_FILL_ORIENTATION	= 12	! 0 - global, 1 - local
SKIN_TYPE				= 13	! 0 - cut, 1 - below cutplane, 2 - above cutplane (all skin types are 0 for simple walls)
!	For D/W in complex walls on the floor plan this variable contains the data of all cut skins, for wall ends on the floor plan the data of all skins.
!	For D/W and wall ends in the 3D window contains the data of the skins actually cut by the D/W or wall end
SKIN_END_LINE_TYPE		= 14
SKIN_FINISH_STATUS		= 15
SKIN_FILL_FIT_TO_SKIN	= 16
SKIN_THICKEN_TRAPEZOID	= 17


! Line Property defines:
LINE_PROPERTY_GENERIC	= 0
LINE_PROPERTY_INNER		= 1
LINE_PROPERTY_CONTOUR	= 2


! Partial Stucture Display defines:
STRUCTURE_ENTIRE_STRUCTURE	= 0
STRUCTURE_CORE_ONLY			= 1
STRUCTURE_WITHOUT_FINISHES	= 2


! ==============================================================================

bCompositeWall		= (WALL_SKINS_NUMBER > 0)
bFirstSkinAtReveal	= (wallIsLeft exor reorder)

! --- find the last core skin ---
firstCoreSkin	= 0
lastCoreSkin	= 0
for i = 1 to WALL_SKINS_NUMBER
	idx = i: gosub 10	! Get proper index

	if abs(WALL_SKINS_PARAMS[idx][SKIN_CORE_STATUS] - 3) < EPS then
		if firstCoreSkin < 1 then
			firstCoreSkin = i
		endif
		lastCoreSkin = i
	endif
next i

if firstCoreSkin = 0 then
	firstCoreSkin = WALL_SKINS_NUMBER
endif

gs_maxPlasterThkIn	= gs_maxPlasterThk
gs_maxPlasterThkOut	= gs_maxPlasterThk


! ==============================================================================
! Partial Stucture Display related calculations
! ==============================================================================

offsetSill	= 0
offsetBoard	= 0
bRevealInDisplayedStructure = 1
bOneFillAtRevealSide		= 1

if GLOB_SCRIPT_TYPE = 2 | GLOB_SCRIPT_TYPE = 3 then
	if GLOB_STRUCTURE_DISPLAY <> STRUCTURE_ENTIRE_STRUCTURE then

		if bCompositeWall then

			offsetInside		= 0
			offsetOutside		= 0

			for i = 1 to WALL_SKINS_NUMBER

				bShowSkin = (GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[i][SKIN_FINISH_STATUS] - 1) > EPS) | \
							(GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY & WALL_SKINS_PARAMS[i][SKIN_CORE_STATUS] > EPS)

				if not(bShowSkin) then
					offsetInside = offsetInside + WALL_SKINS_PARAMS[i][SKIN_THICKNESS]
				else
					i = WALL_SKINS_NUMBER	! Break loop
				endif
			next i

			for i = WALL_SKINS_NUMBER to 1 step -1

				bShowSkin = (GLOB_STRUCTURE_DISPLAY = STRUCTURE_WITHOUT_FINISHES & abs(WALL_SKINS_PARAMS[i][SKIN_FINISH_STATUS] - 1) > EPS) | \
							(GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY & WALL_SKINS_PARAMS[i][SKIN_CORE_STATUS] > EPS)

				if not(bShowSkin) then
					offsetOutside = offsetOutside + WALL_SKINS_PARAMS[i][SKIN_THICKNESS]
				else
					i = 1	! Break loop
				endif
			next i

			if wallIsLeft then
				offsetSill	= offsetInside
				offsetBoard	= offsetOutside
			else
				offsetSill	= offsetOutside
				offsetBoard	= offsetInside
			endif

			bRevealInDisplayedStructure	= (WIDO_REVEAL_ON & (offsetSill < WIDO_SILL) & (offsetBoard < WALL_THICKNESS - WIDO_SILL))
			bOneFillAtRevealSide		= (WIDO_REVEAL_ON & (offsetSill < WIDO_SILL))
		endif
	endif
endif

! ==============================================================================
! Determine number of turned plaster skins from the Outside Face
! ==============================================================================

nSkinTurnIn			= 0
maxSkinTurnIn		= 0
nFinishSkinTurnIn	= 0	! Number of finish state skins at inside
bCountMaxSkins		= 1
possibleSkinTurnIn	= 0
bCountPossibleSkins	= 1
lengthPlasterTurnIn	= bFirstSkinAtReveal * WIDO_SILL + not(bFirstSkinAtReveal) * (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS)

if GLOB_SCRIPT_TYPE <> 5 then
	if bCompositeWall then
		sumThk = 0
		for i = 1 to firstCoreSkin - 1
			idx = i: gosub 10	! Get proper index

			thisTkh = WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
			sumThk = sumThk + thisTkh

			if abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) < EPS | GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY then
				nFinishSkinTurnIn = nFinishSkinTurnIn + 1
			endif

			if thisTkh <= gs_maxPlasterThkIn + EPS then
				if bCountPossibleSkins then possibleSkinTurnIn = possibleSkinTurnIn + 1
			else
				bCountPossibleSkins = 0
			endif

			if bCountMaxSkins & (not(gs_bAutoTurnIn) | thisTkh <= gs_maxPlasterThkIn + EPS) then
				if bFirstSkinAtReveal then
					if sumThk <= WIDO_SILL - EPS then
						maxSkinTurnIn = maxSkinTurnIn + 1
					else
						bCountMaxSkins = 0
					endif
				else
					if sumThk <= WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS - EPS then
						maxSkinTurnIn = maxSkinTurnIn + 1
					else
						bCountMaxSkins = 0
					endif
				endif
			else
				bCountMaxSkins = 0
			endif
		next i

		if gs_useWallFinishSkin then
			maxSkinTurnIn	= 0
			bCountMaxSkins	= 1

			for i = 1 to firstCoreSkin - 1
				idx = i: gosub 10	! Get proper index

				if bCountMaxSkins & abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) < EPS then
					maxSkinTurnIn = maxSkinTurnIn + 1
				else
					bCountMaxSkins = 0
				endif
			next i
		endif

		if gs_bAutoTurnIn then
			nSkinTurnIn = maxSkinTurnIn
		else
			nSkinTurnIn = min(possibleSkinTurnIn, gs_bOverIn)
			nSkinTurnIn = max(nSkinTurnIn, 0)
		endif
		nFinishSkinTurnIn = min(nFinishSkinTurnIn, nSkinTurnIn)
	endif
endif

! ==============================================================================
! Determine number of turned plaster skins from the Inside Face
! ==============================================================================

nSkinTurnOut		= 0
maxSkinTurnOut		= 0
nFinishSkinTurnOut	= 0	! Number of finish state skins at outside
bCountMaxSkins		= 1
possibleSkinTurnOut	= 0
bCountPossibleSkins	= 1
lengthPlasterTurnOut= not(bFirstSkinAtReveal) * WIDO_SILL + bFirstSkinAtReveal * (WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS)

if GLOB_SCRIPT_TYPE <> 5 then
	if bCompositeWall then
		sumThk = 0
		for i = WALL_SKINS_NUMBER to lastCoreSkin + 1 step -1
			idx = i: gosub 10	! Get proper index

			thisTkh = WALL_SKINS_PARAMS[idx][SKIN_THICKNESS]
			sumThk = sumThk + thisTkh

			if abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) < EPS | GLOB_STRUCTURE_DISPLAY = STRUCTURE_CORE_ONLY then
				nFinishSkinTurnOut = nFinishSkinTurnOut + 1
			endif

			if thisTkh <= gs_maxPlasterThkOut + EPS then
				if bCountPossibleSkins then possibleSkinTurnOut = possibleSkinTurnOut + 1
			else
				bCountPossibleSkins = 0
			endif

			if bCountMaxSkins & (not(gs_bAutoTurnOut) | thisTkh <= gs_maxPlasterThkOut + EPS) then
				if bFirstSkinAtReveal then
					if sumThk <= WALL_THICKNESS - WIDO_SILL - WIDO_FRAME_THICKNESS - EPS then
						maxSkinTurnOut = maxSkinTurnOut + 1
					else
						bCountMaxSkins = 0
					endif
				else
					if sumThk <= WIDO_SILL - EPS then
						maxSkinTurnOut = maxSkinTurnOut + 1
					else
						bCountMaxSkins = 0
					endif
				endif
			else
				bCountMaxSkins = 0
			endif
		next i

		if gs_useWallFinishSkin then
			maxSkinTurnOut	= 0
			bCountMaxSkins	= 1

			for i = WALL_SKINS_NUMBER to lastCoreSkin + 1 step -1
				idx = i: gosub 10	! Get proper index

				if bCountMaxSkins & abs(WALL_SKINS_PARAMS[idx][SKIN_FINISH_STATUS] - 1) < EPS then
					maxSkinTurnOut = maxSkinTurnOut + 1
				else
					bCountMaxSkins = 0
				endif
			next i
		endif

		if gs_bAutoTurnOut then
			nSkinTurnOut = maxSkinTurnOut
		else
			nSkinTurnOut = min(possibleSkinTurnOut, gs_bOverOut)
			nSkinTurnOut = max(nSkinTurnOut, 0)
		endif
		nFinishSkinTurnOut = min(nFinishSkinTurnOut, nSkinTurnOut)
	endif
endif


! ==============================================================================
goto 1:
! ==============================================================================



! ==============================================================================
!		Calculate proper skin index from parameter 'idx'
! ------------------------------------------------------------------------------
! Input variables:
!	idx:	index of current skin
! Output variables:
!	idx:	index of skin via 'Composite Structures' dialog
! ==============================================================================

10:
	if reorder then
		idx = WALL_SKINS_NUMBER + 1 - idx
	endif
return

! ==============================================================================

1:

]]>
</Script_1D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_PR SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_PR>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_UI SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[

pageStartY = 5

bDefaultElem = (GLOB_INTGUID = "" or GLOB_INTGUID = "{00000000-0000-0000-0000-000000000000}")
bDefaultElem = 1	! GLOB_INTGUID always 0 !

showTurnPlaster		= 1
showCavityClosure	= 1

if not(bDefaultElem) then
	if WALL_SKINS_NUMBER < 2 then showTurnPlaster	= 0
	if WALL_SKINS_NUMBER = 0 then showCavityClosure	= 0
endif



sep1x = 222
sep2y = 45 + pageStartY
sep3y = 127 + pageStartY

ui_separator sep1x,pageStartY - 4, sep1x,229 + pageStartY
ui_separator 0,sep2y, sep1x-2,sep2y
ui_separator 0,sep3y, sep1x-2,sep3y

! Use Wall Finish Component ---------------------------------------------------

x0 = 0
x1 = 20
x2 = sep1x - 2
y = pageStartY

iFlag = 4 * not(showTurnPlaster | showCavityClosure)

ui_style 0, 0
cx = 18
ui_outfield gs_stCavityClosure[32], x1,y+3, x2-x1-1,18, iFlag		! Use Wall Finish Component
ui_infield "gs_useWallFinishSkin", x0,y, cx,18


! Plaster Thickness Limit -----------------------------------------------------

x1 = 0
x2 = 215
y = 18 + pageStartY

iFlag = 4 * (not(showTurnPlaster | showCavityClosure) | gs_useWallFinishSkin)

cx = 80
ui_style 0, 0
ui_outfield gs_stCavityClosure[31], x0,y,x2-x1-cx-5,27, iFlag		! Plaster Thickness Limit
ui_infield "gs_maxPlasterThk", x2-cx,y+3, cx,18 ui_tooltip `Считать Слой Штукатуркой, если он Тоньше или Равен`


! Turn Plaster ----------------------------------------------------------------

x1 = 0
x2 = 10
x3 = 115
x4 = 162
x5 = 182
x6 = sep1x - 2
y = sep2y + 2
dy = 20

iFlag = 4 * not(showTurnPlaster)

ui_style 0,1
ui_outfield gs_stCavityClosure[26], x1,y+2, x6-x1-1,18				! Turn Plaster

y = y + 20
ui_style 0, 0
ui_outfield gs_stCavityClosure[30], x1,y+2, sep1x-x1-1,18, iFlag	! Number of Skins to Turn
y = y + 18


ui_outfield gs_stCavityClosure[27], x2,y+3, x3-x2-1,18, iFlag		! Outside Face
cx = 40
ui_infield "gs_bOverIn",			x3,y, cx,22
cx = 18
ui_infield "gs_bAutoTurnIn",	x4,y+2, cx,18
ui_outfield gs_stCavityClosure[29], x5,y+3, x6-x5-1,18, iFlag		! Auto Turn
y = y + dy

ui_outfield gs_stCavityClosure[28], x2,y+3, x3-x2-1,18, iFlag		! Inside Face
cx = 40
ui_infield "gs_bOverOut",			x3,y, cx,22
cx = 18
ui_infield "gs_bAutoTurnOut",	x4,y+2, cx,18
ui_outfield gs_stCavityClosure[29], x5,y+3, x6-x5-1,18, iFlag		! Auto Turn
y = y + dy


! Cavity Closure --------------------------------------------------------------

y = sep3y + 2
dy = 20

x0 = 0
x1 = 10
x2 = 215

ui_style 0,1
ui_outfield gs_stCavityClosure[10], x0,y+2,sep1x-x0-1,15		! Cavity Closure
y = y + dy

px = 30
py = 20
cx = px + 10
cy = py + 4

iFlag = 4 * not(showCavityClosure)

ui_style 0, 0
ui_outfield gs_stCavityClosure[11], x1,y+3,x2-x1-cx-18-1,18, iFlag	! Closure Method
ui_infield{3} "iClosureMethod", x2-cx-18,y-7, cx, cy,
	2, 1,		! ui_cavityclosure_type.png
	3, 1,
	cx, cy, px, py,
	1,	gs_stCavityClosure[1],	CLOSURE_METHOD_NONE,
	2,	gs_stCavityClosure[2],	CLOSURE_METHOD_TRADITIONAL,
	3,	gs_stCavityClosure[3],	CLOSURE_METHOD_PREFABRICATED
y = y + dy


iFlag = 4 * not(iClosureMethod <> CLOSURE_METHOD_NONE & showCavityClosure)

cx = 100
ui_style 0, 0
ui_outfield gs_stCavityClosure[12], x1,y+3, x2-x1-cx-1,18, iFlag		! Turn Skin on Side
ui_infield{3}	"iCavityClosureSide", x2-cx, y, cx, 18,
		8, "", 3, 1,
		0, 0, 0, 0,
		1, gs_stCavityClosure[6], CAVITY_SIDE_BOTH,
		2, gs_stCavityClosure[7], CAVITY_SIDE_LEFT,
		3, gs_stCavityClosure[8], CAVITY_SIDE_RIGHT
y = y + dy

if iClosureMethod = CLOSURE_METHOD_NONE | iClosureMethod = CLOSURE_METHOD_TRADITIONAL then

	iFlag = 4 * not(iClosureMethod = CLOSURE_METHOD_TRADITIONAL & showCavityClosure)

	cx = 50
	ui_outfield gs_stCavityClosure[14], x1,y+2, x2-x1-cx-1,18, iFlag		! Number of Skins to Turn
	ui_infield "gs_nTurn", x2-cx,y, cx,18
	y = y + dy

	cx = 100
	ui_outfield gs_stCavityClosure[15], x1,y+2, x2-x1-cx-1,18, iFlag		! Number from
	ui_infield{3}	"iCavityClosureTurnDir", x2-cx, y, cx, 18,
			8, "", 2, 1,
			0, 0, 0, 0,
			1, gs_stCavityClosure[4], CAVITY_TURN_REFERENCE,
			2, gs_stCavityClosure[5], CAVITY_TURN_OPPOSITE

	y = y + dy
endif


! Insulation Strip and Plug ---------------------------------------------------

x0 = 233
x1 = x0 + 30
x2 = 444
y = pageStartY
dy = 25

if iClosureMethod = CLOSURE_METHOD_NONE | iClosureMethod = CLOSURE_METHOD_TRADITIONAL then

	iFlag = 4 * not(iClosureMethod = CLOSURE_METHOD_TRADITIONAL & showCavityClosure)

	ui_style 0,1
	cx = 18
	ui_outfield gs_stCavityClosure[17], x1,y+3, x2-x1-1,18, iFlag		! Insulation Strip
	ui_infield "gs_bJoint", x0,y, cx,18
	y = y + dy

	bFlag = not(gs_bJoint & iClosureMethod = CLOSURE_METHOD_TRADITIONAL & showCavityClosure)
	iFlag = 4 * bFlag

	ui_style 0, 0
	cx = 60
	ui_outfield gs_stCavityClosure[18], x1,y+3, x2-x1-cx-1,18, iFlag		! Thickness
	ui_infield "gs_thkJoint", x2-cx,y, cx,18
	y = y + dy
	y = y + 10

endif

if iClosureMethod = CLOSURE_METHOD_PREFABRICATED then

	bFlag = not(showCavityClosure)
	iFlag = 4 * bFlag

	ui_style 0,1
	ui_outfield gs_stCavityClosure[24], x0,y+3, x2-x0-1,18, iFlag		! Profile
	y = y + dy

	ui_style 0, 0
	cx = 60
	ui_outfield gs_stCavityClosure[25], x1,y+3, x2-x1-cx-1,18, iFlag		! Width
	ui_infield "gs_widthPlug", x2-cx,y, cx,18
	y = y + dy
	y = y + 10

endif



]]>
</Script_UI>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_VL SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! Contact person: <JT, TZs>

! ==============================================================================
! This macro draws the cavity closure and turned plasters
! ------------------------------------------------------------------------------
! Input parameters:
!	gs_maxPlasterThk:	wall skin classification parameter (length)
!						consider Skin as Plaster if it is thinner this
!	gs_bAutoTurnIn:		automatic plaster return at Outside Face (0 / 1)
!	gs_bAutoTurnOut:	automatic plaster return at Inside Face (0 / 1)
!	gs_bOverIn:			number of turned plaster skins at Outside Face (integer)
!	gs_bOverOut:		number of turned plaster skins at Inside Face (integer)
!	gs_closureMethod:	controls the method being used for internal cavity closure
!	gs_nTurn:			number of turned skins in traditional mode (integer value)
!	gs_bJoint:			is there an insulation strip at the front
!						 side of the turned skins (0 / 1) [MODE1]
!	stClosureMethod:	string table for gs_closureMethod
! ==============================================================================


bDisablePrefabClosure = 0

bDefaultElem	= (GLOB_INTGUID = "" | GLOB_INTGUID = "{00000000-0000-0000-0000-000000000000}")
bCompositeWall	= (WALL_SKINS_NUMBER > 0)
if not(bDefaultElem) then
	isCoreSkin = 0
	for i = 1 to WALL_SKINS_NUMBER
		if abs(WALL_SKINS_PARAMS[i][SKIN_CORE_STATUS] - 3) < EPS then
			isCoreSkin = 1
			i = WALL_SKINS_NUMBER
		endif
	next i
	if not(isCoreSkin) then
		bDisablePrefabClosure	= 1
		if iClosureMethod = CLOSURE_METHOD_PREFABRICATED then
			iClosureMethod		= CLOSURE_METHOD_NONE	! None
			gs_closureMethod	= gs_stCavityClosure[1]	! None
			parameters iClosureMethod = iClosureMethod
			parameters gs_closureMethod = gs_closureMethod
		endif
	endif
endif

if not(bDefaultElem) & not(bCompositeWall) then
	iClosureMethod		= CLOSURE_METHOD_NONE	! No Closure
	gs_closureMethod	= gs_stCavityClosure[1]	! None
	parameters iClosureMethod = iClosureMethod
	parameters gs_closureMethod = gs_closureMethod

	lock "gs_closureMethod", "iClosureMethod"
endif

if bDisablePrefabClosure then
	values "gs_closureMethod"	gs_stCavityClosure[1], gs_stCavityClosure[2]
	values "iClosureMethod"	CLOSURE_METHOD_NONE, CLOSURE_METHOD_TRADITIONAL
else
	values "gs_closureMethod"	gs_stCavityClosure[1], gs_stCavityClosure[2], gs_stCavityClosure[3]
	values "iClosureMethod"	CLOSURE_METHOD_NONE, CLOSURE_METHOD_TRADITIONAL, CLOSURE_METHOD_PREFABRICATED
endif

if GLOB_MODPAR_NAME = "gs_closureMethod" then
	iClosureMethod = CLOSURE_METHOD_NONE
	if gs_closureMethod = gs_stCavityClosure[2] then	iClosureMethod = CLOSURE_METHOD_TRADITIONAL
	if gs_closureMethod = gs_stCavityClosure[3] then	iClosureMethod = CLOSURE_METHOD_PREFABRICATED
	parameters iClosureMethod = iClosureMethod
else
	gs_closureMethod = gs_stCavityClosure[1]
	if iClosureMethod = CLOSURE_METHOD_TRADITIONAL then gs_closureMethod = gs_stCavityClosure[2]
	if iClosureMethod = CLOSURE_METHOD_PREFABRICATED then gs_closureMethod = gs_stCavityClosure[3]
	parameters gs_closureMethod = gs_closureMethod
endif

values "gs_cavity_side"		gs_stCavityClosure[6], gs_stCavityClosure[7], gs_stCavityClosure[8]
values "iCavityClosureSide"		CAVITY_SIDE_BOTH, CAVITY_SIDE_LEFT, CAVITY_SIDE_RIGHT

if GLOB_MODPAR_NAME = "gs_cavity_side" then
	iCavityClosureSide = CAVITY_SIDE_BOTH
	if gs_cavity_side = gs_stCavityClosure[7] then	iCavityClosureSide = CAVITY_SIDE_LEFT
	if gs_cavity_side = gs_stCavityClosure[8] then	iCavityClosureSide = CAVITY_SIDE_RIGHT
	parameters iCavityClosureSide = iCavityClosureSide
else
	gs_cavity_side = gs_stCavityClosure[6]
	if iCavityClosureSide = CAVITY_SIDE_LEFT then gs_cavity_side = gs_stCavityClosure[7]
	if iCavityClosureSide = CAVITY_SIDE_RIGHT then gs_cavity_side = gs_stCavityClosure[8]
	parameters gs_cavity_side = gs_cavity_side
endif

values "gs_nTurnDir"		gs_stCavityClosure[4], gs_stCavityClosure[5]
values "iCavityClosureTurnDir" CAVITY_TURN_REFERENCE, CAVITY_TURN_OPPOSITE
if GLOB_MODPAR_NAME = "gs_nTurnDir" then
	iCavityClosureTurnDir = CAVITY_TURN_REFERENCE
	if gs_nTurnDir = gs_stCavityClosure[5] then	iCavityClosureTurnDir = CAVITY_TURN_OPPOSITE
	parameters iCavityClosureTurnDir = iCavityClosureTurnDir
else
	gs_nTurnDir = gs_stCavityClosure[4]
	if iCavityClosureTurnDir = CAVITY_TURN_OPPOSITE then gs_nTurnDir = gs_stCavityClosure[5]
	parameters gs_nTurnDir = gs_nTurnDir
endif

values "gs_nTurn"			range [0, )
values "gs_thkJoint"		range (0, )

! ==============================================================================
! Cavity Closure Parameters
! ==============================================================================

if iClosureMethod = CLOSURE_METHOD_NONE then			! None
	hideparameter	"gs_cavity_side", "iCavityClosureSide"
	lock			"gs_cavity_side", "iCavityClosureSide"
endif

if iClosureMethod = CLOSURE_METHOD_TRADITIONAL then			! Traditional
	if gs_nTurn = 0 then
		hideparameter	"gs_bJoint"
		lock			"gs_bJoint"
		hideparameter	"gs_thkJoint", "gs_penJoint", "gs_ltJoint", "gs_fillJoint", "gs_penJointFg", "gs_penJointBg"
		lock			"gs_thkJoint", "gs_penJoint", "gs_ltJoint", "gs_fillJoint", "gs_penJointFg", "gs_penJointBg"
	else
		if not(gs_bJoint) then
			hideparameter	"gs_thkJoint", "gs_penJoint", "gs_ltJoint", "gs_fillJoint", "gs_penJointFg", "gs_penJointBg"
			lock			"gs_thkJoint", "gs_penJoint", "gs_ltJoint", "gs_fillJoint", "gs_penJointFg", "gs_penJointBg"
		endif
	endif
else
	lock			"gs_nTurnDir", "iCavityClosureTurnDir", "gs_nTurn", "gs_bJoint",
					"gs_thkJoint", "gs_penJoint", "gs_ltJoint", "gs_fillJoint", "gs_penJointFg", "gs_penJointBg"

	hideparameter	"gs_nTurnDir", "iCavityClosureTurnDir", "gs_nTurn", "gs_bJoint",
					"gs_thkJoint", "gs_penJoint", "gs_ltJoint", "gs_fillJoint", "gs_penJointFg", "gs_penJointBg"
endif

if iClosureMethod = CLOSURE_METHOD_PREFABRICATED then			! Prefabricated
else
	lock			"gs_widthPlug", "gs_penPlug", "gs_ltPlug", "gs_fillPlug", "gs_penPlugFg", "gs_penPlugBg"
	hideparameter	"gs_widthPlug", "gs_penPlug", "gs_ltPlug", "gs_fillPlug", "gs_penPlugFg", "gs_penPlugBg"
endif

bDefaultElem = (GLOB_INTGUID = "" or GLOB_INTGUID = "{00000000-0000-0000-0000-000000000000}")
bDefaultElem = 1	! GLOB_INTGUID always 0 !


! ==============================================================================
! Auto Turn Plaster
! ==============================================================================

values "gs_maxPlasterThk" range [0,]

if gs_useWallFinishSkin then
	lock "gs_maxPlasterThk"
	hideparameter "gs_maxPlasterThk"
endif

if gs_bAutoTurnIn then
	lock "gs_bOverIn"
	hideparameter "gs_bOverIn"
	parameters gs_bOverIn = maxSkinTurnIn
else
	if bDefaultElem then
		values "gs_bOverIn" range[0, ]
	else
!		for i=0 to maxSkinTurnIn		! INFO: A Settings Dialogban nem mukodik, mert a
!			put i						! SYMB_MIRRORED, WIDO_REVEAL_SIDE es SYMB_ROTANGLE
!		next i							! mindig nulla
!		values "gs_bOverIn" get(nsp)
		values "gs_bOverIn" range[0, ]
	endif
endif

if gs_bAutoTurnOut then
	lock "gs_bOverOut"
	hideparameter "gs_bOverOut"
	parameters gs_bOverOut = maxSkinTurnOut
else
	if bDefaultElem then
		values "gs_bOverOut" range[0, ]
	else
!		for i=0 to maxSkinTurnOut
!			put i
!		next i
!		values "gs_bOverOut" get(nsp)
		values "gs_bOverOut" range[0, ]
	endif
endif


! ==============================================================================
! Show / Hide Parameters
! ==============================================================================

showTurnPlaster		= 1
showCavityClosure	= 1

if not(bDefaultElem) then
	if WALL_SKINS_NUMBER < 2 then showTurnPlaster	= 0
	if WALL_SKINS_NUMBER = 0 then showCavityClosure	= 0
endif

if not(showTurnPlaster) then
	lock	"gs_turn_plaster",
			"gs_bAutoTurnIn",
			"gs_bAutoTurnOut",
			"gs_bOverIn",
			"gs_bOverOut"
endif

if not(showCavityClosure) then
	lock	"gs_closureMethod",
			"iClosureMethod",
			"gs_cavity_side",
			"iCavityClosureSide",
			"gs_nTurn",
			"gs_nTurnDir",
			"iCavityClosureTurnDir",
			"gs_bJoint",
			"gs_thkJoint",
			"gs_penJoint",
			"gs_ltJoint",
			"gs_fillJoint",
			"gs_penJointFg",
			"gs_penJointBg",
			"gs_widthPlug",
			"gs_penPlug",
			"gs_ltPlug",
			"gs_fillPlug",
			"gs_penPlugFg",
			"gs_penPlugBg"
endif

if not(showTurnPlaster) & not(showCavityClosure) then
	lock "gs_maxPlasterThk"
endif

! --- WIDO_REVEAL_SIDE and WIDO_ORIG_DIST globals don't working in the settings dialog


]]>
</Script_VL>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Comment SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Comment>

<ParamSection SectVersion="26" SectionFlags="0" SubIdent="0">
	<ParamSectHeader>
		<Version>26</Version>
		<AutoHotspots>false</AutoHotspots>
		<StatBits>
			<STBit_FixSize/>
		</StatBits>
		<WDLeftFrame>0</WDLeftFrame>
		<WDRightFrame>0</WDRightFrame>
		<WDTopFrame>0</WDTopFrame>
		<WDBotFrame>0</WDBotFrame>
		<LayFlags>65535</LayFlags>
		<WDMirrorThickness>0</WDMirrorThickness>
		<WDWallInset>0</WDWallInset>
		<SymbolColor>0</SymbolColor>
	</ParamSectHeader>
	<Parameters>
		<Length Name="A">
			<Description><![CDATA["Dimension 1"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Length Name="B">
			<Description><![CDATA["Dimension 2"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Length Name="ZZYZX">
			<Description><![CDATA["Height"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Integer Name="AC_WallContours">
			<Description><![CDATA["Wall Contours (0-None,1-Full,2-Side,3-Length)"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="AC_Hole_Hotspot_Control">
			<Description><![CDATA["Hotspots 0-None,1-2D,2-3D,3-All"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<Boolean Name="AC_show2DHotspotsIn3D">
			<Description><![CDATA["Show 2D Hotspots in 3D"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Length Name="ac_bottomlevel">
			<Description><![CDATA["Bottom Level"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="ac_toplevel">
			<Description><![CDATA["Top Level"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="AC_Sill_To_Curr_Story">
			<Description><![CDATA["Sill Height to Current Story"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Unique/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Integer Name="gs_macro_version">
			<Description><![CDATA["Macro Version"]]></Description>
			<Value>11</Value>
		</Integer>
		<Integer Name="AC_Hole_Display_Option">
			<Description><![CDATA["Floor Plan Display Option"]]></Description>
			<Value>3</Value>
		</Integer>
		<Angle Name="AC_Hole_Position_Angle">
			<Description><![CDATA["Hole Position Angle"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Boolean Name="AC_HoleSideMaterial">
			<Description><![CDATA["Hole has Wall's Side Surface"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="AC_HoleMaterialCurved">
			<Description><![CDATA["Hole Surface's Split is Curved in Curved Walls"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="AC_WallType">
			<Description><![CDATA["Wall Type"]]></Description>
			<Value>0</Value>
		</Integer>
		<Integer Name="AC_WindowInWallContour">
			<Description><![CDATA["Window in Wall Contour"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="4" SecondDimension="0">
				<AVal Row="1">0</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
			</ArrayValues>
		</Integer>
		<Length Name="AC_WallContourPolygon">
			<Description><![CDATA["Wall Contour Polygon"]]></Description>
			<ArrayValues FirstDimension="1" SecondDimension="3">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="AC_Wall_Direction_Type">
			<Description><![CDATA["Wall Direction Type"]]></Description>
			<Value>0</Value>
		</Integer>

		<!-- gs_options: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_options">
			<Description><![CDATA["Options"]]></Description>
		</Title>

		<!-- gs_window_frame: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_window_frame">
			<Description><![CDATA["Window Frame"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
		</Title>
		<Length Name="gs_frame_thk">
			<Description><![CDATA["Frame Thickness"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0.05</Value>
		</Length>
		<Length Name="gs_frame_width">
			<Description><![CDATA["Frame Width"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0.07</Value>
		</Length>

		<!-- gs_window_sash: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_window_sash">
			<Description><![CDATA["Sash Frame"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
		</Title>
		<Length Name="gs_sash_thk">
			<Description><![CDATA["Sash Frame Thickness"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0.05</Value>
		</Length>
		<Length Name="gs_sash_width">
			<Description><![CDATA["Sash Frame Width"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0.05</Value>
		</Length>
		<Length Name="gs_glass_thk">
			<Description><![CDATA["Glass Thickness"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0.02</Value>
		</Length>

		<!-- gs_reveal_type_new: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<String Name="gs_reveal_type_new">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="gs_reveal_type_int">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_BoldName/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<String Name="gs_reveal_type">
			<Description><![CDATA["Outer Reveal Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Без Четверти"]]></Value>
		</String>
		<Length Name="refWidth">
			<Description><![CDATA["Reference Width"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="leftWidth">
			<Description><![CDATA["Left Offset from the Origo"]]></Description>
			<Value>0</Value>
		</Length>
		<Length Name="rightWidth">
			<Description><![CDATA["Right Offset from the Origo"]]></Description>
			<Value>0</Value>
		</Length>
		<Boolean Name="bWndCurved">
			<Description><![CDATA["Curved Window"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bParalellInCurvedWalls">
			<Description><![CDATA["Parallel Opening in Curved Walls"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bDrawObjContourIn">
			<Description><![CDATA["Draw Wall Contour With LINE2 at Ref. Side"]]></Description>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bDrawObjContourOut">
			<Description><![CDATA["Draw Wall Contour With LINE2 at Opp. Side"]]></Description>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bDrawFrameContourLeft">
			<Description><![CDATA["Draw Frame Contour at Left"]]></Description>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bDrawFrameContourRight">
			<Description><![CDATA["Draw Frame Contour at Right"]]></Description>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bForceContinousMode">
			<Description><![CDATA["Force Continuous Mode"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bCornerWindow">
			<Description><![CDATA["Is Corner Window"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bWindowSymbolAtMiddle">
			<Description><![CDATA["Window in the Middle of the Wall (CHI Special)"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Angle Name="ac_corner_angle">
			<Description><![CDATA["Corner Angle"]]></Description>
			<Value>90</Value>
		</Angle>
		<Boolean Name="ac_diff_con_wall_thk">
			<Description><![CDATA["Diff. Conn. Wall Thickness"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Length Name="ac_con_wall_thk">
			<Description><![CDATA["Connecting Wall Thickness"]]></Description>
			<Value>0</Value>
		</Length>
		<FillPattern Name="fillWallHole">
			<Description><![CDATA["Wallhole Background Fill Type"]]></Description>
			<Value>0</Value>
		</FillPattern>
		<PenColor Name="penWallHoleFg">
			<Description><![CDATA["Wallhole Background Fill Pen"]]></Description>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="penWallHoleBg">
			<Description><![CDATA["Wallhole Foreground Fill Pen"]]></Description>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="penWallContour">
			<Description><![CDATA["Wall Contour Pen"]]></Description>
			<Value>0</Value>
		</PenColor>
		<LineType Name="gs_wcont_line_in">
			<Description><![CDATA["Wall Contour Line Type Inside"]]></Description>
			<Value>1</Value>
		</LineType>
		<LineType Name="gs_wcont_line_out">
			<Description><![CDATA["Wall Contour Line Type Outside"]]></Description>
			<Value>1</Value>
		</LineType>
		<PenColor Name="gs_wcont_line_pen">
			<Description><![CDATA["Wall Contour Line Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>3</Value>
		</PenColor>
		<Boolean Name="gs_bFills">
			<Description><![CDATA["Use Fills"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<FillPattern Name="gs_wallhole_fill">
			<Description><![CDATA["Plan Symbol Fill Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>65</Value>
		</FillPattern>
		<PenColor Name="gs_wallhole_pen_fg">
			<Description><![CDATA["Plan Symbol Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</PenColor>
		<PenColor Name="gs_wallhole_pen_bg">
			<Description><![CDATA["Plan Symbol Fill Background Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</PenColor>

		<!-- gs_3D_representation: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_3D_representation">
			<Description><![CDATA["3D Representation"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
		</Title>
		<PenColor Name="gs_frame_pen">
			<Description><![CDATA["Frame Pen"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>2</Value>
		</PenColor>
		<PenColor Name="gs_sash_pen">
			<Description><![CDATA["Sash Pen"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>2</Value>
		</PenColor>
		<PenColor Name="gs_glass_pen">
			<Description><![CDATA["Glass Pen"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>2</Value>
		</PenColor>

		<!-- gs_window_material: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_window_material">
			<Description><![CDATA["Surfaces"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
		</Title>
		<Material Name="gs_frame_mat">
			<Description><![CDATA["Frame Surface"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>15</Value>
		</Material>
		<Material Name="gs_sash_mat">
			<Description><![CDATA["Sash Surface"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>15</Value>
		</Material>
		<Material Name="gs_glass_mat">
			<Description><![CDATA["Glass Surface"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>24</Value>
		</Material>

		<!-- ac_details: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="ac_details">
			<Description><![CDATA["Computed Oversize Values"]]></Description>
			<Fix/>
		</Title>
		<Length Name="ac_left_oversize">
			<Description><![CDATA["AC Left Opening Oversize"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="ac_right_oversize">
			<Description><![CDATA["AC Right Opening Oversize"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="ac_upper_oversize">
			<Description><![CDATA["AC Upper Opening Oversize"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="ac_lower_oversize">
			<Description><![CDATA["AC Lower Opening Oversize"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_head_symbol: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="gs_head_symbol">
			<Description><![CDATA["Head Depth on Symbol"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<LineType Name="gs_head_symbol_line">
			<Description><![CDATA["Head Depth Symbol Line Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>21</Value>
		</LineType>
		<PenColor Name="gs_head_symbol_pen">
			<Description><![CDATA["Head Depth Symbol Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>6</Value>
		</PenColor>

		<!-- iTypeDemolitionFill: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Integer Name="iTypeDemolitionFill">
			<Description><![CDATA["Demolition / New construction"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="ifc_optypestr">
			<Description><![CDATA["IFC Operation"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA["Не определена"]]></Value>
		</String>
		<Integer Name="ifc_optype">
			<Description><![CDATA["IFC Operation"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="gs_ui_current_page">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Unique/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="gs_ui_sub_tabpage_closure">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Unique/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="ac_wido_hide_options">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>2</Value>
		</Integer>

		<!-- gs_opening_oversize: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_opening_oversize">
			<Description><![CDATA["Oversize"]]></Description>
		</Title>
		<Length Name="gs_left_oversize">
			<Description><![CDATA["Left Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_right_oversize">
			<Description><![CDATA["Right Opening Oversize"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- iRevealType: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Integer Name="iRevealType">
			<Description><![CDATA["Reveal Type"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Length Name="gs_reveal_left">
			<Description><![CDATA["Jamb Depth Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.05</Value>
		</Length>
		<Length Name="gs_reveal_right">
			<Description><![CDATA["Jamb Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.1</Value>
		</Length>
		<Angle Name="gs_reveal_left_angle">
			<Description><![CDATA["Angle Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>20</Value>
		</Angle>
		<Angle Name="gs_reveal_right_angle">
			<Description><![CDATA["Angle Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>40</Value>
		</Angle>

		<!-- StackedWindow: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="StackedWindow">
			<Description><![CDATA["Ganging"]]></Description>
		</Title>
		<Boolean Name="gs_stack_left">
			<Description><![CDATA["Connection on the Left"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_stack_right">
			<Description><![CDATA["Connection on the Right"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- gs_turn_plaster: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_turn_plaster">
			<Description><![CDATA["Turn Plaster"]]></Description>
		</Title>
		<Boolean Name="gs_useWallFinishSkin">
			<Description><![CDATA["Use Wall Finish Component"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_maxPlasterThk">
			<Description><![CDATA["Plaster Thickness Limit"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.04</Value>
		</Length>
		<Boolean Name="gs_bAutoTurnOut">
			<Description><![CDATA["Auto Turn Inside Face Plaster"]]></Description>
			<Value>1</Value>
		</Boolean>
		<Integer Name="gs_bOverOut">
			<Description><![CDATA["Turn Inside Face Plaster"]]></Description>
			<Value>0</Value>
		</Integer>
		<Boolean Name="gs_bAutoTurnIn">
			<Description><![CDATA["Auto Turn Outside Face Plaster"]]></Description>
			<Value>1</Value>
		</Boolean>
		<Integer Name="gs_bOverIn">
			<Description><![CDATA["Turn Outside Face Plaster"]]></Description>
			<Value>0</Value>
		</Integer>
		<Boolean Name="gs_turn_plaster_show_3D">
			<Description><![CDATA["Show in 3D"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<String Name="gs_closure_type">
			<Description><![CDATA["Closure Type"]]></Description>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="gs_closure_type_int">
			<Description><![CDATA["Closure Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_BoldName/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>

		<!-- gs_closureMethod: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<String Name="gs_closureMethod">
			<Description><![CDATA["Closure Type"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value><![CDATA["Традиционное"]]></Value>
		</String>
		<Integer Name="iClosureMethod">
			<Description><![CDATA["Closure Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="gs_cavity_side">
			<Description><![CDATA["Turn Skin on Side"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA["Обе"]]></Value>
		</String>
		<Integer Name="iCavityClosureSide">
			<Description><![CDATA["Turn Skin on Side"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Boolean Name="bCavityCloserLeft">
			<Description><![CDATA["Cavity Closure on the Left Side"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bCavityCloserRight">
			<Description><![CDATA["Cavity Closure on the Right Side"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Integer Name="gs_nTurn">
			<Description><![CDATA["Number of Skins to Turn"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="gs_nTurnDir">
			<Description><![CDATA["Number from"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA["Снаружи"]]></Value>
		</String>
		<Integer Name="iCavityClosureTurnDir">
			<Description><![CDATA["Number from"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>

		<!-- Traditional: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="Traditional">
			<Description><![CDATA["Traditional"]]></Description>
		</Title>

		<!-- Strip: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="Strip">
			<Description><![CDATA["Insulation Strip"]]></Description>
		</Title>
		<Boolean Name="gs_cc_dutch_ShowLeft">
			<Description><![CDATA["Place Closer on Side 2"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="gs_cc_dutch_ShowRight">
			<Description><![CDATA["Place Closer on Side 1"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="gs_cc_dutch_ShowTop">
			<Description><![CDATA["Place Closer on Top"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_cc_dutch_ShowBottom">
			<Description><![CDATA["Place Closer on Bottom"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="gs_cc_dutch_ClosureToSkin">
			<Description><![CDATA["Place Closer to Skin"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="gs_cc_dutch_ClosureToSide_str">
			<Description><![CDATA["Place Closer from Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="gs_cc_dutch_ClosureToSide">
			<Description><![CDATA["Place Closer from Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Boolean Name="gs_cc_dutch_TurnToClosure">
			<Description><![CDATA["Turn Skin to Closer"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="gs_cc_dutch_TurnToClosureOffs">
			<Description><![CDATA["Distance of Skin from Closer"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="gs_cc_dutch_widthJoint">
			<Description><![CDATA["Closer Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.038</Value>
		</Length>
		<Length Name="gs_cc_dutch_thkJoint">
			<Description><![CDATA["Closer Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.1</Value>
		</Length>
		<Boolean Name="gs_bJoint">
			<Description><![CDATA["Insert Insulation Strip"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_showJoint">
			<Description><![CDATA["Show Insulation Strip"]]></Description>
			<Value>1</Value>
		</Boolean>
		<Length Name="gs_thkJoint">
			<Description><![CDATA["Strip Thickness"]]></Description>
			<Value>1</Value>
		</Length>
		<PenColor Name="gs_penJoint">
			<Description><![CDATA["Contour Pen"]]></Description>
			<Value>0</Value>
		</PenColor>
		<LineType Name="gs_ltJoint">
			<Description><![CDATA["Contour Line Type"]]></Description>
			<Value>0</Value>
		</LineType>
		<FillPattern Name="gs_fillJoint">
			<Description><![CDATA["Fill Type"]]></Description>
			<Value>0</Value>
		</FillPattern>
		<PenColor Name="gs_penJointFg">
			<Description><![CDATA["Fill Pen"]]></Description>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="gs_penJointBg">
			<Description><![CDATA["Fill Background Pen"]]></Description>
			<Value>0</Value>
		</PenColor>
		<Boolean Name="gs_cc_dutch_matJointCustom">
			<Description><![CDATA["Custom Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Material Name="gs_cc_dutch_matJoint">
			<Description><![CDATA["Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>15</Value>
		</Material>

		<!-- Prefabricated: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="Prefabricated">
			<Description><![CDATA["Heat Insulation"]]></Description>
		</Title>
		<Length Name="gs_widthPlug">
			<Description><![CDATA["Profile Width"]]></Description>
			<Value>0.05</Value>
		</Length>
		<PenColor Name="gs_penPlug">
			<Description><![CDATA["Contour Pen"]]></Description>
			<Value>1</Value>
		</PenColor>
		<LineType Name="gs_ltPlug">
			<Description><![CDATA["Contour Line Type"]]></Description>
			<Value>1</Value>
		</LineType>
		<FillPattern Name="gs_fillPlug">
			<Description><![CDATA["Fill Type"]]></Description>
			<Value>18</Value>
		</FillPattern>
		<PenColor Name="gs_penPlugFg">
			<Description><![CDATA["Fill Pen"]]></Description>
			<Value>0</Value>
		</PenColor>
		<PenColor Name="gs_penPlugBg">
			<Description><![CDATA["Fill Background Pen"]]></Description>
			<Value>0</Value>
		</PenColor>
		<Length Name="gs_custom_cc_array_left">
			<Description><![CDATA["Left Side Skin Data"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="4">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0.015</AVal>
				<AVal Column="3" Row="1">0</AVal>
				<AVal Column="4" Row="1">1</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0.015</AVal>
				<AVal Column="3" Row="2">0</AVal>
				<AVal Column="4" Row="2">1</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0.015</AVal>
				<AVal Column="3" Row="3">0</AVal>
				<AVal Column="4" Row="3">1</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0.015</AVal>
				<AVal Column="3" Row="4">0</AVal>
				<AVal Column="4" Row="4">1</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0.015</AVal>
				<AVal Column="3" Row="5">0</AVal>
				<AVal Column="4" Row="5">1</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0.015</AVal>
				<AVal Column="3" Row="6">0</AVal>
				<AVal Column="4" Row="6">1</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0.015</AVal>
				<AVal Column="3" Row="7">0</AVal>
				<AVal Column="4" Row="7">1</AVal>
				<AVal Column="1" Row="8">0</AVal>
				<AVal Column="2" Row="8">0.015</AVal>
				<AVal Column="3" Row="8">0</AVal>
				<AVal Column="4" Row="8">1</AVal>
			</ArrayValues>
		</Length>
		<Length Name="gs_custom_cc_array_right">
			<Description><![CDATA["Right Side Skin Data"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="8" SecondDimension="4">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0.015</AVal>
				<AVal Column="3" Row="1">0</AVal>
				<AVal Column="4" Row="1">1</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0.015</AVal>
				<AVal Column="3" Row="2">0</AVal>
				<AVal Column="4" Row="2">1</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0.015</AVal>
				<AVal Column="3" Row="3">0</AVal>
				<AVal Column="4" Row="3">1</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0.015</AVal>
				<AVal Column="3" Row="4">0</AVal>
				<AVal Column="4" Row="4">1</AVal>
				<AVal Column="1" Row="5">0</AVal>
				<AVal Column="2" Row="5">0.015</AVal>
				<AVal Column="3" Row="5">0</AVal>
				<AVal Column="4" Row="5">1</AVal>
				<AVal Column="1" Row="6">0</AVal>
				<AVal Column="2" Row="6">0.015</AVal>
				<AVal Column="3" Row="6">0</AVal>
				<AVal Column="4" Row="6">1</AVal>
				<AVal Column="1" Row="7">0</AVal>
				<AVal Column="2" Row="7">0.015</AVal>
				<AVal Column="3" Row="7">0</AVal>
				<AVal Column="4" Row="7">1</AVal>
				<AVal Column="1" Row="8">0</AVal>
				<AVal Column="2" Row="8">0.015</AVal>
				<AVal Column="3" Row="8">0</AVal>
				<AVal Column="4" Row="8">1</AVal>
			</ArrayValues>
		</Length>
		<Integer Name="iCustomCCEditJambSide">
			<Description><![CDATA["Edited Jamb Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="iCustomCCEditWallSide">
			<Description><![CDATA["Edited Wall Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="iCustomCCEditSkin">
			<Description><![CDATA["Edited Skin Number"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Boolean Name="gs_custom_cc_turn_in">
			<Description><![CDATA["Turn-in Skin"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_custom_cc_plaster">
			<Description><![CDATA["Consider Skin as Plaster"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="iCustomCCThicknessType">
			<Description><![CDATA["Turn-in Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Length Name="gs_custom_cc_thickness">
			<Description><![CDATA["Custom Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.015</Value>
		</Length>
		<Integer Name="iCustomCCOrientation">
			<Description><![CDATA["Hatch Orientation"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Boolean Name="gs_custom_cc_separator">
			<Description><![CDATA["Separating Line at Turn-in"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<PenColor Name="gs_custom_cc_separator_pen">
			<Description><![CDATA["Separating Line Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</PenColor>
		<Length Name="gs_custom_cc_overhang">
			<Description><![CDATA["Skin Overhang to Frame Depth"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Boolean Name="gs_custom_cc_last_sel_side">
			<Description><![CDATA["Last Selected Side"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="gs_closure_auto_changed">
			<Description><![CDATA["Closure Method Changed Automatically"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- gs_2D_representation: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_2D_representation">
			<Description><![CDATA["2D and Section Representation"]]></Description>
			<Fix/>
		</Title>
		<PenColor Name="gs_pen_2D">
			<Description><![CDATA["Symbol Pen"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>3</Value>
		</PenColor>
		<String Name="gs_wcont_line">
			<Description><![CDATA["Wall Contour Line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Откл."]]></Value>
		</String>
		<Integer Name="iWallContourLine">
			<Description><![CDATA["Wall Contour Line"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="gs_stCavityClosure">
			<Description><![CDATA["String Resource"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="32" SecondDimension="0">
				<AVal Row="1"><![CDATA["Нет"]]></AVal>
				<AVal Row="2"><![CDATA["Традиционное"]]></AVal>
				<AVal Row="3"><![CDATA["Заводское"]]></AVal>
				<AVal Row="4"><![CDATA["Снаружи"]]></AVal>
				<AVal Row="5"><![CDATA["Внутри"]]></AVal>
				<AVal Row="6"><![CDATA["Обе"]]></AVal>
				<AVal Row="7"><![CDATA["Слева"]]></AVal>
				<AVal Row="8"><![CDATA["Справа"]]></AVal>
				<AVal Row="9"><![CDATA["Замыкание Слоев и Специальная Четверть"]]></AVal>
				<AVal Row="10"><![CDATA["Замыкание Слоев"]]></AVal>
				<AVal Row="11"><![CDATA["Способ Замыкания Изменен Автоматически"]]></AVal>
				<AVal Row="12"><![CDATA["Сторона Проема"]]></AVal>
				<AVal Row="13"><![CDATA["Наружных Слоев"]]></AVal>
				<AVal Row="14"><![CDATA["Поворачивающих Слоев"]]></AVal>
				<AVal Row="15"><![CDATA["Нумерация с"]]></AVal>
				<AVal Row="16"><![CDATA["Поворот на Четверти"]]></AVal>
				<AVal Row="17"><![CDATA["Термовкладыш"]]></AVal>
				<AVal Row="18"><![CDATA["Толщина"]]></AVal>
				<AVal Row="19"><![CDATA["Перо Контура"]]></AVal>
				<AVal Row="20"><![CDATA["Тип Линии"]]></AVal>
				<AVal Row="21"><![CDATA["Тип Штриховки"]]></AVal>
				<AVal Row="22"><![CDATA["Перо Штриховки"]]></AVal>
				<AVal Row="23"><![CDATA["Перо Фона Штр."]]></AVal>
				<AVal Row="24"><![CDATA["Профиль"]]></AVal>
				<AVal Row="25"><![CDATA["Ширина"]]></AVal>
				<AVal Row="26"><![CDATA["Поворот Штукатурки"]]></AVal>
				<AVal Row="27"><![CDATA["Снаружи"]]></AVal>
				<AVal Row="28"><![CDATA["Внутри"]]></AVal>
				<AVal Row="29"><![CDATA["Автоматически"]]></AVal>
				<AVal Row="30"><![CDATA["Поворачивающих Слоев"]]></AVal>
				<AVal Row="31"><![CDATA["Предел Толщины Штукатурки"]]></AVal>
				<AVal Row="32"><![CDATA["Использовать Отделку Стены"]]></AVal>
			</ArrayValues>
		</String>
	</Parameters>
</ParamSection>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="1" length_in_bytes="203" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000005A0000
	001408030000003A24DA2C00000009504C5445FF0000000000FFFFFFCA92C399
	0000000174524E530040E6D866000000664944415478DAD594310EC02010C348
	FFFFE84A74381464A96A7A0386CD040203E354E4A4B6B86C28B5EC15D8CED65F
	DFDA7A5196118AA717F0666BEC305BB335F852DA13D5BA2C6401D41026CB27A7
	76229BA5FFB60BA1DD166814B1B5D96795D8CE4FF5746E4A590268FEE46EBB00
	00000049454E44AE426082
	]]>
</GDLPict>

<Copyright SectVersion="1" SectionFlags="0" SubIdent="0">
	<Author>GRAPHISOFT</Author>
	<License>
		<Type>CC BY-ND</Type>
		<Version>3.0</Version>
	</License>
</Copyright>

</Symbol>
