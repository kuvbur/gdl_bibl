<?xml version="1.0" encoding="UTF-8"?>
<Symbol IsArchivable="false" IsPlaceable="false" MainGUID="6B7FBFF1-5200-4263-AE6F-AF308BB208A3" MigrationValue="Normal" Owner="1196638531" Signature="1196644685" Version="43">
<Ancestry SectVersion="1" SectionFlags="0" SubIdent="0" Template="false">
	<MainGUID>F938E33A-329D-4A36-BE3E-85E126820996</MainGUID>
	<MainGUID>B176ABF1-5813-478F-926B-28EE7C5DC1F7</MainGUID>
	<MainGUID>4FD10D67-2F29-4844-A65A-6597589B0CB5</MainGUID>
</Ancestry>

<CalledMacros SectVersion="2" SectionFlags="0" SubIdent="0">
	<Macro>
		<MName><![CDATA["macro_get_param"]]></MName>
		<MainGUID>7E78907B-4B76-4507-B54E-F469D8A39C4D</MainGUID>
	</Macro>
	<Macro>
		<MName><![CDATA["quantity_text_formatter"]]></MName>
		<MainGUID>5E4D02A3-CF83-4DE5-8F7D-C5FF522A117A</MainGUID>
	</Macro>
</CalledMacros>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_3D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_3D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_2D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
dim tempsRowsOfLabel[]

if not(bUseInSingleRank) then
! making one dimensioned array from sRowsOfLabel[][30]
	i = 1
	if bUsePrefixColumn then
		tempsRowsOfLabel = _sNameOfRow
		i = vardim1(_sNameOfRow)+1
	endif

	for iRow = 1 to vardim1(sRowsOfLabel)
		for iColu =  1 to vardim2(sRowsOfLabel)
			tempsRowsOfLabel[i] = sRowsOfLabel[iRow][iColu]
			i = i + 1
		next iColu
	next iRow
else
	for iRow = 1 to vardim2(sRowsOfLabel)
		tempsRowsOfLabel[iRow] = sRowsOfLabel[1][iRow]
	next iRow
endif

! ==============================================================================
END _nRowLabel, tempsRowsOfLabel
! ==============================================================================

]]>
</Script_2D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_1D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
_bDebug = 0
if bUsePrefixColumn then bUseInSingleRank = 0

EPS					= 0.0001
bDefaultElem = (GLOB_INTGUID = "" | GLOB_INTGUID = "{00000000-0000-0000-0000-000000000000}")

! ---- values for iCallingObject
CALLING_STRUCTURE_LABEL = 1
CALLING_DIMENSION_LABEL = 2
CALLING_GENERIC_LABEL	= 3

dim _sLocalization[]
_sLocalization[1] = `<ID>`
_sLocalization[2] = `<Специальное имя>`
_sLocalization[3] = `<Имя>`
_sLocalization[4] = `<Нет>`
_sLocalization[5] = `<Основной ID>`
_sLocalization[6] = `Специальный`

dim _sToolsName[21]
	_sToolsName[1] = `Выноска`
	_sToolsName[2] = `Объект`
	_sToolsName[3] = `Источник Света`
	_sToolsName[4] = `Окно`
	_sToolsName[5] = `Дверь`
	_sToolsName[6] = `Стена`
	_sToolsName[7] = `Колонна`
	_sToolsName[8] = `Перекрытие`
	_sToolsName[9] = `Крыша`
	_sToolsName[10] = `Штриховка`
	_sToolsName[11] = `3D-сетка`
	_sToolsName[12] = `Зона`
	_sToolsName[13] = `Балка`
	_sToolsName[14] = `Навесная Стена`
	_sToolsName[15] = `Рама Навесной Стены`
	_sToolsName[16] = `Панель Навесной Стены`
	_sToolsName[17] = `Соединение Навесной Стены`
	_sToolsName[18] = `Аксессуары Навесной Стены`
	_sToolsName[19] = `Оболочка`
	_sToolsName[20] = `Световой Люк`
	_sToolsName[21] = `Морф`

! ------------------------------------------------------------------------------
! iDTExt for Content ID
! ------------------------------------------------------------------------------

! ---- values for iIDText ----
IDVALUE_IDNUMBER	= 1
IDVALUE_CUSTOMTEXT	= 2
IDVALUE_FULLIDNUM	= 3
IDVALUE_MASTERID	= 4


VALUE_AUTOMATIC 	= 1 
VALUE_CUSTOM 		= 2

! --------------------------------------------------------------------------
! For Content Dimension
! --------------------------------------------------------------------------

! iContentOrderDim
DIM_WDT	= 1
DIM_LGT	= 2
DIM_THK	= 3
DIM_HGT	= 4

_maxDimensionNum = 4

! ------------------------------------------------------------------------------
! Reference story for Content Elevation
! ------------------------------------------------------------------------------
n = REQUEST ("REFERENCE_LEVEL_DATA", "", name1, elev1, name2, elev2, name3, elev3, name4, elev4)

dim _stRefStory[7]
	_stRefStory[1] = `Текущий Этаж`
	_stRefStory[2] = `Начало Проекта`
	_stRefStory[3] = `Основание Стены`
	_stRefStory[4] = name1
	_stRefStory[5] = name2
	_stRefStory[6] = name3
	_stRefStory[7] = name4


! ---- Values for iRefStory
REF_STORY_CURR		= 1
REF_STORY_PROJECT	= 2
REF_STORY_WALLBASE	= 3
REF_STORY_NAME1	= 4
REF_STORY_NAME2	= 5
REF_STORY_NAME3	= 6
REF_STORY_NAME4	= 7

ELEV_MESURED_FINISH = 1
ELEV_MESURED_CORE	= 2

! --------------------------------------------------------------------------
! For Content Name - Composite/Profile
! --------------------------------------------------------------------------

dim	stIDPlace[2]
	stIDPlace[1] = `как Суффикс`
	stIDPlace[2] = `как Префикс`

IDPLACE_SUFFIX			= 1
IDPLACE_PREFIX			= 2

! --------------------------------------------------------------------------
! For Content Skindata
! --------------------------------------------------------------------------
if iCallingObject = CALLING_STRUCTURE_LABEL then 
	_stSpace 	= " "
else
	_stSpace 	= ""
endif


! ---- Wall, Column and Beam CrossSection Types
WALL_SIMPLE		= 1
WALL_COMPLEX	= 2
WALL_SLANTED	= 3
WALL_TRAPEZOID	= 4

COLUMN_RECTANGULAR	= 1
COLUMN_ROUND		= 2
COLUMN_COMPLEX		= 3

BEAM_RECTANGULAR	= 1
BEAM_COMPLEX		= 2

! ---- values for iTypeSkinContent ----
CONTENT_BUILDING_MATERIAL		= 1
CONTENT_CUT_FILL 				= 2	
CONTENT_BUILDING_ID				= 3
CONTENT_BUILDING_MANUFACTURER	= 4
CONTENT_BUILDING_DESCRIPTION	= 5


! ---- values for sTypeSkinContent ----
dim sTypeSkinContentValues[5]
	sTypeSkinContentValues[1] = `Имя Строительного Материала`
	sTypeSkinContentValues[2] = `Имя Штриховки Сечения`
	sTypeSkinContentValues[3] = `ID Строительного Материала`
	sTypeSkinContentValues[4] = `Производитель Строительного Материала`
	sTypeSkinContentValues[5] = `Описание Строительного Материала`

! --------------------------------------------------------------------------
! For Content Surface Material
! --------------------------------------------------------------------------
dim _sAvailableMaterial[]
dim _iAvailableMaterial[]
dim _iAvailableMaterialContent[]
dim _sAvailableMaterialPict[]

! ------------------------------------------------------------------------------
! Content Types
! ------------------------------------------------------------------------------

CONTENT_NONE		= 1
CONTENT_DIM 		= 2			
CONTENT_VOL			= 3
CONTENT_SURF		= 4
CONTENT_ID			= 5
CONTENT_ELEMENT_NAME= 6
CONTENT_STRUCT_NAME	= 7
CONTENT_CUSTOM		= 8
CONTENT_ELEV		= 9
CONTENT_SKIN		= 10
CONTENT_MATERIAL	= 11
CONTENT_AREA		= 12

_bEnableContentDimension	= 0
_bEnableContentVolume		= 0
_bEnableContentSurface		= 0
_bEnableContentID			= 0
_bEnableContentElementName	= 0
_bEnableContentStructName	= 0
_bEnableContentCustomText	= 0
_bEnableContentElevation	= 0
_bEnableContentSkinData		= 0
_bEnableContentMaterial		= 0
_bEnableContentArea			= 0

for iContent = 1 to vardim1(iSelectedContent)
	if iSelectedContent[iContent] = CONTENT_DIM				then _bEnableContentDimension = 1
	if iSelectedContent[iContent] = CONTENT_VOL				then _bEnableContentVolume = 1
	if iSelectedContent[iContent] = CONTENT_SURF			then _bEnableContentSurface = 1
	if iSelectedContent[iContent] = CONTENT_ID				then _bEnableContentID = 1
	if iSelectedContent[iContent] = CONTENT_ELEMENT_NAME	then _bEnableContentElementName = 1
	if iSelectedContent[iContent] = CONTENT_STRUCT_NAME		then _bEnableContentStructName = 1
	if iSelectedContent[iContent] = CONTENT_CUSTOM			then _bEnableContentCustomText = 1
	if iSelectedContent[iContent] = CONTENT_ELEV			then _bEnableContentElevation = 1
	if iSelectedContent[iContent] = CONTENT_SKIN			then _bEnableContentSkinData = 1
	if iSelectedContent[iContent] = CONTENT_MATERIAL		then _bEnableContentMaterial = 1
	if iSelectedContent[iContent] = CONTENT_AREA			then _bEnableContentArea = 1
next iContent

dim _sSubroutine[12]
	_sSubroutine[CONTENT_NONE] 			= "ContentNone"				
	_sSubroutine[CONTENT_DIM] 			= "ContentDimension"
	_sSubroutine[CONTENT_VOL] 			= "ContentVolume"	
	_sSubroutine[CONTENT_SURF] 			= "ContentSurface"
	_sSubroutine[CONTENT_ID] 			= "ContentID"
	_sSubroutine[CONTENT_ELEMENT_NAME]	= "ContentElementName"
	_sSubroutine[CONTENT_STRUCT_NAME]	= "ContentStructName"
	_sSubroutine[CONTENT_CUSTOM] 		= "ContentCustom"
	_sSubroutine[CONTENT_ELEV] 			= "ContentElevation"
	_sSubroutine[CONTENT_SKIN] 			= "ContentSkindata"
	_sSubroutine[CONTENT_MATERIAL]		= "ContentMaterial"
	_sSubroutine[CONTENT_AREA]			= "ContentArea"

dim _nRowLocal [12]
	_nRowLocal[CONTENT_NONE] 			= 0	! always 0
	_nRowLocal[CONTENT_DIM] 			= 0
	_nRowLocal[CONTENT_VOL] 			= 0
	_nRowLocal[CONTENT_SURF] 			= 0
	_nRowLocal[CONTENT_ID] 				= 0
	_nRowLocal[CONTENT_ELEMENT_NAME]	= 0
	_nRowLocal[CONTENT_STRUCT_NAME]		= 0
	_nRowLocal[CONTENT_CUSTOM] 			= 0
	_nRowLocal[CONTENT_ELEV] 			= 0
	_nRowLocal[CONTENT_SKIN] 			= 0
	_nRowLocal[CONTENT_MATERIAL]	 	= 0
	_nRowLocal[CONTENT_AREA] 			= 0

! ------------------------------------------------------------------------------
! Unit Types - values for iUnitLocal parameter
! ------------------------------------------------------------------------------

DIMUNIT_MM			= 11  
DIMUNIT_CM			= 12
DIMUNIT_METER		= 13
DIMUNIT_INCH		= 14
DIMUNIT_DM			= 15
DIMUNIT_PROJECT		= 10

SURFUNIT_SQM		= 21
SURFUNIT_SQCM		= 22
SURFUNIT_SQMM		= 23
SURFUNIT_SQFT		= 24
SURFUNIT_SQINCH		= 25
SURFUNIT_PROJECT	= 20

VOLUNIT_CM			= 31
VOLUNIT_L			= 32
VOLUNIT_CCM			= 33
VOLUNIT_CMM			= 34
VOLUNIT_CFEET		= 35
VOLUNIT_CINCH		= 36
VOLUNIT_CYARD		= 37
VOLUNIT_GAL			= 38
VOLUNIT_PROJECT		= 30


! ------------------------------------------------------------------------------
! Elem Types
! ------------------------------------------------------------------------------

! --- values for GLOB_ELEM_TYPE ---
ELEM_TYPE_LABEL		= 0
ELEM_TYPE_OBJECT	= 1
ELEM_TYPE_LAMP		= 2
ELEM_TYPE_WINDOW	= 3
ELEM_TYPE_DOOR		= 4
ELEM_TYPE_WALL		= 5
ELEM_TYPE_COLUMN	= 6
ELEM_TYPE_SLAB		= 7
ELEM_TYPE_ROOF		= 8
ELEM_TYPE_FILL		= 9
ELEM_TYPE_MESH		= 10
ELEM_TYPE_ZONE		= 11
ELEM_TYPE_BEAM		= 12
ELEM_TYPE_CW		= 13
ELEM_TYPE_CWFRAME	= 14
ELEM_TYPE_CWPANEL	= 15
ELEM_TYPE_CWJUNCT	= 16
ELEM_TYPE_CWACC		= 17
ELEM_TYPE_SHELL		= 18
ELEM_TYPE_SKYLIGHT	= 19
ELEM_TYPE_MORPH		= 20


! ------------------------------------------------------------------------------
! Skin Structure List type by elem types
! ------------------------------------------------------------------------------
if _bEnableContentSkinData then
	! ---- values for _iSkinListClass ----

	LIST_CUSTOM_ONLY 	= 0		! "Show Skin by" is locked
								! automatically displaying "<Skin Data>"
								! Custom Content (Custom skin names) is only available
	LIST_NAME_FILL		= 1		! "Show Skin by" is locked
								! automatically displaying SYMB_FILL
								! Custom Content (Custom skin names) is only available
	LIST_NAME_COMPLEX	= 2		! "Show Skin by" is locked
								! automatically displaying Profile Name
								! Custom Content (Custom skin names) is only available
	LIST_THK_FILL		= 3		! "Show Skin by" is available
								! automatically displaying all Content Types with skin thickness
								! Custom Content (Custom skin names) is available
	LIST_FILL_ONLY		= 4		! "Show Skin by" is available
								! automatically displaying all Content Types without skin thickness
								! Custom Content (Custom skin names) is available
	LIST_DIM_FILL		= 5		! "Show Skin by" is available
								! automatically displaying all Content Types with element dimensions
								! Custom Content (Custom skin names) is available


	! initialize here, because _iSkinListClass is used in parameter script
	_iSkinListClass = LIST_CUSTOM_ONLY

	if GLOB_ELEM_TYPE = ELEM_TYPE_OBJECT then	_iSkinListClass = LIST_NAME_FILL
	if GLOB_ELEM_TYPE = ELEM_TYPE_FILL then
		if fill_fill_category = 1 and FILL_BMAT_NAME <> "" then
			! Cut fill - Building Material
			_iSkinListClass = LIST_FILL_ONLY
		else
			! Draw, Cover and nature Cut fill
			_iSkinListClass = LIST_NAME_FILL
		endif
	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_MORPH then	_iSkinListClass = LIST_FILL_ONLY
	if GLOB_ELEM_TYPE = ELEM_TYPE_MESH then		_iSkinListClass = LIST_FILL_ONLY

	if GLOB_ELEM_TYPE = ELEM_TYPE_ROOF then		_iSkinListClass = LIST_THK_FILL
	if GLOB_ELEM_TYPE = ELEM_TYPE_SLAB then		_iSkinListClass = LIST_THK_FILL
	if GLOB_ELEM_TYPE = ELEM_TYPE_SHELL then	_iSkinListClass = LIST_THK_FILL

	if GLOB_ELEM_TYPE = ELEM_TYPE_WALL then
		if ac_wall_crosssection_type = WALL_COMPLEX then
			_iSkinListClass = LIST_NAME_COMPLEX
		else
			_iSkinListClass = LIST_THK_FILL
		endif
	endif
	if GLOB_ELEM_TYPE = ELEM_TYPE_COLUMN then
		if ac_colu_crosssection_type = COLUMN_COMPLEX then
			_iSkinListClass = LIST_NAME_COMPLEX
		else
			_iSkinListClass = LIST_DIM_FILL
		endif
	endif
	if GLOB_ELEM_TYPE = ELEM_TYPE_BEAM then
		if ac_beam_crosssection_type = BEAM_COMPLEX then
			_iSkinListClass = LIST_NAME_COMPLEX
		else
			_iSkinListClass = LIST_DIM_FILL
		endif
	endif
endif

! ==============================================================================
! Picture file_dependence for Surface UI - ContentMaterial
! ==============================================================================

file_dependence "ui_wall_outside_flat(1)"
file_dependence "ui_wall_inside_flat(1)"
file_dependence "ui_wall_edge_flat(1)"

file_dependence "ui_general_surface_flat(1)"

file_dependence "ui_slab_top_flat(1)"
file_dependence "ui_slab_edge_flat(1)"
file_dependence "ui_slab_bottom_flat(1)"

file_dependence "ui_mesh_top_flat(1)"
file_dependence "ui_mesh_skirt_flat(1)"
file_dependence "ui_mesh_bottom_flat(1)"

file_dependence "ui_beam_right_flat(1)"
file_dependence "ui_beam_left_flat(1)"
file_dependence "ui_beam_top_flat(1)"
file_dependence "ui_beam_bottom_flat(1)"
file_dependence "ui_beam_end_flat(1)"

file_dependence "ui_cw_outside_flat(1)"
file_dependence "ui_cw_inside_flat(1)"
file_dependence "ui_cw_edge_flat(1)"

file_dependence "ui_shell_reference_flat(1)"
file_dependence "ui_shell_edge_flat(1)"
file_dependence "ui_shell_opposite_flat(1)"

file_dependence "ui_custom_text_flat(1)"

! ==============================================================================
! inicializing container arrays
! ==============================================================================
! dynamic string array storing data segments. Each content-subroutine fills up this array with their own data.

dim _sSegmentLocal[][5]	
	_sSegmentLocal[1][1] = ""			! note 1 (prefix + number)
	_sSegmentLocal[1][2] = ""			! note 2 (frac)
	_sSegmentLocal[1][3] = ""			! note 3 (unit)
	_sSegmentLocal[1][4] = ""			! note 4 (unit index)
	_sSegmentLocal[1][5] = ""			! suffix

! dynamic string array storing data segments. The local _sSegmentLocal strings provided by the content-type-subroutines are filled into this one single array.
dim _sSegmentGlobal[][5]
for i = 1 to 32
	_sSegmentGlobal[i][1] = ""			! note 1 (prefix + number)
	_sSegmentGlobal[i][2] = ""			! note 2 (frac)
	_sSegmentGlobal[i][3] = ""			! note 3 (unit)
	_sSegmentGlobal[i][4] = ""			! note 4 (unit index)
	_sSegmentGlobal[i][5] = ""			! suffix
next i

! dynamic numeric array storing content Type and number of rows
dim _iRowInfo[][3]	! CONTENT: first column stores the index of content types (current value of iSelectedContent is loaded into it)
					! LOCALROW: second column stores the local index of row of the current content type ( _nRowLocal is loaded into it)
					! PARTS_ORDER: third column stores the local index of row of the current display mod (in one row 1,2,3 and alone the 1) ( _displayInOneRowLocal is loaded into it)
CONTENT		= 1
LOCALROW	= 2
PARTS_ORDER	= 3

dim _displayInOneRowLocal[]
	_displayInOneRowLocal[1] = 0


! ==============================================================================
! filling up output container arrays
! ==============================================================================
!if _bDebug then gosub "debugArrays"


_nRowGlobal = 1

for i = 1 to vardim1(iSelectedContent)								!i : running through user-selected enabled content types
	temp = 0
	if iSelectedContent[i] <> 0 then
		temp = iSelectedContent[i]
		gosub _sSubroutine[temp]	! returned _nRowLocal[], _sSegmentLocal[][]
		for m = 1 to _nRowLocal[temp]								!m : running through rows of content returned by the subroutine
				for n = 1 to vardim2(_sSegmentLocal)				!n : the container string array has 5 columns for 5 stringsegments
					_sSegmentGlobal[_nRowGlobal][n]= _sSegmentLocal[m][n]
				next n
			_iRowInfo [_nRowGlobal][CONTENT] = temp
			_iRowInfo [_nRowGlobal][LOCALROW] = m
			if bUseInSingleRank then
				_iRowInfo [_nRowGlobal][PARTS_ORDER] = _nRowGlobal
			else
				_iRowInfo [_nRowGlobal][PARTS_ORDER] = _displayInOneRowLocal[m]
			endif

			_nRowGlobal = _nRowGlobal + 1
		next m
	endif
next i

!if _bDebug then gosub "debugArrays"

_nRowGlobal = _nRowGlobal -1




! ==============================================================================
! rows of label
! ==============================================================================
dim sRowsOfLabel [][30]
for k = 1 to 30
	sRowsOfLabel[1][k] = ""
next k

dim iContentOfRow[]
	iContentOfRow[1] = 0

dim _sNameOfRow[]
	_sNameOfRow[1] = ""

iirows 		= 1
iisegments 	= 1

if _bDebug then gosub "debugArrays"


for i = 1 to _nRowGlobal

	iContentOfRow[iirows] 		= _iRowInfo[i][CONTENT]

	! Fill Name Column
	if bUsePrefixColumn then
		_sNameOfRow[iirows] = sContentTypeNames[ _iRowInfo[i][CONTENT]]
	endif


	for j = 1 to  5	! max Segments

		! Fill array with definitived text data
		sRowsOfLabel[iirows][iisegments] = _sSegmentGlobal[i][j]

		iisegments  = iisegments +1

	next j

	if i = _nRowGlobal then 
		_iRowInfo[i+1][CONTENT]		= 0		! avoiding error "Index value greater than array dimension" 
		_iRowInfo[i+1][LOCALROW]	= 0		! avoiding error "Index value greater than array dimension" 
		for k = iisegments to 30
			sRowsOfLabel[iirows][k] = ""
		next k
		iisegments  = 1
		iirows = iirows +1
	else
		if (_iRowInfo[i][PARTS_ORDER]) >= (_iRowInfo[i+1][PARTS_ORDER]) then
			for k = iisegments to 30
				sRowsOfLabel[iirows][k] = ""
			next k
			iisegments  = 1
			iirows = iirows +1
		endif
	endif
next i


if _bDebug then gosub "debugArrays"

_nRowLabel = iirows -1


! ==============================================================================
! ==============================================================================
goto "MasterEnd"	!	END	!	END	!	END	!	END	!	END	!	END	!	END
! ==============================================================================
! ==============================================================================

! ==============================================================================
"ContentNone" :	! content 1
! ==============================================================================
	_nRowLocal[CONTENT_NONE] = 0
	_iUnitType = iUnitLocal[CONTENT_NONE]	! = 0 (No Unit)

	gosub "clearing_sSegmentLocal_array"

!	_sSegmentLocal[1][5] = _sLocalization[4]	! "<None>"
	_sSegmentLocal[1][5] = ""	! empty string

	_nRowLocal [CONTENT_NONE] = 1

	for iRank = 1 to vardim1(_nRowLocal)
		_displayInOneRowLocal[iRank] = 1
	next iRank 	
return

! ==============================================================================
"ContentDimension":	! content 2
! ==============================================================================
	_nRowLocal [CONTENT_DIM] = 0
	_iUnitType = iUnitLocal[CONTENT_DIM]

	gosub "clearing_sSegmentLocal_array"

! ------------------------------------------------------------------------------
!  generating numerical content by Elem Types 
! ------------------------------------------------------------------------------

	dim	_contentNumericDim[5]
		_contentNumericDim[1] =  0
		_contentNumericDim[2] =  0
		_contentNumericDim[3] =  0
		_contentNumericDim[4] =  0 
		_contentNumericDim[5] =  0 

	_nContent = 1
	_specWallThickDisplay1 = 0
	_specWallThickDisplay2 = 0


	if GLOB_ELEM_TYPE = ELEM_TYPE_OBJECT | GLOB_ELEM_TYPE = ELEM_TYPE_LAMP |\
		GLOB_ELEM_TYPE = ELEM_TYPE_CWJUNCT |  GLOB_ELEM_TYPE = ELEM_TYPE_CWACC then
		_nContent = 1

		for iCol = 1 to _maxDimensionNum
			if iContentOrderDim[iCol] = DIM_WDT & bShowWidth then 
				 _contentNumericDim[_nContent] =  SYMB_A_SIZE : _nContent = _nContent+1 
			endif
			if iContentOrderDim[iCol] = DIM_LGT & bShowLength then 
				_contentNumericDim[_nContent] =  SYMB_B_SIZE : _nContent = _nContent+1 
			endif
			if iContentOrderDim[iCol] = DIM_HGT & bShowHeight then 
				_contentNumericDim[_nContent] =  SYMB_Z_SIZE : _nContent = _nContent+1 
			endif
		next iCol

	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_DOOR | GLOB_ELEM_TYPE = ELEM_TYPE_WINDOW | GLOB_ELEM_TYPE = ELEM_TYPE_SKYLIGHT then
		_nContent = 1

		for iCol = 1 to _maxDimensionNum
			if iContentOrderDim[iCol] = DIM_WDT & bShowWidth then
				rrr = request ("ASSOCLP_PARVALUE", "A",	index_ww, type_ww, flags_ww, dim1_ww, dim2_ww, _widthValue)
				 _contentNumericDim[_nContent] =  _widthValue : _nContent = _nContent+1 
			endif
			if iContentOrderDim[iCol] = DIM_HGT & bShowHeight then
				rrr = request ("ASSOCLP_PARVALUE", "B", index_ww, type_ww, flags_ww, dim1_ww, dim2_ww, _heightValue)
				_contentNumericDim[_nContent] =  _heightValue : _nContent = _nContent+1 
			endif
		next iCol

	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_ROOF then
		_nContent = 1
		if bShowThickness 	then 
			_contentNumericDim[_nContent] = ROOF_THICKNESS : _nContent = _nContent+1
 		endif
	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_SLAB then	
		_nContent = 1
		if bShowThickness 	then 
			_contentNumericDim[_nContent] = SLAB_THICKNESS : _nContent = _nContent+1 
		endif
	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_WALL then
		_nContent = 1

		for iCol = 1 to _maxDimensionNum
			if iContentOrderDim[iCol] = DIM_LGT & bShowLength then  
				_contentNumericDim[_nContent] = WALL_LENGTH_A : _nContent = _nContent+1
			endif

			if iContentOrderDim[iCol] = DIM_THK & bShowThickness then
				! if the wall has trapezoid shape in floorplan, the Thickness is displayed as follows: (<thickness1>-<thickness2>)
				if abs(WALL_INCL) > EPS then	!WALL_INCL = angle between the two inclined wall surfaces - 0 for common straight walls		
					_contentNumericDim[_nContent] = min(WALL_START_THICKNESS, WALL_END_THICKNESS)
					_specWallThickDisplay1 = _nContent
					_nContent = _nContent + 1
					_contentNumericDim[_nContent] = max(WALL_START_THICKNESS, WALL_END_THICKNESS)
					_specWallThickDisplay2 = _nContent
					_nContent = _nContent + 1
				else
					_contentNumericDim[_nContent] = WALL_THICKNESS
					_nContent = _nContent + 1
				endif
			endif

			if iContentOrderDim[iCol] = DIM_HGT & bShowHeight 	then 
				_contentNumericDim[_nContent] = WALL_HEIGHT : _nContent = _nContent + 1 
			endif
		next iCol

	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_SHELL then
		_nContent 			= 1
		if bShowThickness then 	
			_contentNumericDim[_nContent] = SHELLBASE_THICKNESS : _nContent = _nContent + 1 
		endif
	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_COLUMN then
		_nContent 	= 1

		for iCol = 1 to _maxDimensionNum
			if iContentOrderDim[iCol] = DIM_WDT & bShowWidth then 
				_contentNumericDim[_nContent] = COLU_CORE_X : _nContent= _nContent + 1 
			endif
			if iContentOrderDim[iCol] = DIM_LGT & bShowLength then 
				_contentNumericDim[_nContent] = COLU_CORE_Y : _nContent= _nContent + 1 
			endif
			if iContentOrderDim[iCol] = DIM_HGT & bShowHeight then 
				_contentNumericDim[_nContent] = COLU_HEIGHT : _nContent= _nContent + 1 
			endif
		next iCol

	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_BEAM then
		_nContent 	= 1

		for iCol = 1 to _maxDimensionNum
			if iContentOrderDim[iCol] = DIM_WDT & bShowWidth then 
				_contentNumericDim[_nContent] = BEAM_THICKNESS 	: _nContent= _nContent + 1 
			endif
			if iContentOrderDim[iCol] = DIM_LGT & bShowLength then 
				_contentNumericDim[_nContent] = BEAM_LENGTH_RIGHT 	: _nContent= _nContent + 1 
			endif
			if iContentOrderDim[iCol] = DIM_HGT & bShowHeight then 
				_contentNumericDim[_nContent] = BEAM_HEIGHT 		: _nContent= _nContent + 1 
			endif
		next iCol
	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_MESH then
		_nContent 	= 1
		if bShowHeight then 	
			_contentNumericDim[_nContent] =  MESH_BASE_OFFSET : _nContent = _nContent + 1 
		endif
	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_CW then
		_nContent 	= 1

		for iCol = 1 to _maxDimensionNum
			if iContentOrderDim[iCol] = DIM_LGT & bShowLength then 
				_contentNumericDim[_nContent] = CWALL_LENGTH 		: _nContent= _nContent + 1 
			endif
			if iContentOrderDim[iCol] = DIM_HGT & bShowHeight then 
				_contentNumericDim[_nContent] = CWALL_HEIGHT 		: _nContent= _nContent + 1 
			endif
			if iContentOrderDim[iCol] = DIM_THK & bShowThickness then 
				_contentNumericDim[_nContent] = CWALL_THICKNESS 	: _nContent= _nContent + 1 
			endif
		next iCol
	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_CWFRAME then
		_nContent 	= 1

		for iCol = 1 to _maxDimensionNum
			if iContentOrderDim[iCol] = DIM_WDT & bShowWidth then 
				_contentNumericDim[_nContent] = CWFRAME_WIDTH 	: _nContent= _nContent + 1 
			endif
			if iContentOrderDim[iCol] = DIM_HGT & bShowHeight then 
				_contentNumericDim[_nContent] = CWFRAME_DEPTH 		: _nContent= _nContent + 1 
			endif
			if iContentOrderDim[iCol] = DIM_LGT & bShowLength then 
				_contentNumericDim[_nContent] = CWFRAME_LENGTH 		: _nContent= _nContent + 1 
			endif
		next iCol
	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_CWPANEL then
		_nContent 	= 1

		for iCol = 1 to _maxDimensionNum
			if iContentOrderDim[iCol] = DIM_WDT & bShowWidth then 
				_contentNumericDim[_nContent] = CWPANEL_WIDTH 	: _nContent= _nContent + 1 
			endif
			if iContentOrderDim[iCol] = DIM_HGT & bShowHeight then 
				_contentNumericDim[_nContent] = CWPANEL_HEIGHT 		: _nContent= _nContent + 1 
			endif
			if iContentOrderDim[iCol] = DIM_LGT & bShowLength then 
				_contentNumericDim[_nContent] = CWPANEL_THICKNESS 		: _nContent= _nContent + 1 
			endif
		next iCol
	endif



	if GLOB_ELEM_TYPE = ELEM_TYPE_LABEL then
		_sSegmentLocal[1][5] = `<Размеры>`
		_nContent = _nContent + 1
	else

		for z = 1 to vardim1(_contentNumericDim)
			_calledValue = _contentNumericDim[z] : prefix = ""
			if _specWallThickDisplay1 = z then prefix = "(" ! Special thickness display for trapezoid walls

			gosub "ConvertNumericalValueToString"

			_sSegmentLocal[z][1] = note1			! note 1 (prefix + number)
			_sSegmentLocal[z][2] = note2			! note 2 (frac)
			_sSegmentLocal[z][3] = note3			! note 3 (unit)
			_sSegmentLocal[z][4] = note4			! note 4 (unit index)

			if z  = 5 then 
				_sSegmentLocal[z][5] = ""			! suffix
			else
				if abs(_contentNumericDim[z+1]) > EPS then
					_sSegmentLocal[z][5] = strSeparator		! suffix
				else
					_sSegmentLocal[z][5] = ""		! suffix
				endif
			endif
			if _specWallThickDisplay2 = z then 
				_sSegmentLocal[z][5] = ")"				! Special thickness display for trapezoid walls
				if abs(_contentNumericDim[z+1]) > EPS then _sSegmentLocal[z][5] = _sSegmentLocal[z][5] + strSeparator 
			endif
			if _specWallThickDisplay1 = z then _sSegmentLocal[z][5] = "-"					! Special thickness display for trapezoid walls
		next z
	endif

	_nRowLocal [CONTENT_DIM] = _nContent-1

	for iRank = 1 to vardim1(_nRowLocal)
		_displayInOneRowLocal[iRank] = iRank	! in Single Rank - diplays all of datas in one row
	next iRank 	

return 

! ==============================================================================
"ContentVolume":	! content 3
! ==============================================================================
	_nRowLocal [CONTENT_VOL] = 0
	_iUnitType = iUnitLocal[CONTENT_VOL] 

	gosub "clearing_sSegmentLocal_array"

	_contentNumericVol = 0

	if GLOB_ELEM_TYPE = ELEM_TYPE_SLAB		then _contentNumericVol = SLAB_VOLUME
	if GLOB_ELEM_TYPE = ELEM_TYPE_WALL 		then _contentNumericVol = WALL_VOLUME
	if GLOB_ELEM_TYPE = ELEM_TYPE_SHELL 	then _contentNumericVol = SHELLBASE_VOLUME
	if GLOB_ELEM_TYPE = ELEM_TYPE_COLUMN 	then _contentNumericVol = COLU_VOLUME
	if GLOB_ELEM_TYPE = ELEM_TYPE_BEAM 		then _contentNumericVol = BEAM_VOLUME 
	if GLOB_ELEM_TYPE = ELEM_TYPE_MESH 		then _contentNumericVol = MESH_VOLUME
	if GLOB_ELEM_TYPE = ELEM_TYPE_ROOF 		then _contentNumericVol = ROOF_VOLUME
	if GLOB_ELEM_TYPE = ELEM_TYPE_MORPH 	then _contentNumericVol = MORPH_VOLUME
	if GLOB_ELEM_TYPE = ELEM_TYPE_LABEL then
		_sSegmentLocal[1][5] = `<Объем>`
	else
		_calledValue = _contentNumericVol : prefix = ""
		gosub "ConvertNumericalValueToString"
		_sSegmentLocal[1][1] = note1			! note 1 (prefix + number)
		_sSegmentLocal[1][2] = note2			! note 2 (frac)
		_sSegmentLocal[1][3] = note3			! note 3 (unit)
		_sSegmentLocal[1][4] = note4			! note 4 (unit index)
		_sSegmentLocal[1][5] = ""			! suffix
	endif	

	_nRowLocal [CONTENT_VOL] = 1
	for iRank = 1 to vardim1(_nRowLocal)
		_displayInOneRowLocal[iRank] = 1
	next iRank 	
return 

! ==============================================================================
"ContentSurface":	! content 4
! ==============================================================================
	_nRowLocal [CONTENT_SURF] = 0
	_iUnitType = iUnitLocal[CONTENT_SURF]

	gosub "clearing_sSegmentLocal_array"

! ------------------------------------------------------------------------------
!  generating numerical content by Elem Types 
! ------------------------------------------------------------------------------
	_contentNumericSurf = 0


	if GLOB_ELEM_TYPE = ELEM_TYPE_ROOF then 
		_contentNumericSurf =	bAddTopSurface		* ROOF_TOP_SURF		+ \
								bAddBottomSurface	* ROOF_BOTTOM_SURF	+ \
								bAddEdgeSurface		* ROOF_EDGE_SURF
	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_SLAB then
		_contentNumericSurf =	bAddTopSurface		* SLAB_TOP_SURF + \
								bAddBottomSurface	* SLAB_BOT_SURF + \
								bAddEdgeSurface		* SLAB_EDGE_SURF
	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_WALL then
		_contentNumericSurf =	bAddRefSideSurface	* WALL_SURFACE_A + \
								bAddOppSideSurface	* WALL_SURFACE_B + \
								bAddEdgeSurface		* WALL_EDGE_SURF

	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_SHELL then
		_contentNumericSurf =	bAddOppSideSurface	* SHELLBASE_OPPOSITE_SURF	+ \
								bAddRefSideSurface	* SHELLBASE_REFERENCE_SURF	+ \
								bAddEdgeSurface		* SHELLBASE_EDGE_SURF
	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_COLUMN then
		if COLU_VENEER_WIDTH > EPS then
			_contentNumericSurf =	bAddSideSurface		* COLU_VENEER_SURF		+ \
									bAddTopSurface		* COLU_VENEER_TOP_SURF	+ \
									bAddBottomSurface	* COLU_VENEER_BOT_SURF
		else
			_contentNumericSurf =	bAddSideSurface		* COLU_CORE_SURF	+ \
									bAddTopSurface		* COLU_CORE_TOP_SURF + \
									bAddBottomSurface	* COLU_CORE_BOT_SURF
		endif
	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_BEAM then
		_contentNumericSurf =	bAddRefSideSurface	* BEAM_RIGHT_SURF	+ \
								bAddOppSideSurface	* BEAM_LEFT_SURF	+ \
								bAddTopSurface		* BEAM_TOP_SURF		+ \
								bAddBottomSurface	* BEAM_BOTTOM_SURF	+ \
								bAddEdgeSurface		* BEAM_END_SURF
	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_MORPH then  _contentNumericSurf =  MORPH_SURFACE

	if GLOB_ELEM_TYPE = ELEM_TYPE_FILL then  _contentNumericSurf =  bAddTopSurface		* FILL_SURF

	if GLOB_ELEM_TYPE = ELEM_TYPE_MESH then
		_contentNumericSurf =	bAddTopSurface		* MESH_TOP_SURF		+ \
								bAddBottomSurface	* MESH_BOTTOM_SURF	+ \
								bAddEdgeSurface		* MESH_EDGE_SURF
	endif


	if GLOB_ELEM_TYPE = ELEM_TYPE_LABEL then
		_sSegmentLocal[1][5] = `<Площадь Поверхности>`
	else
		if bMorphSurfacePlacehold then
			_sSegmentLocal[1][5] = `Площадь под-поверхностей недоступна для Морфов`
		else
			_calledValue = _contentNumericSurf : prefix = ""
			gosub "ConvertNumericalValueToString"
			_sSegmentLocal[1][1] = note1			! note 1 (prefix + number)
			_sSegmentLocal[1][2] = note2			! note 2 (frac)
			_sSegmentLocal[1][3] = note3			! note 3 (unit)
			_sSegmentLocal[1][4] = note4			! note 4 (unit index)
			_sSegmentLocal[1][5] = ""				! suffix
		endif
	endif

	_nRowLocal [CONTENT_SURF] = 1
	for iRank = 1 to vardim1(_nRowLocal)
		_displayInOneRowLocal[iRank] = 1
	next iRank 
return 

! ==============================================================================
"ContentID":	! content 5
! ==============================================================================
	_nRowLocal [CONTENT_ID] = 0
	_iUnitType = iUnitLocal[CONTENT_ID] 	! = 0 (No Unit)

	gosub "clearing_sSegmentLocal_array"

	if iIDText = IDVALUE_CUSTOMTEXT then
		_sSegmentLocal[1][1] = sIDTextCustom
	else
		dim _MasterID[]
		result = REQUEST("Full_ID_of_parent", "", _MasterID)
		_sSegmentLocal[1][1] = ""
		if result then
			if iIDText = IDVALUE_IDNUMBER then
				_sSegmentLocal[1][1] = _MasterID[vardim1(_MasterID)]
			else
				_end = 1
				if iIDText = IDVALUE_MASTERID then _end = vardim1 (_MasterID) - 1
				if iIDText = IDVALUE_FULLIDNUM then _end = vardim1 (_MasterID)
				for kk = 1 to _end
					_sSegmentLocal[1][1] = _sSegmentLocal[1][1] + _MasterID[kk]
				next kk
			endif
		endif

		if _sSegmentLocal[1][1] = "" then
			if iIDText = IDVALUE_IDNUMBER then
				_sSegmentLocal[1][1] = _sLocalization[1]		! `<ID>`
			else
				_sSegmentLocal[1][1] = _sLocalization[5]		! `<Master ID>`
			endif
		endif
	endif

	_sSegmentLocal[1][1] = sPrefixID + _sSegmentLocal[1][1]
	_sSegmentLocal[1][5] = sSuffixID

	_nRowLocal[CONTENT_ID] = 1
	for iRank = 1 to vardim1(_nRowLocal)
		_displayInOneRowLocal[iRank] = 1
	next iRank 
return 

! ==============================================================================
"ContentElementName":	! content 6
! ==============================================================================
	_nRowLocal [CONTENT_ELEMENT_NAME] = 0
	_iUnitType = iUnitLocal[CONTENT_ELEMENT_NAME] 	! = 0 (No Unit)

	gosub "clearing_sSegmentLocal_array"

	_compNameText = _sToolsName[GLOB_ELEM_TYPE+1]

	if GLOB_ELEM_TYPE = ELEM_TYPE_LABEL then
		_labelnameGSM = ""
		nnn = REQUEST ("Name_of_main", "", _labelnameGSM)

		if nnn then
			_iDotPos = strstr (_labelnameGSM, ".")
			_compNameText = strsub (_labelnameGSM, 1, _iDotPos - 1)
		endif
	endif

	if	GLOB_SCRIPT_TYPE <> 5					&\
		(GLOB_ELEM_TYPE = ELEM_TYPE_OBJECT		|\
		 GLOB_ELEM_TYPE = ELEM_TYPE_LAMP		|\
		 GLOB_ELEM_TYPE = ELEM_TYPE_DOOR		|\
		 GLOB_ELEM_TYPE = ELEM_TYPE_WINDOW		|\
		 GLOB_ELEM_TYPE = ELEM_TYPE_SKYLIGHT)	then
		_dummy = request("Assoclp_Name", "", _compNameText)
	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_CWFRAME then _compNameText = CWFRAME_TYPE
	if GLOB_ELEM_TYPE = ELEM_TYPE_CWPANEL then _compNameText = CWPANEL_TYPE
	if GLOB_ELEM_TYPE = ELEM_TYPE_CWJUNCT then _compNameText = CWJUNC_TYPE
	if GLOB_ELEM_TYPE = ELEM_TYPE_CWACC then _compNameText = CWACC_TYPE

	if GLOB_ELEM_TYPE = ELEM_TYPE_FILL then
		if fill_fill_category = 1 and FILL_BMAT_NAME <> "" then
			! Cut fill - Building Material
			_compNameText = _sToolsName[GLOB_ELEM_TYPE+1]
		else
			_fillName = ""
			if GLOB_SCRIPT_TYPE <> 5 then
				n = request("Name_of_fill", FILL_FILL, _fillName)
			endif
			_compNameText = _fillName
		endif
	endif

	_sSegmentLocal[1][1] = sPrefixName + _compNameText
	_sSegmentLocal[1][5] = sSuffixName

	_nRowLocal [CONTENT_ELEMENT_NAME] = 1
	for iRank = 1 to vardim1(_nRowLocal)
		_displayInOneRowLocal[iRank] = 1
	next iRank
return 

! ==============================================================================
"ContentStructName":	! content 7
! ==============================================================================

	_nRowLocal [CONTENT_STRUCT_NAME] = 0
	_iUnitType = iUnitLocal[CONTENT_STRUCT_NAME] 	! = 0 (No Unit)

	gosub "clearing_sSegmentLocal_array"

	_compNameText = ""

	if GLOB_ELEM_TYPE = ELEM_TYPE_WALL  then
		! Contents the Composite and Profile Name too
		_compNameText = WALL_COMPS_NAME
		if _compNameText = "" then
			! Contents the Building Material if its basic wall
			_compNameText = WALL_BMAT_NAME
			if WALL_CROSSSECTION_TYPE > 1 and _compNameText = "" then	! until fixed 187751
				_compNameText = `<данные недоступны для наклонных Стен>`
			endif
		endif
	endif
	if GLOB_ELEM_TYPE = ELEM_TYPE_SLAB  then
		! Contents the Composite Name
		_compNameText = SLAB_COMPS_NAME
		if _compNameText = "" then
			! Contents the Building Material if its basic
			_compNameText = SLAB_BMAT_NAME
		endif
	endif
	if GLOB_ELEM_TYPE = ELEM_TYPE_ROOF  then
		_compNameText = ROOF_COMPS_NAME
		if _compNameText = "" then
			! Contents the Building Material if its basic
			_compNameText = ROOF_BMAT_NAME
		endif
	endif
	if GLOB_ELEM_TYPE = ELEM_TYPE_SHELL then
		_compNameText = SHELLBASE_COMPS_NAME
		if _compNameText = "" then
			! Contents the Building Material if its basic
			_compNameText = SHELLBASE_BMAT_NAME
		endif
	endif
	if GLOB_ELEM_TYPE = ELEM_TYPE_MORPH then
		_compNameText = MORPH_BMAT_NAME
	endif
	if GLOB_ELEM_TYPE = ELEM_TYPE_COLUMN then
		if COLU_CROSSSECTION_TYPE = 0 then	
			! Complex
			_compNameText = COLU_PROFILE_NAME
		else
			! rectangular, Round
			_compNameText = COLU_CORE_BMAT_NAME
		endif
	endif
	if GLOB_ELEM_TYPE = ELEM_TYPE_BEAM then
		if BEAM_CROSSSECTION_TYPE = 0 then	
			! Complex
			_compNameText = BEAM_PROFILE_NAME
		else
			_compNameText = BEAM_BMAT_NAME
		endif
	endif
	if GLOB_ELEM_TYPE = ELEM_TYPE_MESH  then
		_compNameText = MESH_BMAT_NAME
	endif
	if GLOB_ELEM_TYPE = ELEM_TYPE_FILL then
		if fill_fill_category = 1 and FILL_BMAT_NAME <> "" then
			! Cut fill - Building Material
			_compNameText = FILL_BMAT_NAME
		else
			_fillName = ""
			if GLOB_SCRIPT_TYPE <> 5 then
				n = request("Name_of_fill", FILL_FILL, _fillName)
			endif
			_compNameText = _fillName
		endif
	endif
	if _compNameText <> "" then
		! exchange/replace generated name for complex wall after setting the wall type from composite
		if STRSTR(_compNameText, "CUSTOM_PROFILE_") > 0 then
			_compNameText = `Специальный Профиль`
		endif
		_sSegmentLocal[1][1] =_compNameText
	else
		_sSegmentLocal[1][1] = `<нет содержимого>`
	endif

	_sSegmentLocal[1][1] = sPrefixName + _sSegmentLocal[1][1]
	_sSegmentLocal[1][5] = sSuffixName

	_nRowLocal [CONTENT_STRUCT_NAME] = 1
	for iRank = 1 to vardim1(_nRowLocal)
		_displayInOneRowLocal[iRank] = 1
	next iRank 
return 

! ==============================================================================
"ContentCustom":	! content 8
! ==============================================================================
	_nRowLocal [CONTENT_CUSTOM] = 0
	_iUnitType = iUnitLocal[CONTENT_CUSTOM] 	! = 0 (No Unit)

	gosub "clearing_sSegmentLocal_array"

! --- Filling Up Content Array ---
! ------------------------------------------------------------------------------
	_sSegmentLocal[1][1] = sTextDataCustom			! prefix

	_nRowLocal [CONTENT_CUSTOM] = 1
	for iRank = 1 to vardim1(_nRowLocal)
		_displayInOneRowLocal[iRank] = iRank	! in Single Rank - diplays all of datas in one row
	next iRank 
return 

! ==============================================================================
"ContentElevation":	! content 9
! ==============================================================================
	_nRowLocal [CONTENT_ELEV] = 0
	_iUnitType = iUnitLocal[CONTENT_ELEV]

	gosub "clearing_sSegmentLocal_array"

! ------------------------------------------------------------------------------
!  requesting TopLevel and BottomLevel for Object and Lamp  Elem Types 
! ------------------------------------------------------------------------------

	if GLOB_ELEM_TYPE = ELEM_TYPE_OBJECT or GLOB_ELEM_TYPE = ELEM_TYPE_LAMP then
		_objectTopLevel		= 0
		_objectBottomLevel	= 0

		_dummy	= REQUEST("ASSOCLP_PARVALUE", "ac_toplevel", name_or_index, type, flags, dim1, dim2, _objectTopLevel)
		_dummy	= REQUEST("ASSOCLP_PARVALUE", "ac_bottomlevel", name_or_index, type, flags, dim1, dim2, _objectBottomLevel)

		if ABS(_objectTopLevel) < EPS and (ABS(_objectBottomLevel - 1) < EPS or ABS(_objectBottomLevel) < EPS) then
			_objectBottomLevel	= 0
			_objectTopLevel		= SYMB_Z_SIZE
		endif
	endif

	! ------------------------------------------------------------------------------
	! requesting UnitHeights, SillHeight and Tolerance values for Doors/Windows 
	! ------------------------------------------------------------------------------
	detaliedDwUnitHeight=0
	simpleDwUnitHeight=0
	dwSillHeight=0
	dwToleranceLower=0

	if GLOB_ELEM_TYPE = ELEM_TYPE_WINDOW or GLOB_ELEM_TYPE = ELEM_TYPE_DOOR then
		_detaliedDwUnitHeightRequest	= REQUEST("ASSOCLP_PARVALUE", "ac_unit_height", name_or_index, type, flags, dim1, dim2, detaliedDwUnitHeight)
		_simpleDwUnitHeightRequest		= REQUEST("ASSOCLP_PARVALUE", "B", name_or_index, type, flags, dim1, dim2, simpleDwUnitHeight)
		_sillDwHeightRequest			= REQUEST("ASSOCLP_PARVALUE", "AC_Sill_To_Curr_Story", name_or_index, type, flags, dim1, dim2, dwSillHeight)
		if _detaliedDwUnitHeightRequest then
			_dwUnitHeight	= detaliedDwUnitHeight
		else
			_dwUnitHeight	= simpleDwUnitHeight
		endif
		_dummy	= REQUEST("ASSOCLP_PARVALUE", "gs_tolerance_lower", name_or_index, type, flags, dim1, dim2, dwToleranceLower)
	endif

	! ------------------------------------------------------------------------------
	!  defining _referenceHeightMod 
	! ------------------------------------------------------------------------------

	_referenceHeightMod	= 0
	if iRefStory = REF_STORY_PROJECT	then 	_referenceHeightMod	= GLOB_HSTORY_ELEV
	if iRefStory = REF_STORY_WALLBASE	then	_referenceHeightMod	= GLOB_ELEVATION - dwSillHeight

	if iRefStory = REF_STORY_NAME1	then 	_referenceHeightMod	= GLOB_HSTORY_ELEV
	if iRefStory = REF_STORY_NAME2	then 	_referenceHeightMod	= elev2
	if iRefStory = REF_STORY_NAME3	then 	_referenceHeightMod	= elev3
	if iRefStory = REF_STORY_NAME4	then 	_referenceHeightMod	= elev4

	! ------------------------------------------------------------------------------
	!  generating numerical content by Elem Types 
	! ------------------------------------------------------------------------------
	_numValueTop = 0
	_numValueBot = 0

	if GLOB_ELEM_TYPE	= ELEM_TYPE_OBJECT then
		_numValueTop	= GLOB_ELEVATION + _referenceHeightMod + _objectTopLevel
		_numValueBot	= GLOB_ELEVATION + _referenceHeightMod + _objectBottomLevel
	endif

	if GLOB_ELEM_TYPE	= ELEM_TYPE_SLAB then
		_numValueTop	= SLAB_ELEVATION_TOP + _referenceHeightMod
		if iElevationTopMeasuredTo = ELEV_MESURED_CORE and SLAB_SKINS_NUMBER <> 0 then ! Core
			for iSkinSlab = 1 to SLAB_SKINS_NUMBER
				if SLAB_SKINS_PARAMS[iSkinSlab][6] < EPS then ! not part of core 0 - core status
					_numValueTop = _numValueTop - SLAB_SKINS_PARAMS[iSkinSlab][2]
				else
					iSkinSlab = SLAB_SKINS_NUMBER ! force loop end
				endif
			next iSkinSlab 
		endif
		_numValueBot	= SLAB_ELEVATION_BOTTOM + _referenceHeightMod
		if iElevationBottomMeasuredTo = ELEV_MESURED_CORE and SLAB_SKINS_NUMBER <> 0 then ! Core
			for iSkinSlab = SLAB_SKINS_NUMBER to 1 step -1
				if SLAB_SKINS_PARAMS[iSkinSlab][6] < EPS then ! not part of core - core status
					_numValueBot = _numValueBot + SLAB_SKINS_PARAMS[iSkinSlab][2]
				else
					iSkinSlab = 1 ! force loop end
				endif
			next iSkinSlab 
		endif
	endif

	if GLOB_ELEM_TYPE	= ELEM_TYPE_WALL then
		_numValueTop	= GLOB_ELEVATION + _referenceHeightMod + WALL_HEIGHT
		_numValueBot	= GLOB_ELEVATION + _referenceHeightMod
	endif

	if GLOB_ELEM_TYPE	= ELEM_TYPE_COLUMN then
		_numValueTop	= GLOB_ELEVATION + _referenceHeightMod + COLU_HEIGHT
		_numValueBot	= GLOB_ELEVATION + _referenceHeightMod
	endif

	if GLOB_ELEM_TYPE	= ELEM_TYPE_BEAM then
		beamEdgeHeight	= BEAM_HEIGHT / COS(ac_beam_inclination)

		_numValueTop =  GLOB_ELEVATION + _referenceHeightMod + SIN(ac_beam_inclination) * BEAM_LENGTH_RIGHT
		_numValueBot =  GLOB_ELEVATION + _referenceHeightMod - beamEdgeHeight
	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_DOOR then
		_numValueTop	= dwSillHeight + dwToleranceLower + _dwUnitHeight + _referenceHeightMod
		_numValueBot	= dwSillHeight + dwToleranceLower + _referenceHeightMod
	endif		

	if	GLOB_ELEM_TYPE	= ELEM_TYPE_WINDOW then
		_numValueTop	= dwSillHeight + dwToleranceLower + _dwUnitHeight + _referenceHeightMod
		_numValueBot	= dwSillHeight + dwToleranceLower + _referenceHeightMod

		n = REQUEST ("ASSOCLP_PARVALUE", "AC_fit_to_wall_height", index, type, flags, dim1, dim2, fit_to)
		if n > 0 then		! parent tool is wall end
			_numValueBot	= GLOB_ELEVATION + _referenceHeightMod
			if fit_to = 1 then
				_numValueTop = GLOB_ELEVATION + _referenceHeightMod + WALL_HEIGHT
			else
				_numValueTop = GLOB_ELEVATION + SYMB_Z_SIZE		! need ZZYZX in label
			endif
		endif
	endif

	if	GLOB_ELEM_TYPE	= ELEM_TYPE_LAMP then
		_numValueTop	= GLOB_ELEVATION + _referenceHeightMod + _objectTopLevel
		_numValueBot	= GLOB_ELEVATION + _referenceHeightMod + _objectBottomLevel
	endif

	if	GLOB_ELEM_TYPE	= ELEM_TYPE_CW then
		_numValueTop	= GLOB_ELEVATION + _referenceHeightMod + CWALL_HEIGHT
		_numValueBot	= GLOB_ELEVATION + _referenceHeightMod
	endif

	! the designer is not sure what need to elevate or missing globals (top)
!	if	GLOB_ELEM_TYPE	= ELEM_TYPE_SKYLIGHT then
!		_numValueTop	= _referenceHeightMod + SKYL_HEADER_HEIGHT
!		_numValueBot	= _referenceHeightMod + SKYL_SILL_HEIGHT
!	endif

	! the designer is not sure what need to elevate or missing globals (top)
!	if	GLOB_ELEM_TYPE	= ELEM_TYPE_CWPANEL then
!		_numValueTop	= GLOB_ELEVATION + _referenceHeightMod + CWPANEL_HEIGHT
!		_numValueBot	= GLOB_ELEVATION + _referenceHeightMod
!	endif

	! the designer is not sure what need to elevate	or missing globals
!	if GLOB_ELEM_TYPE	= ELEM_TYPE_ROOF then
!		_numValueBot	= GLOB_ELEVATION + _referenceHeightMod
!	endif

	! the designer is not sure what need to elevate	or missing globals (top)
!	if GLOB_ELEM_TYPE	= ELEM_TYPE_MORPH | GLOB_ELEM_TYPE = ELEM_TYPE_SHELL | GLOB_ELEM_TYPE = ELEM_TYPE_MESH then
!		_numValueBot	= GLOB_ELEVATION + _referenceHeightMod
!	endif

	prefix = strPrefixElevTop
	_calledValue =  _numValueTop
	gosub "ConvertNumericalValueToString"
	_nElevRow = 0
	if bShowElevTop then 

		if STRSTR(strPrefixElevTop,"%")>0 or STRSTR(strSuffixElevTop,"%")>0 then 

			par_fist_str = strPrefixElevTop
			if STRSTR(strSuffixElevTop,"%")>0 then par_fist_str = strSuffixElevTop

			call "macro_get_param" parameters mgp_in_str=par_fist_str RETURNED_PARAMETERS mgp_out_str
			strPrefixElevTop = ""
			strSuffixElevTop = ""
			note1 = mgp_out_str
			note2 = ""
			note3 = ""
			note4 = ""
		endif
		_sSegmentLocal[1][1] = note1		! prefix
		_sSegmentLocal[1][2] = note2		! note 2 (frac)
		_sSegmentLocal[1][3] = note3		! note 3 (unit)
		_sSegmentLocal[1][4] = note4		! note 4 (unit index)
		_sSegmentLocal[1][5] = strSuffixElevTop ! suffix
		if _calledValue>EPS and note1<>GLOB_ID then _sSegmentLocal[1][1] =  "+" + _sSegmentLocal[1][1]
		_nElevRow = _nElevRow + 1
	endif

	prefix = strPrefixElevBottom 
	_calledValue = _numValueBot
	gosub "ConvertNumericalValueToString"
	if bShowElevBottom then 
		if STRSTR(strPrefixElevBottom,"%")>0 or STRSTR(strSuffixElevBottom,"%")>0 then 
			par_fist_str = strPrefixElevBottom
			if STRSTR(strSuffixElevBottom,"%")>0 then par_fist_str = strSuffixElevBottom
			call "macro_get_param" parameters mgp_in_str=par_fist_str RETURNED_PARAMETERS mgp_out_str
			strPrefixElevBottom = ""
			strSuffixElevBottom = ""
			note1 = mgp_out_str
			note2 = ""
			note3 = ""
			note4 = ""
		endif
		_sSegmentLocal[_nElevRow + 1][1] = note1	! note 1 (prefix + number)
		_sSegmentLocal[_nElevRow + 1][2] = note2		! note 2 (frac)
		_sSegmentLocal[_nElevRow + 1][3] = note3		! note 3 (unit)
		_sSegmentLocal[_nElevRow + 1][4] = note4		! note 4 (unit index)
		_sSegmentLocal[_nElevRow + 1][5] = strSuffixElevBottom			! suffix
		if _calledValue>EPS and note1<>GLOB_ID then _sSegmentLocal[_nElevRow + 1][1] = "+" + _sSegmentLocal[_nElevRow + 1][1]
		_nElevRow = _nElevRow + 1
	endif

	_nRowLocal [CONTENT_ELEV] = _nElevRow
	for iRank = 1 to vardim1(_nRowLocal)
		_displayInOneRowLocal[iRank] = 1
	next iRank 

return 

! ==============================================================================
"ContentSkindata":	! content 10
! ==============================================================================
	_nRowLocal [CONTENT_SKIN] = 0
	_iUnitType = iUnitLocal[CONTENT_SKIN]

	gosub "clearing_sSegmentLocal_array"

	! ------------------------------------------------------------------------------
	! assigning listTypes to GLOB_ELEM_TYPEs
	! filling up data array with AUTOMATIC content depending on GLOB_ELEM_TYPE
	! calculating number of rows for AUTOMATIC content
	! ------------------------------------------------------------------------------

	! parameters of skins: 
	_nSkins = 1				! number of structural skins (layers)
	__SkinVar = 1
	dim _SkinPar1FillId[]	! index of fill 
		_SkinPar1FillId[1] = ""
	dim _SkinPar2Thick[]	! thickness
		_SkinPar2Thick[1] = 0
	dim _SkinPar3MatName[]	! material name
		_SkinPar3MatName[1] = ""
	dim _SkinPar4IDName[]	! material ID
		_SkinPar4IDName[1] = ""
	dim _SkinPar5Manuf[]	! material manufacturer
		_SkinPar5Manuf[1] = ""
	dim _SkinPar6Desc[]		! material description
		_SkinPar6Desc[1] = ""

	if _iSkinListClass = LIST_NAME_COMPLEX then

		_skinProfileName = ""
		_nSkins = 1
		if GLOB_ELEM_TYPE = ELEM_TYPE_WALL then
			_nSkins = 1
			n = strstr(ac_wall_profile_name, "CUSTOM_PROFILE")
			if n then
				_skinProfileName = `Специальный Профиль`
			else
				_skinProfileName = ac_wall_profile_name
			endif
		endif
		if GLOB_ELEM_TYPE = ELEM_TYPE_COLUMN then
			m = strstr(ac_colu_profile_name, "CUSTOM_PROFILE")
			if m then
				_skinProfileName = `Специальный Профиль`
			else
				_skinProfileName = ac_colu_profile_name
			endif
		endif
		if GLOB_ELEM_TYPE = ELEM_TYPE_BEAM then
			k = strstr(ac_beam_profile_name, "CUSTOM_PROFILE")
			if k then
				_skinProfileName = `Специальный Профиль`
			else
				_skinProfileName = ac_beam_profile_name
			endif
		endif

		gosub "autoListFillUp"

	else

		if _iSkinListClass = LIST_THK_FILL |\
			_iSkinListClass = LIST_FILL_ONLY |\
			_iSkinListClass = LIST_DIM_FILL then

			if GLOB_ELEM_TYPE = ELEM_TYPE_ROOF then
				if ROOF_SKINS_NUMBER	= 0 then
					_nSkins = 1
					_SkinPar1FillId[1]	= ROOF_FILL
					_SkinPar2Thick[1] = ROOF_THICKNESS 
					_SkinPar3MatName[1]	= ROOF_BMAT_NAME

					__SkinVar = 1
					gosub "ReqBuildMatInfo" ! input __SkinVar, returned _SkinPar4IDName[__SkinVar], _SkinPar5Manuf[__SkinVar], _SkinPar6Desc[__SkinVar] 
				else
					_nSkins = ROOF_SKINS_NUMBER
					for __iSkin = 1 to _nSkins
						_SkinPar1FillId	[__iSkin]	= ROOF_SKINS_PARAMS		[__iSkin][1]	! fill
						_SkinPar2Thick	[__iSkin] 	= ROOF_SKINS_PARAMS		[__iSkin][2]	! thickness
						_SkinPar3MatName[__iSkin]	= ROOF_SKINS_BMAT_NAMES	[__iSkin][1]

						__SkinVar = __iSkin
						gosub "ReqBuildMatInfo" ! input __SkinVar, returned _SkinPar4IDName[__SkinVar], _SkinPar5Manuf[__SkinVar], _SkinPar6Desc[__SkinVar] 
					next __iSkin
				endif
			endif

			if GLOB_ELEM_TYPE = ELEM_TYPE_SLAB then
				if SLAB_SKINS_NUMBER	= 0 then
					_nSkins = 1
					_SkinPar1FillId	[1]	= SLAB_FILL
					_SkinPar2Thick	[1] = SLAB_THICKNESS
					_SkinPar3MatName[1]	= SLAB_BMAT_NAME

					__SkinVar = 1
					gosub "ReqBuildMatInfo" ! input __SkinVar, returned _SkinPar4IDName[__SkinVar], _SkinPar5Manuf[__SkinVar], _SkinPar6Desc[__SkinVar] 
				else
					_nSkins = SLAB_SKINS_NUMBER
					for __iSkin = 1 to _nSkins
						_SkinPar1FillId	[__iSkin] 	= SLAB_SKINS_PARAMS		[__iSkin][1]	!fill
						_SkinPar2Thick	[__iSkin] 	= SLAB_SKINS_PARAMS		[__iSkin][2]	!thickness
						_SkinPar3MatName[__iSkin]	= SLAB_SKINS_BMAT_NAMES	[__iSkin][1]

						__SkinVar = __iSkin
						gosub "ReqBuildMatInfo" ! input __SkinVar, returned _SkinPar4IDName[__SkinVar], _SkinPar5Manuf[__SkinVar], _SkinPar6Desc[__SkinVar] 
					next __iSkin
				endif
			endif

			if GLOB_ELEM_TYPE = ELEM_TYPE_WALL then
				if WALL_SKINS_NUMBER	= 0 then
					_nSkins = 1
					_SkinPar1FillId	[1]	= WALL_FILL
					_SkinPar2Thick	[1] = WALL_THICKNESS
					_SkinPar3MatName[1]	= WALL_BMAT_NAME

					__SkinVar = 1
					gosub "ReqBuildMatInfo" ! input __SkinVar, returned _SkinPar4IDName[__SkinVar], _SkinPar5Manuf[__SkinVar], _SkinPar6Desc[__SkinVar] 
				else
					_nSkins = WALL_SKINS_NUMBER
					for __iSkin = 1 to _nSkins
						_SkinPar1FillId	[__iSkin]	= WALL_SKINS_PARAMS	[__iSkin][1]
						_SkinPar2Thick	[__iSkin]	= WALL_SKINS_PARAMS	[__iSkin][2]
						_SkinPar3MatName[__iSkin]	= WALL_SKINS_BMAT_NAMES[__iSkin][1]

						__SkinVar = __iSkin
						gosub "ReqBuildMatInfo" ! input __SkinVar, returned _SkinPar4IDName[__SkinVar], _SkinPar5Manuf[__SkinVar], _SkinPar6Desc[__SkinVar] 
					next __iSkin
				endif
			endif

			if GLOB_ELEM_TYPE = ELEM_TYPE_SHELL then
				if SHELLBASE_SKINS_NUMBER	= 0 then
					_nSkins = 1
					_SkinPar1FillId	[1]		= SHELLBASE_FILL
					_SkinPar2Thick	[1] 	= SHELLBASE_THICKNESS
					_SkinPar3MatName[1]		= SHELLBASE_BMAT_NAME

					__SkinVar = 1
					gosub "ReqBuildMatInfo" ! input __SkinVar, returned _SkinPar4IDName[__SkinVar], _SkinPar5Manuf[__SkinVar], _SkinPar6Desc[__SkinVar] 

				else
					_nSkins = SHELLBASE_SKINS_NUMBER
					for __iSkin = 1 to _nSkins
						_SkinPar1FillId	[__iSkin]	= SHELLBASE_SKINS_PARAMS[__iSkin][1]
						_SkinPar2Thick	[__iSkin]	= SHELLBASE_SKINS_PARAMS[__iSkin][2]
						_SkinPar3MatName[__iSkin]	= SHELLBASE_SKINS_BMAT_NAMES[__iSkin][1]

						__SkinVar = __iSkin
						gosub "ReqBuildMatInfo" ! input __SkinVar, returned _SkinPar4IDName[__SkinVar], _SkinPar5Manuf[__SkinVar], _SkinPar6Desc[__SkinVar] 

					next __iSkin
				endif
			endif

			if GLOB_ELEM_TYPE = ELEM_TYPE_COLUMN then
				_nSkins = 2

				_begin = 1
				_end = _nSkins
				_step = 1
				if bChangeSkinDirection then
					_begin = _nSkins
					_end = 1
					_step = -1
				endif

				for iColuSkins = _begin to _end step _step
					_SkinPar1FillId	[iColuSkins ] = COLU_CORE_FILL		!idx
					if iColuSkins = _begin then
						_SkinPar2Thick	[iColuSkins ] = COLU_CORE_Y
					else
						_SkinPar2Thick	[iColuSkins ] = COLU_CORE_X
					endif

					_SkinPar3MatName[iColuSkins ]	= COLU_CORE_BMAT_NAME
					_displayInOneRowLocal[iColuSkins] = iColuSkins
					__SkinVar = iColuSkins
					gosub "ReqBuildMatInfo" ! input __SkinVar, returned _SkinPar4IDName[__SkinVar], _SkinPar5Manuf[__SkinVar], _SkinPar6Desc[__SkinVar] 

				next iColuSkins

				if COLU_VENEER_WIDTH > 0 then
					_nSkins = _nSkins+1
					_SkinPar1FillId	[3]	= COLU_VENEER_FILL		! the index will be increased from 2 to 3 if _skinThk2 > 0
					_SkinPar2Thick	[3]	= COLU_VENEER_WIDTH
					_SkinPar3MatName[3]	= COLU_VENEER_BMAT_NAME
					_displayInOneRowLocal[3] =1
					__SkinVar = 3
					gosub "ReqBuildMatInfo" ! input __SkinVar, returned _SkinPar4IDName[__SkinVar], _SkinPar5Manuf[__SkinVar], _SkinPar6Desc[__SkinVar] 

				endif
			endif

			if GLOB_ELEM_TYPE = ELEM_TYPE_BEAM then
				_nSkins = 2

				if bChangeSkinDirection then
					_SkinPar1FillId	[1]	= BEAM_FILL		!idx
					_SkinPar2Thick	[1] = BEAM_THICKNESS
					_SkinPar3MatName[1]	= BEAM_BMAT_NAME
					_displayInOneRowLocal[1] = 1
					__SkinVar = 1
					gosub "ReqBuildMatInfo" ! input __SkinVar, returned _SkinPar4IDName[__SkinVar], _SkinPar5Manuf[__SkinVar], _SkinPar6Desc[__SkinVar] 


					_SkinPar1FillId	[2]	= BEAM_FILL		!idx
					_SkinPar2Thick	[2] = BEAM_HEIGHT
					_SkinPar3MatName[2]	= BEAM_BMAT_NAME
					_displayInOneRowLocal[2] = 2
					__SkinVar = 2
					gosub "ReqBuildMatInfo" ! input __SkinVar, returned _SkinPar4IDName[__SkinVar], _SkinPar5Manuf[__SkinVar], _SkinPar6Desc[__SkinVar] 

				else
					_SkinPar1FillId	[1]	= BEAM_FILL		!idx
					_SkinPar2Thick	[1] = BEAM_HEIGHT
					_SkinPar3MatName[1]	= BEAM_BMAT_NAME
					_displayInOneRowLocal[1] = 1

					__SkinVar = 1
					gosub "ReqBuildMatInfo" ! input __SkinVar, returned _SkinPar4IDName[__SkinVar], _SkinPar5Manuf[__SkinVar], _SkinPar6Desc[__SkinVar] 

					_SkinPar1FillId	[2]	= BEAM_FILL		!idx
					_SkinPar2Thick	[2] = BEAM_THICKNESS
					_SkinPar3MatName[2]	= BEAM_BMAT_NAME
					_displayInOneRowLocal[2] = 2
					__SkinVar = 2
					gosub "ReqBuildMatInfo" ! input __SkinVar, returned _SkinPar4IDName[__SkinVar], _SkinPar5Manuf[__SkinVar], _SkinPar6Desc[__SkinVar] 
				endif
			endif

			if GLOB_ELEM_TYPE = ELEM_TYPE_MORPH then
				_nSkins = 1
				_SkinPar1FillId	[1] = MORPH_FILL
				_SkinPar2Thick	[1] = 0
				_SkinPar3MatName[1]	= MORPH_BMAT_NAME

				__SkinVar = 1
				gosub "ReqBuildMatInfo" ! input __SkinVar, returned _SkinPar4IDName[__SkinVar], _SkinPar5Manuf[__SkinVar], _SkinPar6Desc[__SkinVar] 
			endif

			if GLOB_ELEM_TYPE = ELEM_TYPE_MESH then
				_nSkins = 1
				_SkinPar1FillId	[1] = MESH_FILL
				_SkinPar2Thick	[1] = 0
				_SkinPar3MatName[1]	= MESH_BMAT_NAME

				__SkinVar = 1
				gosub "ReqBuildMatInfo" ! input __SkinVar, returned _SkinPar4IDName[__SkinVar], _SkinPar5Manuf[__SkinVar], _SkinPar6Desc[__SkinVar] 
			endif

			if GLOB_ELEM_TYPE = ELEM_TYPE_FILL then
				_nSkins = 1
				_SkinPar1FillId	[1] = FILL_FILL
				_SkinPar2Thick	[1] = 0
				_SkinPar3MatName[1]	= FILL_BMAT_NAME

				__SkinVar = 1
				gosub "ReqBuildMatInfo" ! input __SkinVar, returned _SkinPar4IDName[__SkinVar], _SkinPar5Manuf[__SkinVar], _SkinPar6Desc[__SkinVar] 
			endif


			if _nSkins > 0 then gosub "autoListFillUp"

		else
			if _iSkinListClass = LIST_NAME_FILL then

				_fillName = ""
				if GLOB_SCRIPT_TYPE <> 5 & GLOB_ELEM_TYPE = ELEM_TYPE_OBJECT then
					n = request("Name_of_fill", SYMB_FILL, _fillName)
				endif

				if GLOB_SCRIPT_TYPE <> 5 & GLOB_ELEM_TYPE = ELEM_TYPE_FILL then
					n = request("Name_of_fill", FILL_FILL, _fillName)
				endif

				gosub "autoListFillUp"
			else

				! LIST_CUSTOM_ONLY 

				gosub "autoListFillUp"
			endif
		endif
	endif


	if bCustomListContent then
		_nRowLocal [CONTENT_SKIN] = _nCustomSkinRow
	else
		_nRowLocal [CONTENT_SKIN] = _nSkins
	endif

	if _displayInOneRowLocal[1] < EPS then
		for iRank = 1 to vardim1(_nRowLocal)
			_displayInOneRowLocal[iRank] = 1
		next iRank 
	endif

return 


! ==========================================================================
"autoListFillUp" :
! ==========================================================================


if not(bCustomListContent) then

! ---------------------------------------------------------------------------
! filling up output arrays with AUTOMATIC content 
! ---------------------------------------------------------------------------

	if 	_iSkinListClass = LIST_THK_FILL then
		for iSkins = 1 to _nSkins
			_skinName = ""
			_skinThk 	= ""

			if GLOB_SCRIPT_TYPE <> 5 & iTypeSkinContent = CONTENT_CUT_FILL then
				_skinFillIdx = _SkinPar1FillId[iSkins]
				n = request("Name_of_fill", _skinFillIdx, _skinName)
			endif
			if iTypeSkinContent = CONTENT_BUILDING_MATERIAL then
				_skinName = _SkinPar3MatName[iSkins]
			endif
			if iTypeSkinContent = CONTENT_BUILDING_ID then
				_skinName = _SkinPar4IDName[iSkins]
			endif
			if iTypeSkinContent = CONTENT_BUILDING_MANUFACTURER then
				_skinName = _SkinPar5Manuf[iSkins]
			endif
			if iTypeSkinContent = CONTENT_BUILDING_DESCRIPTION then
				_skinName = _SkinPar6Desc[iSkins]
			endif

			_skinThk	= _SkinPar2Thick[iSkins]

			_calledValue = _skinThk : prefix 	= _stSpace
			if bShowSkinThickness then
				gosub "ConvertNumericalValueToString"

				_sSegmentLocal[iSkins][1] = note1	! (prefix + number)
				_sSegmentLocal[iSkins][2] = note2	! (frac)
				_sSegmentLocal[iSkins][3] = note3	! (unit)
				_sSegmentLocal[iSkins][4] = note4	! (unit index)
				_sSegmentLocal[iSkins][5] = "  " + _skinName + " "		! suffix
			else
				_sSegmentLocal[iSkins][1] = ""
				_sSegmentLocal[iSkins][2] = ""
				_sSegmentLocal[iSkins][3] = ""
				_sSegmentLocal[iSkins][4] = ""
				_sSegmentLocal[iSkins][5] = " " + _skinName + " "		! suffix
			endif


		next iSkins
	else
		if _iSkinListClass = LIST_FILL_ONLY then
			_skinName = ""
			if GLOB_SCRIPT_TYPE <> 5 & (iTypeSkinContent = CONTENT_CUT_FILL | _SkinPar3MatName[1] = "") then
				_skinFillIdx = _SkinPar1FillId[1]
				n = request("Name_of_fill", _skinFillIdx, _skinName)
			else
				_skinName = _SkinPar3MatName[1]
			endif
			if iTypeSkinContent = CONTENT_BUILDING_MATERIAL then
				_skinName = _SkinPar3MatName[1]
			endif
			if iTypeSkinContent = CONTENT_BUILDING_ID then
				_skinName = _SkinPar4IDName[1]
			endif
			if iTypeSkinContent = CONTENT_BUILDING_MANUFACTURER then
				_skinName = _SkinPar5Manuf[1]
			endif
			if iTypeSkinContent = CONTENT_BUILDING_DESCRIPTION then
				_skinName = _SkinPar6Desc[1]
			endif

			_sSegmentLocal[1][1] = ""		! note 1 (prefix + number)
			_sSegmentLocal[1][2] = ""		! note 2 (frac)
			_sSegmentLocal[1][3] = ""		! note 3 (unit)
			_sSegmentLocal[1][4] = ""		! note 4 (unit index)
			_sSegmentLocal[1][5] = _stSpace + _skinName		! suffix

		else
			if _iSkinListClass = LIST_DIM_FILL then
				for iSkins = 1 to _nSkins
					_skinName = ""
					if GLOB_SCRIPT_TYPE <> 5 & iTypeSkinContent = CONTENT_CUT_FILL then
						_skinFillIdx = _SkinPar1FillId[iSkins]
						n = request("Name_of_fill", _skinFillIdx, _skinName)
					else
						_skinName = _SkinPar3MatName[iSkins]
					endif
					if iTypeSkinContent = CONTENT_BUILDING_MATERIAL then
						_skinName = _SkinPar3MatName[iSkins]
					endif
					if iTypeSkinContent = CONTENT_BUILDING_ID then
						_skinName = _SkinPar4IDName[iSkins]
					endif
					if iTypeSkinContent = CONTENT_BUILDING_MANUFACTURER then
						_skinName = _SkinPar5Manuf[iSkins]
					endif
					if iTypeSkinContent = CONTENT_BUILDING_DESCRIPTION then
						_skinName = _SkinPar6Desc[iSkins]
					endif

					_skinThk1 = _SkinPar2Thick[iSkins]

					_calledValue = _skinThk1 : prefix = _stSpace
					gosub "ConvertNumericalValueToString" ! returned note1 - note4

					_sSegmentLocal[iSkins][1] = note1		! note 1 (prefix + number)
					_sSegmentLocal[iSkins][2] = note2		! note 2 (frac)
					_sSegmentLocal[iSkins][3] = note3		! note 3 (unit)
					_sSegmentLocal[iSkins][4] = note4		! note 4 (unit index)
					_sSegmentLocal[iSkins][5] = " " + _skinName	! suffix

				next iSkins

				_separator = " x "
				if bChangeSkinDirection then 
					_sSegmentLocal[1][5] = _separator
				else
					_sSegmentLocal[2][5] = _separator
				endif
			else
				if _iSkinListClass = LIST_NAME_COMPLEX then
					_sSegmentLocal[1][1] = ""		! note 1 (prefix + number)
					_sSegmentLocal[1][2] = ""		! note 2 (frac)
					_sSegmentLocal[1][3] = ""		! note 3 (unit)
					_sSegmentLocal[1][4] = ""		! note 4 (unit index)
					_sSegmentLocal[1][5] = _stSpace + _skinProfileName
				else
					if _iSkinListClass = LIST_NAME_FILL then
						_sSegmentLocal[1][1] = ""		! note 1 (prefix + number)
						_sSegmentLocal[1][2] = ""		! note 2 (frac)
						_sSegmentLocal[1][3] = ""		! note 3 (unit)
						_sSegmentLocal[1][4] = ""		! note 4 (unit index)
						_sSegmentLocal[1][5] = _stSpace + _fillName
					else	!  LIST_CUSTOM_ONLY	
						_sSegmentLocal[1][1] = ""		! note 1 (prefix + number)
						_sSegmentLocal[1][2] = ""		! note 2 (frac)
						_sSegmentLocal[1][3] = ""		! note 3 (unit)
						_sSegmentLocal[1][4] = ""		! note 4 (unit index)
						_sSegmentLocal[1][5] = `<нет содержимого>`
					endif
				endif
			endif
		endif
	endif

	! Fill a variable with the skins data to set the empty dataCustomSkinRow for default in PM
	dim _actualSkins[]
	for iCustomSkins = 1 to vardim1(_sSegmentLocal)
		_actualSkins[iCustomSkins] = _sSegmentLocal[iCustomSkins][1] +\
									_sSegmentLocal[iCustomSkins][2] +\
									_sSegmentLocal[iCustomSkins][3] +\
									_sSegmentLocal[iCustomSkins][4] +\
									_sSegmentLocal[iCustomSkins][5]

	next iCustomSkins




else
! ---------------------------------------------------------------------------
! filling up output arrays with CUSTOM content
! ---------------------------------------------------------------------------
	_nCustomSkinRow = 0
	for _iAvailableRow = vardim1(dataCustomSkinRow) to 1 step -1		! dataCustomSkinRow is an array with 32 items
		if dataCustomSkinRow[_iAvailableRow] <> "" then
			_nCustomSkinRow = _iAvailableRow
			_iAvailableRow = 1
		endif
	next _iAvailableRow

	for iiSkins = 1 to _nCustomSkinRow

		_sSegmentLocal[iiSkins][1] = ""		! note 1 (prefix + number)
		_sSegmentLocal[iiSkins][2] = ""		! note 2 (frac)
		_sSegmentLocal[iiSkins][3] = ""		! note 3 (unit)
		_sSegmentLocal[iiSkins][4] = ""		! note 4 (unit index)
		_sSegmentLocal[iiSkins][5] = dataCustomSkinRow[iiSkins]	! suffix

	next iiSkins

endif

! ---------------------------------------------------------------------------
! revers order of data
! ---------------------------------------------------------------------------
if not(bChangeSkinDirection) then 
	if bCustomListContent then
		_numberOfDataRows =  _nCustomSkinRow 
	else
		_numberOfDataRows = _nSkins
	endif
! defining temporary array 
	dim	_sSegmentTemp[][5] 				
	for k = 1 to vardim1(_sSegmentTemp)
		for l = 1 to vardim2(_sSegmentLocal) ! 1- 5
			_sSegmentTemp[k][l] = ""
		next l
	next k
! loading data to the temporary array in reversed order
	for iRow = 1 to _numberOfDataRows
		for iSegment = 1 to vardim2(_sSegmentLocal) ! 1- 5
			_sSegmentTemp[iRow][iSegment] = _sSegmentLocal[_numberOfDataRows+1-iRow][iSegment]
		next iSegment
	next iRow
! clearing _sSegmentLocal array
	for k = 1 to vardim1(_sSegmentLocal)
		for l = 1 to vardim2(_sSegmentLocal) ! 1- 5
			_sSegmentLocal[k][l] = ""
		next l
	next k
! re-loading _sSegmentLocal array in reversed order
	for iRow = 1 to _numberOfDataRows
		for iSegment = 1 to vardim2(_sSegmentLocal) ! 1- 5
			_sSegmentLocal[iRow][iSegment] = _sSegmentTemp[iRow][iSegment]
		next iSegment
	next iRow

endif



return

! ==========================================================================
"ContentMaterial":	! content 12
! ==========================================================================
	_nRowLocal [CONTENT_MATERIAL] = 0
	_iUnitType = iUnitLocal[CONTENT_MATERIAL]

	! _iAvailableMaterial is need to be constans and serially
	_iMaterial = 1

	if (GLOB_ELEM_TYPE = ELEM_TYPE_WALL and WALL_CROSSSECTION_TYPE <> 0) | bDefaultElem then
!		WALL_MAT_A material of the wall on the side opposite to the opening side 
!		WALL_MAT_B material of the wall on the opening side this can vary from opening to opening placed in the same wall
!		WALL_MAT_EDGE material of the edges of the wall

		_sAvailableMaterial[_iMaterial] = `Наружная Поверхность Стены`
		_iAvailableMaterial[_iMaterial] = 1
		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = WALL_MAT_A
		_sAvailableMaterialPict[_iMaterial] = "ui_wall_outside_flat(1)"
		_iMaterial  = _iMaterial  + 1

		_sAvailableMaterial[_iMaterial] = `Внутренняя Поверхность Стены`
		_iAvailableMaterial[_iMaterial] = 2
		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = WALL_MAT_B
		_sAvailableMaterialPict[_iMaterial] = "ui_wall_inside_flat(1)"
		_iMaterial  = _iMaterial  + 1

		_sAvailableMaterial[_iMaterial] = `Поверхности Торцов Стены`
		_iAvailableMaterial[_iMaterial] = 3
		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = WALL_MAT_EDGE
		_sAvailableMaterialPict[_iMaterial] = "ui_wall_edge_flat(1)"
		_iMaterial  = _iMaterial  + 1

	endif


	if (GLOB_ELEM_TYPE = ELEM_TYPE_COLUMN and COLU_CROSSSECTION_TYPE <> 0) | bDefaultElem then
!		COLU_MAT material of the column

		_sAvailableMaterial[_iMaterial] = `Покрытие Колонны`
		_iAvailableMaterial[_iMaterial] = 4
		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = COLU_MAT
		_sAvailableMaterialPict[_iMaterial] = "ui_general_surface_flat(1)"
		_iMaterial  = _iMaterial  + 1


	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_SLAB | bDefaultElem then
!		SLAB_MAT_TOP material of the top surface of the slab
!		SLAB_MAT_EDGE material of the edges of the slab
!		SLAB_MAT_BOTT material of the bottom surface of the slab 

		_sAvailableMaterial[_iMaterial] = `Верхняя Поверхность Перекрытия`
		_iAvailableMaterial[_iMaterial] = 5
		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = SLAB_MAT_TOP
		_sAvailableMaterialPict[_iMaterial] = "ui_slab_top_flat(1)"

		_iMaterial  = _iMaterial  + 1

		_sAvailableMaterial[_iMaterial] = `Поверхности Торцов Перекрытия`
		_iAvailableMaterial[_iMaterial] = 6
		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = SLAB_MAT_EDGE
		_sAvailableMaterialPict[_iMaterial] = "ui_slab_edge_flat(1)"
		_iMaterial  = _iMaterial  + 1

		_sAvailableMaterial[_iMaterial] = `Нижняя Поверхность Перекрытия`
		_iAvailableMaterial[_iMaterial] = 7
		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = SLAB_MAT_BOTT
		_sAvailableMaterialPict[_iMaterial] = "ui_slab_bottom_flat(1)"
		_iMaterial  = _iMaterial  + 1
	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_ROOF | bDefaultElem then
!		ROOF_MAT_TOP material of the top surface of the roof
!		ROOF_MAT_EDGE material of the edges of the roof
!		ROOF_MAT_BOTT material of the bottom surface of the roof 

		_sAvailableMaterial[_iMaterial] = `Верхняя Поверхность Крыши`
		_iAvailableMaterial[_iMaterial] = 8
		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = ROOF_MAT_TOP
		_sAvailableMaterialPict[_iMaterial] = "ui_slab_top_flat(1)"
		_iMaterial  = _iMaterial  + 1

		_sAvailableMaterial[_iMaterial] = `Поверхности Торцов Крыши`
		_iAvailableMaterial[_iMaterial] = 9
		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = ROOF_MAT_EDGE
		_sAvailableMaterialPict[_iMaterial] = "ui_slab_edge_flat(1)"
		_iMaterial  = _iMaterial  + 1

		_sAvailableMaterial[_iMaterial] = `Нижняя Поверхность Крыши`
		_iAvailableMaterial[_iMaterial] = 10
		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = ROOF_MAT_BOTT
		_sAvailableMaterialPict[_iMaterial] = "ui_slab_bottom_flat(1)"
		_iMaterial  = _iMaterial  + 1

	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_MESH | bDefaultElem then
!		MESH_MAT_TOP material of the top surface of the mesh
!		MESH_MAT_EDGE material of the edges of the mesh
!		MESH_MAT_BOTT material of the bottom surface of the mesh 

		_sAvailableMaterial[_iMaterial] = `Верхняя Поверхность 3D-сетки`
		_iAvailableMaterial[_iMaterial] = 11
		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = MESH_MAT_TOP
		_sAvailableMaterialPict[_iMaterial] = "ui_mesh_top_flat(1)"
		_iMaterial  = _iMaterial  + 1

		_sAvailableMaterial[_iMaterial] = `Боковые Поверхности 3D-сетки`
		_iAvailableMaterial[_iMaterial] = 12
		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = MESH_MAT_EDGE
		_sAvailableMaterialPict[_iMaterial] = "ui_mesh_skirt_flat(1)"
		_iMaterial  = _iMaterial  + 1

		_sAvailableMaterial[_iMaterial] = `Нижняя Поверхность 3D-сетки`
		_iAvailableMaterial[_iMaterial] = 13
		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = MESH_MAT_BOTT
		_sAvailableMaterialPict[_iMaterial] = "ui_mesh_bottom_flat(1)"
		_iMaterial  = _iMaterial  + 1

	endif

	if (GLOB_ELEM_TYPE = ELEM_TYPE_BEAM and BEAM_CROSSSECTION_TYPE <> 0) | bDefaultElem then
!		BEAM_MAT_RIGHT material of the beam on the right side of the reference line
!		BEAM_MAT_LEFT material of the beam on the left side of the reference line
!		BEAM_MAT_TOP material of the beam on the top
!		BEAM_MAT_BOTTOM material of the beam at the bottom
!		BEAM_MAT_END material of the beam at both ends

		_sAvailableMaterial[_iMaterial] = `Правая Поверхность Балки`
		_iAvailableMaterial[_iMaterial] = 14
		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = BEAM_MAT_RIGHT
		_sAvailableMaterialPict[_iMaterial] = "ui_beam_right_flat(1)"
		_iMaterial  = _iMaterial  + 1

		_sAvailableMaterial[_iMaterial] = `Левая Поверхность Балки`
		_iAvailableMaterial[_iMaterial] = 15
		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = BEAM_MAT_LEFT
		_sAvailableMaterialPict[_iMaterial] = "ui_beam_left_flat(1)"
		_iMaterial  = _iMaterial  + 1

		_sAvailableMaterial[_iMaterial] = `Верхняя Поверхность Балки`
		_iAvailableMaterial[_iMaterial] = 16
		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = BEAM_MAT_TOP
		_sAvailableMaterialPict[_iMaterial] = "ui_beam_top_flat(1)"
		_iMaterial  = _iMaterial  + 1

		_sAvailableMaterial[_iMaterial] = `Нижняя Поверхность Балки`
		_iAvailableMaterial[_iMaterial] = 17
		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = BEAM_MAT_BOTTOM
		_sAvailableMaterialPict[_iMaterial] = "ui_beam_bottom_flat(1)"
		_iMaterial  = _iMaterial  + 1

		_sAvailableMaterial[_iMaterial] = `Поверхности Торцов Балки`
		_iAvailableMaterial[_iMaterial] = 18
		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = BEAM_MAT_END
		_sAvailableMaterialPict[_iMaterial] = "ui_beam_end_flat(1)"
		_iMaterial  = _iMaterial  + 1
	endif

!! by design - we dont want to give this function because the globals working only non-libparts cw members	
!! future release
!!	if GLOB_ELEM_TYPE = ELEM_TYPE_CWFRAME | bDefaultElem then
!!		CWFRAME_MAT material of the frame 
!!
!!		_sAvailableMaterial[_iMaterial] = `Curtain Wall Frame Surface`
!!		_iAvailableMaterial[_iMaterial] = 19
!!		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = CWFRAME_MAT
!!		_sAvailableMaterialPict[_iMaterial] = "ui_general_surface_flat(1)"
!!		_iMaterial  = _iMaterial  + 1
!!
!!	endif
!!
!!	if GLOB_ELEM_TYPE = ELEM_TYPE_CWPANEL | bDefaultElem then
!!		CWPANEL_MAT_OUTER material for the exterior surface of the panel
!!		CWPANEL_MAT_INNER material for the interior surface of the panel
!!		CWPANEL_MAT_CUT material for the edge of the panel 
!!
!!		_sAvailableMaterial[_iMaterial] = `Curtain Wall Panel Outside Surface`
!!		_iAvailableMaterial[_iMaterial] = 20
!!		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = CWPANEL_MAT_OUTER
!!		_sAvailableMaterialPict[_iMaterial] = "ui_cw_outside_flat(1)"
!!		_iMaterial  = _iMaterial  + 1
!!
!!		_sAvailableMaterial[_iMaterial] = `Curtain Wall Panel Inside Surface`
!!		_iAvailableMaterial[_iMaterial] = 21
!!		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = CWPANEL_MAT_INNER
!!		_sAvailableMaterialPict[_iMaterial] = "ui_cw_inside_flat(1)"
!!
!!		_iMaterial  = _iMaterial  + 1
!!
!!		_sAvailableMaterial[_iMaterial] = `Curtain Wall Panel Edge Surface`
!!		_iAvailableMaterial[_iMaterial] = 22
!!		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = CWPANEL_MAT_CUT
!!		_sAvailableMaterialPict[_iMaterial] = "ui_cw_edge_flat(1)"
!!		_iMaterial  = _iMaterial  + 1
!!
!!	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_SHELL | bDefaultElem then
!		SHELLBASE_MAT_REFERENCE material of the bottom surface of the shell/roof equal to ROOF_MAT_BOTT for roofs
!		SHELLBASE_MAT_EDGE material of the edges of the shell/roof equal to ROOF_MAT_EDGE for roofs
!		SHELLBASE_MAT_OPPOSITE material of the top surface of the shell/roof equal to ROOF_MAT_TOP for roofs 

		_sAvailableMaterial[_iMaterial] = `Поверхность Привязки Оболочки`
		_iAvailableMaterial[_iMaterial] = 23
		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = SHELLBASE_MAT_REFERENCE
		_sAvailableMaterialPict[_iMaterial] = "ui_shell_reference_flat(1)"
		_iMaterial  = _iMaterial  + 1

		_sAvailableMaterial[_iMaterial] = `Поверхности Торцов Оболочки`
		_iAvailableMaterial[_iMaterial] = 24
		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = SHELLBASE_MAT_EDGE
		_sAvailableMaterialPict[_iMaterial] = "ui_shell_edge_flat(1)"
		_iMaterial  = _iMaterial  + 1

		_sAvailableMaterial[_iMaterial] = `Поверхности Оболочки, Противоположная Привязке`
		_iAvailableMaterial[_iMaterial] = 25
		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = SHELLBASE_MAT_OPPOSITE
		_sAvailableMaterialPict[_iMaterial] = "ui_shell_opposite_flat(1)"
		_iMaterial  = _iMaterial  + 1

	endif

	if GLOB_ELEM_TYPE = ELEM_TYPE_MORPH | bDefaultElem then
!		MORPH_MAT_DEFAULT Morph default material

		_sAvailableMaterial[_iMaterial] = `Покрытие Морфа`
		_iAvailableMaterial[_iMaterial] = 26
		_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]] = MORPH_MAT_DEFAULT
		_sAvailableMaterialPict[_iMaterial] = "ui_general_surface_flat(1)"
		_iMaterial  = _iMaterial  + 1
	endif

	_sAvailableMaterial[_iMaterial]			= `Специальный Текст`
	_iAvailableMaterial[_iMaterial]			= 99
	_iAvailableMaterialContent[_iAvailableMaterial[_iMaterial]]= sCustomSurface
	_sAvailableMaterialPict[_iMaterial] 	= "ui_custom_text_flat(1)"

	! if a labeled wall is changed to complex profile dont run PM sript
	if 	((GLOB_ELEM_TYPE = ELEM_TYPE_WALL and WALL_CROSSSECTION_TYPE = 0) |\
		(GLOB_ELEM_TYPE = ELEM_TYPE_COLUMN and COLU_CROSSSECTION_TYPE = 0) |\
		(GLOB_ELEM_TYPE = ELEM_TYPE_BEAM and BEAM_CROSSSECTION_TYPE = 0)) and iSurfacetoDisplay # 99 then
		iSurfacetoDisplay = 99
	endif

	_nameSurface = ""
	if bDefaultElem then
		for iSurfList = 1 to vardim1(_iAvailableMaterial)
			if iSurfacetoDisplay = _iAvailableMaterial[iSurfList] then
				_nameSurface = _sAvailableMaterial[iSurfList]
			endif
		next iSurfList
	else
		if GLOB_SCRIPT_TYPE <> 5 & iSurfacetoDisplay <> 99 then
			nnn = REQUEST ("Name_of_material", _iAvailableMaterialContent[iSurfacetoDisplay], _nameSurface)
		else
			_nameSurface = sCustomSurface	! editable custom parameter
		endif
	endif
	if _nameSurface = "" then _nameSurface = `<нет содержимого>`

	_sSegmentLocal[1][1]	= sPrefixSurface
	_sSegmentLocal[1][2]	= ""
	_sSegmentLocal[1][3]	= ""
	_sSegmentLocal[1][4]	= ""
	_sSegmentLocal[1][5]	= _nameSurface + sSuffixSurface

	_nRowLocal[CONTENT_MATERIAL] = 1
	_displayInOneRowLocal[1] = 1

return

! ==============================================================================
"ContentArea" :	! content 13
! ==============================================================================
	_nRowLocal[CONTENT_AREA] = 0
	_iUnitType = iUnitLocal[CONTENT_AREA]	! = 0 (No Unit)

	gosub "clearing_sSegmentLocal_array"

	if GLOB_ELEM_TYPE = ELEM_TYPE_WALL then
		_calledValue = WALL_AREA : prefix = ""
		gosub "ConvertNumericalValueToString"
		_sSegmentLocal[1][1] = note1			! note 1 (prefix + number)
		_sSegmentLocal[1][2] = note2			! note 2 (frac)
		_sSegmentLocal[1][3] = note3			! note 3 (unit)
		_sSegmentLocal[1][4] = note4			! note 4 (unit index)
		_sSegmentLocal[1][5] = ""				! suffix
	endif

	_nRowLocal [CONTENT_AREA] = 1
	for iRank = 1 to vardim1(_nRowLocal)
		_displayInOneRowLocal[iRank] = 1
	next iRank 

return

! ==========================================================================
"ConvertNumericalValueToString":
! ==========================================================================

gosub "DetermineUnitConversionString"

call "quantity_text_formatter" parameters lengthValue	= _calledValue,
								iUnitType 				= _returnedUnitIndex,	! returned by "DetermineUnitConversionString"
								custom_form 			= custom_form,			! returned by "DetermineUnitConversionString"
								horizontalAlignment		= 1,
								verticalAlignment 		= 1,
								AC_TextFont 			= LABEL_FONT_NAME,
								AC_TextSize 			= LABEL_TEXT_SIZE,
								AC_TextStyle 			= LABEL_FONT_STYLE2,
								szPrefix 				= prefix,
								bShowUnit 				= bShowUnit,
								bShowSuperScript 		= bShowSuperScript,
								bIgnoreHideZeroWholes	= bShowUnit,	! by design
			returned_parameters dummy_lengthOfNote1,
								dummy_lengthOfNote2,
								dummy_lengthOfNote3,
								dummy_lengthOfNote4,
								dummy_totalLength,
								dummy_totalHeight,
								dummy_lengthOfUnit,
								dummy_lengthOfIntegerPart,
								note1,		!szPrefix + main
								note2,		!frac,
								note3,		!szUnit,
								note4,		!szUnitIndex,
								dummy_szExtraPrecision,
								dummy_iAnchorString

    if bShowUnit & _iUnitType = DIMUNIT_DM then note3 = " dm"
return


! ==========================================================================
"DetermineUnitConversionString":
! ==========================================================================
	_returnedUnitIndex 	= 0
	custom_form			= "%0.0"

	if bDecimalOptions = 0 then	

		if _iUnitType = DIMUNIT_MM 			then custom_form	= "%.0mm"		!mm
		if _iUnitType = DIMUNIT_CM 			then custom_form	= "%.0cm"		!cm
		if _iUnitType = DIMUNIT_METER 		then custom_form	= "%.2m"		!m
		if _iUnitType = DIMUNIT_INCH 		then custom_form	= "%0.64fi"		!inch
		if _iUnitType = DIMUNIT_DM			then								!dm
				custom_form	= "%.2m"
				_calledValue = _calledValue * 10
		endif
		if _iUnitType = DIMUNIT_PROJECT	then
			custom_form	= ""
			if 	iSelectedContent[i] = CONTENT_ELEV then	
				_returnedUnitIndex = 6	!"Elevation_dimension"
			else
				_returnedUnitIndex = 1	!"Linear_dimension"
			endif
		endif

		if _iUnitType = SURFUNIT_SQM 		then custom_form = "%.0sqm"			!m2
		if _iUnitType = SURFUNIT_SQCM 		then custom_form = "%.0sqcm"		!cm2
		if _iUnitType = SURFUNIT_SQMM 		then custom_form = "%.2sqmm"		!mm2
		if _iUnitType = SURFUNIT_SQFT 		then custom_form = "%0.3sqf"		!square feet
		if _iUnitType = SURFUNIT_SQINCH 	then custom_form = "%0.3sqi"		!square inches
		if _iUnitType = SURFUNIT_PROJECT 	then : custom_form = ""	:																			
			_returnedUnitIndex = 9												!"Area_dimension"
		endif

		if _iUnitType = VOLUNIT_CM 		then custom_form = "%.2cum"				!m3
		if _iUnitType = VOLUNIT_L 		then custom_form = "%.2l"				!liter 
		if _iUnitType = VOLUNIT_CCM 	then custom_form = "%.1cucm"			!cm3 
		if _iUnitType = VOLUNIT_CMM		then custom_form = "%0.0cumm"			!mm3
		if _iUnitType = VOLUNIT_CFEET 	then custom_form = "%0.3cuf"			!cubic feet	
		if _iUnitType = VOLUNIT_CINCH 	then custom_form = "%0.3cui"			!cubic inches	
		if _iUnitType = VOLUNIT_CYARD 	then custom_form = "%0.3cuy"			!cubic yards		
		if _iUnitType = VOLUNIT_GAL 	then custom_form = "%0.3gal"			!gallon	
		if _iUnitType = VOLUNIT_PROJECT then : custom_form = ""	:
			_returnedUnitIndex = 12												!"Calc_volume_unit"
		endif
	else																						
		if _iUnitType = DIMUNIT_MM 		then custom_form = "%~0." + str(iWorkUnitLinearDecimal,1,0) + "mm"		!mm
		if _iUnitType = DIMUNIT_CM 		then custom_form = "%~0." + str(iWorkUnitLinearDecimal,1,0) + "cm"		!cm
		if _iUnitType = DIMUNIT_METER 	then custom_form = "%~0." + str(iWorkUnitLinearDecimal,1,0) + "m"		!m
		if _iUnitType = DIMUNIT_INCH 	then custom_form = "%0.64fi"									!inch
		if _iUnitType = DIMUNIT_DM 		then
			custom_form = "%~0." + str(iWorkUnitLinearDecimal,1,0) + "m"		!dm
			_calledValue = _calledValue * 10
		endif
		if _iUnitType = DIMUNIT_PROJECT	then
			custom_form	= ""
			if 	iSelectedContent[i] = CONTENT_ELEV then	
				_returnedUnitIndex = 6	!"Elevation_dimension"
			else
				_returnedUnitIndex = 1	!"Linear_dimension"
			endif
		endif							

		if _iUnitType = SURFUNIT_SQM 	then custom_form = "%~0." + str(iWorkUnitAreaDecimal,1,0) + "sqm"	!m2
		if _iUnitType = SURFUNIT_SQCM 	then custom_form = "%~0." + str(iWorkUnitAreaDecimal,1,0) + "sqcm"	!cm2
		if _iUnitType = SURFUNIT_SQMM 	then custom_form = "%~0." + str(iWorkUnitAreaDecimal,1,0) + "sqmm"	!mm2
		if _iUnitType = SURFUNIT_SQFT 	then custom_form = "%~0." + str(iWorkUnitAreaDecimal,1,0) + "sqf"	!square feet
		if _iUnitType = SURFUNIT_SQINCH then custom_form = "%~0." + str(iWorkUnitAreaDecimal,1,0) + "sqi"	!square inches
		if _iUnitType = SURFUNIT_PROJECT 	then : custom_form = ""	:																			
			_returnedUnitIndex = 9																		!"Area_dimension"
		endif

		if _iUnitType = VOLUNIT_CM 		then custom_form = "%~0." + str(iWorkUnitVolumeDecimal,1,0) + "cum"	!m3
		if _iUnitType = VOLUNIT_L 		then custom_form = "%~0." + str(iWorkUnitVolumeDecimal,1,0) + "l"		!liter 
		if _iUnitType = VOLUNIT_CCM 	then custom_form = "%~0." + str(iWorkUnitVolumeDecimal,1,0) + "cucm"	!cm3 
		if _iUnitType = VOLUNIT_CMM 	then custom_form = "%~0." + str(iWorkUnitVolumeDecimal,1,0) + "cumm"	!mm3
		if _iUnitType = VOLUNIT_CFEET 	then custom_form = "%~0." + str(iWorkUnitVolumeDecimal,1,0) + "cuf"	!cubic feet	
		if _iUnitType = VOLUNIT_CINCH 	then custom_form = "%~0." + str(iWorkUnitVolumeDecimal,1,0) + "cui"	!cubic inches	
		if _iUnitType = VOLUNIT_CYARD 	then custom_form = "%~0." + str(iWorkUnitVolumeDecimal,1,0) + "cuy"	!cubic yards		
		if _iUnitType = VOLUNIT_GAL 	then custom_form = "%~0." + str(iWorkUnitVolumeDecimal,1,0) + "gal"	!gallon	
		if _iUnitType = VOLUNIT_PROJECT then : custom_form = ""	:
			_returnedUnitIndex = 12												!"Calc_volume_unit"
		endif
	endif
return

! clearing temporary array after every content type
"clearing_sSegmentLocal_array":
	for p = 1 to vardim1(_sSegmentLocal)
		for q = 1 to vardim2(_sSegmentLocal)
			_sSegmentLocal[p][q] = ""
		next q
	next p
	for p = 1 to vardim1(_displayInOneRowLocal)
		_displayInOneRowLocal[p] = 0
	next p

return

! ==============================================================================
"ReqBuildMatInfo":
! ==============================================================================

	if GLOB_SCRIPT_TYPE <> 5 then
		nnn = REQUEST{2} ("Building_Material_info", _SkinPar3MatName[__SkinVar], "gs_bmat_id", _SkinPar4IDName[__SkinVar])
		nnn = REQUEST{2} ("Building_Material_info", _SkinPar3MatName[__SkinVar], "gs_bmat_manufacturer", _SkinPar5Manuf[__SkinVar])
		nnn = REQUEST{2} ("Building_Material_info", _SkinPar3MatName[__SkinVar], "gs_bmat_description", _SkinPar6Desc[__SkinVar])
	else
		_SkinPar4IDName[__SkinVar]	= ""
		_SkinPar5Manuf[__SkinVar]	= ""
		_SkinPar6Desc[__SkinVar]	= ""
	endif

return

"debugArrays":

if _bDebug then
define style "mainStyleDebug"  "Arial", 3 , 1, 0
style mainStyleDebug
n = request("Height_of_style", "mainStyleDebug", _heightStyle, descent, leading)

! ----- First Column ------
	add2 0,10

	yposDebug = 0
	widthCells = 1

	text2 -7,0,"1st step: init _sSegmentLocal"

	for iDebugRow = 1 to vardim1(_sSegmentLocal)
		for iDebugColu =  1 to vardim2(_sSegmentLocal)
			posx = iDebugColu * widthCells
			width = widthCells
			_text = _sSegmentLocal[iDebugRow][iDebugColu]
			text2 posx, iDebugRow, _text
			rect2 posx + width, 0 , posx, iDebugRow
		next iDebugColu
	next iDebugRow
	yposDebug = yposDebug + vardim1(_sSegmentLocal) + 0.5


	add2 0, yposDebug
	text2 -7,0,"2nd step: init _sSegmentGlobal"

	for iDebugRow = 1 to vardim1(_sSegmentGlobal)
		for iDebugColu =  1 to vardim2(_sSegmentGlobal)
			posx = iDebugColu * widthCells
			width = widthCells
			_text = _sSegmentGlobal[iDebugRow][iDebugColu]
			text2 posx, iDebugRow, _text
			rect2 posx+width, 0, posx, iDebugRow
		next iDebugColu
	next iDebugRow
	del 1
	yposDebug = yposDebug + vardim1(_sSegmentGlobal)  + 0.5

del 1

! ----- Second Column ------

add2 10 + widthCells, 10
	yposDebug = 0	
	text2 -7,0,"3rd step: read iSelectedContent[]"

	for iDebugRow = 1 to vardim1(iSelectedContent)
		posx = 0
		width = widthCells
		text2 posx, iDebugRow, iSelectedContent[iDebugRow]
		rect2 posx+width, 0, posx, iDebugRow
	next iDebugRow
	yposDebug = yposDebug + vardim1(iSelectedContent) + 0.5

	add2 0,yposDebug
	text2 -7,0,"4th step: read _nRowLocal[]"

	for iDebugRow = 1 to vardim1(_nRowLocal)
		posx = 0
		width = widthCells
		text2 posx,iDebugRow,_nRowLocal[iDebugRow]
		rect2 posx+width,0,posx,iDebugRow
	next iDebugRow
	del 1
	yposDebug = yposDebug + vardim1(_nRowLocal) + 0.5

del 1
! ----- Third Column ------

add2 20 + widthCells, 10
	yposDebug = 0

	text2 -7,0,"5th step: after fill _iRowInfo"
	for iDebugRow = 1 to vardim1(_iRowInfo)
		for iDebugColu =  1 to 3
			posx = iDebugColu * widthCells
			width = widthCells
			text2 posx,iDebugRow,_iRowInfo[iDebugRow][iDebugColu]
			rect2 posx+width,0,posx,iDebugRow
		next iDebugColu
	next iDebugRow
	yposDebug = yposDebug + vardim1(_iRowInfo) + 0.5


	add2 0,yposDebug
	text2 -7,0,"6th step: init sRowsOfLabel"
	for iDebugRow = 1 to vardim1(sRowsOfLabel)
		for iDebugColu =  1 to vardim2(sRowsOfLabel)
			posx = iDebugColu * widthCells
			width = widthCells
			text2 posx, iDebugRow, sRowsOfLabel[iDebugRow][iDebugColu]
			rect2 posx+width,0,posx,iDebugRow
		next iDebugColu
	next iDebugRow
	del 1
	yposDebug = yposDebug + vardim1(sRowsOfLabel) + 0.5

	add2 0,yposDebug
	text2 -7,0,"12th step: init iContentOfRow"
	for iDebugRow = 1 to vardim1(iContentOfRow)
		posx = 0
		width = widthCells
		text2 posx,iDebugRow,iContentOfRow[iDebugRow]
		rect2 posx+width,0,posx,iDebugRow
	next iDebugRow
	del 1
	yposDebug = yposDebug + vardim1(iContentOfRow) + 0.5


endif

return

"MasterEnd":

]]>
</Script_1D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_PR SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_PR>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_UI SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_UI>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_VL SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! --------------------------------------------------------------------------
!  CONTENT_SKIN
! --------------------------------------------------------------------------
if _bEnableContentSkinData then
! ==============================================================================
! SKIN CONTENT: in case the custom content array is empty, it is filled up with the automatic content 
! ==============================================================================

	! calculate custom rows
	 _bEmptyCustomArray = 1
	for iSearch = 1 to vardim1(dataCustomSkinRow)
		if dataCustomSkinRow[iSearch] # "" then
			 _bEmptyCustomArray = 0
		endif
	next iSearch

	iCustom = 1
	if _bEmptyCustomArray and not(bDefaultElem) then
		for iRow = 1 to _nRowLabel
			if iContentOfRow[iRow] = CONTENT_SKIN then
				dataCustomSkinRow[iCustom] = _actualSkins[iCustom]
				iCustom = iCustom + 1
			endif
		next iRow 

		parameters dataCustomSkinRow = dataCustomSkinRow
	endif
endif

! --------------------------------------------------------------------------
!  CONTENT_MATERIAL
! --------------------------------------------------------------------------
if _bEnableContentMaterial then

	dim iAvailableMaterial[]
	iAvailableMaterial = _iAvailableMaterial
	parameters iAvailableMaterial = iAvailableMaterial 

	dim sAvailableMaterial[]
	sAvailableMaterial = _sAvailableMaterial
	parameters sAvailableMaterial = sAvailableMaterial 

	dim sAvailableMaterialPict[]
	sAvailableMaterialPict = _sAvailableMaterialPict
	parameters sAvailableMaterialPict = sAvailableMaterialPict

	! if by default elem set displayed Surface is not available in the parent tool after placing, 
	! content is switched to custom instead of another surface type
	_isOutofRange = 0	! for changing parent tool
	for i = 1 to vardim1(iAvailableMaterial)
		if iSurfaceToDisplay <> iAvailableMaterial[i] then
			_isOutofRange = 1
		else
			_isOutofRange = 0
			i = vardim1(iAvailableMaterial) ! force loop end
		endif
	next i
	if _isOutofRange then
		iSurfaceToDisplay = 99	! Custom Text
		parameters iSurfaceToDisplay = iSurfaceToDisplay
	endif

	values{2} "iSurfaceToDisplay" iAvailableMaterial, sAvailableMaterial
	if iSurfaceToDisplay <> 99 then
		lock "sCustomSurface"
		hideparameter "sCustomSurface"
	endif

endif
! ==========================================================================
!END 	!END	!END 	!END 	!END 	!END 	!END 	!END 	!END 	!END
! ==========================================================================




]]>
</Script_VL>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_FWM SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_FWM>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_BWM SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_BWM>

<ParamSection SectVersion="27" SectionFlags="0" SubIdent="0">
	<ParamSectHeader>
		<AutoHotspots>false</AutoHotspots>
		<StatBits>
			<STBit_FixSize/>
		</StatBits>
		<WDLeftFrame>0</WDLeftFrame>
		<WDRightFrame>0</WDRightFrame>
		<WDTopFrame>0</WDTopFrame>
		<WDBotFrame>0</WDBotFrame>
		<LayFlags>65535</LayFlags>
		<WDMirrorThickness>0</WDMirrorThickness>
		<WDWallInset>0</WDWallInset>
	</ParamSectHeader>
	<Parameters>
		<Length Name="A">
			<Description><![CDATA["Dimension 1"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Length Name="B">
			<Description><![CDATA["Dimension 2"]]></Description>
			<Fix/>
			<Value>6.28571428571</Value>
		</Length>
		<Integer Name="iCallingObject">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="iSelectedContent">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="32" SecondDimension="0">
				<AVal Row="1">11</AVal>
				<AVal Row="2">0</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
				<AVal Row="13">0</AVal>
				<AVal Row="14">0</AVal>
				<AVal Row="15">0</AVal>
				<AVal Row="16">0</AVal>
				<AVal Row="17">0</AVal>
				<AVal Row="18">0</AVal>
				<AVal Row="19">0</AVal>
				<AVal Row="20">0</AVal>
				<AVal Row="21">0</AVal>
				<AVal Row="22">0</AVal>
				<AVal Row="23">0</AVal>
				<AVal Row="24">0</AVal>
				<AVal Row="25">0</AVal>
				<AVal Row="26">0</AVal>
				<AVal Row="27">0</AVal>
				<AVal Row="28">0</AVal>
				<AVal Row="29">0</AVal>
				<AVal Row="30">0</AVal>
				<AVal Row="31">0</AVal>
				<AVal Row="32">0</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="iUnitLocal">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="12" SecondDimension="0">
				<AVal Row="1">10</AVal>
				<AVal Row="2">30</AVal>
				<AVal Row="3">20</AVal>
				<AVal Row="4">0</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">10</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
			</ArrayValues>
		</Integer>
		<Boolean Name="bDecimalOptions">
			<Description><![CDATA["Enable Decimal Options"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="iWorkUnitLinearDecimal">
			<Description><![CDATA["Number of Decimals"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="iWorkUnitAreaDecimal">
			<Description><![CDATA["Number of Decimals"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="iWorkUnitVolumeDecimal">
			<Description><![CDATA["Number of Decimals"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="iContentOrderDim">
			<Description><![CDATA["Order of Dimensions"]]></Description>
			<ArrayValues FirstDimension="4" SecondDimension="0">
				<AVal Row="1">1</AVal>
				<AVal Row="2">2</AVal>
				<AVal Row="3">3</AVal>
				<AVal Row="4">4</AVal>
			</ArrayValues>
		</Integer>
		<Boolean Name="bUsePrefixColumn">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<String Name="sContentTypeNames">
			<Description><![CDATA["Custom Content Names"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="12" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
				<AVal Row="3"><![CDATA[""]]></AVal>
				<AVal Row="4"><![CDATA[""]]></AVal>
				<AVal Row="5"><![CDATA[""]]></AVal>
				<AVal Row="6"><![CDATA[""]]></AVal>
				<AVal Row="7"><![CDATA[""]]></AVal>
				<AVal Row="8"><![CDATA[""]]></AVal>
				<AVal Row="9"><![CDATA[""]]></AVal>
				<AVal Row="10"><![CDATA[""]]></AVal>
				<AVal Row="11"><![CDATA[""]]></AVal>
				<AVal Row="12"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<Boolean Name="bUseInSingleRank">
			<Description><![CDATA["Display all as one row"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bSeparatorLinesbyContent">
			<Description><![CDATA[""]]></Description>
			<Value>1</Value>
		</Boolean>

		<!-- title2D: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="title2D">
			<Description><![CDATA["2D Representation"]]></Description>
		</Title>
		<String Name="AC_TextFont">
			<Description><![CDATA["Text Font"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Arial"]]></Value>
		</String>
		<FillPattern Name="filltypeBackground">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>65</Value>
		</FillPattern>
		<RealNum Name="AC_TextSize">
			<Description><![CDATA["Text Size"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2</Value>
		</RealNum>
		<Integer Name="AC_TextStyle">
			<Description><![CDATA["Text Style"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Length Name="labelPosHor">
			<Description><![CDATA["Horizontal Position"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="labelPosVert">
			<Description><![CDATA["Vertical Position"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Angle Name="labelAngle">
			<Description><![CDATA["Rotation Angle"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Boolean Name="bShowHotspots">
			<Description><![CDATA["Show Hotspots"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bSHowFrame">
			<Description><![CDATA["Show Frame"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bShowFill">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bSHow2D">
			<Description><![CDATA["Show 2D Symbol"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Integer Name="iAnchorDataBox">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="iAnchorNameBox">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Angle Name="anglePosition">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>

		<!-- quantity_formatter_macro: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="quantity_formatter_macro">
			<Description><![CDATA["Parameters for Calling Formatter Macro"]]></Description>
		</Title>
		<Boolean Name="bShowSuperScript">
			<Description><![CDATA["Show Unit Exponent as Superscript"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bShowSkinThickness">
			<Description><![CDATA["Show Skin Thickness"]]></Description>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bShowUnit">
			<Description><![CDATA["Show Unit"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>

		<!-- contentID: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="contentID">
			<Description><![CDATA["Content ID"]]></Description>
		</Title>
		<Integer Name="iIDText">
			<Description><![CDATA[""]]></Description>
			<Value>1</Value>
		</Integer>
		<String Name="sIDTextCustom">
			<Description><![CDATA["Custom Text"]]></Description>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="sPrefixID">
			<Description><![CDATA[""]]></Description>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="sSuffixID">
			<Description><![CDATA[""]]></Description>
			<Value><![CDATA[""]]></Value>
		</String>

		<!-- contentCustom: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="contentCustom">
			<Description><![CDATA["Content Custom Text"]]></Description>
		</Title>
		<String Name="sTextDataCustom">
			<Description><![CDATA["Input Array for User Defined Data"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>

		<!-- contentSkindata: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="contentSkindata">
			<Description><![CDATA["Content Skin Data"]]></Description>
		</Title>
		<Boolean Name="bShowSeparatorLines">
			<Description><![CDATA["Show Separator Lines"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bChangeSkinDirection">
			<Description><![CDATA["Reverse Skin Order"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="iTypeSkinContent">
			<Description><![CDATA["Skin Content"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<String Name="sTypeSkinContent">
			<Description><![CDATA["Skin Content"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="iUIFlagSkinContent">
			<Description><![CDATA["UI"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<String Name="dataCustomSkinRow">
			<Description><![CDATA["User Defined Skin Data"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="32" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
				<AVal Row="3"><![CDATA[""]]></AVal>
				<AVal Row="4"><![CDATA[""]]></AVal>
				<AVal Row="5"><![CDATA[""]]></AVal>
				<AVal Row="6"><![CDATA[""]]></AVal>
				<AVal Row="7"><![CDATA[""]]></AVal>
				<AVal Row="8"><![CDATA[""]]></AVal>
				<AVal Row="9"><![CDATA[""]]></AVal>
				<AVal Row="10"><![CDATA[""]]></AVal>
				<AVal Row="11"><![CDATA[""]]></AVal>
				<AVal Row="12"><![CDATA[""]]></AVal>
				<AVal Row="13"><![CDATA[""]]></AVal>
				<AVal Row="14"><![CDATA[""]]></AVal>
				<AVal Row="15"><![CDATA[""]]></AVal>
				<AVal Row="16"><![CDATA[""]]></AVal>
				<AVal Row="17"><![CDATA[""]]></AVal>
				<AVal Row="18"><![CDATA[""]]></AVal>
				<AVal Row="19"><![CDATA[""]]></AVal>
				<AVal Row="20"><![CDATA[""]]></AVal>
				<AVal Row="21"><![CDATA[""]]></AVal>
				<AVal Row="22"><![CDATA[""]]></AVal>
				<AVal Row="23"><![CDATA[""]]></AVal>
				<AVal Row="24"><![CDATA[""]]></AVal>
				<AVal Row="25"><![CDATA[""]]></AVal>
				<AVal Row="26"><![CDATA[""]]></AVal>
				<AVal Row="27"><![CDATA[""]]></AVal>
				<AVal Row="28"><![CDATA[""]]></AVal>
				<AVal Row="29"><![CDATA[""]]></AVal>
				<AVal Row="30"><![CDATA[""]]></AVal>
				<AVal Row="31"><![CDATA[""]]></AVal>
				<AVal Row="32"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<Boolean Name="bCustomListContent">
			<Description><![CDATA["Custom Content"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<String Name="ac_wall_profile_name">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="ac_wall_crosssection_type">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Angle Name="ac_wall_slant_angle1">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<Integer Name="ac_colu_crosssection_type">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<String Name="ac_colu_profile_name">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Angle Name="ac_colu_twist_angle">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>
		<String Name="ac_beam_profile_name">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="ac_beam_crosssection_type">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Angle Name="ac_beam_inclination">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Angle>

		<!-- contentName: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="contentName">
			<Description><![CDATA["Content Name"]]></Description>
		</Title>
		<String Name="sPrefixName">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="sSuffixName">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>

		<!-- contentElevation: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="contentElevation">
			<Description><![CDATA["Content Elevation"]]></Description>
		</Title>
		<Boolean Name="bShowElevTop">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bShowElevBottom">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<String Name="strPrefixElevTop">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="strSuffixElevTop">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="strPrefixElevBottom">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="strSuffixElevBottom">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="iElevationTopMeasuredTo">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="iElevationBottomMeasuredTo">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="iRefStory">
			<Description><![CDATA["Reference Story"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="sRefStory">
			<Description><![CDATA[""]]></Description>
			<Value><![CDATA["Текущий Этаж"]]></Value>
		</String>
		<Angle Name="ac_colu_inclination">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Angle>

		<!-- contentDim: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="contentDim">
			<Description><![CDATA["Content Dimension"]]></Description>
		</Title>
		<Boolean Name="bShowWidth">
			<Description><![CDATA["Show Dimension X"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bShowThickness">
			<Description><![CDATA["Show Thickness"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bShowLength">
			<Description><![CDATA["Show Length"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bShowHeight">
			<Description><![CDATA["Show Height"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<String Name="strSeparator">
			<Description><![CDATA["Separator String"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[" x "]]></Value>
		</String>

		<!-- contentSurf: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="contentSurf">
			<Description><![CDATA["Content SUrface"]]></Description>
		</Title>
		<Boolean Name="bAddBottomSurface">
			<Description><![CDATA["Bottom Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bAddEdgeSurface">
			<Description><![CDATA["Edge Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bAddTopSurface">
			<Description><![CDATA["Top Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bAddSideSurface">
			<Description><![CDATA["Side Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bAddOppSideSurface">
			<Description><![CDATA["Side Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bAddRefSideSurface">
			<Description><![CDATA["Reference Side Surface"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bMorphSurfacePlacehold">
			<Description><![CDATA["Morph Surface Placeholder"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- contentMaterial: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="contentMaterial">
			<Description><![CDATA["Content Material"]]></Description>
		</Title>
		<Integer Name="iSurfaceToDisplay">
			<Description><![CDATA["Surface to Display"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>99</Value>
		</Integer>
		<String Name="sCustomSurface">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="sPrefixSurface">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="sSuffixSurface">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="iAvailableMaterial">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="23" SecondDimension="0">
				<AVal Row="1">1</AVal>
				<AVal Row="2">2</AVal>
				<AVal Row="3">3</AVal>
				<AVal Row="4">4</AVal>
				<AVal Row="5">5</AVal>
				<AVal Row="6">6</AVal>
				<AVal Row="7">7</AVal>
				<AVal Row="8">8</AVal>
				<AVal Row="9">9</AVal>
				<AVal Row="10">10</AVal>
				<AVal Row="11">11</AVal>
				<AVal Row="12">12</AVal>
				<AVal Row="13">13</AVal>
				<AVal Row="14">14</AVal>
				<AVal Row="15">15</AVal>
				<AVal Row="16">16</AVal>
				<AVal Row="17">17</AVal>
				<AVal Row="18">18</AVal>
				<AVal Row="19">23</AVal>
				<AVal Row="20">24</AVal>
				<AVal Row="21">25</AVal>
				<AVal Row="22">26</AVal>
				<AVal Row="23">99</AVal>
			</ArrayValues>
		</Integer>
		<String Name="sAvailableMaterial">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="23" SecondDimension="0">
				<AVal Row="1"><![CDATA["Наружная Поверхность Стены"]]></AVal>
				<AVal Row="2"><![CDATA["Внутренняя Поверхность Стены"]]></AVal>
				<AVal Row="3"><![CDATA["Поверхности Торцов Стены"]]></AVal>
				<AVal Row="4"><![CDATA["Покрытие Колонны"]]></AVal>
				<AVal Row="5"><![CDATA["Верхняя Поверхность Перекрытия"]]></AVal>
				<AVal Row="6"><![CDATA["Поверхности Торцов Перекрытия"]]></AVal>
				<AVal Row="7"><![CDATA["Нижняя Поверхность Перекрытия"]]></AVal>
				<AVal Row="8"><![CDATA["Верхняя Поверхность Крыши"]]></AVal>
				<AVal Row="9"><![CDATA["Поверхности Торцов Крыши"]]></AVal>
				<AVal Row="10"><![CDATA["Нижняя Поверхность Крыши"]]></AVal>
				<AVal Row="11"><![CDATA["Верхняя Поверхность 3D-сетки"]]></AVal>
				<AVal Row="12"><![CDATA["Боковые Поверхности 3D-сетки"]]></AVal>
				<AVal Row="13"><![CDATA["Нижняя Поверхность 3D-сетки"]]></AVal>
				<AVal Row="14"><![CDATA["Правая Поверхность Балки"]]></AVal>
				<AVal Row="15"><![CDATA["Левая Поверхность Балки"]]></AVal>
				<AVal Row="16"><![CDATA["Верхняя Поверхность Балки"]]></AVal>
				<AVal Row="17"><![CDATA["Нижняя Поверхность Балки"]]></AVal>
				<AVal Row="18"><![CDATA["Поверхности Торцов Балки"]]></AVal>
				<AVal Row="19"><![CDATA["Поверхность Привязки Оболочки"]]></AVal>
				<AVal Row="20"><![CDATA["Поверхности Торцов Оболочки"]]></AVal>
				<AVal Row="21"><![CDATA["Поверхности Оболочки, Противоположная Привязке"]]></AVal>
				<AVal Row="22"><![CDATA["Покрытие Морфа"]]></AVal>
				<AVal Row="23"><![CDATA["Специальный Текст"]]></AVal>
			</ArrayValues>
		</String>
		<String Name="sAvailableMaterialPict">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="23" SecondDimension="0">
				<AVal Row="1"><![CDATA["ui_wall_outside_flat(1)"]]></AVal>
				<AVal Row="2"><![CDATA["ui_wall_inside_flat(1)"]]></AVal>
				<AVal Row="3"><![CDATA["ui_wall_edge_flat(1)"]]></AVal>
				<AVal Row="4"><![CDATA["ui_general_surface_flat(1)"]]></AVal>
				<AVal Row="5"><![CDATA["ui_slab_top_flat(1)"]]></AVal>
				<AVal Row="6"><![CDATA["ui_slab_edge_flat(1)"]]></AVal>
				<AVal Row="7"><![CDATA["ui_slab_bottom_flat(1)"]]></AVal>
				<AVal Row="8"><![CDATA["ui_slab_top_flat(1)"]]></AVal>
				<AVal Row="9"><![CDATA["ui_slab_edge_flat(1)"]]></AVal>
				<AVal Row="10"><![CDATA["ui_slab_bottom_flat(1)"]]></AVal>
				<AVal Row="11"><![CDATA["ui_mesh_top_flat(1)"]]></AVal>
				<AVal Row="12"><![CDATA["ui_mesh_skirt_flat(1)"]]></AVal>
				<AVal Row="13"><![CDATA["ui_mesh_bottom_flat(1)"]]></AVal>
				<AVal Row="14"><![CDATA["ui_beam_right_flat(1)"]]></AVal>
				<AVal Row="15"><![CDATA["ui_beam_left_flat(1)"]]></AVal>
				<AVal Row="16"><![CDATA["ui_beam_top_flat(1)"]]></AVal>
				<AVal Row="17"><![CDATA["ui_beam_bottom_flat(1)"]]></AVal>
				<AVal Row="18"><![CDATA["ui_beam_end_flat(1)"]]></AVal>
				<AVal Row="19"><![CDATA["ui_shell_reference_flat(1)"]]></AVal>
				<AVal Row="20"><![CDATA["ui_shell_edge_flat(1)"]]></AVal>
				<AVal Row="21"><![CDATA["ui_shell_opposite_flat(1)"]]></AVal>
				<AVal Row="22"><![CDATA["ui_general_surface_flat(1)"]]></AVal>
				<AVal Row="23"><![CDATA["ui_custom_text_flat(1)"]]></AVal>
			</ArrayValues>
		</String>
		<Boolean Name="bDebug">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
	</Parameters>
</ParamSection>

<Copyright SectVersion="1" SectionFlags="0" SubIdent="0">
	<Author>GRAPHISOFT</Author>
	<License>
		<Type>CC BY-ND</Type>
		<Version>3.0</Version>
	</License>
</Copyright>

<Keywords SectVersion="1" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Keywords>

<Comment SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Comment>

</Symbol>
