<?xml version="1.0" encoding="UTF-8"?>
<Symbol IsArchivable="false" IsPlaceable="false" MainGUID="2DAE714F-7409-4247-B425-65419C2FB216" MigrationValue="Normal" Owner="1196638531" Signature="1196644685" Version="43">
<Ancestry SectVersion="1" SectionFlags="0" SubIdent="0" Template="false">
	<MainGUID>F938E33A-329D-4A36-BE3E-85E126820996</MainGUID>
	<MainGUID>B176ABF1-5813-478F-926B-28EE7C5DC1F7</MainGUID>
	<MainGUID>4FD10D67-2F29-4844-A65A-6597589B0CB5</MainGUID>
</Ancestry>

<CalledMacros SectVersion="2" SectionFlags="0" SubIdent="0">
	<Macro>
		<MName><![CDATA["DynamicTableWriter"]]></MName>
		<MainGUID>12BD2FEE-5DF8-4F1F-98E1-EB78C949A26A</MainGUID>
	</Macro>
</CalledMacros>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_3D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_3D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_2D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
if nRows = 4 & gs_ui_current_page = idTab_AdditionalWork & GLOB_PREVIEW_MODE = 1 then
	gosub "drawAdditionalWork"
	end 
endif 

! ================================================================================
! Lines, hotspots, sizing, attributes
! ================================================================================

! --------------------------------------------------------------------------------
! Enable Frame in Editing Contexts
! --------------------------------------------------------------------------------
_bEditingContext = (GLOB_CONTEXT = 28 | GLOB_CONTEXT = 22 | GLOB_CONTEXT = 28)
_blockWidth = (A-_gapSumWidth)/nBlocks
_bEnableEmptyRowLines = (bShowVertLines | bShowHorizLines)

! --------------------------------------------------------------------------------
! Bounding Box Strech Hotspots
! --------------------------------------------------------------------------------
unID = 1
gosub "boundingBoxHotspots"


! --------------------------------------------------------------------------------
! Display Fill, Frame, block bounding hotlines and feedback lines for editing
! --------------------------------------------------------------------------------
fill fillStamp
pen penFrame
line_type lineTypeFrame
_hotlineID = 1000

gosub "fillFrameLinesAndBlockHotlines"

! --------------------------------------------------------------------------------
! Define Text Style for Data Textblock, Title and Watermark
! --------------------------------------------------------------------------------
gosub "defineTextStyleAttributes"

! --------------------------------------------------------------------------------
! Title hotlines, hotspots and feedback lines in editing mode
! --------------------------------------------------------------------------------
if bDisplayHeader then
	gosub "headerHotlinesHotspotsEditingLines"
endif


! --------------------------------------------------------------------------------
! Display vertical and horizontal feedback lines in editing mode
! --------------------------------------------------------------------------------
gosub "vertHorEditingLines"


! --------------------------------------------------------------------------------
! Watermark
! --------------------------------------------------------------------------------
gosub "watermarkLinesText"


! ================================================================================
! Creating Data Containers if we have existing data
! ================================================================================
_bEmptyDisplayRevisionData = 0

if not(_bEmptyLayoutRevHistory) then
	_nAllRevCol	= vardim2(LayoutRevHistory)
	_nAllRevRow	= vardim1(LayoutRevHistory)
	_nAllChangeCol	= vardim2(LayoutChangeHistory)
	_nAllChangeRow	= vardim1(LayoutChangeHistory)
	_numFullDataCol	= _nAllRevCol+(_nAllChangeCol-1)		! Revision ID is duplicated in both-> -1
	
	dim _stChangeData[][]			! all data from Change Array for operations
	dim _stRevisionData[][]			! all data from Revision Array for operations
	
	
	if iLayoutType = LAYOUT_SIMPLE then
	! --------------------------------------------------------------------------------
	! Collapse Change data: merge column cells belonging to same revision
	! --------------------------------------------------------------------------------
	
		dim _stCollapsedChData[][]
			for h = 1 to _nAllChangeCol
				for kk = 1 to _nAllChangeRow
					_stCollapsedChData[kk][h] = ""
				next kk
			next h
	
		dim _stChangeDataForSub[][]
		
		_stChangeDataForSub = LayoutChangeHistory
		gosub "collapseChangeData"
	
		_stChangeData = _stCollapsedChData
		_stRevisionData = LayoutRevHistory
	else
		_stChangeData = LayoutChangeHistory
		_stRevisionData = LayoutRevHistory
	endif
	
	! --------------------------------------------------------------------------------
	! Gather all revision data in 1 array for further horizontal slicing (filters)
	! --------------------------------------------------------------------------------
	!	_stChangeData: original or collapsed Change data (LAYOUT_CHANGE_HISTORY global)
	!	_stRevisionData: original Revision data (LAYOUT_REVISION_HISTORY global)
	
	dim _fullRevisionData[][]		! merged original Revision data from AC
	
	gosub "getFullRevisionData"

	! force "empty" string into previously non-inicilized cells
	! can not initialize before, no way to calculate full data dimensions in advance
	for i= 1 to vardim1(_fullRevisionData)
		for j = 1 to vardim2(_fullRevisionData)
			if vartype(_fullRevisionData[i][j]) = 1 then
				_fullRevisionData[i][j] = ""
			endif
		next j	
	next i

	! --------------------------------------------------------------------------------
	! Debug function for _fullRevisionData
	! Check if all cells are strings and inicialized after data merge
	! --------------------------------------------------------------------------------
!!!	for iRows = 1 to vardim1(_fullRevisionData)
!!!		for iCols = 1 to vardim2(_fullRevisionData)
!!!			set style "emptyTextStyle"
!!!			text2 0.02*iCols, 0.003*iRows, strlen(_fullRevisionData[iRows][iCols])
!!!		next iCols
!!!	next iRows


	! --------------------------------------------------------------------------------
	! Transfer array for containing actual rows of revision data for input of subroutines,
	! reset and modified with the latest data after every stage, or left with the previous data
	! --------------------------------------------------------------------------------
	dim _actUsedRevisonData[][]
	
	_actUsedRevisonData = _fullRevisionData


	! --------------------------------------------------------------------------------
	! Calculate first active row index (regarding boolean filters condition)
	! --------------------------------------------------------------------------------
	_idxFirstActiveRevision = 0
	
	if bShowLatestRevisonOnly | not(bDisplayFirstRevision) then
		! active boolean filters
		gosub "getFilteredRowStartIndex"
	else
		! no filter, start from the beginning
		_idxFirstActiveRevision = 1
	endif


	! --------------------------------------------------------------------------------
	! Get all filtered data (rows) from selected data array using _idxFirstActiveRevision
	! If no boolean filter is used, the data in filtered arrays is the same as selected arrays
	! --------------------------------------------------------------------------------
	dim _allFilteredRevisionData[][]	! array variable for data rows remaining after using boolean filters
	
	if (vardim1(_actUsedRevisonData) > 0) then
		if bShowLatestRevisonOnly | not(bDisplayFirstRevision) then
			gosub "getFilteredRowsData"
			! use result array for next step by overwriting the transfer array, reset to empty
			dim _actUsedRevisonData[][]
			_actUsedRevisonData = _allFilteredRevisionData
		endif
	else
		_bEmptyDisplayRevisionData = 1
	endif
	
	
	! --------------------------------------------------------------------------------
	! Use custom filters to sort assembled data,
	! only rows matching the criteria will be included in the result data array
	! --------------------------------------------------------------------------------
	dim _allCustFilteredRevisionData[][]	! data rows remaining after executing custom filter options
	
	if (vardim1(_actUsedRevisonData) > 0) then
		if bUseCustomRowFilter then
			_nUsedDataCol = vardim2(_actUsedRevisonData)
		
			! Find index of criteria column by searching all scheme titles----------------------------------
			_idxColCustFilterCriteria = 0
			_idxColumn = 1	
			for _idxColumn = 1 to _nUsedDataCol
				if stCustFilterColumnID = _allSchemeTitleID[_idxColumn] then
					_idxColCustFilterCriteria = _idxColumn
					! exit cycle
					_idxColumn = _nUsedDataCol
				endif
			next _idxColumn
		
			! Match criteria index column data to criteria text (stCustFilterConditionText)------------------------
			_bHasFilterTargetRow = 0
			dim _bRowMatchCustFilterCriteria[]		! array to mark matching row idx, 1: use, 0: leave out
	
			_idxInicialize = 1
			for _idxInicialize = 1 to vardim1(_actUsedRevisonData)
				_bRowMatchCustFilterCriteria[_idxInicialize] = 0
			next _idxInicialize
	
			if _idxColCustFilterCriteria > 0 then
				gosub "matchCustFilterCriteria"
			endif
			
			! only filter _actUsed array if some data row has matching criteria text
			if _bHasFilterTargetRow = 1 then
				gosub "getCustomFilteredRowsData"
				! use result array for next step by overwriting the transfer array, reset to empty
				dim _actUsedRevisonData[][]
				_actUsedRevisonData = _allCustFilteredRevisionData
			else
				! no matching row for filter, nothing to display or work with in the next step, reset working array to empty
				dim _actUsedRevisonData[][]
				_bEmptyDisplayRevisionData = 1
			endif
		endif
	else
		_bEmptyDisplayRevisionData = 1
	endif
	

	
	! --------------------------------------------------------------------------------
	! Sorting order
	! --------------------------------------------------------------------------------
	dim _allSortedRevisionData[][]		! output all filtered rows from selected columns (multiple block included)
	
	if (vardim1(_actUsedRevisonData) > 0) then
		gosub "getSortedRowsData"
		! use result array for next step by overwriting the transfer array, reset to empty
		dim _actUsedRevisonData[][]
		_actUsedRevisonData = _allSortedRevisionData
	else
		_bEmptyDisplayRevisionData = 1
	endif
	

	! --------------------------------------------------------------------------------
	! Collect sorted RevID-s for cell merging info, used in DinamicTableWriter Macro
	! --------------------------------------------------------------------------------
	!		_textMergeClass[][]:	array variable containing Revision IDs in all columns


	dim _textMergeClass[][]

	for _idxInicialize = 1 to nRows
		idxInicializeCol = 1
		for idxInicializeCol = 1 to nColumns
			_textMergeClass[_idxInicialize][idxInicializeCol] = ""
		next idxInicializeCol
	next _idxInicialize

	if (vardim1(_actUsedRevisonData) > 0) then
		for _idxRow = 1 to vardim1(_actUsedRevisonData)
			_idxCol = 1
			for _idxCol = 1 to nColumns
				! fill up all rows with Revision IDs (first column)
				_textMergeClass[_idxRow][_idxCol] = _actUsedRevisonData[_idxRow][1]
			next _idxCol
		next _idxRow
	else
		_bEmptyDisplayRevisionData = 1
	endif

	
	!------------------------------------------------------------------------------------------------
	! Find criteria match and mark RevID column if Show NCS Marker is ON
	!------------------------------------------------------------------------------------------------
	!		_stRevisionData[][]:	original Revision data variable (LAYOUT_REVISION_HISTORY global)
	!		_issueSchemeTitleID[]:	array variable (String), header IDs collected from GlobIssueScheme for NCS marker head UI selection 
	!		_issueSchemeName[]:		array variable (String), header Names collected from GlobIssueScheme for NCS marker head UI selection values
	
	if (vardim1(_actUsedRevisonData) > 0) then
		if bShowNCSRevisionMarker then
			__nUsedDataRows = vardim1(_actUsedRevisonData)
			__nUsedDataCol = vardim2(_actUsedRevisonData)
		
			dim _bRowMatchNCSCriteria[]		! array to mark matching row idx
		
			for _idxInicialize = 1 to __nUsedDataRows
				_bRowMatchNCSCriteria[_idxInicialize] = 0
			next _idxInicialize
		
			! Find index of criteria column -------------------------------------------------------------
			_idxColNCSCriteria = 0
		
			for _idxColumn = 1 to __nUsedDataCol
				if stNCSConditionColumnID = _allSchemeTitleID[_idxColumn] then
					_idxColNCSCriteria = _idxColumn
					! exit cycle
					_idxColumn = __nUsedDataCol
				endif
			next _idxColumn
		
			! Match criteria index column data to criteria text (stNCSConditionText)------------------------
			if _idxColNCSCriteria > 0 then
				gosub "matchNCSCriteria"
			
				! Mark selected and dispalyed Revision ID columns--------------------------------------------
				dim _bDisplayedRevIDColumn[]		! ON: selected and displayed column is Revision ID
			
				for i = 1 to nColumns
					_bDisplayedRevIDColumn[i] = 0
				next i
			
				_idxSelectedCol = 1
				for _idxSelectedCol = 1 to nColumns
					if selectedColumnIDs[_idxSelectedCol] = _allSchemeTitleID[1] then
						! if the actual selected column is a Revision ID column, set value to TRUE
						_bDisplayedRevIDColumn[_idxSelectedCol] = 1
					endif
				next _idxSelectedCol
			endif
		endif
	else
		_bEmptyDisplayRevisionData = 1
	endif
	
	! --------------------------------------------------------------------------------
	! Debug function for _actUsedRevisonData
	! Last point of use
	! --------------------------------------------------------------------------------

!!!	for iRows = 1 to vardim1(_actUsedRevisonData)
!!!		for iCols = 1 to vardim2(_actUsedRevisonData)
!!!			set style "emptyTextStyle"
!!!			text2 0.02*iCols, 0.003*iRows, _actUsedRevisonData[iRows][iCols]
!!!		next iCols
!!!	next iRows



	! --------------------------------------------------------------------------------
	! Collect selected data columns from all data array
	! --------------------------------------------------------------------------------
	dim _selectedRevisionData[][]	! array containing data only from selected columns

	dim _bMergeColumnFlag[]	! indicate revision data origin for merging selected revision cells in column
	for _idxInicialize = 1 to nColumns
		_bMergeColumnFlag[_idxInicialize] = 0
	next _idxInicialize

	if (vardim1(_actUsedRevisonData) > 0) then
		gosub "getSelectedColumnsData"
	else
		_bEmptyDisplayRevisionData = 1
	endif

	! --------------------------------------------------------------------------------
	! Debug function for _selectedRevisionData
	! Using this array from this point
	! --------------------------------------------------------------------------------
!!!	for iRows = 1 to vardim1(_selectedRevisionData)
!!!		for iCols = 1 to vardim2(_selectedRevisionData)
!!!			set style "emptyTextStyle"
!!!			text2 0.02*iCols, 0.003*iRows, _selectedRevisionData[iRows][iCols]
!!!		next iCols
!!!	next iRows

	
	! --------------------------------------------------------------------------------
	! Fill up NCS marker flag column for table drawing macro (using selected columns only)
	! --------------------------------------------------------------------------------
	dim _bMarkerCellFlag[][]			! variable array for tableWriter macro with marker enable flags

	if (vardim1(_selectedRevisionData) > 0) then
		_iRows = 1
		for _iRows = 1 to vardim1(_selectedRevisionData)
			_idxSelectedCol = 1
			for _idxSelectedCol = 1 to nColumns
				if bShowNCSRevisionMarker then
					if _bDisplayedRevIDColumn[_idxSelectedCol] = 1 & _bRowMatchNCSCriteria[_iRows] = 1 then
						_bMarkerCellFlag[_iRows][_idxSelectedCol] = 1
					else
						_bMarkerCellFlag[_iRows][_idxSelectedCol] = 0
					endif
				else
					_bMarkerCellFlag[_iRows][_idxSelectedCol] = 0
				endif
			next _idxSelectedCol
		next _iRows
	else
		_bEmptyDisplayRevisionData= 1
	endif
endif ! of not(_bEmptyLayoutRevHistory)


! ================================================================================
! Display Header
! ================================================================================
! Header Word Wrap and text function arrays
! --------------------------------------------------------------------------------
if bDisplayHeader then
	dim	_paragraphNames[]			! array for paragraph names for 1 row
	dim _textblockNames[]			! array for textblock names for 1 row
	_idxCol = 1
	for _idxCol = 1 to nColumns
		lengthString = 1
		if _idxCol > 9 then lengthString = 2
		_numString = str(_idxCol, lengthString, 0)
		_paragraphNames[_idxCol] = "paragraph_" + _numString
		_textblockNames[_idxCol] = "textblock_" + _numString
	next _idxCol
	
	_idxCol = 1
	_idxRow = 1
	_iBlocks = 1
	_textPosX = 0
	_textPosY = 0
	dim _nHeaderWrappedLines[]		! array for header wrapped line number
	
	! inicialize with 1 line
	_nMaxLinePerHeaderRow = 1

	gosub "headerDisplay"
endif


!==============================================================================
! Display data if any remains after the filters and selections, else just draw empty cells
! ================================================================================
if bDisplayHeader & iHeaderPosition = HEADER_TOP then
	add2 0, -headerRowHeight
endif

if not(_bEmptyDisplayRevisionData) & not(_bEmptyLayoutRevHistory) then
	! --------------------------------------------------------------------------------
	! Run calculation macro of line numbers with selected data array
	! --------------------------------------------------------------------------------
	dim _textDataMacro[][]
	dim _bRevColFlagMacro[]
	dim _bMarkerCellFlagMacro[][]
	dim _textMergeClassMacro[][]
	dim _lineEnds_closed[]
	dim _lineEnds_closedCalc[]

	_lineEnds_closed[1] = 0

	_lineNumDiff = 0

	_bDrawTable		= 0
	_nMaxLines = nRows*nBlocks
	_textDataMacro = _selectedRevisionData
	_bRevColFlagMacro = _bMergeColumnFlag
	_textMergeClassMacro = _textMergeClass
	_bMarkerCellFlagMacro = _bMarkerCellFlag
	if iDataAlign = ALIGN_TO_BOTTOM then
		bStartFromEnd = 1
	else
		bStartFromEnd = 0
	endif
	gosub "callTableWriter"

	! --------------------------------------------------------------------------------
	! Calculate data array slicing to ensure visibility of the last change
	! of the latest revision in all sorting/alignment types
	! --------------------------------------------------------------------------------
	_lineEnds_closedCalc = _lineEnds_closed
	_nAllAvailableRows = nRows * nBlocks
	_nAllDataRows = vardim1(_selectedRevisionData)					! number of all data rows
	_nAllMaxLineRows = _lineEnds_closed[vardim1(_lineEnds_closed)]	! number of all rows nominated for display without breaks (in last cell of returned array)

	_bRevColFlagMacro = _bMergeColumnFlag

	if nBlocks = 1 & (_nAllAvailableRows >= _nAllMaxLineRows) then
		! --------------------------------------------------------------------------------
		! Equal or more free lines than displayed lines without block-break,
		! simply draw data, no need to recalculate used line numbers
		! --------------------------------------------------------------------------------
		_bDrawTable = 1
		_nMaxLines = nRows
		_textDataMacro = _selectedRevisionData
		_bMarkerCellFlagMacro = _bMarkerCellFlag
		_textMergeClassMacro = _textMergeClass

		gosub "callTableWriter"

		! adding empty lines
		_lineNumDiff = max(_nAllAvailableRows - _nAllMaxLineRows)
		_nUsedBlockLineRows = _nAllMaxLineRows
		if (_bEnableEmptyRowLines & bShowLinesEmptyRows) then
			gosub "emptyFillLines"
		endif
	else
		! --------------------------------------------------------------------------------
		! Block-breaks can modify precalculated used line numbers (breaks inside revisions),
		! so section beginning-end index recalculations are needed to ensure
		! the visibility of the latest revision (or last change of latest revision)
		! --------------------------------------------------------------------------------
		_idxStartBlockSliceDataRow = 1		! starting calculations with first index, increment later if necessary
		_bCalculationSuccess = 0

		do
			! start cycle with reset data
			_iBlocks = 1
			dim _idxFirstDataRowBlock[]
			dim _idxLastDataRowBlock[]

			! inicialize
			_idxFirstDataRowBlock[1] = _idxStartBlockSliceDataRow
			_idxLastDataRowBlock[1] = _idxStartBlockSliceDataRow
			_idxBlockSliceDataRow = _idxStartBlockSliceDataRow

			for _iBlocks = 1 to nBlocks
				! try to find the actual block's last data row index
				if _idxBlockSliceDataRow <= _nAllDataRows then
					_idxFirstDataRowBlock[_iBlocks] = _idxBlockSliceDataRow
					while	(_idxBlockSliceDataRow <= vardim1(_lineEnds_closedCalc)) &\
							(_idxBlockSliceDataRow <= _nAllDataRows)  do
								_idxLastDataRowBlock[_iBlocks] = _idxBlockSliceDataRow
								_idxBlockSliceDataRow = _idxBlockSliceDataRow + 1
					endwhile
				else
					_idxFirstDataRowBlock[_iBlocks] = 0
					_idxLastDataRowBlock[_iBlocks] = 0
				endif
	
				_idxSlice = 1
				! new clean array in every block cycle
				dim _sliceData[][]
				dim _sliceTextMergeClass[][]

				if _idxFirstDataRowBlock[_iBlocks] > 0 then
					_iDataRow = _idxFirstDataRowBlock[_iBlocks]
	
					for _iDataRow = _idxFirstDataRowBlock[_iBlocks] to _idxLastDataRowBlock[_iBlocks]
						_iCol = 1
						for _iCol = 1 to nColumns
							_sliceData[_idxSlice][_iCol] = _selectedRevisionData[_iDataRow][_iCol]
							_sliceTextMergeClass[_idxSlice][_iCol] = _textMergeClass[_iDataRow][_iCol]
						next _iCol
						_idxSlice = _idxSlice + 1
					next _iDataRow
				endif

				_linesToWrite = 0
				if vardim1(_sliceData) > 0 then
					_textDataMacro = _sliceData
					_textMergeClassMacro = _sliceTextMergeClass
					_nMaxLines = nRows
					_bDrawTable = 0
					if iDataAlign = ALIGN_TO_BOTTOM then
						bStartFromEnd = 1
					else
						bStartFromEnd = 0
					endif
					gosub "callTableWriter"
	
					! --------------------------------------------------------------------------------
					! Check if precalculated line number fits actual block-break affected line number
					! and if not, correct starting index for the next slice of data adding skipped indexes
					! --------------------------------------------------------------------------------
					
					if _linesToWrite <> (_idxLastDataRowBlock[_iBlocks] - _idxFirstDataRowBlock[_iBlocks]) + 1 then
						! block-break caused more/less used lines than free space
						_lineNumBlockBreakDifference = ((_idxLastDataRowBlock[_iBlocks] - _idxFirstDataRowBlock[_iBlocks]) + 1) - _linesToWrite
						_idxBlockSliceDataRow = _idxBlockSliceDataRow - _lineNumBlockBreakDifference
						_idxLastDataRowBlock[_iBlocks] = _idxBlockSliceDataRow - 1
					endif

					if (iDataSortingOrder = LATEST_TO_FIRST & iDataAlign = ALIGN_TO_TOP) |\
						(iDataSortingOrder = FIRST_TO_LATEST & iDataAlign = ALIGN_TO_BOTTOM) then
						! --------------------------------------------------------------------------------
						! in this mode combinations the latest revision is always automatically displayed first in the table,
						! no need to recalculate starting index, starting slice index does not change
						! --------------------------------------------------------------------------------
						_bCalculationSuccess = 1
					else
						! --------------------------------------------------------------------------------
						! The visibility of the latest revision must be ensured in any case,
						! (which has the last data index in these cases, _nAllDataRows)
						! so the first slicing start index must be incremented accordingly
						! --------------------------------------------------------------------------------
						if _nAllDataRows <= _idxLastDataRowBlock[_iBlocks] then
							! latest revision data's index is included in last block
							_bCalculationSuccess = 1
						else
							! latest revision data's index is still missing from last block, do again starting from the next starting data index
							_bCalculationSuccess = 0
						endif
					endif
				endif
			next _iBlocks
			! increase starter index for next run
			_idxStartBlockSliceDataRow = _idxStartBlockSliceDataRow + 1
		while (_bCalculationSuccess = 0) & (_idxStartBlockSliceDataRow <= _nAllDataRows)

		_iBlocks = 1
		for _iBlocks = 1 to nBlocks
			if _bCalculationSuccess then
				_idxSlice = 1
				! clean array in every block cycle for data and marker flag
				dim _sliceData[][]
				dim _sliceNCSMarkerFlag[][]
				dim _sliceTextMergeClass[][]

				if iDataAlign = ALIGN_TO_BOTTOM then
					add2 A - _blockWidth*_iBlocks - gapBetweenBlocks*(_iBlocks-1), 0
				endif

				_realLinesNum = 0
				if _idxFirstDataRowBlock[_iBlocks] > 0 then
					for _iDataRow = _idxFirstDataRowBlock[_iBlocks] to _idxLastDataRowBlock[_iBlocks]
						for _iCol = 1 to nColumns
							_sliceData[_idxSlice][_iCol] = _selectedRevisionData[_iDataRow][_iCol]
							_sliceTextMergeClass[_idxSlice][_iCol] = _textMergeClass[_iDataRow][_iCol]

							if bShowNCSRevisionMarker then
								_sliceNCSMarkerFlag[_idxSlice][_iCol] = _bMarkerCellFlag[_iDataRow][_iCol]
							else
								_sliceNCSMarkerFlag[_idxSlice][_iCol] = 0
							endif
						next _iCol
						_idxSlice = _idxSlice + 1
					next _iDataRow

					if _idxLastDataRowBlock[_iBlocks] > 0 then
						! data is available for display in current block
						_textDataMacro = _sliceData
						_bMarkerCellFlagMacro = _sliceNCSMarkerFlag
						_textMergeClassMacro = _sliceTextMergeClass
						_nMaxLines = nRows
						_bDrawTable = 1
						if iDataAlign = ALIGN_TO_BOTTOM then
							bStartFromEnd = 1
						else
							bStartFromEnd = 0
						endif
						gosub "callTableWriter"
					else
						! no more data to display, empty block
						_realLinesNum = 0
					endif
				endif

				_nUsedBlockLineRows = _realLinesNum
				_lineNumDiff = max(0, nRows - _nUsedBlockLineRows)
				if (_bEnableEmptyRowLines & bShowLinesEmptyRows) then
					gosub "emptyFillLines"
				endif
				if iDataAlign = ALIGN_TO_BOTTOM then
					del 1
				endif
				if iDataAlign = ALIGN_TO_TOP then
					add2 _blockWidth + gapBetweenBlocks, 0
				endif
			endif
		next _iBlocks
		if iDataAlign = ALIGN_TO_TOP & _bCalculationSuccess then
			del nBlocks
		endif
	endif
else
	! --------------------------------------------------------------------------------
	! Display empty cells (no data, just inner horizontal lines)
	! --------------------------------------------------------------------------------
	pen 1
	for _iBlocks = 1 to nBlocks
		for _countRows = 1 to nRows
			if (_countRows > 1) then
				gosub "drawHorizontalLine"
			endif
			gosub "drawVerticalLines"
			add2 0, -rowHeight
		next _countRows
		del nRows
		add2 _blockWidth + gapBetweenBlocks, 0
	next _iBlocks
	del nBlocks
endif
	
if bDisplayHeader & iHeaderPosition = HEADER_TOP then
	del 1
endif

! --------------------------------------------------------------------------------
end
! --------------------------------------------------------------------------------


! ==============================================================================
"emptyFillLines":
! ==============================================================================
	if iDataAlign = ALIGN_TO_TOP then
		add2 0, _nUsedBlockLineRows * (-rowHeight)
		if (_lineNumDiff < nRows) & (_lineNumDiff > 0) then
			gosub "drawHorizontalLine"
		endif
	else
		add2 0, 0
	endif

	for _iEmptyLines = 1 to _lineNumDiff
		if iDataAlign = ALIGN_TO_TOP & _iEmptyLines > 1 |\
			iDataAlign = ALIGN_TO_BOTTOM & _iEmptyLines > 1 then
			gosub "drawHorizontalLine"
		endif
		gosub "drawVerticalLines"
		add2 0, -rowHeight
	next _iEmptyLines
	if (_iEmptyLines <= nRows) & (iDataAlign = ALIGN_TO_BOTTOM) & (_lineNumDiff > 0) then
		gosub "drawHorizontalLine"
	endif
	del _lineNumDiff
	del 1
return


! ==============================================================================
"drawHorizontalLine":
! ==============================================================================
	pen penFrame
	line_type lineTypeSeparators
	if (bShowHorizLines & bShowLinesEmptyRows) then
		line2 0, 0, _blockWidth, 0
		hotline2 0, 0, _blockWidth, 0, _hotlineID : _hotlineID = _hotlineID + 1
	endif
return

! ==============================================================================
"drawVerticalLines":
! ==============================================================================
	_iCols = 1
	pen penFrame
	line_type lineTypeSeparators
	if (bShowVertLines & bShowLinesEmptyRows) then
		for _iCols = 1 to (nColumns-1)
			add2 columnWidths[_iCols], 0
			line2 0, 0, 0, -rowHeight
			hotline2 0, 0, 0, -rowHeight, _hotlineID : _hotlineID = _hotlineID + 1
		next _iCols
		del (nColumns-1)
	endif
return



! ==============================================================================
"headerDisplay":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		nBlocks:				parameter (Integer) number of Blocks if Multiple Blocks are displayed
!		nColumns:				parameter (Integer) for number of displayed columns set on UI
!		iHeaderPosition:		parameter (Integer) to set the Top/Bottom position of Title
!		headerRowHeight:		parameter (Length) for Title row height
!		iHeaderAlignment:		parameter (Integer) to set Title text alignment
!		_textPosX:				X coor value for text positioning transformation, calculated from actual textblock size and height of text row
!		_textPosY:				Y coor value for text positioning transformation, calculated from actual textblock size and height of text row
!		_textblockNames[]		variable string array to store text block names for cycle
!		__bMaxLineNumCalculation:	variable to enable/disable calculation mode (no actual drawing)
!		columnWidths[]:			parameter (Length) for width of columns
!	Output Parameters:
! ==============================================================================

	for _iBlocks = 1 to nBlocks
		_countRows = 1
		_countCols = 1

		for _countCols = 1 to nColumns
			_bMaxLineNumCalculation = 1
			gosub "headerParagraphAndLineWrap"
		next _countCols

		_countRows = 1
		_countCols = 1
		for _countCols = 1 to nColumns
			_bMaxLineNumCalculation = 0
			gosub "headerParagraphAndLineWrap"

			_nTransHeaderPos = 0
			if iHeaderPosition = HEADER_BOTTOM then
				add2 0, -B + headerRowHeight
				_nTransHeaderPos = _nTransHeaderPos + 1
			endif

			if (bShowVertLines & (_countCols < nColumns)) | _bEditingContext then
				pen penFrame
				line_type lineTypeSeparators
				line2 columnWidths[_countCols], 0, columnWidths[_countCols], -headerRowHeight
				hotline2 columnWidths[_countCols], 0, columnWidths[_countCols], -headerRowHeight, _hotlineID
				_hotlineID = _hotlineID + 1 
			endif

			if iHeaderAlignment = HEAD_ALIGN_CENTER then
				add2 0, -headerRowHeight/2
				_nTransHeaderPos = _nTransHeaderPos + 1
			else
				if iHeaderAlignment = HEAD_ALIGN_BOTTOM then
					add2 0, -headerRowHeight
					_nTransHeaderPos = _nTransHeaderPos + 1
				endif
			endif

			richtext2 _textPosX, _textPosY, _textblockNames[_countCols]
			del _nTransHeaderPos

			add2 columnWidths[_countCols], 0
		next _countCols
		del nColumns

		add2 _blockWidth + gapBetweenBlocks, 0
	next _iBlocks
	del nBlocks
return



! ==============================================================================
"getFullRevisionData":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		_nAllRevRow:			vardim1(LayoutRevHistory), full number of rows in array	
!		_nAllRevCol:			vardim2(LayoutRevHistory), full number of columns in array
!		_nAllChangeRow:			vardim1(LayoutChangeHistory), full number of rows in array
!		_nAllChangeCol:			vardim2(LayoutChangeHistory), full number of columns in array	
!		_numFullDataCol:			_nAllRevCol+_nAllChangeCol-1, Revision ID is duplicated in both, hence the -1
!		_stRevisionData[][]:	original Revision data (LAYOUT_REVISION_HISTORY global/LayoutRevHistory)
!		_stChangeData[][]:		original or collapsed Change data (LAYOUT_CHANGE_HISTORY global/LayoutChangeHistory)
!	Output Parameters:
!		_fullRevisionData[][]:	array containing merged revision and change data from revision manager
! ==============================================================================

	__idxFullDataRow = 0
	__idxChangeRow = 1
	__idxRevRow = 1

	do
		__idxFullDataRow = __idxFullDataRow + 1
		if __idxRevRow <= _nAllRevRow then
			! reading 1 row Revision column data
			for iRevCol = 1 to _nAllRevCol
				_fullRevisionData[__idxFullDataRow][iRevCol] = _stRevisionData[__idxRevRow][iRevCol]
			next iRevCol
		endif
		if (__idxChangeRow <= _nAllChangeRow) & (__idxRevRow <= _nAllRevRow) then
			if _stChangeData[__idxChangeRow][1] = _stRevisionData[__idxRevRow][1] then
				! Change belongs to actual Revision
				for _iChangeCol = 2 to _nAllChangeCol
					! concatenate Change column data to Revision data
					_fullRevisionData[__idxFullDataRow][_nAllRevCol+_iChangeCol-1] = _stChangeData[__idxChangeRow][_iChangeCol]
				next _iChangeCol
				if (__idxChangeRow+1) <= _nAllChangeRow then
					! next Change row Data, unless it was last
					if _stChangeData[__idxChangeRow+1][1] <> _stRevisionData[__idxRevRow][1] then
						! next Change belongs to another Revision
						__idxRevRow = __idxRevRow + 1
					endif
					__idxChangeRow = __idxChangeRow + 1
				else
					! no more remaining Change rows
					__idxRevRow = __idxRevRow + 1
				endif
			else
				! no (more) Change belonging to actual Reveision row, go to next Revision
				__idxRevRow = __idxRevRow + 1
			endif  
		else
			__idxRevRow = __idxRevRow + 1
			__idxChangeRow = __idxChangeRow + 1
		endif
	! do as long as there is a row left in Revision or Change array
	while (__idxRevRow <= _nAllRevRow | __idxChangeRow <= _nAllChangeRow) 
return


! ==============================================================================
"collapseChangeData":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		_nAllChangeRow:				vardim1(LayoutChangeHistory), full number of rows in array
!		_nAllChangeCol:				vardim2(LayoutChangeHistory), full number of columns in array
!		_stChangeDataForSub[][]:	buffer array for sub, this case containing LayoutChangeHistory[][]
!		separatorString:			parameter (String) for separating merged change cell data
!	Output Parameters:
!		_stCollapsedChData[][]:		array containing collapsed Change data for Simple Stamp
! ==============================================================================

	__idxChRow = 1
	__idxChCol = 1
	__idxCollRow = 1

	for __idxChRow = 1 to _nAllChangeRow
		for __idxChCol = 1 to _nAllChangeCol
			if __idxChRow = 1 then
				! first row goes directly into Collapsed array
				_stCollapsedChData[1][__idxChCol] = _stChangeDataForSub[1][__idxChCol]
			else
				if __idxChCol = 1 then
					! dont collapse Revision ID field
					_stCollapsedChData[__idxCollRow][1] = _stChangeDataForSub[__idxChRow][1]
				else
					if _stCollapsedChData[__idxCollRow][__idxChCol] = "" then
						_stCollapsedChData[__idxCollRow][__idxChCol] = _stChangeDataForSub[__idxChRow][__idxChCol]
					else
						! check for redundant data, skip if already listed
						__stSearchIn = separatorString + _stCollapsedChData[__idxCollRow][__idxChCol] + separatorString
						__stSearchWhat = separatorString + _stChangeDataForSub[__idxChRow][__idxChCol] + separatorString
						__bFoundMatch = STRSTR(__stSearchIn, __stSearchWhat)

						if __bFoundMatch = 0 & _stChangeDataForSub[__idxChRow][__idxChCol] <> "" then
							_stCollapsedChData[__idxCollRow][__idxChCol] = _stCollapsedChData[__idxCollRow][__idxChCol] + separatorString + _stChangeDataForSub[__idxChRow][__idxChCol]
						endif
					endif
				endif
			endif
		next __idxChCol
		if __idxChRow < _nAllChangeRow then
			if _stChangeDataForSub[__idxChRow][1] <> _stChangeDataForSub[__idxChRow+1][1] then
			! check Revision key of next row
				__idxCollRow = __idxCollRow + 1
			endif
		endif
	next __idxChRow
return


! ==============================================================================
"getSelectedColumnsData":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		nColumns:						parameter (Integer) for number of displayed columns set on UI
!		iLayoutType:					parameter (Integer) 1-Simple, 2-Detailed
!		_allSchemeTitleID[]:			array variable (String), all header column IDs corresponding _fullRevisionData array
!		_bAllEnableColCellMerge[]:			indicates if Column belongs to Issue(1) or Change(0) originally
!		_actUsedRevisonData[][]:		array containing merged revision and change data from revision manager
!		selectedColumnIDs[]:			array parameter (String), ID-s collected from stColumnData_n UI parameters (column data selected by user)
!	Output Parameters:
!		_selectedRevisionData[][]:		all rows of selected columns extracted from _fullRevisionData[][]
!		_bMergeColumnFlag[]:			indicates if selected Column belongs to Revison(1) or Change(0) originally
! ==============================================================================

	__idxSelectedCol = 1			! Selected column index
	__iCol	= 1
	
	for __idxSelectedCol = 1 to nColumns
		for __iCol = 1 to vardim1(_allSchemeTitleID)
			if selectedColumnIDs[__idxSelectedCol] = _allSchemeTitleID[__iCol] then
				__idxRow = 1
				for __idxRow = 1 to vardim1(_actUsedRevisonData)
					_selectedRevisionData[__idxRow][__idxSelectedCol] = _actUsedRevisonData[__idxRow][__iCol]
				next __idxRow
				if iLayoutType = LAYOUT_DETAILED then
					_bMergeColumnFlag[__idxSelectedCol] = _bAllEnableColCellMerge[__iCol]
				endif
			endif
		next __iCol
	next __idxSelectedCol
return


! ==============================================================================
"getFilteredRowStartIndex":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		_fullRevisionData[][]:			array containing merged revision and change data from revision manager
!		bShowLatestRevisonOnly:			parameter (Boolean) to only display the latest revision changes
!		bDisplayFirstRevision:			parameter (Boolean) to allow displaying the first revision's data
!	Output Parameters:
!		_idxFirstActiveRevision:		index of first active data line after filtering first or last revision's data
! ==============================================================================
	
	if bShowLatestRevisonOnly then
		__idxLatestRevisionID = vardim1(_fullRevisionData)

		! get idx of first data line belonging to the latest revision
		
		for __idxRow = vardim1(_fullRevisionData) to 1 step -1
			! get first data line index of the latest revision
			if _fullRevisionData[__idxRow][1] = _fullRevisionData[__idxLatestRevisionID][1] then
				_idxFirstActiveRevision = __idxRow
			else
				!break cycle, passed first row of latest revision
				__idxRow = 1
			endif
		next __idxRow
	else
		if not(bDisplayFirstRevision) then
			for __idxRow = 1 to vardim1(_fullRevisionData)
				! find first data line index of second revision data, skip the first revision data lines
				if _fullRevisionData[__idxRow][1] = _fullRevisionData[1][1] then
					_idxFirstActiveRevision = __idxRow + 1
				endif
			next __idxRow
		endif
	endif
return


! ==============================================================================
"getFilteredRowsData":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		_idxFirstActiveRevision:		index of first active data line after filtering first or last revision's data
!		_actUsedRevisonData[][]:		input array containing actual data (this case: _fullRevisionData[][])
!	Output Parameters:
! 		_allFilteredRevisionData[][]:	all available data in filtered rows of selected columns
! ==============================================================================
	__nUsedDataRows = vardim1(_actUsedRevisonData)
	__nUsedDataCol = vardim2(_actUsedRevisonData)

	if vardim1(_actUsedRevisonData) >= _idxFirstActiveRevision then
		! index is in valid range
		__idxRemainingRevisionRows = 1
		for _iRows = _idxFirstActiveRevision to __nUsedDataRows
			_iCols = 1
			for _iCols = 1 to __nUsedDataCol
				_allFilteredRevisionData[__idxRemainingRevisionRows][_iCols] = _actUsedRevisonData[_iRows][_iCols]
			next _iCols
			__idxRemainingRevisionRows = __idxRemainingRevisionRows + 1
		next _iRows
	else
		! fill up one line with empty strings for dummy info display function
		for _iCols = 1 to __nUsedDataCol
			_allFilteredRevisionData[1][_iCols] = ""
		next _iCols
	endif
return



! ==============================================================================
"getSortedRowsData":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		iDataSortingOrder: 			parameter (integer)	FIRST_TO_LATEST = 1, LATEST_TO_FIRST = 2
!		iDataAlign:					parameter (integer) ALIGN_TO_TOP = 1, ALIGN_TO_BOTTOM = 2
!		_actUsedRevisonData[][]:	array containing merged revision and change data from revision manager
!	Output Parameters:
! 		_allSortedRevisionData[][]:	all available data in sorted rows of selected columns
! ==============================================================================
	__nUsedDataRows = vardim1(_actUsedRevisonData)
	__nUsedDataCol = vardim2(_actUsedRevisonData)

	if vardim1(_actUsedRevisonData) > 0 then
		if	(iDataSortingOrder = LATEST_TO_FIRST & iDataAlign = ALIGN_TO_TOP) |\
			(iDataSortingOrder = FIRST_TO_LATEST & iDataAlign = ALIGN_TO_BOTTOM) then
			! fill up sorted arrays with reversed filtered arrays for drawing macro

			_iRows = 1
			for _iRows = 1 to __nUsedDataRows
				_iCols = 1
				for _iCols = 1 to __nUsedDataCol
					_allSortedRevisionData[_iRows][_iCols] = _actUsedRevisonData[__nUsedDataRows+1-_iRows][_iCols]
				next _iCols
			next _iRows
		else
			! sorted and filtered are in the same order, just copy
			_allSortedRevisionData = _actUsedRevisonData
		endif
	else
		! fill up one line with empty strings for dummy info display function
		_iCols = 1
		for _iCols = 1 to __nUsedDataCol
			_allSortedRevisionData[1][_iCols] = ""
		next _iCols
	endif
return



! ==============================================================================
"headerParagraphAndLineWrap":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		textIndent:					parameter (Length) for setting text indent
!		columnWidths[]:				parameter (Length) for width of columns
!		selectedColumnNames[]:		array parameter (String), names collected corresponding selectedColumnIDs[]
!		_bMaxLineNumCalculation:	calculation phase, saving data for next running of subroutine
!	Output Parameters:
!		_textPosX:					X coor value for text positioning transformation
!		_textPosY:					Y coor value for text positioning transformation
!		_nHeaderWrappedLines[][]:	number of cellrows needed to display wrapped header text
!		_nMaxLinePerHeaderRow:		number of maximum header rows for alignment calculations
! ==============================================================================

	__styleParagraph	= "headstyle"
	__penParagraph		= penHeaderText
	
	if bUseCustomHeaders[_countCols] = 1 then
		__paragraphString	= selectedCustHeaders[_countCols]
	else
		__paragraphString	= selectedColumnNames[_countCols]
	endif
	__textLineHeight = 0
	__textBlockHeight = 0
	__realTextBlockHeight = 0

	if _countCols <= nColumns then
		gosub "paragraphTextboxSizes"

		if __textLineHeight > 0 then
			_nHeaderWrappedLines[_countCols] = INT(__textBlockHeight / __textLineHeight)
			if _bMaxLineNumCalculation then
				! simulation run: save data on all row items for final drawing calculations
				_nMaxLinePerHeaderRow = max(_nMaxLinePerHeaderRow, _nHeaderWrappedLines[_countCols])
			endif
			__maxTextBlockHeight = _nMaxLinePerHeaderRow * __textLineHeight
			if iHeaderAlignment = HEAD_ALIGN_CENTER then
				_textPosY = __maxTextBlockHeight/2 - __textLineHeight/2*(_nMaxLinePerHeaderRow-_nHeaderWrappedLines[_countCols])
			else
				if iHeaderAlignment = HEAD_ALIGN_TOP then
					_textPosY = 0
				else
					_textPosY = __maxTextBlockHeight - __textLineHeight*(_nMaxLinePerHeaderRow-_nHeaderWrappedLines[_countCols])
				endif
			endif
		endif
	endif
	_textPosX = textIndent
return


! ==============================================================================
"paragraphTextboxSizes":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		iTextAlignments[]:			parameter (Integer array) for setting column alignment
!		textIndent:					parameter (Length) for setting text indent
!		columnWidths[]:				parameter (Length) for width of columns
!	Output Parameters:
!		_textPosX:					X coor value for text positioning transformation
!		_textPosY:					Y coor value for text positioning transformation
!		__realTextBlockHeight:		Height of text with line spacing above
! ==============================================================================

	__cellWidth = columnWidths[_countCols]-2*textIndent

	PARAGRAPH _paragraphNames[_countCols] iTextAlignments[_countCols], 0, 0, 0, 1, 0
		pen __penParagraph
		set style __styleParagraph
		__paragraphString
	ENDPARAGRAPH

	TEXTBLOCK _textblockNames[_countCols] __cellWidth, 1, 0, 1 , 1, 0, _paragraphNames[_countCols]

	nnn = REQUEST ("Height_of_style", __styleParagraph, __textLineHeight)
	__textBlockWidth = 0
	ttt = REQUEST ("TEXTBLOCK_INFO", _textblockNames[_countCols], __textBlockWidth, __textBlockHeight)

	__realTextBlockHeight = __textBlockHeight + (rowHeight/2 - __textLineHeight/2)
return


! ==============================================================================
"boundingBoxHotspots":
! ==============================================================================
	hotspot2 A, 		0, 			unID, B, 1+256		:unID=unID+1
	hotspot2 A, 		0.001,		unID, B, 3+128		:unID=unID+1
	hotspot2 A, 		-B, 		unID, B, 2			:unID=unID+1
	
	hotspot2 0, 		-B, 		unID, A, 1+256		:unID=unID+1
	hotspot2 -0.001,	-B, 		unID, A, 3+128		:unID=unID+1
	hotspot2 A,			-B, 		unID, A, 2			:unID=unID+1
	
	hotspot2 0, 		0, 			unID, A, 1+256		:unID=unID+1
	hotspot2 -0.001, 	0, 			unID, A, 3+128		:unID=unID+1
	hotspot2 A, 		0, 			unID, A, 2			:unID=unID+1
	
	hotspot2 0, 		0, 			unID, B, 1+256		:unID=unID+1
	hotspot2 0, 		0.001,		unID, B, 3+128		:unID=unID+1
	hotspot2 0, 		-B, 		unID, B, 2			:unID=unID+1
return


! ==============================================================================
"watermarkLinesText":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		nBlocks:				parameter (Integer) number of Blocks if Multiple Blocks are displayed
!		bWatermark:				parameter (Boolean) to enable/disable watermark text
!		LAYOUT_CURRENTREVISION_OPEN:	GDL global variable 1/0 last revision open/closed
!		iWMarkOrientation:		parameter (Integer) for watermark text orientation
!		gapBetweenBlocks:		parameter (Length) to set distance between 2 blocks of data
!		_blockWidth:			length variable, block width calculated from columnWidths[] parameters
!	Output Parameters:
! ==============================================================================
	for _iBlocks = 1 to nBlocks
		if bWatermark & LAYOUT_CURRENTREVISION_OPEN then
			__textRotAngle = atn(B/_blockWidth)
			pen penWatermarkText
			set style "waterMarkStyle"
			add2 _blockWidth/2, -B/2
			if iWMarkOrientation = LEFTTOP_RIGHTBOTTOM then
				rot2 -__textRotAngle
			else
				rot2 __textRotAngle
			endif
			text2 0, 0, stWatermark
			del 2
		endif
	
		add2 _blockWidth+gapBetweenBlocks, 0
	next _iBlocks
	del nBlocks
return



! ==============================================================================
"matchNCSCriteria":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		_actUsedRevisonData[][]:		input array containing actual data (this case: _fullRevisionData[][])
!		_idxColNCSCriteria:		criteria column index of _fullRevisionData[][]
!		iNCSConditionType:			integer parameter for condition type
!	Output Parameters:
!		_bRowMatchNCSCriteria[]:	array to mark criteria row match, inicialized to OFF (ON: row criteria matches condition text)
!		_bHasNCSTargetRow:			indicator of at least one row's existence subject to NCS marker
! ==============================================================================
	! reset for "findGeneralCriteriaMatch" subroutine	
	__bHasTargetRow = 0	

	for __idxRow = 1 to vardim1(_actUsedRevisonData)
		if not(_bEmptyLayoutRevHistory) then
			_stNCSUsedCellText = _actUsedRevisonData[__idxRow][_idxColNCSCriteria]
		else
			_stNCSUsedCellText = ""
		endif

		__iConditionType = iNCSConditionType
		__stUsedCellText = _stNCSUsedCellText
		__stConditionText = stNCSConditionText
		__bMatchCase = bNCSCaseSensitive
		__bRowMatchCriteria = 0
		gosub "findGeneralCriteriaMatch"
		_bRowMatchNCSCriteria[__idxRow] = __bRowMatchCriteria
	next __idxRow
	_bHasNCSTargetRow = __bHasTargetRow
return



! ==============================================================================
"matchCustFilterCriteria":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		_actUsedRevisonData[][]:		input array containing actual data (this case: _fullRevisionData[][])
!		_idxColCustFilterCriteria:		criteria column index
!		iCustFilterConditionType:		integer parameter for condition type
!	Output Parameters:
!		_bRowMatchCustFilterCriteria[]:	array to mark criteria row match, ON: row criteria matches condition text
!		_bHasFilterTargetRow:			indicator of at least one row's existence subject to custom filter
! ==============================================================================
	! reset for "findGeneralCriteriaMatch" subroutine	
	__bHasTargetRow = 0

	for __idxRow = 1 to vardim1(_actUsedRevisonData)
		if not(_bEmptyLayoutRevHistory) then
			_stCustCritUsedCellText = _actUsedRevisonData[__idxRow][_idxColCustFilterCriteria]
		else
			_stCustCritUsedCellText = ""
		endif

		__iConditionType = iCustFilterConditionType
		__stUsedCellText = _stCustCritUsedCellText
		__stConditionText = stCustFilterConditionText
		__bMatchCase = bCustFilterCaseSensitive
		__bRowMatchCriteria = 0
		gosub "findGeneralCriteriaMatch"
		_bRowMatchCustFilterCriteria[__idxRow] = __bRowMatchCriteria
	next __idxRow
	_bHasFilterTargetRow = __bHasTargetRow
return



! ==============================================================================
"findGeneralCriteriaMatch":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		__iConditionType:		iNCSConditionType or iCustFilterConditionType
!		__stUsedCellText:		text in actual data cell, subject to pattern matching
!		__stConditionText:		text pattern
!	Output Parameters:
!		__bRowMatchCriteria:	mark criteria row match, ON: row criteria matches condition text
!		__bHasTargetRow:		indicator of at least one row's existence subject to actual filter
! ==============================================================================
	if not(__bMatchCase) then
		__tmpCellText = STRTOLOWER(__stUsedCellText)
		__tmpCondText = STRTOLOWER(__stConditionText)
		__stUsedCellText = __tmpCellText
		__stConditionText = __tmpCondText
	endif

	if __iConditionType = COND_STARTSWITH | __iConditionType = COND_STARTSWITHNOT then
		n = strstr(__stUsedCellText, __stConditionText)
		if n = 1 then
			if __iConditionType = COND_STARTSWITH then
				__bRowMatchCriteria = 1
				__bHasTargetRow = 1
			endif
		else
			if __iConditionType = COND_STARTSWITHNOT then
				__bRowMatchCriteria = 1
				__bHasTargetRow = 1
			endif
		endif
	endif

	if __iConditionType = COND_ENDSWITH | __iConditionType = COND_ENDSWITHNOT then
		__subDataString = ""
		__startPosEndsWith = 1

		__charNumData = strlen(__stUsedCellText)
		__charNumConditionText = strlen(__stConditionText)
		__startPosEndsWith = __charNumData - __charNumConditionText + 1
		__subDataString = strsub(__stUsedCellText, __startPosEndsWith, __charNumConditionText)

		if __subDataString = __stConditionText then
			if __iConditionType = COND_ENDSWITH then
				__bRowMatchCriteria = 1
				__bHasTargetRow = 1
			endif
		else
			if __iConditionType = COND_ENDSWITHNOT then
				__bRowMatchCriteria = 1
				__bHasTargetRow = 1
			endif
		endif
	endif

	if __iConditionType = COND_CONTAINS | __iConditionType = COND_CONTAINSNOT then
		n = strstr(__stUsedCellText, __stConditionText)
		if n = 0 then
			if __iConditionType = COND_CONTAINSNOT then
				__bRowMatchCriteria = 1
				__bHasTargetRow = 1
			endif
		else
			if __iConditionType = COND_CONTAINS then
				__bRowMatchCriteria = 1
				__bHasTargetRow = 1
			endif
		endif
	endif

	if __iConditionType = COND_IS | __iConditionType = COND_ISNOT then
		if __stUsedCellText = __stConditionText then
			if __iConditionType = COND_IS then
				__bRowMatchCriteria = 1
				__bHasTargetRow = 1
			endif
		else
			if __iConditionType = COND_ISNOT then
				__bRowMatchCriteria = 1
				__bHasTargetRow = 1
			endif
		endif
	endif
return



! ==============================================================================
"getCustomFilteredRowsData":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		_actUsedRevisonData[][]:			array containing merged revision and change data from revision manager
!		_bRowMatchCustFilterCriteria[]:		array for marking all matching rows for custom filter criteria
!	Output Parameters:
! 		_allCustFilteredRevisionData[][]:	all available data in filtered rows of selected columns
! ==============================================================================
	__nUsedDataRows = vardim1(_actUsedRevisonData)
	__nUsedDataCol = vardim2(_actUsedRevisonData)
	
	__idxRemainingRevisionRows = 1
	_iRows = 1
	for _iRows = 1 to __nUsedDataRows
		if _bRowMatchCustFilterCriteria[_iRows] = 1 then
			! 1: include row in output
			_iCols = 1
			for _iCols = 1 to __nUsedDataCol
				_allCustFilteredRevisionData[__idxRemainingRevisionRows][_iCols] = _actUsedRevisonData[_iRows][_iCols]
			next _iCols
			__idxRemainingRevisionRows = __idxRemainingRevisionRows + 1
		endif
	next _iRows
return



! ==============================================================================
"fillFrameLinesAndBlockHotlines":
! ==============================================================================
	! --------------------------------------------------------------------------------
	! Background fill and frame polygon
	! --------------------------------------------------------------------------------
	poly2_b 5, (bShowFrame)+bShowFill*2+4, fillFgPenStamp, fillBgPenStamp,
		0, 0, bShowFrame,
		A, 0, bShowFrame,
		A, -B, bShowFrame,
		0, -B, bShowFrame,
		0, 0, -1

	_iBlocks = 1
	for _iBlocks = 1 to nBlocks
		! --------------------------------------------------------------------------------
		! Frame hotlines
		! --------------------------------------------------------------------------------
		hotline2 0, 0, 				_blockWidth, 0,  _hotlineID	: _hotlineID = _hotlineID + 1
		hotline2 0, 0, 				0, 			 -B, _hotlineID	: _hotlineID = _hotlineID + 1
		hotline2 _blockWidth, 0, 	_blockWidth, -B, _hotlineID	: _hotlineID = _hotlineID + 1
		hotline2 0, -B, 			_blockWidth, -B, _hotlineID	: _hotlineID = _hotlineID + 1

		if _bEditingContext then
		! --------------------------------------------------------------------------------
		! Frame editing lines
		! --------------------------------------------------------------------------------
			line_type 1
			line2 0, 0, 			_blockWidth, 0
			line2 0, 0, 			0, 			 -B
			line2 _blockWidth, 0, 	_blockWidth, -B
			line2 0, -B, 			_blockWidth, -B
			line_type lineTypeFrame
		endif

		! --------------------------------------------------------------------------------
		! Additional frame lines between blocks
		! --------------------------------------------------------------------------------
		if (_iBlocks > 1) & bShowFrame then
			line2 0, 0, 		0, 			 -B
		endif
		if (_iBlocks < nBlocks) & bShowFrame then
			line2 _blockWidth, 0, 	_blockWidth, -B
		endif
		add2 _blockWidth + gapBetweenBlocks, 0
	next _iBlocks
	del nBlocks
return



! ==============================================================================
"headerHotlinesHotspotsEditingLines":
! ==============================================================================
	_iBlocks = 1
	for _iBlocks = 1 to nBlocks
		! --------------------------------------------------------------------------------
		! Horizontal header editing lines/hotlines
		! --------------------------------------------------------------------------------
		if _bEditingContext then
			line_type 1
		else
			line_type lineTypeSeparators
		endif
		if iHeaderPosition = HEADER_TOP then
			hotline2 0, -headerRowHeight, _blockWidth, -headerRowHeight, _hotlineID	: _hotlineID = _hotlineID + 1
			if _bEditingContext | bShowHorizLines then
				line2 0, -headerRowHeight, _blockWidth, -headerRowHeight
			endif
		else
			hotline2 0, -B+headerRowHeight, _blockWidth, -B+headerRowHeight, _hotlineID	: _hotlineID = _hotlineID + 1
			if _bEditingContext | bShowHorizLines  then
				line2 0, -B+headerRowHeight, _blockWidth, -B+headerRowHeight
			endif
		endif

		! --------------------------------------------------------------------------------
		!Header hotspots to all columns
		! --------------------------------------------------------------------------------
		_countCols = 1
		__nTransHeader = 0
		if iHeaderPosition = HEADER_BOTTOM then
			add2 0, -B+headerRowHeight
			__nTransHeader = __nTransHeader + 1
		endif

		for _countCols = 1 to nColumns
			gosub "drawHeaderHotspots"
				
			add2 columnWidths[_countCols], 0
		next _countCols
		del nColumns
		del __nTransHeader

		add2 _blockWidth + gapBetweenBlocks, 0
	next _iBlocks
	del nBlocks
return


! ==============================================================================
"drawHeaderHotspots":
! ==============================================================================
	if _iBlocks = 1 then
		hotspot2 columnWidths[_countCols], 	0,	unID, headerRowHeight, 1+128				:	unID = unID + 1
		hotspot2 columnWidths[_countCols], 	1,	unID, headerRowHeight, 3					:	unID = unID + 1
		hotspot2 columnWidths[_countCols], 	-headerRowHeight,	unID, headerRowHeight, 2					:	unID = unID + 1

		hotspot2  0, 						-headerRowHeight,	unID, columnWidths[_countCols], 1+128		:	unID = unID + 1
		hotspot2 -1, 						-headerRowHeight,	unID, columnWidths[_countCols], 3			:	unID = unID + 1
		hotspot2 columnWidths[_countCols], 	-headerRowHeight,	unID, columnWidths[_countCols], 2			:	unID = unID + 1
	endif
return


! ==============================================================================
"vertHorEditingLines":
! ==============================================================================
	if _bEditingContext then
		line_type 1
	else
		line_type lineTypeSeparators
	endif

	_iBlocks = 1
	for _iBlocks = 1 to nBlocks
		if _bEditingContext then
			! --------------------------------------------------------------------------------
			! Horizontal and Vertical Editing Lines
			! --------------------------------------------------------------------------------
			__nTransHeader = 0
			if bDisplayHeader &	iHeaderPosition = HEADER_TOP then
				add2 0, -headerRowHeight
				__nTransHeader = __nTransHeader + 1
			endif
			__numEditingLineRows = nRows
			if bDisplayHeader &	iHeaderPosition = HEADER_BOTTOM then
				! header does it's own top line this case
				__numEditingLineRows = nRows -1
			endif
			for _countRows = 1 to __numEditingLineRows
				_countCols = 1
				line2 0, -rowHeight, _blockWidth, -rowHeight
				for _countCols = 1 to (nColumns-1)
					line2 columnWidths[_countCols], 0, columnWidths[_countCols], -rowHeight
					add2 columnWidths[_countCols], 0
				next _countCols
				del _countCols-1
				add2 0, -rowHeight
			next _countRows
			del __numEditingLineRows
	
			del __nTransHeader
		endif

		! --------------------------------------------------------------------------------
		! Hotspots
		! --------------------------------------------------------------------------------
		_countCols = 1
		for _countCols = 1 to nColumns
			if _iBlocks = 1 then

				if bDisplayHeader &	iHeaderPosition = HEADER_TOP then
					_referenceDistance = -headerRowHeight
				else
					_referenceDistance = 0
				endif
				gosub "drawEditableHotspots"
				gosub "drawGapHotspots"
			endif
			add2 columnWidths[_countCols], 0
		next _countCols
		del nColumns

		add2 _blockWidth + gapBetweenBlocks, 0
	next _iBlocks
	del nBlocks
return


! ==============================================================================
"drawEditableHotspots":
! ==============================================================================
	hotspot2 columnWidths[_countCols], 	_referenceDistance,				unID, rowHeight, 1+128				:	unID = unID + 1
	hotspot2 columnWidths[_countCols], 	1,				unID, 		rowHeight, 	3					:	unID = unID + 1
	hotspot2 columnWidths[_countCols], 	_referenceDistance-rowHeight,		unID, rowHeight, 2					:	unID = unID + 1

	hotspot2  0, 						_referenceDistance-rowHeight,	unID, columnWidths[_countCols], 1+128	:	unID = unID + 1
	hotspot2 -1, 						_referenceDistance-rowHeight,	unID, columnWidths[_countCols], 3		:	unID = unID + 1
	hotspot2 columnWidths[_countCols], 	_referenceDistance-rowHeight,	unID, columnWidths[_countCols], 2		:	unID = unID + 1
return



! ==============================================================================
"drawGapHotspots":
! ==============================================================================
	if (nBlocks > 1) & _countCols = nColumns then
		hotspot2  columnWidths[_countCols], 				0,	unID, gapBetweenBlocks, 1+128	:	unID = unID + 1
		hotspot2 -1, 										0,	unID, gapBetweenBlocks, 3		:	unID = unID + 1
		hotspot2 columnWidths[_countCols]+gapBetweenBlocks, 0,	unID, gapBetweenBlocks, 2		:	unID = unID + 1
	endif
return



! ==============================================================================
"defineTextStyleAttributes":
! ==============================================================================
	__styleHeaderTextBit = bHeaderTextBold + 2 * bHeaderTextItalic \
					 + 4 * bHeaderTextUnderLine + 128 * bHeaderTextStrikeThrough
	
	__styleTextBit = bTextBold + 2 * bTextItalic \
					 + 4 * bTextUnderLine + 128 * bTextStrikeThrough
	
	__styleTextBitWm = bWmTextBold + 2 * bWmTextItalic \
					 + 4 * bWmTextUnderLine + 128 * bWmTextStrikeThrough
	
	
	__fontSizeHeaderModel = fontSizeHeaderMm / 1000
	
	define style "headstyle"  fontTypeHeader, __fontSizeHeaderModel, 5, __styleHeaderTextBit
	
	__fontSizeTextModel = fontSizeTextMm / 1000
	define style "textStyle"  fontTypeText, __fontSizeTextModel, 5, __styleTextBit
	
	__watermarkFontSizeModel = fontSizeWatermarkMm / GLOB_SCALE
	define style "waterMarkStyle"  fontTypeWatermark, __watermarkFontSizeModel, 5, __styleTextBitWm
	
	__fontSizeEmptyModel = fontSizeTextMm / GLOB_SCALE
	define style "emptyTextStyle" fontTypeText, __fontSizeEmptyModel, 5, __styleTextBit
return


! ==============================================================================
"callTableWriter":
! ==============================================================================
	call "DynamicTableWriter" parameters	bDebugMode		= 0,
											bDrawTable		= _bDrawTable,
	
											! table content, column widths, merging info
											textData		= _textDataMacro,
											textMergeClass	= _textMergeClassMacro,
											bMergeColumn	= _bRevColFlagMacro,
											columnAlignments= iTextAlignments,
											
											! text style parameters
											bEnableAllLines		= 0,
											bEnableUnitIndex	= 0,
											bUnitIndex			= 0,
											fontTypeText		= fontTypeText,
											fontSizeTextMm		= fontSizeTextMm,
											styleTextBit		= __styleTextBit,
											penText				= penText,
											leftTextIndentMm 	= textIndent*1000/GLOB_SCALE,
											rightTextIndentMm 	= textIndent*1000/GLOB_SCALE,
	
											! table formatting, ordering
											cellHeightMm		= rowHeight*1000/GLOB_SCALE,
											columnWidths		= columnWidths,
											nMaxLines			= _nMaxLines,
											bStartFromEnd		= bStartFromEnd,
											bFrameOutside		= 0,
											bBottomFrame		= 1,
											bTopFrame			= 1,
											bSideFrame			= 1,
											bFrameInsideVertical = bShowVertLines,
											bFrameInsideHorizontal= bShowHorizLines,
											penFrame			= penFrame,
											bEnableHotlines		= 1,
											hotlineID			= _hotlineID,
											
											! marker parameters
											bShowCellDataMarker	= bShowNCSRevisionMarker,
											bMarkerCellFlag		= _bMarkerCellFlagMacro,
											penMarker			= penNCSMarker,
											sizeMarker			= sizeNCSMarker,
				returned_parameters _hotlineID,
									_linesToWrite,		! number of lines written from the input textdata table
									_realLinesNum,		! number of lines used with the given fixed cell height
									_dummy,
									_lineEnds_closed	! sum height to this line


return


! ==============================================================================
"drawAdditionalWork":
! ==============================================================================
	_modSize = 1
	if (GLOB_VIEW_TYPE = 8) then
		_modSize = 100
	endif
	define style "funStyle"  fontTypeText, _modSize*2*a/3, 5, 0
	set style "funStyle"
	set fill fillStamp

	poly2 4, 1+2+4,
		0,	0,
		a,	0,
		a,	a,
		0,	a
	
	for i2 = 0 to 4
		line2 0,		i2*a/4,		a,			i2*a/4
		line2 i2*a/4,	0,			i2*a/4,		a
	next i2
	
	for _j = 1 to 4
		for _i = 1 to 4
			if dataGame[_i][_j] = 0 then
			else
				pen log(dataGame[_i][_j])/log(2)
				text2 (2*_j-1)*a/8,	(9-2*_i)*a/8, dataGame[_i][_j]
			endif
		next _i
	next _j

	if bGameOver then
		pen penWatermarkText
		line2 0, 0, A, A
		line2 0, A, A, 0
	endif
return



]]>
</Script_2D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_1D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[

!------------------------------------------------------------------------------------------------
! Descriptions
!------------------------------------------------------------------------------------------------
EPS = 0.00001
MM_IN_A_DOT = 25.4 / 72
DOT_IN_MM = 72 / 25.4

w_units_form = ""
rrr = request("Working_length_unit", "", w_units_form)
_bMetricDimensionNeeded = strstr(w_units_form, "m")		! m, cm, mm

bShowFill = 1		! Fill is always ON
_gapSumWidth = gapBetweenBlocks*(nBlocks-1)

!------------------------------------------------------------------------------------------------
! UI TabIDs
!------------------------------------------------------------------------------------------------

idTab_Root = -1
idxPage = 1

idTab_Style			= idxPage	: idxPage = idxPage + 1
idTab_Content		= idxPage	: idxPage = idxPage + 1
idTab_Content2		= idxPage	: idxPage = idxPage + 1
idTab_CustTitle		= idxPage	: idxPage = idxPage + 1
idTab_CustTitle2	= idxPage	: idxPage = idxPage + 1
idTab_DisplayOptions = idxPage	: idxPage = idxPage + 1
idTab_2DRepText 	= idxPage	: idxPage = idxPage + 1
idTab_AdditionalWork = 	 idxPage	: idxPage = idxPage + 1

_nColumnsMax = 16 		! number of allowed columns, keep it even number for UI (2 pages)
_nColMaxPage = 8		! number of allowed rows/pages

!------------------------------------------------------------------------------------------------
! Local Variables
!------------------------------------------------------------------------------------------------
! iHeaderPosition integer values
HEADER_TOP = 1
HEADER_BOTTOM = 2

! iHeaderPosition descriptions
dim _stHeaderPosDesc[2]
	_stHeaderPosDesc[1] = `Сверху`
	_stHeaderPosDesc[2] = `Снизу`

! iHeaderAlignment
HEAD_ALIGN_TOP = 1
HEAD_ALIGN_CENTER = 2
HEAD_ALIGN_BOTTOM = 3


! iLayoutType
LAYOUT_SIMPLE = 1
LAYOUT_DETAILED	= 2

! iTextAlignments, iTextAlignment_n
ANCHOR_LEFT = 1
ANCHOR_CENTER = 2
ANCHOR_RIGHT = 3
ANCHOR_JUSTIFIED = 4

! iDataSortingOrder integer values
FIRST_TO_LATEST = 1
LATEST_TO_FIRST = 2

! iDataAlign integer values
ALIGN_TO_TOP = 1
ALIGN_TO_BOTTOM = 2

! bWatermark
LEFTTOP_RIGHTBOTTOM = 1
LEFTBOTTOM_RIGHTTOP = 2

! ui buttons
iButtonID = 1000
_iButtonIDLimitLower = iButtonID -_nColumnsMax
_iButtonIDLimitUpper = iButtonID + _nColumnsMax

CONTENTORDER_MINUSBUTTON_ID = iButtonID 
CONTENTORDER_PLUSBUTTON_ID = iButtonID

! iNCSConditionType, iCustFilterConditionType
COND_STARTSWITH		= 1
COND_STARTSWITHNOT	= 2
COND_ENDSWITH		= 3
COND_ENDSWITHNOT	= 4
COND_CONTAINS		= 5
COND_CONTAINSNOT	= 6
COND_IS				= 7
COND_ISNOT			= 8

dim _stConditionValues[8]
	_stConditionValues[1] = `начинается с`
	_stConditionValues[2] = `не начинается с`
	_stConditionValues[3] = `оканчивается на`
	_stConditionValues[4] = `не оканчивается на`
	_stConditionValues[5] = `содержит`
	_stConditionValues[6] = `не содержит`
	_stConditionValues[7] = `совпадает с`
	_stConditionValues[8] = `не совпадает с`



if GLOB_SCRIPT_TYPE = 7 then
	goto "MasterEnd"
endif

!------------------------------------------------------------------------------------------------
! Check global existence
!------------------------------------------------------------------------------------------------

dim GlobIssueScheme[2][]
dim GlobChangeScheme[2][]
dim LayoutRevHistory[][]
dim LayoutChangeHistory[][]

_bEmptyGlobIssues = 0
_bEmptyGlobChanges = 0
_bEmptyLayoutRevHistory = 0
_bEmptyLayoutChHistory = 0

if vardim2(GLOB_ISSUE_SCHEME) > 0 then
	! global exists
	GlobIssueScheme		= GLOB_ISSUE_SCHEME
else
	_bEmptyGlobIssues = 1
endif

if vardim2(GLOB_CHANGE_SCHEME) > 0 then
	! global exists
	GlobChangeScheme	= GLOB_CHANGE_SCHEME
else
	_bEmptyGlobChanges = 1
endif

if GLOB_SCRIPT_TYPE = 2 then
	_bLayoutContext = (GLOB_CONTEXT = 8 | GLOB_CONTEXT = 28)
	if _bLayoutContext then
		! Layout context or Layout Editing feedback: use globals from Issue Manager
		LayoutRevHistory	= LAYOUT_REVISION_HISTORY
		LayoutChangeHistory	= LAYOUT_CHANGE_HISTORY
	endif
endif

if vardim2(LayoutRevHistory) <> vardim2(GlobIssueScheme) then
	! if global exists, must have same number of columns as GLOB_ISSUE_SCHEME
	_bEmptyLayoutRevHistory = 1
endif

if vardim2(LayoutChangeHistory) <> vardim2(GlobChangeScheme) then
	! if global exists, must have same number of columns as GLOB_CHANGE_SCHEME
	_bEmptyLayoutChHistory = 1
endif

if not(_bEmptyLayoutRevHistory) & _bEmptyLayoutChHistory then
	! if has revision data but no change attached, create 1 dummy empty change row
	for _iChangeCol = 1 to vardim2(GLOB_CHANGE_SCHEME)
		if _iChangeCol = 1 then
			LayoutChangeHistory[1][1] = LayoutRevHistory[1][1]
		else
			LayoutChangeHistory[1][_iChangeCol] = ""
		endif
	next _iChangeCol
endif


!------------------------------------------------------------------------------------------------
! Collect all column data for UI and Sizing params
!------------------------------------------------------------------------------------------------
dim _bAllFixColumnWidthFlag[]	! ON: fix width when changing size "A", OFF: change of size "A" overrides column width
for h = 1 to (vardim2(GlobIssueScheme)+vardim2(GlobChangeScheme)-1)
	_bAllFixColumnWidthFlag[h] = 0
next h

if iLayoutType = LAYOUT_DETAILED then
	dim _bAllEnableColCellMerge[]	! 0: do not merge cells in selected columns, 1: merge is enabled
	
	for _idxInicialize = 1 to (vardim2(GlobIssueScheme)+vardim2(GlobChangeScheme)-1)
		_bAllEnableColCellMerge[_idxInicialize] = 0
	next _idxInicialize
endif

dim _allSchemeTitleID[]		! Header ID for UI selection from GlobIssueScheme and/or GlobChangeScheme
dim _allSchemeTitleName[]	! Header Name for UI selection from GlobIssueScheme and/or GlobChangeScheme
dim _issueSchemeTitleID[]	! Header ID for UI selection from GlobIssueScheme for NCS marker head
dim _issueSchemeName[]		! Header Name for UI selection from GlobIssueScheme for NCS marker head

_idxAllTitles = 1

for _idxIssue = 1 to vardim2(GlobIssueScheme)
	_allSchemeTitleID[_idxIssue] = GlobIssueScheme[2][_idxIssue]
	_allSchemeTitleName[_idxIssue] = GlobIssueScheme[1][_idxIssue]
	_issueSchemeTitleID[_idxIssue] = GlobIssueScheme[2][_idxIssue]
	_issueSchemeName[_idxIssue] = GlobIssueScheme[1][_idxIssue]

	! Revision ID, Issue ID and Issue Date is fix sized
	if _idxIssue = 1 | _idxIssue = 2 | _idxIssue = 4 then
		_bAllFixColumnWidthFlag[_idxIssue] = 1
	else
		_bAllFixColumnWidthFlag[_idxIssue] = 0
	endif

	if iLayoutType = LAYOUT_DETAILED then
		! enable merging of cells originating from Issue data
		_bAllEnableColCellMerge[_idxIssue] = 1
	endif
next _idxIssue

_idxAllTitles = _idxIssue-1
for _idxChange = 2 to vardim2(GlobChangeScheme)
	_allSchemeTitleID[_idxAllTitles+_idxChange-1] = GlobChangeScheme[2][_idxChange]
	_allSchemeTitleName[_idxAllTitles+_idxChange-1] = GlobChangeScheme[1][_idxChange]

	if (_idxChange = 2 | _idxChange = 4) & (iLayoutType <> LAYOUT_SIMPLE) then
		_bAllFixColumnWidthFlag[_idxAllTitles+_idxChange-1] = 1
	else
		_bAllFixColumnWidthFlag[_idxAllTitles+_idxChange-1] = 0
	endif
	if iLayoutType = LAYOUT_DETAILED then
		! disable merging of cells originating from Change data
		_bAllEnableColCellMerge[_idxAllTitles+_idxChange] = 0
	endif
next _idxChange

_idxAllTitles = _idxAllTitles + _idxChange - 1 - 1


! --------------------------------------------------------------------------------
! Setting Deafults (template) for selected column ID parameter "selectedColumnIDs"
! These columns are not deletable by user from Revision Manager, therefore always available
! Inicializing only when invalid "" ID is in the parameter, and only the first 4 columns
! The other columns get inicialized in the next step in case of selected data gets deleted by the user in Revision Manager
! --------------------------------------------------------------------------------

dim _selectedColumnIDDefaults[4]
	_selectedColumnIDDefaults[1] = "CE12B934-2099-4BCD-B3B1-CFCC850B13BF"
	_selectedColumnIDDefaults[2] = "2B6E2094-9872-4BE8-AB0E-861319807D88"
	_selectedColumnIDDefaults[3] = "F429E418-BB0E-4494-B4D1-9A46562CC8FD"
	_selectedColumnIDDefaults[4] = "8BED4AD8-A781-4A18-BC40-FF7391A19270"

for _idxDefaultColumns = 1 to min(4, nColumns)
	if selectedColumnIDs[_idxDefaultColumns] = "" then
		selectedColumnIDs[_idxDefaultColumns] = _selectedColumnIDDefaults[_idxDefaultColumns]

		__idxAllNames = 1
		for __idxAllNames = 1 to vardim1(_allSchemeTitleID)
			if selectedColumnIDs[_idxDefaultColumns] = _allSchemeTitleID[__idxAllNames] then
				selectedColumnNames[_idxDefaultColumns]= _allSchemeTitleName[__idxAllNames]
			endif
		next __idxAllNames	
	endif
next _idxDefaultColumns
parameters selectedColumnIDs = selectedColumnIDs,
			selectedColumnNames = selectedColumnNames


!------------------------------------------------------------------------------------------------
! Check if every old selected column is still available, not deleted from Revision Manager
! (reset to "Revision ID" guid/name if selected in this object but not there any more)
! it is possible to rename a scheme entry without changing the GUID
!------------------------------------------------------------------------------------------------

_idxSelectedCol = 1			! Selected column index
_idxAllNames	= 1
dim _bFoundMatch[]

for _idxSelectedCol = 1 to nColumns
	_bFoundMatch[_idxSelectedCol] = 0
	for _idxAllNames = 1 to vardim1(_allSchemeTitleID)
		if selectedColumnIDs[_idxSelectedCol] = _allSchemeTitleID[_idxAllNames] then
			_bFoundMatch[_idxSelectedCol] = 1
			selectedColumnNames[_idxSelectedCol]= _allSchemeTitleName[_idxAllNames]

			_idxAllNames = vardim1(_allSchemeTitleID)
		endif
	next _idxAllNames
next _idxSelectedCol

_idxSelectedCol = 1
for _idxSelectedCol = 1 to nColumns
	if _bFoundMatch[_idxSelectedCol] = 0 then
		selectedColumnIDs[_idxSelectedCol] = _allSchemeTitleID[1]
		selectedColumnNames[_idxSelectedCol] = _allSchemeTitleName[1]
	endif
next _idxSelectedCol


!------------------------------------------------------------------------------------------------
! Check if every old selected column is still available for NCS selsction, not deleted from Revision Manager
! (reset to "Revision ID" guid/name if selected in this object but not there any more)
! it is possible to rename a scheme without changing the GUID
!------------------------------------------------------------------------------------------------
if bShowNCSRevisionMarker then
	gosub "checkSelectedNCSExist"
endif

!------------------------------------------------------------------------------------------------
! Check if every old selected column is still available for Custom row filter selsction, not deleted from Revision Manager
! (reset to "Revision ID" guid/name if selected in this object but not there any more)
! it is possible to rename a scheme without changing the GUID
!------------------------------------------------------------------------------------------------
if bUseCustomRowFilter then
	gosub "checkSelectedCustFilterExist"
endif

!------------------------------------------------------------------------------------------------
! Collect selected column data for Fixed Sizes params
!------------------------------------------------------------------------------------------------
dim _bSelectedFixColumnWidthFlag[]	! ON: fix width when changing size "A", OFF: change of size "A" overrides column width
for i = 1 to nColumns
	_bSelectedFixColumnWidthFlag[i] = 0
next i

_idxSelectedCol = 1			! Selected column index
_idxAllNames	= 1

for _idxSelectedCol = 1 to nColumns
	for _idxAllNames = 1 to vardim1(_allSchemeTitleID)
		if selectedColumnIDs[_idxSelectedCol] = _allSchemeTitleID[_idxAllNames] then
			_bSelectedFixColumnWidthFlag[_idxSelectedCol]= _bAllFixColumnWidthFlag[_idxAllNames]
		endif
	next _idxAllNames
next _idxSelectedCol


!------------------------------------------------------------------------------------------------
! set UI Infield parameter names of column selection into infield variable for iteration
!------------------------------------------------------------------------------------------------
gosub "uiParameterValueVariables"


!------------------------------------------------------------------------------------------------
! put Selected Column Name as default into Custom Name parameter if Custom Name is empty and bUseCustomHeaders is OFF
!------------------------------------------------------------------------------------------------
gosub "setCustomHeaderNames"



goto "MasterEnd"


! ==============================================================================
"uiParameterValueVariables":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		nColumns:					parameter (Integer) for number of displayed columns set on UI
!		stColumnData_n:				parameters (String) n = 1-14, UI parameter of row data selection
!		iTextAlignment_n:			parameters (Integer) n = 1-14, UI parameter of row data alignment
!		stCustHeader_n:				parameters (String) n = 1-14, UI parameter of row data custom header names
!	Output Variables:
!		_stSelectedColParNames[14]:			array variable (String) to store parameter name for row data selection in UI infield iterations
!		_stTextAlignParNames[14]:		array variable (String) to store parameter name for row data alignment in UI infield iterations
!		_stCustHeaderParNames[14]:		array variable (String) to store parameter name for row data custom header names in UI infield iterations
! ==============================================================================

	dim _stSelectedColParNames[16]
	dim _stTextAlignParNames[16]
	dim _stCustHeaderParNames[16]
	__idxColumns = 1

	for __idxColumns = 1 to nColumns
		lengthString = 1
		if __idxColumns > 9 then lengthString = 2
		__numString = str(__idxColumns, lengthString, 0)
		_stSelectedColParNames[__idxColumns]			= "stColumnData_" + __numString
		_stTextAlignParNames[__idxColumns]	= "iTextAlignment_" + __numString
		_stCustHeaderParNames[__idxColumns]	= "stCustHeader_" + __numString
	next __idxColumns
return


! ==============================================================================
"setCustomHeaderNames":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		nColumns:					parameter (Integer) for number of displayed columns set on UI
!		_allSchemeTitleID[]:		array variable (String), all header column IDs corresponding _fullRevisionData array
!		selectedColumnIDs[]:		array parameter (String), ID-s collected from stColumnData_n UI parameters (column data selected by user)
!		selectedColumnNames[]:		array parameter (String), names collected corresponding selectedColumnIDs[]
!		bUseCustomHeaders[]:		array parameter (Boolean) to store bUseCustHeader_n parameters from UI for iterations
!	Output Parameters:
!		selectedCustHeaders[]:		array parameter (String), CUstom Header Names collected from stCustHeader_n UI parameters for iterations
! ==============================================================================

	__idxSelectedCol = 1			! Selected column index
	__idxAllNames	= 1
	
	for __idxSelectedCol = 1 to nColumns
		for __idxAllNames = 1 to vardim1(_allSchemeTitleID)
			if selectedColumnIDs[__idxSelectedCol] = _allSchemeTitleID[__idxAllNames] then
				if selectedCustHeaders[__idxSelectedCol] = "" & bUseCustomHeaders[__idxSelectedCol] = 0 then
					selectedCustHeaders[__idxSelectedCol] = selectedColumnNames[__idxSelectedCol]
				endif
			endif
		next __idxAllNames
	next __idxSelectedCol

	parameters selectedCustHeaders = selectedCustHeaders
return


! ==============================================================================
"checkSelectedNCSExist":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		_issueSchemeTitleID[]:		array variable (String), header IDs collected from GlobIssueScheme for NCS marker head UI selection values
!		_issueSchemeName[]:			array variable (String), header Names collected from GlobIssueScheme for NCS marker head UI selection values
!		stNCSConditionColumnID:	parameter (String), NCS criteria column data ID
!	Output Parameters:
!		stNCSConditionColumnID:	parameter (String), NCS criteria column data ID
! ==============================================================================
	if GLOB_SCRIPT_TYPE <> 7 & GLOB_SCRIPT_TYPE <> 8 then

		__idxAllNCSNames	= 1
		__bFoundNCSMatch	= 0
		
		for __idxAllNCSNames = 1 to vardim1(_issueSchemeTitleID)
			if stNCSConditionColumnID = _issueSchemeTitleID[__idxAllNCSNames] then
				! if previously selected condition still exists in Revision Manager
				__bFoundNCSMatch = 1
				! exit cycle
				__idxAllNCSNames = vardim1(_issueSchemeTitleID)
			endif
		next __idxAllNCSNames
		
		if __bFoundNCSMatch = 0 then
			! Condition column has been deleted from Revision Manager, set to always existing default
			stNCSConditionColumnID = _issueSchemeTitleID[1]
			parameters	stNCSConditionColumnID = stNCSConditionColumnID
					
		endif
	endif
return


! ==============================================================================
"checkSelectedCustFilterExist":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		_issueSchemeTitleID[]:		array variable (String), header IDs collected from GlobIssueScheme for UI selection values
!		_issueSchemeName[]:			array variable (String), header Names collected from GlobIssueScheme for UI selection values
!		stCustFilterColumnID:		parameter (String), Custom filter criteria column data ID
!	Output Parameters:
!		stCustFilterColumnID:	parameter (String), Custom filter criteria column data ID
! ==============================================================================
	if GLOB_SCRIPT_TYPE <> 7 & GLOB_SCRIPT_TYPE <> 8 then

		__idxAllCFNames	= 1
		__bFoundCFMatch	= 0
		
		for __idxAllCFNames = 1 to vardim1(_issueSchemeTitleID)
			if stCustFilterColumnID = _issueSchemeTitleID[__idxAllCFNames] then
				! if previously selected condition still exists in Revision Manager
				__bFoundCFMatch = 1
				! exit cycle
				__idxAllCFNames = vardim1(_issueSchemeTitleID)
			endif
		next __idxAllCFNames
		
		if __bFoundCFMatch = 0 then
			! Condition column has been deleted from Revision Manager, set to always existing default
			stCustFilterColumnID = _issueSchemeTitleID[1]
			parameters	stCustFilterColumnID = stCustFilterColumnID
					
		endif
	endif
return


"MasterEnd":










]]>
</Script_1D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_PR SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_PR>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_UI SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[


!------------------------------------------------------------------------------------------------
! Variables
!------------------------------------------------------------------------------------------------

_titleSuffix1 = ""
_titleSuffix2 = " " + str((_nColMaxPage+1), 1, 0) + "-" + str(_nColumnsMax, 1, 0)
if nColumns > _nColMaxPage then
	_titleSuffix1 = " " + "1-" + str(_nColMaxPage, 1, 0)
endif

_widthButton = 13
_heightButton = 13
_radButtonHeight = 30
_stCustomOutfield = `Специальный`

_bLockPlusButton  = 0
_bLockMinusButton = 0

if nColumns = _nColumnsMax then _bLockPlusButton = 1
if nColumns = 1 then _bLockMinusButton = 1

!------------------------------------------------------------------------------------------------
! Tabpages
!------------------------------------------------------------------------------------------------

ui_dialog `Параметры Истории Редакций`
ui_current_page gs_ui_current_page

ui_page idTab_Style, idTab_Root, `Стиль`, "uiTab_Dimension_flat(1)"
		gosub "pageStyle"

ui_page idTab_Content, idTab_Root, `Данные` + _titleSuffix1, "uiTab_RevContent_flat(1)"
gosub "pageContent1"

if nColumns > _nColMaxPage then
	ui_page idTab_Content2, idTab_Root, `Данные` + _titleSuffix2, "uiTab_RevContent_flat(1)"
		gosub "pageContent2"
endif

if bDisplayHeader then
	ui_page idTab_CustTitle, idTab_Root, `Специальные Заголовки` + _titleSuffix1, "uiTab_RevCustomHeader_flat(1)"
		gosub "pageCustomTitle1"
	
	if nColumns > _nColMaxPage then
		ui_page idTab_CustTitle2, idTab_Root, `Специальные Заголовки` + _titleSuffix2, "uiTab_RevCustomHeader_flat(1)"
			gosub "pageCustomTitle2"
	endif
endif

ui_page idTab_DisplayOptions, idTab_Root, `Дополнительные Параметры Показа`, "uiTab_RevWatermark_flat(1)"
	gosub "pageDisplayOptions"

ui_page idTab_2DRepText, idTab_Root, `2D-отображение Текст`, "uiTab_2DRepr_flat(1)"
	gosub "page2DRepText"

if nRows = 4 then
	ui_page idTab_AdditionalWork, idTab_Root, "2048", "uiTab_GameRevHistory_flat(1)"
	if gs_ui_current_page = idTab_AdditionalWork then
		gosub "pageAdditionalWork"
	endif
endif

file_dependence "uiTab_Dimension_flat(1)"
file_dependence "uiTab_RevContent_flat(1)"
file_dependence "uiTab_2DRepr_flat(1)"
file_dependence "uiTab_RevWatermark_flat(1)"
file_dependence "uiTab_RevCustomHeader_flat(1)"
file_dependence "uiTab_GameRevHistory_flat(1)"

end



!------------------------------------------------------------------------------------------------
! Layout Settings
!------------------------------------------------------------------------------------------------
"pageStyle":
	pageStartY = 8

	ui_style 0, 0
	dy = 22
	x1 = 2
	x2 = 106
	x3 = 206
	x4 = 238
	_infieldHeight = 19

	yCurr = pageStartY

	x1 = 2
	x2 = 106
	x3 = 206
	x4 = 238
	dy = 27

	_ySave = yCurr
	ui_outfield `Строки`, x1, yCurr, x2-x1-1, 15
	ui_infield "nRows", x2, yCurr-4, x3-x2, _infieldHeight
	yCurr = yCurr + dy

	ui_outfield `Единицы`, x1, yCurr, x2-x1-1, 15
	ui_infield "nBlocks", x2, yCurr-4, x3-x2, _infieldHeight
	yCurr = yCurr + dy

	yCurr = _ySave

	__picButtonHeight = 24
	__picButtonWidth = 32
	ui_outfield `Границы`, x4, yCurr, 309-x4-1, 15
	ui_infield{3} "bShowFrame", 309, yCurr-6, __picButtonWidth, __picButtonHeight,
			6, "",					! borderOut.png
			2,
			1, 16, 16, 25, 13,
			"ui_borderOut_flat(1)", "", 0,
			"ui_borderOut_flat(1)", "", 1\
			ui_tooltip `Наружные Границы`
	
	ui_infield{3} "bShowHorizLines", 309+(__picButtonWidth+2), yCurr-6, __picButtonWidth, __picButtonHeight,
			6, "",
			2,
			1, 16, 16, 25, 13,
			"ui_horizontalSeparator_flat(1)", "", 0,
			"ui_horizontalSeparator_flat(1)", "", 1\
			ui_tooltip `Горизонтальные Линии`
	
	ui_infield{3} "bShowVertLines", 309+2*(__picButtonWidth+2), yCurr-6, __picButtonWidth, __picButtonHeight,
			6, "",
			2,
			1, 16, 16, 25, 13,
			"ui_verticalSeparator_flat(1)", "", 0,
			"ui_verticalSeparator_flat(1)", "", 1\
			ui_tooltip `Вертикальные Линии`

	ui_infield{3} "bShowLinesEmptyRows", 309+3*(__picButtonWidth+2), yCurr-6, __picButtonWidth, __picButtonHeight,
			6, "",
			2,
			1, 16, 16, 25, 13,
			"ui_showEmptyRows_off_flat(1)", "", 0,
			"ui_showEmptyRows_on_flat(1)", "", 1\
			ui_tooltip `Показать Линии Пустых Строк`
	yCurr = yCurr + dy

	ui_outfield `Сортировка`, x4, yCurr, 309-x4-1, 15
	ui_infield{3} "iDataSortingOrder", 309, yCurr-6, 2*33, 24,
			4, 1, 2, 1,					! sorting.png
			0, 0, 29, 20,
			1, "",	FIRST_TO_LATEST, 
			2, "",	LATEST_TO_FIRST ui_tooltip `Сортировка от старых редакций к новым или от новым к старым.`

	ui_infield{3} "iDataAlign", 309+66+2, yCurr-6, 2*33, 24,
			4, 2, 2, 1,					! align.png
			0, 0, 29, 20,
			1, "",	ALIGN_TO_TOP, 
			2, "",	ALIGN_TO_BOTTOM ui_tooltip `Выравнивание списка по верху (слева) или по низу (справа).`
	yCurr = yCurr + dy + 3

	ui_separator 0, yCurr-8, 444, yCurr-8
	x1 = 2
	x2 = 106
	x3 = 206
	x4 = 238
	dy = 24
	ui_infield{3}	"bShowLatestRevisonOnly", x1, yCurr-4,	x4-x1-1, _infieldHeight,
			7, "", 2, 1, 0, 0, 0, 0,
			1, `Показ Только Последней Редакции`, 0,
			2, `Показ Только Последней Редакции`, 1

	ui_infield{3}	"bDisplayFirstRevision", x4, yCurr-4,	440-x4, _infieldHeight,
			7, "", 2, 1, 0, 0, 0, 0,
			1, `Включить Первую Редакцию`, 0,
			2, `Включить Первую Редакцию`, 1
	yCurr = yCurr + dy

	ui_infield{3}	"bUseCustomRowFilter", x1, yCurr-4,	440-x1, _infieldHeight,
			7, "", 2, 1, 0, 0, 0, 0,
			1, `Фильтрация Редакций по критериям`, 0,
			2, `Фильтрация Редакций по критериям`, 1
	yCurr = yCurr + dy

	_conditionInfieldParID = "stCustFilterColumnID"
	_xWidthControl = x3-x1-16
	_xStartControl = x1+16
	gosub "conditionInfield"

	x3 = 210
	x4 = 224
	x5 = 309
	ui_infield{3}	"iCustFilterConditionType",	x3, yCurr-4, x5-x3-3, 19,
			8, "", 5, 1,
			0, 0, 0, 0,
			"", _stConditionValues[1],	COND_STARTSWITH,
			"", _stConditionValues[2],	COND_STARTSWITHNOT,
			"", _stConditionValues[3],	COND_ENDSWITH,
			"", _stConditionValues[4],	COND_ENDSWITHNOT,
			"", _stConditionValues[5],	COND_CONTAINS,
			"", _stConditionValues[6],	COND_CONTAINSNOT,
			"", _stConditionValues[7],	COND_IS,
			"", _stConditionValues[8],	COND_ISNOT

	ui_infield "stCustFilterConditionText", x5, yCurr-4, 440 - x5, 19
	yCurr = yCurr + dy

	ui_infield{3}	"bCustFilterCaseSensitive", x1+16, yCurr-4,	x5-x1-16-1, _infieldHeight,
			7, "", 2, 1, 0, 0, 0, 0,
			1, `Учет Регистра`, 0,
			2, `Учет Регистра`, 1

	yCurr = yCurr + dy

	dy = 24
	x1 = 2
	x2 = 106
	x3 = 206
	x4 = 238
	ui_separator 0, yCurr-4, 444, yCurr-4

	ui_outfield `Стиль Текста`, x1, yCurr, x3-x1, 15
	yCurr = yCurr + dy
	
	ui_infield "fontTypeText", x1, yCurr-4, x3-x1, _infieldHeight
	
	ui_pict "ui_FontSize_flat(1)", x4-27-3, yCurr, 27, 14, 1
	
	if _bMetricDimensionNeeded then
		ui_infield "fontSizeTextMm", x4, yCurr-4, 68, _infieldHeight ui_tooltip `Размер Шрифта Заголовка (мм)`
	else
		ui_infield "fontSizeTextPt", x4, yCurr-4, 68, _infieldHeight ui_tooltip `Размер Шрифта Заголовка (пт)`
	endif

	__boldParName		= "bTextBold"
	__italicParName		= "bTextItalic"
	__underlineParName	= "bTextUnderline"
	__strikethroughParName ="bTextStrikethrough"
	gosub "textAttributeButtons"

	yCurr = yCurr + dy
	
	ui_infield{3}	"bDisplayHeader", x1, yCurr-4,	x2-x1-2, _infieldHeight,
			7, "", 2, 1, 0, 0, 0, 0,
			1, `Заголовок`, 0,
			2, `Заголовок`, 1

	ui_infield{3} "iHeaderPosition", x2, yCurr-4, x3-x2, _infieldHeight,
			8, "", 2, 1,
			0, 0, 0, 0,
			"", _stHeaderPosDesc[1], HEADER_TOP,
			"", _stHeaderPosDesc[2], HEADER_BOTTOM


	yCurr = yCurr + dy

	ui_infield "fontTypeHeader", x1, yCurr-4, x3-x1, _infieldHeight
	
	if bDisplayHeader then
		ui_pict "ui_FontSize_flat(1)", x4-27-3, yCurr, 27, 14, 1
	else
		ui_pict "ui_FontSize_hide_flat(1)", x4-27-3, yCurr, 27, 14, 1
	endif
	
	if _bMetricDimensionNeeded then
		ui_infield "fontSizeHeaderMm", x4, yCurr-4, 68, _infieldHeight ui_tooltip `Размер Шрифта Заголовка (мм)`
	else
		ui_infield "fontSizeHeaderPt", x4, yCurr-4, 68, _infieldHeight ui_tooltip `Размер Шрифта Заголовка (пт)`
	endif

	__boldParName		= "bHeaderTextBold"
	__italicParName		= "bHeaderTextItalic"
	__underlineParName	= "bHeaderTextUnderline"
	__strikethroughParName ="bHeaderTextStrikethrough"

	gosub "textAttributeButtons"
return


!------------------------------------------------------------------------------------------------
! Content Order 1
!------------------------------------------------------------------------------------------------
"pageContent1":
	ui_style 0, 0
	pageStartY = 5
	
	x0 = 1
	x1 = 25

	_widthIOfield = 225
	_heightIOfield = 19
	dy = 32

	! --------------------------------------------------------------------------
	! displaying infields 
	! --------------------------------------------------------------------------
	y = pageStartY
	_idxBlockOutfield = 1
	_rowIndexOnPage = _nColMaxPage
	x0 = 1
	x1 = 25
	gosub "displayInfields"

	! --------------------------------------------------------------------------
	! displaying, greying out / activating ordering buttons  
	! --------------------------------------------------------------------------

	buttonOffsetY = ( _heightIOfield - _heightButton)/4
	_idxBlockOutfield = 1
	
	y = pageStartY
	xButton = 258

	gosub "displayPlusMinusButtons"
	
	if _bLockPlusButton then
		ui_pict_button ui_function, "", "ui_button_plus_lock_flat(1)", xButton,	y - 16 - buttonOffsetY,	_widthButton,	_heightButton 	! greyed-out button with no effect
	else
		ui_pict_button ui_function, "", "ui_button_plus_flat(1)", xButton,	y - 16 - buttonOffsetY,	_widthButton,	_heightButton, CONTENTORDER_PLUSBUTTON_ID + i	 ui_tooltip `Добавить Строку`
	endif
return

!------------------------------------------------------------------------------------------------
! Content Order 2
!------------------------------------------------------------------------------------------------
"pageContent2":
	ui_style 0, 0
	pageStartY = 15
	
	x0 = 1
	x1 = 25
	
	_widthIOfield = 225
	_heightIOfield = 19
	dy = 32
	
	! --------------------------------------------------------------------------
	! displaying infields 
	! --------------------------------------------------------------------------
	y = pageStartY
	_idxBlockOutfield = _nColMaxPage + 1
	_rowIndexOnPage = _nColumnsMax
	x0 = 1
	x1 = 25
	gosub "displayInfields"
	
	! --------------------------------------------------------------------------
	! displaying, greying out / activating ordering buttons  
	! --------------------------------------------------------------------------
	
	buttonOffsetY = ( _heightIOfield - _heightButton)/4
	_idxBlockOutfield = _nColMaxPage + 1
	
	y = pageStartY
	xButton = 258

	gosub "displayPlusMinusButtons"

	if nColumns < _rowIndexOnPage then
		ui_pict_button ui_function, "", "ui_button_plus_flat(1)", xButton,	y - 16 - buttonOffsetY,	_widthButton,	_heightButton , CONTENTORDER_PLUSBUTTON_ID + i	 ui_tooltip `Добавить Строку`
	endif
return



!------------------------------------------------------------------------------------------------
! 2D Representation and Text
!------------------------------------------------------------------------------------------------
"page2DRepText":
	listfieldID = idTab_2DRepText
	itemID = 1

	ui_listfield listfieldID, 0, 0, 444, 265, 1

	if bShowFrame | bShowVertLines | bShowHorizLines then
		ui_listitem  itemID, listfieldID, "", 0, "", `Рамка`		:itemID = itemID + 1

		if bShowFrame | bShowVertLines | bShowHorizLines then
			ui_listitem  itemID, listfieldID, "penFrame", 1, "ui_list_contourPen_flat(1)", `Перо Границы`		:itemID = itemID + 1
			if bShowFrame then
				ui_listitem  itemID, listfieldID, "lineTypeFrame", 1, "ui_list_contLineType_flat(1)", `Тип Линии Границы`
			endif
			itemID = itemID + 1
			if bShowVertLines | bShowHorizLines then
				ui_listitem  itemID, listfieldID, "lineTypeSeparators", 1, "ui_list_contLineType_flat(1)", `Тип Линий Разделителей`
			endif
			itemID = itemID + 1
		else
			itemID = itemID + 3
		endif
	else
		itemID = itemID + 4
	endif

	ui_listitem  itemID, listfieldID, "", 0, "", `Штриховка`		:itemID = itemID + 1
	ui_listitem  itemID, listfieldID, "fillStamp", 1, 		"ui_list_fillType_flat(1)", `Тип Штриховки`		:itemID = itemID + 1
	ui_listitem  itemID, listfieldID, "fillFgPenStamp", 1,	"ui_list_fillPen_flat(1)", `Перо Штриховки`		:itemID = itemID + 1
	ui_listitem  itemID, listfieldID, "fillBgPenStamp", 1,	"ui_list_fillBgPen_flat(1)", `Перо Фона Штриховки`		:itemID = itemID + 1

	ui_listitem  itemID, listfieldID, "", 0, "", `Текст`		:itemID = itemID + 1

	ui_listitem  itemID, listfieldID, "textIndent", 1, "", `Отступ Текста`		:itemID = itemID + 1
	if iLayoutType = LAYOUT_SIMPLE then
		ui_listitem  itemID, listfieldID, "separatorString", 1, "", `Строка Разделителя`
	endif
	itemID = itemID + 1
	if bDisplayHeader then
		ui_listitem  itemID, listfieldID, "iHeaderAlignment", 1, "", `Вертикальное Выравнивание Текста Заголовка`		:itemID = itemID + 1
		ui_listitem  itemID, listfieldID, "penHeaderText", 1, "ui_list_pencolor_flat(1)", `Цвет Заголовка`		:itemID = itemID + 1
	else
		itemID = itemID + 2
	endif
	ui_listitem  itemID, listfieldID, "penText", 1, "ui_list_pencolor_flat(1)", `Цвет Текста`		:itemID = itemID + 1
	if bWatermark then
		ui_listitem  itemID, listfieldID, "penWatermarkText", 1, "ui_list_pencolor_flat(1)", `Цвет Водяного Знака`
	endif
	itemID = itemID + 1
return



!------------------------------------------------------------------------------------------------
! Display Options
!------------------------------------------------------------------------------------------------
"pageDisplayOptions":
	ui_style 0, 1
	yCurr = 5
	dy = 23
	x1 = 2
	x2 = 110
	x3 = 210
	x4 = 224
	x5 = 309

	ui_infield{3}	"bWatermark", x1, yCurr-4,	440-x1, 19,
			7, "", 2, 1, 0, 0, 0, 0,
			1, `Показ Водяного Знака на Макетах в Процессе Изменений`, 0,
			2, `Показ Водяного Знака на Макетах в Процессе Изменений`, 1
	
	yCurr = yCurr + dy
	ui_style 0, 0
	ui_outfield `Ориентация`, x1, yCurr, x3-x1-1, 17, 4-4*bWatermark
	ui_infield{3}	"iWMarkOrientation",	x3, yCurr-4, 440-x3, 19,
			8, "", 2, 1,
			0, 0, 0, 0,
			1, `Сверху Вниз`,	LEFTTOP_RIGHTBOTTOM,
			2, `Снизу Вверх`,	LEFTBOTTOM_RIGHTTOP

	yCurr = yCurr + dy

	ui_outfield `Текст`, x1, yCurr, x3-x1-1, 15, 4-4*bWatermark
	ui_infield "stWatermark", x3, yCurr-4, 440-x3, 19
	yCurr = yCurr + dy

	ui_outfield `Стиль Текста`, x1, yCurr, x3-x1, 15, 4-4*bWatermark
	yCurr = yCurr + dy
	
	ui_infield "fontTypeWatermark", x1, yCurr-4, x3-x1, 19
	
	if bWatermark then
		ui_pict "ui_FontSize_flat(1)", 214, yCurr, 27, 14, 1
	else
		ui_pict "ui_FontSize_hide_flat(1)", 214, yCurr, 27, 14, 1
	endif

	if _bMetricDimensionNeeded then
		ui_infield "fontSizeWatermarkMm", 246, yCurr-4, 60, 19 ui_tooltip `Размер Шрифта Водяного Знака (мм)`
	else
		ui_infield "fontSizeWatermarkPt", 246, yCurr-4, 60, 19 ui_tooltip `Размер Шрифта Водяного Знака (пт)`
	endif

	__boldParName		= "bWmTextBold"
	__italicParName		= "bWmTextItalic"
	__underlineParName	= "bWmTextUnderline"
	__strikethroughParName ="bWmTextStrikethrough"
	gosub "textAttributeButtons"
	
	yCurr = yCurr + dy
	ui_outfield `Перо Текста`, x1, yCurr, x3-x1-1, 15, 4-4*bWatermark
	ui_infield "penWatermarkText", x3, yCurr-4, 33, 19
	
	yCurr = yCurr + 18

	ui_separator 0, yCurr, 444, yCurr
	yCurr = yCurr + 8
	ui_style 0, 1
	ui_infield{3}	"bShowNCSRevisionMarker", x1, yCurr-4,	440-x1, 19,
			7, "", 2, 1, 0, 0, 0, 0,
			1, `Показ Маркера вокруг ID Редакции, если:`, 0,
			2, `Показ Маркера вокруг ID Редакции, если:`, 1

	ui_style 0, 0

	yCurr = yCurr + dy
	_conditionInfieldParID = "stNCSConditionColumnID"
	_xWidthControl = x3-x1-5
	_xStartControl = x1
	gosub "conditionInfield"

	x1 = 50
	ui_pict 3, 10, yCurr+dy+3, 33, 30, 1			! marker.png

	ui_infield{3}	"iNCSConditionType",	x3, yCurr-4, x5-x3-3, 19,
			8, "", 5, 1,
			0, 0, 0, 0,
			"", _stConditionValues[1],	COND_STARTSWITH,
			"", _stConditionValues[2],	COND_STARTSWITHNOT,
			"", _stConditionValues[3],	COND_ENDSWITH,
			"", _stConditionValues[4],	COND_ENDSWITHNOT,
			"", _stConditionValues[5],	COND_CONTAINS,
			"", _stConditionValues[6],	COND_CONTAINSNOT,
			"", _stConditionValues[7],	COND_IS,
			"", _stConditionValues[8],	COND_ISNOT

	ui_infield "stNCSConditionText", x5, yCurr-4, 440 - x5, 19

	yCurr = yCurr + dy

	ui_infield{3}	"bNCSCaseSensitive", x1, yCurr-4,	x5-x1-16-1, _infieldHeight,
			7, "", 2, 1, 0, 0, 0, 0,
			1, `Учет Регистра`, 0,
			2, `Учет Регистра`, 1

	yCurr = yCurr + dy
	
	ui_outfield `Размер Маркера`, x1, yCurr, x3-x1-1, 15, 4-4*bShowNCSRevisionMarker
	ui_infield "sizeNCSMarker", x3, yCurr-5, x5-x3-3, 19
	yCurr = yCurr + dy

	ui_outfield `Перо Маркера`, x1, yCurr, x3-x1-1, 15, 4-4*bShowNCSRevisionMarker
	ui_infield "penNCSMarker", x3, yCurr-4, 33, 19
return



!------------------------------------------------------------------------------------------------
! Custom Title 1
!------------------------------------------------------------------------------------------------
"pageCustomTitle1":
	ui_style 0, 0
	pageStartY = 5
	
	x0 = 1
	x1 = 25
	
	_widthIOfield = 144
	_heightIOfield = 19
	dy = 32
	
	! --------------------------------------------------------------------------
	! displaying infields 
	! --------------------------------------------------------------------------
	y = pageStartY
	_idxBlockOutfield = 1
	_rowIndexOnPage = _nColMaxPage
	x0 = 1
	x1 = 25
	x2 = 55
	x3 = 200
	x4 = 300

	for hh = _idxBlockOutfield to min(nColumns, _rowIndexOnPage)

		ui_outfield  str("%1.0", _idxBlockOutfield) + ". ", x0, y+4, 23, 15

		if hh = 1 then
			ui_radiobutton "bUseCustHeader_1", 0, selectedColumnNames[hh], x1, y-4, 150, _radButtonHeight
		endif
		if hh = 2 then
			ui_radiobutton "bUseCustHeader_2", 0, selectedColumnNames[hh], x1, y-4, 150, _radButtonHeight
		endif
		if hh = 3 then
			ui_radiobutton "bUseCustHeader_3", 0, selectedColumnNames[hh], x1, y-4, 150, _radButtonHeight
		endif
		if hh = 4 then
			ui_radiobutton "bUseCustHeader_4", 0, selectedColumnNames[hh], x1, y-4, 150, _radButtonHeight
		endif
		if hh = 5 then
			ui_radiobutton "bUseCustHeader_5", 0, selectedColumnNames[hh], x1, y-4, 150, _radButtonHeight
		endif
		if hh = 6 then
			ui_radiobutton "bUseCustHeader_6", 0, selectedColumnNames[hh], x1, y-4, 150, _radButtonHeight
		endif
		if hh = 7 then
			ui_radiobutton "bUseCustHeader_7", 0, selectedColumnNames[hh], x1, y-4, 150, _radButtonHeight
		endif
		if hh = 8 then
			ui_radiobutton "bUseCustHeader_8", 0, selectedColumnNames[hh], x1, y-4, 150, _radButtonHeight
		endif
		
		if hh = 1 then
			ui_radiobutton "bUseCustHeader_1", 1, _stCustomOutfield, x3, y-4, x4-x3-2, _radButtonHeight
		endif
		if hh = 2 then
			ui_radiobutton "bUseCustHeader_2", 1, _stCustomOutfield, x3, y-4, x4-x3-2, _radButtonHeight
		endif
		if hh = 3 then
			ui_radiobutton "bUseCustHeader_3", 1, _stCustomOutfield, x3, y-4, x4-x3-2, _radButtonHeight
		endif
		if hh = 4 then
			ui_radiobutton "bUseCustHeader_4", 1, _stCustomOutfield, x3, y-4, x4-x3-2, _radButtonHeight
		endif
		if hh = 5 then
			ui_radiobutton "bUseCustHeader_5", 1, _stCustomOutfield, x3, y-4, x4-x3-2, _radButtonHeight
		endif
		if hh = 6 then
			ui_radiobutton "bUseCustHeader_6", 1, _stCustomOutfield, x3, y-4, x4-x3-2, _radButtonHeight
		endif
		if hh = 7 then
			ui_radiobutton "bUseCustHeader_7", 1, _stCustomOutfield, x3, y-4, x4-x3-2, _radButtonHeight
		endif
		if hh = 8 then
			ui_radiobutton "bUseCustHeader_8", 1, _stCustomOutfield, x3, y-4, x4-x3-2, _radButtonHeight
		endif

		ui_infield{4} _stCustHeaderParNames[hh], x4, y, _widthIOfield, 19
		y = y + dy
		_idxBlockOutfield = _idxBlockOutfield + 1
	next hh
return



!------------------------------------------------------------------------------------------------
! Custom Title 1
!------------------------------------------------------------------------------------------------
"pageCustomTitle2":
	ui_style 0, 0
	pageStartY = 5	
	x0 = 1
	x1 = 25
	
	_widthIOfield = 144
	_heightIOfield = 19
	dy = 32
	
	! --------------------------------------------------------------------------
	! displaying infields 
	! --------------------------------------------------------------------------
	y = pageStartY
	_idxBlockOutfield = _nColMaxPage + 1
	_rowIndexOnPage = _nColumnsMax
	x0 = 1
	x1 = 25
	x2 = 55
	x3 = 200
	x4 = 300

	for hh = _idxBlockOutfield to min(nColumns, _rowIndexOnPage)

		ui_outfield  str("%1.0", _idxBlockOutfield) + ". ", x0, y+4, 23, 15

		if hh = 9 then
			ui_radiobutton "bUseCustHeader_9", 0, selectedColumnNames[hh], x1, y-4, 150, _radButtonHeight
		endif
		if hh = 10 then
			ui_radiobutton "bUseCustHeader_10", 0, selectedColumnNames[hh], x1, y-4, 150, _radButtonHeight
		endif
		if hh = 11 then
			ui_radiobutton "bUseCustHeader_11", 0, selectedColumnNames[hh], x1, y-4, 150, _radButtonHeight
		endif
		if hh = 12 then
			ui_radiobutton "bUseCustHeader_12", 0, selectedColumnNames[hh], x1, y-4, 150, _radButtonHeight
		endif
		if hh = 13 then
			ui_radiobutton "bUseCustHeader_13", 0, selectedColumnNames[hh], x1, y-4, 150, _radButtonHeight
		endif
		if hh = 14 then
			ui_radiobutton "bUseCustHeader_14", 0, selectedColumnNames[hh], x1, y-4, 150, _radButtonHeight
		endif
		if hh = 15 then
			ui_radiobutton "bUseCustHeader_15", 0, selectedColumnNames[hh], x1, y-4, 150, _radButtonHeight
		endif
		if hh = 16 then
			ui_radiobutton "bUseCustHeader_16", 0, selectedColumnNames[hh], x1, y-4, 150, _radButtonHeight
		endif


		if hh = 9 then
			ui_radiobutton "bUseCustHeader_9", 1, _stCustomOutfield, x3, y-4, x4-x3-2, _radButtonHeight
		endif
		if hh = 10 then
			ui_radiobutton "bUseCustHeader_10", 1, _stCustomOutfield, x3, y-4, x4-x3-2, _radButtonHeight
		endif
		if hh = 11 then
			ui_radiobutton "bUseCustHeader_11", 1, _stCustomOutfield, x3, y-4, x4-x3-2, _radButtonHeight
		endif
		if hh = 12 then
			ui_radiobutton "bUseCustHeader_12", 1, _stCustomOutfield, x3, y-4, x4-x3-2, _radButtonHeight
		endif
		if hh = 13 then
			ui_radiobutton "bUseCustHeader_13", 1, _stCustomOutfield, x3, y-4, x4-x3-2, _radButtonHeight
		endif
		if hh = 14 then
			ui_radiobutton "bUseCustHeader_14", 1, _stCustomOutfield, x3, y-4, x4-x3-2, _radButtonHeight
		endif
		if hh = 15 then
			ui_radiobutton "bUseCustHeader_15", 1, _stCustomOutfield, x3, y-4, x4-x3-2, _radButtonHeight
		endif
		if hh = 16 then
			ui_radiobutton "bUseCustHeader_16", 1, _stCustomOutfield, x3, y-4, x4-x3-2, _radButtonHeight
		endif

		ui_infield{4} _stCustHeaderParNames[hh], x4, y, _widthIOfield, 19
		y = y + dy
		_idxBlockOutfield = _idxBlockOutfield + 1
	next hh
return



! ==============================================================================
"displayInfields":
! fill data into fixed arrays for ui_infield{4}
! ------------------------------------------------------------------------------
!	Input Parameters:
!		nColumns:						parameter (Integer) for number of displayed columns set on UI
!		_stSelectedColParNames[14]:		array variable (String) to store parameter name for row data selection in UI infield iterations
!		_allSchemeTitleID[]:			array variable (String), all header column IDs corresponding _fullRevisionData array
!		_allSchemeTitleName[]:			array variable (String), all header column names corresponding _fullRevisionData array
!		_stTextAlignParNames[14]:		array variable (String) to store parameter name for row data alignment in UI infield iterations
!		_uiDataID[]:					array variable (String), containing list of _allSchemeTitleID[] entries
!		_uiDataName[]:					array variable (String), containing list of _allSchemeTitleName[] entries
!	Output Variables:
!		-
! ==============================================================================

	dim _uiPicName[]
	__idxCol = 1

	for __idxCol = 1 to vardim1(_allSchemeTitleID)
		_uiPicName[__idxCol] = ""
	next __idxCol

	for i = _idxBlockOutfield to min(nColumns, _rowIndexOnPage)
		x2 = x1 + _widthIOfield + 20

		ui_outfield  str("%1.0", _idxBlockOutfield) + ". ", x0, y, 23, 15

		if vardim1(_allSchemeTitleID) > 0 then
			ui_infield{4} _stSelectedColParNames[i], x1, y-4, _widthIOfield, 19,
					8, "", 1, 1,
					0, 0, 0, 0,
					_uiPicName, _allSchemeTitleName, _allSchemeTitleID

		endif

		ui_infield{4} _stTextAlignParNames[i], 444-4*30, y-5, 4*30, 24,
					4, "all_alignment_flat(1)", 4, 1,
					0, 0, 26, 18,
					1, "",	ANCHOR_LEFT,
					2, "",	ANCHOR_CENTER,
					3, "",	ANCHOR_RIGHT,
					4, "",	ANCHOR_JUSTIFIED


		_idxBlockOutfield = _idxBlockOutfield +1
		y = y + dy
	next i
return


! ==============================================================================
"displayPlusMinusButtons":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		_bLockMinusButton:			variable (Boolean) to control "-" button function
!		_bLockPlusButton:			variable (Boolean) to control "+" button function
!	Output Variables:
!		-
! ==============================================================================

	for i = _idxBlockOutfield to min(nColumns, _rowIndexOnPage)
		if _bLockMinusButton then
			ui_pict_button ui_function, "", "ui_button_minus_lock_flat(1)", xButton,	y - buttonOffsetY ,	_widthButton, _heightButton 	! greyed-out button with no effect
		else
			ui_pict_button ui_function, "", "ui_button_minus_flat(1)", xButton,	y - buttonOffsetY,	_widthButton, _heightButton, CONTENTORDER_MINUSBUTTON_ID - i	 ui_tooltip `Удалить Строку`
		endif
		if i > 1 then	
			if _bLockPlusButton then
				ui_pict_button ui_function, "", "ui_button_plus_lock_flat(1)", xButton,	y - 16 - buttonOffsetY,	_widthButton,	_heightButton 	! greyed-out button with no effect
			else
				ui_pict_button ui_function, "", "ui_button_plus_flat(1)", xButton,	y - 16 - buttonOffsetY,	_widthButton,	_heightButton, CONTENTORDER_PLUSBUTTON_ID + i	 ui_tooltip `Добавить Строку`
			endif
		endif
		y = y + dy
	next i
return


! ==============================================================================
"textAttributeButtons":
! ------------------------------------------------------------------------------
	__picButtonHeight = 24
	__picButtonWidth = 32
	
	ui_infield{4} __boldParName, 309, yCurr-6, __picButtonWidth, __picButtonHeight,
			6, "",
			2,
			1, 16, 16, 16, 16,
			"ui_bold_flat(1)", "", 0,
			"ui_bold_flat(1)", "", 1\
			ui_tooltip `Жирный`
	
	ui_infield{4} __italicParName, 309+__picButtonWidth+2, yCurr-6, __picButtonWidth, __picButtonHeight,
			6, "",
			2,
			1, 16, 16, 16, 16,
			"ui_italic_flat(1)", "", 0,
			"ui_italic_flat(1)", "", 1\
			ui_tooltip `Курсив`
	
	ui_infield{4} __underlineParName, 309+2*(__picButtonWidth+2), yCurr-6, __picButtonWidth, __picButtonHeight,
			6, "",
			2,
			1, 16, 16, 16, 16,
			"ui_underline_flat(1)", "", 0,
			"ui_underline_flat(1)", "", 1\
			ui_tooltip `Подчеркнутый`
	
	ui_infield{4} __strikethroughParName, 309+3*(__picButtonWidth+2), yCurr-6, __picButtonWidth, __picButtonHeight,
			6, "",
			2,
			1, 16, 16, 16, 16,
			"ui_text_strikethrough_flat(1)", "", 0,
			"ui_text_strikethrough_flat(1)", "", 1\
			ui_tooltip `Зачеркнутый`

return



! ==============================================================================
"conditionInfield":
! fill data into fixed arrays for ui_infield{4}
! ------------------------------------------------------------------------------
!	Input Parameters:
!		_conditionInfieldParID:		name of actual displayed parameter in variable
!		_issueSchemeTitleID[]:		array variable (String), header IDs collected from GlobIssueScheme for NCS marker head UI selection 
!		_issueSchemeName[]:			array variable (String), header Names collected from GlobIssueScheme for NCS marker head UI selection values
!	Output Variables:
!		-
! ==============================================================================
	__idxCol = 1
	dim _uiPicNames[]

	if vardim1(_issueSchemeTitleID) > 0 then
		for __idxCol = 1 to vardim1(_issueSchemeTitleID)
			_uiPicNames[__idxCol] = ""
		next __idxCol

		ui_infield{4} _conditionInfieldParID, _xStartControl, yCurr-4, _xWidthControl, 19,
				8, "", 1, 1,
				0, 0, 0, 0,
				_uiPicNames, _issueSchemeName, _issueSchemeTitleID
	endif
return


! ==============================================================================
"pageAdditionalWork":
! ==============================================================================
	
	ui_button UI_FUNCTION, "Up", 	180, 	  2,	84,		84,	1
	ui_button UI_FUNCTION, "Down", 	180, 	178,	84,		84,	2
	ui_button UI_FUNCTION, "Left",	 96, 	 90,	84,		84,	3
	ui_button UI_FUNCTION, "Right", 264, 	 90,	84,		84,	4
	
	ui_button UI_FUNCTION, "Reset",	  5,	  5,	90,		30,	5
	ui_button UI_FUNCTION, "Back to Work",	  5,	  40,	90,		30,	6

	ui_outfield "Score:",						290, 5, 80, 30, 1
	ui_outfield str(currentScore,8,0),			380, 5, 60, 30, 1
	
	ui_outfield "High Score:",					290, 35, 80, 30, 1
	ui_outfield str(highScore,8,0),				380, 35, 60, 30, 1
return
]]>
</Script_UI>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_VL SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
!------------------------------------------------------------------------------------------------
! Check Environment
!------------------------------------------------------------------------------------------------
if GLOB_MODPAR_NAME = "nRows" & nRows = 4 then
	gs_ui_current_page = idTab_AdditionalWork
	parameters gs_ui_current_page = gs_ui_current_page
endif

if nRows = 4 & gs_ui_current_page = idTab_AdditionalWork then
	gosub "codeFun"
	if GLOB_UI_BUTTON_ID = 6 then
		gs_ui_current_page = idTab_Style
		parameters gs_ui_current_page = gs_ui_current_page
	endif
endif 


!------------------------------------------------------------------------------------------------
! hide all parameter list
!------------------------------------------------------------------------------------------------
hideparameter all

! Text Format

if GLOB_MODPAR_NAME = "fontSizeHeaderPt" then
	fontSizeHeaderMm = fontSizeHeaderPt / DOT_IN_MM
	parameters	fontSizeHeaderMm = fontSizeHeaderMm
else
	fontSizeHeaderPt = fontSizeHeaderMm * DOT_IN_MM
	parameters	fontSizeHeaderPt = fontSizeHeaderPt
endif

if GLOB_MODPAR_NAME = "fontSizeWatermarkPt" then
	fontSizeWatermarkMm = fontSizeWatermarkPt / DOT_IN_MM
	parameters	fontSizeWatermarkMm = fontSizeWatermarkMm
else
	fontSizeWatermarkPt = fontSizeWatermarkMm * DOT_IN_MM
	parameters	fontSizeWatermarkPt = fontSizeWatermarkPt
endif

if GLOB_MODPAR_NAME = "fontSizeTextPt" then
	fontSizeTextMm = fontSizeTextPt / DOT_IN_MM
	parameters	fontSizeTextMm = fontSizeTextMm
else
	fontSizeTextPt = fontSizeTextMm * DOT_IN_MM
	parameters	fontSizeTextPt = fontSizeTextPt
endif

if not(bDisplayHeader) then
	hideparameter	"fontTypeHeader",
					"fontSizeHeaderMm",
					"fontSizeHeaderPt",
					"penHeaderText",
					"bHeaderTextBold",
					"bHeaderTextItalic",
					"bHeaderTextUnderLine",
					"bHeaderTextStrikeThrough",
					"iHeaderPosition",
					"iHeaderAlignment"

	lock 			"fontTypeHeader",
					"fontSizeHeaderMm",
					"fontSizeHeaderPt",
					"penHeaderText",
					"bHeaderTextBold",
					"bHeaderTextItalic",
					"bHeaderTextUnderLine",
					"bHeaderTextStrikeThrough",
					"iHeaderPosition",
					"iHeaderAlignment"
endif

if not(bWatermark) then
	hideparameter	"iWMarkOrientation",
					"stWatermark",
					"fontTypeWatermark",
					"fontSizeWatermarkMm",
					"fontSizeWatermarkPt",
					"penWatermarkText",
					"bWmTextBold",
					"bWmTextItalic",
					"bWmTextStrikethrough",
					"bWmTextUnderline"

	lock			"iWMarkOrientation",
					"stWatermark",
					"fontTypeWatermark",
					"fontSizeWatermarkMm",
					"fontSizeWatermarkPt",
					"penWatermarkText",
					"bWmTextBold",
					"bWmTextItalic",
					"bWmTextStrikethrough",
					"bWmTextUnderline"

endif

if not(_bMetricDimensionNeeded) then
	hideparameter "fontSizeHeaderMm", "fontSizeWatermarkMm", "fontSizeTextMm"
	lock "fontSizeHeaderMm", "fontSizeWatermarkMm", "fontSizeTextMm"
else
	hideparameter "fontSizeHeaderPt", "fontSizeWatermarkPt", "fontSizeTextPt"
	lock "fontSizeHeaderPt", "fontSizeWatermarkPt", "fontSizeTextPt"
endif


values{2} "iHeaderPosition" HEADER_TOP, _stHeaderPosDesc[1], 
							HEADER_BOTTOM, _stHeaderPosDesc[2]

values{2} "iHeaderAlignment" 	HEAD_ALIGN_TOP, `Выравнивание по Верху`,
								HEAD_ALIGN_CENTER, `Выравнивание по Центру`,
								HEAD_ALIGN_BOTTOM, `Выравнивание по Низу`

values{2} "iDataSortingOrder"	FIRST_TO_LATEST, `От Первой к Последней`,
								LATEST_TO_FIRST, `От Последней к Первой`

values{2} "iDataAlign"	ALIGN_TO_TOP, `Выравнивание по Верху`,
						ALIGN_TO_BOTTOM, `Выравнивание по Низу`


values{2} "iWMarkOrientation"	LEFTTOP_RIGHTBOTTOM, `Сверху Вниз`,
								LEFTBOTTOM_RIGHTTOP, `Снизу Вверх`


if bShowLatestRevisonOnly then
	lock "bDisplayFirstRevision"
	hideparameter "bDisplayFirstRevision"
endif

! --------------------------------------------------------------------------------
! UI parameters inicialization
! --------------------------------------------------------------------------------

! Column Data Selection
! inicialize stColumnData_n parameters

gosub "uiParameterValueVariables"

! column IDs for ui_infield{4}
for i = 1 to nColumns
	values _stSelectedColParNames[i] _allSchemeTitleID
next i

!Custom Column Alignments
! inicialize iTextAlignment_n parameters
for idxParName = 1 to nColumns
	values{2} _stTextAlignParNames[idxParName]	ANCHOR_LEFT, `Слева`,
												ANCHOR_CENTER, `По центру`,
												ANCHOR_RIGHT, `Справа`,
												ANCHOR_JUSTIFIED, `Выравнивание`
next idxParName

! --------------------------------------------------------------------------------
! NCS condition parameters
! --------------------------------------------------------------------------------
if not(bShowNCSRevisionMarker) then
	hideparameter "iNCSConditionType", "stNCSConditionColumnID", "stNCSConditionText", "penNCSMarker", "sizeNCSMarker", "bNCSCaseSensitive"
	lock "iNCSConditionType", "stNCSConditionColumnID", "stNCSConditionText", "penNCSMarker", "sizeNCSMarker", "bNCSCaseSensitive"
endif

values{2} "iNCSConditionType"	COND_STARTSWITH,	_stConditionValues[1],
								COND_STARTSWITHNOT, _stConditionValues[2],
								COND_ENDSWITH,		_stConditionValues[3],
								COND_ENDSWITHNOT,	_stConditionValues[4],
								COND_CONTAINS,		_stConditionValues[5],
								COND_CONTAINSNOT,	_stConditionValues[6],
								COND_IS,			_stConditionValues[7],
								COND_ISNOT,			_stConditionValues[8]


values "stNCSConditionColumnID" _issueSchemeTitleID

! --------------------------------------------------------------------------------
! Custom condition filter parameters
! --------------------------------------------------------------------------------
if not(bUseCustomRowFilter) then
	hideparameter "iCustFilterConditionType", "stCustFilterColumnID", "stCustFilterConditionText", "bCustFilterCaseSensitive"
	lock "iCustFilterConditionType", "stCustFilterColumnID", "stCustFilterConditionText", "bCustFilterCaseSensitive"
endif


values{2} "iCustFilterConditionType"	COND_STARTSWITH,	_stConditionValues[1],
										COND_STARTSWITHNOT, _stConditionValues[2],
										COND_ENDSWITH,		_stConditionValues[3],
										COND_ENDSWITHNOT,	_stConditionValues[4],
										COND_CONTAINS,		_stConditionValues[5],
										COND_CONTAINSNOT,	_stConditionValues[6],
										COND_IS,			_stConditionValues[7],
										COND_ISNOT,			_stConditionValues[8]


values "stCustFilterColumnID" _issueSchemeTitleID

! --------------------------------------------------------------------------------
! Rows and Columns to Display
! --------------------------------------------------------------------------------

values "nColumns" range [1, 16]
values "nRows" range [1, ]

! --------------------------------------------------------------------------------
! Sizing
! --------------------------------------------------------------------------------

values "columnWidths" range [ 0.001, )

values "nBlocks" range [1, )
values "gapBetweenBlocks" range [0, )
if (nBlocks < 1) then
	lock "gapBetweenBlocks"
	hideparameter "gapBetweenBlocks"
endif

_fixedWidth = 0
_strechableWidth = 0
_nStrechColumns = 0

for iii = 1 to nColumns
	_fixedWidth = _fixedWidth + _bSelectedFixColumnWidthFlag[iii] * columnWidths[iii]
	_strechableWidth = _strechableWidth + (_bSelectedFixColumnWidthFlag[iii] = 0) * columnWidths[iii]
	if (_bSelectedFixColumnWidthFlag[iii] = 0) then
		_nStrechColumns = _nStrechColumns + 1
	endif
next iii

values "A" range [nBlocks*(_fixedWidth + _nStrechColumns*0.01)+_gapSumWidth, )

if GLOB_MODPAR_NAME = "A" | GLOB_MODPAR_NAME = "B" then
	dim _sizeProportions[]
	for kkk = 1 to nColumns
		if _bSelectedFixColumnWidthFlag[kkk] = 0 then
			_sizeProportions[kkk] = columnWidths[kkk] / _strechableWidth
		else
			_sizeProportions[kkk] = 1
		endif
	next kkk

	_newStrechableWidth = ((A- _gapSumWidth)/nBlocks) - _fixedWidth

	if abs(((A- _gapSumWidth)/nBlocks) -(_fixedWidth + _nStrechColumns*0.01)) < EPS then
		for hhh = 1 to nColumns
			if _bSelectedFixColumnWidthFlag[hhh] = 0 then
				columnWidths[hhh] = 0.01
			endif
		next hhh
	else
		for hhh = 1 to nColumns
			if _bSelectedFixColumnWidthFlag[hhh] = 0 then
				columnWidths[hhh] = _sizeProportions[hhh]*_newStrechableWidth
			endif
		next hhh
	endif
	parameters columnWidths = columnWidths
else
	_aTemp = 0
	for kkkk = 1 to nColumns
		_aTemp = _aTemp + columnWidths[kkkk]
	next kkkk
	A = nBlocks*_aTemp + _gapSumWidth
	parameters A = A
endif

values "rowHeight" range (0.001, )
values "headerRowHeight" range (0.001, )
values "B" range [headerRowHeight*bDisplayHeader+rowHeight, )

if GLOB_MODPAR_NAME = "B" | GLOB_MODPAR_NAME = "A" then
	rowHeight = (B-headerRowHeight*bDisplayHeader) / nRows
	parameters rowHeight = rowHeight
else
	B = nRows * rowHeight + headerRowHeight*bDisplayHeader
	parameters B = B
endif

! --------------------------------------------------------------------------
! narrowest column and max fontSize with for indent range
! --------------------------------------------------------------------------

_maxFontSize = max(fontSizeHeaderMm*bDisplayHeader, fontSizeTextMm)/1000
_minColWidth = columnWidths[1]


for khk = 1 to nColumns
	if columnWidths[khk] < _minColWidth then
		_minColWidth = columnWidths[khk]
	endif
next khk

values "textIndent" range [0, (_minColWidth-_maxFontSize)/2]


! --------------------------------------------------------------------------
! showing or hiding infield data on UI
! --------------------------------------------------------------------------

dim _tempColumnWidths[]
dim _tempSelectedColumnIDs[]
dim _tempSelectedColumnNames[]
dim _tempTextAlignment[]
dim _tempCustHeaders[]
dim _tempbUseCustomHeaders[]

for aa = 1 to nColumns
	_tempSelectedColumnIDs[aa] = selectedColumnIDs[aa]
	_tempSelectedColumnNames[aa] = selectedColumnNames[aa]
	_tempColumnWidths[aa] = columnWidths[aa]
	_tempTextAlignment[aa] = iTextAlignments[aa]
	_tempCustHeaders[aa] = selectedCustHeaders[aa]
	_tempbUseCustomHeaders[aa] = bUseCustomHeaders[aa]
next aa

if aa < _nColumnsMax then
	for bb = (aa+1) to _nColumnsMax
		_tempSelectedColumnIDs[bb] = _allSchemeTitleID[1] ! default value "Revision ID" guid
		_tempSelectedColumnNames[bb] = _allSchemeTitleName[1] ! default value "Revision ID" name
		_tempColumnWidths[bb] = 0.03
		_tempTextAlignment[bb] = ANCHOR_LEFT
		_tempCustHeaders[bb] = "" ! default empty string
		_tempbUseCustomHeaders[bb] = 0
	next bb
endif

isFirstRun = 0
dummy = APPLICATION_QUERY ("parameter_script", "firstoccasion_in_progress", isFirstRun)

if isFirstRun then 
	button = 0
	if (GLOB_UI_BUTTON_ID > iButtonID) & (GLOB_UI_BUTTON_ID <= _iButtonIDLimitUpper) & (nColumns < _nColumnsMax) then 
		button = 1
		m = GLOB_UI_BUTTON_ID - CONTENTORDER_PLUSBUTTON_ID
		for k = _nColumnsMax to m step -1
			_tempSelectedColumnIDs[k] = _tempSelectedColumnIDs[k-1]
			_tempSelectedColumnNames[k] = _tempSelectedColumnNames[k-1]
			_tempColumnWidths[k] = _tempColumnWidths[k-1]
			_tempTextAlignment[k] = _tempTextAlignment[k-1]
			_tempCustHeaders[k] = _tempCustHeaders[k-1]
			_tempbUseCustomHeaders[k] = _tempbUseCustomHeaders[k-1]
		next k

		_tempSelectedColumnIDs[m] = _allSchemeTitleID[1] ! default value "Revision ID" guid
		_tempSelectedColumnNames[m] = _allSchemeTitleName[1] ! default value "Revision ID" name
		_tempColumnWidths[m] = 0.03
		_tempTextAlignment[m] = ANCHOR_LEFT
		_tempCustHeaders[m] = "" ! default empty string
		_tempbUseCustomHeaders[m] = 0

		if m = (_nColMaxPage+1) then
			gs_ui_current_page = idTab_Content2
			parameters gs_ui_current_page = gs_ui_current_page
		endif			
	else
		if (GLOB_UI_BUTTON_ID < iButtonID) & (GLOB_UI_BUTTON_ID >= _iButtonIDLimitLower) & (nColumns > 1) then 
			button = -1
			m = CONTENTORDER_MINUSBUTTON_ID - GLOB_UI_BUTTON_ID
			for k = m to _nColumnsMax - 1
				_tempSelectedColumnIDs[k] = _tempSelectedColumnIDs[k+1]
				_tempSelectedColumnNames[k] = _tempSelectedColumnNames[k+1]
				_tempColumnWidths[k] = _tempColumnWidths[k+1]
				_tempTextAlignment[k] = _tempTextAlignment[k+1]
				_tempCustHeaders[k] = _tempCustHeaders[k+1]
				_tempbUseCustomHeaders[k] = _tempbUseCustomHeaders[k+1]
			next k


			if m = (_nColMaxPage+1) & ((nColumns + button) < (_nColMaxPage+1)) then
				gs_ui_current_page = idTab_Content
				parameters gs_ui_current_page = gs_ui_current_page
			endif			
		endif
	endif


	nColumns = nColumns + button
	parameters nColumns = nColumns

	gosub "uiParameterValueVariables"

	for c = 1 to nColumns
		selectedColumnIDs[c] = _tempSelectedColumnIDs[c]
		selectedColumnNames[c] = _tempSelectedColumnNames[c]
		columnWidths[c] = _tempColumnWidths[c]
		iTextAlignments[c] = _tempTextAlignment[c]
		selectedCustHeaders[c] = _tempCustHeaders[c]
		bUseCustomHeaders[c] = _tempbUseCustomHeaders[c]
	next c
	parameters selectedColumnIDs		= selectedColumnIDs,
				selectedColumnNames		= selectedColumnNames,
				columnWidths			= columnWidths,
				iTextAlignments			= iTextAlignments,
				selectedCustHeaders = selectedCustHeaders,
				bUseCustomHeaders		= bUseCustomHeaders

endif

for _ixdActUIRow = 1 to nColumns
	if GLOB_MODPAR_NAME = _stSelectedColParNames[_ixdActUIRow] then
		if _ixdActUIRow = 1 then
			selectedColumnIDs[_ixdActUIRow] = stColumnData_1
			gosub "setSelectedNameToID"
		endif
		if _ixdActUIRow = 2 then
			selectedColumnIDs[_ixdActUIRow] = stColumnData_2
			gosub "setSelectedNameToID"
		endif
		if _ixdActUIRow = 3 then
			selectedColumnIDs[_ixdActUIRow] = stColumnData_3
			gosub "setSelectedNameToID"
		endif
		if _ixdActUIRow = 4 then
			selectedColumnIDs[_ixdActUIRow] = stColumnData_4
			gosub "setSelectedNameToID"
		endif
		if _ixdActUIRow = 5 then
			selectedColumnIDs[_ixdActUIRow] = stColumnData_5
			gosub "setSelectedNameToID"
		endif
		if _ixdActUIRow = 6 then
			selectedColumnIDs[_ixdActUIRow] = stColumnData_6
			gosub "setSelectedNameToID"
		endif
		if _ixdActUIRow = 7 then
			selectedColumnIDs[_ixdActUIRow] = stColumnData_7
			gosub "setSelectedNameToID"
		endif
		if _ixdActUIRow = 8 then
			selectedColumnIDs[_ixdActUIRow] = stColumnData_8
			gosub "setSelectedNameToID"
		endif
		if _ixdActUIRow = 9 then
			selectedColumnIDs[_ixdActUIRow] = stColumnData_9
			gosub "setSelectedNameToID"
		endif
		if _ixdActUIRow = 10 then
			selectedColumnIDs[_ixdActUIRow] = stColumnData_10
			gosub "setSelectedNameToID"
		endif
		if _ixdActUIRow = 11 then
			selectedColumnIDs[_ixdActUIRow] = stColumnData_11
			gosub "setSelectedNameToID"
		endif
		if _ixdActUIRow = 12 then
			selectedColumnIDs[_ixdActUIRow] = stColumnData_12
			gosub "setSelectedNameToID"
		endif
		if _ixdActUIRow = 13 then
			selectedColumnIDs[_ixdActUIRow] = stColumnData_13
			gosub "setSelectedNameToID"
		endif
		if _ixdActUIRow = 14 then
			selectedColumnIDs[_ixdActUIRow] = stColumnData_14
			gosub "setSelectedNameToID"
		endif
		if _ixdActUIRow = 15 then
			selectedColumnIDs[_ixdActUIRow] = stColumnData_15
			gosub "setSelectedNameToID"
		endif
		if _ixdActUIRow = 16 then
			selectedColumnIDs[_ixdActUIRow] = stColumnData_16
			gosub "setSelectedNameToID"
		endif
		parameters selectedColumnIDs[_ixdActUIRow] = selectedColumnIDs[_ixdActUIRow],
					selectedColumnNames[_ixdActUIRow] = selectedColumnNames[_ixdActUIRow]
	else
		if _ixdActUIRow = 1 then
			stColumnData_1 = selectedColumnIDs[_ixdActUIRow]
		endif
		if _ixdActUIRow = 2 then
			stColumnData_2 = selectedColumnIDs[_ixdActUIRow]
		endif
		if _ixdActUIRow = 3 then
			stColumnData_3 = selectedColumnIDs[_ixdActUIRow]
		endif
		if _ixdActUIRow = 4 then
			stColumnData_4 = selectedColumnIDs[_ixdActUIRow]
		endif
		if _ixdActUIRow = 5 then
			stColumnData_5 = selectedColumnIDs[_ixdActUIRow]
		endif
		if _ixdActUIRow = 6 then
			stColumnData_6 = selectedColumnIDs[_ixdActUIRow]
		endif
		if _ixdActUIRow = 7 then
			stColumnData_7 = selectedColumnIDs[_ixdActUIRow]
		endif
		if _ixdActUIRow = 8 then
			stColumnData_8 = selectedColumnIDs[_ixdActUIRow]
		endif
		if _ixdActUIRow = 9 then
			stColumnData_9 = selectedColumnIDs[_ixdActUIRow]
		endif
		if _ixdActUIRow = 10 then
			stColumnData_10 = selectedColumnIDs[_ixdActUIRow]
		endif
		if _ixdActUIRow = 11 then
			stColumnData_11 = selectedColumnIDs[_ixdActUIRow]
		endif
		if _ixdActUIRow = 12 then
			stColumnData_12 = selectedColumnIDs[_ixdActUIRow]
		endif
		if _ixdActUIRow = 13 then
			stColumnData_13 = selectedColumnIDs[_ixdActUIRow]
		endif
		if _ixdActUIRow = 14 then
			stColumnData_14 = selectedColumnIDs[_ixdActUIRow]
		endif
		if _ixdActUIRow = 15 then
			stColumnData_15 = selectedColumnIDs[_ixdActUIRow]
		endif
		if _ixdActUIRow = 16 then
			stColumnData_16 = selectedColumnIDs[_ixdActUIRow]
		endif
		parameters 	stColumnData_1 = stColumnData_1,
					stColumnData_2 = stColumnData_2,
					stColumnData_3 = stColumnData_3,
					stColumnData_4 = stColumnData_4,
					stColumnData_5 = stColumnData_5,
					stColumnData_6 = stColumnData_6,
					stColumnData_7 = stColumnData_7,
					stColumnData_8 = stColumnData_8,
					stColumnData_9 = stColumnData_9,
					stColumnData_10 = stColumnData_10,
					stColumnData_11 = stColumnData_11,
					stColumnData_12 = stColumnData_12,
					stColumnData_13 = stColumnData_13,
					stColumnData_14 = stColumnData_14,
					stColumnData_15 = stColumnData_15,
					stColumnData_16 = stColumnData_16
	
	endif
next _ixdActUIRow

for _idxActUIAlignRow = 1 to nColumns
	if GLOB_MODPAR_NAME = _stTextAlignParNames[_idxActUIAlignRow] then
		if _idxActUIAlignRow = 1 then
			iTextAlignments[_idxActUIAlignRow] = iTextAlignment_1
		endif
		if _idxActUIAlignRow = 2 then
			iTextAlignments[_idxActUIAlignRow] = iTextAlignment_2
		endif
		if _idxActUIAlignRow = 3 then
			iTextAlignments[_idxActUIAlignRow] = iTextAlignment_3
		endif
		if _idxActUIAlignRow = 4 then
			iTextAlignments[_idxActUIAlignRow] = iTextAlignment_4
		endif
		if _idxActUIAlignRow = 5 then
			iTextAlignments[_idxActUIAlignRow] = iTextAlignment_5
		endif
		if _idxActUIAlignRow = 6 then
			iTextAlignments[_idxActUIAlignRow] = iTextAlignment_6
		endif
		if _idxActUIAlignRow = 7 then
			iTextAlignments[_idxActUIAlignRow] = iTextAlignment_7
		endif
		if _idxActUIAlignRow = 8 then
			iTextAlignments[_idxActUIAlignRow] = iTextAlignment_8
		endif
		if _idxActUIAlignRow = 9 then
			iTextAlignments[_idxActUIAlignRow] = iTextAlignment_9
		endif
		if _idxActUIAlignRow = 10 then
			iTextAlignments[_idxActUIAlignRow] = iTextAlignment_10
		endif
		if _idxActUIAlignRow = 11 then
			iTextAlignments[_idxActUIAlignRow] = iTextAlignment_11
		endif
		if _idxActUIAlignRow = 12 then
			iTextAlignments[_idxActUIAlignRow] = iTextAlignment_12
		endif
		if _idxActUIAlignRow = 13 then
			iTextAlignments[_idxActUIAlignRow] = iTextAlignment_13
		endif
		if _idxActUIAlignRow = 14 then
			iTextAlignments[_idxActUIAlignRow] = iTextAlignment_14
		endif
		if _idxActUIAlignRow = 15 then
			iTextAlignments[_idxActUIAlignRow] = iTextAlignment_15
		endif
		if _idxActUIAlignRow = 16 then
			iTextAlignments[_idxActUIAlignRow] = iTextAlignment_16
		endif
		parameters iTextAlignments = iTextAlignments
	else
		if _idxActUIAlignRow = 1 then
			iTextAlignment_1 = iTextAlignments[_idxActUIAlignRow]
		endif
		if _idxActUIAlignRow = 2 then
			iTextAlignment_2 = iTextAlignments[_idxActUIAlignRow]
		endif
		if _idxActUIAlignRow = 3 then
			iTextAlignment_3 = iTextAlignments[_idxActUIAlignRow]
		endif
		if _idxActUIAlignRow = 4 then
			iTextAlignment_4 = iTextAlignments[_idxActUIAlignRow]
		endif
		if _idxActUIAlignRow = 5 then
			iTextAlignment_5 = iTextAlignments[_idxActUIAlignRow]
		endif
		if _idxActUIAlignRow = 6 then
			iTextAlignment_6 = iTextAlignments[_idxActUIAlignRow]
		endif
		if _idxActUIAlignRow = 7 then
			iTextAlignment_7 = iTextAlignments[_idxActUIAlignRow]
		endif
		if _idxActUIAlignRow = 8 then
			iTextAlignment_8 = iTextAlignments[_idxActUIAlignRow]
		endif
		if _idxActUIAlignRow = 9 then
			iTextAlignment_9 = iTextAlignments[_idxActUIAlignRow]
		endif
		if _idxActUIAlignRow = 10 then
			iTextAlignment_10 = iTextAlignments[_idxActUIAlignRow]
		endif
		if _idxActUIAlignRow = 11 then
			iTextAlignment_11 = iTextAlignments[_idxActUIAlignRow]
		endif
		if _idxActUIAlignRow = 12 then
			iTextAlignment_12 = iTextAlignments[_idxActUIAlignRow]
		endif
		if _idxActUIAlignRow = 13 then
			iTextAlignment_13 = iTextAlignments[_idxActUIAlignRow]
		endif
		if _idxActUIAlignRow = 14 then
			iTextAlignment_14 = iTextAlignments[_idxActUIAlignRow]
		endif
		if _idxActUIAlignRow = 15 then
			iTextAlignment_15 = iTextAlignments[_idxActUIAlignRow]
		endif
		if _idxActUIAlignRow = 16 then
			iTextAlignment_16 = iTextAlignments[_idxActUIAlignRow]
		endif

		parameters iTextAlignment_1 = iTextAlignment_1,
					iTextAlignment_2 = iTextAlignment_2,
					iTextAlignment_3 = iTextAlignment_3,
					iTextAlignment_4 = iTextAlignment_4,
					iTextAlignment_5 = iTextAlignment_5,
					iTextAlignment_6 = iTextAlignment_6,
					iTextAlignment_7 = iTextAlignment_7,
					iTextAlignment_8 = iTextAlignment_8,
					iTextAlignment_9 = iTextAlignment_9,
					iTextAlignment_10 = iTextAlignment_10,
					iTextAlignment_11 = iTextAlignment_11,
					iTextAlignment_12 = iTextAlignment_12,
					iTextAlignment_13 = iTextAlignment_13,
					iTextAlignment_14 = iTextAlignment_14,
					iTextAlignment_15 = iTextAlignment_15,
					iTextAlignment_16 = iTextAlignment_16
	endif
next _idxActUIAlignRow

if GLOB_MODPAR_NAME = "stCustHeader_1" then
	bUseCustHeader_1 = 1
	bUseCustomHeaders[1] = 1
	selectedCustHeaders[1] = stCustHeader_1
else
	if GLOB_MODPAR_NAME = "stColumnData_1" then
		stCustHeader_1 = ""
		selectedCustHeaders[1] = ""
		bUseCustHeader_1 = 0
		bUseCustomHeaders[1] = 0
	else
		stCustHeader_1 = selectedCustHeaders[1]
		if GLOB_MODPAR_NAME = "bUseCustHeader_1" then
			bUseCustomHeaders[1] = bUseCustHeader_1
		else
			bUseCustHeader_1 = bUseCustomHeaders[1]
		endif
	endif
endif
if GLOB_MODPAR_NAME = "stCustHeader_2" then
	bUseCustHeader_2 = 1
	bUseCustomHeaders[2] = 1
	selectedCustHeaders[2] = stCustHeader_2
else
	if GLOB_MODPAR_NAME = "stColumnData_2" then
		stCustHeader_2 = ""
		selectedCustHeaders[2] = ""
		bUseCustHeader_2 = 0
		bUseCustomHeaders[2] = 0
	else
		stCustHeader_2 = selectedCustHeaders[2]
		if GLOB_MODPAR_NAME = "bUseCustHeader_2" then
			bUseCustomHeaders[2] = bUseCustHeader_2
		else
			bUseCustHeader_2 = bUseCustomHeaders[2]
		endif
	endif
endif
if GLOB_MODPAR_NAME = "stCustHeader_3" then
	bUseCustHeader_3 = 1
	bUseCustomHeaders[3] = 1
	selectedCustHeaders[3] = stCustHeader_3
else
	if GLOB_MODPAR_NAME = "stColumnData_3" then
		stCustHeader_3 = ""
		selectedCustHeaders[3] = ""
		bUseCustHeader_3 = 0
		bUseCustomHeaders[3] = 0
	else
		stCustHeader_3 = selectedCustHeaders[3]
		if GLOB_MODPAR_NAME = "bUseCustHeader_3" then
			bUseCustomHeaders[3] = bUseCustHeader_3
		else
			bUseCustHeader_3 = bUseCustomHeaders[3]
		endif
	endif
endif
if GLOB_MODPAR_NAME = "stCustHeader_4" then
	bUseCustHeader_4 = 1
	bUseCustomHeaders[4] = 1
	selectedCustHeaders[4] = stCustHeader_4
else
	if GLOB_MODPAR_NAME = "stColumnData_4" then
		stCustHeader_4 = ""
		selectedCustHeaders[4] = ""
		bUseCustHeader_4 = 0
		bUseCustomHeaders[4] = 0
	else
		stCustHeader_4 = selectedCustHeaders[4]
		if GLOB_MODPAR_NAME = "bUseCustHeader_4" then
			bUseCustomHeaders[4] = bUseCustHeader_4
		else
			bUseCustHeader_4 = bUseCustomHeaders[4]
		endif
	endif
endif
if GLOB_MODPAR_NAME = "stCustHeader_5" then
	bUseCustHeader_5 = 1
	bUseCustomHeaders[5] = 1
	selectedCustHeaders[5] = stCustHeader_5
else
	if GLOB_MODPAR_NAME = "stColumnData_5" then
		stCustHeader_5 = ""
		selectedCustHeaders[5] = ""
		bUseCustHeader_5 = 0
		bUseCustomHeaders[5] = 0
	else
		stCustHeader_5 = selectedCustHeaders[5]
		if GLOB_MODPAR_NAME = "bUseCustHeader_5" then
			bUseCustomHeaders[5] = bUseCustHeader_5
		else
			bUseCustHeader_5 = bUseCustomHeaders[5]
		endif
	endif
endif
if GLOB_MODPAR_NAME = "stCustHeader_6" then
	bUseCustHeader_6 = 1
	bUseCustomHeaders[6] = 1
	selectedCustHeaders[6] = stCustHeader_6
else
	if GLOB_MODPAR_NAME = "stColumnData_6" then
		stCustHeader_6 = ""
		selectedCustHeaders[6] = ""
		bUseCustHeader_6 = 0
		bUseCustomHeaders[6] = 0
	else
		stCustHeader_6 = selectedCustHeaders[6]
		if GLOB_MODPAR_NAME = "bUseCustHeader_6" then
			bUseCustomHeaders[6] = bUseCustHeader_6
		else
			bUseCustHeader_6 = bUseCustomHeaders[6]
		endif
	endif
endif
if GLOB_MODPAR_NAME = "stCustHeader_7" then
	bUseCustHeader_7 = 1
	bUseCustomHeaders[7] = 1
	selectedCustHeaders[7] = stCustHeader_7
else
	if GLOB_MODPAR_NAME = "stColumnData_7" then
		stCustHeader_7 = ""
		selectedCustHeaders[7] = ""
		bUseCustHeader_7 = 0
		bUseCustomHeaders[7] = 0
	else
		stCustHeader_7 = selectedCustHeaders[7]
		if GLOB_MODPAR_NAME = "bUseCustHeader_7" then
			bUseCustomHeaders[7] = bUseCustHeader_7
		else
			bUseCustHeader_7 = bUseCustomHeaders[7]
		endif
	endif
endif
if GLOB_MODPAR_NAME = "stCustHeader_8" then
	bUseCustHeader_8 = 1
	bUseCustomHeaders[8] = 1
	selectedCustHeaders[8] = stCustHeader_8
else
	if GLOB_MODPAR_NAME = "stColumnData_8" then
		stCustHeader_8 = ""
		selectedCustHeaders[8] = ""
		bUseCustHeader_8 = 0
		bUseCustomHeaders[8] = 0
	else
		stCustHeader_8 = selectedCustHeaders[8]
		if GLOB_MODPAR_NAME = "bUseCustHeader_8" then
			bUseCustomHeaders[8] = bUseCustHeader_8
		else
			bUseCustHeader_8 = bUseCustomHeaders[8]
		endif
	endif
endif
if GLOB_MODPAR_NAME = "stCustHeader_9" then
	bUseCustHeader_9 = 1
	bUseCustomHeaders[9] = 1
	selectedCustHeaders[9] = stCustHeader_9
else
	if GLOB_MODPAR_NAME = "stColumnData_9" then
		stCustHeader_9 = ""
		selectedCustHeaders[9] = ""
		bUseCustHeader_9 = 0
		bUseCustomHeaders[9] = 0
	else
		stCustHeader_9 = selectedCustHeaders[9]
		if GLOB_MODPAR_NAME = "bUseCustHeader_9" then
			bUseCustomHeaders[9] = bUseCustHeader_9
		else
			bUseCustHeader_9 = bUseCustomHeaders[9]
		endif
	endif
endif
if GLOB_MODPAR_NAME = "stCustHeader_10" then
	bUseCustHeader_10 = 1
	bUseCustomHeaders[10] = 1
	selectedCustHeaders[10] = stCustHeader_10
else
	if GLOB_MODPAR_NAME = "stColumnData_10" then
		stCustHeader_10 = ""
		selectedCustHeaders[10] = ""
		bUseCustHeader_10 = 0
		bUseCustomHeaders[10] = 0
	else
		stCustHeader_10 = selectedCustHeaders[10]
		if GLOB_MODPAR_NAME = "bUseCustHeader_10" then
			bUseCustomHeaders[10] = bUseCustHeader_10
		else
			bUseCustHeader_10 = bUseCustomHeaders[10]
		endif
	endif
endif
if GLOB_MODPAR_NAME = "stCustHeader_11" then
	bUseCustHeader_11 = 1
	bUseCustomHeaders[11] = 1
	selectedCustHeaders[11] = stCustHeader_11
else
	if GLOB_MODPAR_NAME = "stColumnData_11" then
		stCustHeader_11 = ""
		selectedCustHeaders[11] = ""
		bUseCustHeader_11 = 0
		bUseCustomHeaders[11] = 0
	else
		stCustHeader_11 = selectedCustHeaders[11]
		if GLOB_MODPAR_NAME = "bUseCustHeader_11" then
			bUseCustomHeaders[11] = bUseCustHeader_11
		else
			bUseCustHeader_11 = bUseCustomHeaders[11]
		endif
	endif
endif
if GLOB_MODPAR_NAME = "stCustHeader_12" then
	bUseCustHeader_12 = 1
	bUseCustomHeaders[12] = 1
	selectedCustHeaders[12] = stCustHeader_12
else
	if GLOB_MODPAR_NAME = "stColumnData_12" then
		stCustHeader_12 = ""
		selectedCustHeaders[12] = ""
		bUseCustHeader_12 = 0
		bUseCustomHeaders[12] = 0
	else
		stCustHeader_12 = selectedCustHeaders[12]
		if GLOB_MODPAR_NAME = "bUseCustHeader_12" then
			bUseCustomHeaders[12] = bUseCustHeader_12
		else
			bUseCustHeader_12 = bUseCustomHeaders[12]
		endif
	endif
endif
if GLOB_MODPAR_NAME = "stCustHeader_13" then
	bUseCustHeader_13 = 1
	bUseCustomHeaders[13] = 1
	selectedCustHeaders[13] = stCustHeader_13
else
	if GLOB_MODPAR_NAME = "stColumnData_13" then
		stCustHeader_13 = ""
		selectedCustHeaders[13] = ""
		bUseCustHeader_13 = 0
		bUseCustomHeaders[13] = 0
	else
		stCustHeader_13 = selectedCustHeaders[13]
		if GLOB_MODPAR_NAME = "bUseCustHeader_13" then
			bUseCustomHeaders[13] = bUseCustHeader_13
		else
			bUseCustHeader_13 = bUseCustomHeaders[13]
		endif
	endif
endif
if GLOB_MODPAR_NAME = "stCustHeader_14" then
	bUseCustHeader_14 = 1
	bUseCustomHeaders[14] = 1
	selectedCustHeaders[14] = stCustHeader_14
else
	if GLOB_MODPAR_NAME = "stColumnData_14" then
		stCustHeader_14 = ""
		selectedCustHeaders[14] = ""
		bUseCustHeader_14 = 0
		bUseCustomHeaders[14] = 0
	else
		stCustHeader_14 = selectedCustHeaders[14]
		if GLOB_MODPAR_NAME = "bUseCustHeader_14" then
			bUseCustomHeaders[14] = bUseCustHeader_14
		else
			bUseCustHeader_14 = bUseCustomHeaders[14]
		endif
	endif
endif
if GLOB_MODPAR_NAME = "stCustHeader_15" then
	bUseCustHeader_15 = 1
	bUseCustomHeaders[15] = 1
	selectedCustHeaders[15] = stCustHeader_15
else
	if GLOB_MODPAR_NAME = "stColumnData_15" then
		stCustHeader_15 = ""
		selectedCustHeaders[15] = ""
		bUseCustHeader_15 = 0
		bUseCustomHeaders[15] = 0
	else
		stCustHeader_15 = selectedCustHeaders[15]
		if GLOB_MODPAR_NAME = "bUseCustHeader_15" then
			bUseCustomHeaders[15] = bUseCustHeader_15
		else
			bUseCustHeader_15 = bUseCustomHeaders[15]
		endif
	endif
endif
if GLOB_MODPAR_NAME = "stCustHeader_16" then
	bUseCustHeader_16 = 1
	bUseCustomHeaders[16] = 1
	selectedCustHeaders[16] = stCustHeader_16
else
	if GLOB_MODPAR_NAME = "stColumnData_16" then
		stCustHeader_16 = ""
		selectedCustHeaders[16] = ""
		bUseCustHeader_16 = 0
		bUseCustomHeaders[16] = 0
	else
		stCustHeader_16 = selectedCustHeaders[16]
		if GLOB_MODPAR_NAME = "bUseCustHeader_16" then
			bUseCustomHeaders[16] = bUseCustHeader_16
		else
			bUseCustHeader_16 = bUseCustomHeaders[16]
		endif
	endif
endif
parameters stCustHeader_1 = stCustHeader_1,
			stCustHeader_2 = stCustHeader_2,
			stCustHeader_3 = stCustHeader_3,
			stCustHeader_4 = stCustHeader_4,
			stCustHeader_5 = stCustHeader_5,
			stCustHeader_6 = stCustHeader_6,
			stCustHeader_7 = stCustHeader_7,
			stCustHeader_8 = stCustHeader_8,
			stCustHeader_9 = stCustHeader_9,
			stCustHeader_10 = stCustHeader_10,
			stCustHeader_11 = stCustHeader_11,
			stCustHeader_12 = stCustHeader_12,
			stCustHeader_13 = stCustHeader_13,
			stCustHeader_14 = stCustHeader_14,
			stCustHeader_15 = stCustHeader_15,
			stCustHeader_16 = stCustHeader_16,
			selectedCustHeaders = selectedCustHeaders,
			bUseCustomHeaders = bUseCustomHeaders,
			bUseCustHeader_1 = bUseCustHeader_1,
			bUseCustHeader_2 = bUseCustHeader_2,
			bUseCustHeader_3 = bUseCustHeader_3,
			bUseCustHeader_4 = bUseCustHeader_4,
			bUseCustHeader_5 = bUseCustHeader_5,
			bUseCustHeader_6 = bUseCustHeader_6,
			bUseCustHeader_7 = bUseCustHeader_7,
			bUseCustHeader_8 = bUseCustHeader_8,
			bUseCustHeader_9 = bUseCustHeader_9,
			bUseCustHeader_10 = bUseCustHeader_10,
			bUseCustHeader_11 = bUseCustHeader_11,
			bUseCustHeader_12 = bUseCustHeader_12,
			bUseCustHeader_13 = bUseCustHeader_13,
			bUseCustHeader_14 = bUseCustHeader_14,
			bUseCustHeader_15 = bUseCustHeader_15,
			bUseCustHeader_16 = bUseCustHeader_16


! Lock-Hide

if iLayoutType = LAYOUT_DETAILED then
	lock "separatorString"
	hideparameter "separatorString"
endif

if not(bShowFrame | bShowVertLines | bShowHorizLines) then
	lock "penFrame", "lineTypeFrame"
	hideparameter "penFrame", "lineTypeFrame"
endif
if not(bShowFrame) then
	lock "lineTypeFrame"
	hideparameter "lineTypeFrame"
endif
if not(bShowVertLines | bShowHorizLines) then
	lock "lineTypeSeparators", "bShowLinesEmptyRows"
	hideparameter "lineTypeSeparators", "bShowLinesEmptyRows"
endif

if nBlocks = 1 then
	lock "gapBetweenBlocks"
	hideparameter "gapBetweenBlocks"
endif


end

! ==============================================================================
"setSelectedNameToID":
! ------------------------------------------------------------------------------
!	Input Parameters:
!		_allSchemeTitleID[]:			array variable (String), all header column IDs corresponding _fullRevisionData array
!		_allSchemeTitleName[]:		array variable (String), all header column names corresponding _fullRevisionData array
!		_ixdActUIRow:				index variable of edited UI row data
!		selectedColumnIDs[]:		array parameter (String), ID-s collected from stColumnData_n UI parameters (column data selected by user)
!	Output Parameters:
!		selectedColumnNames[]:		array parameter (String), names collected corresponding selectedColumnIDs[]
! ==============================================================================
	__idxAllNames = 1
	for __idxAllNames = 1 to vardim1(_allSchemeTitleID)
		if selectedColumnIDs[_ixdActUIRow] = _allSchemeTitleID[__idxAllNames] then
			selectedColumnNames[_ixdActUIRow]= _allSchemeTitleName[__idxAllNames]
		endif
	next __idxAllNames
return



! ==============================================================================
"codeFun":
! ==============================================================================
	dim _tempData[4][4]
	isFirstRun = 0
	qq = APPLICATION_QUERY ("parameter_script", "firstoccasion_in_progress", isFirstRun)
	_tempData = dataGame
	_currentScore = currentScore
	
	gosub "_emptyFieldCount"
	if _emptyFieldCount = 0 then
		gosub "CheckValidMoves"
		_currentScore = currentScore
		_tempData = dataGame
	endif

	if not(bGameOver) then
		! ------------------------------------------------------------------------------
		! Interaction Up
		! ------------------------------------------------------------------------------
		if GLOB_UI_BUTTON_ID = 1 & isFirstRun then
			gosub "moveUp"
			gosub "CheckChanges"
			if _bChanged then
				dataGame = _tempData
				gosub "AddNew"
			endif
		endif
		
		! ------------------------------------------------------------------------------
		! Interaction Down
		! ------------------------------------------------------------------------------
		if GLOB_UI_BUTTON_ID = 2 & isFirstRun then
			gosub "moveDown"
			gosub "CheckChanges"
			if _bChanged then
				dataGame = _tempData
				gosub "AddNew"
			endif
		endif
		
		! ------------------------------------------------------------------------------
		! Interaction Left
		! ------------------------------------------------------------------------------
		if GLOB_UI_BUTTON_ID = 3 & isFirstRun then
			gosub "moveLeft"
			gosub "CheckChanges"
			if _bChanged then
				dataGame = _tempData
				gosub "AddNew"
			endif
		endif
		
		! ------------------------------------------------------------------------------
		! Interaction Right
		! ------------------------------------------------------------------------------
		if GLOB_UI_BUTTON_ID = 4 & isFirstRun then
			gosub "moveRight"
			gosub "CheckChanges"
			if _bChanged then
				dataGame = _tempData
				gosub "AddNew"
			endif
		endif
	endif
	! ------------------------------------------------------------------------------
	! Start/Reset
	! ------------------------------------------------------------------------------
	if (GLOB_UI_BUTTON_ID = 5 | nMoves = 0) & isFirstRun then 
		for _i = 1 to 4
			for _j = 1 to 4
				dataGame[_i][_j] = 0
			next _j
		next _i
		gosub "AddNew"
		gosub "AddNew"
		_currentScore = 0
		bGameOver = 0
		parameters bGameOver = bGameOver
	endif
	
	parameters	dataGame = dataGame,
				currentScore = _currentScore
	
	if currentScore > highScore then 
		parameters highScore = currentScore
	endif
return


! ==============================================================================
"Gravity":
! ------------------------------------------------------------------------------
	for _i = 1 to 4
		for _j = 1 to 3
			if _tempData[4][_i] = 0 then
				_tempData[4][_i] = _tempData[3][_i]
				_tempData[3][_i] = _tempData[2][_i]
				_tempData[2][_i] = _tempData[1][_i]
				_tempData[1][_i] = 0
			endif
		next _j
	
		for _j = 1 to 2
			if _tempData[3][_i] = 0 then
				_tempData[3][_i] = _tempData[2][_i]
				_tempData[2][_i] = _tempData[1][_i]
				_tempData[1][_i] = 0
			endif
		next _j
	
		if _tempData[2][_i] = 0 then
			_tempData[2][_i] = _tempData[1][_i]
			_tempData[1][_i] = 0
		endif
	next _i
return



! ==============================================================================
"Sum":
! ------------------------------------------------------------------------------
	for _i = 1 to 4
		if _tempData[4][_i] = _tempData[3][_i] then
			if _tempData[2][_i] = _tempData[1][_i] then
				_tempData[4][_i] = _tempData[4][_i] + _tempData[3][_i] : _currentScore = _currentScore + _tempData[4][_i] 
				_tempData[3][_i] = _tempData[2][_i] + _tempData[1][_i] : _currentScore = _currentScore + _tempData[3][_i] 
				_tempData[2][_i] = 0
				_tempData[1][_i] = 0
			else
				_tempData[4][_i] = _tempData[4][_i] + _tempData[3][_i] : _currentScore = _currentScore + _tempData[4][_i]
				_tempData[3][_i] = _tempData[2][_i]
				_tempData[2][_i] = _tempData[1][_i]
				_tempData[1][_i] = 0
			endif
		else
			if _tempData[3][_i] = _tempData[2][_i] then
				_tempData[4][_i] = _tempData[4][_i]
				_tempData[3][_i] = _tempData[3][_i] + _tempData[2][_i] : _currentScore = _currentScore + _tempData[3][_i]
				_tempData[2][_i] = _tempData[1][_i]
				_tempData[1][_i] = 0
			else
				if _tempData[2][_i] = _tempData[1][_i] then
					_tempData[4][_i] = _tempData[4][_i]
					_tempData[3][_i] = _tempData[3][_i]
					_tempData[2][_i] = _tempData[2][_i] + _tempData[1][_i] : _currentScore = _currentScore + _tempData[2][_i]
					_tempData[1][_i] = 0
				endif
			endif
		endif
	next _i
return



! ==============================================================================
"AddNew":
! ------------------------------------------------------------------------------
	_emptyFieldCount = 0
	gosub "_emptyFieldCount"

	if _emptyFieldCount <> 0 then
		gosub "GetRandomNumber"
		_randomNumber = (ownRandomNumber mod _emptyFieldCount) + 1
		for _i = 1 to 4
			for _j = 1 to 4
				if dataGame[_i][_j] = 0 then 
					_randomNumber = _randomNumber - 1
					if _randomNumber = 0 then
						dataGame[_i][_j] = 2
					endif
				endif
			next _j
		next _i
	endif

	parameters	dataGame = dataGame,
				_emptyFieldCount = _emptyFieldCount
return



! ==============================================================================
"FlipTemp":
! ------------------------------------------------------------------------------
	for _j = 1 to 4
		for _i = 4 to 1 step -1
			PUT(_tempData[_i][_j])
		next _i
	
		for _i = 1 to 4
			_tempData[_i][_j]= GET(1)
		next _i
	next _j
return



! ==============================================================================
"TransposeTemp":
! ------------------------------------------------------------------------------
	for _j = 1 to 4
		for _i = 1 to 4
			PUT(_tempData[_i][_j])
		next _i
	next _j
	
	for _j = 1 to 4
		for _i = 1 to 4
			_tempData[_j][_i]= GET(1)
		next _i
	next _j
return


! ==============================================================================
"GetRandomNumber":
! ------------------------------------------------------------------------------
	if GLOB_INTGUID = "" then 
		guidString = "B7411A05BA1547BBA8CD9F352C00E290"
	else
		guidString = STRSUB (GLOB_INTGUID, 1, 8) + STRSUB (GLOB_INTGUID, 10, 4) + STRSUB (GLOB_INTGUID, 15, 4) + STRSUB (GLOB_INTGUID, 20, 4)+ STRSUB (GLOB_INTGUID, 25, 12)
	endif

	_i = (nMoves mod 32) + 1

	if STRSUB (guidString, _i, 1) = "0" then ownRandomNumber = 0
	if STRSUB (guidString, _i, 1) = "1" then ownRandomNumber = 1
	if STRSUB (guidString, _i, 1) = "2" then ownRandomNumber = 2
	if STRSUB (guidString, _i, 1) = "3" then ownRandomNumber = 3
	if STRSUB (guidString, _i, 1) = "4" then ownRandomNumber = 4
	if STRSUB (guidString, _i, 1) = "5" then ownRandomNumber = 5
	if STRSUB (guidString, _i, 1) = "6" then ownRandomNumber = 6
	if STRSUB (guidString, _i, 1) = "7" then ownRandomNumber = 7
	if STRSUB (guidString, _i, 1) = "8" then ownRandomNumber = 8
	if STRSUB (guidString, _i, 1) = "9" then ownRandomNumber = 9
	if STRSUB (guidString, _i, 1) = "A" then ownRandomNumber = 10
	if STRSUB (guidString, _i, 1) = "B" then ownRandomNumber = 11
	if STRSUB (guidString, _i, 1) = "C" then ownRandomNumber = 12
	if STRSUB (guidString, _i, 1) = "D" then ownRandomNumber = 13
	if STRSUB (guidString, _i, 1) = "E" then ownRandomNumber = 14
	if STRSUB (guidString, _i, 1) = "F" then ownRandomNumber = 15

	nMoves = nMoves + 1
	parameters	nMoves = nMoves,
				ownRandomNumber = ownRandomNumber
return


! ==============================================================================
"CheckChanges":
! ------------------------------------------------------------------------------
	_bChanged = 0
	for _i = 1 to 4
		for _j = 1 to 4
			if _tempData[_i][_j] <> dataGame[_i][_j] then _bChanged = 1
		next _j
	next _i
return

! ==============================================================================
"CheckValidMoves":
! ------------------------------------------------------------------------------
	gosub "moveUp"
	gosub "moveDown"
	gosub "moveLeft"
	gosub "moveRight"
		
	gosub "CheckChanges"

	if not(_bChanged) & _emptyFieldCount = 0 then
		bGameOver = 1
		parameters bGameOver = bGameOver
	endif

return

! ==============================================================================
"_emptyFieldCount":
! ==============================================================================
	_emptyFieldCount = 0

	for _i = 1 to 4
		for _j = 1 to 4
			if dataGame[_i][_j] = 0 then 
				_emptyFieldCount = _emptyFieldCount + 1
			endif
		next _j
	next _i

return

"moveUp":
	gosub "FlipTemp"
	gosub "Gravity"
	gosub "Sum"
	gosub "FlipTemp"
return

"moveDown":
	gosub "Gravity"
	gosub "Sum"
return

"moveLeft":
	gosub "TransposeTemp"
	gosub "FlipTemp"
	gosub "Gravity"
	gosub "Sum"
	gosub "FlipTemp"
	gosub "TransposeTemp"
return

"moveRight":
	gosub "TransposeTemp"
	gosub "Gravity"
	gosub "Sum"
	gosub "TransposeTemp"
return

]]>
</Script_VL>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_FWM SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_FWM>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_BWM SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_BWM>

<ParamSection SectVersion="22" SectionFlags="0" SubIdent="0">
	<ParamSectHeader>
		<AutoHotspots>false</AutoHotspots>
		<StatBits>
			<STBit_UIDefault/>
			<STBit_FixSize/>
			<STBit_UIUseHierarchicalPages/>
		</StatBits>
		<WDLeftFrame>0</WDLeftFrame>
		<WDRightFrame>0</WDRightFrame>
		<WDTopFrame>0</WDTopFrame>
		<WDBotFrame>0</WDBotFrame>
		<LayFlags>65535</LayFlags>
		<WDMirrorThickness>0</WDMirrorThickness>
		<WDWallInset>0</WDWallInset>
	</ParamSectHeader>
	<Parameters>
		<Length Name="A">
			<Description><![CDATA["Dimension 1"]]></Description>
			<Fix/>
			<Value>0.062</Value>
		</Length>
		<Length Name="B">
			<Description><![CDATA["Dimension 2"]]></Description>
			<Fix/>
			<Value>0.003</Value>
		</Length>
		<Integer Name="iLayoutType">
			<Description><![CDATA["Layout Type (1-Simple, 2-Detailed)"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Integer Name="nBlocks">
			<Description><![CDATA["Number of Units"]]></Description>
			<Value>1</Value>
		</Integer>
		<Length Name="gapBetweenBlocks">
			<Description><![CDATA["Gap between Units"]]></Description>
			<Value>0.001</Value>
		</Length>
		<Integer Name="iDataSortingOrder">
			<Description><![CDATA["Display Order"]]></Description>
			<Value>1</Value>
		</Integer>
		<Integer Name="iDataAlign">
			<Description><![CDATA["Alignment Order"]]></Description>
			<Value>1</Value>
		</Integer>

		<!-- RevisionStDimensions: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="RevisionStDimensions">
			<Description><![CDATA["Dimensions"]]></Description>
		</Title>
		<Integer Name="nRows">
			<Description><![CDATA["Number of Data Rows"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>11</Value>
		</Integer>
		<Integer Name="nColumns">
			<Description><![CDATA["Number of Columns"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>4</Value>
		</Integer>
		<Length Name="columnWidths">
			<Description><![CDATA["Width of Columns"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<ArrayValues FirstDimension="16" SecondDimension="0">
				<AVal Row="1">0.008</AVal>
				<AVal Row="2">0.008</AVal>
				<AVal Row="3">0.028</AVal>
				<AVal Row="4">0.018</AVal>
				<AVal Row="5">0.01</AVal>
				<AVal Row="6">0.01</AVal>
				<AVal Row="7">0.01</AVal>
				<AVal Row="8">0.01</AVal>
				<AVal Row="9">0.01</AVal>
				<AVal Row="10">0.01</AVal>
				<AVal Row="11">0.01</AVal>
				<AVal Row="12">0.01</AVal>
				<AVal Row="13">0.01</AVal>
				<AVal Row="14">0.01</AVal>
				<AVal Row="15">0.01</AVal>
				<AVal Row="16">0.01</AVal>
			</ArrayValues>
		</Length>
		<Length Name="headerRowHeight">
			<Description><![CDATA["Height of Header Row"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.003</Value>
		</Length>
		<Length Name="rowHeight">
			<Description><![CDATA["Height of Data Row"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.003</Value>
		</Length>

		<!-- RevisionStVisualization: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="RevisionStVisualization">
			<Description><![CDATA["Borders"]]></Description>
		</Title>
		<Boolean Name="bShowFrame">
			<Description><![CDATA["Show Border"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bShowVertLines">
			<Description><![CDATA["Show Vertical Separators"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bShowHorizLines">
			<Description><![CDATA["Show Horizontal Separators"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bShowLinesEmptyRows">
			<Description><![CDATA["Show Lines in Empty Rows"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>

		<!-- RevisionStAttributes: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="RevisionStAttributes">
			<Description><![CDATA["Attributes"]]></Description>
		</Title>
		<FillPattern Name="fillStamp">
			<Description><![CDATA["Fill Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>65</Value>
		</FillPattern>
		<PenColor Name="fillFgPenStamp">
			<Description><![CDATA["Fill Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>62</Value>
		</PenColor>
		<PenColor Name="fillBgPenStamp">
			<Description><![CDATA["Fill Background Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>-1</Value>
		</PenColor>
		<PenColor Name="penFrame">
			<Description><![CDATA["Border Line Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</PenColor>
		<LineType Name="lineTypeFrame">
			<Description><![CDATA["Border Line Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</LineType>
		<LineType Name="lineTypeSeparators">
			<Description><![CDATA["Separator Line Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</LineType>

		<!-- bDisplayHeader: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="bDisplayHeader">
			<Description><![CDATA["Title"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Integer Name="iHeaderPosition">
			<Description><![CDATA["Title Position"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="iHeaderAlignment">
			<Description><![CDATA["Title Text Vertical Alignment"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<String Name="fontTypeHeader">
			<Description><![CDATA["Font Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Arial"]]></Value>
		</String>
		<RealNum Name="fontSizeHeaderMm">
			<Description><![CDATA["Font Size (mm)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1.5</Value>
		</RealNum>
		<RealNum Name="fontSizeHeaderPt">
			<Description><![CDATA["Font Size (point)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4.25196850394</Value>
		</RealNum>
		<PenColor Name="penHeaderText">
			<Description><![CDATA["Title Color"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</PenColor>
		<Boolean Name="bHeaderTextBold">
			<Description><![CDATA["Bold"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bHeaderTextItalic">
			<Description><![CDATA["Italic"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bHeaderTextUnderLine">
			<Description><![CDATA["Underline"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bHeaderTextStrikeThrough">
			<Description><![CDATA["Strikethrough"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- RevTextFormatTitle: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="RevTextFormatTitle">
			<Description><![CDATA["Text Format"]]></Description>
		</Title>
		<Boolean Name="bShowLatestRevisonOnly">
			<Description><![CDATA["Show Latest Revision Only"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bDisplayFirstRevision">
			<Description><![CDATA["Include First Revision"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<String Name="separatorString">
			<Description><![CDATA["Separator String"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[", "]]></Value>
		</String>
		<Length Name="textIndent">
			<Description><![CDATA["Text Indent"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.001</Value>
		</Length>
		<RealNum Name="fontSizeTextMm">
			<Description><![CDATA["Font Size (mm)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1.5</Value>
		</RealNum>
		<RealNum Name="fontSizeTextPt">
			<Description><![CDATA["Font Size (point)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4.25196850394</Value>
		</RealNum>
		<String Name="fontTypeText">
			<Description><![CDATA["Font Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Arial"]]></Value>
		</String>
		<PenColor Name="penText">
			<Description><![CDATA["Text Color"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</PenColor>
		<Boolean Name="bTextBold">
			<Description><![CDATA["Bold"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bTextItalic">
			<Description><![CDATA["Italic"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bTextUnderline">
			<Description><![CDATA["Underline"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bTextStrikethrough">
			<Description><![CDATA["Strikethrough"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- bWatermark: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="bWatermark">
			<Description><![CDATA["Show Watermark"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="iWMarkOrientation">
			<Description><![CDATA["Watermark Orientation"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<String Name="stWatermark">
			<Description><![CDATA["Text"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Выполняются Изменения"]]></Value>
		</String>
		<String Name="fontTypeWatermark">
			<Description><![CDATA["Font Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Arial"]]></Value>
		</String>
		<RealNum Name="fontSizeWatermarkMm">
			<Description><![CDATA["Font Size (mm)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>6</Value>
		</RealNum>
		<RealNum Name="fontSizeWatermarkPt">
			<Description><![CDATA["Font Size (point)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>17.0078740157</Value>
		</RealNum>
		<PenColor Name="penWatermarkText">
			<Description><![CDATA["Watermark Color"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>58</Value>
		</PenColor>
		<Boolean Name="bWmTextBold">
			<Description><![CDATA["Bold"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bWmTextItalic">
			<Description><![CDATA["Italic"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bWmTextStrikethrough">
			<Description><![CDATA["Strikethrough"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bWmTextUnderline">
			<Description><![CDATA["Underline"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- bShowNCSRevisionMarker: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="bShowNCSRevisionMarker">
			<Description><![CDATA["Show Marker around Revision ID"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<String Name="stNCSConditionColumnID">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="iNCSConditionType">
			<Description><![CDATA["Condition Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</Integer>
		<String Name="stNCSConditionText">
			<Description><![CDATA["Condition Text"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Boolean Name="bNCSCaseSensitive">
			<Description><![CDATA["Match Case"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<PenColor Name="penNCSMarker">
			<Description><![CDATA["Marker Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</PenColor>
		<Length Name="sizeNCSMarker">
			<Description><![CDATA["Marker Size"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.008</Value>
		</Length>

		<!-- bUseCustomRowFilter: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="bUseCustomRowFilter">
			<Description><![CDATA["Custom Row Filter"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<String Name="stCustFilterColumnID">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="iCustFilterConditionType">
			<Description><![CDATA["Condition Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<String Name="stCustFilterConditionText">
			<Description><![CDATA["Condition Text"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Boolean Name="bCustFilterCaseSensitive">
			<Description><![CDATA["Match Case"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- RevisionUIParamsTitle: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="RevisionUIParamsTitle">
			<Description><![CDATA["UI Parameters"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
		</Title>
		<String Name="selectedColumnIDs">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="16" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
				<AVal Row="3"><![CDATA[""]]></AVal>
				<AVal Row="4"><![CDATA[""]]></AVal>
				<AVal Row="5"><![CDATA[""]]></AVal>
				<AVal Row="6"><![CDATA[""]]></AVal>
				<AVal Row="7"><![CDATA[""]]></AVal>
				<AVal Row="8"><![CDATA[""]]></AVal>
				<AVal Row="9"><![CDATA[""]]></AVal>
				<AVal Row="10"><![CDATA[""]]></AVal>
				<AVal Row="11"><![CDATA[""]]></AVal>
				<AVal Row="12"><![CDATA[""]]></AVal>
				<AVal Row="13"><![CDATA[""]]></AVal>
				<AVal Row="14"><![CDATA[""]]></AVal>
				<AVal Row="15"><![CDATA[""]]></AVal>
				<AVal Row="16"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<String Name="selectedColumnNames">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="16" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
				<AVal Row="3"><![CDATA[""]]></AVal>
				<AVal Row="4"><![CDATA[""]]></AVal>
				<AVal Row="5"><![CDATA[""]]></AVal>
				<AVal Row="6"><![CDATA[""]]></AVal>
				<AVal Row="7"><![CDATA[""]]></AVal>
				<AVal Row="8"><![CDATA[""]]></AVal>
				<AVal Row="9"><![CDATA[""]]></AVal>
				<AVal Row="10"><![CDATA[""]]></AVal>
				<AVal Row="11"><![CDATA[""]]></AVal>
				<AVal Row="12"><![CDATA[""]]></AVal>
				<AVal Row="13"><![CDATA[""]]></AVal>
				<AVal Row="14"><![CDATA[""]]></AVal>
				<AVal Row="15"><![CDATA[""]]></AVal>
				<AVal Row="16"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<Integer Name="iTextAlignments">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="16" SecondDimension="0">
				<AVal Row="1">2</AVal>
				<AVal Row="2">2</AVal>
				<AVal Row="3">1</AVal>
				<AVal Row="4">3</AVal>
				<AVal Row="5">1</AVal>
				<AVal Row="6">1</AVal>
				<AVal Row="7">1</AVal>
				<AVal Row="8">1</AVal>
				<AVal Row="9">1</AVal>
				<AVal Row="10">1</AVal>
				<AVal Row="11">1</AVal>
				<AVal Row="12">1</AVal>
				<AVal Row="13">1</AVal>
				<AVal Row="14">1</AVal>
				<AVal Row="15">1</AVal>
				<AVal Row="16">1</AVal>
			</ArrayValues>
		</Integer>
		<String Name="selectedCustHeaders">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="16" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
				<AVal Row="3"><![CDATA[""]]></AVal>
				<AVal Row="4"><![CDATA[""]]></AVal>
				<AVal Row="5"><![CDATA[""]]></AVal>
				<AVal Row="6"><![CDATA[""]]></AVal>
				<AVal Row="7"><![CDATA[""]]></AVal>
				<AVal Row="8"><![CDATA[""]]></AVal>
				<AVal Row="9"><![CDATA[""]]></AVal>
				<AVal Row="10"><![CDATA[""]]></AVal>
				<AVal Row="11"><![CDATA[""]]></AVal>
				<AVal Row="12"><![CDATA[""]]></AVal>
				<AVal Row="13"><![CDATA[""]]></AVal>
				<AVal Row="14"><![CDATA[""]]></AVal>
				<AVal Row="15"><![CDATA[""]]></AVal>
				<AVal Row="16"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<Boolean Name="bUseCustomHeaders">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="16" SecondDimension="0">
				<AVal Row="1">1</AVal>
				<AVal Row="2">1</AVal>
				<AVal Row="3">0</AVal>
				<AVal Row="4">1</AVal>
				<AVal Row="5">0</AVal>
				<AVal Row="6">0</AVal>
				<AVal Row="7">0</AVal>
				<AVal Row="8">0</AVal>
				<AVal Row="9">0</AVal>
				<AVal Row="10">0</AVal>
				<AVal Row="11">0</AVal>
				<AVal Row="12">0</AVal>
				<AVal Row="13">0</AVal>
				<AVal Row="14">0</AVal>
				<AVal Row="15">0</AVal>
				<AVal Row="16">0</AVal>
			</ArrayValues>
		</Boolean>
		<String Name="stCustHeader_1">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stCustHeader_2">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stCustHeader_3">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Имя Изменения"]]></Value>
		</String>
		<String Name="stCustHeader_4">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stCustHeader_5">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stCustHeader_6">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stCustHeader_7">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stCustHeader_8">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stCustHeader_9">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stCustHeader_10">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stCustHeader_11">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stCustHeader_12">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stCustHeader_13">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stCustHeader_14">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stCustHeader_15">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stCustHeader_16">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stColumnData_1">
			<Description><![CDATA["Column 1 Data"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stColumnData_2">
			<Description><![CDATA["Column 2 Data"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stColumnData_3">
			<Description><![CDATA["Column 3 Data"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stColumnData_4">
			<Description><![CDATA["Column 4 Data"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stColumnData_5">
			<Description><![CDATA["Column 5 Data"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stColumnData_6">
			<Description><![CDATA["Column 6 Data"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stColumnData_7">
			<Description><![CDATA["Column 7 Data"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stColumnData_8">
			<Description><![CDATA["Column 8 Data"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stColumnData_9">
			<Description><![CDATA["Column 9 Data"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stColumnData_10">
			<Description><![CDATA["Column 10 Data"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stColumnData_11">
			<Description><![CDATA["Column 11 Data"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stColumnData_12">
			<Description><![CDATA["Column 12 Data"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stColumnData_13">
			<Description><![CDATA["Column 13 Data"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stColumnData_14">
			<Description><![CDATA["Column 14 Data"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stColumnData_15">
			<Description><![CDATA["Column 15 Data"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="stColumnData_16">
			<Description><![CDATA["Column 16 Data"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<Integer Name="iTextAlignment_1">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Integer Name="iTextAlignment_2">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Integer Name="iTextAlignment_3">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="iTextAlignment_4">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<Integer Name="iTextAlignment_5">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="iTextAlignment_6">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="iTextAlignment_7">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="iTextAlignment_8">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="iTextAlignment_9">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="iTextAlignment_10">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="iTextAlignment_11">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="iTextAlignment_12">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="iTextAlignment_13">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="iTextAlignment_14">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="iTextAlignment_15">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Integer Name="iTextAlignment_16">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<Boolean Name="bUseCustHeader_1">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bUseCustHeader_2">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bUseCustHeader_3">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bUseCustHeader_4">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bUseCustHeader_5">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bUseCustHeader_6">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bUseCustHeader_7">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bUseCustHeader_8">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bUseCustHeader_9">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bUseCustHeader_10">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bUseCustHeader_11">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bUseCustHeader_12">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bUseCustHeader_13">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bUseCustHeader_15">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bUseCustHeader_14">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Boolean Name="bUseCustHeader_16">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="gs_ui_current_page">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>

		<!-- titleDebug: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="titleDebug">
			<Description><![CDATA[""]]></Description>
		</Title>
		<Boolean Name="bDebug">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>

		<!-- titleGame: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="titleGame">
			<Description><![CDATA[""]]></Description>
		</Title>
		<Boolean Name="bGameOver">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Integer Name="dataGame">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="4" SecondDimension="4">
				<AVal Column="1" Row="1">0</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
				<AVal Column="4" Row="1">0</AVal>
				<AVal Column="1" Row="2">0</AVal>
				<AVal Column="2" Row="2">0</AVal>
				<AVal Column="3" Row="2">0</AVal>
				<AVal Column="4" Row="2">0</AVal>
				<AVal Column="1" Row="3">0</AVal>
				<AVal Column="2" Row="3">0</AVal>
				<AVal Column="3" Row="3">0</AVal>
				<AVal Column="4" Row="3">0</AVal>
				<AVal Column="1" Row="4">0</AVal>
				<AVal Column="2" Row="4">0</AVal>
				<AVal Column="3" Row="4">0</AVal>
				<AVal Column="4" Row="4">0</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="ownRandomNumber">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>7</Value>
		</Integer>
		<Integer Name="currentScore">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="highScore">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="nMoves">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
	</Parameters>
</ParamSection>

<Picture MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="0" length_in_bytes="5152" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000001000000
	010008030000006BAC5854000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC610500000300504C54450000002424244949496F6F6F7F7F7F91
	9191999999A4A4A4B7B7B7C5C5C5CCCCCCE2E2E2FFFFFF000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000091179B94000000097048597300000EC3
	00000EC301C76FA8640000001A74455874536F667477617265005061696E742E
	4E45542076332E352E313147F342370000107949444154785EED5D8B76EBAA0E
	CCA34D9B36FFFFBD67662430769C4082CE5ADD0BE69E8887402FB02D9CECDEC3
	6D70CC0078392C6600BC1C1633005E0E8B19002F87C50C8097C36206C0CB6131
	03E0E5B09801F07258CC0078392C6600BC1C1633005E0E8B19002F87C50C8097
	C36206C0CB613103E0E5B09801F07258CC0078392C6600BC1C1633005E0E8B19
	002F87C50C8097C36206C0CB613103E0E5B09801F07258CC0078392C6600BC1C
	1633005E0E8B19002F87C50C8097C36206C0CB61C1001C46450E002B4FD0CB0F
	479042892151E503F86145F852DB1BAEEF173DBFDFACADB8CE5FB8BBF8F8E5B4
	20B841AF201BFCBB58213124AAB0FFEBF3E3FBF6C931FCDFEDC7C7BABE4F7AF9
	F581CE15D7F9998B48807C82A0F575A348B2C1FF22EBF7EBE3FB030DEF7F0B6E
	D02BA0C19FB4ECEB03A5A99618125518A22FBAFFF5FBFD632EEA03983E85EEF7
	939EAEB8C62FB80C069A9FF87C7FFD5024F0F5FDAD099F18F3815AEA7F0B66D0
	4B70836959562D3124AAC0A6AF1FEE931F2EEDC300C88D870110F7130BCCDACF
	0FB5F9D6B38080050E827C4BFD6FC10C7A0932589665934C0C892A18F1851D40
	57D21A6F2F815F6CEF2500DB4B2071E1B705000E23A6BED1795530243900EF5F
	00D9A0574083718FF31D609018125530E2F78321BA7D62C0939BA00250709D9F
	B9A8580070B97D6AD1C9C6AC6FDE03520052FF5B70835E010D966537DE034CB5
	C490D4E4BDCFEF5AE7C7A819D408892179DF41C3237EB94B425133A8111243F2
	AE830941F6B42348A1C490F43A18644F3B82144A0C8967C6E32107809527E8E5
	872348A1C49094F24E871388371C357D2688113DAA7DBB4AC0464A20F60C3A1E
	CE663CF51ED010D4733C5CACA56E1BA46622853C987EBA1E370AF6F495105F52
	8FD0052D27693C49213E579866160661C7A00B34C978E8B95DDD1C73072C5B18
	75DB204162480A79970BFF4B2172ECE85BC104D1DBE391965C7D07B0AA260390
	CD08C0BE4127335ED6FB9AABA7D08C6E1FA45622853C63BF1300CD4100B00227
	0F00AB6A2A007ED389C0AE20A85802E02E5BCFE190438F057A1E00DB203D0140
	BC530058F5A6FAC3B067D0E99276B7769BB9E03D291CEC4E5D80C49094F2DEBE
	09A60068D9FD1EE03B004B00EE7159875EEC18A40D966F82BADFA88E9EEB81E6
	B065DDE862C3C5903439F804357E3882144A0C49AF8341F6B42348A1C490F43A
	18644F3B82144A0C49AF8341F6B42348A1C49030891B123900AC3C412F3F1C41
	0A2586A494C787C43669151F0F9303321AC3FA6149FE994F1A7FBEEAF97BB487
	2F6AFE14769CF4503290F910C6DB1D521A9CB07F169014EB06AC3B4B94189242
	1ED38433D26A6F1AD48217D7838BE2A8E2C4C08A390A2BD00FEEE182066276E2
	B100270424C4ECF771E7EBE54A6BC4C494D3E16C49027346B438060924D3074A
	DAACC7CAE00424393B670136CC5A36AC7B6DB74821CF13459FEE209F86C3095B
	4D1B9507693E733D5871C4C02347DB50366F70C0BBD8C3605C94ADF1CCA02947
	889034058033D9CDC198E6D51285C10576CE026A7837A1EEB5DD24853C1B9C87
	18C8A723B2EF76C6D2ED04E042A7EC3251BE493790FC29001CAB7E01E9223619
	98CC917DCAD1980A803E9CC2DC1101F0BB55816D5B80AC250039666878B7C06E
	37C3C59014F26012CC4AC31DE21FAFB804DC098DDA08BA9DB49CE6A805006A8B
	1D607311263410008C55006C4A0A00E6692E979DD31980ED05B0323863F72C20
	6FBD1BBAAD3BB14C0C49290F17E05DC8D5F29BA0CDD665BA16440BB4E41A93EE
	01D8DCE91EE07375133CC3201D12780FE0140F004F0DB859F8FED0298EF78086
	4BE0C15940245B6B77136FB818921D792BF4F2EF71BFA80B108E1A5E57B80B89
	21E975F0657B781D3CC40801E84590428921E97530C89E760429941892AA837F
	0E6E5827DA03E0E52304D9D38E20851243D2E4A03F060D7CB0D83385201F0FDB
	EBE1AAC7FECE7DCC6E7AC614B60F36A1B835EEF2336A06374262486AF2C48749
	ABB340716260892E1447A4EE1893D2793B1800880E6A29AF3F2A4B404DDF58B0
	65BD1E54BD5F678C913F1431295033B8111243529347BE566F7D16C82B667C72
	B0033090C9BD25736C7084E58629AFE77FAA89E7893F49AAE04483F1E7A3CFBE
	43CDE046480C494D9E3948C26C6EFF2C80DD81367D4464342E1F0C003B0AA4BC
	9E01B0649F3CB8CC5E76389B5B0162AE479F7D879AC18D9018929A3CF1EFCE02
	CB89817C7629F5574501C06EBE0B806E0E3B3B40893A3B3D63E70EB8FCAD006C
	CF02B65A024BEE10DC0491BAF31EA071F960900290F27AFDA77B00796CA957F7
	8054818AE3DF0AC01304D9B385F6C32E82144A0C49AF8341F6ACB16CB07B0429
	9418929ABC5E7E3882144A0C49AF8341F6B42348A1C490541DFC7370C33AD11E
	002F1F21C89E7604299418922607EFCE02F6929D209FEC7B39077B139D910510
	7A08BE859AC18D9018929A3CF161EEEA2CB0498501A63229FD57528F02B3EC35
	AFBDFACF87047C2EC898D1424F19A226D40C6E84C490D4E491CF44677316E049
	46B0F9F6AE9F299C67F7008F4C16007BF59F0F09646B283EE77F28004CCDF259
	C07C04349F0398CF6B4C4A13E5A10240A73D21165301408B39FF3F110098BB3E
	0B706D59078C8F8F7600FB5111B8E63C1DA437DFAC1A3305003D4F5F91EEA266
	70232486A4264FFCED59205DE600F9D817E0F31EA031FE2E1F356C70BEECF700
	6812992900CCF9FF8D003C41A73D69BBB4A3536182C490F43AD8658FDF2D5E42
	97C20512435293D7CB0F4790428921E97530C89E760429941812DEBF86440E00
	2B4FD0CB0F479042892129E5ADB37C83F83BDF0BA4C797F8FCDA3BA5347A04A2
	1FB06C918F3DEFDC03B38303D36687D28527280D4EE0035689369FBD8B07DE61
	60B78D112486A49007D565966F101F16AD7F23B48C219FCD23137E8E80B7F49C
	23EC973E0A4091FAA75F05795A8001E8D077011ACE2F10C4D394ED7AAC0C4EC0
	B3F4D16F84F28F82D86D630CEA2729E46DB27C03F9F2B73C0B3023661DD07CD9
	CB41F4CB86A51D20F71100F8890F537F3F1A307334C22C4903349C15757B2559
	9C50185CE0D16F84523080C3C5C7582B91429EF3657F06F9300584A9DB721648
	827DFE511E68614D8065B996F73100988D6994E489A1BE1C105100641987538E
	BAA570B9D6120A8317405B6156F2808D623A75480D213124853CA82EB37C83F8
	95B3805CD5D7226500E8317B72003093233D00F73BE004BFCB1D8029A8244509
	85C119B872395FBBBF98C232D5D9ED6304892129E5F12AD7955940FCCA59005D
	D876BC07AC02703D605E11000C63EAEF013019BA07A0854FF1C320F134A56907
	E88849B3A4567235CB3BACC16E8D51CBC490ECC85BA197BF06D6A117AF297C08
	8921E975F0157BB850DD081041480C494D5E2F3F1C410A2586A4D7C1207BDA11
	A4506248AA0EFE39B8619D680F80978F10644F3B82144A0C499383FE1834D863
	50CF3A807CB2AD8D27ED033C58BB2CF50E8F24D50C6E84C490D4E4890FEFD6DF
	0B2087F38C827CB9EDD93E7FF3633FFA45A7C54A3EA285596CA8C3CE0B18C721
	08E032E1E47C29DB41CDE046480C494D5EE120E30037984F5ECC2B407CACEE19
	832C8D63AFA5F6244AEA008AD0CF84AC837D6427A979C29921B20C711F35831B
	21312435797250016062E667011CEA50086BBEDCC0F259E6C7C47BF996001FE6
	F8CAF3E51ED91A574E6030ED47439CB5839AC18D9018929A3CF177CE02F84F20
	7F13009E00528B43050CB9DCEF00FF455131C1F6D61FDB015A165B2BC02EEC64
	1FF95A35E3339147D3FC29876A61D1806774517DBC07C8EF62C211F70030FFD6
	3DE01982ECC9C0DA3F4790428921E97530C81E87B6C97304299418929ABC5E7E
	3882144A0C49AF8341F6B42348A1C490F0E6342472005879825E7E3882144A0C
	C946DE717B1316DF1F830E3EEDF4B426C8571EF0141A904755873FC3C660814F
	563E7237B6B1430F5DC2BAB36A892159CBB31FBE97101F9DF92C0091C5BB77F1
	1900C48889CCF26B2053A86E3DD4492A697E13D6060B78743EFA5E802C35AC3B
	7F4D60BD24B947385FF26B5307F95AE194B59BFCFCEE3DF3213DBDF2E7506876
	4996FB91E48A31DEC3DAE08487DF0B24EADDA9616248D6F2B0D5F310437650A9
	1ACE02FECF66931399CF040E63F88A9743ED74A76E25F6243A173C49F39BB036
	D8A1743A0520DBA6C6A28CDDB92531242B797C6DBF51A066791690B65C179F01
	603E9F0380CDEE43D89D171E1F6DCAF01DF0EC7B01DF0EDE9D58268664250F8E
	E6190EF1FD26E8B351E45B8BF862F39D480A00D9B603D45DDC03E0FBFF700FE0
	CECA3741D9261520761865CB4C464D2C1343B2236F8577F888C3FF879A418D90
	1892771C2CB1C71F3E00FF2B82144A0C49AF8341F6B42348A1C490541DFC7370
	C33AD11E002F1F21C89E7604299418922607FD3168581E3344E6AB85A7604E18
	05E54877D8EF6D43CDE046480C494D9EF870299F0590511C10045689CCD71F0B
	91FB073DE9311C94AE223CC804F9E7833884F9C42967ABAFA36670232486A426
	8F7C2DD8721658B20920F32DC3530090F1B04F3F08B2816823CBD41006C07BDF
	42CDE046480C494D5E7690862F6781EC41E65BCEA50070247260768BA50490AF
	D2790CF81703B03E0B2857CE1E947CD65200E0A37E10848F8E09FEE783B435F8
	35D0DBA819DC088921A9C913DF6F82327BC9AE85CCB775CE01D02B7E9FA9AF4E
	EDCF07214ABC23FC63F7806778C2C7821758353A5033A8111243D2E1A0F090AF
	8DB280D743086A06354262486AF27AF9E10852283124BD0E06D9D38E20851243
	829D3A2672005879825E7E3882144A0CC94A1E1F5A9BBBB5F8FE18346808721A
	6FE1B34CD3BF947C04FF57013D4900408578A4221B49BFD2E1CB5042D2811D2F
	EE21BF485449A06D1BF3C487E8E537421A72F75A3CFDD8FFCC61CB9F072AFE66
	28FF5500FFF4244A250A47B3B3C1D815A4100220C8F20A9C3CF8EFB451F137D1
	3407F988D9A02389D7A92AA9935F24AA24307614512039589C05E0FCF96E0770
	08D33C0DF3B7FF24FE5501C123C289FFB0C072AAFCB6D817B211321822100009
	809CA31963BF33CA0130F53A92E497D2FABF3CD06089215125C1A6AE2007E980
	ACD6590043F83D8421F119720580C38E96F693A0CD17C584FA9134E700206E28
	B621AF40069FCED7F385AB6072520024D72F01B3C18E24080075515552273124
	AA24D0938D39E2976701C490DB3DCD63A969CAF8730018715B827500B01F3186
	35AD888913B715528C55851829811CFF3E2F074002F30EC055A7BA5465751243
	921C11E8585A5A87F8EC77E990CCAB68BD03380D0476D8F54DB3380A641D0034
	AFB88474C5D89EC94BD20A19C4BC12155372B9F0FB0C543601105B4712D5A90F
	D5A73B6007BDFC70BCAC908B7F0F8921E975F0657B7AF1A2C2E5625D43BD2435
	79BDFC7004299418925E0783EC694790428921C11619133900AC3C412F3F1C41
	0A2586A4D7C1207BDA11A45062487A1D0CB2A71D410A2586A4D7C1207BDA11A4
	5062487A1D0CB2A71D410A2586A4D7C1207BDA11A45062487A1D0CB2A71D410A
	2586A4D7C1207BDA11A45062487A1D0CB2A71D410A2586A4D7C1207BDA11A450
	62487A1D0CB2A71D410A2586C433E3F190A330326600BC1C1633005E0E8B1900
	2F87C50C8097C36206C0CB613103E0E5B09801F07258CC0078392C6600BC1C16
	33005E0E8B19002F87C50C8097C36206C0CB613103E0E5B09801F07258CC0078
	392C6600BC1C1633005E0E8B19002F87C50C8097C36206C0CB613103E0E5B098
	01F07258CC0078392C6600BC1C1633005E0E8B19002F87C50C8097C36206C0CB
	613103E0E5B0183C00B7DB7F5B58E9736402CBC80000000049454E44AE426082
	]]>
</Picture>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="1" length_in_bytes="429" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003A0000
	00140806000000DC1D2E6E000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1874455874536F667477617265007061696E742E6E657420342E302E338CE697
	5000000114494441545847DD94810E82400C43F9FF9F4646AC59C6DA9D3B50F4
	254DBC8E750C03CB3758D7F5F9EBCFF9B545ED6ED51DD35A7351CC8322CC97F8
	C02CC09F63CDC87A5E148BCAE2069B07AAFE03D60045468299AF16B502C4C86A
	DE53BD14D664BE5706F3D9A23E0F8A641E507D6D7C180BA603273E46238DEDF0
	0C1F96059B071DB8D3C7E85226FED1D3C1D3F1F2C47344D68B4559716AA6C21A
	A153118B5E36B3820DAC6E44D6C9A2664679E23952D53FCF9DDED10A3C7128C2
	FC9D894565EE463BB8220BF65E3AB8B968956BDEDBC168F2CAC87CEFA57DC5A2
	23B346AE19C69AA00C152A7BC5A2AACFD7B2BAC1FC12D538129A5E43163533CA
	E3CFB10698DF0637024598BF73F13BDA0ABF84E6A2132CCB03700DD7298092CB
	1C0000000049454E44AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="2" length_in_bytes="260" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D494844520000003A0000
	00140806000000DC1D2E6E000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1874455874536F667477617265007061696E742E6E657420342E302E338CE697
	500000006B494441545847ED8F310EC03008C4F2FF4F131822A551B381AFAAB0
	E41573A369FE83159845E6AD4F2319AA88E2CD082E49D0DE3E724981B5CE81BB
	0454E78122DA432BE9A1C944E726021672CE81649B8D399291011E74144D4D54
	41E6D0B895AD1E33C395F0F648AD3626EE4D0906F2919BF50000000049454E44
	AE426082
	]]>
</GDLPict>

<GDLPict MIME="image/png" SectVersion="19" SectionFlags="0" SubIdent="3" length_in_bytes="362" platform="Win">
	<![CDATA[
	696D6167652F706E670089504E470D0A1A0A0000000D49484452000000210000
	001E0806000000A2C87717000000017352474200AECE1CE90000000467414D41
	0000B18F0BFC6105000000097048597300000EC300000EC301C76FA864000000
	1A74455874536F667477617265005061696E742E4E45542076332E352E313147
	F34237000000CF494441545847C58E0B0E85300804BDFFA57D5DF3C69096FEB4
	964988B86C618F059CFF6F180A4085701D17F41277131EE20E00681AEE223C44
	110098C9F435E121AA01008FCC5FD00D0078F56835E1218603006FF47815E121
	A603006FB5E42DE1218A0068B92E3AFE475417E6BDE0DF6A6066D3140BADE6F5
	56B398D914CD655ECF973E8759AA61DC6556F73C9E06CC520DD15D94F7E06916
	E6A9BA5417D999E7F3340BF3544D9A4B041ECF37F9DEA5BB6015DCD2D19CF010
	DB020037751CC2436C0F00DCBE4304972B6EACE3FC0140F0F254161BE20F0000
	000049454E44AE426082
	]]>
</GDLPict>

<Copyright SectVersion="1" SectionFlags="0" SubIdent="0">
	<Author>GRAPHISOFT</Author>
	<License>
		<Type>CC BY-ND</Type>
		<Version>3.0</Version>
	</License>
</Copyright>

<Keywords SectVersion="1" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Keywords>

<Comment SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Comment>

</Symbol>
