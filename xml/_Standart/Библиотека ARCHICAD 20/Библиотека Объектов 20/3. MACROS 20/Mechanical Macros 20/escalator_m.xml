<?xml version="1.0" encoding="UTF-8"?>
<Symbol IsArchivable="true" IsPlaceable="false" MainGUID="98056E21-8EC5-406A-A1BC-73253A97CE5E" MigrationValue="Normal" Owner="1196638531" Signature="1196644685" Version="43">
<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_FWM SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_FWM>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_BWM SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_BWM>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_3D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! ==============================================================================
! escalator_m
! ==============================================================================


if gs_detlevel_3D_m = 0 then end
if not(gs_shadow) then SHADOW OFF

grooveWidth = 0
grooveDepth = 0
if gs_detlevel_3D_m = 2 then
	grooveWidth = 0.01
	grooveDepth = 0.005
endif
balustradeFooting = 0.3

trussLowerRad = 2.53
if landingHeight > 0 then
if landingLength >= A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread)) - ((riserBegin - 0.02) / tan(inclination)) - 0.02 / sin(inclination) - trussLowerRad * tan(inclination/2) then
	trussLowerRad = (A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread)) - ((riserBegin - 0.02) / tan(inclination)) - 0.02 / sin(inclination) - landingLength) / tan(inclination/2) - 0.01
endif
endif
trussUpperRad = 1.07
if landingHeight - trussLowerRad * (1 - cos(inclination)) - trussUpperRad * (1 - cos(inclination)) < 0.01 & inclination > 0 then
	trussLowerRad = (landingHeight - trussUpperRad * (1 - cos(inclination)) - 0.01) / (1 - cos(inclination))
	if trussLowerRad < trussLowerRadMin then
		trussLowerRad = trussLowerRadMin
		trussUpperRad = (landingHeight - trussLowerRad * (1 - cos(inclination)) - 0.01) / (1 - cos(inclination))
	endif
endif
treadThk = 0.05

beta = asn(treadThk/tread*sin(inclination + 90))
riserAngle = beta + inclination
riserHeight = tread * sin(riserAngle)
if landingHeight > 0 then
	riserBeginAngle = asn(riserBegin/tread)
else
	riserBeginAngle = 0
endif

if landingHeight > 0 then
	if landingHeight < landingHeightMin then
		maskMod = 0
	else
		maskMod = 1000
	endif
	maskMod2 = 0
else
	maskMod = 0
	maskMod2 = -2
	inclination = 0
endif

pen gs_cont_pen
if gs_detlevel_3D_m = 1 then gs_resol = 8
resol gs_resol * 2


! ==============================================================================
! Hotspots
! ==============================================================================

unID = 1
hotspot 0, 0, 0, unID, B, 1 + 256 : unID = unID + 1
hotspot 0, B, 0, unID, B, 2 : unID = unID + 1
hotspot 0, -1, 0, unID, B, 3 : unID = unID + 1

hotspot A, 0, landingHeight, unID, B, 1 + 256 : unID = unID + 1
hotspot A, B, landingHeight, unID, B, 2 : unID = unID + 1
hotspot A, -1, landingHeight, unID, B, 3 : unID = unID + 1

if iObjectType = ESCALATOR then
	hotspot 0, B/2, 0, unID, A, 1 + 256 : unID = unID + 1
	hotspot A, B/2, 0, unID, A, 2 : unID = unID + 1
	hotspot -1, B/2, 0, unID, A, 3 : unID = unID + 1
else
	hotspot 0, B/2, landingHeight, unID, A, 1 + 128 : unID = unID + 1
	hotspot A, B/2, landingHeight, unID, A, 2 : unID = unID + 1
	hotspot -1, B/2, landingHeight, unID, A, 3 : unID = unID + 1
endif

hotspot A, B/2, 0, unID, landingHeight, 1 + 128 : unID = unID + 1
hotspot A, B/2, landingHeight, unID, landingHeight, 2 : unID = unID + 1
hotspot A, B/2, -1, unID, landingHeight, 3 : unID = unID + 1


! ==============================================================================
! Truss
! ==============================================================================

material matTruss

addy B
rotx 90

! Truss Cuting Points
tcx1 = A/2 - totalTreadLength/2
tcx2 = tcx1
if iObjectType = ESCALATOR then
	tcx3 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread)) - ((riserHeight + riserBegin - treadThk) / tan(inclination))
	tcx4 = tcx3
	tcx5 = A/2 + totalTreadLength/2 - (nLowerLandingTread - 1) * tread - tread * cos(asn(riserBegin/tread)) - ((riserHeight - riserBegin - treadThk) / tan(inclination))
	tcx6 = tcx5
else
	tcx3 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + treadThk * tan(riserBeginAngle/2)
	tcx4 = tcx3 + (treadThk * tan(riserBeginAngle/2) + tread + treadThk * tan((inclination - riserBeginAngle)/2)) * cos(riserBeginAngle)
	tcx6 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread + treadThk * tan(riserBeginAngle/2)
	tcx5 = tcx6 - (tread - treadThk * tan(riserBeginAngle/2) - treadThk * tan((inclination - riserBeginAngle)/2)) * cos(riserBeginAngle)
endif
tcx7 = A/2 + totalTreadLength/2
tcx8 = tcx7
tcx9 = A - landingLength
tcx10 = A - landingLength
tcx11 = A - landingLength
tcx12 = landingLength
tcx13 = landingLength

tcy1 = -0.02 + grooveDepth
if iObjectType = ESCALATOR then
	tcy2 = -0.02 - riserHeight
	tcy3 = -0.02 - riserHeight
	tcy4 = -0.02 - riserHeight
	tcy5 = landingHeight -0.02 - riserHeight
	tcy6 = landingHeight -0.02 - riserHeight
else
	tcy2 = -0.02 - treadThk
	tcy3 = -0.02 - treadThk
	tcy4 = tcy3 + (treadThk * tan(riserBeginAngle/2) + tread + treadThk * tan((inclination - riserBeginAngle)/2)) * sin(riserBeginAngle)
	tcy5 = landingHeight -0.02 - treadThk
	tcy6 = landingHeight -0.02 - treadThk
	tcy5 = tcy6 - (tread - treadThk * tan(riserBeginAngle/2) - treadThk * tan((inclination - riserBeginAngle)/2)) * sin(riserBeginAngle)
endif
tcy7 = tcy6
tcy8 = landingHeight - 0.02 + grooveDepth
tcy9 = tcy8
tcy10 = landingHeight - 0.02 + grooveDepth
tcy11 = landingHeight
tcy12 = landingHeight
tcy13 = tcy1

addz balustradeWidth
cutform 14, 1, 1 + 2,
	0, 0, 1, stepWidth,
	tcx1, tcy1, 31,
	tcx2, tcy2, 31,
	tcx3, tcy3, 31,
	tcx4, tcy4, 31,
	tcx5, tcy5, 31,
	tcx6, tcy6, 31,
	tcx7, tcy7, 31,
	tcx8, tcy8, 31,
	tcx9, tcy9, 31,
	tcx10, tcy10, 31,
	tcx11, tcy11, 31,
	tcx12, tcy12, 31,
	tcx13, tcy13, 31,
	tcx1, tcy1, -1
del 1

tbx1 = 0
if landingHeight > 0 then
	if landingHeight < landingHeightMin then
		tbx2 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread)) - ((riserBegin - 0.02) / tan(inclination)) - 0.02 / sin(inclination)
		tbx3 = tbx2
		tbx4 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread)) + ((riserBegin + 0.02) / tan(inclination)) - 0.02 / sin(inclination)
		tbx5 = tbx4
	else
		tbx2 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread)) - ((riserBegin - 0.02) / tan(inclination)) - 0.02 / sin(inclination)- trussLowerRad * tan(inclination/2)
		tbx3 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread)) - ((riserBegin - 0.02) / tan(inclination))  - 0.02 / sin(inclination)+ trussLowerRad * tan(inclination/2) * cos(inclination)
		tbx4 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread)) + ((riserBegin + 0.02) / tan(inclination)) - 0.02 / sin(inclination) - trussUpperRad * tan(inclination/2) * cos(inclination)
		tbx5 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread)) + ((riserBegin + 0.02) / tan(inclination)) - 0.02 / sin(inclination) + trussUpperRad * tan(inclination/2)
	endif
	tbx8 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread)) + ((riserBegin + 0.02) / tan(inclination)) - 0.02 / sin(inclination) + tan(inclination/2)
	tbx9 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread)) - ((riserBegin - 0.02) / tan(inclination)) - 0.02 / sin(inclination) + tan(inclination/2)
else
	tbx2 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread))
	tbx3 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread))
	tbx4 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread))
	tbx5 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread))
	tbx8 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread))
	tbx9 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread))
endif
tbx6 = A
tbx7 = A
tbx10 = 0
tbx11 = tbx1

tby1 = 0
if landingHeight > 0 then
	tby2 = 0
	if landingHeight < landingHeightMin then
		tby3 = 0
		tby4 = landingHeight
	else
		tby3 = trussLowerRad * tan(inclination/2) * sin(inclination)
		tby4 = landingHeight - trussUpperRad * tan(inclination/2) * sin(inclination)
	endif
	tby5 = landingHeight
	tby6 = landingHeight
else
	tby2 = 0
	tby3 = 0
	tby4 = 0
	tby5 = 0
	tby6 = 0
endif
tby7 = landingHeight - 1
tby8 = landingHeight - 1
tby9 = -1
tby10 = -1
tby11 = 0

prism_ 11, B,
	tbx1, tby1, 15,
	tbx2, tby2, 15 + 64,
	tbx3, tby3, 15 + 64 + maskMod,
	tbx4, tby4, 15 + 64,
	tbx5, tby5, 15 + 64 + maskMod,
	tbx6, tby6, 15,
	tbx7, tby7, 15,
	tbx8, tby8, 15 + maskMod2,
	tbx9, tby9, 15 + maskMod2,
	tbx10, tby10, 15,
	tbx11, tby11, -1

cutend

xCombPos = 0
yCombPos = 0
zCombPos = 0
combAngle = 0
gosub "Comb"

xCombPos = A
yCombPos = B
zCombPos = landingHeight
combAngle = 180
gosub "Comb"

del 2


! ==============================================================================
! Balustrade
! ==============================================================================

! Balustrade Footing Points
hfx1 = landingLength
if landingHeight > 0 then
	if landingHeight < landingHeightMin then
		hfx2 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread)) - ((riserBegin - 0.02) / tan(inclination)) - 0.02 / sin(inclination)
		hfx3 = hfx2
		hfx4 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread)) + ((riserBegin + 0.02) / tan(inclination)) - 0.02 / sin(inclination)
		hfx5 = hfx4
	else
		hfx2 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread)) - ((riserBegin - 0.02) / tan(inclination)) - 0.02 / sin(inclination) - trussLowerRad * tan(inclination/2)
		hfx3 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread)) - ((riserBegin - 0.02) / tan(inclination)) - 0.02 / sin(inclination) + trussLowerRad * tan(inclination/2) * cos(inclination)
		hfx4 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread)) + ((riserBegin + 0.02) / tan(inclination)) - 0.02 / sin(inclination) - trussUpperRad * tan(inclination/2) * cos(inclination)
		hfx5 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread)) + ((riserBegin + 0.02) / tan(inclination)) - 0.02 / sin(inclination) + trussUpperRad * tan(inclination/2)
	endif
else
	hfx2 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread))
	hfx3 = A/2 - totalTreadLength/2 + nLowerLandingTread * tread + tread * cos(asn(riserBegin/tread))
	hfx4 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread))
	hfx5 = A/2 + totalTreadLength/2 - nUpperLandingTread * tread - tread * cos(asn(riserBegin/tread))
endif
hfx6 = A - landingLength
hfx7 = hfx6
if landingHeight < landingHeightMin then
	hfx8 = hfx5 - balustradeFooting * tan(inclination/2)
	hfx9 = hfx8
	hfx10 = hfx2 - balustradeFooting * tan(inclination/2)
	hfx11 = hfx10
else
	hfx8 = hfx5
	hfx9 = hfx5 - (trussUpperRad + balustradeFooting) * sin(inclination)
	hfx10 = hfx2 + (trussLowerRad - balustradeFooting) * sin(inclination)
	hfx11 = hfx2
endif
hfx12 = hfx1

hfy1 = 0
hfy2 = 0
if landingHeight < landingHeightMin then
	hfy3 = 0
	hfy4 = landingHeight
else
	hfy3 = trussLowerRad * tan(inclination/2) * sin(inclination)
	hfy4 = landingHeight - trussUpperRad * tan(inclination/2) * sin(inclination)
endif
hfy5 = landingHeight
hfy6 = landingHeight
hfy7 = landingHeight + balustradeFooting
hfy8 = hfy7
if landingHeight < landingHeightMin then
	hfy9 = hfy7
	hfy10 = balustradeFooting
else
	hfy9 = hfy7 - (trussUpperRad + balustradeFooting) + (trussUpperRad + balustradeFooting) * cos(inclination)
	hfy10 = balustradeFooting + (trussLowerRad - balustradeFooting) - (trussLowerRad - balustradeFooting) * cos(inclination)
endif
hfy11 = balustradeFooting
hfy12 = hfy11

! Balustrade Points
hsx1 = hfx6
hsx2 = hsx1
if landingHeight < landingHeightMin then
	hsx3 = hfx5 - balustradeHeight * tan(inclination/2)
	hsx4 = hsx3
	hsx5 = hfx2 - balustradeHeight * tan(inclination/2)
	hsx6 = hsx5
else
	hsx3 = hfx5
	hsx4 = hfx5 - (trussUpperRad + balustradeHeight) * sin(inclination)
	hsx5 = hfx2 + (trussLowerRad - balustradeHeight) * sin(inclination)
	hsx6 = hfx2
endif

hsx7 = hfx1
hsx8 = hsx7

hsy1 = landingHeight + 0.1
hsy2 = landingHeight + balustradeHeight
hsy3 = hsy2
if landingHeight < landingHeightMin then
	hsy4 = hsy2
	hsy5 = balustradeHeight
else
	hsy4 = hsy2 - (trussUpperRad + balustradeHeight) + (trussUpperRad + balustradeHeight) * cos(inclination)
	hsy5 = balustradeHeight + (trussLowerRad - balustradeHeight) - (trussLowerRad - balustradeHeight) * cos(inclination)
endif
hsy6 = balustradeHeight
hsy7 = hsy6
hsy8 = 0.1

! Handrail (Rubber Band) Points
hrx1 = hfx6
hrx2 = hrx1
if landingHeight < landingHeightMin then
	hrx3 = hfx5 - (balustradeHeight + handrailRubberThk) * tan(inclination/2)
	hrx4 = hrx3
	hrx5 = hfx2 - (balustradeHeight + handrailRubberThk) * tan(inclination/2)
	hrx6 = hrx5
else
	hrx3 = hfx5
	hrx4 = hfx5 - (trussUpperRad + balustradeHeight + handrailRubberThk) * sin(inclination)
	hrx5 = hfx2 + (trussLowerRad - balustradeHeight - handrailRubberThk) * sin(inclination)
	hrx6 = hfx2
endif
hrx7 = hfx1
hrx8 = hrx7

hry1 = landingHeight + 0.1 - handrailRubberThk
hry2 = landingHeight + balustradeHeight + handrailRubberThk
hry3 = hry2
if landingHeight < landingHeightMin then
	hry4 = hry2
	hry5 = balustradeHeight + handrailRubberThk
else
	hry4 = hry2 - (trussUpperRad + balustradeHeight + handrailRubberThk) + (trussUpperRad + balustradeHeight + handrailRubberThk) * cos(inclination)
	hry5 = balustradeHeight + handrailRubberThk + (trussLowerRad - balustradeHeight - handrailRubberThk) - (trussLowerRad - balustradeHeight - handrailRubberThk) * cos(inclination)
endif
hry6 = balustradeHeight + handrailRubberThk
hry7 = hry6
hry8 = 0.1 - handrailRubberThk

for nBal = 1 to 2
	if iBalustradeType = BALUSTRADE_SOLID then
		addy balustradeWidth
		rotx 90
		material matBalustrade
		prism_ 16, balustradeWidth,
			hfx1, hfy1, 15,
			hfx2, hfy2, 15 + 64,
			hfx3, hfy3, 15 + 64 + maskMod,
			hfx4, hfy4, 15 + 64,
			hfx5, hfy5, 15 + 64 + maskMod,
			hfx6, hfy6, 15,

			hsx1, hsy1, 15 + 64,
			1, 0, 800,
			hsx2, hsy2, 1015 + 64,
			hsx3, hsy3, 15 + 64,
			hsx4, hsy4, 15 + 64 + maskMod,
			hsx5, hsy5, 15 + 64,
			hsx6, hsy6, 15 + 64 + maskMod,
			hsx7, hsy7, 15 + 64,
			hsx8, hsy8, 1015,

			hfx1, hfy1, -1
		del 2
	else
		addy balustradeWidth
		rotx 90
		material matTruss
		prism_ 13, balustradeWidth,
			hfx1, hfy1, 15,
			hfx2, hfy2, 15 + 64,
			hfx3, hfy3, 15 + 64 + maskMod,
			hfx4, hfy4, 15 + 64,
			hfx5, hfy5, 15 + 64 + maskMod,
			hfx6, hfy6, 15,
			hfx7, hfy7, 15,
			hfx8, hfy8, 15 + 64,
			hfx9, hfy9, 15 + 64 + maskMod,
			hfx10, hfy10, 15 + 64,
			hfx11, hfy11, 15 + 64 + maskMod,
			hfx12, hfy12, 15,
			hfx1, hfy1, -1
		del 2

		addy balustradeWidth/2 + balustradeGlassWidth/2
		rotx 90
		material matGlass
		prism_ 16, balustradeGlassWidth,
			hfx12, hfy12, 15,
			hfx11, hfy11, 15 + 64,
			hfx10, hfy10, 15 + 64 + maskMod,
			hfx9, hfy9, 15 + 64,
			hfx8, hfy8, 15 + 64 + maskMod,
			hfx7, hfy7, 15,

			hsx1, hsy1, 15 + 64,
			1, 0, 800,
			hsx2, hsy2, 1015 + 64,
			hsx3, hsy3, 15 + 64,
			hsx4, hsy4, 15 + 64 + maskMod,
			hsx5, hsy5, 15 + 64,
			hsx6, hsy6, 15 + 64 + maskMod,
			hsx7, hsy7, 15 + 64,
			hsx8, hsy8, 1015,

			hfx12, hfy12, -1
		del 2
	endif

	addy balustradeWidth/2 + handrailRubberWidth/2
	rotx 90
	material matHandrailRubber
	prism_ 19, handrailRubberWidth,
		hsx1, hsy1, 15 + 64,
		1, 0, 800,
		hsx2, hsy2, 1015 + 64,
		hsx3, hsy3, 15 + 64,
		hsx4, hsy4, 15 + 64 + maskMod,
		hsx5, hsy5, 15 + 64,
		hsx6, hsy6, 15 + 64 + maskMod,
		hsx7, hsy7, 15 + 64,
		hsx8, hsy8, 1015,

		hrx8, hry8, 15 + 64,
		-1, 0, 800,
		hrx7, hry7, 1015 + 64,
		hrx6, hry6, 15 + 64,
		hrx5, hry5, 15 + 64 + maskMod,
		hrx4, hry4, 15 + 64,
		hrx3, hry3, 15 + 64 + maskMod,
		hrx2, hry2, 15 + 64,
		hrx1, hry1, 1015,

		hsx1, hsy1, -1
	del 2
addy B - balustradeWidth
next nBal
del 2


! ==============================================================================
! Treads
! ==============================================================================

resol gs_resol
material matTread
add A/2 - totalTreadLength/2, 0, -0.02
for hi = 1 to nTread + (nLowerLandingTread + nUpperLandingTread) * (landingHeight > 0)
	xTread = tread * cos(asn(riser/tread))
	zTread = riser
	treadAngle = 0
	closingAngle = inclination
	if iObjectType = ESCALATOR then
		if hi = 1 | hi = 2 | hi = nTread + 3 | hi = nTread + 4 | hi = nTread + 5 | hi = nTread + 6 then
			xTread = tread
			zTread = 0
			treadAngle = 0
			closingAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
		endif
		if hi = 3 then
			xTread = tread * cos(asn(riserBegin/tread))
			zTread = riserBegin
			treadAngle = 0
			closingAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
		endif
		if hi = 4 then
			if iObjectType = MOVING_WALKWAY then treadAngle = acs(riserBegin/tread)*0	+ acs(tread * cos(asn(riserBegin/tread))/tread)
			closingAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
		endif
		if hi = nTread + 2 then
			xTread = tread * cos(asn(riserBegin/tread))
			zTread = riserBegin
		endif
		if hi = nTread + 3 then
			if iObjectType = MOVING_WALKWAY then treadAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
			closingAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
		endif
	else
		treadAngle = inclination
		if hi < nLowerLandingTread then
			xTread = tread
			zTread = 0
			treadAngle = 0
			closingAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
		endif
		if hi = nLowerLandingTread then
			xTread = tread * cos(asn(riserBegin/tread))
			zTread = riserBegin
			treadAngle = 0
			closingAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
		endif
		if hi = nLowerLandingTread + 1 | hi = nLowerLandingTread + nTread then
			xTread = tread * cos(asn(riser/tread))
			zTread = riser
			treadAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
			closingAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
		endif
		if hi = nLowerLandingTread + nTread - 1 then
			xTread = tread * cos(asn(riserBegin/tread))
			zTread = riserBegin
		endif
		if hi = nLowerLandingTread + nTread then
			xTread = tread
			zTread = 0
			treadAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
			closingAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
		endif
		if hi > nLowerLandingTread + nTread then
			xTread = tread
			zTread = 0
			treadAngle = 0
			closingAngle = acs(tread * cos(asn(riserBegin/tread))/tread)
		endif
	endif
	gosub "tread"
	add xTread, 0, zTread
next hi
del nTread + (nLowerLandingTread + nUpperLandingTread) * (landingHeight > 0) + 1

end


"tread":

add tread, (B - balustradeWidth), 0
rotx 90
rotz treadAngle

if gs_detlevel_3D_m = 2 & GLOB_CONTEXT <> 5 then
!	nGroove = int(stepWidth/grooveWidth/4) + 1
	nGroove = int(int((stepWidth - grooveWidth)/grooveWidth)/2)

	addz stepWidth/2
	roty 90
	for hj = 1 to 2
	for iGroove = 1 to nGroove
		cutform 5, 1, 1 + 2 + 8 + 16,
			0, 0, 1, 1,
			grooveWidth/2, 0, 31,
			3*grooveWidth/2, 0, 31,
			3*grooveWidth/2, grooveDepth, 31,
			grooveWidth/2, grooveDepth, 31,
			grooveWidth/2, 0, -1
		addx 2 * grooveWidth
	next iGroove
	del nGroove
	mulx -1
	next hj
	del 2
	del 2

	roty -90
	cutplane 225
	del 1
	addx -tread
	roty -90
	cutplane 315
	del 2
endif

if iObjectType = ESCALATOR then
	prism_ 8, stepWidth,
		0, grooveDepth, 15,
		0, -treadThk, 15,
		-tread * cos(riserAngle), -tread * sin(riserAngle), 15,
		-tan(riserAngle), 1, 800,
		-tread * cos(closingAngle), -tread * sin(closingAngle), 1015,
		-tread, 0, 1015,
		-tread, grooveDepth, 15,
		0, grooveDepth, 15
endif
if iObjectType = MOVING_WALKWAY then
	prism_ 7, stepWidth,
		-grooveDepth, grooveDepth, 15,
		0, 0, 15,
		-treadThk * tan(15), -treadThk, 15,
		-tread + treadThk * tan(15), -treadThk, 15,
		-tread, 0, 15,
		-tread + grooveDepth, grooveDepth, 15,
		-grooveDepth, grooveDepth, -1
endif

if gs_detlevel_3D_m = 2  & GLOB_CONTEXT <> 5 then
	cutend
	cutend
	for iGroove = 1 to nGroove * 2
		cutend
	next iGroove
endif

del 1

del 2

return


"Comb":

add xCombPos, zCombPos, yCombPos
roty combAngle

if gs_detlevel_3D_m = 2  & GLOB_CONTEXT <> 5 then
	nGroove = int(int((stepWidth - grooveWidth)/grooveWidth)/2)

	add A/2 - totalTreadLength/2, -0.02, 0

	addz stepWidth/2 + balustradeWidth
	roty 90
	for hk = 1 to 2
	for iGroove = 1 to nGroove
		cutform 5, 1, 1 + 2,
			0, 0, 1, landingLength + comblength - (A - totalTreadLength)/2,
			-grooveWidth/2, 0, 31,
			grooveWidth/2, 0, 31,
			grooveWidth/2, grooveDepth, 31,
			-grooveWidth/2, grooveDepth, 31,
			-grooveWidth/2, 0, -1
		addx 2 * grooveWidth
	next iGroove
	del nGroove
	mulx -1
	next hk
	del 2
	del 2
	del 1
endif

addz balustradeWidth
prism_ 4, B - 2 * balustradeWidth,
	landingLength, -0.02, 15,
	landingLength + combLength, -0.02, 15,
	landingLength, 0, 15,
	landingLength, -0.02, -1
del 1

if gs_detlevel_3D_m = 2 then
	for iGroove = 1 to nGroove * 2
		cutend
	next iGroove
endif
del 2

return


]]>
</Script_3D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_2D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! ==============================================================================
! escalator_m
! ==============================================================================


call "2dDetailLevel" parameters gs_detlevel_2D_m = gs_detlevel_2D_m,
				returned_parameters det2D

if inclination > 0 then
	nLowerTread = int(GLOB_CUTPLANES_INFO[1]/riser)
	if nLowerTread > nTread - 4 then nLowerTread = nTread - 4
else
	nLowerTread = 5
endif

if abs(inclination) < eps then bShowBreakline = 0
breaklineAngle = atn((tread * cos(asn(riser/tread)) - 0.05)/stepWidth)
breaklineDist = 0.1

HOTSPOT2 0, 0, unID, xBreaklinePos, 1+128: unID=unID+1
HOTSPOT2 xBreaklinePos, 0, unID, xBreaklinePos, 2: unID=unID+1

!xBreaklinePos = A/2 - totalTreadLength/2 + 2 * tread + tread * cos(asn(riserBegin/tread)) + (nLowerTread - 1) * tread * cos(asn(riser/tread)) - balustradeWidth * tan(breaklineAngle)
!if xBreaklinePos < landingLength + 2 * combLength then xBreaklinePos = landingLength + 2 * combLength

railMod = balustradeRadius
if iBalustradeType = BALUSTRADE_GLAZED & det2D = DET2D_DETAILED then railMod = 0
bRubber = 1
if det2D = DET2D_DETAILED then bRubber = 0

pen gs_cont_pen
fill gs_fill_type

unID = 1
hotspot2 0, 0, unID : unID = unID + 1
hotspot2 0, B/2, unID : unID = unID + 1
hotspot2 0, B, unID : unID = unID + 1
hotspot2 A, B, unID : unID = unID + 1
hotspot2 A, B/2, unID : unID = unID + 1
hotspot2 A, 0, unID : unID = unID + 1
hotspot2 landingLength, B, unID : unID = unID + 1
hotspot2 landingLength, 0, unID : unID = unID + 1
hotspot2 A - landingLength, B, unID : unID = unID + 1
hotspot2 A - landingLength, 0, unID : unID = unID + 1
hotspot2 A/2, B/2, unID

if bStorySensitive then
	if GLOB_CSTORY_ELEV > GLOB_HSTORY_ELEV then
		if bShowBreaklineUp then
			if bShowLower2D then
				poly2_b 5, 2+64, gs_fill_pen, gs_back_pen,
					xBreaklinePos, 0, 0,
					xBreaklinePos + breaklineDist, 0, 0,
					xBreaklinePos + B * tan(breaklineAngle) + breaklineDist, B, 0,
					xBreaklinePos + B * tan(breaklineAngle), B, 0,
					xBreaklinePos, 0, -1
				bBreakline = 1
				ltStair = 1
				gosub "LowerStair"
			endif

			bBreakline = 1
			ltStair = 1
			gosub "UpperStair"
		else
			bBreakline = 0
			ltStair = 1
			gosub "LowerStair"
			gosub "UpperStair"
		endif
	endif
	if GLOB_CSTORY_ELEV < GLOB_HSTORY_ELEV then
		bBreakline = 0
		ltStair = ltOverhead
		gosub "LowerStair"
		gosub "UpperStair"
	endif
endif

if not(bStorySensitive) | (bStorySensitive & abs(GLOB_CSTORY_ELEV - GLOB_HSTORY_ELEV) < eps) then
	if bShowBreakline then
		bBreakline = 1
		if bShowOverhead then
			poly2_b 5, 2+64, gs_fill_pen, gs_back_pen,
				xBreaklinePos, 0, 0,
				xBreaklinePos + breaklineDist, 0, 0,
				xBreaklinePos + B * tan(breaklineAngle) + breaklineDist, B, 0,
				xBreaklinePos + B * tan(breaklineAngle), B, 0,
				xBreaklinePos, 0, -1

			ltStair = ltOverhead
			gosub "UpperStair"
		endif

		ltStair = 1
		gosub "LowerStair"
	else
		bBreakline = 0
		ltStair = 1
		gosub "LowerStair"
		gosub "UpperStair"
	endif
endif


! ==============================================================================
! Up and Down text
! ==============================================================================

if walkingDirUPDN_m then
	dim stWText[2]
		stWText[1] = `ВВЕРХ`
		stWText[2] = `ВНИЗ`

	define style "UPDN" fontType, UPDNfontsize, 5, 1		  	!!- UP/DN
	UPDNheigth = 0
	rrr = request("Height_of_style", "UPDN", UPDNheigth)
	UPDNheigth = UPDNheigth / 1000 * GLOB_SCALE
	set style "UPDN"
	pen UPDNfontpen

	UPDNx=0
	if walkingDirUPDN_m = 1 then	! UP
		UPDNText = stWText[1]
	else
		if walkingDirUPDN_m = 3 then
			UPDNx = a
		endif
		UPDNText = stWText[2]
	endif
	UPDNwidth = STW ((UPDNText+"  ")) / 1000 * GLOB_SCALE

	! --- Oriented View ------------------------------ [
	angleViewRot = 0
	rrr = REQUEST ("View_Rotangle", "", angleViewRot)
	totalRotate = (SYMB_ROTANGLE + angleViewRot) MOD 360
	! --- Oriented View ------------------------------ ]

	iReadable = 0
	gs_readable_angle = 0
	rotateUPDN = 0
	! Text Rotation - Readable / Parallel with Walking Line / Align with Symbol
	! ----------------------------------------------------------------------
	if UPDNx > EPS then
		UPDNTextOffset = UPDNheigth/2
	else
		UPDNTextOffset = -UPDNheigth/2
	endif
	if typeTextRotation_UpDn_m = 1 then									! Readable
		if (totalRotate > (gs_readable_angle + eps) & totalRotate < (gs_readable_angle + 180 + eps)) then
			rotateUPDN = -180
		endif
		if SYMB_MIRRORED then rotateUPDN=rotateUPDN-180
	else
		if typeTextRotation_UpDn_m = 2 then								! Parallel with Walking Line
			gs_readable_angle = 180
			iReadable = (totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps))- not(totalRotate > (gs_readable_angle - 90 + eps) & totalRotate < (gs_readable_angle + 180 - 90 + eps))

			rotateUPDN = 90 * iReadable

			if UPDNx > EPS then
				UPDNTextOffset = UPDNwidth/2
			else
				UPDNTextOffset = -UPDNwidth/2
			endif
		else
			rotateUPDN = 180
		endif
	endif

	add2 UPDNx+UPDNTextOffset, B/2
	rot2 rotateUPDN+90
	text2 0, 0, UPDNText
	del 2
endif

end


"LowerStair":

line_type ltStair

poly2_b 5, 1+2+64, gs_fill_pen, gs_back_pen,
	0, 0, 1,
	xBreaklinePos + breaklineDist * not(bBreakLine), 0, bBreakline,
	xBreaklinePos + B * tan(breaklineAngle) + breaklineDist * not(bBreakLine), B, 1,
	0, B, 1,
	0, 0, -1

poly2_b 7, 1, gs_fill_pen, gs_back_pen,
	landingLength - railMod, 0, 0,
	xBreaklinePos + breaklineDist * not(bBreakLine), 0, 0,
	xBreaklinePos + balustradeWidth * tan(breaklineAngle) + breaklineDist * not(bBreakLine), balustradeWidth, 1,
	landingLength - railMod, balustradeWidth, 1,
	landingLength - railMod, balustradeWidth/2 + handrailRubberWidth/2, bRubber,
	landingLength - railMod, balustradeWidth/2 - handrailRubberWidth/2, 1,
	landingLength - railMod, 0, -1

poly2_b 7, 1, gs_fill_pen, gs_back_pen,
	landingLength - railMod, B - balustradeWidth, 1,
	xBreaklinePos + (B - balustradeWidth) * tan(breaklineAngle) + breaklineDist * not(bBreakLine), B - balustradeWidth, 0,
	xBreaklinePos + B * tan(breaklineAngle) + breaklineDist * not(bBreakLine), B, 0,
	landingLength - railMod, B, 1,
	landingLength - railMod, B - balustradeWidth/2 + handrailRubberWidth/2, bRubber,
	landingLength - railMod, B - balustradeWidth/2 - handrailRubberWidth/2, 1,
	landingLength - railMod, B - balustradeWidth, -1

if det2D = DET2D_DETAILED then
	poly2_b 5, 1, gs_fill_pen, gs_back_pen,
		landingLength - balustradeRadius - handrailRubberThk, balustradeWidth/2 - handrailRubberWidth/2, 1,
		xBreaklinePos + (balustradeWidth/2 - handrailRubberWidth/2) * tan(breaklineAngle) + breaklineDist * not(bBreakLine), balustradeWidth/2 - handrailRubberWidth/2, 0,
		xBreaklinePos + (balustradeWidth/2 + handrailRubberWidth/2) * tan(breaklineAngle) + breaklineDist * not(bBreakLine), balustradeWidth/2 + handrailRubberWidth/2, 1,
		landingLength - balustradeRadius - handrailRubberThk, balustradeWidth/2 + handrailRubberWidth/2, 1,
		landingLength - balustradeRadius - handrailRubberThk, balustradeWidth/2 - handrailRubberWidth/2, -1

	poly2_b 5, 1, gs_fill_pen, gs_back_pen,
		landingLength - balustradeRadius - handrailRubberThk, B - balustradeWidth/2 - handrailRubberWidth/2, 1,
		xBreaklinePos + (B - balustradeWidth/2 - handrailRubberWidth/2) * tan(breaklineAngle) + breaklineDist * not(bBreakLine), B - balustradeWidth/2 - handrailRubberWidth/2, 0,
		xBreaklinePos + (B - balustradeWidth/2 + handrailRubberWidth/2) * tan(breaklineAngle) + breaklineDist * not(bBreakLine), B - balustradeWidth/2 + handrailRubberWidth/2, 1,
		landingLength - balustradeRadius - handrailRubberThk, B - balustradeWidth/2 + handrailRubberWidth/2, 1,
		landingLength - balustradeRadius - handrailRubberThk, B - balustradeWidth/2 - handrailRubberWidth/2, -1
endif

if (det2D = DET2D_DETAILED | det2D = DET2D_MIDDLE) then
	line2 landingLength, balustradeWidth, landingLength, B - balustradeWidth
endif

if (det2D = DET2D_DETAILED | det2D = DET2D_MIDDLE) & iObjectType = ESCALATOR then
	nShowTreadBegin = 1
	if totalTreadLength - 2 * tread > A - 2 * (landingLength + combLength) then
		nShowTreadBegin = 2
	endif
	nShowTreadLast = int((xBreaklinePos)/(tread * cos(asn(riser/tread))))-1
	gosub "Tread"
endif
line2 landingLength + combLength, balustradeWidth, landingLength + combLength, B - balustradeWidth
line2 landingLength + combLength, B/2, xBreaklinePos + B/2 * tan(breaklineAngle) + breaklineDist * not(bBreakLine), B/2

return


"UpperStair":

line_type ltStair

poly2_b 5, 1+2+64, gs_fill_pen, gs_back_pen,
	A, 0, 1,
	xBreaklinePos + breaklineDist, 0, bBreakline,
	xBreaklinePos + B * tan(breaklineAngle) + breaklineDist, B, 1,
	A, B, 1,
	A, 0, -1

poly2_b 7, 1, gs_fill_pen, gs_back_pen,
	A - landingLength + railMod, 0, 0,
	xBreaklinePos + breaklineDist, 0, 0,
	xBreaklinePos + balustradeWidth * tan(breaklineAngle) + breaklineDist, balustradeWidth, 1,
	A - landingLength + railMod, balustradeWidth, 1,
	A - landingLength + railMod, balustradeWidth/2 + handrailRubberWidth/2, bRubber,
	A - landingLength + railMod, balustradeWidth/2 - handrailRubberWidth/2, 1,
	A - landingLength + railMod, 0, -1

poly2_b 7, 1, gs_fill_pen, gs_back_pen,
	A - landingLength + railMod, B - balustradeWidth, 1,
	xBreaklinePos + (B - balustradeWidth) * tan(breaklineAngle) + breaklineDist, B - balustradeWidth, 0,
	xBreaklinePos + B * tan(breaklineAngle) + breaklineDist, B, 0,
	A - landingLength + railMod, B, 1,
	A - landingLength + railMod, B - balustradeWidth/2 + handrailRubberWidth/2, bRubber,
	A - landingLength + railMod, B - balustradeWidth/2 - handrailRubberWidth/2, 1,
	A - landingLength + railMod, B - balustradeWidth, -1

if det2D = DET2D_DETAILED then
	poly2_b 5, 1, gs_fill_pen, gs_back_pen,
		A - landingLength + balustradeRadius + handrailRubberThk, balustradeWidth/2 - handrailRubberWidth/2, 1,
		xBreaklinePos + (balustradeWidth/2 - handrailRubberWidth/2) * tan(breaklineAngle) + breaklineDist, balustradeWidth/2 - handrailRubberWidth/2, 0,
		xBreaklinePos + (balustradeWidth/2 + handrailRubberWidth/2) * tan(breaklineAngle) + breaklineDist, balustradeWidth/2 + handrailRubberWidth/2, 1,
		A - landingLength + balustradeRadius + handrailRubberThk, balustradeWidth/2 + handrailRubberWidth/2, 1,
		A - landingLength + balustradeRadius + handrailRubberThk, balustradeWidth/2 - handrailRubberWidth/2, -1

	poly2_b 5, 1, gs_fill_pen, gs_back_pen,
		A - landingLength + balustradeRadius + handrailRubberThk, B - balustradeWidth/2 - handrailRubberWidth/2, 1,
		xBreaklinePos + (B - balustradeWidth/2 - handrailRubberWidth/2) * tan(breaklineAngle) + breaklineDist, B - balustradeWidth/2 - handrailRubberWidth/2, 0,
		xBreaklinePos + (B - balustradeWidth/2 + handrailRubberWidth/2) * tan(breaklineAngle) + breaklineDist, B - balustradeWidth/2 + handrailRubberWidth/2, 1,
		A - landingLength + balustradeRadius + handrailRubberThk, B - balustradeWidth/2 + handrailRubberWidth/2, 1,
		A - landingLength + balustradeRadius + handrailRubberThk, B - balustradeWidth/2 - handrailRubberWidth/2, -1
endif

if (det2D = DET2D_DETAILED | det2D = DET2D_MIDDLE) then
	line2 A - landingLength, balustradeWidth, A - landingLength, B - balustradeWidth
endif

if (det2D = DET2D_DETAILED | det2D = DET2D_MIDDLE)  & iObjectType = ESCALATOR then
!	nShowTreadBegin = nLowerTread + 3
	nShowTreadBegin = int((xBreaklinePos)/(tread * cos(asn(riser/tread))))
	nShowTreadLast = nTread + 3 + nUpperLandingTread
	arrowMod = 1
	if totalTreadLength - 2 * tread > A - 2 * (landingLength + combLength) then
		nShowTreadLast = nTread + 3 + nUpperLandingTread - 1
		arrowMod = 2
	endif
	gosub "Tread"

endif
line2 A - landingLength - combLength, balustradeWidth, A - landingLength - combLength, B - balustradeWidth
line2 A - landingLength - combLength, B/2, xBreaklinePos + B/2 * tan(breaklineAngle) + breaklineDist, B/2

line2 A - landingLength - combLength - tread, balustradeWidth, A - landingLength - combLength, B/2
line2 A - landingLength - combLength - tread, B - balustradeWidth, A - landingLength - combLength, B/2

return


"Tread":
add2 A/2 - totalTreadLength/2, balustradeWidth
for hi = 1 to nTread + 3 + nUpperLandingTread

	xTread = tread * cos(asn(riser/tread))
	zTread = riser
	treadAngle = 0
	if hi = 1 | hi = 2 | hi = nTread + 3 | hi = nTread + 4 | hi = nTread + 5 | hi = nTread + 6 then
		xTread = tread
	endif
	if hi = 3 then
		xTread = tread * cos(asn(riserBegin/tread))
	endif
	if hi = nTread + 2 then
		xTread = tread * cos(asn(riserBegin/tread))
	endif

	if hi > nShowTreadBegin & hi <= nShowTreadLast then
		line2 0, 0, 0, stepWidth
	endif

	add2 xTread, 0
next hi
del nTread + 3 + nUpperLandingTread + 1

return

]]>
</Script_2D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_1D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! ==============================================================================
! escalator_m
! ==============================================================================


EPS=0.0001

DET2D_OFF			= 0
DET2D_SIMPLE		= 1
DET2D_MIDDLE		= 2
DET2D_DETAILED		= 3

ESCALATOR = 1
MOVING_WALKWAY = 2

! iBalustradeType
BALUSTRADE_SOLID	= 1
BALUSTRADE_GLAZED	= 2

balustradeWidth = 0.18
balustradeHeight = 1
balustradeGlassWidth = 0.012
handrailRubberWidth = 0.08
handrailRubberThk = 0.03
balustradeRadius = 0.45
combLength = 0.4
trussLowerRadMin = 1.23
trussUpperRadMin = 0.2
landingHeightMin = trussLowerRadMin * (1 - cos(inclination)) + trussUpperRadMin * (1 - cos(inclination)) + 0.01

if iObjectType = ESCALATOR then
	if GLOB_MODPAR_NAME = "inclination" then
		riser = tread * sin(inclination)
		parameters riser = riser
	else
		if riser > tread then
			riser = tread * sin(inclination)
			parameters riser = riser
		endif
		inclination = asn(riser/tread)
		parameters inclination = inclination
	endif
else
	riser = tread * sin(inclination)
	parameters riser = riser
endif
if landingHeight > 0 then
	if (landingHeight - (int(landingHeight/riser)-1)*riser)/2 > riser*0.75 then
		nTread = int(landingHeight/riser) + 2
	else
		nTread = int(landingHeight/riser) + 1
	endif
	if nTread < 2 then nTread = 2

	riserBegin = (landingHeight - (nTread - 2) * riser) / 2
	if iObjectType = ESCALATOR then
		totalTreadLength = 5 * tread + 2 * tread * cos(asn(riserBegin/tread)) + (nTread - 2) * tread * cos(asn(riser/tread))
		nLowerLandingTread = 3
		nUpperLandingTread = 2
	else
		inclTreadLength = 2 * tread * cos(asn(riserBegin/tread)) + (nTread - 2) * tread * cos(asn(riser/tread))
		nLowerLandingTread = int((A - 2 * landingLength - inclTreadLength) / (2 * tread))
		if 2 * nLowerLandingTread * tread + 2 * tread * cos(asn(riserBegin/tread)) + (nTread - 2) * tread * cos(asn(riser/tread)) < A - 2 * landingLength - combLength then
			nLowerLandingTread = int((A - 2 * landingLength - inclTreadLength) / (2 * tread)) + 1
		endif
		nUpperLandingTread = nLowerLandingTread
		totalTreadLength = (nLowerLandingTread + nUpperLandingTread) * tread + 2 * tread * cos(asn(riserBegin/tread)) + (nTread - 2) * tread * cos(asn(riser/tread))
	endif
else
	inclination = 0
	riser = 0
	hideparameter "inclination"
	lock "inclination"
	nTread = int((A - 2 * landingLength)/tread)
	riserBegin = 0
	totalTreadLength = nTread * tread
	nLowerLandingTread = 3
	nUpperLandingTread = 3
endif
]]>
</Script_1D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_VL SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
! ==============================================================================
! escalator_m
! ==============================================================================


values "xBreaklinePos" range (landingLength + 2 * combLength, A-(landingLength + 2 * combLength))

dim stDetail[3]
	stDetail[1]=`Детальный`
	stDetail[2]=`Простой`
	stDetail[3]=`Откл.`

values "gs_detlevel_3D" stDetail
values "gs_detlevel_3D_m" 0, 1, 2

if GLOB_MODPAR_NAME = "gs_detlevel_3D" then
	gs_detlevel_3D_m = 2	! Detailed
	if gs_detlevel_3D = stDetail[2] then gs_detlevel_3D_m = 1
	if gs_detlevel_3D = stDetail[3] then gs_detlevel_3D_m = 0
	parameters gs_detlevel_3D_m = gs_detlevel_3D_m
else
	gs_detlevel_3D = stDetail[1]
	if gs_detlevel_3D_m = 0 then gs_detlevel_3D = stDetail[3]
	if gs_detlevel_3D_m = 1 then gs_detlevel_3D = stDetail[2]
	parameters gs_detlevel_3D = gs_detlevel_3D
endif


dim stBalustradeType[2]
	stBalustradeType[1] = `Сплошной`
	stBalustradeType[2] = `Стекло`

values{2} "iBalustradeType"	1, stBalustradeType[1],
							2, stBalustradeType[2]

if iBalustradeType = BALUSTRADE_SOLID then
	lock "matGlass"
	hideparameter "matGlass"
endif
if iBalustradeType = BALUSTRADE_GLAZED then
	lock "matBalustrade"
	hideparameter "matBalustrade"
endif

IF gs_cont_pen=0 THEN PARAMETERS gs_cont_pen=2
IF gs_fill_pen=0 THEN PARAMETERS gs_fill_pen=91

IF gs_detlevel_3D_m = 1 then
	lock "gs_resol"
	hideparameter "gs_resol"
else
	values "gs_resol" range [6, )
endif

call "2dDetailLevel" parameters gs_detlevel_2D	= gs_detlevel_2D,
							gs_detlevel_2D_m	= gs_detlevel_2D_m,
							enable2dDetLevels	= 2 + 4 + 8 + 16

if bShowBreakline = 0 then
	hideparameter "bShowOverhead", "ltOverhead"
	lock "bShowOverhead", "ltOverhead"
endif
if bStorySensitive = 0 then
	hideparameter "aboveHomeStory"
	lock "aboveHomeStory"
endif
if GLOB_MODPAR_NAME = "stepWidth" then
	B = stepWidth + 2 * balustradeWidth
	parameters B = B
else
	stepWidth = B - 2 * balustradeWidth
	parameters stepWidth = stepWidth
endif

values "B" range [1, )
values "tread" range [0.2, 0.6]
if iObjectType = ESCALATOR then
	values "A" range [totalTreadLength + 2 * landingLength - 3 * tread + 2 * combLength, totalTreadLength + 2 * landingLength - tread + 2 * combLength]
	values "landingHeight" range [ceil(10*(trussLowerRadMin * (1 - cos(inclination)) + trussUpperRadMin * (1 - cos(inclination)) + 0.1))/10, )
	values "riser" range [tread * sin(20), tread * sin(45)]
	values "inclination" range (20, 45]
endif
if iObjectType = MOVING_WALKWAY then
	if landingHeight > 0 then
		if GLOB_MODPAR_NAME = "A" | GLOB_MODPAR_NAME = "landingHeight"  then
			inclination = atn(landingHeight / (A - 2 * landingLength - 8 * tread))
			riser = tread * sin(inclination)
			parameters inclination = inclination, riser = riser
		endif

		if A < 2 * landingLength + 8 * tread + landingHeight / tan(20) then
			A = 2 * landingLength + 8 * tread + landingHeight / tan(20)
			parameters A = A
		endif
	else
		values "A" range [2 * landingLength + 8 * tread, )
		hideparameter "bShowBreakline", "bShowOverhead", "ltOverhead", "aboveHomeStory", "bShowBreaklineUp", "bShowLower2D"
		lock "bShowBreakline", "bShowOverhead", "ltOverhead", "aboveHomeStory", "bShowBreaklineUp", "bShowLower2D"
	endif
	if GLOB_MODPAR_NAME = "inclination" then
		A = 2 * landingLength + inclTreadLength + 8 * tread
		parameters A = A
		if 2 * landingLength + 8 * tread + landingHeight / tan(inclination) > 100 then
			inclination = atn(landingHeight / (100 - 2 * landingLength - 8 * tread))
			parameters inclination = inclination
		endif
	endif
	values "landingHeight" range [0, )
	values "riser" range [0, tread * sin(20)]
	values "inclination" range (0, 20]
	lock "riser"
endif
ZZYZX = 1 + landingHeight + balustradeHeight + handrailRubberThk
parameters ZZYZX = ZZYZX
lock "ZZYZX"

if bShowBreaklineUp = 0 then
	lock "bShowLower2D"
	hideparameter "bShowLower2D"
endif

parameters gs_FontSize= abs(gs_FontSize)
values "gs_FontSize" range (0,]


dim stWalking[4]
	stWalking[1] = `Нет`
	stWalking[2] = `Вверх`
	stWalking[3] = `Вниз в Нижней Части`
	stWalking[4] = `Вниз в Верхней Части`

dim stTextOrientation[3]
	stTextOrientation[1] = `Читаемый`
	stTextOrientation[2] = `Параллельно Основной Линии`
	stTextOrientation[3] = `Выровнять по Символу`

values "walkingDirUPDN" stWalking
values "walkingDirUPDN_m" 0,1,2,3
values "typeTextRotation_UpDn" stTextOrientation
values "typeTextRotation_UpDn_m" 1,2,3

values "UPDNfontsize" RANGE (0,)

if GLOB_MODPAR_NAME = "walkingDirUPDN" then
	walkingDirUPDN_m = 0
	for iWalk = 2 to vardim1(stWalking)
		if walkingDirUPDN = stWalking[iWalk] then walkingDirUPDN_m = iWalk - 1
	next iWalk
	parameters walkingDirUPDN_m = walkingDirUPDN_m
else
	walkingDirUPDN_m = max(min(walkingDirUPDN_m,3),0)
	parameters walkingDirUPDN = stWalking[walkingDirUPDN_m+1]
endif

if GLOB_MODPAR_NAME = "typeTextRotation_UpDn" then
	typeTextRotation_UpDn_m = 3
	for i = 1 to vardim1(stTextOrientation)
		if typeTextRotation_UpDn = stTextOrientation[i] then	typeTextRotation_UpDn_m = i
	next i
	parameters typeTextRotation_UpDn_m = typeTextRotation_UpDn_m
else
	typeTextRotation_UpDn_m = max(min(typeTextRotation_UpDn_m,3),1)
	parameters typeTextRotation_UpDn = stTextOrientation[typeTextRotation_UpDn_m]
endif

if not(walkingDirUPDN_m) then hideparameter "UPDNfontsize", "typeTextRotation_UpDn", "UPDNfontpen"

AC_show2DHotspotsin3D = 0
parameters AC_show2DHotspotsin3D = AC_show2DHotspotsin3D
parameters ac_bottomlevel	= 0
parameters ac_toplevel 		= landingHeight


! =============================================================================
! IFC Parameters
! =============================================================================

ifc_CapacityByWeight	= FM_LiftCapacityNumber
ifc_CapacityByNumber	= FM_TransportablePersons
parameters	ifc_CapacityByWeight	= ifc_CapacityByWeight,
			ifc_CapacityByNumber	= ifc_CapacityByNumber

FM_LiftCapacity = str("%~m", FM_LiftCapacityNumber)
parameters FM_LiftCapacity = FM_LiftCapacity

if iObjectType = ESCALATOR then
	ifc_optype = 2
else
	ifc_optype = 3
endif
parameters ifc_optype = ifc_optype

values "FM_LiftCapacityNumber" range[0, )
]]>
</Script_VL>

<ParamSection SectVersion="22" SectionFlags="0" SubIdent="0">
	<ParamSectHeader>
		<AutoHotspots>false</AutoHotspots>
		<StatBits>
			<STBit_FixSize/>
		</StatBits>
		<WDLeftFrame>0</WDLeftFrame>
		<WDRightFrame>0</WDRightFrame>
		<WDTopFrame>0</WDTopFrame>
		<WDBotFrame>0</WDBotFrame>
		<LayFlags>65535</LayFlags>
		<WDMirrorThickness>0</WDMirrorThickness>
		<WDWallInset>0</WDWallInset>
	</ParamSectHeader>
	<Parameters>
		<Length Name="A">
			<Description><![CDATA["Dimension 1"]]></Description>
			<Fix/>
			<Value>9.17532360493</Value>
		</Length>
		<Length Name="B">
			<Description><![CDATA["Dimension 2"]]></Description>
			<Fix/>
			<Value>2</Value>
		</Length>
		<Length Name="zzyzx">
			<Description><![CDATA["Height"]]></Description>
			<Fix/>
			<Value>4.03</Value>
		</Length>
		<Length Name="landingHeight">
			<Description><![CDATA["Landing Height"]]></Description>
			<Value>2</Value>
		</Length>
		<Integer Name="iObjectType">
			<Description><![CDATA["Object Type"]]></Description>
			<Value>1</Value>
		</Integer>
		<String Name="gs_detlevel_3D">
			<Description><![CDATA["3D Detail Level"]]></Description>
			<Value><![CDATA["Детальный"]]></Value>
		</String>
		<Integer Name="gs_detlevel_3D_m">
			<Description><![CDATA["3D Detail level"]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Integer Name="iBalustradeType">
			<Description><![CDATA["Balustrade Type"]]></Description>
			<Value>1</Value>
		</Integer>

		<!-- dimensions: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="dimensions">
			<Description><![CDATA["Dimensions"]]></Description>
		</Title>
		<Length Name="stepWidth">
			<Description><![CDATA["Step Width"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1.64</Value>
		</Length>
		<Length Name="landingLength">
			<Description><![CDATA["Landing Length"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="riser">
			<Description><![CDATA["Riser"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.169047304696</Value>
		</Length>
		<Length Name="tread">
			<Description><![CDATA["Tread"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0.4</Value>
		</Length>
		<Angle Name="inclination">
			<Description><![CDATA["Inclination"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>24.9999999999558</Value>
		</Angle>

		<!-- gs_3D_representation: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_3D_representation">
			<Description><![CDATA["3D Representation"]]></Description>
		</Title>
		<Integer Name="gs_resol">
			<Description><![CDATA["Resolution"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>16</Value>
		</Integer>
		<Boolean Name="gs_shadow">
			<Description><![CDATA["Shadow"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="AC_show2DHotspotsIn3D">
			<Description><![CDATA["Show 2D Hotspots in 3D"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="ac_bottomlevel">
			<Description><![CDATA["Bottom Level"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>
		<Length Name="ac_toplevel">
			<Description><![CDATA["Top Level"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>2</Value>
		</Length>

		<!-- gs_2D_representation: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_2D_representation">
			<Description><![CDATA["2D Representation"]]></Description>
			<Fix/>
		</Title>
		<String Name="gs_detlevel_2D">
			<Description><![CDATA["2D Detail Level"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Зависит от Масштаба"]]></Value>
		</String>
		<Integer Name="gs_detlevel_2D_m">
			<Description><![CDATA["2D Detail Level"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<PenColor Name="gs_cont_pen">
			<Description><![CDATA["Contour Pen"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>15</Value>
		</PenColor>
		<FillPattern Name="gs_fill_type">
			<Description><![CDATA["Fill Type"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>65</Value>
		</FillPattern>
		<PenColor Name="gs_fill_pen">
			<Description><![CDATA["Fill Pen"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</PenColor>
		<PenColor Name="gs_back_pen">
			<Description><![CDATA["Fill Background Pen"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</PenColor>
		<Boolean Name="bShowBreakline">
			<Description><![CDATA["Show Break Line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bShowOverhead">
			<Description><![CDATA["Show Overhead"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<LineType Name="ltOverhead">
			<Description><![CDATA["Overhead Line Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</LineType>
		<String Name="walkingDirUPDN">
			<Description><![CDATA["UP/DOWN Text"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_BoldName/>
			</Flags>
			<Value><![CDATA["Нет"]]></Value>
		</String>
		<Integer Name="walkingDirUPDN_m">
			<Description><![CDATA["UP/DOWN Text"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<String Name="fontType">
			<Description><![CDATA["Font Type"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Arial"]]></Value>
		</String>
		<RealNum Name="UPDNfontsize">
			<Description><![CDATA["Font Size"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2</Value>
		</RealNum>
		<String Name="typeTextRotation_UpDn">
			<Description><![CDATA["Text Orientation"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Выровнять по Символу"]]></Value>
		</String>
		<Integer Name="typeTextRotation_UpDn_m">
			<Description><![CDATA["Text Orientation"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>3</Value>
		</Integer>
		<PenColor Name="UPDNfontpen">
			<Description><![CDATA["Text Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>86</Value>
		</PenColor>
		<RealNum Name="gs_FontSize">
			<Description><![CDATA["Font Size"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</RealNum>
		<Boolean Name="bStorySensitive">
			<Description><![CDATA["Story Sensitive"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>1</Value>
		</Boolean>

		<!-- aboveHomeStory: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="aboveHomeStory">
			<Description><![CDATA["2D above Home Story"]]></Description>
		</Title>
		<Boolean Name="bShowBreaklineUp">
			<Description><![CDATA["Show Break Line"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="bShowLower2D">
			<Description><![CDATA["Show 2D under Break Mark"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>

		<!-- gs_material: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_material">
			<Description><![CDATA["Surfaces"]]></Description>
		</Title>
		<Material Name="matTruss">
			<Description><![CDATA["Truss"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>18</Value>
		</Material>
		<Material Name="matBalustrade">
			<Description><![CDATA["Balustrade"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>13</Value>
		</Material>
		<Material Name="matGlass">
			<Description><![CDATA["Glass"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>29</Value>
		</Material>
		<Material Name="matHandrailRubber">
			<Description><![CDATA["Handrail"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</Material>
		<Material Name="matTread">
			<Description><![CDATA["Tread"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>75</Value>
		</Material>

		<!-- gs_list: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_list">
			<Description><![CDATA["Parameters for Listing"]]></Description>
			<Fix/>
		</Title>
		<RealNum Name="gs_list_cost">
			<Description><![CDATA["Cost"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</RealNum>
		<String Name="gs_list_manufacturer">
			<Description><![CDATA["Manufacturer"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_note">
			<Description><![CDATA["Note/Remarks"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_location">
			<Description><![CDATA["Location"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_accessories">
			<Description><![CDATA["Accessories"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="FM_Type">
			<Description><![CDATA["Group Type"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Лифты"]]></Value>
		</String>
		<Integer Name="iFMType">
			<Description><![CDATA["Group Type"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>4</Value>
		</Integer>
		<String Name="FM_InventoryNumber">
			<Description><![CDATA["Inventory Number"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="FM_SerialNumber">
			<Description><![CDATA["Serial Number"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="FM_ProductionYear">
			<Description><![CDATA["Production Year"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<RealNum Name="FM_ObjectWeight">
			<Description><![CDATA["Object Weight"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</RealNum>
		<String Name="FM_ObjectWeightUnit">
			<Description><![CDATA["Object Weight Unit"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["кг"]]></Value>
		</String>
		<String Name="FM_FloorSpace">
			<Description><![CDATA["Net Floor Space"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="FM_Speed">
			<Description><![CDATA["Speed of Lifting"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<RealNum Name="FM_LiftCapacityNumber">
			<Description><![CDATA["Lift Capacity"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</RealNum>
		<Integer Name="FM_TransportablePersons">
			<Description><![CDATA["Capacity by Persons"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<String Name="FM_LiftCapacity">
			<Description><![CDATA["Lift Capacity"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["0"]]></Value>
		</String>
		<String Name="FM_HeadRoom">
			<Description><![CDATA["Headroom"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_custom1">
			<Description><![CDATA["User Defined 1"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_custom2">
			<Description><![CDATA["User Defined 2"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_custom3">
			<Description><![CDATA["User Defined 3"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_custom4">
			<Description><![CDATA["User Defined 4"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_custom5">
			<Description><![CDATA["User Defined 5"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<RealNum Name="ifc_CapacityByWeight">
			<Description><![CDATA["Capacity by Weight"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</RealNum>
		<Integer Name="ifc_CapacityByNumber">
			<Description><![CDATA["Capacity by Persons"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Unique/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Integer>
		<Integer Name="ifc_optype">
			<Description><![CDATA["IFC Operation"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Unique/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Length Name="xBreaklinePos">
			<Description><![CDATA[""]]></Description>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1.81</Value>
		</Length>
	</Parameters>
</ParamSection>

<Ancestry SectVersion="1" SectionFlags="0" SubIdent="0" Template="false">
	<MainGUID>F938E33A-329D-4A36-BE3E-85E126820996</MainGUID>
	<MainGUID>103E8D2C-8230-42E1-9597-46F84CCE28C0</MainGUID>
	<MainGUID>A117C8F5-39B3-4826-80C3-F912E4222AB5</MainGUID>
</Ancestry>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_PR SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_PR>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_UI SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_UI>

<Comment SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Comment>

<CalledMacros SectVersion="2" SectionFlags="0" SubIdent="0">
	<Macro>
		<MName><![CDATA["2dDetailLevel"]]></MName>
		<MainGUID>2FD16305-CA53-4505-BFA7-4E98A8BA9399</MainGUID>
	</Macro>
</CalledMacros>

<Copyright SectVersion="1" SectionFlags="0" SubIdent="0">
	<Author>GRAPHISOFT</Author>
	<License>
		<Type>CC0</Type>
		<Version>1.0</Version>
	</License>
</Copyright>

<Keywords SectVersion="1" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Keywords>

</Symbol>
