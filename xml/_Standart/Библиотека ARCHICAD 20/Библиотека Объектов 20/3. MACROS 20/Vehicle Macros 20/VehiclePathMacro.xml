<?xml version="1.0" encoding="UTF-8"?>
<Symbol IsArchivable="false" IsPlaceable="false" MainGUID="A5B275BE-DE68-40F1-B855-B5A80FBE113F" MigrationValue="Normal" Owner="1196638531" Signature="1196644685" Version="38">
<Ancestry SectVersion="1" SectionFlags="0" SubIdent="0" Template="false">
	<MainGUID>F938E33A-329D-4A36-BE3E-85E126820996</MainGUID>
	<MainGUID>103E8D2C-8230-42E1-9597-46F84CCE28C0</MainGUID>
	<MainGUID>2BE37B56-E4CC-412B-BA03-C60B6C3F0D5C</MainGUID>
	<MainGUID>5AB3C7DA-8FC3-4BBC-8226-4F91EFD9AE9F</MainGUID>
</Ancestry>

<CalledMacros SectVersion="2" SectionFlags="0" SubIdent="0">
</CalledMacros>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_3D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
if not(gs_path_move) then

	wheelAngle	= 0
	wheelRot	= 0
	posX		= 0
	posY		= 0
	posZ		= 0
	dirAngle	= 0
	riseAngle	= 0

else

! =============================================================================
! Editable Hotspots
! =============================================================================

	if gs_path_show_3D then
		for i=1 to gs_pathNodes_Num

			idx = i+1

			! Start vector
			if i=1 then
				add gs_pathNodes_Pos[2][1], gs_pathNodes_Pos[2][2], gs_pathNodes_Pos[2][3]
				hotspot gs_pathNodes_Pos[1][1],gs_pathNodes_Pos[1][2],	0,						hsId,   gs_pathNodes_Pos[1][3], 1+128
				hotspot gs_pathNodes_Pos[1][1],gs_pathNodes_Pos[1][2],	-1,						hsId+1, gs_pathNodes_Pos[1][3], 3
				hotspot gs_pathNodes_Pos[1][1],gs_pathNodes_Pos[1][2],	gs_pathNodes_Pos[1][3],	hsId+2, gs_pathNodes_Pos[1][3], 2
				hsId = hsId + 3
				del 1
			endif

			hotspot gs_pathNodes_Pos[idx][1],gs_pathNodes_Pos[idx][2],	0,							hsId,   gs_pathNodes_Pos[idx][3], 1+128
			hotspot gs_pathNodes_Pos[idx][1],gs_pathNodes_Pos[idx][2],	-1,							hsId+1, gs_pathNodes_Pos[idx][3], 3
			hotspot gs_pathNodes_Pos[idx][1],gs_pathNodes_Pos[idx][2],	gs_pathNodes_Pos[idx][3],	hsId+2, gs_pathNodes_Pos[idx][3], 2
			hsId = hsId + 3

			! End vector
			if i=gs_pathNodes_Num then
				add gs_pathNodes_Pos[gs_pathNodes_Num+1][1], gs_pathNodes_Pos[gs_pathNodes_Num+1][2], gs_pathNodes_Pos[gs_pathNodes_Num+1][3]
				hotspot gs_pathNodes_Pos[gs_pathNodes_Num+2][1],gs_pathNodes_Pos[gs_pathNodes_Num+2][2],	0,									hsId,   gs_pathNodes_Pos[gs_pathNodes_Num+2][3], 1+128
				hotspot gs_pathNodes_Pos[gs_pathNodes_Num+2][1],gs_pathNodes_Pos[gs_pathNodes_Num+2][2],	-1,									hsId+1, gs_pathNodes_Pos[gs_pathNodes_Num+2][3], 3
				hotspot gs_pathNodes_Pos[gs_pathNodes_Num+2][1],gs_pathNodes_Pos[gs_pathNodes_Num+2][2],	gs_pathNodes_Pos[gs_pathNodes_Num+2][3],	hsId+2, gs_pathNodes_Pos[gs_pathNodes_Num+2][3], 2
				hsId = hsId + 3
				del 1
			endif
		next i
	endif

! =============================================================================
! Visualization of Skeleton
! =============================================================================

	if gs_path_show_3D then
		sizeHpts = 0.05 ! Size of Hotspots

		for i=1 to gs_pathNodes_Num - 1
			pen gs_path_pen
			add sect[i][1],sect[i][2],sect[i][3]
			add -sizeHpts/2,-sizeHpts/2,-sizeHpts/2
			block sizeHpts,sizeHpts,sizeHpts
			del 2

			add sect[i][10],sect[i][11],sect[i][12]
			add -sizeHpts/2,-sizeHpts/2,-sizeHpts/2
			block sizeHpts,sizeHpts,sizeHpts
			del 2

!			lin_ sect[i][1],sect[i][2],sect[i][3],
!				 sect[i][10],sect[i][11],sect[i][12]

			pen gs_path_line_pen
			add sect[i][4],sect[i][5],sect[i][6]
			add -sizeHpts/2,-sizeHpts/2,-sizeHpts/2
			block sizeHpts,sizeHpts,sizeHpts
			del 2

			add sect[i][7],sect[i][8],sect[i][9]
			add -sizeHpts/2,-sizeHpts/2,-sizeHpts/2
			block sizeHpts,sizeHpts,sizeHpts
			del 2

			lin_ sect[i][1],sect[i][2],sect[i][3],
				 sect[i][4],sect[i][5],sect[i][6]
			lin_ sect[i][10],sect[i][11],sect[i][12],
				 sect[i][7],sect[i][8],sect[i][9]
		next i
	endif

! =============================================================================
! Draw Bezier Path
! =============================================================================

	if gs_path_show_3D then
		pen gs_path_pen
		for i=1 to vardim1(pathPnts) - 1
			lin_ pathPnts[i][1],   pathPnts[i][2],   pathPnts[i][3],
				 pathPnts[i+1][1], pathPnts[i+1][2], pathPnts[i+1][3]
		next i
	endif

! =============================================================================
! Calculate vehicle transformation
! =============================================================================

	idx = min(frameIdx, vardim1(pathPnts))
	posX = pathPnts[idx][1]
	posY = pathPnts[idx][2]
	posZ = pathPnts[idx][3]

	! Front wheel tangent
	if idx > 1 then
		dirFrontX = pathPnts[idx - 1][1] - posX
		dirFrontY = pathPnts[idx - 1][2] - posY
		dirFrontZ = pathPnts[idx - 1][3] - posZ
	else
		dirFrontX = gs_pathNodes_Pos[2][1] - gs_pathNodes_Pos[1][1]
		dirFrontY = gs_pathNodes_Pos[2][2] - gs_pathNodes_Pos[1][2]
		dirFrontZ = gs_pathNodes_Pos[2][3] - gs_pathNodes_Pos[1][3]
	endif

	! Car body direction
	dirCarX = pathPnts[idx][4] - pathPnts[idx][1]
	dirCarY = pathPnts[idx][5] - pathPnts[idx][2]
	dirCarZ = pathPnts[idx][6] - pathPnts[idx][3]

	Lxy = sqr(dirCarX^2 + dirCarY^2)
	if abs(Lxy) > EPS then
		riseAngle = -atn(dirCarZ / Lxy)
	else
		riseAngle = 0
	endif

	vx = dirFrontX
	vy = dirFrontY
	gosub 103	 ! Direction angle
	dirFrontAngle = angle

	vx = dirCarX
	vy = dirCarY
	gosub 103	 ! Direction angle
	dirAngle = angle

	wheelAngle = dirFrontAngle - dirAngle

	wheelRot = (pathPnts[idx][7] / (wheelDiam * PI)) * 360
endif


if test then
	hotspot  0,			0,	0, hsId,   testPos, 1+128
	hotspot  1,			0,	0, hsId+1, testPos, 3
	hotspot -testPos,	0,	0, hsId+2, testPos, 2
	hsId = hsId + 3
endif



end wheelAngle, wheelRot,
	posX,posY,posZ,
	dirAngle, riseAngle





103:

if abs(vx) < EPS & abs(vy) < EPS then
	angle = 0
	return
endif

if abs(vx) < EPS then
	if vy > 0 then
		angle = 90
	else
		angle = 270
	endif
else
	angle = atn(vy / vx)
	if vx >= 0 then
		if angle < 0 then
			angle = angle + 360
		endif
	else
		angle = 180 + angle
	endif
endif

return





]]>
</Script_3D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_2D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
if not(gs_path_move) then

	wheelAngle	= 0
	posX		= 0
	posY		= 0
	rotAngle	= 0

else

! =============================================================================
! Editable Hotspots
! =============================================================================

	fontSize = 0.3	! Font size in model space
	define style "TextStyle" fontType, fontSize / (GLOB_SCALE / 1000), 1, 0
	define style "TextStyleCenter" fontType, fontSize / (GLOB_SCALE / 1000), 2, 0

	if gs_path_show_2D then
		pen gs_path_line_pen
		set style "TextStyleCenter"

		diamSpeedometer = 0.9
		if SYMB_MIRRORED then
			mirSign = 1
		else
			mirSign = -1
		endif

		for i=1 to gs_pathNodes_Num

			idx = i+1

			! Start vector
			if i=1 then
				add2 gs_pathNodes_Pos[2][1], gs_pathNodes_Pos[2][2]
				hotspot2 gs_pathNodes_Pos[1][1],	0,						hsId,   gs_pathNodes_Pos[1][2], 1+128
				hotspot2 gs_pathNodes_Pos[1][1],	-1,						hsId+1, gs_pathNodes_Pos[1][2], 3
				hotspot2 gs_pathNodes_Pos[1][1],	gs_pathNodes_Pos[1][2],	hsId+2, gs_pathNodes_Pos[1][2], 2
				hsId = hsId + 3

				hotspot2 0,							gs_pathNodes_Pos[1][2],	hsId,   gs_pathNodes_Pos[1][1], 1+128
				hotspot2 -1,						gs_pathNodes_Pos[1][2],	hsId+1, gs_pathNodes_Pos[1][1], 3
				hotspot2 gs_pathNodes_Pos[1][1],	gs_pathNodes_Pos[1][2],	hsId+2, gs_pathNodes_Pos[1][1], 2
				hsId = hsId + 3
				del 1
			endif

			hotspot2 gs_pathNodes_Pos[idx][1],	0,							hsId,   gs_pathNodes_Pos[idx][2], 1+128
			hotspot2 gs_pathNodes_Pos[idx][1],	-1,							hsId+1, gs_pathNodes_Pos[idx][2], 3
			hotspot2 gs_pathNodes_Pos[idx][1],	gs_pathNodes_Pos[idx][2],	hsId+2, gs_pathNodes_Pos[idx][2], 2
			hsId = hsId + 3

			hotspot2 0,							gs_pathNodes_Pos[idx][2],	hsId,   gs_pathNodes_Pos[idx][1], 1+128
			hotspot2 -1,						gs_pathNodes_Pos[idx][2],	hsId+1, gs_pathNodes_Pos[idx][1], 3
			hotspot2 gs_pathNodes_Pos[idx][1],	gs_pathNodes_Pos[idx][2],	hsId+2, gs_pathNodes_Pos[idx][1], 2
			hsId = hsId + 3

			! End vector
			if i=gs_pathNodes_Num then
				add2 gs_pathNodes_Pos[gs_pathNodes_Num+1][1], gs_pathNodes_Pos[gs_pathNodes_Num+1][2]
				hotspot2 gs_pathNodes_Pos[gs_pathNodes_Num+2][1],	0,											hsId,   gs_pathNodes_Pos[gs_pathNodes_Num+2][2], 1+128
				hotspot2 gs_pathNodes_Pos[gs_pathNodes_Num+2][1],	-1,											hsId+1, gs_pathNodes_Pos[gs_pathNodes_Num+2][2], 3
				hotspot2 gs_pathNodes_Pos[gs_pathNodes_Num+2][1],	gs_pathNodes_Pos[gs_pathNodes_Num+2][2],	hsId+2, gs_pathNodes_Pos[gs_pathNodes_Num+2][2], 2
				hsId = hsId + 3

				hotspot2 0,											gs_pathNodes_Pos[gs_pathNodes_Num+2][2],	hsId,   gs_pathNodes_Pos[gs_pathNodes_Num+2][1], 1+128
				hotspot2 -1,										gs_pathNodes_Pos[gs_pathNodes_Num+2][2],	hsId+1, gs_pathNodes_Pos[gs_pathNodes_Num+2][1], 3
				hotspot2 gs_pathNodes_Pos[gs_pathNodes_Num+2][1],	gs_pathNodes_Pos[gs_pathNodes_Num+2][2],	hsId+2, gs_pathNodes_Pos[gs_pathNodes_Num+2][1], 2
				hsId = hsId + 3
				del 1
			endif

			! Speedometer
			add2 gs_pathNodes_Pos[idx][1], gs_pathNodes_Pos[idx][2]
			rot2 mirSign * SYMB_ROTANGLE

			if not(bFeedBack) then
				circle2 0,0, diamSpeedometer/2
				arc2 0,0,diamSpeedometer*0.45, -25,205
				arc2 0,0,diamSpeedometer*0.40, -25,205
			endif

			text2 0,0, gs_pathNodes_Speed[idx]

			rot2 -mirSign * 115

			R = diamSpeedometer*0.425
			hotspot2 0, 										0, 									hsId,	gs_pathNodes_Angle[idx], 6 + 512 * not(SYMB_MIRRORED), gs_pathNodes_Speed[idx]
			hotspot2 0,											R,									hsId+1,	gs_pathNodes_Angle[idx], 4 + 128, gs_pathNodes_Speed[idx]
			hotspot2 -mirSign*sin(gs_pathNodes_Angle[idx]) * R,	cos(gs_pathNodes_Angle[idx]) * R,	hsId+2,	gs_pathNodes_Angle[idx], 5, gs_pathNodes_Speed[idx]
			hsId = hsId + 3

			rot2 mirSign * gs_pathNodes_Angle[idx]
			line2 0,0,0,R
			del 3

			del 1
		next i
	endif

! =============================================================================
! Visualization of Skeleton
! =============================================================================

	if gs_path_show_2D then

		sizeHpts = 0.06 ! Size of Hotspots

		for i=1 to gs_pathNodes_Num - 1
			pen gs_path_pen
			circle2 sect[i][1], sect[i][2],  sizeHpts
			circle2 sect[i][10],sect[i][11], sizeHpts

!			lin_ sect[i][1], sect[i][2], sect[i][3],
!				 sect[i][10],sect[i][11],sect[i][12]

			pen gs_path_line_pen
			circle2 sect[i][4],sect[i][5], sizeHpts
			circle2 sect[i][7],sect[i][8], sizeHpts

			line2 sect[i][1], sect[i][2],
				  sect[i][4], sect[i][5]
			line2 sect[i][10],sect[i][11],
				  sect[i][7], sect[i][8]
		next i
	endif

! =============================================================================
! Show animation infos
! =============================================================================

	if gs_path_show_2D then
		set style "TextStyle"
		sp = 1.5 * fontSize

		add2 0, -1.0

		pen gs_path_pen
		text2 0,0,	   stAnimationInfo[1] + " " + str(gs_path_fps,1,0) + " " + stAnimationInfo[5]			! Animation speed: 24 [fps]
		text2 0,-1*sp, stAnimationInfo[2] + " " + str(gs_path_start_frame,1,0) + " " + stAnimationInfo[6]	! Start frame: 1 [frame]
		text2 0,-2*sp, stAnimationInfo[3] + " " + str(gs_path_start_frame + vardim1(pathPnts),1,0) + " " + stAnimationInfo[6]	! End frame: 101 [frame]
		text2 0,-3*sp, stAnimationInfo[4] + " " + str(vardim1(pathPnts),1,0) + " " + stAnimationInfo[6]		! Animation length: 100 [frame]
		text2 0,-4*sp, stAnimationInfo[4] + " " + str(vardim1(pathPnts) / gs_path_fps,2,1) + " " + stAnimationInfo[7]		! Animation length: 4 [sec]

		del 1
	endif

! =============================================================================
! Draw Bezier Path
! =============================================================================

	if gs_path_show_2D then
		pen gs_path_pen

		for i=1 to vardim1(pathPnts) - 1
			if not(bFeedBack) then
				circle2 pathPnts[i][1],   pathPnts[i][2], 0.03
				hotspot2 pathPnts[i][1],   pathPnts[i][2], hsId
			endif
			hsId = hsId + 1

			line2 pathPnts[i][1],   pathPnts[i][2],
				  pathPnts[i+1][1], pathPnts[i+1][2]
		next i
	endif

! =============================================================================
! Calculate vehicle transformation
! =============================================================================

	idx = min(frameIdx, vardim1(pathPnts))
	posX = pathPnts[idx][1]
	posY = pathPnts[idx][2]

!!!circle2 pathPnts[idx][4], pathPnts[idx][5], 0.1		! Back wheel point

	if idx > 1 then
		dirX = pathPnts[idx - 1][1] - posX
		dirY = pathPnts[idx - 1][2] - posY
	else
		dirX = gs_pathNodes_Pos[2][1] - gs_pathNodes_Pos[1][1]
		dirY = gs_pathNodes_Pos[2][2] - gs_pathNodes_Pos[1][2]
	endif

	dirX = pathPnts[idx][4] - pathPnts[idx][1]
	dirY = pathPnts[idx][5] - pathPnts[idx][2]


	vx = dirX
	vy = dirY
	gosub 103	 ! Direction angle
	rotAngle = angle

	wheelAngle = 0

endif



if test then
	add2 0, -1
	circle2 0,0,0.05
	circle2 -testPos,0,0.05
	hotspot2  0,		0,	hsId,   testPos, 1+128
	hotspot2  1,		0,	hsId+1, testPos, 3
	hotspot2 -testPos,	0,	hsId+2, testPos, 2
	hsId = hsId + 3
	del 1
endif



end wheelAngle,
	posX, posY, rotAngle



103:

if abs(vx) < EPS & abs(vy) < EPS then
	angle = 0
	return
endif

if abs(vx) < EPS then
	if vy > 0 then
		angle = 90
	else
		angle = 270
	endif
else
	angle = atn(vy / vx)
	if vx >= 0 then
		if angle < 0 then
			angle = angle + 360
		endif
	else
		angle = 180 + angle
	endif
endif

return



]]>
</Script_2D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_1D SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
EPS = 0.0001

! =============================================================================
! Frame index
! =============================================================================

if GLOB_SCRIPT_TYPE = 2 | GLOB_SCRIPT_TYPE = 3 then
	if test then
		frameIdx = int(10 * testPos) + 1
	else
		frameIdx = max(1, GLOB_FRAME_NR + 1 - gs_path_start_frame)
	endif
else
	frameIdx = 1
endif


! =============================================================================
! Bezier path points
! =============================================================================

dim Coord[4][3] ! Coordinate System, and Translation Vector
dim m[4][4]     ! The Last Rotation's Matrix
dim summ[4][4]  ! The Whole Rotation Matrix

lambda = 1/2 ! Length of middle points
SectL = 0.25 ! Length of Ring Section

dim sect[][14] ! Bezier Sections
	!  1- 3 : x1,y1,z1
	!  4- 6 : x2,y3,z4
	!  7- 9 : x3,y3,z3
	! 10-12 : x4,y4,z4
	! 13    : Length of Spline
	! 14    : Segment Length

dim pathPnts[][7]	! path points
	!  1-3 : Front wheel position (x,y,z)
	!  4-6 : End wheel position (x,y,z)
	!  7   : Distance from the begining of the path

pathNodesNum = gs_pathNodes_Num_old

if GLOB_SCRIPT_TYPE = 2 | GLOB_SCRIPT_TYPE = 3 then
	bFeedBack = (GLOB_CONTEXT > 20 and GLOB_CONTEXT < 40)
else
	bFeedBack = 0
endif

if gs_path_move then

	if bFeedBack then
		gs_path_fps	= 5
	endif

! =============================================================================
! Calculating Bezier Control Points
! =============================================================================

	for i=2 to pathNodesNum + 1

		sect[i-1][1] = gs_pathNodes_Pos[i][1]
		sect[i-1][2] = gs_pathNodes_Pos[i][2]
		sect[i-1][3] = gs_pathNodes_Pos[i][3]

		sect[i-1][10] = gs_pathNodes_Pos[i+1][1]
		sect[i-1][11] = gs_pathNodes_Pos[i+1][2]
		sect[i-1][12] = gs_pathNodes_Pos[i+1][3]

		if i=2 then
			! Normalize Vector
			x = gs_pathNodes_Pos[1][1]
			y = gs_pathNodes_Pos[1][2]
			z = gs_pathNodes_Pos[1][3]
			S = 1/sqr(x^2 + y^2 + z^2)
			x = S*x
			y = S*y
			z = S*z

			x1 = gs_pathNodes_Pos[2][1]-gs_pathNodes_Pos[3][1]
			y1 = gs_pathNodes_Pos[2][2]-gs_pathNodes_Pos[3][2]
			z1 = gs_pathNodes_Pos[2][3]-gs_pathNodes_Pos[3][3]
			S1 = sqr(x1^2 + y1^2 + z1^2)
			x = lambda*S1*x
			y = lambda*S1*y
			z = lambda*S1*z

			sect[1][4] = gs_pathNodes_Pos[2][1] + x
			sect[1][5] = gs_pathNodes_Pos[2][2] + y
			sect[1][6] = gs_pathNodes_Pos[2][3] + z
		endif

		if i = pathNodesNum + 1 then
			! Normalize Vector
			x = gs_pathNodes_Pos[i+1][1]
			y = gs_pathNodes_Pos[i+1][2]
			z = gs_pathNodes_Pos[i+1][3]
			S = 1/sqr(x^2 + y^2 + z^2)
			x = S*x
			y = S*y
			z = S*z

			x1 = gs_pathNodes_Pos[i][1]-gs_pathNodes_Pos[i-1][1]
			y1 = gs_pathNodes_Pos[i][2]-gs_pathNodes_Pos[i-1][2]
			z1 = gs_pathNodes_Pos[i][3]-gs_pathNodes_Pos[i-1][3]
			S1 = sqr(x1^2 + y1^2 + z1^2)
			x = lambda*S1*x
			y = lambda*S1*y
			z = lambda*S1*z
			sect[i-2][7] = gs_pathNodes_Pos[i][1] + x
			sect[i-2][8] = gs_pathNodes_Pos[i][2] + y
			sect[i-2][9] = gs_pathNodes_Pos[i][3] + z
		endif

		if i > 2 and i < pathNodesNum + 1 then
			! P0
			x0 = 0
			y0 = 0
			z0 = 0

			! P1
			x1 = gs_pathNodes_Pos[i-1][1]-gs_pathNodes_Pos[i][1]
			y1 = gs_pathNodes_Pos[i-1][2]-gs_pathNodes_Pos[i][2]
			z1 = gs_pathNodes_Pos[i-1][3]-gs_pathNodes_Pos[i][3]
			S1 = 1/sqr(x1^2 + y1^2 + z1^2)

			! P2
			x2 = gs_pathNodes_Pos[i+1][1]-gs_pathNodes_Pos[i][1]
			y2 = gs_pathNodes_Pos[i+1][2]-gs_pathNodes_Pos[i][2]
			z2 = gs_pathNodes_Pos[i+1][3]-gs_pathNodes_Pos[i][3]
			S2 = 1/sqr(x2^2 + y2^2 + z2^2)

			! Mid Angle
			x = (S1*x1 + S2*x2)/2
			y = (S1*y1 + S2*y2)/2
			z = (S1*z1 + S2*z2)/2

			gosub 100 ! Cross Product (P0,P1,P2)

			gosub 1100	! Init Coordinate System

			if abs(x)> EPS or abs(y) > EPS or abs(z) > EPS then
				put x,y,z,90
				gosub 1120	! Rot around (x,y,z) axis

				put Vx,Vy,Vz
				gosub 1210	! Transform
				xx=GET(1): yy=GET(1): zz=GET(1)
			else
				xx = x1
				yy = y1
				zz = z1
			endif

			! Normalize vector
			temp  = sqr(xx^2 + yy^2 + zz^2)
			xx = xx/temp
			yy = yy/temp
			zz = zz/temp

			xx1 = lambda*xx/S1
			yy1 = lambda*yy/S1
			zz1 = lambda*zz/S1

			xx2 = -lambda*xx/S2
			yy2 = -lambda*yy/S2
			zz2 = -lambda*zz/S2

			sect[i-2][7] = gs_pathNodes_Pos[i][1]+xx1
			sect[i-2][8] = gs_pathNodes_Pos[i][2]+yy1
			sect[i-2][9] = gs_pathNodes_Pos[i][3]+zz1

			sect[i-1][4] = gs_pathNodes_Pos[i][1]+xx2
			sect[i-1][5] = gs_pathNodes_Pos[i][2]+yy2
			sect[i-1][6] = gs_pathNodes_Pos[i][3]+zz2
		endif
	next i

! =============================================================================
! Calculating Curve Lengths - Step 1
! =============================================================================

	for i=1 to pathNodesNum - 1

		x=sect[i][1]-sect[i][10]
		y=sect[i][2]-sect[i][11]
		z=sect[i][3]-sect[i][12]
		L1 = sqr(x^2 + y^2 + z^2)

		x=sect[i][1]-sect[i][4]
		y=sect[i][2]-sect[i][5]
		z=sect[i][3]-sect[i][6]
		L2 = sqr(x^2 + y^2 + z^2)

		x=sect[i][4]-sect[i][7]
		y=sect[i][5]-sect[i][8]
		z=sect[i][6]-sect[i][9]
		L2 = L2 + sqr(x^2 + y^2 + z^2)

		x=sect[i][7]-sect[i][10]
		y=sect[i][8]-sect[i][11]
		z=sect[i][9]-sect[i][12]
		L2 = L2 + sqr(x^2 + y^2 + z^2)

		L = (L1 + L2) / 2
		stp = 1/max(1, int(L/SectL))

		sect[i][13] = L
		sect[i][14] = stp
	next i

! =============================================================================
! Calculating Curve Lengths - Step 2
! =============================================================================

	pathLength = 0

	for i=1 to pathNodesNum - 1

		stp = sect[i][14]
		L = 0

		t=0
		Px0 = ((1-t)^3)*sect[i][1] + (3*t*(1-t)^2)*sect[i][4] + (3*t*t*(1-t))*sect[i][7] + (t^3)*sect[i][10]
		Py0 = ((1-t)^3)*sect[i][2] + (3*t*(1-t)^2)*sect[i][5] + (3*t*t*(1-t))*sect[i][8] + (t^3)*sect[i][11]
		Pz0 = ((1-t)^3)*sect[i][3] + (3*t*(1-t)^2)*sect[i][6] + (3*t*t*(1-t))*sect[i][9] + (t^3)*sect[i][12]

		for t=stp to 1 step stp
			Px = ((1-t)^3)*sect[i][1] + (3*t*(1-t)^2)*sect[i][4] + (3*t*t*(1-t))*sect[i][7] + (t^3)*sect[i][10]
			Py = ((1-t)^3)*sect[i][2] + (3*t*(1-t)^2)*sect[i][5] + (3*t*t*(1-t))*sect[i][8] + (t^3)*sect[i][11]
			Pz = ((1-t)^3)*sect[i][3] + (3*t*(1-t)^2)*sect[i][6] + (3*t*t*(1-t))*sect[i][9] + (t^3)*sect[i][12]

			L = L + sqr( (Px-Px0)^2 + (Py-Py0)^2 + (Pz-Pz0)^2 )
			Px0 = Px
			Py0 = Py
			Pz0 = Pz
		next t

		stp = 1/max(1, int(L/SectL))
		pathLength = pathLength + L

		sect[i][13] = L
		sect[i][14] = stp
	next i


! =============================================================================
! Create Bezier Path
! =============================================================================

	idx = 1
	summDist = 0

	for i=1 to pathNodesNum - 1

! Acceleration ----------------------------------------------------------------

		pathLeght	= sect[i][13]
		speedStart	= gs_pathNodes_Speed[i + 1] / 3.6	! Convert km/h to m/s
		speedEnd	= gs_pathNodes_Speed[i + 2] / 3.6

		if pathLeght > EPS then
			tStepStart	= speedStart / gs_path_fps / pathLeght	! Step of (t) parameter at the start of path t=[0...1]
			tStepEnd	= speedEnd   / gs_path_fps / pathLeght	! Step of (t) parameter at the end of path t=[0...1]
		else
			tStepStart	= 0
			tStepEnd	= 0
		endif
		averageStep = (tStepEnd + tStepStart) / 2
		if averageStep > EPS then
			numSteps = max(1, ceil((1 - tStepEnd - tStepStart) / ((tStepEnd + tStepStart) / 2)))
		else
			numSteps = 1
		endif

		avgStep = (1 - tStepEnd - tStepStart) / numSteps

! Calculate points within the path --------------------------------------------

		for s=0 to numSteps + 1 * (i = (pathNodesNum - 1))

			t = tStepStart * s * (1 - s / (numSteps + 1)) + avgStep * s * (s / numSteps)

! Front wheel point -----------------------------------------------------------

			Px = ((1-t)^3)*sect[i][1] + (3*t*(1-t)^2)*sect[i][4] + (3*t^2*(1-t))*sect[i][7] + (t^3)*sect[i][10]
			Py = ((1-t)^3)*sect[i][2] + (3*t*(1-t)^2)*sect[i][5] + (3*t^2*(1-t))*sect[i][8] + (t^3)*sect[i][11]
			Pz = ((1-t)^3)*sect[i][3] + (3*t*(1-t)^2)*sect[i][6] + (3*t^2*(1-t))*sect[i][9] + (t^3)*sect[i][12]

! Rear wheel point ------------------------------------------------------------

			pathLeghtFromBeg = t * pathLeght
			if pathLeghtFromBeg > wheelBase then
				t2 = (pathLeghtFromBeg - wheelBase) / pathLeght
				idxEnd = i
			else
				idxEnd = i - 1
				if idxEnd > 0 then
					bLoopEnd = 0
					while (not(bLoopEnd)) & (idxEnd > 0) do
						if (pathLeghtFromBeg + sect[idxEnd][13]) < wheelBase then
							pathLeghtFromBeg = pathLeghtFromBeg + sect[idxEnd][13]
							idxEnd = idxEnd - 1
						else
							bLoopEnd = 1
						endif
					endwhile
				endif
				if idxEnd > 0 then
					t2 = 1 - (wheelBase - pathLeghtFromBeg) / sect[idxEnd][13]
				else
					vectLength = wheelBase - pathLeghtFromBeg
				endif
			endif

			if idxEnd > 0 then
				P2x = ((1-t2)^3)*sect[idxEnd][1] + (3*t2*(1-t2)^2)*sect[idxEnd][4] + (3*t2^2*(1-t2))*sect[idxEnd][7] + (t2^3)*sect[idxEnd][10]
				P2y = ((1-t2)^3)*sect[idxEnd][2] + (3*t2*(1-t2)^2)*sect[idxEnd][5] + (3*t2^2*(1-t2))*sect[idxEnd][8] + (t2^3)*sect[idxEnd][11]
				P2z = ((1-t2)^3)*sect[idxEnd][3] + (3*t2*(1-t2)^2)*sect[idxEnd][6] + (3*t2^2*(1-t2))*sect[idxEnd][9] + (t2^3)*sect[idxEnd][12]
			else
				vx = sect[1][4] - sect[1][1]
				vy = sect[1][5] - sect[1][2]
				vz = sect[1][6] - sect[1][3]
				L = vectLength / sqr(vx^2 + vy^2 + vz^2)
				P2x = sect[1][1] - vx * L
				P2y = sect[1][2] - vy * L
				P2z = sect[1][3] - vz * L
			endif

! Store points ----------------------------------------------------------------

			pathPnts[idx][1] = Px
			pathPnts[idx][2] = Py
			pathPnts[idx][3] = Pz

			pathPnts[idx][4] = P2x
			pathPnts[idx][5] = P2y
			pathPnts[idx][6] = P2z

			if idx > 1 then
				distDelta = sqr((Px - pathPnts[idx - 1][1])^2 + (Py - pathPnts[idx - 1][2])^2)
			else
				distDelta = 0
			endif
			summDist = summDist + distDelta
			pathPnts[idx][7] = summDist

			idx = idx + 1
		next s
	next i

endif


goto 1



! =============================================================================
! Geometry functions
! =============================================================================

100:	! Cross Product
	Vx = (Y0-Y1)*(Z0-Z2) - (Z0-Z1)*(Y0-Y2)
	Vy = (Z0-Z1)*(X0-X2) - (X0-X1)*(Z0-Z2)
	Vz = (X0-X1)*(Y0-Y2) - (Y0-Y1)*(X0-X2)
return

200:	! Dot Product
	angle = (x1*x2) + (y1*y2) + (z1*z2)
return


! =============================================================================
! Matrix functions
! =============================================================================

1100:	! Init Coordinate System

	! Reset Coordinate Vectors
	Coord[1][1]=1: Coord[1][2]=0: Coord[1][3]=0
	Coord[2][1]=0: Coord[2][2]=1: Coord[2][3]=0
	Coord[3][1]=0: Coord[3][2]=0: Coord[3][3]=1

	! Set Zero Translation
	Coord[4][1]=0: Coord[4][2]=0: Coord[4][3]=0

	! Set Identity Matrix
	for ii=1 to 4
		for jj=1 to 4
			if ii=jj then
				m[ii][jj]=1
				summ[ii][jj]=1
			else
				m[ii][jj]=0
				summ[ii][jj]=0
			endif
		next jj
	next ii
return


1120:	! Rotation around Axis with Angle

	if NSP<>4 then print "Something Wrong !"

	! Transform axis to the current coordinate system
	gosub 1201   ! Transform Point with summ[4][4]

	alfa_hpts = -get(1)
	x_hpts = get(1)
	y_hpts = get(1)
	z_hpts = get(1)

	gosub 1301   ! Rotation Axis and Angle to Quaternion
	gosub 1304   ! Quaternion to Rotation Matrix
	gosub 1202   ! Transform Coordinate System with Matrix m[4][4]
	gosub 1203   ! Transform Summ Matrix
return


1200:	! Transform Point with m[4][4]
	x_hpts = get(1)
	y_hpts = get(1)
	z_hpts = get(1)
	h_hpts = 1
	put x_hpts*m[1][1] + y_hpts*m[2][1] + z_hpts*m[3][1] + h_hpts*m[4][1] ! X
	put x_hpts*m[1][2] + y_hpts*m[2][2] + z_hpts*m[3][2] + h_hpts*m[4][2] ! Y
	put x_hpts*m[1][3] + y_hpts*m[2][3] + z_hpts*m[3][3] + h_hpts*m[4][3] ! Z
!	put x_hpts*m[1][4] + y_hpts*m[2][4] + z_hpts*m[3][4] + h_hpts*m[4][4] ! h
return


1201:	! Transform Point with summ[4][4]
	x_hpts = get(1)
	y_hpts = get(1)
	z_hpts = get(1)
	h_hpts = 1
	put x_hpts*summ[1][1] + y_hpts*summ[2][1] + z_hpts*summ[3][1] + h_hpts*summ[4][1] ! X
	put x_hpts*summ[1][2] + y_hpts*summ[2][2] + z_hpts*summ[3][2] + h_hpts*summ[4][2] ! Y
	put x_hpts*summ[1][3] + y_hpts*summ[2][3] + z_hpts*summ[3][3] + h_hpts*summ[4][3] ! Z
!	put x_hpts*summ[1][4] + y_hpts*summ[2][4] + z_hpts*summ[3][4] + h_hpts*summ[4][4] ! h
return


1202:	! Transform Coordinate System
	put Coord[1][1],Coord[1][2],Coord[1][3]
	gosub 1200
	Coord[1][1] = get(1)
	Coord[1][2] = get(1)
	Coord[1][3] = get(1)

	put Coord[2][1],Coord[2][2],Coord[2][3]
	gosub 1200
	Coord[2][1] = get(1)
	Coord[2][2] = get(1)
	Coord[2][3] = get(1)

	put Coord[3][1],Coord[3][2],Coord[3][3]
	gosub 1200
	Coord[3][1] = get(1)
	Coord[3][2] = get(1)
	Coord[3][3] = get(1)
return


1203:	! Transform Matrix
	dim temp[4][4] ! Temporary Matrix

	! Copy summ[] to temp[]
	for ii=1 TO 4
		for jj=1 TO 4
			temp[ii][jj]=summ[ii][jj]
		next jj
	next ii

	! Transform summ[] and m[]
	for ii=1 to 4
		for jj=1 to 4
			summ[ii][jj]=0
			for kk=1 to 4
				summ[ii][jj] = summ[ii][jj]+temp[ii][kk]*m[kk][jj]
			next kk
		next jj
	next ii
return


1210:	! Transform Point with summ[4][4] and Coord[4][3]
	gosub 1201   ! Transform Point with summ[4][4]

	x_hpts = get(1)
	y_hpts = get(1)
	z_hpts = get(1)

	put Coord[4][1] + x_hpts
	put Coord[4][2] + y_hpts
	put Coord[4][3] + z_hpts
return


! =============================================================================
! Quaternion Functions
! =============================================================================

1301:	! Rotation Axis and Angle to Quaternion

	temp_hpts = x_hpts^2 + y_hpts^2 + z_hpts^2
	dist_hpts = SIN(alfa_hpts/2) / sqr(temp_hpts)

	qX_hpts = x_hpts * dist_hpts
	qY_hpts = y_hpts * dist_hpts
	qZ_hpts = z_hpts * dist_hpts
	qW_hpts = COS(alfa_hpts/2)
return

1304:	! Quaternion to Rotation Matrix
	x2_hpts = qx_hpts + qx_hpts: y2_hpts = qy_hpts + qy_hpts: z2_hpts = qz_hpts + qz_hpts
	xx_hpts = qx_hpts * x2_hpts: xy_hpts = qx_hpts * y2_hpts: xz_hpts = qx_hpts * z2_hpts
	yy_hpts = qy_hpts * y2_hpts: yz_hpts = qy_hpts * z2_hpts: zz_hpts = qz_hpts * z2_hpts
	wx_hpts = qw_hpts * x2_hpts: wy_hpts = qw_hpts * y2_hpts: wz_hpts = qw_hpts * z2_hpts

	m[1][1] = 1 - (yy_hpts + zz_hpts)
	m[1][2] = xy_hpts - wz_hpts
	m[1][3] = xz_hpts + wy_hpts
	m[1][4] = 0

	m[2][1] = xy_hpts + wz_hpts
	m[2][2] = 1 - (xx_hpts + zz_hpts)
	m[2][3] = yz_hpts - wx_hpts
	m[2][4] = 0

	m[3][1] = xz_hpts - wy_hpts
	m[3][2] = yz_hpts + wx_hpts
	m[3][3] = 1 - (xx_hpts + yy_hpts)
	m[3][4] = 0

	m[4][1] = 0
	m[4][2] = 0
	m[4][3] = 0
	m[4][4] = 1
return

1:
]]>
</Script_1D>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_PR SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_PR>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_UI SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Script_UI>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Script_VL SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[
if test then
	values "testPos" range[0,)
endif

if not(gs_path_move) then
	lock "gs_path_show_2D", "gs_path_show_3D", "gs_pathNodes_Num", "gs_path_fps", "gs_path_start_frame"
	hideparameter "gs_path_show_2D", "gs_path_show_3D", "gs_pathNodes_Num", "gs_path_fps", "gs_path_start_frame"
endif

if not(gs_path_move and (gs_path_show_2D or gs_path_show_3D)) then
	lock "gs_path_pen", "gs_path_line_pen"
	hideparameter "gs_path_pen", "gs_path_line_pen"
endif

maxAngle = 230
maxSpeed = 80

values "gs_pathNodes_Angle" range[0,maxAngle]
values "gs_pathNodes_Speed" range[0,maxSpeed]
ratio = maxAngle / maxSpeed

if GLOB_MODPAR_NAME = "gs_pathNodes_Angle" then
	for i=1 to vardim1(gs_pathNodes_Angle)

		if gs_pathNodes_Angle[i] > (maxAngle + (360 - maxAngle) / 2) then
			gs_pathNodes_Angle[i] = 20
			parameters gs_pathNodes_Angle[i] = 20
		else
			if gs_pathNodes_Angle[i] > maxAngle then
				gs_pathNodes_Angle[i] = maxAngle
				parameters gs_pathNodes_Angle[i] = maxAngle
			endif
		endif

		gs_pathNodes_Speed[i] = gs_pathNodes_Angle[i] / Ratio
		parameters gs_pathNodes_Speed[i] = gs_pathNodes_Speed[i]
	next i
else
	for i=1 to vardim1(gs_pathNodes_Angle)
		gs_pathNodes_Angle[i] = gs_pathNodes_Speed[i] * Ratio
		parameters gs_pathNodes_Angle[i] = gs_pathNodes_Angle[i]
	next i
endif

values "gs_path_fps" range[1,]
values "gs_path_start_frame" range[1,]

values "gs_pathNodes_Num" range[2,100]

if GLOB_MODPAR_NAME = "gs_pathNodes_Num" then

	addLength = 5.0

	if gs_pathNodes_Num_old > gs_pathNodes_Num then
		vx = gs_pathNodes_Pos[gs_pathNodes_Num + 1][1] - gs_pathNodes_Pos[gs_pathNodes_Num + 2][1]
		vy = gs_pathNodes_Pos[gs_pathNodes_Num + 1][2] - gs_pathNodes_Pos[gs_pathNodes_Num + 2][2]
		vz = gs_pathNodes_Pos[gs_pathNodes_Num + 1][3] - gs_pathNodes_Pos[gs_pathNodes_Num + 2][3]
		L = sqr(vx^2 + vy^2 + vz^2)		! Unit vector
		if L > EPS then
			vx = vx / L
			vy = vy / L
			vz = vz / L
		endif
		gs_pathNodes_Pos[gs_pathNodes_Num + 2][1] = vx
		gs_pathNodes_Pos[gs_pathNodes_Num + 2][2] = vy
		gs_pathNodes_Pos[gs_pathNodes_Num + 2][3] = vz
	endif

	if gs_pathNodes_Num_old < gs_pathNodes_Num then
		px = gs_pathNodes_Pos[gs_pathNodes_Num_old + 1][1]
		py = gs_pathNodes_Pos[gs_pathNodes_Num_old + 1][2]
		pz = gs_pathNodes_Pos[gs_pathNodes_Num_old + 1][3]
		vx = gs_pathNodes_Pos[gs_pathNodes_Num_old + 2][1]
		vy = gs_pathNodes_Pos[gs_pathNodes_Num_old + 2][2]
		vz = gs_pathNodes_Pos[gs_pathNodes_Num_old + 2][3]
		L = sqr(vx^2 + vy^2 + vz^2)		! Unit vector
		if L > EPS then
			vx = vx / L
			vy = vy / L
			vz = vz / L
		endif

		for i=gs_pathNodes_Num_old to gs_pathNodes_Num
			px = px - addLength * vx
			py = py - addLength * vy
			pz = pz - addLength * vz
			gs_pathNodes_Pos[i + 2][1] = px
			gs_pathNodes_Pos[i + 2][2] = py
			gs_pathNodes_Pos[i + 2][3] = pz
		next i
		gs_pathNodes_Pos[gs_pathNodes_Num + 2][1] = vx
		gs_pathNodes_Pos[gs_pathNodes_Num + 2][2] = vy
		gs_pathNodes_Pos[gs_pathNodes_Num + 2][3] = vz
		gs_pathNodes_Speed[gs_pathNodes_Num + 2] = 15
		gs_pathNodes_Angle[gs_pathNodes_Num + 2] = gs_pathNodes_Speed[gs_pathNodes_Num + 2] * Ratio

	endif

	for t=1 to vardim1(gs_pathNodes_Angle)
		if gs_pathNodes_Angle[t] < eps then
			gs_pathNodes_Speed[t]= 15
			gs_pathNodes_Angle[t]= gs_pathNodes_Speed[t]* Ratio
		endif
	next t

	parameters gs_pathNodes_Pos = gs_pathNodes_Pos,
		gs_pathNodes_Angle = gs_pathNodes_Angle,
		gs_pathNodes_Speed = gs_pathNodes_Speed
endif
gs_pathNodes_Num_old = gs_pathNodes_Num
parameters gs_pathNodes_Num_old = gs_pathNodes_Num

]]>
</Script_VL>

<!-- GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT ===== GDL SCRIPT -->

<Comment SectVersion="20" SectionFlags="0" SubIdent="0">
<![CDATA[]]>
</Comment>

<ParamSection SectVersion="26" SectionFlags="0" SubIdent="0">
	<ParamSectHeader>
		<Version>26</Version>
		<AutoHotspots>false</AutoHotspots>
		<StatBits>
			<STBit_FixSize/>
		</StatBits>
		<WDLeftFrame>0</WDLeftFrame>
		<WDRightFrame>0</WDRightFrame>
		<WDTopFrame>0</WDTopFrame>
		<WDBotFrame>0</WDBotFrame>
		<LayFlags>65535</LayFlags>
		<WDMirrorThickness>0</WDMirrorThickness>
		<WDWallInset>0</WDWallInset>
		<SymbolColor>0</SymbolColor>
	</ParamSectHeader>
	<Parameters>
		<Length Name="A">
			<Description><![CDATA["Dimension 1"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Length Name="B">
			<Description><![CDATA["Dimension 2"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Length Name="ZZYZX">
			<Description><![CDATA["Height"]]></Description>
			<Fix/>
			<Value>1</Value>
		</Length>
		<Boolean Name="AC_show2DHotspotsIn3D">
			<Description><![CDATA["Show 2D Hotspots in 3D"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Boolean>
		<Length Name="ac_bottomlevel">
			<Description><![CDATA["Bottom Level"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>1</Value>
		</Length>
		<Length Name="ac_toplevel">
			<Description><![CDATA["Top Level"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Hidden/>
			</Flags>
			<Value>0</Value>
		</Length>

		<!-- gs_2D_representation: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_2D_representation">
			<Description><![CDATA["2D Representation"]]></Description>
			<Fix/>
		</Title>
		<PenColor Name="gs_cont_pen">
			<Description><![CDATA["Contour Pen"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>4</Value>
		</PenColor>
		<FillPattern Name="gs_fill_type">
			<Description><![CDATA["Fill Type"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>65</Value>
		</FillPattern>
		<PenColor Name="gs_fill_pen">
			<Description><![CDATA["Fill Pen"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</PenColor>
		<PenColor Name="gs_back_pen">
			<Description><![CDATA["Fill Background Pen"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>19</Value>
		</PenColor>
		<Length Name="wheelBase">
			<Description><![CDATA["Wheelbase"]]></Description>
			<Value>2.76</Value>
		</Length>
		<Length Name="wheelDiam">
			<Description><![CDATA["Wheel Diameter"]]></Description>
			<Value>0.7</Value>
		</Length>
		<Integer Name="hsId">
			<Description><![CDATA["HotspotID"]]></Description>
			<Value>1</Value>
		</Integer>

		<!-- gs_path_move: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Boolean Name="gs_path_move">
			<Description><![CDATA["Move Along Path"]]></Description>
			<Flags>
				<ParFlg_BoldName/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="gs_path_show_2D">
			<Description><![CDATA["Show Path in 2D"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Boolean Name="gs_path_show_3D">
			<Description><![CDATA["Show Path in 3D"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Boolean>
		<Integer Name="gs_pathNodes_Num">
			<Description><![CDATA["Number of Path Nodes"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Integer Name="gs_pathNodes_Num_old">
			<Description><![CDATA["Number of Path Nodes"]]></Description>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>2</Value>
		</Integer>
		<Length Name="gs_pathNodes_Pos">
			<Description><![CDATA["Position of Path Nodes"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="4" SecondDimension="3">
				<AVal Column="1" Row="1">0.001</AVal>
				<AVal Column="2" Row="1">0</AVal>
				<AVal Column="3" Row="1">0</AVal>
				<AVal Column="1" Row="2">1</AVal>
				<AVal Column="2" Row="2">2</AVal>
				<AVal Column="3" Row="2">0</AVal>
				<AVal Column="1" Row="3">1.5</AVal>
				<AVal Column="2" Row="3">2.5</AVal>
				<AVal Column="3" Row="3">0.5</AVal>
				<AVal Column="1" Row="4">-0.267261241912</AVal>
				<AVal Column="2" Row="4">0.534522483825</AVal>
				<AVal Column="3" Row="4">-0.801783725737</AVal>
			</ArrayValues>
		</Length>
		<Angle Name="gs_pathNodes_Angle">
			<Description><![CDATA["Speed at Path Node"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="4" SecondDimension="0">
				<AVal Row="1">57.5</AVal>
				<AVal Row="2">57.5</AVal>
				<AVal Row="3">57.5</AVal>
				<AVal Row="4">57.5</AVal>
			</ArrayValues>
		</Angle>
		<Integer Name="gs_pathNodes_Speed">
			<Description><![CDATA["Speed at Path Node (km/h)"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<ArrayValues FirstDimension="4" SecondDimension="0">
				<AVal Row="1">20</AVal>
				<AVal Row="2">20</AVal>
				<AVal Row="3">20</AVal>
				<AVal Row="4">20</AVal>
			</ArrayValues>
		</Integer>
		<Integer Name="gs_path_fps">
			<Description><![CDATA["Frames per Second"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>10</Value>
		</Integer>
		<Integer Name="gs_path_start_frame">
			<Description><![CDATA["Start Frame Index"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>1</Value>
		</Integer>
		<PenColor Name="gs_path_pen">
			<Description><![CDATA["Path Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>6</Value>
		</PenColor>
		<PenColor Name="gs_path_line_pen">
			<Description><![CDATA["Path Control Line Pen"]]></Description>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>7</Value>
		</PenColor>
		<String Name="stAnimationInfo">
			<Description><![CDATA[""]]></Description>
			<ArrayValues FirstDimension="7" SecondDimension="0">
				<AVal Row="1"><![CDATA[""]]></AVal>
				<AVal Row="2"><![CDATA[""]]></AVal>
				<AVal Row="3"><![CDATA[""]]></AVal>
				<AVal Row="4"><![CDATA[""]]></AVal>
				<AVal Row="5"><![CDATA[""]]></AVal>
				<AVal Row="6"><![CDATA[""]]></AVal>
				<AVal Row="7"><![CDATA[""]]></AVal>
			</ArrayValues>
		</String>
		<Boolean Name="test">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Boolean>
		<Length Name="testPos">
			<Description><![CDATA[""]]></Description>
			<Value>0</Value>
		</Length>
		<String Name="fontType">
			<Description><![CDATA[""]]></Description>
			<Value><![CDATA["Arial"]]></Value>
		</String>

		<!-- gs_list: PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK ===== PARAMETER BLOCK -->

		<Title Name="gs_list">
			<Description><![CDATA["Parameters for Listing"]]></Description>
			<Fix/>
		</Title>
		<RealNum Name="gs_list_cost">
			<Description><![CDATA["Cost"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value>0</Value>
		</RealNum>
		<String Name="gs_list_manufacturer">
			<Description><![CDATA["Manufacturer"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_note">
			<Description><![CDATA["Note/Remarks"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_location">
			<Description><![CDATA["Location"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_accessories">
			<Description><![CDATA["Accessories"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="FM_Type">
			<Description><![CDATA["Group Type"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA["Наружные Объекты"]]></Value>
		</String>
		<Integer Name="iFMType">
			<Description><![CDATA["Group Type"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
				<ParFlg_Hidden/>
			</Flags>
			<Value>19</Value>
		</Integer>
		<String Name="FM_InventoryNumber">
			<Description><![CDATA["Inventory Number"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="FM_ProductionYear">
			<Description><![CDATA["Production Year"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_custom1">
			<Description><![CDATA["User Defined 1"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_custom2">
			<Description><![CDATA["User Defined 2"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_custom3">
			<Description><![CDATA["User Defined 3"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_custom4">
			<Description><![CDATA["User Defined 4"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
		<String Name="gs_list_custom5">
			<Description><![CDATA["User Defined 5"]]></Description>
			<Fix/>
			<Flags>
				<ParFlg_Child/>
			</Flags>
			<Value><![CDATA[""]]></Value>
		</String>
	</Parameters>
</ParamSection>

<Copyright SectVersion="1" SectionFlags="0" SubIdent="0">
	<Author>GRAPHISOFT</Author>
	<License>
		<Type>CC BY-ND</Type>
		<Version>3.0</Version>
	</License>
</Copyright>

</Symbol>
